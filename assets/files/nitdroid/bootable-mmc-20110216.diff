diff --git a/arch/arm/configs/n810_defconfig b/arch/arm/configs/n810_defconfig
new file mode 100644
index 0000000..b7eb160
--- /dev/null
+++ b/arch/arm/configs/n810_defconfig
@@ -0,0 +1,1909 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.32.9
+# Thu Feb 17 02:07:35 2011
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=21
+# CONFIG_GROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_NET_NS is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=0
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_ASHMEM=y
+CONFIG_AIO=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+# CONFIG_LBDAF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+# CONFIG_IOSCHED_DEADLINE is not set
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_DAVINCI is not set
+CONFIG_ARCH_OMAP=y
+# CONFIG_ARCH_BCMRING is not set
+
+#
+# TI OMAP Implementations
+#
+CONFIG_ARCH_OMAP_OTG=y
+# CONFIG_ARCH_OMAP1 is not set
+CONFIG_ARCH_OMAP2=y
+# CONFIG_ARCH_OMAP3 is not set
+# CONFIG_ARCH_OMAP4 is not set
+
+#
+# OMAP Feature Selections
+#
+# CONFIG_OMAP_DEBUG_POWERDOMAIN is not set
+# CONFIG_OMAP_DEBUG_CLOCKDOMAIN is not set
+CONFIG_OMAP_RESET_CLOCKS=y
+CONFIG_OMAP_BOOT_TAG=y
+CONFIG_OMAP_BOOT_REASON=y
+CONFIG_OMAP_COMPONENT_VERSION=y
+CONFIG_OMAP_MUX=y
+# CONFIG_OMAP_MUX_DEBUG is not set
+CONFIG_OMAP_MUX_WARNINGS=y
+CONFIG_OMAP_MCBSP=y
+CONFIG_OMAP_MBOX_FWK=y
+# CONFIG_OMAP_MPU_TIMER is not set
+CONFIG_OMAP_32K_TIMER=y
+CONFIG_OMAP_32K_TIMER_HZ=128
+CONFIG_OMAP_DM_TIMER=y
+# CONFIG_OMAP_LL_DEBUG_UART1 is not set
+# CONFIG_OMAP_LL_DEBUG_UART2 is not set
+CONFIG_OMAP_LL_DEBUG_UART3=y
+# CONFIG_OMAP_LL_DEBUG_NONE is not set
+# CONFIG_OMAP_PM_NONE is not set
+CONFIG_OMAP_PM_NOOP=y
+# CONFIG_OMAP_PM_SRF is not set
+# CONFIG_MACH_OMAP_GENERIC is not set
+
+#
+# OMAP Core Type
+#
+CONFIG_ARCH_OMAP24XX=y
+CONFIG_ARCH_OMAP2420=y
+# CONFIG_ARCH_OMAP2430 is not set
+
+#
+# OMAP Board Type
+#
+CONFIG_MACH_OMAP2_TUSB6010=y
+# CONFIG_MACH_OMAP_H4 is not set
+# CONFIG_MACH_OMAP_APOLLON is not set
+# CONFIG_MACH_OMAP_2430SDP is not set
+# CONFIG_TIWLAN_SDIO is not set
+CONFIG_MACH_NOKIA_N800=y
+CONFIG_MACH_NOKIA_N810=y
+CONFIG_MACH_NOKIA_N810_WIMAX=y
+CONFIG_MACH_NOKIA_N8X0=y
+CONFIG_MACH_NOKIA_N8X0_LCD=y
+CONFIG_MACH_NOKIA_N8X0_USB=y
+# CONFIG_MACH_OMAP_ZOOM3 is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_V6=y
+# CONFIG_CPU_32v6K is not set
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_PABRT_V6=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_ARM_ERRATA_411920=y
+CONFIG_COMMON_CLKDEV=y
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_HZ=128
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_HAVE_MLOCK=y
+CONFIG_HAVE_MLOCKED_PAGE_BIT=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_LEDS=y
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x10C08000
+CONFIG_ZBOOT_ROM_BSS=0x10200000
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_CMDLINE="root=1f03 rootfstype=jffs2 console=tty0"
+# CONFIG_XIP_KERNEL is not set
+CONFIG_KEXEC=y
+CONFIG_ATAGS_PROC=y
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_FREQ is not set
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_APM_EMULATION is not set
+# CONFIG_PM_RUNTIME is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=m
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+# CONFIG_IPV6_ROUTE_INFO is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+CONFIG_IPV6_MIP6=m
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=m
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+CONFIG_ANDROID_PARANOID_NETWORK=y
+CONFIG_NET_ACTIVITY_STATS=y
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_BRIDGE_NETFILTER=y
+
+#
+# Core Netfilter Configuration
+#
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+# CONFIG_NF_CONNTRACK is not set
+CONFIG_NETFILTER_XTABLES=y
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_LED is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_HL is not set
+# CONFIG_NETFILTER_XT_MATCH_IPRANGE is not set
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+# CONFIG_NETFILTER_XT_MATCH_LIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_MAC is not set
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_PHYSDEV is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_TIME is not set
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV4 is not set
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_ADDRTYPE is not set
+# CONFIG_IP_NF_MATCH_AH is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+CONFIG_IP_NF_FILTER=y
+# CONFIG_IP_NF_TARGET_REJECT is not set
+# CONFIG_IP_NF_TARGET_LOG is not set
+# CONFIG_IP_NF_TARGET_ULOG is not set
+# CONFIG_IP_NF_MANGLE is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# IPv6: Netfilter Configuration
+#
+# CONFIG_IP6_NF_QUEUE is not set
+# CONFIG_IP6_NF_IPTABLES is not set
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+CONFIG_STP=m
+CONFIG_BRIDGE=m
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=m
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=m
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=m
+CONFIG_BT_L2CAP=m
+CONFIG_BT_SCO=m
+CONFIG_BT_RFCOMM=m
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=m
+# CONFIG_BT_BNEP_MC_FILTER is not set
+# CONFIG_BT_BNEP_PROTO_FILTER is not set
+CONFIG_BT_HIDP=m
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_BT_HCIBTSDIO is not set
+# CONFIG_BT_HCIUART is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+CONFIG_CFG80211=m
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+# CONFIG_CFG80211_DEFAULT_PS is not set
+CONFIG_CFG80211_DEFAULT_PS_VALUE=0
+# CONFIG_WIRELESS_OLD_REGULATORY is not set
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+CONFIG_MAC80211=m
+CONFIG_MAC80211_RC_MINSTREL=y
+# CONFIG_MAC80211_RC_DEFAULT_PID is not set
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel"
+CONFIG_MAC80211_MESH=y
+# CONFIG_MAC80211_LEDS is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_HAVE_MTD_OTP=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+CONFIG_MTD_BLOCK2MTD=y
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND_IDS is not set
+# CONFIG_MTD_NAND is not set
+CONFIG_MTD_ONENAND=y
+# CONFIG_MTD_ONENAND_VERIFY_WRITE is not set
+# CONFIG_MTD_ONENAND_GENERIC is not set
+CONFIG_MTD_ONENAND_OMAP2=y
+CONFIG_MTD_ONENAND_OTP=y
+# CONFIG_MTD_ONENAND_2X_PROGRAM is not set
+# CONFIG_MTD_ONENAND_SIM is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+CONFIG_MACVLAN=m
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=m
+# CONFIG_VETH is not set
+# CONFIG_NET_ETHERNET is not set
+CONFIG_NETDEV_1000=y
+CONFIG_NETDEV_10000=y
+CONFIG_WLAN=y
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+CONFIG_PPP=m
+# CONFIG_PPP_MULTILINK is not set
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_PPP_BSDCOMP=m
+CONFIG_PPP_MPPE=m
+# CONFIG_PPPOE is not set
+# CONFIG_PPPOL2TP is not set
+# CONFIG_PPPOLAC is not set
+# CONFIG_PPPOPNS is not set
+# CONFIG_SLIP is not set
+CONFIG_SLHC=m
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=800
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=480
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_KEYRESET is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+CONFIG_KEYBOARD_LM8323=y
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_OMAP is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+CONFIG_TOUCHSCREEN_TSC2005=y
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_QUANTUM_OBP is not set
+# CONFIG_INPUT_MISC is not set
+# CONFIG_INPUT_GPIO is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_CONSOLE is not set
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MAX3100 is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_OMAP=y
+CONFIG_SERIAL_OMAP_CONSOLE=y
+# CONFIG_SERIAL_OMAP_DMA_UART1 is not set
+# CONFIG_SERIAL_OMAP_DMA_UART2 is not set
+# CONFIG_SERIAL_OMAP_DMA_UART3 is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_OMAP=y
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_DCC_TTY is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_OMAP=y
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_PCA963X is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+CONFIG_SPI_OMAP24XX=y
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+CONFIG_DEBUG_GPIO=y
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+
+#
+# AC97 GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+CONFIG_HWMON=m
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7473 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+CONFIG_SENSORS_LM75=m
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_THERMAL is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_OMAP_WATCHDOG=y
+# CONFIG_OMAP_WATCHDOG_AUTOPET is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS65010 is not set
+CONFIG_MENELAUS=y
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13783 is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_CPCAP is not set
+# CONFIG_REGULATOR is not set
+CONFIG_MEDIA_SUPPORT=m
+
+#
+# Multimedia core support
+#
+CONFIG_VIDEO_DEV=m
+CONFIG_VIDEO_V4L2_COMMON=m
+CONFIG_VIDEO_ALLOW_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+# CONFIG_DVB_CORE is not set
+CONFIG_VIDEO_MEDIA=m
+
+#
+# Multimedia drivers
+#
+CONFIG_MEDIA_ATTACH=y
+CONFIG_MEDIA_TUNER=m
+# CONFIG_MEDIA_TUNER_CUSTOMISE is not set
+CONFIG_MEDIA_TUNER_SIMPLE=m
+CONFIG_MEDIA_TUNER_TDA8290=m
+CONFIG_MEDIA_TUNER_TDA9887=m
+CONFIG_MEDIA_TUNER_TEA5761=m
+CONFIG_MEDIA_TUNER_TEA5767=m
+CONFIG_MEDIA_TUNER_MT20XX=m
+CONFIG_MEDIA_TUNER_XC2028=m
+CONFIG_MEDIA_TUNER_XC5000=m
+CONFIG_MEDIA_TUNER_MC44S803=m
+CONFIG_VIDEO_V4L2=m
+CONFIG_VIDEO_V4L1=m
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+# CONFIG_VIDEO_HELPER_CHIPS_AUTO is not set
+# CONFIG_VIDEO_OMAP3_HP3A is not set
+
+#
+# Encoders/decoders and other helper chips
+#
+
+#
+# Audio decoders
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TDA9875 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_ADV7180 is not set
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+CONFIG_VIDEO_TCM825X=m
+# CONFIG_VIDEO_OMAP3_HPLENS is not set
+# CONFIG_VIDEO_MT9P012 is not set
+# CONFIG_VIDEO_IMX046 is not set
+# CONFIG_VIDEO_LV8093 is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_SAA7191 is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# MPEG video encoders
+#
+# CONFIG_VIDEO_CX2341X is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_SOC_CAMERA is not set
+# CONFIG_VIDEO_OLDOMAP34XX_ISP_PREVIEWER is not set
+# CONFIG_VIDEO_OLDOMAP34XX_ISP_RESIZER is not set
+# CONFIG_VIDEO_OMAP2 is not set
+# CONFIG_RADIO_ADAPTERS is not set
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_SGX is not set
+# CONFIG_SGX_RELEASE_LOGGING is not set
+# CONFIG_SGX_EDM_TRACING is not set
+# CONFIG_SGX_MK_TRACE is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_FB_OMAP=y
+CONFIG_FB_OMAP_LCDC_EXTERNAL=y
+# CONFIG_FB_OMAP_LCDC_HWA742 is not set
+CONFIG_FB_OMAP_LCDC_BLIZZARD=y
+# CONFIG_FB_OMAP_MANUAL_UPDATE is not set
+CONFIG_FB_OMAP_LCD_MIPID=y
+CONFIG_FB_OMAP_BOOTLOADER_INIT=y
+CONFIG_FB_OMAP_CONSISTENT_DMA_SIZE=2
+# CONFIG_OMAP2_DSS is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=m
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=m
+CONFIG_SND_TIMER=m
+CONFIG_SND_PCM=m
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=m
+CONFIG_SND_PCM_OSS=m
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_ARM=y
+CONFIG_SND_SPI=y
+CONFIG_SND_SOC=m
+CONFIG_SND_OMAP_SOC=m
+CONFIG_SND_OMAP_SOC_MCBSP=m
+CONFIG_SND_OMAP_SOC_N810=m
+CONFIG_SND_SOC_I2C_AND_SPI=m
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_TLV320AIC3X=m
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+# CONFIG_HID_PID is not set
+
+#
+# Special HID drivers
+#
+CONFIG_HID_APPLE=m
+CONFIG_HID_WACOM=m
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+# CONFIG_USB is not set
+CONFIG_USB_MUSB_HDRC=y
+CONFIG_USB_TUSB6010=y
+# CONFIG_USB_MUSB_HOST is not set
+CONFIG_USB_MUSB_PERIPHERAL=y
+# CONFIG_USB_MUSB_OTG is not set
+CONFIG_USB_GADGET_MUSB_HDRC=y
+# CONFIG_MUSB_PIO_ONLY is not set
+# CONFIG_USB_INVENTRA_DMA is not set
+# CONFIG_USB_TI_CPPI_DMA is not set
+CONFIG_USB_TUSB_OMAP_DMA=y
+CONFIG_USB_MUSB_DEBUG=y
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DEBUG=y
+CONFIG_USB_GADGET_DEBUG_FILES=y
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_R8A66597 is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LANGWELL is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+CONFIG_USB_ETH=y
+CONFIG_USB_ETH_RNDIS=y
+# CONFIG_USB_ETH_EEM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_ANDROID is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+
+#
+# OTG and related infrastructure
+#
+CONFIG_USB_OTG_UTILS=y
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_ISP1301_OMAP is not set
+CONFIG_NOP_USB_XCEIV=y
+# CONFIG_CPCAP_USB is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_EMBEDDED_SDIO is not set
+# CONFIG_MMC_PARANOID_SD_INIT is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+CONFIG_MMC_OMAP=y
+# CONFIG_MMC_AT91 is not set
+# CONFIG_MMC_ATMELMCI is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LM3554 is not set
+# CONFIG_LEDS_LM3530 is not set
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_SWITCH is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# TI VLYNQ
+#
+CONFIG_STAGING=y
+# CONFIG_STAGING_EXCLUDE_BUILD is not set
+# CONFIG_ECHO is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+# CONFIG_ANDROID_RAM_CONSOLE is not set
+CONFIG_ANDROID_TIMED_OUTPUT=y
+# CONFIG_ANDROID_TIMED_GPIO is not set
+# CONFIG_ANDROID_LOW_MEMORY_KILLER is not set
+
+#
+# Qualcomm MSM Camera And Video
+#
+
+#
+# Camera Sensor Selection
+#
+# CONFIG_DST is not set
+# CONFIG_POHMELFS is not set
+# CONFIG_PLAN9AUTH is not set
+
+#
+# RAR Register Driver
+#
+# CONFIG_RAR_REGISTER is not set
+CONFIG_IIO=y
+# CONFIG_IIO_RING_BUFFER is not set
+# CONFIG_IIO_TRIGGER is not set
+
+#
+# Accelerometers
+#
+# CONFIG_KXSD9 is not set
+# CONFIG_LIS3L02DQ is not set
+
+#
+# Analog to digital convertors
+#
+# CONFIG_MAX1363 is not set
+
+#
+# Light sensors
+#
+# CONFIG_TSL2561 is not set
+
+#
+# Triggers - standalone
+#
+
+#
+# CBUS support
+#
+CONFIG_CBUS=y
+CONFIG_CBUS_TAHVO=y
+CONFIG_CBUS_TAHVO_USER=y
+CONFIG_CBUS_RETU=y
+CONFIG_CBUS_RETU_USER=y
+CONFIG_CBUS_RETU_POWERBUTTON=y
+CONFIG_CBUS_RETU_RTC=y
+CONFIG_CBUS_RETU_WDT=y
+# CONFIG_CBUS_RETU_HEADSET is not set
+# CONFIG_MPU_BRIDGE is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=m
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+# CONFIG_EXT3_FS_SECURITY is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_JBD=m
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+CONFIG_FUSE_FS=m
+CONFIG_CUSE=m
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_YAFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+CONFIG_JFFS2_SUMMARY=y
+# CONFIG_JFFS2_FS_XATTR is not set
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_LZO=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_JFFS2_CMODE_NONE is not set
+CONFIG_JFFS2_CMODE_PRIORITY=y
+# CONFIG_JFFS2_CMODE_SIZE is not set
+# CONFIG_JFFS2_CMODE_FAVOURLZO is not set
+# CONFIG_CRAMFS is not set
+CONFIG_SQUASHFS=y
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+CONFIG_NLS_ISO8859_15=y
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC is not set
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=0
+CONFIG_DETECT_HUNG_TASK=y
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_PAGE_POISONING is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+# CONFIG_BOOT_TRACER is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_KMEMTRACE is not set
+# CONFIG_WORKQUEUE_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=m
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=m
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC32=y
+CONFIG_CRC7=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
diff --git a/arch/arm/include/asm/setup.h b/arch/arm/include/asm/setup.h
index 5ccce0a..3fba901 100644
--- a/arch/arm/include/asm/setup.h
+++ b/arch/arm/include/asm/setup.h
@@ -136,6 +136,13 @@ struct tag_acorn {
 	__u8 adfsdrives;
 };
 
+/* TI OMAP specific information */
+#define ATAG_BOARD       0x414f4d50
+
+struct tag_omap {
+	u8 data[0];
+};
+
 /* footbridge memory clock, see arch/arm/mach-footbridge/arch.c */
 #define ATAG_MEMCLK	0x41000402
 
@@ -162,6 +169,11 @@ struct tag {
 		struct tag_acorn	acorn;
 
 		/*
+		 * OMAP specific
+                 */
+                struct tag_omap         omap;
+
+		/*
 		 * DC21285 specific
 		 */
 		struct tag_memclk	memclk;
diff --git a/arch/arm/mach-omap2/Kconfig b/arch/arm/mach-omap2/Kconfig
index f5704ee..7267efd 100644
--- a/arch/arm/mach-omap2/Kconfig
+++ b/arch/arm/mach-omap2/Kconfig
@@ -117,6 +117,16 @@ config MACH_NOKIA_N8X0
 	select MACH_NOKIA_N810
 	select MACH_NOKIA_N810_WIMAX
 
+config MACH_NOKIA_N8X0_LCD
+	bool
+	depends on MACH_NOKIA_N8X0 && FB_OMAP_LCDC_BLIZZARD && FB_OMAP_LCD_MIPID
+	default y
+
+config MACH_NOKIA_N8X0_USB
+	bool
+	depends on MACH_NOKIA_N8X0 && MACH_OMAP2_TUSB6010
+	default y
+
 config MACH_NOKIA_RX51
 	bool "Nokia RX-51 board"
 	depends on ARCH_OMAP3 && ARCH_OMAP34XX
diff --git a/arch/arm/mach-omap2/Makefile b/arch/arm/mach-omap2/Makefile
index a435cd0..84c34ed 100644
--- a/arch/arm/mach-omap2/Makefile
+++ b/arch/arm/mach-omap2/Makefile
@@ -79,7 +79,10 @@ obj-$(CONFIG_MACH_OMAP3_PANDORA)	+= board-omap3pandora.o \
 					   mmc-twl4030.o
 obj-$(CONFIG_MACH_OMAP_3430SDP)		+= board-3430sdp.o \
 					   mmc-twl4030.o
-obj-$(CONFIG_MACH_NOKIA_N8X0)		+= board-n8x0.o
+obj-$(CONFIG_MACH_NOKIA_N8X0)		+= board-n8x0.o \
+					   board-n8x0-mmc.o
+obj-$(CONFIG_MACH_NOKIA_N8X0_LCD)	+= board-n8x0-lcd.o
+obj-$(CONFIG_MACH_NOKIA_N8X0_USB)	+= board-n8x0-usb.o
 obj-$(CONFIG_MACH_OMAP_ZOOM2)		+= board-zoom2.o \
 					   mmc-twl4030.o \
 					   board-ldp-flash.o \
diff --git a/arch/arm/mach-omap2/board-n8x0-lcd.c b/arch/arm/mach-omap2/board-n8x0-lcd.c
new file mode 100644
index 0000000..2fc5bcd
--- /dev/null
+++ b/arch/arm/mach-omap2/board-n8x0-lcd.c
@@ -0,0 +1,127 @@
+/*
+ * linux/arch/arm/mach-omap2/board-n8x0.c
+ *
+ * Copyright (C) 2005-2009 Nokia Corporation
+ * Author: Juha Yrjola <juha.yrjola@nokia.com>
+ *
+ * Modified from mach-omap2/board-generic.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/omapfb.h>
+
+#include <plat/lcd_mipid.h>
+#include <plat/blizzard.h>
+
+#include <../drivers/cbus/tahvo.h>
+
+#define N8X0_BLIZZARD_POWERDOWN_GPIO	15
+
+// MIPID LCD Panel
+
+static void mipid_shutdown(struct mipid_platform_data *pdata)
+{
+	if (pdata->nreset_gpio != -1) {
+		pr_info("shutdown LCD\n");
+		gpio_set_value(pdata->nreset_gpio, 0);
+		msleep(120);
+	}
+}
+
+struct mipid_platform_data n8x0_mipid_platform_data = {
+	.shutdown = mipid_shutdown,
+};
+
+void __init n8x0_mipid_init(void)
+{
+	const struct omap_lcd_config *conf;
+
+	conf = omap_get_config(OMAP_TAG_LCD, struct omap_lcd_config);
+	if (conf != NULL) {
+		n8x0_mipid_platform_data.nreset_gpio = conf->nreset_gpio;
+		n8x0_mipid_platform_data.data_lines = conf->data_lines;
+		printk(KERN_INFO "N8x0 MIPID config loaded");
+	}
+	else
+		printk(KERN_INFO "N8x0 MIPID config not provided");
+}
+
+
+// Epson Blizzard LCD Controller
+
+static struct {
+	struct clk *sys_ck;
+} blizzard;
+
+static int blizzard_get_clocks(void)
+{
+	blizzard.sys_ck = clk_get(0, "osc_ck");
+	if (IS_ERR(blizzard.sys_ck)) {
+		printk(KERN_ERR "can't get Blizzard clock\n");
+		return PTR_ERR(blizzard.sys_ck);
+	}
+	return 0;
+}
+
+static unsigned long blizzard_get_clock_rate(struct device *dev)
+{
+	return clk_get_rate(blizzard.sys_ck);
+}
+
+static void blizzard_enable_clocks(int enable)
+{
+	if (enable)
+		clk_enable(blizzard.sys_ck);
+	else
+		clk_disable(blizzard.sys_ck);
+}
+
+static void blizzard_power_up(struct device *dev)
+{
+	/* Vcore to 1.475V */
+	tahvo_set_clear_reg_bits(0x07, 0, 0xf);
+	msleep(10);
+
+	blizzard_enable_clocks(1);
+	gpio_set_value(N8X0_BLIZZARD_POWERDOWN_GPIO, 1);
+}
+
+static void blizzard_power_down(struct device *dev)
+{
+	gpio_set_value(N8X0_BLIZZARD_POWERDOWN_GPIO, 0);
+	blizzard_enable_clocks(0);
+
+	/* Vcore to 1.005V */
+	tahvo_set_clear_reg_bits(0x07, 0xf, 0);
+}
+
+static struct blizzard_platform_data n8x0_blizzard_data = {
+	.power_up	= blizzard_power_up,
+	.power_down	= blizzard_power_down,
+	.get_clock_rate	= blizzard_get_clock_rate,
+	.te_connected	= 1,
+};
+
+void __init n8x0_blizzard_init(void)
+{
+	int r;
+
+	r = gpio_request(N8X0_BLIZZARD_POWERDOWN_GPIO, "Blizzard pd");
+	if (r < 0)
+	{
+		printk(KERN_ERR "Can't get N8x0 Blizzard powerdown GPIO %d\n", N8X0_BLIZZARD_POWERDOWN_GPIO);
+		return;
+	}
+	gpio_direction_output(N8X0_BLIZZARD_POWERDOWN_GPIO, 1);
+
+	blizzard_get_clocks();
+	omapfb_set_ctrl_platform_data(&n8x0_blizzard_data);
+
+	printk(KERN_INFO "N8x0 Blizzard initialized");
+}
diff --git a/arch/arm/mach-omap2/board-n8x0-mmc.c b/arch/arm/mach-omap2/board-n8x0-mmc.c
new file mode 100644
index 0000000..954eecb
--- /dev/null
+++ b/arch/arm/mach-omap2/board-n8x0-mmc.c
@@ -0,0 +1,361 @@
+/*
+ * linux/arch/arm/mach-omap2/board-n8x0-mmc.c
+ *
+ * Copyright (C) 2006 Nokia Corporation
+ * Author: Juha Yrjola
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+
+#include <asm/mach-types.h>
+
+#include <plat/menelaus.h>
+#include <plat/mmc.h>
+
+#if defined(CONFIG_MMC_OMAP) || defined(CONFIG_MMC_OMAP_MODULE)
+
+static const int slot_switch_gpio = 96;
+
+static const int n810_slot2_pw_vddf = 23;
+static const int n810_slot2_pw_vdd = 9;
+
+static int slot1_cover_open;
+static int slot2_cover_open;
+static struct device *mmc_device;
+
+/*
+ * VMMC   --> slot 1 (N800 & N810)
+ * VDCDC3_APE, VMCS2_APE --> slot 2 on N800
+ * GPIO96 --> Menelaus GPIO2
+ * GPIO23 --> controls slot2 VSD    (N810 only)
+ * GPIO9  --> controls slot2 VIO_SD (N810 only)
+ */
+
+static int n8x0_mmc_switch_slot(struct device *dev, int slot)
+{
+#ifdef CONFIG_MMC_DEBUG
+	dev_dbg(dev, "Choose slot %d\n", slot + 1);
+#endif
+	gpio_set_value(slot_switch_gpio, slot);
+	return 0;
+}
+
+static int n8x0_mmc_set_power_menelaus(struct device *dev, int slot,
+					int power_on, int vdd)
+{
+	int mV;
+
+#ifdef CONFIG_MMC_DEBUG
+	dev_dbg(dev, "Set slot %d power: %s (vdd %d)\n", slot + 1,
+		power_on ? "on" : "off", vdd);
+#endif
+	if (slot == 0) {
+		if (!power_on)
+			return menelaus_set_vmmc(0);
+		switch (1 << vdd) {
+		case MMC_VDD_33_34:
+		case MMC_VDD_32_33:
+		case MMC_VDD_31_32:
+			mV = 3100;
+			break;
+		case MMC_VDD_30_31:
+			mV = 3000;
+			break;
+		case MMC_VDD_28_29:
+			mV = 2800;
+			break;
+		case MMC_VDD_165_195:
+			mV = 1850;
+			break;
+		default:
+			BUG();
+		}
+		return menelaus_set_vmmc(mV);
+	} else {
+		if (!power_on)
+			return menelaus_set_vdcdc(3, 0);
+		switch (1 << vdd) {
+		case MMC_VDD_33_34:
+		case MMC_VDD_32_33:
+			mV = 3300;
+			break;
+		case MMC_VDD_30_31:
+		case MMC_VDD_29_30:
+			mV = 3000;
+			break;
+		case MMC_VDD_28_29:
+		case MMC_VDD_27_28:
+			mV = 2800;
+			break;
+		case MMC_VDD_24_25:
+		case MMC_VDD_23_24:
+			mV = 2400;
+			break;
+		case MMC_VDD_22_23:
+		case MMC_VDD_21_22:
+			mV = 2200;
+			break;
+		case MMC_VDD_20_21:
+			mV = 2000;
+			break;
+		case MMC_VDD_165_195:
+			mV = 1800;
+			break;
+		default:
+			BUG();
+		}
+		return menelaus_set_vdcdc(3, mV);
+	}
+	return 0;
+}
+
+static void nokia_mmc_set_power_internal(struct device *dev,
+					 int power_on)
+{
+	dev_dbg(dev, "Set internal slot power %s\n",
+		power_on ? "on" : "off");
+
+	if (power_on) {
+		gpio_set_value(n810_slot2_pw_vddf, 1);
+		udelay(30);
+		gpio_set_value(n810_slot2_pw_vdd, 1);
+		udelay(100);
+	} else {
+		gpio_set_value(n810_slot2_pw_vdd, 0);
+		msleep(50);
+		gpio_set_value(n810_slot2_pw_vddf, 0);
+		msleep(50);
+	}
+}
+
+static int n8x0_mmc_set_power(struct device *dev, int slot, int power_on,
+			      int vdd)
+{
+	if (machine_is_nokia_n800() || slot == 0)
+		return n8x0_mmc_set_power_menelaus(dev, slot, power_on, vdd);
+
+	nokia_mmc_set_power_internal(dev, power_on);
+
+	return 0;
+}
+
+static int n8x0_mmc_set_bus_mode(struct device *dev, int slot, int bus_mode)
+{
+	int r;
+
+	dev_dbg(dev, "Set slot %d bus mode %s\n", slot + 1,
+		bus_mode == MMC_BUSMODE_OPENDRAIN ? "open-drain" : "push-pull");
+	BUG_ON(slot != 0 && slot != 1);
+	slot++;
+	switch (bus_mode) {
+	case MMC_BUSMODE_OPENDRAIN:
+		r = menelaus_set_mmc_opendrain(slot, 1);
+		break;
+	case MMC_BUSMODE_PUSHPULL:
+		r = menelaus_set_mmc_opendrain(slot, 0);
+		break;
+	default:
+		BUG();
+	}
+	if (r != 0 && printk_ratelimit())
+		dev_err(dev, "MMC: unable to set bus mode for slot %d\n",
+			slot);
+	return r;
+}
+
+static int n8x0_mmc_get_cover_state(struct device *dev, int slot)
+{
+	slot++;
+	BUG_ON(slot != 1 && slot != 2);
+	if (slot == 1)
+		return slot1_cover_open;
+	else
+		return slot2_cover_open;
+}
+
+static void n8x0_mmc_callback(void *data, u8 card_mask)
+{
+	int bit, *openp, index;
+
+	if (machine_is_nokia_n800()) {
+		bit = 1 << 1;
+		openp = &slot2_cover_open;
+		index = 1;
+	} else {
+		bit = 1;
+		openp = &slot1_cover_open;
+		index = 0;
+	}
+
+	if (card_mask & bit)
+		*openp = 1;
+	else
+		*openp = 0;
+
+	omap_mmc_notify_cover_event(mmc_device, index, *openp);
+}
+
+static int n8x0_mmc_late_init(struct device *dev)
+{
+	int r, bit, *openp;
+	int vs2sel;
+
+	mmc_device = dev;
+
+	r = menelaus_set_slot_sel(1);
+	if (r < 0)
+		return r;
+
+	if (machine_is_nokia_n800())
+		vs2sel = 0;
+	else
+		vs2sel = 2;
+
+	r = menelaus_set_mmc_slot(2, 0, vs2sel, 1);
+	if (r < 0)
+		return r;
+
+	n8x0_mmc_set_power(dev, 0, MMC_POWER_ON, 16); /* MMC_VDD_28_29 */
+	n8x0_mmc_set_power(dev, 1, MMC_POWER_ON, 16);
+
+	r = menelaus_set_mmc_slot(1, 1, 0, 1);
+	if (r < 0)
+		return r;
+	r = menelaus_set_mmc_slot(2, 1, vs2sel, 1);
+	if (r < 0)
+		return r;
+
+	r = menelaus_get_slot_pin_states();
+	if (r < 0)
+		return r;
+
+	if (machine_is_nokia_n800()) {
+		bit = 1 << 1;
+		openp = &slot2_cover_open;
+	} else {
+		bit = 1;
+		openp = &slot1_cover_open;
+		slot2_cover_open = 0;
+	}
+
+	/* All slot pin bits seem to be inversed until first swith change */
+	if (r == 0xf || r == (0xf & ~bit))
+		r = ~r;
+
+	if (r & bit)
+		*openp = 1;
+	else
+		*openp = 0;
+
+	r = menelaus_register_mmc_callback(n8x0_mmc_callback, NULL);
+
+	return r;
+}
+
+static void n8x0_mmc_shutdown(struct device *dev)
+{
+	int vs2sel;
+
+	if (machine_is_nokia_n800())
+		vs2sel = 0;
+	else
+		vs2sel = 2;
+
+	menelaus_set_mmc_slot(1, 0, 0, 0);
+	menelaus_set_mmc_slot(2, 0, vs2sel, 0);
+}
+
+static void n8x0_mmc_cleanup(struct device *dev)
+{
+	menelaus_unregister_mmc_callback();
+
+	gpio_free(slot_switch_gpio);
+
+	if (machine_is_nokia_n810()) {
+		gpio_free(n810_slot2_pw_vddf);
+		gpio_free(n810_slot2_pw_vdd);
+	}
+}
+
+/*
+ * MMC controller1 has two slots that are multiplexed via I2C.
+ * MMC controller2 is not in use.
+ */
+static struct omap_mmc_platform_data mmc1_data = {
+	.nr_slots		= 2,
+	.switch_slot		= n8x0_mmc_switch_slot,
+	.init			= n8x0_mmc_late_init,
+	.cleanup		= n8x0_mmc_cleanup,
+	.shutdown		= n8x0_mmc_shutdown,
+	.max_freq               = 24000000,
+	.dma_mask		= 0xffffffff,
+	.slots[0] = {
+		.wires		= 4,
+		.set_power	= n8x0_mmc_set_power,
+		.set_bus_mode	= n8x0_mmc_set_bus_mode,
+		.get_cover_state= n8x0_mmc_get_cover_state,
+		.ocr_mask	= MMC_VDD_165_195 | MMC_VDD_30_31 |
+				  MMC_VDD_32_33   | MMC_VDD_33_34,
+		.name		= "internal",
+	},
+	.slots[1] = {
+		.set_power	= n8x0_mmc_set_power,
+		.set_bus_mode	= n8x0_mmc_set_bus_mode,
+		.get_cover_state= n8x0_mmc_get_cover_state,
+		.ocr_mask	= MMC_VDD_165_195 | MMC_VDD_20_21 |
+				  MMC_VDD_21_22 | MMC_VDD_22_23 | MMC_VDD_23_24 |
+				  MMC_VDD_24_25 | MMC_VDD_27_28 | MMC_VDD_28_29 |
+				  MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_32_33 |
+				  MMC_VDD_33_34,
+		.name		= "external",
+	},
+};
+
+static struct omap_mmc_platform_data *mmc_data[OMAP24XX_NR_MMC];
+
+void __init n8x0_mmc_init(void)
+
+{
+	if (machine_is_nokia_n810()) {
+		mmc1_data.slots[0].name = "external";
+
+		/*
+		 * Some Samsung Movinand chips do not like open-ended
+		 * multi-block reads and fall to braind-dead state
+		 * while doing so. Reducing the number of blocks in
+		 * the transfer or delays in clock disable do not help
+		 */
+		mmc1_data.slots[1].name = "internal";
+		mmc1_data.slots[1].ban_openended = 1;
+	}
+
+	if (gpio_request(slot_switch_gpio, "MMC slot switch") < 0)
+		BUG();
+	gpio_direction_output(slot_switch_gpio, 0);
+
+	if (machine_is_nokia_n810()) {
+		if (gpio_request(n810_slot2_pw_vddf, "MMC slot 2 Vddf") < 0)
+			BUG();
+		gpio_direction_output(n810_slot2_pw_vddf, 0);
+
+		if (gpio_request(n810_slot2_pw_vdd, "MMC slot 2 Vdd") < 0)
+			BUG();
+		gpio_direction_output(n810_slot2_pw_vdd, 0);
+	}
+
+	mmc_data[0] = &mmc1_data;
+	omap2_init_mmc(mmc_data, OMAP24XX_NR_MMC);
+}
+#else
+
+void __init n8x0_mmc_init(void)
+{
+}
+
+#endif
diff --git a/arch/arm/mach-omap2/board-n8x0-usb.c b/arch/arm/mach-omap2/board-n8x0-usb.c
new file mode 100644
index 0000000..44921b8
--- /dev/null
+++ b/arch/arm/mach-omap2/board-n8x0-usb.c
@@ -0,0 +1,175 @@
+/*
+ * linux/arch/arm/mach-omap2/board-n8x0-usb.c
+ *
+ * Copyright (C) 2006 Nokia Corporation
+ * Author: Juha Yrjola
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/usb/musb.h>
+
+#include <plat/gpmc.h>
+
+#define TUSB_ASYNC_CS		1
+#define TUSB_SYNC_CS		4
+#define GPIO_TUSB_INT		58
+#define GPIO_TUSB_ENABLE	0
+
+static int tusb_set_power(int state);
+static int tusb_set_clock(struct clk *osc_ck, int state);
+
+#if	defined(CONFIG_USB_MUSB_OTG)
+#	define BOARD_MODE	MUSB_OTG
+#elif	defined(CONFIG_USB_MUSB_PERIPHERAL)
+#	define BOARD_MODE	MUSB_PERIPHERAL
+#else	/* defined(CONFIG_USB_MUSB_HOST) */
+#	define BOARD_MODE	MUSB_HOST
+#endif
+
+static struct musb_hdrc_eps_bits musb_eps[] = {
+	{	"ep1_tx", 5,	},
+	{	"ep1_rx", 5,	},
+	{	"ep2_tx", 5,	},
+	{	"ep2_rx", 5,	},
+	{	"ep3_tx", 3,	},
+	{	"ep3_rx", 3,	},
+	{	"ep4_tx", 3,	},
+	{	"ep4_rx", 3,	},
+	{	"ep5_tx", 2,	},
+	{	"ep5_rx", 2,	},
+	{	"ep6_tx", 2,	},
+	{	"ep6_rx", 2,	},
+	{	"ep7_tx", 2,	},
+	{	"ep7_rx", 2,	},
+	{	"ep8_tx", 2,	},
+	{	"ep8_rx", 2,	},
+	{	"ep9_tx", 2,	},
+	{	"ep9_rx", 2,	},
+	{	"ep10_tx", 2,	},
+	{	"ep10_rx", 2,	},
+	{	"ep11_tx", 2,	},
+	{	"ep11_rx", 2,	},
+	{	"ep12_tx", 2,	},
+	{	"ep12_rx", 2,	},
+	{	"ep13_tx", 2,	},
+	{	"ep13_rx", 2,	},
+	{	"ep14_tx", 2,	},
+	{	"ep14_rx", 2,	},
+	{	"ep15_tx", 2,	},
+	{	"ep15_rx", 2,	},
+};
+
+static struct musb_hdrc_config musb_config = {
+	.multipoint	= 1,
+	.dyn_fifo	= 1,
+	.soft_con	= 1,
+	.dma		= 1,
+	.num_eps	= 16,
+	.dma_channels	= 7,
+	.ram_bits	= 12,
+	.eps_bits	= musb_eps,
+};
+
+static struct musb_hdrc_platform_data tusb_data = {
+	.mode		= BOARD_MODE,
+	.set_power	= tusb_set_power,
+	.set_clock	= tusb_set_clock,
+	.min_power	= 25,	/* x2 = 50 mA drawn from VBUS as peripheral */
+	.power		= 100,	/* Max 100 mA VBUS for host mode */
+	.clock		= "osc_ck",
+	.config		= &musb_config,
+};
+
+/*
+ * Enable or disable power to TUSB6010. When enabling, turn on 3.3 V and
+ * 1.5 V voltage regulators of PM companion chip. Companion chip will then
+ * provide then PGOOD signal to TUSB6010 which will release it from reset.
+ */
+static int tusb_set_power(int state)
+{
+	int i, retval = 0;
+
+	if (state) {
+		gpio_set_value(GPIO_TUSB_ENABLE, 1);
+		msleep(1);
+
+		/* Wait until TUSB6010 pulls INT pin down */
+		i = 100;
+		while (i && gpio_get_value(GPIO_TUSB_INT)) {
+			msleep(1);
+			i--;
+		}
+
+		if (!i) {
+			printk(KERN_ERR "tusb: powerup failed\n");
+			retval = -ENODEV;
+		}
+	} else {
+		gpio_set_value(GPIO_TUSB_ENABLE, 0);
+		msleep(10);
+	}
+
+	return retval;
+}
+
+static int		osc_ck_on;
+
+static int tusb_set_clock(struct clk *osc_ck, int state)
+{
+	if (state) {
+		if (osc_ck_on > 0)
+			return -ENODEV;
+
+		//omap2_block_sleep();
+		clk_enable(osc_ck);
+		osc_ck_on = 1;
+	} else {
+		if (osc_ck_on == 0)
+			return -ENODEV;
+
+		clk_disable(osc_ck);
+		osc_ck_on = 0;
+		//omap2_allow_sleep();
+	}
+
+	return 0;
+}
+
+void __init n8x0_usb_init(void)
+{
+	int ret = 0;
+	static char	announce[] __initdata = KERN_INFO "TUSB 6010\n";
+
+	/* PM companion chip power control pin */
+	ret = gpio_request(GPIO_TUSB_ENABLE, "TUSB6010 enable");
+	if (ret != 0) {
+		printk(KERN_ERR "Could not get TUSB power GPIO%i\n",
+		       GPIO_TUSB_ENABLE);
+		return;
+	}
+	gpio_direction_output(GPIO_TUSB_ENABLE, 0);
+
+	tusb_set_power(0);
+
+	ret = tusb6010_setup_interface(&tusb_data, TUSB6010_REFCLK_19, 2,
+					TUSB_ASYNC_CS, TUSB_SYNC_CS,
+					GPIO_TUSB_INT, 0x3f);
+	if (ret != 0)
+		goto err;
+
+	printk(announce);
+
+	return;
+
+err:
+	gpio_free(GPIO_TUSB_ENABLE);
+}
diff --git a/arch/arm/mach-omap2/board-n8x0.c b/arch/arm/mach-omap2/board-n8x0.c
index 764ab1e..3274764 100644
--- a/arch/arm/mach-omap2/board-n8x0.c
+++ b/arch/arm/mach-omap2/board-n8x0.c
@@ -17,8 +17,15 @@
 #include <linux/init.h>
 #include <linux/io.h>
 #include <linux/stddef.h>
+#include <linux/platform_device.h>
 #include <linux/spi/spi.h>
+#include <linux/spi/tsc2005.h>
+#include <linux/input.h>
 #include <linux/usb/musb.h>
+#ifdef CONFIG_MENELAUS
+#include <linux/i2c.h>
+#endif
+#include <linux/i2c/lm8323.h>
 
 #include <asm/mach/arch.h>
 #include <asm/mach-types.h>
@@ -27,15 +34,156 @@
 #include <plat/common.h>
 #include <mach/irqs.h>
 #include <plat/mcspi.h>
+#ifdef CONFIG_MENELAUS
+#include <plat/menelaus.h>
+#endif
 #include <plat/onenand.h>
 #include <plat/serial.h>
+#include <plat/cbus.h>
+
+#define	RX51_TSC2005_RESET_GPIO	94
+#define	RX51_TSC2005_IRQ_GPIO	106
+#define OMAP_TAG_NOKIA_BT	0x4e01
+
+static s16 rx44_keymap[LM8323_KEYMAP_SIZE] = {
+	[0x01] = KEY_Q,
+	[0x02] = KEY_K,
+	[0x03] = KEY_O,
+	[0x04] = KEY_P,
+	[0x05] = KEY_BACKSPACE,
+	[0x06] = KEY_A,
+	[0x07] = KEY_S,
+	[0x08] = KEY_D,
+	[0x09] = KEY_F,
+	[0x0a] = KEY_G,
+	[0x0b] = KEY_H,
+	[0x0c] = KEY_J,
+
+	[0x11] = KEY_W,
+	[0x12] = KEY_F4,
+	[0x13] = KEY_L,
+	[0x14] = KEY_APOSTROPHE,
+	[0x16] = KEY_Z,
+	[0x17] = KEY_X,
+	[0x18] = KEY_C,
+	[0x19] = KEY_V,
+	[0x1a] = KEY_B,
+	[0x1b] = KEY_N,
+	[0x1c] = KEY_LEFTSHIFT, /* Actually, this is both shift keys */
+	[0x1f] = KEY_F7,
+
+	[0x21] = KEY_E,
+	[0x22] = KEY_SEMICOLON,
+	[0x23] = KEY_MINUS,
+	[0x24] = KEY_EQUAL,
+	[0x2b] = KEY_FN,
+	[0x2c] = KEY_M,
+	[0x2f] = KEY_F8,
+
+	[0x31] = KEY_R,
+	[0x32] = KEY_RIGHTCTRL,
+	[0x34] = KEY_SPACE,
+	[0x35] = KEY_COMMA,
+	[0x37] = KEY_UP,
+	[0x3c] = KEY_COMPOSE,
+	[0x3f] = KEY_F6,
+
+	[0x41] = KEY_T,
+	[0x44] = KEY_DOT,
+	[0x46] = KEY_RIGHT,
+	[0x4f] = KEY_F5,
+	[0x51] = KEY_Y,
+	[0x53] = KEY_DOWN,
+	[0x55] = KEY_ENTER,
+	[0x5f] = KEY_ESC,
+
+	[0x61] = KEY_U,
+	[0x64] = KEY_LEFT,
+
+	[0x71] = KEY_I,
+	[0x75] = KEY_KPENTER,
+};
+
+static struct lm8323_platform_data lm8323_pdata = {
+	.repeat		= 0, /* Repeat is handled in userspace for now. */
+	.keymap		= rx44_keymap,
+	.size_x		= 8,
+	.size_y		= 12,
+	.debounce_time	= 12,
+	.active_time	= 500,
+
+	.name		= "Internal keyboard",
+	.pwm_names[0] 	= "n810::keyboard",
+	.pwm_names[1] 	= "n810::cover",
+	//.pwm1_name	= "n810::keyboard",
+	//.pwm2_name	= "n810::cover",
+};
+
+struct omap_bluetooth_config {
+	u8    chip_type;
+	u8    bt_wakeup_gpio;
+	u8    host_wakeup_gpio;
+	u8    reset_gpio;
+	u8    bt_uart;
+	u8    bd_addr[6];
+	u8    bt_sysclk;
+};
+
+static struct platform_device n8x0_bt_device = {
+	.name           = "hci_h4p",
+	.id             = -1,
+	.num_resources  = 0,
+};
+
+void __init n8x0_bt_init(void)
+{
+	const struct omap_bluetooth_config *bt_config;
+
+	bt_config = (void *) omap_get_config(OMAP_TAG_NOKIA_BT,
+					     struct omap_bluetooth_config);
+	n8x0_bt_device.dev.platform_data = (void *) bt_config;
+	if (platform_device_register(&n8x0_bt_device) < 0)
+		BUG();
+}
+
+static struct omap2_mcspi_device_config mipid_mcspi_config = {
+	.turbo_mode	= 0,
+	.single_channel	= 1,
+};
 
 static struct omap2_mcspi_device_config p54spi_mcspi_config = {
 	.turbo_mode	= 0,
 	.single_channel = 1,
 };
 
+#ifdef CONFIG_MACH_NOKIA_N8X0_LCD
+extern struct mipid_platform_data n8x0_mipid_platform_data;
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_TSC2005
+static struct tsc2005_platform_data tsc2005_config;
+static void rx51_tsc2005_set_reset(bool enable)
+{
+	gpio_set_value(RX51_TSC2005_RESET_GPIO, enable);
+}
+
+static struct omap2_mcspi_device_config tsc2005_mcspi_config = {
+	.turbo_mode	= 0,
+	.single_channel = 1,
+};
+#endif
+
 static struct spi_board_info n800_spi_board_info[] __initdata = {
+#ifdef CONFIG_MACH_NOKIA_N8X0_LCD
+	{
+		.modalias	= "lcd_mipid",
+		.bus_num	= 1,
+		.chip_select	= 1,
+		.max_speed_hz	= 4000000,
+		.controller_data= &mipid_mcspi_config,
+		.platform_data	= &n8x0_mipid_platform_data,
+	},
+#endif
 	{
 		.modalias	= "p54spi",
 		.bus_num	= 2,
@@ -43,6 +191,127 @@ static struct spi_board_info n800_spi_board_info[] __initdata = {
 		.max_speed_hz   = 48000000,
 		.controller_data = &p54spi_mcspi_config,
 	},
+	{
+		.modalias	 = "tsc2005",
+		.bus_num	 = 1,
+		.chip_select	 = 0,
+		.irq		 = OMAP_GPIO_IRQ(RX51_TSC2005_IRQ_GPIO),
+		.max_speed_hz    = 6000000,
+		.controller_data = &tsc2005_mcspi_config,
+		.platform_data   = &tsc2005_config,
+	},
+};
+
+static void __init tsc2005_set_config(void)
+{
+	const struct omap_lcd_config *conf;
+
+	conf = omap_get_config(OMAP_TAG_LCD, struct omap_lcd_config);
+	if (conf != NULL) {
+#ifdef CONFIG_TOUCHSCREEN_TSC2005
+		if (strcmp(conf->panel_name, "lph8923") == 0) {
+			tsc2005_config.ts_x_plate_ohm = 180;
+			tsc2005_config.ts_hw_avg = 0;
+			tsc2005_config.ts_ignore_last = 0;
+			tsc2005_config.ts_touch_pressure = 1500;
+			tsc2005_config.ts_stab_time = 100;
+			tsc2005_config.ts_pressure_max = 2048;
+			tsc2005_config.ts_pressure_fudge = 2;
+			tsc2005_config.ts_x_max = 4096;
+			tsc2005_config.ts_x_fudge = 4;
+			tsc2005_config.ts_y_max = 4096;
+			tsc2005_config.ts_y_fudge = 7;
+			tsc2005_config.set_reset = rx51_tsc2005_set_reset;
+		} else if (strcmp(conf->panel_name, "ls041y3") == 0) {
+			tsc2005_config.ts_x_plate_ohm = 280;
+			tsc2005_config.ts_hw_avg = 0;
+			tsc2005_config.ts_ignore_last = 0;
+			tsc2005_config.ts_touch_pressure = 1500;
+			tsc2005_config.ts_stab_time = 1000;
+			tsc2005_config.ts_pressure_max = 2048;
+			tsc2005_config.ts_pressure_fudge = 2;
+			tsc2005_config.ts_x_max = 4096;
+			tsc2005_config.ts_x_fudge = 4;
+			tsc2005_config.ts_y_max = 4096;
+			tsc2005_config.ts_y_fudge = 7;
+			tsc2005_config.set_reset = rx51_tsc2005_set_reset;
+		} else {
+			printk(KERN_ERR "Unknown panel type, set default "
+			       "touchscreen configuration\n");
+			tsc2005_config.ts_x_plate_ohm = 200;
+			tsc2005_config.ts_stab_time = 100;
+		}
+#endif
+	}
+}
+
+#ifdef CONFIG_MENELAUS
+static int n8x0_auto_sleep_regulators(void)
+{
+	u32 val;
+	int ret;
+
+	val = EN_VPLL_SLEEP | EN_VMMC_SLEEP    \
+		| EN_VAUX_SLEEP | EN_VIO_SLEEP \
+		| EN_VMEM_SLEEP | EN_DC3_SLEEP \
+		| EN_VC_SLEEP | EN_DC2_SLEEP;
+
+	ret = menelaus_set_regulator_sleep(1, val);
+	if (ret < 0) {
+		printk(KERN_ERR "Could not set regulators to sleep on "
+			"menelaus: %u\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int n8x0_auto_voltage_scale(void)
+{
+	int ret;
+
+	ret = menelaus_set_vcore_hw(1400, 1050);
+	if (ret < 0) {
+		printk(KERN_ERR "Could not set VCORE voltage on "
+			"menelaus: %u\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int n8x0_menelaus_init(struct device *dev)
+{
+	int ret;
+
+	ret = n8x0_auto_voltage_scale();
+	if (ret < 0)
+		return ret;
+	ret = n8x0_auto_sleep_regulators();
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+static struct menelaus_platform_data n8x0_menelaus_platform_data = {
+	.late_init = n8x0_menelaus_init,
+};
+
+static struct i2c_board_info __initdata n8x0_i2c_board_info_menelaus[] = {
+	{
+		I2C_BOARD_INFO("menelaus", 0x72),
+		.irq = INT_24XX_SYS_NIRQ,
+		.platform_data = &n8x0_menelaus_platform_data,
+	},
+};
+#endif
+
+static struct i2c_board_info __initdata_or_module n8x0_i2c_board_info_2[] = {};
+
+static struct i2c_board_info __initdata_or_module n810_i2c_board_info_2[] = {
+	{
+		I2C_BOARD_INFO("lm8323", 0x45),
+		.irq		= OMAP_GPIO_IRQ(109),
+		.platform_data	= &lm8323_pdata,
+	},
 };
 
 #if defined(CONFIG_MTD_ONENAND_OMAP2) || \
@@ -77,6 +346,20 @@ static struct mtd_partition onenand_partitions[] = {
 	},
 };
 
+static struct cbus_host_platform_data n8x0_cbus_data = {
+	.clk_gpio	= 66,
+	.dat_gpio	= 65,
+	.sel_gpio	= 64,
+};
+
+static struct platform_device n8x0_cbus_device = {
+	.name		= "cbus",
+	.id		= -1,
+	.dev		= {
+		.platform_data = &n8x0_cbus_data,
+	},
+};
+
 static struct omap_onenand_platform_data board_onenand_data = {
 	.cs		= 0,
 	.gpio_irq	= 26,
@@ -109,13 +392,53 @@ static void __init n8x0_init_irq(void)
 	omap_gpio_init();
 }
 
+#if defined(CONFIG_MMC_OMAP) || defined(CONFIG_MMC_OMAP_MODULE)
+extern void n8x0_mmc_init(void);
+#endif
+#ifdef CONFIG_MACH_NOKIA_N8X0_LCD
+extern void n8x0_mipid_init(void);
+extern void n8x0_blizzard_init(void);
+#else
+#define n8x0_mipid_init() 0
+#define n8x0_blizzard_init() 0
+#endif
+#ifdef CONFIG_MACH_NOKIA_N8X0_USB
+extern void n8x0_usb_init(void);
+#else
+#	define n8x0_usb_init() 0
+#endif
+
 static void __init n8x0_init_machine(void)
 {
+	platform_device_register(&n8x0_cbus_device);
+
+#if defined(CONFIG_MMC_OMAP) || defined(CONFIG_MMC_OMAP_MODULE)
+	n8x0_mmc_init();
+#endif
+	n8x0_bt_init();
+	n8x0_usb_init();
+
 	/* FIXME: add n810 spi devices */
+	tsc2005_set_config();
 	spi_register_board_info(n800_spi_board_info,
 				ARRAY_SIZE(n800_spi_board_info));
 
 	omap_serial_init();
+
+#ifdef CONFIG_MENELAUS
+	omap_register_i2c_bus(1, 400, n8x0_i2c_board_info_menelaus,
+			      ARRAY_SIZE(n8x0_i2c_board_info_menelaus));
+#endif
+
+	omap_register_i2c_bus(2, 400, n8x0_i2c_board_info_2,
+			      ARRAY_SIZE(n8x0_i2c_board_info_2));
+
+	i2c_register_board_info(2, n810_i2c_board_info_2,
+    				ARRAY_SIZE(n810_i2c_board_info_2));
+
+	n8x0_mipid_init();
+	n8x0_blizzard_init();
+
 	n8x0_onenand_init();
 }
 
diff --git a/arch/arm/mach-omap2/io.c b/arch/arm/mach-omap2/io.c
index ac31a6c..4093db8 100644
--- a/arch/arm/mach-omap2/io.c
+++ b/arch/arm/mach-omap2/io.c
@@ -306,10 +306,7 @@ static int __init _omap2_init_reprogram_sdrc(void)
 }
 
 void __init omap2_init_common_hw(struct omap_sdrc_params *sdrc_cs0,
-				 struct omap_sdrc_params *sdrc_cs1,
-				 struct omap_opp *mpu_opps,
-				 struct omap_opp *dsp_opps,
-				 struct omap_opp *l3_opps)
+				 struct omap_sdrc_params *sdrc_cs1)
 {
 	struct omap_hwmod **hwmods = NULL;
 
@@ -327,8 +324,8 @@ void __init omap2_init_common_hw(struct omap_sdrc_params *sdrc_cs0,
 	omap_pm_if_early_init(mpu_opps, dsp_opps, l3_opps);
 	pwrdm_init(powerdomains_omap);
 	clkdm_init(clockdomains_omap, clkdm_pwrdm_autodeps);
-	omap2_clk_init();
 #endif
+	omap2_clk_init();
 	omap_serial_early_init();
 #ifndef CONFIG_ARCH_OMAP4
 	omap_hwmod_late_init();
diff --git a/arch/arm/mach-omap2/mailbox.c b/arch/arm/mach-omap2/mailbox.c
index 281ab63..2c9fd1c 100644
--- a/arch/arm/mach-omap2/mailbox.c
+++ b/arch/arm/mach-omap2/mailbox.c
@@ -93,7 +93,7 @@ static int omap2_mbox_startup(struct omap_mbox *mbox)
 
 	mbox_ick_handle = clk_get(NULL, "mailboxes_ick");
 	if (IS_ERR(mbox_ick_handle)) {
-		printk(KERN_ERR "Could not get mailboxes_ick: %d\n",
+		printk(KERN_ERR "Could not get mailboxes_ick: %ld\n",
 			PTR_ERR(mbox_ick_handle));
 		return PTR_ERR(mbox_ick_handle);
 	}
diff --git a/arch/arm/mach-omap2/serial.c b/arch/arm/mach-omap2/serial.c
index a27e91e..ab0c259 100644
--- a/arch/arm/mach-omap2/serial.c
+++ b/arch/arm/mach-omap2/serial.c
@@ -10,35 +10,39 @@
  *
  * Based off of arch/arm/mach-omap/omap1/serial.c
  *
+ * Copyright (C) 2009 Texas Instruments
+ * Added OMAP4 support - Santosh Shilimkar <santosh.shilimkar@ti.com
+ *
  * This file is subject to the terms and conditions of the GNU General Public
  * License. See the file "COPYING" in the main directory of this archive
  * for more details.
  */
 #include <linux/kernel.h>
 #include <linux/init.h>
+#include <linux/serial_8250.h>
 #include <linux/serial_reg.h>
 #include <linux/clk.h>
-#ifdef CONFIG_SERIAL_OMAP
-#include <linux/platform_device.h>
-#endif
 #include <linux/io.h>
-#include <linux/delay.h>
-#include <linux/debugfs.h>
 
 #include <plat/common.h>
 #include <plat/board.h>
 #include <plat/clock.h>
 #include <plat/control.h>
-#include <mach/gpio.h>
-#include <plat/omap-serial.h>
-
-#include <asm/mach/serial_omap.h>
 
 #include "prm.h"
 #include "pm.h"
 #include "prm-regbits-34xx.h"
 
-#define DEFAULT_TIMEOUT (HZ / 2)
+#define UART_OMAP_NO_EMPTY_FIFO_READ_IP_REV	0x52
+#define UART_OMAP_WER		0x17	/* Wake-up enable register */
+
+/*
+ * NOTE: By default the serial timeout is disabled as it causes lost characters
+ * over the serial ports. This means that the UART clocks will stay on until
+ * disabled via sysfs. This also causes that any deeper omap sleep states are
+ * blocked. 
+ */
+#define DEFAULT_TIMEOUT 0
 
 struct omap_uart_state {
 	int num;
@@ -51,16 +55,13 @@ struct omap_uart_state {
 	u32 wk_mask;
 	u32 padconf;
 
-	u32 rts_padconf;
-	int rts_override;
-	u16 rts_padvalue;
-
 	struct clk *ick;
 	struct clk *fck;
 	int clocked;
 
-        struct plat_serialomap_port *p;
+	struct plat_serial8250_port *p;
 	struct list_head node;
+	struct platform_device pdev;
 
 #if defined(CONFIG_ARCH_OMAP3) && defined(CONFIG_PM)
 	int context_valid;
@@ -75,129 +76,76 @@ struct omap_uart_state {
 #endif
 };
 
-static struct omap_uart_state omap_uart[OMAP_MAX_NR_PORTS];
 static LIST_HEAD(uart_list);
-static unsigned int fifo_idleblks = 0;
 
-#ifdef CONFIG_SERIAL_OMAP
-static struct plat_serialomap_port serial_platform_data[] = {
+static struct plat_serial8250_port serial_platform_data0[] = {
 	{
-		.membase	= OMAP2_L4_IO_ADDRESS(OMAP_UART1_BASE),
+		.mapbase	= OMAP_UART1_BASE,
 		.irq		= 72,
-		.regshift	= 2,
 		.flags		= UPF_BOOT_AUTOCONF,
-	},
-	{
-		.membase	= OMAP2_L4_IO_ADDRESS(OMAP_UART2_BASE),
-		.irq		= 73,
+		.iotype		= UPIO_MEM,
 		.regshift	= 2,
-		.flags		= UPF_BOOT_AUTOCONF,
-	},
-	{
-		.membase	= OMAP2_L4_IO_ADDRESS(OMAP_UART3_BASE),
-		.irq		= 74,
-		.regshift	= 2,
-		.flags		= UPF_BOOT_AUTOCONF,
-	},
-};
-
-static struct resource omap2_uart1_resources[] = {
-	{
-		.start		= OMAP_UART1_BASE,
-		.end		= OMAP_UART1_BASE + 0x3ff,
-		.flags		= IORESOURCE_MEM,
+		.uartclk	= OMAP24XX_BASE_BAUD * 16,
 	}, {
-		.start		= 72,
-                .flags		= IORESOURCE_IRQ,
+		.flags		= 0
 	}
 };
 
-static struct resource omap2_uart2_resources[] = {
+static struct plat_serial8250_port serial_platform_data1[] = {
 	{
-		.start		= OMAP_UART2_BASE,
-		.end		= OMAP_UART2_BASE + 0x3ff,
-		.flags		= IORESOURCE_MEM,
+		.mapbase	= OMAP_UART2_BASE,
+		.irq		= 73,
+		.flags		= UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= OMAP24XX_BASE_BAUD * 16,
 	}, {
-		.start		= 73,
-		.flags		= IORESOURCE_IRQ,
+		.flags		= 0
 	}
 };
 
-static struct resource omap2_uart3_resources[] = {
+static struct plat_serial8250_port serial_platform_data2[] = {
 	{
-		.start		= OMAP_UART3_BASE,
-		.end		= OMAP_UART3_BASE + 0x3ff,
-		.flags		= IORESOURCE_MEM,
+		.mapbase	= OMAP_UART3_BASE,
+		.irq		= 74,
+		.flags		= UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= OMAP24XX_BASE_BAUD * 16,
 	}, {
-		.start		= 74,
-		.flags		= IORESOURCE_IRQ,
+		.flags		= 0
 	}
 };
 
-#ifdef CONFIG_MACH_OMAP_ZOOM2
-static struct resource omap2_quaduart_resources[] = {
+#ifdef CONFIG_ARCH_OMAP4
+static struct plat_serial8250_port serial_platform_data3[] = {
 	{
-		.start		= 0x10000000,
-		.end		= 0x10000000 + (0x16 << 1),
-		.flags		= IORESOURCE_MEM,
+		.mapbase	= OMAP_UART4_BASE,
+		.irq		= 70,
+		.flags		= UPF_BOOT_AUTOCONF,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+		.uartclk	= OMAP24XX_BASE_BAUD * 16,
 	}, {
-		.start		= OMAP_GPIO_IRQ(102),
-		.flags		= IORESOURCE_IRQ,
+		.flags		= 0
 	}
 };
 #endif
+static inline unsigned int __serial_read_reg(struct uart_port *up,
+					   int offset)
+{
+	offset <<= up->regshift;
+	return (unsigned int)__raw_readb(up->membase + offset);
+}
 
-/* OMAP UART platform structure */
-static struct platform_device uart1_device = {
-	.name			= "omap-uart",
-	.id			= 1,
-	.num_resources		= ARRAY_SIZE(omap2_uart1_resources),
-	.resource		= omap2_uart1_resources,
-	.dev.platform_data	= &serial_platform_data[0],
-};
-static struct platform_device uart2_device = {
-	.name			= "omap-uart",
-	.id			= 2,
-	.num_resources		= ARRAY_SIZE(omap2_uart2_resources),
-	.resource		= omap2_uart2_resources,
-	.dev.platform_data	= &serial_platform_data[1],
-};
-static struct platform_device uart3_device = {
-	.name			= "omap-uart",
-	.id			= 3,
-	.num_resources		= ARRAY_SIZE(omap2_uart3_resources),
-	.resource		= omap2_uart3_resources,
-	.dev.platform_data	= &serial_platform_data[2],
-};
-
-#ifdef CONFIG_MACH_OMAP_ZOOM2
-static struct platform_device quaduart_device = {
-
-	.name			= "omap-uart",
-	.id			= 4,
-	.num_resources		= ARRAY_SIZE(omap2_quaduart_resources),
-	.resource		= omap2_quaduart_resources,
-};
-#endif
-
-static struct platform_device *uart_devices[] = {
-	&uart1_device,
-	&uart2_device,
-	&uart3_device,
-#ifdef CONFIG_MACH_OMAP_ZOOM2
-	&quaduart_device
-#endif
-};
-#endif
-
-static inline unsigned int serial_read_reg(struct plat_serialomap_port *up,
+static inline unsigned int serial_read_reg(struct plat_serial8250_port *up,
 					   int offset)
 {
 	offset <<= up->regshift;
 	return (unsigned int)__raw_readb(up->membase + offset);
 }
 
-static inline void serial_write_reg(struct plat_serialomap_port *p, int offset,
+static inline void serial_write_reg(struct plat_serial8250_port *p, int offset,
 				    int value)
 {
 	offset <<= p->regshift;
@@ -211,7 +159,7 @@ static inline void serial_write_reg(struct plat_serialomap_port *p, int offset,
  */
 static inline void __init omap_uart_reset(struct omap_uart_state *uart)
 {
-	struct plat_serialomap_port *p = uart->p;
+	struct plat_serial8250_port *p = uart->p;
 
 	serial_write_reg(p, UART_OMAP_MDR1, 0x07);
 	serial_write_reg(p, UART_OMAP_SCR, 0x08);
@@ -219,23 +167,12 @@ static inline void __init omap_uart_reset(struct omap_uart_state *uart)
 	serial_write_reg(p, UART_OMAP_SYSC, (0x02 << 3) | (1 << 2) | (1 << 0));
 }
 
-static inline void omap_uart_enable_clocks(struct omap_uart_state *uart)
-{
-	if (uart->clocked)
-		return;
-
-	clk_enable(uart->ick);
-	clk_enable(uart->fck);
-	uart->clocked = 1;
-}
-
-#ifdef CONFIG_PM
-#ifdef CONFIG_ARCH_OMAP3
+#if defined(CONFIG_PM) && defined(CONFIG_ARCH_OMAP3)
 
 static void omap_uart_save_context(struct omap_uart_state *uart)
 {
 	u16 lcr = 0;
-	struct plat_serialomap_port *p = uart->p;
+	struct plat_serial8250_port *p = uart->p;
 
 	if (!enable_off_mode)
 		return;
@@ -256,7 +193,7 @@ static void omap_uart_save_context(struct omap_uart_state *uart)
 static void omap_uart_restore_context(struct omap_uart_state *uart)
 {
 	u16 efr = 0;
-	struct plat_serialomap_port *p = uart->p;
+	struct plat_serial8250_port *p = uart->p;
 
 	if (!enable_off_mode)
 		return;
@@ -272,16 +209,12 @@ static void omap_uart_restore_context(struct omap_uart_state *uart)
 	serial_write_reg(p, UART_EFR, UART_EFR_ECB);
 	serial_write_reg(p, UART_LCR, 0x0); /* Operational mode */
 	serial_write_reg(p, UART_IER, 0x0);
-#ifdef CONFIG_SERIAL_OMAP
-	serial_write_reg(p, UART_FCR, fcr[uart->num]);
-#else
-	serial_write_reg(p, UART_FCR, 0xA1);
-#endif
 	serial_write_reg(p, UART_LCR, 0xBF); /* Config B mode */
 	serial_write_reg(p, UART_DLL, uart->dll);
 	serial_write_reg(p, UART_DLM, uart->dlh);
 	serial_write_reg(p, UART_LCR, 0x0); /* Operational mode */
 	serial_write_reg(p, UART_IER, uart->ier);
+	serial_write_reg(p, UART_FCR, 0xA1);
 	serial_write_reg(p, UART_LCR, 0xBF); /* Config B mode */
 	serial_write_reg(p, UART_EFR, efr);
 	serial_write_reg(p, UART_LCR, UART_LCR_WLEN8);
@@ -293,60 +226,84 @@ static void omap_uart_restore_context(struct omap_uart_state *uart)
 #else
 static inline void omap_uart_save_context(struct omap_uart_state *uart) {}
 static inline void omap_uart_restore_context(struct omap_uart_state *uart) {}
-#endif /* CONFIG_ARCH_OMAP3 */
+#endif /* CONFIG_PM && CONFIG_ARCH_OMAP3 */
 
-static void omap_uart_smart_idle_enable(struct omap_uart_state *uart,
-					  int enable)
+static inline void omap_uart_enable_clocks(struct omap_uart_state *uart)
 {
-	struct plat_serialomap_port *p = uart->p;
-	u16 sysc;
-
-	sysc = serial_read_reg(p, UART_OMAP_SYSC) & 0x7;
-	if (enable)
-		sysc |= 0x2 << 3;
-	else
-		sysc |= 0x1 << 3;
+	if (uart->clocked)
+		return;
 
-	serial_write_reg(p, UART_OMAP_SYSC, sysc);
+	clk_enable(uart->ick);
+	clk_enable(uart->fck);
+	uart->clocked = 1;
+	omap_uart_restore_context(uart);
 }
 
-static inline void omap_uart_disable_rtspullup(struct omap_uart_state *uart)
+#ifdef CONFIG_PM
+
+static inline void omap_uart_disable_clocks(struct omap_uart_state *uart)
 {
-	if (!uart->rts_padconf || !uart->rts_override)
+	if (!uart->clocked)
 		return;
-	omap_ctrl_writew(uart->rts_padvalue, uart->rts_padconf);
-	uart->rts_override = 0;
+
+	omap_uart_save_context(uart);
+	uart->clocked = 0;
+	clk_disable(uart->ick);
+	clk_disable(uart->fck);
 }
 
-static inline void omap_uart_enable_rtspullup(struct omap_uart_state *uart)
+static void omap_uart_enable_wakeup(struct omap_uart_state *uart)
 {
-	if (!uart->rts_padconf || uart->rts_override)
-		return;
+	/* Set wake-enable bit */
+	if (uart->wk_en && uart->wk_mask) {
+		u32 v = __raw_readl(uart->wk_en);
+		v |= uart->wk_mask;
+		__raw_writel(v, uart->wk_en);
+	}
 
-	uart->rts_padvalue = omap_ctrl_readw(uart->rts_padconf);
-	omap_ctrl_writew(0x18 | 0x7, uart->rts_padconf);
-	uart->rts_override = 1;
+	/* Ensure IOPAD wake-enables are set */
+	if (cpu_is_omap34xx() && uart->padconf) {
+		u16 v = omap_ctrl_readw(uart->padconf);
+		v |= OMAP3_PADCONF_WAKEUPENABLE0;
+		omap_ctrl_writew(v, uart->padconf);
+	}
 }
 
-static inline void omap_uart_restore(struct omap_uart_state *uart)
+static void omap_uart_disable_wakeup(struct omap_uart_state *uart)
 {
-	omap_uart_enable_clocks(uart);
-	omap_uart_restore_context(uart);
+	/* Clear wake-enable bit */
+	if (uart->wk_en && uart->wk_mask) {
+		u32 v = __raw_readl(uart->wk_en);
+		v &= ~uart->wk_mask;
+		__raw_writel(v, uart->wk_en);
+	}
+
+	/* Ensure IOPAD wake-enables are cleared */
+	if (cpu_is_omap34xx() && uart->padconf) {
+		u16 v = omap_ctrl_readw(uart->padconf);
+		v &= ~OMAP3_PADCONF_WAKEUPENABLE0;
+		omap_ctrl_writew(v, uart->padconf);
+	}
 }
 
-static inline void omap_uart_disable_clocks(struct omap_uart_state *uart)
+static void omap_uart_smart_idle_enable(struct omap_uart_state *uart,
+					  int enable)
 {
-	if (!uart->clocked)
-		return;
-	omap_uart_save_context(uart);
-	uart->clocked = 0;
-	clk_disable(uart->ick);
-	clk_disable(uart->fck);
+	struct plat_serial8250_port *p = uart->p;
+	u16 sysc;
+
+	sysc = serial_read_reg(p, UART_OMAP_SYSC) & 0x7;
+	if (enable)
+		sysc |= 0x2 << 3;
+	else
+		sysc |= 0x1 << 3;
+
+	serial_write_reg(p, UART_OMAP_SYSC, sysc);
 }
 
-static void _omap_uart_block_sleep(struct omap_uart_state *uart)
+static void omap_uart_block_sleep(struct omap_uart_state *uart)
 {
-	omap_uart_restore(uart);
+	omap_uart_enable_clocks(uart);
 
 	omap_uart_smart_idle_enable(uart, 0);
 	uart->can_sleep = 0;
@@ -356,20 +313,13 @@ static void _omap_uart_block_sleep(struct omap_uart_state *uart)
 		del_timer(&uart->timer);
 }
 
-void omap_uart_block_sleep(int num)
-{
-	struct omap_uart_state *uart;
-
-	list_for_each_entry(uart, &uart_list, node) {
-		if (num == uart->num)
-			_omap_uart_block_sleep(uart);
-		return;
-	}
-}
-EXPORT_SYMBOL(omap_uart_block_sleep);
-
 static void omap_uart_allow_sleep(struct omap_uart_state *uart)
 {
+	if (device_may_wakeup(&uart->pdev.dev))
+		omap_uart_enable_wakeup(uart);
+	else
+		omap_uart_disable_wakeup(uart);
+
 	if (!uart->clocked)
 		return;
 
@@ -391,24 +341,6 @@ void omap_uart_prepare_idle(int num)
 
 	list_for_each_entry(uart, &uart_list, node) {
 		if (num == uart->num && uart->can_sleep) {
-
-			omap_uart_enable_rtspullup(uart);
-			/*
-			 * There seems to be a window here where
-			 * data could still be on the way to the
-			 * fifo. This delay is ~1 byte time @ 115.2k
-			 */
-			if (uart->num == 0)
-				udelay(80);
-
-#ifdef CONFIG_SERIAL_OMAP
-			if (are_driveromap_uarts_active(num)) {
-				fifo_idleblks++;
-				_omap_uart_block_sleep(uart);
-				omap_uart_disable_rtspullup(uart);
-				return;
-			}
-#endif
 			omap_uart_disable_clocks(uart);
 			return;
 		}
@@ -421,22 +353,19 @@ void omap_uart_resume_idle(int num)
 
 	list_for_each_entry(uart, &uart_list, node) {
 		if (num == uart->num) {
-			omap_uart_restore(uart);
-			omap_uart_disable_rtspullup(uart);
+			omap_uart_enable_clocks(uart);
 
 			/* Check for IO pad wakeup */
 			if (cpu_is_omap34xx() && uart->padconf) {
 				u16 p = omap_ctrl_readw(uart->padconf);
 
 				if (p & OMAP3_PADCONF_WAKEUPEVENT0)
-					_omap_uart_block_sleep(uart);
+					omap_uart_block_sleep(uart);
 			}
 
 			/* Check for normal UART wakeup */
-			if (__raw_readl(uart->wk_st) & uart->wk_mask) {
-				_omap_uart_block_sleep(uart);
-			}
-
+			if (__raw_readl(uart->wk_st) & uart->wk_mask)
+				omap_uart_block_sleep(uart);
 			return;
 		}
 	}
@@ -465,13 +394,6 @@ int omap_uart_can_sleep(void)
 			continue;
 		}
 
-#ifdef CONFIG_SERIAL_OMAP
-		if (are_driveromap_uarts_active(uart->num)) {
-			can_sleep = 0;
-			continue;
-		}
-#endif
-
 		/* This UART can now safely sleep. */
 		omap_uart_allow_sleep(uart);
 	}
@@ -492,49 +414,23 @@ static irqreturn_t omap_uart_interrupt(int irq, void *dev_id)
 {
 	struct omap_uart_state *uart = dev_id;
 
-	_omap_uart_block_sleep(uart);
+	omap_uart_block_sleep(uart);
 
 	return IRQ_NONE;
 }
 
-static u32 sleep_timeout = DEFAULT_TIMEOUT;
-
-static void omap_uart_rtspad_init(struct omap_uart_state *uart)
-{
-	if (!cpu_is_omap34xx())
-		return;
-	switch(uart->num) {
-	case 0:
-		uart->rts_padconf = 0x17e;
-		break;
-	case 1:
-		uart->rts_padconf = 0x176;
-		break;
-	case 2:
-/*		uart->rts_padconf = 0x19c; */
-		break;
-	default:
-		uart->rts_padconf = 0;
-		break;
-	}
-}
-
 static void omap_uart_idle_init(struct omap_uart_state *uart)
 {
-	u32 v;
-	struct plat_serialomap_port *p = uart->p;
+	struct plat_serial8250_port *p = uart->p;
 	int ret;
 
 	uart->can_sleep = 0;
-	uart->timeout = sleep_timeout;
-	if (!uart->timeout)
-		_omap_uart_block_sleep(uart);
-	else {
-		setup_timer(&uart->timer, omap_uart_idle_timer,
-			    (unsigned long) uart);
+	uart->timeout = DEFAULT_TIMEOUT;
+	setup_timer(&uart->timer, omap_uart_idle_timer,
+		    (unsigned long) uart);
+	if (uart->timeout)
 		mod_timer(&uart->timer, jiffies + uart->timeout);
-		omap_uart_smart_idle_enable(uart, 0);
-	}
+	omap_uart_smart_idle_enable(uart, 0);
 
 	if (cpu_is_omap34xx()) {
 		u32 mod = (uart->num == 2) ? OMAP3430_PER_MOD : CORE_MOD;
@@ -546,7 +442,7 @@ static void omap_uart_idle_init(struct omap_uart_state *uart)
 		switch (uart->num) {
 		case 0:
 			wk_mask = OMAP3430_ST_UART1_MASK;
-			padconf = 0x180;
+			padconf = 0x182;
 			break;
 		case 1:
 			wk_mask = OMAP3430_ST_UART2_MASK;
@@ -588,26 +484,10 @@ static void omap_uart_idle_init(struct omap_uart_state *uart)
 		uart->padconf = 0;
 	}
 
-	/* Set wake-enable bit */
-	if (uart->wk_en && uart->wk_mask) {
-		v = __raw_readl(uart->wk_en);
-		v |= uart->wk_mask;
-		__raw_writel(v, uart->wk_en);
-	}
-
-	/* Ensure IOPAD wake-enables are set */
-	if (cpu_is_omap34xx() && uart->padconf) {
-		u16 v;
-
-		v = omap_ctrl_readw(uart->padconf);
-		v |= OMAP3_PADCONF_WAKEUPENABLE0;
-		omap_ctrl_writew(v, uart->padconf);
-	}
-
-	p->flags |= UPF_SHARE_IRQ;
+/*	p->irqflags |= IRQF_SHARED;
 	ret = request_irq(p->irq, omap_uart_interrupt, IRQF_SHARED,
 			  "serial idle", (void *)uart);
-	WARN_ON(ret);
+	WARN_ON(ret); */
 }
 
 void omap_uart_enable_irqs(int enable)
@@ -615,100 +495,143 @@ void omap_uart_enable_irqs(int enable)
 	int ret;
 	struct omap_uart_state *uart;
 
-	list_for_each_entry(uart, &uart_list, node) {
+/*	list_for_each_entry(uart, &uart_list, node) {
 		if (enable)
 			ret = request_irq(uart->p->irq, omap_uart_interrupt,
 				IRQF_SHARED, "serial idle", (void *)uart);
 		else
 			free_irq(uart->p->irq, (void *)uart);
-	}
+	} */
 }
 
-static ssize_t sleep_timeout_show(struct kobject *kobj,
-				  struct kobj_attribute *attr,
+static ssize_t sleep_timeout_show(struct device *dev,
+				  struct device_attribute *attr,
 				  char *buf)
 {
-	return sprintf(buf, "%u\n", sleep_timeout / HZ);
+	struct platform_device *pdev = container_of(dev,
+					struct platform_device, dev);
+	struct omap_uart_state *uart = container_of(pdev,
+					struct omap_uart_state, pdev);
+
+	return sprintf(buf, "%u\n", uart->timeout / HZ);
 }
 
-static ssize_t sleep_timeout_store(struct kobject *kobj,
-				   struct kobj_attribute *attr,
+static ssize_t sleep_timeout_store(struct device *dev,
+				   struct device_attribute *attr,
 				   const char *buf, size_t n)
 {
-	struct omap_uart_state *uart;
+	struct platform_device *pdev = container_of(dev,
+					struct platform_device, dev);
+	struct omap_uart_state *uart = container_of(pdev,
+					struct omap_uart_state, pdev);
 	unsigned int value;
 
 	if (sscanf(buf, "%u", &value) != 1) {
 		printk(KERN_ERR "sleep_timeout_store: Invalid value\n");
 		return -EINVAL;
 	}
-	sleep_timeout = value * HZ;
-	list_for_each_entry(uart, &uart_list, node) {
-		uart->timeout = sleep_timeout;
-		if (uart->timeout)
-			mod_timer(&uart->timer, jiffies + uart->timeout);
-		else
-			/* A zero value means disable timeout feature */
-			_omap_uart_block_sleep(uart);
-	}
+
+	uart->timeout = value * HZ;
+	if (uart->timeout)
+		mod_timer(&uart->timer, jiffies + uart->timeout);
+	else
+		/* A zero value means disable timeout feature */
+		omap_uart_block_sleep(uart);
+
 	return n;
 }
 
-static struct kobj_attribute sleep_timeout_attr =
-	__ATTR(sleep_timeout, 0644, sleep_timeout_show, sleep_timeout_store);
-
+DEVICE_ATTR(sleep_timeout, 0644, sleep_timeout_show, sleep_timeout_store);
+#define DEV_CREATE_FILE(dev, attr) WARN_ON(device_create_file(dev, attr))
 #else
 static inline void omap_uart_idle_init(struct omap_uart_state *uart) {}
+#define DEV_CREATE_FILE(dev, attr)
 #endif /* CONFIG_PM */
 
-static int fifo_idleblk_get(void *data, u64 *val)
-{
-	*val = fifo_idleblks;
-	return 0;
-}
+static struct omap_uart_state omap_uart[] = {
+	{
+		.pdev = {
+			.name			= "serial8250",
+			.id			= PLAT8250_DEV_PLATFORM,
+			.dev			= {
+				.platform_data	= serial_platform_data0,
+			},
+		},
+	}, {
+		.pdev = {
+			.name			= "serial8250",
+			.id			= PLAT8250_DEV_PLATFORM1,
+			.dev			= {
+				.platform_data	= serial_platform_data1,
+			},
+		},
+	}, {
+		.pdev = {
+			.name			= "serial8250",
+			.id			= PLAT8250_DEV_PLATFORM2,
+			.dev			= {
+				.platform_data	= serial_platform_data2,
+			},
+		},
+	},
+#ifdef CONFIG_ARCH_OMAP4
+	{
+		.pdev = {
+			.name			= "serial8250",
+			.id			= 3,
+			.dev			= {
+				.platform_data	= serial_platform_data3,
+			},
+		},
+	},
+#endif
+};
 
-static int fifo_idleblk_set(void *data, u64 val)
+/*
+ * Override the default 8250 read handler: mem_serial_in()
+ * Empty RX fifo read causes an abort on omap3630 and omap4
+ * This function makes sure that an empty rx fifo is not read on these silicons
+ * (OMAP1/2/3430 are not affected)
+ */
+static unsigned int serial_in_override(struct uart_port *up, int offset)
 {
-	fifo_idleblks = 0;
-	return 0;
-}
+	if (UART_RX == offset) {
+		unsigned int lsr;
+		lsr = __serial_read_reg(up, UART_LSR);
+		if (!(lsr & UART_LSR_DR))
+			return -EPERM;
+	}
 
-DEFINE_SIMPLE_ATTRIBUTE(fifo_idleblk_fops, fifo_idleblk_get, fifo_idleblk_set, "%llu\n");
-void __init omap_serial_early_init(void)
-{
+	return __serial_read_reg(up, offset);
 }
 
-void __init omap_serial_init(int wake_gpio_strobe,
-			     unsigned int wake_strobe_enable_mask)
+void __init omap_serial_early_init(void)
 {
 	int i;
-	const struct omap_uart_config *info;
 	char name[16];
 
-	debugfs_create_file("fifo_idle_block_count", 0644, NULL, NULL, &fifo_idleblk_fops);
 	/*
 	 * Make sure the serial ports are muxed on at this point.
 	 * You have to mux them off in device drivers later on
 	 * if not needed.
 	 */
 
-	info = omap_get_config(OMAP_TAG_UART, struct omap_uart_config);
-
-	if (info == NULL)
-		return;
-
-	for (i = 0; i < OMAP_MAX_NR_PORTS; i++) {
-		struct plat_serialomap_port *p = serial_platform_data + i;
+	for (i = 0; i < ARRAY_SIZE(omap_uart); i++) {
 		struct omap_uart_state *uart = &omap_uart[i];
-
-		if (!(info->enabled_uarts & (1 << i))) {
-			p->disabled = 1;
+		struct platform_device *pdev = &uart->pdev;
+		struct device *dev = &pdev->dev;
+		struct plat_serial8250_port *p = dev->platform_data;
+
+		/*
+		 * Module 4KB + L4 interconnect 4KB
+		 * Static mapping, never released
+		 */
+		p->membase = ioremap(p->mapbase, SZ_8K);
+		if (!p->membase) {
+			printk(KERN_ERR "ioremap failed for uart%i\n", i + 1);
 			continue;
 		}
 
-		if (wake_strobe_enable_mask & (1 << i))
-			p->wake_gpio_strobe = wake_gpio_strobe;
-
 		sprintf(name, "uart%d_ick", i+1);
 		uart->ick = clk_get(NULL, name);
 		if (IS_ERR(uart->ick)) {
@@ -723,40 +646,83 @@ void __init omap_serial_init(int wake_gpio_strobe,
 			uart->fck = NULL;
 		}
 
-		if (!uart->ick || !uart->fck)
-			continue;
+		/* FIXME: Remove this once the clkdev is ready */
+		if (!cpu_is_omap44xx()) {
+			if (!uart->ick || !uart->fck)
+				continue;
+		}
 
 		uart->num = i;
 		p->private_data = uart;
 		uart->p = p;
-		list_add(&uart->node, &uart_list);
 
-		omap_uart_enable_clocks(uart);
-		omap_uart_reset(uart);
-		omap_uart_rtspad_init(uart);
-		omap_uart_idle_init(uart);
+		if (cpu_is_omap44xx())
+			p->irq += 32;
 	}
 }
 
-#ifdef CONFIG_SERIAL_OMAP
-static int __init omap_hs_init(void)
+/**
+ * omap_serial_init_port() - initialize single serial port
+ * @port: serial port number (0-3)
+ *
+ * This function initialies serial driver for given @port only.
+ * Platforms can call this function instead of omap_serial_init()
+ * if they don't plan to use all available UARTs as serial ports.
+ *
+ * Don't mix calls to omap_serial_init_port() and omap_serial_init(),
+ * use only one of the two.
+ */
+void __init omap_serial_init_port(int port)
 {
-	int ret = 0;
+	struct omap_uart_state *uart;
+	struct platform_device *pdev;
+	struct device *dev;
 
-	ret = platform_add_devices(uart_devices, ARRAY_SIZE(uart_devices));
-	if (ret) {
-		printk(KERN_ERR "Error adding uart devices (%d)\n", ret);
-		return ret;
-	}
-	ret = sysfs_create_file(&uart1_device.dev.kobj,
-				&sleep_timeout_attr.attr);
-	if (ret) {
-		printk(KERN_ERR
-		       "Error creating uart sleep_timeout sysfs file (%d)\n",
-			ret);
-		return ret;
+	BUG_ON(port < 0);
+	BUG_ON(port >= ARRAY_SIZE(omap_uart));
+
+	uart = &omap_uart[port];
+	pdev = &uart->pdev;
+	dev = &pdev->dev;
+
+	omap_uart_enable_clocks(uart);
+
+	omap_uart_reset(uart);
+	omap_uart_idle_init(uart);
+
+	list_add_tail(&uart->node, &uart_list);
+
+	if (WARN_ON(platform_device_register(pdev)))
+		return;
+
+	if ((cpu_is_omap34xx() && uart->padconf) ||
+	    (uart->wk_en && uart->wk_mask)) {
+		device_init_wakeup(dev, true);
+		DEV_CREATE_FILE(dev, &dev_attr_sleep_timeout);
 	}
-	return ret;
+
+		/* omap44xx: Never read empty UART fifo
+		 * omap3xxx: Never read empty UART fifo on UARTs
+		 * with IP rev >=0x52
+		 */
+		if (cpu_is_omap44xx())
+			uart->p->serial_in = serial_in_override;
+		else if ((serial_read_reg(uart->p, UART_OMAP_MVER) & 0xFF)
+				>= UART_OMAP_NO_EMPTY_FIFO_READ_IP_REV)
+			uart->p->serial_in = serial_in_override;
+}
+
+/**
+ * omap_serial_init() - intialize all supported serial ports
+ *
+ * Initializes all available UARTs as serial ports. Platforms
+ * can call this function when they want to have default behaviour
+ * for serial ports (e.g initialize them all as serial ports).
+ */
+void __init omap_serial_init(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(omap_uart); i++)
+		omap_serial_init_port(i);
 }
-arch_initcall(omap_hs_init);
-#endif
diff --git a/arch/arm/plat-omap/Kconfig b/arch/arm/plat-omap/Kconfig
index 418a349..d657f53 100644
--- a/arch/arm/plat-omap/Kconfig
+++ b/arch/arm/plat-omap/Kconfig
@@ -120,6 +120,30 @@ config OMAP_RESET_CLOCKS
 	  probably do not want this option enabled until your
 	  device drivers work properly.
 
+config OMAP_BOOT_TAG
+	bool "OMAP bootloader information passing"
+        depends on ARCH_OMAP
+        default n
+        help
+          Say Y, if you have a bootloader which passes information
+          about your board and its peripheral configuration.
+
+config OMAP_BOOT_REASON
+	bool "Support for boot reason"
+        depends on OMAP_BOOT_TAG
+        default n
+        help
+          Say Y, if you want to have a procfs entry for reading the boot
+          reason in user-space.
+
+config OMAP_COMPONENT_VERSION
+	bool "Support for component version display"
+	depends on OMAP_BOOT_TAG && PROC_FS
+	default n
+	help
+	  Say Y, if you want to have a procfs entry for reading component
+	  versions (supplied by the bootloader) in user-space.
+
 config OMAP_MUX
 	bool "OMAP multiplexing support"
         depends on ARCH_OMAP
diff --git a/arch/arm/plat-omap/Makefile b/arch/arm/plat-omap/Makefile
index 95f8413..56a9ea6 100644
--- a/arch/arm/plat-omap/Makefile
+++ b/arch/arm/plat-omap/Makefile
@@ -22,6 +22,8 @@ obj-$(CONFIG_OMAP_IOMMU_DEBUG) += iommu-debug.o
 
 obj-$(CONFIG_CPU_FREQ) += cpu-omap.o
 obj-$(CONFIG_OMAP_DM_TIMER) += dmtimer.o
+obj-$(CONFIG_OMAP_BOOT_REASON) += bootreason.o
+obj-$(CONFIG_OMAP_COMPONENT_VERSION) += component-version.o
 obj-$(CONFIG_OMAP_DEBUG_DEVICES) += debug-devices.o
 obj-$(CONFIG_OMAP_DEBUG_LEDS) += debug-leds.o
 i2c-omap-$(CONFIG_I2C_OMAP) := i2c.o
diff --git a/arch/arm/plat-omap/bootreason.c b/arch/arm/plat-omap/bootreason.c
new file mode 100644
index 0000000..e5f8e87
--- /dev/null
+++ b/arch/arm/plat-omap/bootreason.c
@@ -0,0 +1,79 @@
+/*
+ * linux/arch/arm/plat-omap/bootreason.c
+ *
+ * OMAP Bootreason passing
+ *
+ * Copyright (c) 2004 Nokia
+ *
+ * Written by David Weinehall <david.weinehall@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/proc_fs.h>
+#include <linux/errno.h>
+#include <plat/board.h>
+
+static char boot_reason[16];
+
+static int omap_bootreason_read_proc(char *page, char **start, off_t off,
+					 int count, int *eof, void *data)
+{
+	int len = 0;
+
+	len += sprintf(page + len, "%s\n", boot_reason);
+
+	*start = page + off;
+
+	if (len > off)
+		len -= off;
+	else
+		len = 0;
+
+	return len < count ? len  : count;
+}
+
+static int __init bootreason_init(void)
+{
+	const struct omap_boot_reason_config *cfg;
+	int reason_valid = 0;
+
+	cfg = omap_get_config(OMAP_TAG_BOOT_REASON, struct omap_boot_reason_config);
+	if (cfg != NULL) {
+		strncpy(boot_reason, cfg->reason_str, sizeof(cfg->reason_str));
+		boot_reason[sizeof(cfg->reason_str)] = 0;
+		reason_valid = 1;
+	} else {
+		/* Read the boot reason from the OMAP registers */
+	}
+
+	if (!reason_valid)
+		return -ENOENT;
+
+	printk(KERN_INFO "Bootup reason: %s\n", boot_reason);
+
+	if (!create_proc_read_entry("bootreason", S_IRUGO, NULL,
+					omap_bootreason_read_proc, NULL))
+		return -ENOMEM;
+
+	return 0;
+}
+
+late_initcall(bootreason_init);
diff --git a/arch/arm/plat-omap/common.c b/arch/arm/plat-omap/common.c
index 8da1c44..74b8536 100644
--- a/arch/arm/plat-omap/common.c
+++ b/arch/arm/plat-omap/common.c
@@ -43,7 +43,7 @@
 
 #define NO_LENGTH_CHECK 0xffffffff
 
-unsigned char omap_bootloader_tag[512];
+unsigned char omap_bootloader_tag[1024];
 int omap_bootloader_tag_len;
 
 struct omap_board_config_kernel *omap_board_config;
@@ -52,10 +52,24 @@ int omap_board_config_size;
 /* used by omap-smp.c and board-4430sdp.c */
 void __iomem *gic_cpu_base_addr;
 
-#ifdef CONFIG_OMAP_PM_NONE
-struct omap_opp *mpu_opps;
-struct omap_opp *dsp_opps;
-struct omap_opp *l3_opps;
+#ifdef CONFIG_OMAP_BOOT_TAG
+
+static int __init parse_tag_omap(const struct tag *tag)
+{
+	u32 size = tag->hdr.size - (sizeof(tag->hdr) >> 2);
+
+        size <<= 2;
+	if (size > sizeof(omap_bootloader_tag))
+		return -1;
+
+	memcpy(omap_bootloader_tag, tag->u.omap.data, size);
+	omap_bootloader_tag_len = size;
+
+        return 0;
+}
+
+__tagtable(ATAG_BOARD, parse_tag_omap);
+
 #endif
 
 static const void *get_config(u16 tag, size_t len, int skip, size_t *len_out)
@@ -63,6 +77,50 @@ static const void *get_config(u16 tag, size_t len, int skip, size_t *len_out)
 	struct omap_board_config_kernel *kinfo = NULL;
 	int i;
 
+#ifdef CONFIG_OMAP_BOOT_TAG
+	struct omap_board_config_entry *info = NULL;
+
+	if (omap_bootloader_tag_len > 4)
+		info = (struct omap_board_config_entry *) omap_bootloader_tag;
+	while (info != NULL) {
+		u8 *next;
+
+		if (info->tag == tag) {
+			if (skip == 0)
+				break;
+			skip--;
+		}
+
+		if ((info->len & 0x03) != 0) {
+			/* We bail out to avoid an alignment fault */
+			printk(KERN_ERR "OMAP peripheral config: Length (%d) not word-aligned (tag %04x)\n",
+			       info->len, info->tag);
+			return NULL;
+		}
+		next = (u8 *) info + sizeof(*info) + info->len;
+		if (next >= omap_bootloader_tag + omap_bootloader_tag_len)
+			info = NULL;
+		else
+			info = (struct omap_board_config_entry *) next;
+	}
+	if (info != NULL) {
+		/* Check the length as a lame attempt to check for
+		 * binary inconsistency. */
+		if (len != NO_LENGTH_CHECK) {
+			/* Word-align len */
+			if (len & 0x03)
+				len = (len + 3) & ~0x03;
+			if (info->len != len) {
+				printk(KERN_ERR "OMAP peripheral config: Length mismatch with tag %x (want %d, got %d)\n",
+				       tag, len, info->len);
+				return NULL;
+			}
+		}
+		if (len_out != NULL)
+			*len_out = info->len;
+		return info->data;
+	}
+#endif
 	/* Try to find the config from the board-specific structures
 	 * in the kernel. */
 	for (i = 0; i < omap_board_config_size; i++) {
@@ -181,10 +239,9 @@ unsigned long long sched_clock(void)
 /**
  * read_persistent_clock -  Return time from a persistent clock.
  *
- * Reads the time from a source which isn't disabled during PM: 32k sync
- * Convert the cycles elapsed since last read into nsecs and adds to
- * a monotonically increasing timespec.
- *
+ * Reads the time from a source which isn't disabled during PM, the
+ * 32k sync timer.  Convert the cycles elapsed since last read into
+ * nsecs and adds to a monotonically increasing timespec.
  */
 static struct timespec persistent_ts;
 static cycles_t cycles, last_cycles;
@@ -197,14 +254,10 @@ void read_persistent_clock(struct timespec *ts)
 	last_cycles = cycles;
 	cycles = clocksource_32k.read(&clocksource_32k);
 	delta = cycles - last_cycles;
-	if (unlikely(cycles < last_cycles)) {
-		pr_warning("%s: WRAP\n", __func__);
-		delta = last_cycles - cycles;
-	}
 
 	nsecs = clocksource_cyc2ns(delta,
 				   clocksource_32k.mult, clocksource_32k.shift);
-		
+
 	timespec_add_ns(tsp, nsecs);
 	*ts = *tsp;
 }
@@ -317,16 +370,18 @@ void __init omap2_set_globals_343x(void)
 #if defined(CONFIG_ARCH_OMAP4)
 static struct omap_globals omap4_globals = {
 	.class	= OMAP443X_CLASS,
-	.tap	= OMAP2_L4_IO_ADDRESS(0x4830a000),
+	.tap	= OMAP2_L4_IO_ADDRESS(OMAP443X_SCM_BASE),
 	.ctrl	= OMAP2_L4_IO_ADDRESS(OMAP443X_CTRL_BASE),
 	.prm	= OMAP2_L4_IO_ADDRESS(OMAP4430_PRM_BASE),
 	.cm	= OMAP2_L4_IO_ADDRESS(OMAP4430_CM_BASE),
+	.cm2	= OMAP2_L4_IO_ADDRESS(OMAP4430_CM2_BASE),
 };
 
 void __init omap2_set_globals_443x(void)
 {
 	omap2_set_globals_tap(&omap4_globals);
 	omap2_set_globals_control(&omap4_globals);
+	omap2_set_globals_prcm(&omap4_globals);
 }
 #endif
 
diff --git a/arch/arm/plat-omap/component-version.c b/arch/arm/plat-omap/component-version.c
new file mode 100644
index 0000000..0efca55
--- /dev/null
+++ b/arch/arm/plat-omap/component-version.c
@@ -0,0 +1,64 @@
+/*
+ *  linux/arch/arm/plat-omap/component-version.c
+ *
+ *  Copyright (C) 2005 Nokia Corporation
+ *  Written by Juha Yrjl <juha.yrjola@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/proc_fs.h>
+#include <plat/board.h>
+
+static int component_version_read_proc(char *page, char **start, off_t off,
+				       int count, int *eof, void *data)
+{
+	int len, i;
+	const struct omap_version_config *ver;
+	char *p;
+
+	i = 0;
+	p = page;
+	while ((ver = omap_get_nr_config(OMAP_TAG_VERSION_STR,
+					 struct omap_version_config, i)) != NULL) {
+		p += sprintf(p, "%-12s%s\n", ver->component, ver->version);
+		i++;
+	}
+
+	len = (p - page) - off;
+	if (len < 0)
+		len = 0;
+
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+
+static int __init component_version_init(void)
+{
+	if (omap_get_config(OMAP_TAG_VERSION_STR, struct omap_version_config) == NULL)
+		return -ENODEV;
+	if (!create_proc_read_entry("component_version", S_IRUGO, NULL,
+				    component_version_read_proc, NULL))
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void __exit component_version_exit(void)
+{
+	remove_proc_entry("component_version", NULL);
+}
+
+late_initcall(component_version_init);
+module_exit(component_version_exit);
+
+MODULE_AUTHOR("Juha Yrjl <juha.yrjola@nokia.com>");
+MODULE_DESCRIPTION("Component version driver");
+MODULE_LICENSE("GPL");
diff --git a/arch/arm/plat-omap/i2c.c b/arch/arm/plat-omap/i2c.c
index fb447c1..cc96f19 100644
--- a/arch/arm/plat-omap/i2c.c
+++ b/arch/arm/plat-omap/i2c.c
@@ -122,9 +122,11 @@ static void omap_i2c_set_wfc_mpu_wkup_lat(struct device *dev, int val)
 static void __init omap_set_i2c_constraint_func(
 				struct omap_i2c_bus_platform_data *pd)
 {
+#ifdef CONFIG_ARCH_OMAP34XX
 	if (cpu_is_omap34xx())
 		pd->set_mpu_wkup_lat = omap_i2c_set_wfc_mpu_wkup_lat;
 	else
+#endif
 		pd->set_mpu_wkup_lat = NULL;
 }
 
diff --git a/arch/arm/plat-omap/include/plat/cbus.h b/arch/arm/plat-omap/include/plat/cbus.h
new file mode 100644
index 0000000..d938e23
--- /dev/null
+++ b/arch/arm/plat-omap/include/plat/cbus.h
@@ -0,0 +1,31 @@
+/*
+ * cbus.h - CBUS platform_data definition
+ *
+ * Copyright (C) 2004 - 2009 Nokia Corporation
+ *
+ * Written by Felipe Balbi <felipe.balbi@nokia.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License. See the file "COPYING" in the main directory of this
+ * archive for more details.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __PLAT_CBUS_H
+#define __PLAT_CBUS_H
+
+struct cbus_host_platform_data {
+	int	dat_gpio;
+	int	clk_gpio;
+	int	sel_gpio;
+};
+
+#endif /* __PLAT_CBUS_H */
diff --git a/arch/arm/plat-omap/include/plat/io.h b/arch/arm/plat-omap/include/plat/io.h
index b455433..6c77b03 100644
--- a/arch/arm/plat-omap/include/plat/io.h
+++ b/arch/arm/plat-omap/include/plat/io.h
@@ -275,10 +275,7 @@ extern void omap1_init_common_hw(void);
 
 extern void omap2_map_common_io(void);
 extern void omap2_init_common_hw(struct omap_sdrc_params *sdrc_cs0,
-				 struct omap_sdrc_params *sdrc_cs1,
-				 struct omap_opp *mpu_opps,
-				 struct omap_opp *dsp_opps,
-				 struct omap_opp *l3_opps);
+				 struct omap_sdrc_params *sdrc_cs1);
 
 #define __arch_ioremap(p,s,t)	omap_ioremap(p,s,t)
 #define __arch_iounmap(v)	omap_iounmap(v)
diff --git a/arch/arm/plat-omap/include/plat/omap-serial.h b/arch/arm/plat-omap/include/plat/omap-serial.h
deleted file mode 100644
index c54c52e..0000000
--- a/arch/arm/plat-omap/include/plat/omap-serial.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * linux/include/asm-arm/arch-omap/omap-serial.h
- *
- * register definitions for omap24xx/omap34xx uart controller.
- *
- * Copyright (C) 2008-2009 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#ifndef __OMAP_SERIAL_H__
-#define __OMAP_SERIAL_H__
-
-/* UART NUMBERS */
-#define MAX_UARTS 			4
-#define UART1				(0x0)
-#define UART2				(0x1)
-#define UART3				(0x2)
-#define UART4				(0x3)
-
-#define UART_BASE(uart_no)		(uart_no == UART1)?OMAP_UART1_BASE :\
-					(uart_no == UART2)?OMAP_UART2_BASE :\
-					 OMAP_UART3_BASE
-
-#define UART_MODULE_BASE(uart_no)	 (UART1 == uart_no ? IO_ADDRESS(OMAP_UART1_BASE) :\
-		                                 ( UART2 == uart_no ? IO_ADDRESS(OMAP_UART2_BASE) :\
-					         IO_ADDRESS(OMAP_UART3_BASE) ))
-extern unsigned int fcr[MAX_UARTS];
-#endif /* __OMAP_SERIAL_H__ */
-
diff --git a/arch/arm/plat-omap/include/plat/serial.h b/arch/arm/plat-omap/include/plat/serial.h
index 785fc4a..f5a4a92 100644
--- a/arch/arm/plat-omap/include/plat/serial.h
+++ b/arch/arm/plat-omap/include/plat/serial.h
@@ -1,5 +1,8 @@
 /*
- *  arch/arm/plat-omap/include/mach/serial.h
+ * arch/arm/plat-omap/include/mach/serial.h
+ *
+ * Copyright (C) 2009 Texas Instruments
+ * Addded OMAP4 support- Santosh Shilimkar <santosh.shilimkar@ti.com>
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -10,6 +13,8 @@
 #ifndef __ASM_ARCH_SERIAL_H
 #define __ASM_ARCH_SERIAL_H
 
+#include <linux/init.h>
+
 #if defined(CONFIG_ARCH_OMAP1)
 /* OMAP1 serial ports */
 #define OMAP_UART1_BASE		0xfffb0000
@@ -25,10 +30,14 @@
 #define OMAP_UART1_BASE		0x4806a000
 #define OMAP_UART2_BASE		0x4806c000
 #define OMAP_UART3_BASE		0x49020000
-#define OMAP_UART_EXT_BASE	0x10000000
+#elif defined(CONFIG_ARCH_OMAP4)
+/* OMAP4 serial ports */
+#define OMAP_UART1_BASE		0x4806a000
+#define OMAP_UART2_BASE		0x4806c000
+#define OMAP_UART3_BASE		0x48020000
+#define OMAP_UART4_BASE		0x4806e000
 #endif
 
-#define OMAP_MAX_NR_PORTS	3
 #define OMAP1510_BASE_BAUD	(12000000/16)
 #define OMAP16XX_BASE_BAUD	(48000000/16)
 #define OMAP24XX_BASE_BAUD	(48000000/16)
@@ -42,9 +51,9 @@
 			})
 
 #ifndef __ASSEMBLER__
-extern void omap_serial_early_init(void);
-extern void omap_serial_init(int wake_gpio_strobe,
-			     unsigned int wake_strobe_enable_mask);
+extern void __init omap_serial_early_init(void);
+extern void omap_serial_init(void);
+extern void omap_serial_init_port(int port);
 extern int omap_uart_can_sleep(void);
 extern void omap_uart_check_wakeup(void);
 extern void omap_uart_prepare_suspend(void);
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 62e21b8..71554e9 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -507,6 +507,17 @@ config TOUCHSCREEN_TOUCHIT213
 	  To compile this driver as a module, choose M here: the
 	  module will be called touchit213.
 
+config TOUCHSCREEN_TSC2005
+        tristate "TSC2005 based touchscreens"
+        depends on SPI_MASTER
+        help
+          Say Y here if you have a TSC2005 based touchscreen.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tsc2005.
+
 config TOUCHSCREEN_TSC2007
 	tristate "TSC2007 based touchscreens"
 	depends on I2C
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index b7176b3..64da8ae 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -31,6 +31,7 @@ obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI)	+= synaptics_i2c_rmi.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHIT213)	+= touchit213.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHRIGHT)	+= touchright.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHWIN)	+= touchwin.o
+obj-$(CONFIG_TOUCHSCREEN_TSC2005)	+= tsc2005.o
 obj-$(CONFIG_TOUCHSCREEN_TSC2007)	+= tsc2007.o
 obj-$(CONFIG_TOUCHSCREEN_UCB1400)	+= ucb1400_ts.o
 obj-$(CONFIG_TOUCHSCREEN_WACOM_W8001)	+= wacom_w8001.o
diff --git a/drivers/input/touchscreen/tsc2005.c b/drivers/input/touchscreen/tsc2005.c
new file mode 100644
index 0000000..abc0548
--- /dev/null
+++ b/drivers/input/touchscreen/tsc2005.c
@@ -0,0 +1,958 @@
+/*
+ * TSC2005 touchscreen driver
+ *
+ * Copyright (C) 2006-2008 Nokia Corporation
+ *
+ * Author: Lauri Leukkunen <lauri.leukkunen@nokia.com>
+ * based on TSC2301 driver by Klaus K. Pedersen <klaus.k.pedersen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+
+#include <linux/spi/tsc2005.h>
+
+/**
+ * The touchscreen interface operates as follows:
+ *
+ * Initialize:
+ *    Request access to GPIO103 (DAV)
+ *    tsc2005_ts_irq_handler will trigger when DAV line goes down
+ *
+ *  1) Pen is pressed against touchscreeen
+ *  2) TSC2005 performs AD conversion
+ *  3) After the conversion is done TSC2005 drives DAV line down
+ *  4) GPIO IRQ is received and tsc2005_ts_irq_handler is called
+ *  5) tsc2005_ts_irq_handler queues up an spi transfer to fetch
+ *     the x, y, z1, z2 values
+ *  6) tsc2005_ts_rx() reports coordinates to input layer and
+ *     sets up tsc2005_ts_timer() to be called after TSC2005_TS_SCAN_TIME
+ *  7)  When the penup_timer expires, there have not been DAV interrupts
+ *     during the last 20ms which means the pen has been lifted.
+ */
+
+#define TSC2005_VDD_LOWER_27
+
+#ifdef TSC2005_VDD_LOWER_27
+#define TSC2005_HZ     (10000000)
+#else
+#define TSC2005_HZ     (25000000)
+#endif
+
+#define TSC2005_CMD	(0x80)
+#define TSC2005_REG	(0x00)
+
+#define TSC2005_CMD_STOP	(1)
+#define TSC2005_CMD_10BIT	(0 << 2)
+#define TSC2005_CMD_12BIT	(1 << 2)
+
+#define TSC2005_CMD_SCAN_XYZZ	(0 << 3)
+#define TSC2005_CMD_SCAN_XY	(1 << 3)
+#define TSC2005_CMD_SCAN_X	(2 << 3)
+#define TSC2005_CMD_SCAN_Y	(3 << 3)
+#define TSC2005_CMD_SCAN_ZZ	(4 << 3)
+#define TSC2005_CMD_AUX_SINGLE	(5 << 3)
+#define TSC2005_CMD_TEMP1	(6 << 3)
+#define TSC2005_CMD_TEMP2	(7 << 3)
+#define TSC2005_CMD_AUX_CONT	(8 << 3)
+#define TSC2005_CMD_TEST_X_CONN	(9 << 3)
+#define TSC2005_CMD_TEST_Y_CONN	(10 << 3)
+#define TSC2005_CMD_TEST_SHORT	(11 << 3)
+/* command 12 reserved, according to 2008-03 erratum */
+#define TSC2005_CMD_DRIVE_XX	(13 << 3)
+#define TSC2005_CMD_DRIVE_YY	(14 << 3)
+#define TSC2005_CMD_DRIVE_YX	(15 << 3)
+
+#define TSC2005_REG_X		(0 << 3)
+#define TSC2005_REG_Y		(1 << 3)
+#define TSC2005_REG_Z1		(2 << 3)
+#define TSC2005_REG_Z2		(3 << 3)
+#define TSC2005_REG_AUX		(4 << 3)
+#define TSC2005_REG_TEMP1	(5 << 3)
+#define TSC2005_REG_TEMP2	(6 << 3)
+#define TSC2005_REG_STATUS	(7 << 3)
+#define TSC2005_REG_AUX_HIGH	(8 << 3)
+#define TSC2005_REG_AUX_LOW	(9 << 3)
+#define TSC2005_REG_TEMP_HIGH	(10 << 3)
+#define TSC2005_REG_TEMP_LOW	(11 << 3)
+#define TSC2005_REG_CFR0	(12 << 3)
+#define TSC2005_REG_CFR1	(13 << 3)
+#define TSC2005_REG_CFR2	(14 << 3)
+#define TSC2005_REG_FUNCTION	(15 << 3)
+
+#define TSC2005_REG_PND0	(1 << 1)
+#define TSC2005_REG_READ	(0x01)
+#define TSC2005_REG_WRITE	(0x00)
+
+
+#define TSC2005_CFR0_LONGSAMPLING	(1)
+#define TSC2005_CFR0_DETECTINWAIT	(1 << 1)
+#define TSC2005_CFR0_SENSETIME_32US	(0)
+#define TSC2005_CFR0_SENSETIME_96US	(1 << 2)
+#define TSC2005_CFR0_SENSETIME_544US	(1 << 3)
+#define TSC2005_CFR0_SENSETIME_2080US	(1 << 4)
+#define TSC2005_CFR0_SENSETIME_2656US	(0x001C)
+#define TSC2005_CFR0_PRECHARGE_20US	(0x0000)
+#define TSC2005_CFR0_PRECHARGE_84US	(0x0020)
+#define TSC2005_CFR0_PRECHARGE_276US	(0x0040)
+#define TSC2005_CFR0_PRECHARGE_1044US	(0x0080)
+#define TSC2005_CFR0_PRECHARGE_1364US	(0x00E0)
+#define TSC2005_CFR0_STABTIME_0US	(0x0000)
+#define TSC2005_CFR0_STABTIME_100US	(0x0100)
+#define TSC2005_CFR0_STABTIME_500US	(0x0200)
+#define TSC2005_CFR0_STABTIME_1MS	(0x0300)
+#define TSC2005_CFR0_STABTIME_5MS	(0x0400)
+#define TSC2005_CFR0_STABTIME_100MS	(0x0700)
+#define TSC2005_CFR0_CLOCK_4MHZ		(0x0000)
+#define TSC2005_CFR0_CLOCK_2MHZ		(0x0800)
+#define TSC2005_CFR0_CLOCK_1MHZ		(0x1000)
+#define TSC2005_CFR0_RESOLUTION12	(0x2000)
+#define TSC2005_CFR0_STATUS		(0x4000)
+#define TSC2005_CFR0_PENMODE		(0x8000)
+
+#define TSC2005_CFR0_INITVALUE	(TSC2005_CFR0_STABTIME_1MS  |	\
+				 TSC2005_CFR0_CLOCK_1MHZ    |	\
+				 TSC2005_CFR0_RESOLUTION12  |	\
+				 TSC2005_CFR0_PRECHARGE_276US | \
+				 TSC2005_CFR0_PENMODE)
+
+/* Bits common to both read and write of config register 0 */
+#define	TSC2005_CFR0_RW_MASK	0x3fff
+
+#define TSC2005_CFR1_BATCHDELAY_0MS	(0x0000)
+#define TSC2005_CFR1_BATCHDELAY_1MS	(0x0001)
+#define TSC2005_CFR1_BATCHDELAY_2MS	(0x0002)
+#define TSC2005_CFR1_BATCHDELAY_4MS	(0x0003)
+#define TSC2005_CFR1_BATCHDELAY_10MS	(0x0004)
+#define TSC2005_CFR1_BATCHDELAY_20MS	(0x0005)
+#define TSC2005_CFR1_BATCHDELAY_40MS	(0x0006)
+#define TSC2005_CFR1_BATCHDELAY_100MS	(0x0007)
+
+#define TSC2005_CFR1_INITVALUE	(TSC2005_CFR1_BATCHDELAY_4MS)
+
+#define TSC2005_CFR2_MAVE_TEMP	(0x0001)
+#define TSC2005_CFR2_MAVE_AUX	(0x0002)
+#define TSC2005_CFR2_MAVE_Z	(0x0004)
+#define TSC2005_CFR2_MAVE_Y	(0x0008)
+#define TSC2005_CFR2_MAVE_X	(0x0010)
+#define TSC2005_CFR2_AVG_1	(0x0000)
+#define TSC2005_CFR2_AVG_3	(0x0400)
+#define TSC2005_CFR2_AVG_7	(0x0800)
+#define TSC2005_CFR2_MEDIUM_1	(0x0000)
+#define TSC2005_CFR2_MEDIUM_3	(0x1000)
+#define TSC2005_CFR2_MEDIUM_7	(0x2000)
+#define TSC2005_CFR2_MEDIUM_15	(0x3000)
+
+#define TSC2005_CFR2_IRQ_MASK   (0xC000)
+#define TSC2005_CFR2_IRQ_DAV	(0x4000)
+#define TSC2005_CFR2_IRQ_PEN	(0x8000)
+#define TSC2005_CFR2_IRQ_PENDAV	(0x0000)
+
+#define TSC2005_CFR2_INITVALUE	(TSC2005_CFR2_IRQ_PENDAV |	\
+				 TSC2005_CFR2_MAVE_X    |	\
+				 TSC2005_CFR2_MAVE_Y    |	\
+				 TSC2005_CFR2_MAVE_Z    |	\
+				 TSC2005_CFR2_MEDIUM_15 |	\
+				 TSC2005_CFR2_AVG_7)
+
+#define MAX_12BIT					((1 << 12) - 1)
+#define TS_SAMPLES					4
+#define TSC2005_TS_PENUP_TIME				40
+
+static const u32 tsc2005_read_reg[] = {
+	(TSC2005_REG | TSC2005_REG_X | TSC2005_REG_READ) << 16,
+	(TSC2005_REG | TSC2005_REG_Y | TSC2005_REG_READ) << 16,
+	(TSC2005_REG | TSC2005_REG_Z1 | TSC2005_REG_READ) << 16,
+	(TSC2005_REG | TSC2005_REG_Z2 | TSC2005_REG_READ) << 16,
+};
+#define NUM_READ_REGS	(sizeof(tsc2005_read_reg)/sizeof(tsc2005_read_reg[0]))
+
+struct tsc2005 {
+	struct spi_device	*spi;
+
+	struct input_dev	*idev;
+	char			phys[32];
+	struct timer_list	penup_timer;
+
+	/* ESD recovery via a hardware reset if the tsc2005
+	 * doesn't respond after a configurable period (in ms) of
+	 * IRQ/SPI inactivity. If esd_timeout is 0, timer and work
+	 * fields are used.
+	 */
+	u32			esd_timeout;
+	struct timer_list	esd_timer;
+	struct work_struct	esd_work;
+
+	spinlock_t		lock;
+	struct mutex		mutex;
+
+	struct spi_message	read_msg;
+	struct spi_transfer	read_xfer[NUM_READ_REGS];
+	u32                     data[NUM_READ_REGS];
+
+	/* previously reported x,y,p (if pen_down) */
+	int			out_x;
+	int			out_y;
+	int			out_p;
+	/* fudge parameters - changes must exceed one of these. */
+	int			fudge_x;
+	int			fudge_y;
+	int			fudge_p;
+	/* raw copy of previous x,y,z */
+	int			in_x;
+	int			in_y;
+	int			in_z1;
+	int			in_z2;
+	/* average accumulators for each component */
+	int			sample_cnt;
+	int			avg_x;
+	int			avg_y;
+	int			avg_z1;
+	int			avg_z2;
+	/* configuration */
+	int			x_plate_ohm;
+	int			hw_avg_max;
+	int			stab_time;
+	int			p_max;
+	int			touch_pressure;
+	/* status */
+	u8			sample_sent;
+	u8			pen_down;
+	u8			disabled;
+	u8			disable_depth;
+	u8			spi_pending;
+
+	void (*set_reset)(bool enable);
+};
+
+static void tsc2005_cmd(struct tsc2005 *ts, u8 cmd)
+{
+	u8 data = TSC2005_CMD | TSC2005_CMD_12BIT | cmd;
+	struct spi_message msg;
+	struct spi_transfer xfer = { 0 };
+
+	xfer.tx_buf = &data;
+	xfer.rx_buf = NULL;
+	xfer.len = 1;
+	xfer.bits_per_word = 8;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfer, &msg);
+	spi_sync(ts->spi, &msg);
+}
+
+static void tsc2005_write(struct tsc2005 *ts, u8 reg, u16 value)
+{
+	u32 tx;
+	struct spi_message msg;
+	struct spi_transfer xfer = { 0 };
+
+	tx = (TSC2005_REG | reg | TSC2005_REG_PND0 |
+	       TSC2005_REG_WRITE) << 16;
+	tx |= value;
+
+	xfer.tx_buf = &tx;
+	xfer.rx_buf = NULL;
+	xfer.len = 4;
+	xfer.bits_per_word = 24;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfer, &msg);
+	spi_sync(ts->spi, &msg);
+}
+
+static void tsc2005_read(struct tsc2005 *ts, u8 reg, u16 *value)
+{
+	u32 tx;
+	u32 rx = 0;
+	struct spi_message msg;
+	struct spi_transfer xfer = { 0 };
+
+	tx = (TSC2005_REG | reg | TSC2005_REG_READ) << 16;
+
+	xfer.tx_buf = &tx;
+	xfer.rx_buf = &rx;
+	xfer.len = 4;
+	xfer.bits_per_word = 24;
+
+	spi_message_init(&msg);
+	spi_message_add_tail(&xfer, &msg);
+	spi_sync(ts->spi, &msg);
+	*value = rx;
+}
+
+static void tsc2005_ts_update_pen_state(struct tsc2005 *ts,
+					int x, int y, int pressure)
+{
+	if (pressure) {
+		input_report_abs(ts->idev, ABS_X, x);
+		input_report_abs(ts->idev, ABS_Y, y);
+		input_report_abs(ts->idev, ABS_PRESSURE, pressure);
+		if (!ts->pen_down) {
+			input_report_key(ts->idev, BTN_TOUCH, 1);
+			ts->pen_down = 1;
+		}
+	} else {
+		input_report_abs(ts->idev, ABS_PRESSURE, 0);
+		if (ts->pen_down) {
+			input_report_key(ts->idev, BTN_TOUCH, 0);
+			ts->pen_down = 0;
+		}
+	}
+
+	input_sync(ts->idev);
+}
+
+/*
+ * This function is called by the SPI framework after the coordinates
+ * have been read from TSC2005
+ */
+static void tsc2005_ts_rx(void *arg)
+{
+	struct tsc2005 *ts = arg;
+	unsigned long flags;
+	int inside_rect, pressure_limit;
+	int x, y, z1, z2, pressure;
+
+	spin_lock_irqsave(&ts->lock, flags);
+
+	if (ts->disable_depth) {
+		ts->spi_pending = 0;
+		goto out;
+	}
+
+	x = ts->data[0];
+	y = ts->data[1];
+	z1 = ts->data[2];
+	z2 = ts->data[3];
+
+	/* validate pressure and position */
+	if (x > MAX_12BIT || y > MAX_12BIT)
+		goto out;
+
+	/* skip coords if the pressure-components are out of range */
+	if (z1 < 100 || z2 > MAX_12BIT || z1 >= z2)
+		goto out;
+
+	/* skip point if this is a pen down with the exact same values as
+	 * the value before pen-up - that implies SPI fed us stale data
+	 */
+	if (!ts->pen_down &&
+	    ts->in_x == x &&
+	    ts->in_y == y &&
+	    ts->in_z1 == z1 &&
+	    ts->in_z2 == z2)
+		goto out;
+
+	/* At this point we are happy we have a valid and useful reading.
+	 * Remember it for later comparisons. We may now begin downsampling
+	 */
+	ts->in_x = x;
+	ts->in_y = y;
+	ts->in_z1 = z1;
+	ts->in_z2 = z2;
+
+	/* don't run average on the "pen down" event */
+	if (ts->sample_sent) {
+		ts->avg_x += x;
+		ts->avg_y += y;
+		ts->avg_z1 += z1;
+		ts->avg_z2 += z2;
+
+		if (++ts->sample_cnt < TS_SAMPLES)
+			goto out;
+
+		x = ts->avg_x / TS_SAMPLES;
+		y = ts->avg_y / TS_SAMPLES;
+		z1 = ts->avg_z1 / TS_SAMPLES;
+		z2 = ts->avg_z2 / TS_SAMPLES;
+	}
+
+	ts->sample_cnt = 0;
+	ts->avg_x = 0;
+	ts->avg_y = 0;
+	ts->avg_z1 = 0;
+	ts->avg_z2 = 0;
+
+	pressure = x * (z2 - z1) / z1;
+	pressure = pressure * ts->x_plate_ohm / 4096;
+
+	pressure_limit = ts->sample_sent ? ts->p_max : ts->touch_pressure;
+	if (pressure > pressure_limit)
+		goto out;
+
+	/* Discard the event if it still is within the previous rect -
+	 * unless the pressure is clearly harder, but then use previous
+	 * x,y position. If any coordinate deviates enough, fudging
+	 * of all three will still take place in the input layer.
+	 */
+	inside_rect = (ts->sample_sent &&
+		x > (int)ts->out_x - ts->fudge_x &&
+		x < (int)ts->out_x + ts->fudge_x &&
+		y > (int)ts->out_y - ts->fudge_y &&
+		y < (int)ts->out_y + ts->fudge_y);
+	if (inside_rect)
+		x = ts->out_x, y = ts->out_y;
+
+	if (!inside_rect || pressure < (ts->out_p - ts->fudge_p)) {
+		tsc2005_ts_update_pen_state(ts, x, y, pressure);
+		ts->sample_sent = 1;
+		ts->out_x = x;
+		ts->out_y = y;
+		ts->out_p = pressure;
+	}
+out:
+	if (ts->spi_pending > 1) {
+		/* One or more interrupts (sometimes several dozens)
+		 * occured while waiting for the SPI read - get
+		 * another read going.
+		 */
+		ts->spi_pending = 1;
+		if (spi_async(ts->spi, &ts->read_msg)) {
+			dev_err(&ts->spi->dev, "ts: spi_async() failed");
+			ts->spi_pending = 0;
+		}
+	} else
+		ts->spi_pending = 0;
+
+	/* kick pen up timer - to make sure it expires again(!) */
+	if (ts->sample_sent) {
+		mod_timer(&ts->penup_timer,
+			  jiffies + msecs_to_jiffies(TSC2005_TS_PENUP_TIME));
+		/* Also kick the watchdog, as we still think we're alive */
+		if (ts->esd_timeout && ts->disable_depth == 0) {
+			unsigned long wdj = msecs_to_jiffies(ts->esd_timeout);
+			mod_timer(&ts->esd_timer, round_jiffies(jiffies+wdj));
+		}
+	}
+	spin_unlock_irqrestore(&ts->lock, flags);
+}
+
+/* This penup timer is very forgiving of delayed SPI reads. The
+ * (ESD) watchdog will rescue us if spi_pending remains set, unless
+ * we are enterring the disabled state. In that case we must just
+ * handle the pen up, and let disabling complete.
+ */
+static void tsc2005_ts_penup_timer_handler(unsigned long data)
+{
+	struct tsc2005 *ts = (struct tsc2005 *)data;
+	if ((!ts->spi_pending || ts->disable_depth) &&
+	    ts->sample_sent) {
+		tsc2005_ts_update_pen_state(ts, 0, 0, 0);
+		ts->sample_sent = 0;
+	}
+}
+
+/*
+ * This interrupt is called when pen is down and coordinates are
+ * available. That is indicated by a either:
+ * a) a rising edge on PINTDAV or (PENDAV mode)
+ * b) a falling edge on DAV line (DAV mode)
+ * depending on the setting of the IRQ bits in the CFR2 setting above.
+ */
+static irqreturn_t tsc2005_ts_irq_handler(int irq, void *dev_id)
+{
+	struct tsc2005 *ts = dev_id;
+	if (ts->disable_depth)
+		goto out;
+
+	if (!ts->spi_pending) {
+		if (spi_async(ts->spi, &ts->read_msg)) {
+			dev_err(&ts->spi->dev, "ts: spi_async() failed");
+			goto out;
+		}
+	}
+	/* By shifting in 1s we can never wrap */
+	ts->spi_pending = (ts->spi_pending<<1)+1;
+
+	/* Kick pen up timer only if it's not been started yet. Strictly,
+	 * it isn't even necessary to start it at all here,  but doing so
+	 * keeps an equivalence between pen state and timer state.
+	 * The SPI read loop will keep pushing it into the future.
+	 * If it times out with an SPI pending, it's ignored anyway.
+	 */
+	if (!timer_pending(&ts->penup_timer)) {
+		unsigned long pu = msecs_to_jiffies(TSC2005_TS_PENUP_TIME);
+		ts->penup_timer.expires = jiffies + pu;
+		add_timer(&ts->penup_timer);
+	}
+out:
+	return IRQ_HANDLED;
+}
+
+static void tsc2005_ts_setup_spi_xfer(struct tsc2005 *ts)
+{
+	struct spi_message *m = &ts->read_msg;
+	struct spi_transfer *x = &ts->read_xfer[0];
+	int i;
+
+	spi_message_init(m);
+
+	for (i = 0; i < NUM_READ_REGS; i++, x++) {
+		x->tx_buf = &tsc2005_read_reg[i];
+		x->rx_buf = &ts->data[i];
+		x->len = 4;
+		x->bits_per_word = 24;
+		x->cs_change = i < (NUM_READ_REGS - 1);
+		spi_message_add_tail(x, m);
+	}
+
+	m->complete = tsc2005_ts_rx;
+	m->context = ts;
+}
+
+static ssize_t tsc2005_ts_pen_down_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct tsc2005 *ts = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", ts->pen_down);
+}
+
+static DEVICE_ATTR(pen_down, S_IRUGO, tsc2005_ts_pen_down_show, NULL);
+
+static int tsc2005_configure(struct tsc2005 *ts, int flags)
+{
+	tsc2005_write(ts, TSC2005_REG_CFR0, TSC2005_CFR0_INITVALUE);
+	tsc2005_write(ts, TSC2005_REG_CFR1, TSC2005_CFR1_INITVALUE);
+	tsc2005_write(ts, TSC2005_REG_CFR2, TSC2005_CFR2_INITVALUE);
+	tsc2005_cmd(ts, flags);
+
+	return 0;
+}
+
+static void tsc2005_start_scan(struct tsc2005 *ts)
+{
+	tsc2005_configure(ts, TSC2005_CMD_SCAN_XYZZ);
+}
+
+static void tsc2005_stop_scan(struct tsc2005 *ts)
+{
+	tsc2005_cmd(ts, TSC2005_CMD_STOP);
+}
+
+/* Must be called with mutex held */
+static void tsc2005_disable(struct tsc2005 *ts)
+{
+	if (ts->disable_depth++ != 0)
+		return;
+
+	disable_irq(ts->spi->irq);
+	if (ts->esd_timeout)
+		del_timer(&ts->esd_timer);
+
+	/* wait until penup timer expire normally */
+	do {
+		msleep(4);
+	} while (ts->sample_sent);
+
+	tsc2005_stop_scan(ts);
+}
+
+static void tsc2005_enable(struct tsc2005 *ts)
+{
+	if (ts->disable_depth != 1)
+		goto out;
+
+	if (ts->esd_timeout) {
+		unsigned long wdj = msecs_to_jiffies(ts->esd_timeout);
+		ts->esd_timer.expires = round_jiffies(jiffies+wdj);
+		add_timer(&ts->esd_timer);
+	}
+	tsc2005_start_scan(ts);
+	enable_irq(ts->spi->irq);
+out:
+	--ts->disable_depth;
+}
+
+static ssize_t tsc2005_disable_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct tsc2005 *ts = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", ts->disabled);
+}
+
+static ssize_t tsc2005_disable_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct tsc2005		*ts = dev_get_drvdata(dev);
+	unsigned long res;
+	int i;
+
+	if (strict_strtoul(buf, 10, &res) < 0)
+		return -EINVAL;
+	i = res ? 1 : 0;
+
+	mutex_lock(&ts->mutex);
+	if (i == ts->disabled)
+		goto out;
+	ts->disabled = i;
+
+	if (i)
+		tsc2005_disable(ts);
+	else
+		tsc2005_enable(ts);
+out:
+	mutex_unlock(&ts->mutex);
+	return count;
+}
+
+static DEVICE_ATTR(disable_ts, 0664, tsc2005_disable_show,
+		   tsc2005_disable_store);
+
+static ssize_t tsc2005_ctrl_selftest_show(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	u16 temp_high_orig, temp_high_test, temp_high;
+	unsigned int result = 1;
+	struct tsc2005 *ts = dev_get_drvdata(dev);
+
+	if (!ts->set_reset) {
+		dev_warn(&ts->spi->dev,
+			 "unable to selftest: reset not configured\n");
+		result = 0;
+		goto out;
+	}
+
+	mutex_lock(&ts->mutex);
+	tsc2005_disable(ts);
+
+	/* Test ctrl communications via temp high / low registers */
+	tsc2005_read(ts, TSC2005_REG_TEMP_HIGH, &temp_high_orig);
+
+	temp_high_test = (temp_high_orig - 1) & 0x0FFF;
+
+	tsc2005_write(ts, TSC2005_REG_TEMP_HIGH, temp_high_test);
+
+	tsc2005_read(ts, TSC2005_REG_TEMP_HIGH, &temp_high);
+
+	if (temp_high != temp_high_test) {
+		result = 0;
+		dev_warn(dev, "selftest failed: %d != %d\n",
+			 temp_high, temp_high_test);
+	}
+
+	/* HW Reset */
+	ts->set_reset(0);
+	msleep(1); /* only 10us required */
+	ts->set_reset(1);
+
+	tsc2005_enable(ts);
+
+	/* Test that reset really happened */
+	tsc2005_read(ts, TSC2005_REG_TEMP_HIGH, &temp_high);
+
+	if (temp_high != temp_high_orig) {
+		result = 0;
+		dev_warn(dev, "selftest failed after reset: "
+			 "%d != %d\n",
+			 temp_high, temp_high_orig);
+	}
+
+	mutex_unlock(&ts->mutex);
+
+out:
+	return sprintf(buf, "%u\n", result);
+}
+
+static DEVICE_ATTR(ts_ctrl_selftest, S_IRUGO, tsc2005_ctrl_selftest_show, NULL);
+
+static void tsc2005_esd_timer_handler(unsigned long data)
+{
+	struct tsc2005 *ts = (struct tsc2005 *)data;
+	if (!ts->disable_depth)
+		schedule_work(&ts->esd_work);
+}
+
+static void tsc2005_rst_handler(struct work_struct *work)
+{
+	u16 reg_val;
+	struct tsc2005 *ts = container_of(work, struct tsc2005, esd_work);
+	unsigned long wdj;
+
+	mutex_lock(&ts->mutex);
+
+	/* If we are disabled, or the a touch has been detected,
+	 * then ignore this timeout. The enable will restart the
+	 * watchdog, as it restarts scanning
+	 */
+	if (ts->disable_depth)
+		goto out;
+
+	/* If we cannot read our known value from configuration register 0
+	 * then reset the controller as if from power-up and start
+	 * scanning again. Always re-arm the watchdog.
+	 */
+	tsc2005_read(ts, TSC2005_REG_CFR0, &reg_val);
+	if ((reg_val ^ TSC2005_CFR0_INITVALUE) & TSC2005_CFR0_RW_MASK) {
+		dev_info(&ts->spi->dev, "TSC not responding, resetting.\n");
+		/* If this timer kicked in, the penup timer, if ever active
+		 * at all, must have expired ages ago, so no need to del it.
+		 */
+		ts->set_reset(0);
+		if (ts->sample_sent) {
+			tsc2005_ts_update_pen_state(ts, 0, 0, 0);
+			ts->sample_sent = 0;
+		}
+		ts->spi_pending = 0;
+		msleep(1); /* only 10us required */
+		ts->set_reset(1);
+		tsc2005_start_scan(ts);
+	}
+	wdj = msecs_to_jiffies(ts->esd_timeout);
+	mod_timer(&ts->esd_timer, round_jiffies(jiffies+wdj));
+
+out:
+	mutex_unlock(&ts->mutex);
+}
+
+static int __devinit tsc2005_ts_init(struct tsc2005 *ts,
+				     struct tsc2005_platform_data *pdata)
+{
+	struct input_dev *idev;
+	int r;
+	int x_max, y_max;
+
+	init_timer(&ts->penup_timer);
+	setup_timer(&ts->penup_timer, tsc2005_ts_penup_timer_handler,
+			(unsigned long)ts);
+
+	spin_lock_init(&ts->lock);
+	mutex_init(&ts->mutex);
+
+	ts->x_plate_ohm		= pdata->ts_x_plate_ohm ? : 280;
+	ts->hw_avg_max		= pdata->ts_hw_avg;
+	ts->stab_time		= pdata->ts_stab_time;
+	x_max			= pdata->ts_x_max ? : 4096;
+	ts->fudge_x		= pdata->ts_x_fudge ? : 4;
+	y_max			= pdata->ts_y_max ? : 4096;
+	ts->fudge_y		= pdata->ts_y_fudge ? : 8;
+	ts->p_max		= pdata->ts_pressure_max ? : MAX_12BIT;
+	ts->touch_pressure	= pdata->ts_touch_pressure ? : ts->p_max;
+	ts->fudge_p		= pdata->ts_pressure_fudge ? : 2;
+
+	ts->set_reset		= pdata->set_reset;
+
+	idev = input_allocate_device();
+	if (idev == NULL) {
+		r = -ENOMEM;
+		goto err1;
+	}
+
+	idev->name = "TSC2005 touchscreen";
+	snprintf(ts->phys, sizeof(ts->phys), "%s/input-ts",
+		 dev_name(&ts->spi->dev));
+	idev->phys = ts->phys;
+
+	idev->evbit[0] = BIT(EV_ABS) | BIT(EV_KEY);
+	idev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y) | BIT(ABS_PRESSURE);
+	idev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+	ts->idev = idev;
+
+	tsc2005_ts_setup_spi_xfer(ts);
+
+	input_set_abs_params(idev, ABS_X, 0, x_max, ts->fudge_x, 0);
+	input_set_abs_params(idev, ABS_Y, 0, y_max, ts->fudge_y, 0);
+	input_set_abs_params(idev, ABS_PRESSURE, 0, ts->p_max, ts->fudge_p, 0);
+
+	tsc2005_start_scan(ts);
+
+	r = request_irq(ts->spi->irq, tsc2005_ts_irq_handler,
+			(((TSC2005_CFR2_INITVALUE & TSC2005_CFR2_IRQ_MASK) ==
+			  TSC2005_CFR2_IRQ_PENDAV)
+			 ? IRQF_TRIGGER_RISING
+			 : IRQF_TRIGGER_FALLING) |
+			IRQF_DISABLED, "tsc2005", ts);
+	if (r < 0) {
+		dev_err(&ts->spi->dev, "unable to get DAV IRQ");
+		goto err2;
+	}
+
+	set_irq_wake(ts->spi->irq, 1);
+
+	r = input_register_device(idev);
+	if (r < 0) {
+		dev_err(&ts->spi->dev, "can't register touchscreen device\n");
+		goto err3;
+	}
+
+	/* We can tolerate these failing */
+	r = device_create_file(&ts->spi->dev, &dev_attr_ts_ctrl_selftest);
+	if (r < 0)
+		dev_warn(&ts->spi->dev, "can't create sysfs file for %s: %d\n",
+			 dev_attr_ts_ctrl_selftest.attr.name, r);
+
+	r = device_create_file(&ts->spi->dev, &dev_attr_pen_down);
+	if (r < 0)
+		dev_warn(&ts->spi->dev, "can't create sysfs file for %s: %d\n",
+			 dev_attr_pen_down.attr.name, r);
+
+	r = device_create_file(&ts->spi->dev, &dev_attr_disable_ts);
+	if (r < 0)
+		dev_warn(&ts->spi->dev, "can't create sysfs file for %s: %d\n",
+			 dev_attr_disable_ts.attr.name, r);
+
+	/* Finally, configure and start the optional EDD watchdog. */
+	ts->esd_timeout = pdata->esd_timeout;
+	if (ts->esd_timeout && ts->set_reset) {
+		unsigned long wdj;
+		setup_timer(&ts->esd_timer, tsc2005_esd_timer_handler,
+			    (unsigned long)ts);
+		INIT_WORK(&ts->esd_work, tsc2005_rst_handler);
+		wdj = msecs_to_jiffies(ts->esd_timeout);
+		ts->esd_timer.expires = round_jiffies(jiffies+wdj);
+		add_timer(&ts->esd_timer);
+	}
+
+	return 0;
+err3:
+	free_irq(ts->spi->irq, ts);
+err2:
+	tsc2005_stop_scan(ts);
+	input_free_device(idev);
+err1:
+	return r;
+}
+
+static int __devinit tsc2005_probe(struct spi_device *spi)
+{
+	struct tsc2005			*ts;
+	struct tsc2005_platform_data	*pdata = spi->dev.platform_data;
+	int r;
+
+	if (spi->irq < 0) {
+		dev_dbg(&spi->dev, "no irq?\n");
+		return -ENODEV;
+	}
+	if (!pdata) {
+		dev_dbg(&spi->dev, "no platform data?\n");
+		return -ENODEV;
+	}
+
+	ts = kzalloc(sizeof(*ts), GFP_KERNEL);
+	if (ts == NULL)
+		return -ENOMEM;
+
+	dev_set_drvdata(&spi->dev, ts);
+	ts->spi = spi;
+	spi->dev.power.power_state = PMSG_ON;
+
+	spi->mode = SPI_MODE_0;
+	spi->bits_per_word = 8;
+	/* The max speed might've been defined by the board-specific
+	 * struct */
+	if (!spi->max_speed_hz)
+		spi->max_speed_hz = TSC2005_HZ;
+
+	spi_setup(spi);
+
+	r = tsc2005_ts_init(ts, pdata);
+	if (r)
+		goto err1;
+
+	return 0;
+
+err1:
+	kfree(ts);
+	return r;
+}
+
+static int __devexit tsc2005_remove(struct spi_device *spi)
+{
+	struct tsc2005 *ts = dev_get_drvdata(&spi->dev);
+
+	mutex_lock(&ts->mutex);
+	tsc2005_disable(ts);
+	mutex_unlock(&ts->mutex);
+
+	device_remove_file(&ts->spi->dev, &dev_attr_disable_ts);
+	device_remove_file(&ts->spi->dev, &dev_attr_pen_down);
+	device_remove_file(&ts->spi->dev, &dev_attr_ts_ctrl_selftest);
+
+	free_irq(ts->spi->irq, ts);
+	input_unregister_device(ts->idev);
+
+	if (ts->esd_timeout)
+		del_timer(&ts->esd_timer);
+	kfree(ts);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int tsc2005_suspend(struct spi_device *spi, pm_message_t mesg)
+{
+	struct tsc2005 *ts = dev_get_drvdata(&spi->dev);
+
+	mutex_lock(&ts->mutex);
+	tsc2005_disable(ts);
+	mutex_unlock(&ts->mutex);
+
+	return 0;
+}
+
+static int tsc2005_resume(struct spi_device *spi)
+{
+	struct tsc2005 *ts = dev_get_drvdata(&spi->dev);
+
+	mutex_lock(&ts->mutex);
+	tsc2005_enable(ts);
+	mutex_unlock(&ts->mutex);
+
+	return 0;
+}
+#endif
+
+static struct spi_driver tsc2005_driver = {
+	.driver = {
+		.name = "tsc2005",
+		.owner = THIS_MODULE,
+	},
+#ifdef CONFIG_PM
+	.suspend = tsc2005_suspend,
+	.resume = tsc2005_resume,
+#endif
+	.probe = tsc2005_probe,
+	.remove = __devexit_p(tsc2005_remove),
+};
+
+static int __init tsc2005_init(void)
+{
+	printk(KERN_INFO "TSC2005 driver initializing\n");
+
+	return spi_register_driver(&tsc2005_driver);
+}
+module_init(tsc2005_init);
+
+static void __exit tsc2005_exit(void)
+{
+	spi_unregister_driver(&tsc2005_driver);
+}
+module_exit(tsc2005_exit);
+
+MODULE_AUTHOR("Lauri Leukkunen <lauri.leukkunen@nokia.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:tsc2005");
diff --git a/drivers/mfd/menelaus.c b/drivers/mfd/menelaus.c
index 970afa1..4a46bd6 100644
--- a/drivers/mfd/menelaus.c
+++ b/drivers/mfd/menelaus.c
@@ -355,9 +355,9 @@ int menelaus_set_mmc_slot(int slot, int enable, int power, int cd_en)
 		int b;
 
 		if (enable)
-			ret |= 1 << 1;
+			val |= 1 << 1;
 		else
-			ret &= ~(1 << 1);
+			val &= ~(1 << 1);
 		b = menelaus_read_reg(MENELAUS_MCT_CTRL2);
 		b &= ~0x03;
 		b |= power;
diff --git a/drivers/serial/Makefile b/drivers/serial/Makefile
index 0c3c225..d21d5dd 100644
--- a/drivers/serial/Makefile
+++ b/drivers/serial/Makefile
@@ -81,4 +81,3 @@ obj-$(CONFIG_SERIAL_KS8695) += serial_ks8695.o
 obj-$(CONFIG_KGDB_SERIAL_CONSOLE) += kgdboc.o
 obj-$(CONFIG_SERIAL_QE) += ucc_uart.o
 obj-$(CONFIG_SERIAL_TIMBERDALE)	+= timbuart.o
-obj-$(CONFIG_SERIAL_OMAP) += omap-serial.o
diff --git a/drivers/serial/omap-serial.c b/drivers/serial/omap-serial.c
deleted file mode 100644
index 5565bab..0000000
--- a/drivers/serial/omap-serial.c
+++ /dev/null
@@ -1,1782 +0,0 @@
-/*
- *  linux/drivers/serial/omap-serial.c
- *
- *  Modified: Manasa Gangaiah
- *  Copyright (C) 2009 Texas Instrument Inc.
- *
- *  Initial driver: Juha Yrjola
- *  Copyright (C) 2007 Nokia Corporation
- *
- *  Based on drivers/serial/pxa.c by Nicolas Pitre.
- *  Copyright (C) 2003 Monta Vista Software, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- */
-
-#if defined(CONFIG_SERIAL_OMAP_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
-#define SUPPORT_SYSRQ
-#endif
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/console.h>
-#include <linux/serial_reg.h>
-#include <linux/delay.h>
-#include <linux/platform_device.h>
-#include <linux/tty.h>
-#include <linux/tty_flip.h>
-#include <linux/serial_core.h>
-#include <linux/io.h>
-#include <linux/dma-mapping.h>
-#include <linux/wakelock.h>
-#include <linux/workqueue.h>
-
-#include <asm/irq.h>
-#include <asm/dma.h>
-
-#include <plat/dmtimer.h>
-#include <plat/omap-serial.h>
-#include <mach/gpio.h>
-#include <plat/dma.h>
-#include <plat/io.h>
-#ifdef CONFIG_OMAP3_PM
-#include <../arch/arm/mach-omap2/ti-compat.h>
-#include <../arch/arm/mach-omap2/prcm-regs.h>
-#endif
-#include <asm/mach/serial_omap.h>
-
-unsigned long isr8250_activity;
-
-#define CONSOLE_NAME	"console="
-
-#ifdef CONFIG_ARCH_OMAP34XX
-#define OMAP_MDR1_DISABLE 0x07
-#define OMAP_MDR1_MODE13X 0x03
-#define OMAP_MDR1_MODE16X 0x00
-#define OMAP_MODE13X_SPEED	230400
-#endif
-
-
-/* Debugging Macros */
-#undef DEBUG
-
-#ifdef DEBUG
-#define DPRINTK  printk
-#else
-#define DPRINTK(x...)
-#endif
-
-/*
- * We default to IRQ0 for the "no irq" hack.   Some
- * machine types want others as well - they're free
- * to redefine this in their header file.
- */
-#define is_real_interrupt(irq)  ((irq) != 0)
-
-/* TBD: move this to header file */
-static u8 uart_dma_tx[MAX_UARTS + 1] =
-    { OMAP24XX_DMA_UART1_TX, OMAP24XX_DMA_UART2_TX, OMAP24XX_DMA_UART3_TX };
-static u8 uart_dma_rx[MAX_UARTS + 1] =
-    { OMAP24XX_DMA_UART1_RX, OMAP24XX_DMA_UART2_RX, OMAP24XX_DMA_UART3_RX };
-
-
-struct uart_omap_dma {
-	int rx_dma_channel;
-	int tx_dma_channel;
-	dma_addr_t rx_buf_dma_phys;	/* Physical adress of RX DMA buffer */
-	dma_addr_t tx_buf_dma_phys;	/* Physical adress of TX DMA buffer */
-	/*
-	 * Buffer for rx dma.It is not required for tx because the buffer
-	 * comes from port structure
-	 */
-	unsigned char *rx_buf;
-	unsigned int prev_rx_dma_pos;
-	int tx_buf_size;
-	int tx_dma_state;
-	int rx_dma_state;
-	spinlock_t tx_lock;
-	spinlock_t rx_lock;
-	struct timer_list 	rx_timer;/* timer to poll activity on rx dma */
-	int rx_buf_size;
-	int rx_timeout;
-};
-
-struct uart_omap_port {
-	struct uart_port	port;
-	struct uart_omap_dma	uart_dma;
-	struct platform_device	*pdev;
-
-	unsigned char		ier;
-	unsigned char		lcr;
-	unsigned char		mcr;
-	int			use_dma;
-	int			is_buf_dma_alloced;
-	int			restore_autorts;
-	/*
-	 * Some bits in registers are cleared on a read, so they must
-	 * be saved whenever the register is read but the bits will not
-	 * be immediately processed.
-	 */
-	unsigned int		lsr_break_flag;
-#define MSR_SAVE_FLAGS UART_MSR_ANY_DELTA
-	unsigned char		msr_saved_flags;
-	char			name[12];
-	int			use_console;
-	spinlock_t		uart_lock;
-	char			dev_name[50];
-	struct work_struct	tty_work;
-};
-
-static struct uart_omap_port *ui[MAX_UARTS + 1];
-unsigned int fcr[MAX_UARTS];
-
-static struct wake_lock omap_serial_wakelock;
-static struct workqueue_struct *omap_serial_workqueue;
-
-/* Forward declaration of dma callback functions */
-static void uart_tx_dma_callback(int lch, u16 ch_status, void *data);
-static void serial_omap_display_reg(struct uart_port *port);
-static void serial_omap_rx_timeout(unsigned long uart_no);
-static void serial_omap_start_rxdma(struct uart_omap_port *up);
-static void serial_omap_set_autorts(struct uart_omap_port *p, int set);
-
-#define DBG_RX_DATA 0
-
-int console_detect(char *str)
-{
-	extern char *saved_command_line;
-	char *next, *start = NULL;
-	int i;
-
-	i = strlen(CONSOLE_NAME);
-	next = saved_command_line;
-
-	while ((next = strchr(next, 'c')) != NULL) {
-		if (!strncmp(next, CONSOLE_NAME, i)) {
-			start = next;
-			break;
-		} else {
-			next++;
-		}
-
-	}
-	if (!start)
-		return -EPERM;
-	i = 0;
-	start = strchr(start, '=') + 1;
-	while (*start != ',') {
-		str[i++] = *start++;
-		if (i > 6) {
-			printk(KERN_ERR "Invalid Console Name\n");
-			return -EPERM;
-		}
-	}
-	str[i] = '\0';
-	return 0;
-}
-
-static inline unsigned int serial_in(struct uart_omap_port *up, int offset)
-{
-	offset <<= up->port.regshift;
-	if (up->pdev->id != 4)
-		return readb(up->port.membase + offset);
-	else
-		return readw(up->port.membase + offset);
-}
-
-static inline void serial_out(struct uart_omap_port *up, int offset, int value)
-{
-	offset <<= up->port.regshift;
-	if (up->pdev->id != 4)
-		writeb(value, up->port.membase + offset);
-	else
-		writew(value, up->port.membase + offset);
-}
-
-static inline void serial_omap_clear_fifos(struct uart_omap_port *p)
-{
-		serial_out(p, UART_FCR, UART_FCR_ENABLE_FIFO);
-		serial_out(p, UART_FCR, UART_FCR_ENABLE_FIFO |
-			       UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
-		serial_out(p, UART_FCR, 0);
-		fcr[p->pdev->id - 1] = 0;
-}
-
-/*
- * We have written our own function to get the divisor so as to support
- * 13x mode. TBD see if this can be integrated with uart_get_divisor.
- */
-static unsigned int
-serial_omap_get_divisor(struct uart_port *port, unsigned int baud)
-{
-	unsigned int divisor;
-	if (baud > OMAP_MODE13X_SPEED && baud != 3000000)
-		divisor = 13;
-	else
-		divisor = 16;
-	return port->uartclk/(baud * divisor);
-}
-
-static void serial_omap_stop_rxdma(struct uart_omap_port *up)
-{
-	if (up->uart_dma.rx_dma_state) {
-		del_timer(&up->uart_dma.rx_timer);
-		omap_stop_dma(up->uart_dma.rx_dma_channel);
-		omap_free_dma(up->uart_dma.rx_dma_channel);
-		up->uart_dma.rx_dma_channel = 0xFF;
-		up->uart_dma.rx_dma_state = 0x0;
-	}
-}
-
-static void serial_omap_enable_ms(struct uart_port *port)
-{
-	struct uart_omap_port *up = (struct uart_omap_port *)port;
-
-	DPRINTK("serial_omap_enable_ms+%d\n", up->pdev->id);
-	up->ier |= UART_IER_MSI;
-	serial_out(up, UART_IER, up->ier);
-}
-
-static void serial_omap_stop_tx(struct uart_port *port)
-{
-	struct uart_omap_port *up = (struct uart_omap_port *)port;
-	if (up->use_dma && up->uart_dma.tx_dma_channel != 0xFF) {
-		/*
-		 * Check if dma is still active . If yes do nothing,
-		 * return. Else stop dma.
-		 */
-		int status = omap_readl(OMAP34XX_DMA4_BASE +
-				OMAP_DMA4_CCR(up->uart_dma.tx_dma_channel));
-		if (status & (1 << 7))
-			return;
-		omap_stop_dma(up->uart_dma.tx_dma_channel);
-		omap_free_dma(up->uart_dma.tx_dma_channel);
-		up->uart_dma.tx_dma_channel = 0xFF;
-	}
-
-	if (up->ier & UART_IER_THRI) {
-		up->ier &= ~UART_IER_THRI;
-		serial_out(up, UART_IER, up->ier);
-	}
-#ifdef CONFIG_PM
-	if (!up->uart_dma.rx_dma_state) {
-		unsigned int tmp;
-		tmp = (serial_in(up, UART_OMAP_SYSC) & 0x7) | (2 << 3);
-		serial_out(up, UART_OMAP_SYSC, tmp); /* smart-idle */
-	}
-#endif
-}
-
-static void serial_omap_stop_rx(struct uart_port *port)
-{
-	struct uart_omap_port *up = (struct uart_omap_port *)port;
-	serial_omap_stop_rxdma(up);
-	up->ier &= ~UART_IER_RLSI;
-	up->port.read_status_mask &= ~UART_LSR_DR;
-	serial_out(up, UART_IER, up->ier);
-
-}
-
-static inline void receive_chars(struct uart_omap_port *up, int *status)
-{
-	unsigned int ch, flag;
-	int max_count = 256;
-
-#if DBG_RX_DATA
-	printk("[RX]: ");
-#endif
-	do {
-		ch = serial_in(up, UART_RX);
-#if DBG_RX_DATA
-		if ((ch >= 32) && (ch < 127))
-			printk("%c", ch);
-		else
-			printk("{0x%.2x}", ch);
-#endif
-		flag = TTY_NORMAL;
-		up->port.icount.rx++;
-
-		if (unlikely(*status & (UART_LSR_BI | UART_LSR_PE |
-				       UART_LSR_FE | UART_LSR_OE))) {
-			/*
-			 * For statistics only
-			 */
-			if (*status & UART_LSR_BI) {
-				*status &= ~(UART_LSR_FE | UART_LSR_PE);
-				up->port.icount.brk++;
-				/*
-				 * We do the SysRQ and SAK checking
-				 * here because otherwise the break
-				 * may get masked by ignore_status_mask
-				 * or read_status_mask.
-				 */
-				if (uart_handle_break(&up->port))
-					goto ignore_char;
-			} else if (*status & UART_LSR_PE)
-				up->port.icount.parity++;
-			else if (*status & UART_LSR_FE)
-				up->port.icount.frame++;
-			if (*status & UART_LSR_OE)
-				up->port.icount.overrun++;
-
-			/*
-			 * Mask off conditions which should be ignored.
-			 */
-			*status &= up->port.read_status_mask;
-
-#ifdef CONFIG_SERIAL_OMAP_CONSOLE
-			if (up->port.line == up->port.cons->index) {
-				/* Recover the break flag from console xmit */
-				*status |= up->lsr_break_flag;
-				up->lsr_break_flag = 0;
-			}
-#endif
-			if (*status & UART_LSR_BI)
-				flag = TTY_BREAK;
-			else if (*status & UART_LSR_PE)
-				flag = TTY_PARITY;
-			else if (*status & UART_LSR_FE)
-				flag = TTY_FRAME;
-		}
-
-		if (uart_handle_sysrq_char(&up->port, ch))
-			goto ignore_char;
-
-		uart_insert_char(&up->port, *status, UART_LSR_OE, ch, flag);
-
-ignore_char:
-		*status = serial_in(up, UART_LSR);
-	} while ((*status & UART_LSR_DR) && (max_count-- > 0));
-
-	queue_work(omap_serial_workqueue, &up->tty_work);
-
-#if DBG_RX_DATA
-	printk("\n");
-#endif
-}
-
-static void tty_flip_buffer_work(struct work_struct *work)
-{
-	struct uart_omap_port *up =
-			container_of(work, struct uart_omap_port, tty_work);
-	struct tty_struct *tty = up->port.state->port.tty;
-
-	tty_flip_buffer_push(tty);
-}
-
-static void transmit_chars(struct uart_omap_port *up)
-{
-	struct circ_buf *xmit = &up->port.state->xmit;
-	int count;
-
-	if (up->port.x_char) {
-		serial_out(up, UART_TX, up->port.x_char);
-		up->port.icount.tx++;
-		up->port.x_char = 0;
-		return;
-	}
-	if (uart_circ_empty(xmit) || uart_tx_stopped(&up->port)) {
-		serial_omap_stop_tx(&up->port);
-		return;
-	}
-
-	count = up->port.fifosize / 4;
-
-	do {
-		serial_out(up, UART_TX, xmit->buf[xmit->tail]);
-		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
-		up->port.icount.tx++;
-		if (uart_circ_empty(xmit))
-			break;
-	} while (--count > 0);
-
-	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
-		uart_write_wakeup(&up->port);
-
-	if (uart_circ_empty(xmit))
-		serial_omap_stop_tx(&up->port);
-}
-
-static void serial_omap_start_tx(struct uart_port *port)
-{
-	struct uart_omap_port *up = (struct uart_omap_port *)port;
-#ifdef CONFIG_PM
-		/* Disallow OCP bus idle. UART TX irqs are not seen during
-		 * bus idle. Alternative is to set kernel timer at fifo
-		 * drain rate.
-		 */
-		unsigned int tmp;
-		tmp = (serial_in(up, UART_OMAP_SYSC) & 0x7) | (1 << 3);
-		serial_out(up, UART_OMAP_SYSC, tmp); /* no-idle */
-#endif
-
-	if (up->use_dma && !(up->port.x_char)) {
-
-		struct circ_buf *xmit = &up->port.state->xmit;
-		unsigned int start = up->uart_dma.tx_buf_dma_phys +
-				     (xmit->tail & (UART_XMIT_SIZE - 1));
-		if (uart_circ_empty(xmit) || up->uart_dma.tx_dma_state)
-			return;
-		spin_lock(&(up->uart_dma.tx_lock));
-		up->uart_dma.tx_dma_state = 1;
-		spin_unlock(&(up->uart_dma.tx_lock));
-
-		up->uart_dma.tx_buf_size = uart_circ_chars_pending(xmit);
-		/* It is a circular buffer. See if the buffer has wounded back.
-		 * If yes it will have to be transferred in two separate dma
-		 * transfers */
-		if (start + up->uart_dma.tx_buf_size >= up->uart_dma.tx_buf_dma_phys + UART_XMIT_SIZE)
-			up->uart_dma.tx_buf_size = (up->uart_dma.tx_buf_dma_phys + UART_XMIT_SIZE) - start;
-
-		if (up->uart_dma.tx_dma_channel == 0xFF) {
-			omap_request_dma(uart_dma_tx[up->pdev->id-1],
-					 "UART Tx DMA",
-					 (void *)uart_tx_dma_callback, up,
-					&(up->uart_dma.tx_dma_channel));
-		}
-		omap_set_dma_dest_params(up->uart_dma.tx_dma_channel, 0,
-					 OMAP_DMA_AMODE_CONSTANT,
-					 UART_BASE(up->pdev->id - 1), 0, 0);
-		omap_set_dma_src_params(up->uart_dma.tx_dma_channel, 0,
-			OMAP_DMA_AMODE_POST_INC, start, 0, 0);
-
-		omap_set_dma_transfer_params(up->uart_dma.tx_dma_channel,
-					     OMAP_DMA_DATA_TYPE_S8,
-					     up->uart_dma.tx_buf_size, 1,
-					     OMAP_DMA_SYNC_ELEMENT,
-					     uart_dma_tx[(up->pdev->id)-1], 0);
-
-		omap_start_dma(up->uart_dma.tx_dma_channel);
-
-	} else if (!(up->ier & UART_IER_THRI)) {
-		up->ier |= UART_IER_THRI;
-		serial_out(up, UART_IER, up->ier);
-	}
-
-	if (up->restore_autorts) {
-		serial_omap_set_autorts(up, 1);
-		up->restore_autorts = 0;
-	}
-}
-
-static unsigned int check_modem_status(struct uart_omap_port *up)
-{
-	int status;
-	status = serial_in(up, UART_MSR);
-
-	status |= up->msr_saved_flags;
-	up->msr_saved_flags = 0;
-
-	if ((status & UART_MSR_ANY_DELTA) == 0)
-		return status;
-	if (status & UART_MSR_ANY_DELTA && up->ier & UART_IER_MSI &&
-	    up->port.state != NULL) {
-		if (status & UART_MSR_TERI)
-			up->port.icount.rng++;
-		if (status & UART_MSR_DDSR)
-			up->port.icount.dsr++;
-		if (status & UART_MSR_DDCD)
-			uart_handle_dcd_change
-				(&up->port, status & UART_MSR_DCD);
-		if (status & UART_MSR_DCTS)
-			uart_handle_cts_change
-				(&up->port, status & UART_MSR_CTS);
-		wake_up_interruptible(&up->port.state->port.delta_msr_wait);
-	}
-
-	return status;
-}
-
-/*
- * This handles the interrupt from one port.
- */
-static inline irqreturn_t serial_omap_irq(int irq, void *dev_id)
-{
-	struct uart_omap_port *up = dev_id;
-	unsigned int iir, lsr;
-
-	iir = serial_in(up, UART_IIR);
-	if (iir & UART_IIR_NO_INT)
-		return IRQ_NONE;
-	lsr = serial_in(up, UART_LSR);
-	if ((iir & 0x4) && up->use_dma) {
-		up->ier &= ~UART_IER_RDI;
-		serial_out(up, UART_IER, up->ier);
-		serial_omap_start_rxdma(up);
-	} else if (lsr & UART_LSR_DR) {
-		receive_chars(up, &lsr);
-		/* XXX: After driver resume optimization, lower this */
-		wake_lock_timeout(&omap_serial_wakelock, (HZ * 1));
-	}
-	check_modem_status(up);
-	if ((lsr & UART_LSR_THRE) && (iir & 0x2))
-		transmit_chars(up);
-	isr8250_activity = jiffies;
-
-	return IRQ_HANDLED;
-}
-
-static unsigned int serial_omap_tx_empty(struct uart_port *port)
-{
-	struct uart_omap_port *up = (struct uart_omap_port *)port;
-	unsigned long flags;
-	unsigned int ret;
-
-	DPRINTK("serial_omap_tx_empty+%d\n", up->pdev->id);
-	spin_lock_irqsave(&up->port.lock, flags);
-	ret = serial_in(up, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;
-	spin_unlock_irqrestore(&up->port.lock, flags);
-
-	return ret;
-}
-
-static unsigned int serial_omap_get_mctrl(struct uart_port *port)
-{
-	struct uart_omap_port *up = (struct uart_omap_port *)port;
-	unsigned char status;
-	unsigned int ret;
-
-	status = check_modem_status(up);
-	DPRINTK("serial_omap_get_mctrl+%d\n", up->pdev->id);
-
-	ret = 0;
-	if (status & UART_MSR_DCD)
-		ret |= TIOCM_CAR;
-	if (status & UART_MSR_RI)
-		ret |= TIOCM_RNG;
-	if (status & UART_MSR_DSR)
-		ret |= TIOCM_DSR;
-	if (status & UART_MSR_CTS)
-		ret |= TIOCM_CTS;
-	return ret;
-}
-
-static void serial_omap_set_mctrl(struct uart_port *port, unsigned int mctrl)
-{
-	struct uart_omap_port *up = (struct uart_omap_port *)port;
-	unsigned char mcr = 0;
-
-	DPRINTK("serial_omap_set_mctrl+%d\n", up->pdev->id);
-	if (mctrl & TIOCM_RTS) {
-		/*
-		 * We need to be careful not to cause
-		 * RTS to assert when we have a pending
-		 * auto-rts restore.
-		 */
-		if (!up->restore_autorts)
-			mcr |= UART_MCR_RTS;
-	}
-	if (mctrl & TIOCM_DTR)
-		mcr |= UART_MCR_DTR;
-	if (mctrl & TIOCM_OUT1)
-		mcr |= UART_MCR_OUT1;
-	if (mctrl & TIOCM_OUT2)
-		mcr |= UART_MCR_OUT2;
-	if (mctrl & TIOCM_LOOP)
-		mcr |= UART_MCR_LOOP;
-
-	mcr |= up->mcr;
-	serial_out(up, UART_MCR, mcr);
-}
-
-static void serial_omap_break_ctl(struct uart_port *port, int break_state)
-{
-	struct uart_omap_port *up = (struct uart_omap_port *)port;
-	unsigned long flags;
-
-	DPRINTK("serial_omap_break_ctl+%d\n", up->pdev->id);
-	spin_lock_irqsave(&up->port.lock, flags);
-	if (break_state == -1)
-		up->lcr |= UART_LCR_SBC;
-	else
-		up->lcr &= ~UART_LCR_SBC;
-	serial_out(up, UART_LCR, up->lcr);
-	spin_unlock_irqrestore(&up->port.lock, flags);
-}
-
-static void serial_omap_wake_peer(struct uart_port *port)
-{
-	struct uart_omap_port *up = (struct uart_omap_port *)port;
-	struct plat_serialomap_port *pd = up->pdev->dev.platform_data;
-	if (pd->wake_gpio_strobe) {
-		gpio_direction_output(pd->wake_gpio_strobe, 1);
-		udelay(5);
-		gpio_direction_output(pd->wake_gpio_strobe, 0);
-		udelay(5);
-	}
-}
-
-static void serial_omap_set_autorts(struct uart_omap_port *p, int set)
-{
-        u8 lcr_val = 0, mcr_val = 0, efr_val = 0;
-        u8 lcr_backup = 0, mcr_backup = 0, efr_backup = 0;
-
-        lcr_val = serial_in(p, UART_LCR);
-        lcr_backup = lcr_val;
-	/* Enter Config mode B */
-        serial_out(p, UART_LCR, 0xbf);
-
-        efr_val = serial_in(p, UART_EFR);
-        efr_backup = efr_val;
-
-	/*
-	 * Enhanced functions write enable.
-	 * Enables writes to IER[7:4], FCR[5:4], MCR[7:5]
-	 */
-        serial_out(p, UART_EFR, efr_val | 0x10);
-
-        mcr_val = serial_in(p, UART_MCR);
-        mcr_backup = mcr_val;
-	/* Enable access to TCR_REG and TLR_REG */
-        serial_out(p, UART_MCR, mcr_val | 0x40);
-
-	/* Set RX_FIFO_TRIG levels */
-        serial_out(p, 0x18, 0x0f);
-
-        efr_val = serial_in(p, UART_EFR);
-        if (set)
-		serial_out(p, UART_EFR, efr_val | (1 << 6));
-        else
-                serial_out(p, UART_EFR, efr_val & ~(1 << 6));
-
-
-        mcr_val = serial_in(p, UART_MCR);
-	/* Restore original state of TCR_TLR access */
-        serial_out(p, UART_MCR, (mcr_val & ~0x40) | (mcr_backup & 0x40));
-
-	/* Enhanced function write disable. */
-	serial_out(p, UART_EFR, serial_in(p, UART_EFR) & ~0x10);
-
-	/* Normal operation */
-        serial_out(p, UART_LCR, lcr_backup);
-}
-
-static int serial_omap_startup(struct uart_port *port)
-{
-	struct uart_omap_port *up = (struct uart_omap_port *)port;
-	unsigned long flags;
-	int irq_flags = port->flags & UPF_SHARE_IRQ ? IRQF_SHARED : 0;
-	int retval;
-
-	/* Zoom2 has GPIO_102 connected to Serial device:
-	* Active High
-	*/
-
-	if (up->port.flags & UPF_TRIGGER_HIGH)
-		irq_flags |= IRQF_TRIGGER_HIGH;
-
-	if (up->port.flags & UPF_SHARE_IRQ)
-		irq_flags |= IRQF_SHARED;
-
-	/*
-	 * Allocate the IRQ
-	 */
-	retval = request_irq(up->port.irq, serial_omap_irq, irq_flags,
-			     up->name, up);
-	if (retval) {
-		printk(KERN_ERR "%s: Failed to register IRQ %d for %s (%d)\n",
-		       __func__, up->port.irq, up->name, retval);
-		return retval;
-	}
-
-
-	/* do not let tty layer execute RX in global workqueue, use a
-	 * dedicated workqueue managed by this driver */
-	port->state->port.tty->low_latency = 1;
-
-	/*
-	 * Stop the baud clock and disable the UART. UART will be enabled
-	 * back in set_termios. This is essential for DMA mode operations.
-	 */
-	serial_out(up, UART_LCR, UART_LCR_DLAB);
-	serial_out(up, UART_DLL, 0);
-	serial_out(up, UART_DLM, 0);
-	serial_out(up, UART_LCR, 0);
-	serial_out(up, UART_OMAP_MDR1, OMAP_MDR1_DISABLE);
-
-	/*
-	 * Clear the FIFO buffers and disable them.
-	 * (they will be reenabled in set_termios())
-	 */
-	serial_omap_clear_fifos(up);
-	serial_out(up, UART_SCR, 0x00);
-	/* For Hardware flow control */
-//	serial_out(up, UART_MCR, 0x2);
-
-	/*
-	 * Clear the interrupt registers.
-	 */
-	(void) serial_in(up, UART_LSR);
-	(void) serial_in(up, UART_RX);
-	(void) serial_in(up, UART_IIR);
-	(void) serial_in(up, UART_MSR);
-	/*
-	 * Now, initialize the UART
-	 */
-	serial_out(up, UART_LCR, UART_LCR_WLEN8);
-	spin_lock_irqsave(&up->port.lock, flags);
-	if (up->port.flags & UPF_FOURPORT) {
-		if (!is_real_interrupt(up->port.irq))
-			up->port.mctrl |= TIOCM_OUT1;
-	} else {
-		/*
-		 * Most PC uarts need OUT2 raised to enable interrupts.
-		 */
-		if (is_real_interrupt(up->port.irq))
-			up->port.mctrl |= TIOCM_OUT2;
-	}
-	serial_omap_set_mctrl(&up->port, up->port.mctrl);
-	spin_unlock_irqrestore(&up->port.lock, flags);
-
-	up->msr_saved_flags = 0;
-
-
-
-	if (up->port.flags & UPF_FOURPORT) {
-		unsigned int icp;
-		/*
-		 * Enable interrupts on the AST Fourport board
-		 */
-		icp = (up->port.iobase & 0xfe0) | 0x01f;
-		outb_p(0x80, icp);
-		(void) inb_p(icp);
-	}
-	if (up->use_dma) {
-		if (!up->is_buf_dma_alloced) {
-			free_page((unsigned long)up->port.state->xmit.buf);
-			up->port.state->xmit.buf = NULL;
-			up->port.state->xmit.buf = dma_alloc_coherent(NULL,
-							UART_XMIT_SIZE,
-						(dma_addr_t *)&(up->uart_dma.tx_buf_dma_phys), 0);
-			up->is_buf_dma_alloced = 1;
-		}
-		init_timer(&(up->uart_dma.rx_timer));
-		up->uart_dma.rx_timer.function = serial_omap_rx_timeout;
-		up->uart_dma.rx_timer.data = up->pdev->id;
-		/* Currently the buffer size is 4KB. Can increase it later*/
-		up->uart_dma.rx_buf = dma_alloc_coherent(NULL,
-					up->uart_dma.rx_buf_size,
-					(dma_addr_t *)&(up->uart_dma.rx_buf_dma_phys), 0);
-		serial_omap_start_rxdma(up);
-	} else {
-		/*
-		* Finally, enable interrupts.  Note: Modem status interrupts
-		* are set via set_termios(), which will be occurring imminently
-		* anyway, so we don't enable them here.
-		*/
-		up->ier = UART_IER_RLSI | UART_IER_RDI;
-			/*| UART_IER_RTOIE |UART_IER_THRI; */
-		serial_out(up, UART_IER, up->ier);
-	}
-
-	return 0;
-}
-
-static void serial_omap_shutdown(struct uart_port *port)
-{
-	struct uart_omap_port *up = (struct uart_omap_port *)port;
-	unsigned long flags;
-	u8 lcr, efr;
-
-	DPRINTK("serial_omap_shutdown+%d\n", up->pdev->id);
-	/* 
-	 * If we're using auto-rts then disable it.
-	 */
-	lcr = serial_in(up, UART_LCR);
-	serial_out(up, UART_LCR, 0xbf);
-	efr = serial_in(up, UART_EFR);
-	serial_out(up, UART_LCR, lcr);
-
-	if (efr & UART_EFR_RTS) {
-		serial_omap_set_autorts(up, 0);
-		up->restore_autorts = 1;
-	}
-
-	/*
-	 * Disable interrupts from this port
-	 */
-	up->ier = 0;
-	serial_out(up, UART_IER, 0);
-
-	spin_lock_irqsave(&up->port.lock, flags);
-	if (up->port.flags & UPF_FOURPORT) {
-		/* reset interrupts on the AST Fourport board */
-		inb((up->port.iobase & 0xfe0) | 0x1f);
-		up->port.mctrl |= TIOCM_OUT1;
-	} else
-		up->port.mctrl &= ~TIOCM_OUT2;
-	serial_omap_set_mctrl(&up->port, (up->port.mctrl & ~TIOCM_RTS));
-	spin_unlock_irqrestore(&up->port.lock, flags);
-
-	/*
-	 * Disable break condition and FIFOs
-	 */
-	serial_out(up, UART_LCR, serial_in(up, UART_LCR) & ~UART_LCR_SBC);
-	serial_omap_clear_fifos(up);
-
-	/*
-	 * Read data port to reset things, and then free the irq
-	 */
-	(void) serial_in(up, UART_RX);
-
-	if (up->use_dma) {
-		int tmp;
-		if (up->is_buf_dma_alloced) {
-			dma_free_coherent(up->port.dev,
-					  UART_XMIT_SIZE,
-					  up->port.state->xmit.buf,
-					  up->uart_dma.tx_buf_dma_phys);
-			up->port.state->xmit.buf = NULL;
-			up->is_buf_dma_alloced = 0;
-		}
-		/*TBD: Check if this is really needed here*/
-		serial_omap_stop_rx(port);
-		dma_free_coherent(up->port.dev,
-				  up->uart_dma.rx_buf_size,
-				  up->uart_dma.rx_buf, up->uart_dma.rx_buf_dma_phys);
-		up->uart_dma.rx_buf = NULL;
-		tmp = serial_in(up, UART_OMAP_SYSC) & 0x7;
-		serial_out(up, UART_OMAP_SYSC, tmp); /* force-idle */
-	}
-
-	free_irq(up->port.irq, up);
-
-	if (cancel_work_sync(&up->tty_work))
-		tty_flip_buffer_work(&up->tty_work);
-}
-
-static void
-serial_omap_set_termios(struct uart_port *port, struct ktermios *termios,
-			struct ktermios *old)
-{
-	struct uart_omap_port *up = (struct uart_omap_port *)port;
-	unsigned char cval;
-	unsigned char efr = 0;
-	unsigned long flags;
-	unsigned int baud, quot;
-
-	serial_out(up, UART_LCR, UART_LCR_DLAB);
-	serial_out(up, UART_DLL, 0);
-	serial_out(up, UART_DLM, 0);
-	serial_out(up, UART_LCR, 0);
-	serial_out(up, UART_OMAP_MDR1, OMAP_MDR1_DISABLE);
-	switch (termios->c_cflag & CSIZE) {
-	case CS5:
-		cval = UART_LCR_WLEN5;
-		break;
-	case CS6:
-		cval = UART_LCR_WLEN6;
-		break;
-	case CS7:
-		cval = UART_LCR_WLEN7;
-		break;
-	default:
-	case CS8:
-		cval = UART_LCR_WLEN8;
-		break;
-	}
-
-	if (termios->c_cflag & CSTOPB)
-		cval |= UART_LCR_STOP;
-	if (termios->c_cflag & PARENB)
-		cval |= UART_LCR_PARITY;
-	if (!(termios->c_cflag & PARODD))
-		cval |= UART_LCR_EPAR;
-
-	/*
-	 * Ask the core to calculate the divisor for us.
-	 */
-
-	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/13);
-	quot = serial_omap_get_divisor(port, baud);
-
-	if (up->use_dma)
-		fcr[up->pdev->id - 1] = UART_FCR_ENABLE_FIFO | 0x1 << 6 | 0x1 << 4 | UART_FCR_DMA_SELECT;
-	else
-		fcr[up->pdev->id - 1] = UART_FCR_ENABLE_FIFO;
-
-	/*
-	 * Ok, we're now changing the port state.  Do it with
-	 * interrupts disabled.
-	 */
-	spin_lock_irqsave(&up->port.lock, flags);
-
-	/*
-	 * Update the per-port timeout.
-	 */
-	uart_update_timeout(port, termios->c_cflag, baud);
-
-	up->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;
-	if (termios->c_iflag & INPCK)
-		up->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;
-	if (termios->c_iflag & (BRKINT | PARMRK))
-		up->port.read_status_mask |= UART_LSR_BI;
-
-	/*
-	 * Characters to ignore
-	 */
-	up->port.ignore_status_mask = 0;
-	if (termios->c_iflag & IGNPAR)
-		up->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;
-	if (termios->c_iflag & IGNBRK) {
-		up->port.ignore_status_mask |= UART_LSR_BI;
-		/*
-		 * If we're ignoring parity and break indicators,
-		 * ignore overruns too (for real raw support).
-		 */
-		if (termios->c_iflag & IGNPAR)
-			up->port.ignore_status_mask |= UART_LSR_OE;
-	}
-
-	/*
-	 * ignore all characters if CREAD is not set
-	 */
-	if ((termios->c_cflag & CREAD) == 0)
-		up->port.ignore_status_mask |= UART_LSR_DR;
-
-	/*
-	 * CTS flow control flag and modem status interrupts
-	 */
-	up->ier &= ~UART_IER_MSI;
-	if (UART_ENABLE_MS(&up->port, termios->c_cflag))
-		up->ier |= UART_IER_MSI;
-	serial_out(up, UART_IER, up->ier);
-
-	if (termios->c_cflag & CRTSCTS) {
-		efr |= (UART_EFR_CTS | (up->restore_autorts ? 0 : UART_EFR_RTS));
-	}
-
-	serial_out(up, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */
-	serial_out(up, UART_DLL, quot & 0xff);		/* LS of divisor */
-	serial_out(up, UART_DLM, quot >> 8);		/* MS of divisor */
-
-	serial_out(up, UART_LCR, cval);		/* reset DLAB */
-	up->lcr = cval;				/* Save LCR */
-	if (up->use_dma)
-		serial_out(up, UART_OMAP_SCR  , ((1 << 6) | (1 << 7)));
-
-	serial_out(up, UART_LCR, 0xbf);	/* Access EFR */
-	serial_out(up, UART_EFR, UART_EFR_ECB);
-	serial_out(up, UART_LCR, 0x0);		/* Access FCR */
-	serial_out(up, UART_FCR, fcr[up->pdev->id - 1]);
-	serial_out(up, UART_LCR, 0xbf);	/* Access EFR */
-	serial_out(up, UART_EFR, efr);
-	serial_out(up, UART_LCR, cval);	/* Access FCR */
-
-	serial_omap_set_mctrl(&up->port, up->port.mctrl);
-	/*
-	 * Clear all the status registers and RX register before
-	 * enabling UART
-	 */
-	(void) serial_in(up, UART_LSR);
-	(void) serial_in(up, UART_RX);
-	(void) serial_in(up, UART_IIR);
-	(void) serial_in(up, UART_MSR);
-
-	if (baud > 230400 && baud != 3000000)
-		serial_out(up, UART_OMAP_MDR1, OMAP_MDR1_MODE13X);
-	else
-		serial_out(up, UART_OMAP_MDR1, OMAP_MDR1_MODE16X);
-	spin_unlock_irqrestore(&up->port.lock, flags);
-
-	DPRINTK("serial_omap_set_termios+%d\n", up->pdev->id);
-	serial_omap_display_reg(port);
-}
-
-static void
-serial_omap_pm(struct uart_port *port, unsigned int state,
-	       unsigned int oldstate)
-{
-	struct uart_omap_port *up = (struct uart_omap_port *)port;
-	unsigned char efr;
-	DPRINTK("serial_omap_pm+%d\n", up->pdev->id);
-	efr = serial_in(up, UART_EFR);
-	serial_out(up, UART_LCR, 0xBF);
-	serial_out(up, UART_EFR, efr | UART_EFR_ECB);
-	serial_out(up, UART_LCR, 0);
-
-	serial_out(up, UART_IER, (state != 0) ? UART_IERX_SLEEP : 0);
-	serial_out(up, UART_LCR, 0xBF);
-	serial_out(up, UART_EFR, efr);
-	serial_out(up, UART_LCR, 0);
-}
-
-static void serial_omap_release_port(struct uart_port *port)
-{
-	DPRINTK("serial_omap_release_port+\n");
-}
-
-static int serial_omap_request_port(struct uart_port *port)
-{
-	DPRINTK("serial_omap_request_port+\n");
-	return 0;
-}
-
-static void serial_omap_config_port(struct uart_port *port, int flags)
-{
-	struct uart_omap_port *up = (struct uart_omap_port *)port;
-
-	DPRINTK("serial_omap_config_port+%d\n", up->pdev->id);
-	up->port.type = PORT_OMAP;
-}
-
-static int
-serial_omap_verify_port(struct uart_port *port, struct serial_struct *ser)
-{
-	/* we don't want the core code to modify any port params */
-	DPRINTK("serial_omap_verify_port+\n");
-	return -EINVAL;
-}
-
-static const char *
-serial_omap_type(struct uart_port *port)
-{
-	struct uart_omap_port *up = (struct uart_omap_port *)port;
-
-	DPRINTK("serial_omap_type+%d\n", up->pdev->id);
-	return up->name;
-}
-
-#ifdef CONFIG_SERIAL_OMAP_CONSOLE
-
-static struct uart_omap_port *serial_omap_console_ports[4];
-
-static struct uart_driver serial_omap_reg;
-
-#define BOTH_EMPTY (UART_LSR_TEMT | UART_LSR_THRE)
-
-/*
- *	Wait for transmitter & holding register to empty
- */
-static inline void wait_for_xmitr(struct uart_omap_port *up)
-{
-	unsigned int status, tmout = 10000;
-
-	/* Wait up to 10ms for the character(s) to be sent. */
-	do {
-		status = serial_in(up, UART_LSR);
-
-		if (status & UART_LSR_BI)
-			up->lsr_break_flag = UART_LSR_BI;
-
-		if (--tmout == 0)
-			break;
-		udelay(1);
-	} while ((status & BOTH_EMPTY) != BOTH_EMPTY);
-
-	/* Wait up to 1s for flow control if necessary */
-	if (up->port.flags & UPF_CONS_FLOW) {
-		tmout = 1000000;
-		for (tmout = 1000000; tmout; tmout--) {
-			unsigned int msr = serial_in(up, UART_MSR);
-			up->msr_saved_flags |= msr & MSR_SAVE_FLAGS;
-			if (msr & UART_MSR_CTS)
-				break;
-			udelay(1);
-		}
-	}
-}
-
-static void serial_omap_console_putchar(struct uart_port *port, int ch)
-{
-	struct uart_omap_port *up = (struct uart_omap_port *)port;
-
-	wait_for_xmitr(up);
-	serial_out(up, UART_TX, ch);
-}
-
-/*
- * Print a string to the serial port trying not to disturb
- * any possible real use of the port...
- *
- *	The console_lock must be held when we get here.
- */
-static void
-serial_omap_console_write(struct console *co, const char *s,
-		unsigned int count)
-{
-	/* TBD: In 8250 interrupts were disabled in the beginning of this
-	 * function and enabled in the end. We might need to do the same*/
-	struct uart_omap_port *up = serial_omap_console_ports[co->index];
-	unsigned int ier;
-
-	/*
-	 *	First save the IER then disable the interrupts
-	 */
-	ier = serial_in(up, UART_IER);
-	serial_out(up, UART_IER, 0);
-
-	uart_console_write(&up->port, s, count, serial_omap_console_putchar);
-
-	/*
-	 *	Finally, wait for transmitter to become empty
-	 *	and restore the IER
-	 */
-	wait_for_xmitr(up);
-	serial_out(up, UART_IER, ier);
-	/*
-	 *	The receive handling will happen properly because the
-	 *	receive ready bit will still be set; it is not cleared
-	 *	on read.  However, modem control will not, we must
-	 *	call it if we have saved something in the saved flags
-	 *	while processing with interrupts off.
-	 */
-	if (up->msr_saved_flags)
-		check_modem_status(up);
-}
-
-static int __init
-serial_omap_console_setup(struct console *co, char *options)
-{
-	struct uart_omap_port *up;
-	int baud = 9600;
-	int bits = 8;
-	int parity = 'n';
-	int flow = 'n';
-	int r;
-
-	if (serial_omap_console_ports[co->index] == NULL)
-		return -ENODEV;
-	up = serial_omap_console_ports[co->index];
-
-	if (options)
-		uart_parse_options(options, &baud, &parity, &bits, &flow);
-
-	r = uart_set_options(&up->port, co, baud, parity, bits, flow);
-
-	return r;
-}
-
-static struct console serial_omap_console = {
-	.name		= "ttyS",
-	.write		= serial_omap_console_write,
-	.device		= uart_console_device,
-	.setup		= serial_omap_console_setup,
-	.flags		= CON_PRINTBUFFER,
-	.index		= -1,
-	.data		= &serial_omap_reg,
-};
-
-static void serial_omap_add_console_port(struct uart_omap_port *up)
-{
-	serial_omap_console_ports[up->pdev->id - 1] = up;
-}
-
-#define OMAP_CONSOLE	(&serial_omap_console)
-
-#else
-
-#define OMAP_CONSOLE	NULL
-
-static inline void serial_omap_add_console_port(struct uart_omap_port *up) {}
-
-#endif
-
-struct uart_ops serial_omap_pops = {
-	.tx_empty	= serial_omap_tx_empty,
-	.set_mctrl	= serial_omap_set_mctrl,
-	.get_mctrl	= serial_omap_get_mctrl,
-	.stop_tx	= serial_omap_stop_tx,
-	.start_tx	= serial_omap_start_tx,
-	.stop_rx	= serial_omap_stop_rx,
-	.enable_ms	= serial_omap_enable_ms,
-	.break_ctl	= serial_omap_break_ctl,
-	.startup	= serial_omap_startup,
-	.shutdown	= serial_omap_shutdown,
-	.set_termios	= serial_omap_set_termios,
-	.pm		= serial_omap_pm,
-	.type		= serial_omap_type,
-	.release_port	= serial_omap_release_port,
-	.request_port	= serial_omap_request_port,
-	.config_port	= serial_omap_config_port,
-	.verify_port	= serial_omap_verify_port,
-	.wake_peer	= serial_omap_wake_peer,
-};
-
-static struct uart_driver serial_omap_reg = {
-	.owner		= THIS_MODULE,
-	.driver_name	= "OMAP-SERIAL",
-	.dev_name	= "ttyS",
-	.major		= TTY_MAJOR,
-	.minor		= 64,
-	.nr		= 4,
-	.cons		= OMAP_CONSOLE,
-};
-
-static int serial_omap_remove(struct platform_device *dev);
-static int serial_omap_suspend(struct platform_device *pdev, pm_message_t state)
-{
-	struct uart_omap_port *up = platform_get_drvdata(pdev);
-	unsigned int tmp;
-
-	if (up)
-		uart_suspend_port(&serial_omap_reg, &up->port);
-	if (up->use_dma) {
-		/*
-		 * Silicon Errata i291 workaround.
-		 * UART Module has to be put in force idle if it is
-		 * configured in DMA mode and when there is no activity
-		 * expected.
-		 */
-		tmp = (serial_in(up, UART_OMAP_SYSC) & 0x7);
-		serial_out(up, UART_OMAP_SYSC, tmp); /* force-idle */
-	}
-	return 0;
-}
-
-static int serial_omap_resume(struct platform_device *dev)
-{
-	struct uart_omap_port *up = platform_get_drvdata(dev);
-	if (up)
-		uart_resume_port(&serial_omap_reg, &up->port);
-
-	return 0;
-}
-
-static void serial_omap_rx_timeout(unsigned long uart_no)
-{
-	struct uart_omap_port *up = ui[uart_no - 1];
-	unsigned int curr_dma_pos;
-	curr_dma_pos = omap_readl(OMAP34XX_DMA4_BASE + OMAP_DMA4_CDAC(up->uart_dma.rx_dma_channel));
-	if ((curr_dma_pos == up->uart_dma.prev_rx_dma_pos) || (curr_dma_pos == 0)) {
-		/*
-		 * If there is no transfer rx happening for 10sec then stop the dma
-		 * else just restart the timer. See if 10 sec can be improved.
-		 */
-		if (jiffies_to_msecs(jiffies - isr8250_activity) < 10000)
-			mod_timer(&up->uart_dma.rx_timer, jiffies +
-				usecs_to_jiffies(up->uart_dma.rx_timeout));
-		else {
-			del_timer(&up->uart_dma.rx_timer);
-			serial_omap_stop_rxdma(up);
-			up->ier |= UART_IER_RDI;
-			serial_out(up, UART_IER, up->ier);
-		}
-
-		return;
-	} else {
-		unsigned int curr_transmitted_size = curr_dma_pos - up->uart_dma.prev_rx_dma_pos;
-		up->port.icount.rx += curr_transmitted_size;
-		tty_insert_flip_string(up->port.state->port.tty, up->uart_dma.rx_buf + (up->uart_dma.prev_rx_dma_pos - up->uart_dma.rx_buf_dma_phys), curr_transmitted_size);
-		queue_work(omap_serial_workqueue, &up->tty_work);
-		up->uart_dma.prev_rx_dma_pos = curr_dma_pos;
-		if (up->uart_dma.rx_buf_size + up->uart_dma.rx_buf_dma_phys == curr_dma_pos) {
-			serial_omap_start_rxdma(up);
-		} else
-			mod_timer(&up->uart_dma.rx_timer,
-				  jiffies + usecs_to_jiffies(up->uart_dma.rx_timeout));
-		isr8250_activity = jiffies;
-	}
-}
-
-static void uart_rx_dma_callback(int lch, u16 ch_status, void *data)
-{
-	return;
-}
-
-static void serial_omap_start_rxdma(struct uart_omap_port *up)
-{
-#ifdef CONFIG_PM
-	/* Disallow OCP bus idle. UART TX irqs are not seen during
-	 * bus idle. Alternative is to set kernel timer at fifo
-	 * drain rate.
-	 */
-	unsigned int tmp;
-	tmp = (serial_in(up, UART_OMAP_SYSC) & 0x7) | (1 << 3);
-	serial_out(up, UART_OMAP_SYSC, tmp); /* no-idle */
-#endif
-	if (up->uart_dma.rx_dma_channel == 0xFF) {
-		omap_request_dma(uart_dma_rx[up->pdev->id-1], "UART Rx DMA",
-				(void *)uart_rx_dma_callback, up,
-				&(up->uart_dma.rx_dma_channel));
-		omap_set_dma_src_params(up->uart_dma.rx_dma_channel, 0,
-					OMAP_DMA_AMODE_CONSTANT,
-					UART_BASE(up->pdev->id - 1), 0, 0);
-		omap_set_dma_dest_params(up->uart_dma.rx_dma_channel, 0,
-					OMAP_DMA_AMODE_POST_INC,
-					up->uart_dma.rx_buf_dma_phys, 0, 0);
-		omap_set_dma_transfer_params(up->uart_dma.rx_dma_channel,
-					OMAP_DMA_DATA_TYPE_S8,
-					up->uart_dma.rx_buf_size, 1,
-					OMAP_DMA_SYNC_ELEMENT,
-					uart_dma_rx[up->pdev->id-1], 0);
-	}
-	up->uart_dma.prev_rx_dma_pos = up->uart_dma.rx_buf_dma_phys;
-	omap_writel(0, OMAP34XX_DMA4_BASE +
-		OMAP_DMA4_CDAC(up->uart_dma.rx_dma_channel));
-	omap_start_dma(up->uart_dma.rx_dma_channel);
-	mod_timer(&up->uart_dma.rx_timer, jiffies +
-			usecs_to_jiffies(up->uart_dma.rx_timeout));
-	up->uart_dma.rx_dma_state = 1;
-}
-
-static void serial_omap_continue_tx(struct uart_omap_port *up)
-{
-	struct circ_buf *xmit = &up->port.state->xmit;
-	int start = up->uart_dma.tx_buf_dma_phys + (xmit->tail & (UART_XMIT_SIZE - 1));
-	if (uart_circ_empty(xmit))
-		return;
-
-	up->uart_dma.tx_buf_size = uart_circ_chars_pending(xmit);
-	/* It is a circular buffer. See if the buffer has wounded back.
-	* If yes it will have to be transferred in two separate dma
-	* transfers
-	*/
-	if (start + up->uart_dma.tx_buf_size >=
-			up->uart_dma.tx_buf_dma_phys + UART_XMIT_SIZE)
-		up->uart_dma.tx_buf_size =
-			(up->uart_dma.tx_buf_dma_phys + UART_XMIT_SIZE) - start;
-	omap_set_dma_dest_params(up->uart_dma.tx_dma_channel, 0,
-				 OMAP_DMA_AMODE_CONSTANT,
-				 UART_BASE(up->pdev->id - 1), 0, 0);
-	omap_set_dma_src_params(up->uart_dma.tx_dma_channel, 0,
-				OMAP_DMA_AMODE_POST_INC, start, 0, 0);
-
-	omap_set_dma_transfer_params(up->uart_dma.tx_dma_channel,
-				     OMAP_DMA_DATA_TYPE_S8,
-				     up->uart_dma.tx_buf_size, 1,
-				     OMAP_DMA_SYNC_ELEMENT,
-				     uart_dma_tx[(up->pdev->id)-1], 0);
-
-	omap_start_dma(up->uart_dma.tx_dma_channel);
-}
-
-static void uart_tx_dma_callback(int lch, u16 ch_status, void *data)
-{
-	struct uart_omap_port *up = (struct uart_omap_port *)data;
-	struct circ_buf *xmit = &up->port.state->xmit;
-	xmit->tail = (xmit->tail + up->uart_dma.tx_buf_size) & (UART_XMIT_SIZE - 1);
-	up->port.icount.tx += up->uart_dma.tx_buf_size;
-
-	/* Revisit: Not sure about the below two steps. Seen some instabilities
-	* with them. might not be needed in the DMA path
-	*/
-	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
-		uart_write_wakeup(&up->port);
-
-	if (uart_circ_empty(xmit)) {
-
-		spin_lock(&(up->uart_dma.tx_lock));
-		serial_omap_stop_tx(&up->port);
-		up->uart_dma.tx_dma_state = 0;
-		spin_unlock(&(up->uart_dma.tx_lock));
-	} else {
-		omap_stop_dma(up->uart_dma.tx_dma_channel);
-		serial_omap_continue_tx(up);
-	}
-	isr8250_activity = jiffies;
-
-	return;
-}
-
-static int serial_omap_probe(struct platform_device *pdev)
-{
-	struct plat_serialomap_port *pdata = pdev->dev.platform_data;
-	struct uart_omap_port	*up;
-	struct resource		*mem, *irq;
-	int ret = -ENOSPC;
-	char str[7];
-
-	if (!pdata) {
-		dev_err(&pdev->dev, "no platform data?\n");
-		return -ENODEV;
-	}
-
-	if (pdata->disabled) {
-		dev_err(&pdev->dev, "device disabled\n");
-		return -ENODEV;
-	}
-
-	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!mem) {
-		dev_err(&pdev->dev, "no mem resource?\n");
-		return -ENODEV;
-	}
-	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	if (!irq) {
-		dev_err(&pdev->dev, "no irq resource?\n");
-		return -ENODEV;
-	}
-
-	ret = (int) request_mem_region(mem->start, (mem->end - mem->start) + 1,
-				     pdev->dev.driver->name);
-	if (!ret) {
-		dev_err(&pdev->dev, "memory region already claimed\n");
-		return -EBUSY;
-	}
-	up = kzalloc(sizeof(*up), GFP_KERNEL);
-	if (up == NULL) {
-		ret = -ENOMEM;
-		goto do_release_region;
-	}
-	sprintf(up->name, "OMAP UART%d", pdev->id);
-
-	up->pdev = pdev;
-	up->port.dev = &pdev->dev;
-	up->port.type = PORT_OMAP;
-	up->port.iotype = UPIO_MEM;
-	up->port.mapbase = mem->start;
-	up->port.irq = irq->start;
-	up->port.fifosize = 64;
-	up->port.ops = &serial_omap_pops;
-	up->port.line = pdev->id - 1;
-#define QUART_CLK (1843200)
-	if (pdev->id == 4) {
-		up->port.membase = ioremap_nocache(mem->start, 0x16 << 1);
-		up->port.flags = UPF_BOOT_AUTOCONF | UPF_IOREMAP |
-			UPF_SHARE_IRQ | UPF_TRIGGER_HIGH;
-		up->port.uartclk = QUART_CLK;
-		up->port.regshift = 1;
-	} else {
-		up->port.membase = (void *) OMAP2_L4_IO_ADDRESS(mem->start);
-		up->port.flags = pdata->flags;
-		up->port.uartclk = 48000000;
-		up->port.regshift = 2;
-	}
-
-
-	if (pdev->id == (UART1+1)) {
-#ifdef CONFIG_SERIAL_OMAP_DMA_UART1
-		up->use_dma = 1;
-		up->uart_dma.rx_buf_size =
-			CONFIG_SERIAL_OMAP_UART1_RXDMA_BUFSIZE;
-		up->uart_dma.rx_timeout =
-			CONFIG_SERIAL_OMAP_UART1_RXDMA_TIMEOUT;
-#endif
-	} else if (pdev->id == (UART2+1)) {
-#ifdef CONFIG_SERIAL_OMAP_DMA_UART2
-		up->use_dma = 1;
-		up->uart_dma.rx_buf_size =
-			CONFIG_SERIAL_OMAP_UART2_RXDMA_BUFSIZE;
-		up->uart_dma.rx_timeout =
-			CONFIG_SERIAL_OMAP_UART2_RXDMA_TIMEOUT;
-#endif
-	} else if (pdev->id == (UART3+1)) {
-#ifdef CONFIG_SERIAL_OMAP_DMA_UART3
-		up->use_dma = 1;
-		up->uart_dma.rx_buf_size =
-			CONFIG_SERIAL_OMAP_UART3_RXDMA_BUFSIZE;
-		up->uart_dma.rx_timeout =
-			CONFIG_SERIAL_OMAP_UART3_RXDMA_TIMEOUT;
-#endif
-	}
-
-	if (up->use_dma) {
-		spin_lock_init(&(up->uart_dma.tx_lock));
-		spin_lock_init(&(up->uart_dma.rx_lock));
-		up->uart_dma.tx_dma_channel = 0xFF;
-		up->uart_dma.rx_dma_channel = 0xFF;
-	}
-	if (console_detect(str))
-		printk("Invalid console paramter. UART Library Init Failed!\n");
-	up->use_console = 0;
-	fcr[pdev->id - 1] = 0;
-	if (!strcmp(str, "ttyS0"))
-		up->use_console = 1;
-	else if (!strcmp(str, "ttyS1"))
-		up->use_console = 1;
-	else if (!strcmp(str, "ttyS2"))
-		up->use_console = 1;
-	else if (!strcmp(str, "ttyS3"))
-		up->use_console = 1;
-	else
-		printk(KERN_INFO
-		       "!!!!!!!! Unable to recongnize Console UART........\n");
-	ui[pdev->id - 1] = up;
-	serial_omap_add_console_port(up);
-	serial_omap_clear_fifos(up);
-
-	ret = uart_add_one_port(&serial_omap_reg, &up->port);
-	if (ret != 0)
-		goto do_release_region;
-	platform_set_drvdata(pdev, up);
-
-	if (pdata->wake_gpio_strobe) {
-		if (gpio_request(pdata->wake_gpio_strobe,
-				 "UART AP -> BP wakeup strobe")) {
-			printk(KERN_ERR "Error requesting GPIO\n");
-		} else
-			gpio_direction_output(pdata->wake_gpio_strobe, 0);
-	}
-
-	INIT_WORK(&up->tty_work, tty_flip_buffer_work);
-		
-	return 0;
-do_release_region:
-	release_mem_region(mem->start, (mem->end - mem->start) + 1);
-	return ret;
-}
-
-static int serial_omap_remove(struct platform_device *dev)
-{
-	struct uart_omap_port *up = platform_get_drvdata(dev);
-
-	platform_set_drvdata(dev, NULL);
-	if (up) {
-		uart_remove_one_port(&serial_omap_reg, &up->port);
-		kfree(up);
-	}
-	return 0;
-}
-
-static struct platform_driver serial_omap_driver = {
-	.probe          = serial_omap_probe,
-	.remove         = serial_omap_remove,
-
-	.suspend	= serial_omap_suspend,
-	.resume		= serial_omap_resume,
-	.driver		= {
-		.name	= "omap-uart",
-	},
-};
-
-int __init serial_omap_init(void)
-{
-	int ret;
-
-	wake_lock_init(&omap_serial_wakelock, WAKE_LOCK_SUSPEND,
-		       "omap_serial");
-	omap_serial_workqueue = create_singlethread_workqueue("omap_serial");
-	ret = uart_register_driver(&serial_omap_reg);
-	if (ret != 0)
-		return ret;
-	ret = platform_driver_register(&serial_omap_driver);
-	if (ret != 0)
-		uart_unregister_driver(&serial_omap_reg);
-	return ret;
-}
-
-void __exit serial_omap_exit(void)
-{
-	wake_lock_destroy(&omap_serial_wakelock);
-	destroy_workqueue(omap_serial_workqueue);
-	platform_driver_unregister(&serial_omap_driver);
-	uart_unregister_driver(&serial_omap_reg);
-}
-
-#if defined(CONFIG_OMAP3_PM)
-int omap24xx_uart_cts_wakeup(int uart_no, int state)
-{
-	u32 *ptr;
-	unsigned char lcr, efr;
-	struct uart_omap_port *up = ui[uart_no];
-
-	if (unlikely(uart_no < 0 || uart_no > MAX_UARTS)) {
-		printk(KERN_INFO "Bad uart id %d \n", uart_no);
-		return -EPERM;
-	}
-
-	if (state) {
-		/*
-		 * Enable the CTS for io pad wakeup
-		 */
-		switch (uart_no) {
-		case UART1:
-			ptr = (u32 *) (&CONTROL_PADCONF_UART1_CTS);
-			break;
-		case UART2:
-			ptr = (u32 *) (&CONTROL_PADCONF_UART2_CTS);
-			break;
-		default:
-			printk(KERN_ERR
-			"Wakeup on Uart%d is not supported\n", uart_no);
-			return -EPERM;
-		}
-		*ptr |= (u32)((IO_PAD_WAKEUPENABLE | IO_PAD_OFFPULLUDENABLE |
-				IO_PAD_OFFOUTENABLE | IO_PAD_OFFENABLE |
-				IO_PAD_INPUTENABLE | IO_PAD_PULLUDENABLE|
-				IO_PAD_MUXMODE0)
-				);
-		/*
-		 * Enable the CTS for module level wakeup
-		 */
-		lcr = serial_in(up, UART_LCR);
-		serial_out(up, UART_LCR, 0xbf);
-		efr = serial_in(up, UART_EFR);
-		serial_out(up, UART_EFR, efr | UART_EFR_ECB);
-		serial_out(up, UART_LCR, lcr);
-		up->ier	|= (1 << 7);
-		serial_out(up, UART_IER, up->ier);
-		serial_out(up, UART_OMAP_WER,
-				serial_in(up, UART_OMAP_WER) | 0x1);
-		serial_out(up, UART_LCR, 0xbf);
-		serial_out(up, UART_EFR, efr);
-		serial_out(up, UART_LCR, lcr);
-
-	} else {
-		/*
-		 * Disable the CTS capability for io pad wakeup
-		 */
-		switch (uart_no) {
-		case UART1:
-			ptr = (u32 *) (&CONTROL_PADCONF_UART1_CTS);
-			break;
-		case UART2:
-			ptr = (u32 *) (&CONTROL_PADCONF_UART2_CTS);
-			break;
-		default:
-			printk(KERN_ERR
-			"Wakeup on Uart%d is not supported\n", uart_no);
-			return -EPERM;
-		}
-		*ptr &= (u32) (~(IO_PAD_WAKEUPENABLE | IO_PAD_OFFPULLUDENABLE |
-				IO_PAD_OFFOUTENABLE | IO_PAD_OFFENABLE |
-				IO_PAD_INPUTENABLE | IO_PAD_PULLUDENABLE));
-		*ptr |= IO_PAD_MUXMODE7;
-
-		/*
-		 * Disable the CTS for module level wakeup
-		 */
-		lcr = serial_in(up, UART_LCR);
-		serial_out(up, UART_LCR, 0xbf);
-		efr = serial_in(up, UART_EFR);
-		serial_out(up, UART_EFR, efr | UART_EFR_ECB);
-		serial_out(up, UART_LCR, lcr);
-		up->ier	&= ~(1 << 7);
-		serial_out(up, UART_IER, up->ier);
-		/* TBD:Do we really want to disable module wake up for this in WER*/
-		serial_out(up, UART_LCR, 0xbf);
-		serial_out(up, UART_EFR, efr);
-		serial_out(up, UART_LCR, lcr);
-	}
-	return 0;
-}
-EXPORT_SYMBOL(omap24xx_uart_cts_wakeup);
-#endif
-
-#ifdef CONFIG_PM
-/**
- * are_driver8250_uarts_active() - Check if any ports managed by this
- * driver are currently busy.  This should be called with interrupts
- * disabled.
- */
-int are_driveromap_uarts_active(int num)
-{
-	struct circ_buf *xmit;
-	unsigned int status;
-	struct uart_omap_port *up = ui[num];
-
-	if (!up)
-		return 0;
-
-	/* check ownership of port */
-	/* Check only ports managed by this driver and open */
-	if ((up->port.dev == NULL) || (up->port.type == PORT_UNKNOWN))
-		return 0;
-
-	/* driver owns this port but it's closed */
-	if (up->port.state == NULL)
-		return 0;
-
-	/* check for any current pending activity */
-	/* Any queued work in ring buffer which can be handled still? */
-	xmit = &up->port.state->xmit;
-	if (!(uart_circ_empty(xmit) || uart_tx_stopped(&up->port)))
-		return 1;
-	status = serial_in(up, UART_LSR);
-
-	/* TX hardware not empty */
-	if (!(status & (UART_LSR_TEMT | UART_LSR_THRE)))
-		return 1;
-
-	/* Any rx activity? */
-	if (status & UART_LSR_DR)
-		return 1;
-
-	if (up->use_dma) {
-		/*
-		 * Silicon Errata i291 workaround.
-		 * UART Module has to be put in force idle if it is
-		 * configured in DMA mode and when there is no activity
-		 * expected.
-		 */
-		unsigned int tmp;
-		del_timer(&up->uart_dma.rx_timer);
-		serial_omap_stop_rxdma(up);
-		up->ier |= UART_IER_RDI;
-		serial_out(up, UART_IER, up->ier);
-		tmp = (serial_in(up, UART_OMAP_SYSC) & 0x7);
-		serial_out(up, UART_OMAP_SYSC, tmp); /* force-idle */
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(are_driveromap_uarts_active);
-
-#endif
-
-static void serial_omap_display_reg(struct uart_port *port)
-{
-	struct uart_omap_port *up = (struct uart_omap_port *)port;
-	unsigned int lcr, efr, mcr, dll, dlh, xon1, xon2, xoff1, xoff2;
-	unsigned int tcr, tlr, uasr;
-	DPRINTK("Register dump for UART%d\n", up->pdev->id);
-	DPRINTK("IER_REG=0x%x\n", serial_in(up, UART_IER));
-	DPRINTK("IIR_REG=0x%x\n", serial_in(up, UART_IIR));
-	lcr = serial_in(up, UART_LCR);
-	DPRINTK("LCR_REG=0x%x\n", lcr);
-	mcr = serial_in(up, UART_MCR);
-	DPRINTK("MCR_REG=0x%x\n", mcr);
-	DPRINTK("LSR_REG=0x%x\n", serial_in(up, UART_LSR));
-	DPRINTK("MSR_REG=0x%x\n", serial_in(up, UART_MSR));
-	DPRINTK("SPR_REG=0x%x\n", serial_in(up, UART_OMAP_SPR));
-	DPRINTK("MDR1_REG=0x%x\n", serial_in(up, UART_OMAP_MDR1));
-	DPRINTK("MDR2_REG=0x%x\n", serial_in(up, UART_OMAP_MDR2));
-	DPRINTK("SCR_REG=0x%x\n", serial_in(up, UART_OMAP_SCR));
-	DPRINTK("SSR_REG=0x%x\n", serial_in(up, UART_OMAP_SSR));
-	DPRINTK("MVR_REG=0x%x\n", serial_in(up, UART_OMAP_MVER));
-	DPRINTK("SYSC_REG=0x%x\n", serial_in(up, UART_OMAP_SYSC));
-	DPRINTK("SYSS_REG=0x%x\n", serial_in(up, UART_OMAP_SYSS));
-	DPRINTK("WER_REG=0x%x\n", serial_in(up, UART_OMAP_WER));
-
-	serial_out(up, UART_LCR, 0xBF);
-	dll = serial_in(up, UART_DLL);
-	dlh = serial_in(up, UART_DLM);
-	efr = serial_in(up, UART_EFR);
-	xon1 = serial_in(up, UART_XON1);
-	xon2 = serial_in(up, UART_XON2);
-
-	serial_out(up, UART_EFR, efr | UART_EFR_ECB);
-	serial_out(up, UART_LCR, lcr);
-	serial_out(up, UART_MCR, mcr | UART_MCR_TCRTLR);
-	serial_out(up, UART_LCR, 0xBF);
-
-	tcr = serial_in(up, UART_TI752_TCR);
-	tlr = serial_in(up, UART_TI752_TLR);
-
-	serial_out(up, UART_LCR, lcr);
-	serial_out(up, UART_MCR, mcr);
-	serial_out(up, UART_LCR, 0xBF);
-
-	xoff1 = serial_in(up, UART_XOFF1);
-	xoff2 = serial_in(up, UART_XOFF2);
-	uasr = serial_in(up, UART_OMAP_UASR);
-
-	serial_out(up, UART_EFR, efr);
-	serial_out(up, UART_LCR, lcr);
-
-
-	DPRINTK("DLL_REG=0x%x\n", dll);
-	DPRINTK("DLH_REG=0x%x\n", dlh);
-	DPRINTK("EFR_REG=0x%x\n", efr);
-
-	DPRINTK("XON1_ADDR_REG=0x%x\n", xon1);
-	DPRINTK("XON2_ADDR_REG=0x%x\n", xon2);
-	DPRINTK("TCR_REG=0x%x\n", tcr);
-	DPRINTK("TLR_REG=0x%x\n", tlr);
-
-
-	DPRINTK("XOFF1_REG=0x%x\n", xoff1);
-	DPRINTK("XOFF2_REG=0x%x\n", xoff2);
-	DPRINTK("UASR_REG=0x%x\n", uasr);
-
-}
-
-subsys_initcall(serial_omap_init);
-module_exit(serial_omap_exit);
-
-MODULE_LICENSE("GPL");
diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c
index 08bcecb..6b34141 100644
--- a/drivers/usb/gadget/composite.c
+++ b/drivers/usb/gadget/composite.c
@@ -24,6 +24,7 @@
 #include <linux/kernel.h>
 #include <linux/slab.h>
 #include <linux/device.h>
+#include <linux/kdev_t.h>
 
 #include <linux/usb/composite.h>
 
diff --git a/drivers/video/omap/dispc.c b/drivers/video/omap/dispc.c
index c7c6455..e40146a 100644
--- a/drivers/video/omap/dispc.c
+++ b/drivers/video/omap/dispc.c
@@ -189,7 +189,7 @@ static struct {
 	struct omapfb_color_key	color_key;
 } dispc;
 
-static struct platform_device omapdss_device = {
+struct platform_device omapdss_device = {
 	.name		= "omapdss",
 	.id		= -1,
 };
diff --git a/drivers/video/omap/omapfb.h b/drivers/video/omap/omapfb.h
index 46e4714..0a4988e 100644
--- a/drivers/video/omap/omapfb.h
+++ b/drivers/video/omap/omapfb.h
@@ -224,4 +224,6 @@ extern int  omapfb_update_window_async(struct fb_info *fbi,
 				       void (*callback)(void *),
 				       void *callback_data);
 
+extern struct platform_device omapdss_device;
+
 #endif /* __OMAPFB_H */
diff --git a/drivers/video/omap/omapfb_main.c b/drivers/video/omap/omapfb_main.c
index c7f59a5..361ef59 100644
--- a/drivers/video/omap/omapfb_main.c
+++ b/drivers/video/omap/omapfb_main.c
@@ -170,7 +170,7 @@ static int ctrl_init(struct omapfb_device *fbdev)
 		/* 12 bpp is packed in 16 bits */
 		if (bpp == 12)
 			bpp = 16;
-		def_size = def_vxres * def_vyres * bpp / 8;
+		def_size = def_vxres * def_vyres * 2* bpp / 8;
 		fbdev->mem_desc.region_cnt = 1;
 		fbdev->mem_desc.region[0].size = PAGE_ALIGN(def_size);
 	}
@@ -434,6 +434,7 @@ static void set_fb_fix(struct fb_info *fbi, int from_init)
 	}
 	fix->accel		= FB_ACCEL_OMAP1610;
 	fix->line_length	= var->xres_virtual * bpp / 8;
+        fix->ypanstep           = 1;
 }
 
 static int set_color_mode(struct omapfb_plane_struct *plane,
@@ -1505,7 +1506,7 @@ static int fbinfo_init(struct omapfb_device *fbdev, struct fb_info *info)
 	var->xres = def_vxres;
 	var->yres = def_vyres;
 	var->xres_virtual = def_vxres;
-	var->yres_virtual = def_vyres;
+	var->yres_virtual = def_vyres * 2;
 	var->rotate	  = def_rotate;
 	var->bits_per_pixel = fbdev->panel->bpp;
 
diff --git a/drivers/video/omap/rfbi.c b/drivers/video/omap/rfbi.c
index fed7b1b..188e621 100644
--- a/drivers/video/omap/rfbi.c
+++ b/drivers/video/omap/rfbi.c
@@ -26,6 +26,7 @@
 #include <linux/interrupt.h>
 #include <linux/clk.h>
 #include <linux/io.h>
+#include <linux/platform_device.h>
 
 #include "omapfb.h"
 #include "dispc.h"
@@ -83,13 +84,13 @@ static inline u32 rfbi_read_reg(int idx)
 
 static int rfbi_get_clocks(void)
 {
-	rfbi.dss_ick = clk_get(rfbi.fbdev->dev, "ick");
+	rfbi.dss_ick = clk_get(&omapdss_device.dev, "ick");
 	if (IS_ERR(rfbi.dss_ick)) {
 		dev_err(rfbi.fbdev->dev, "can't get ick\n");
 		return PTR_ERR(rfbi.dss_ick);
 	}
 
-	rfbi.dss1_fck = clk_get(rfbi.fbdev->dev, "dss1_fck");
+	rfbi.dss1_fck = clk_get(&omapdss_device.dev, "dss1_fck");
 	if (IS_ERR(rfbi.dss1_fck)) {
 		dev_err(rfbi.fbdev->dev, "can't get dss1_fck\n");
 		clk_put(rfbi.dss_ick);
diff --git a/drivers/watchdog/omap_wdt.c b/drivers/watchdog/omap_wdt.c
index 2c23dff..c6aaf28 100644
--- a/drivers/watchdog/omap_wdt.c
+++ b/drivers/watchdog/omap_wdt.c
@@ -42,9 +42,6 @@
 #include <linux/bitops.h>
 #include <linux/io.h>
 #include <linux/uaccess.h>
-#ifdef CONFIG_OMAP_WATCHDOG_AUTOPET
-#include <linux/timer.h>
-#endif
 #include <mach/hardware.h>
 #include <plat/prcm.h>
 
@@ -67,11 +64,6 @@ struct omap_wdt_dev {
 	struct clk      *fck;
 	struct resource *mem;
 	struct miscdevice omap_wdt_miscdev;
-#ifdef CONFIG_OMAP_WATCHDOG_AUTOPET
-	struct timer_list autopet_timer;
-	unsigned long  jiffies_start;
-	unsigned long  jiffies_exp;
-#endif
 };
 
 static void omap_wdt_ping(struct omap_wdt_dev *wdev)
@@ -91,23 +83,6 @@ static void omap_wdt_ping(struct omap_wdt_dev *wdev)
 	/* reloaded WCRR from WLDR */
 }
 
-static int omap_wdt_panic(struct notifier_block *this, unsigned long event,
-				void *ptr)
-{
-	struct omap_wdt_dev *wdev = platform_get_drvdata(omap_wdt_dev);
-	unsigned long flags;
-
-	spin_lock_irqsave(&wdt_lock, flags);
-
-	if (wdev && wdev->omap_wdt_users > 0)
-		omap_wdt_ping(wdev);
-
-	spin_unlock_irqrestore(&wdt_lock, flags);
-
-	return NOTIFY_DONE;
-}
-
-
 static void omap_wdt_enable(struct omap_wdt_dev *wdev)
 {
 	void __iomem *base = wdev->base;
@@ -159,8 +134,12 @@ static void omap_wdt_set_timeout(struct omap_wdt_dev *wdev)
 		cpu_relax();
 }
 
-static void omap_wdt_startclocks(struct omap_wdt_dev *wdev)
+/*
+ *	Allow only one task to hold it open
+ */
+static int omap_wdt_open(struct inode *inode, struct file *file)
 {
+	struct omap_wdt_dev *wdev = platform_get_drvdata(omap_wdt_dev);
 	void __iomem *base = wdev->base;
 
 	if (test_and_set_bit(1, (unsigned long *)&(wdev->omap_wdt_users)))
@@ -176,19 +155,6 @@ static void omap_wdt_startclocks(struct omap_wdt_dev *wdev)
 	__raw_writel((1 << 5) | (PTV << 2), base + OMAP_WATCHDOG_CNTRL);
 	while (__raw_readl(base + OMAP_WATCHDOG_WPS) & 0x01)
 		cpu_relax();
-}
-
-/*
- *	Allow only one task to hold it open
- */
-static int omap_wdt_open(struct inode *inode, struct file *file)
-{
-	struct omap_wdt_dev *wdev = platform_get_drvdata(omap_wdt_dev);
-
-	if (test_and_set_bit(1, (unsigned long *)&(wdev->omap_wdt_users)))
-		return -EBUSY;
-
-	omap_wdt_startclocks(wdev);
 
 	file->private_data = (void *) wdev;
 
@@ -223,14 +189,13 @@ static int omap_wdt_release(struct inode *inode, struct file *file)
 static ssize_t omap_wdt_write(struct file *file, const char __user *data,
 		size_t len, loff_t *ppos)
 {
-	unsigned long flags;
 	struct omap_wdt_dev *wdev = file->private_data;
 
 	/* Refresh LOAD_TIME. */
 	if (len) {
-		spin_lock_irqsave(&wdt_lock, flags);
+		spin_lock(&wdt_lock);
 		omap_wdt_ping(wdev);
-		spin_unlock_irqrestore(&wdt_lock, flags);
+		spin_unlock(&wdt_lock);
 	}
 	return len;
 }
@@ -240,7 +205,6 @@ static long omap_wdt_ioctl(struct file *file, unsigned int cmd,
 {
 	struct omap_wdt_dev *wdev;
 	int new_margin;
-	unsigned long flags;
 	static const struct watchdog_info ident = {
 		.identity = "OMAP Watchdog",
 		.options = WDIOF_SETTIMEOUT,
@@ -263,22 +227,22 @@ static long omap_wdt_ioctl(struct file *file, unsigned int cmd,
 			return put_user(omap_prcm_get_reset_sources(),
 					(int __user *)arg);
 	case WDIOC_KEEPALIVE:
-		spin_lock_irqsave(&wdt_lock, flags);
+		spin_lock(&wdt_lock);
 		omap_wdt_ping(wdev);
-		spin_unlock_irqrestore(&wdt_lock, flags);
+		spin_unlock(&wdt_lock);
 		return 0;
 	case WDIOC_SETTIMEOUT:
 		if (get_user(new_margin, (int __user *)arg))
 			return -EFAULT;
 		omap_wdt_adjust_timeout(new_margin);
 
-		spin_lock_irqsave(&wdt_lock, flags);
+		spin_lock(&wdt_lock);
 		omap_wdt_disable(wdev);
 		omap_wdt_set_timeout(wdev);
 		omap_wdt_enable(wdev);
 
 		omap_wdt_ping(wdev);
-		spin_unlock_irqrestore(&wdt_lock, flags);
+		spin_unlock(&wdt_lock);
 		/* Fall */
 	case WDIOC_GETTIMEOUT:
 		return put_user(timer_margin, (int __user *)arg);
@@ -295,21 +259,6 @@ static const struct file_operations omap_wdt_fops = {
 	.release = omap_wdt_release,
 };
 
-#ifdef CONFIG_OMAP_WATCHDOG_AUTOPET
-static void autopet_handler(unsigned long data)
-{
-	unsigned long flags;
-	struct omap_wdt_dev *wdev = (struct omap_wdt_dev *) data;
-
-	spin_lock_irqsave(&wdt_lock, flags);
-	omap_wdt_ping(wdev);
-	spin_unlock_irqrestore(&wdt_lock, flags);
-	wdev->jiffies_start = jiffies;
-	wdev->jiffies_exp = (HZ * TIMER_AUTOPET_FREQ);
-	mod_timer(&wdev->autopet_timer, jiffies + wdev->jiffies_exp);
-}
-#endif
-
 static int __devinit omap_wdt_probe(struct platform_device *pdev)
 {
 	struct resource *res, *mem;
@@ -328,8 +277,7 @@ static int __devinit omap_wdt_probe(struct platform_device *pdev)
 		goto err_busy;
 	}
 
-	mem = request_mem_region(res->start, res->end - res->start + 1,
-				 pdev->name);
+	mem = request_mem_region(res->start, resource_size(res), pdev->name);
 	if (!mem) {
 		ret = -EBUSY;
 		goto err_busy;
@@ -357,7 +305,7 @@ static int __devinit omap_wdt_probe(struct platform_device *pdev)
 		goto err_clk;
 	}
 
-	wdev->base = ioremap(res->start, res->end - res->start + 1);
+	wdev->base = ioremap(res->start, resource_size(res));
 	if (!wdev->base) {
 		ret = -ENOMEM;
 		goto err_ioremap;
@@ -392,18 +340,6 @@ static int __devinit omap_wdt_probe(struct platform_device *pdev)
 
 	omap_wdt_dev = pdev;
 
-#ifdef CONFIG_OMAP_WATCHDOG_AUTOPET
-	setup_timer(&wdev->autopet_timer, autopet_handler,
-		    (unsigned long) wdev);
-	omap_wdt_startclocks(wdev);
-	omap_wdt_set_timeout(wdev);
-	wdev->jiffies_start = jiffies;
-	wdev->jiffies_exp = (HZ * TIMER_AUTOPET_FREQ);
-	mod_timer(&wdev->autopet_timer, jiffies + wdev->jiffies_exp);
-	omap_wdt_enable(wdev);
-	pr_info("Watchdog auto-pet enabled at %d sec intervals\n",
-		TIMER_AUTOPET_FREQ);
-#endif
 	return 0;
 
 err_misc:
@@ -414,7 +350,6 @@ err_ioremap:
 	wdev->base = NULL;
 
 err_clk:
-	printk("clk error in watchdog\n");
 	if (wdev->ick)
 		clk_put(wdev->ick);
 	if (wdev->fck)
@@ -422,7 +357,7 @@ err_clk:
 	kfree(wdev);
 
 err_kzalloc:
-	release_mem_region(res->start, res->end - res->start + 1);
+	release_mem_region(res->start, resource_size(res));
 
 err_busy:
 err_get_resource:
@@ -447,7 +382,7 @@ static int __devexit omap_wdt_remove(struct platform_device *pdev)
 		return -ENOENT;
 
 	misc_deregister(&(wdev->omap_wdt_miscdev));
-	release_mem_region(res->start, res->end - res->start + 1);
+	release_mem_region(res->start, resource_size(res));
 	platform_set_drvdata(pdev, NULL);
 
 	clk_put(wdev->ick);
@@ -468,26 +403,23 @@ static int __devexit omap_wdt_remove(struct platform_device *pdev)
  * may not play well enough with NOWAYOUT...
  */
 
-int omap_wdt_suspend(void)
+static int omap_wdt_suspend(struct platform_device *pdev, pm_message_t state)
 {
-	struct omap_wdt_dev *wdev = platform_get_drvdata(omap_wdt_dev);
+	struct omap_wdt_dev *wdev = platform_get_drvdata(pdev);
 
-	if (wdev->omap_wdt_users) {
-		wdev->jiffies_exp -= jiffies - wdev->jiffies_start;
-		del_timer(&wdev->autopet_timer);
+	if (wdev->omap_wdt_users)
 		omap_wdt_disable(wdev);
-	}
 
 	return 0;
 }
 
-int omap_wdt_resume(void)
+static int omap_wdt_resume(struct platform_device *pdev)
 {
-	struct omap_wdt_dev *wdev = platform_get_drvdata(omap_wdt_dev);
+	struct omap_wdt_dev *wdev = platform_get_drvdata(pdev);
 
 	if (wdev->omap_wdt_users) {
-		mod_timer(&wdev->autopet_timer, jiffies + wdev->jiffies_exp);
 		omap_wdt_enable(wdev);
+		omap_wdt_ping(wdev);
 	}
 
 	return 0;
@@ -502,18 +434,14 @@ static struct platform_driver omap_wdt_driver = {
 	.probe		= omap_wdt_probe,
 	.remove		= __devexit_p(omap_wdt_remove),
 	.shutdown	= omap_wdt_shutdown,
-//	.suspend	= omap_wdt_suspend,
-//	.resume		= omap_wdt_resume,
+	.suspend	= omap_wdt_suspend,
+	.resume		= omap_wdt_resume,
 	.driver		= {
 		.owner	= THIS_MODULE,
 		.name	= "omap_wdt",
 	},
 };
 
-static struct notifier_block panic_blk = {
-	.notifier_call  = omap_wdt_panic,
-};
-
 static int __init omap_wdt_init(void)
 {
 	spin_lock_init(&wdt_lock);
@@ -528,13 +456,6 @@ static void __exit omap_wdt_exit(void)
 module_init(omap_wdt_init);
 module_exit(omap_wdt_exit);
 
-static int __init omap_wdt_panic_init(void)
-{
-	atomic_notifier_chain_register(&panic_notifier_list, &panic_blk);
-}
-
-arch_initcall(omap_wdt_panic_init);
-
 MODULE_AUTHOR("George G. Davis");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
diff --git a/include/linux/spi/tsc2005.h b/include/linux/spi/tsc2005.h
new file mode 100644
index 0000000..1a60c90
--- /dev/null
+++ b/include/linux/spi/tsc2005.h
@@ -0,0 +1,30 @@
+#ifndef _LINUX_SPI_TSC2005_H
+#define _LINUX_SPI_TSC2005_H
+
+#include <linux/types.h>
+
+struct tsc2005_platform_data {
+	u16	ts_x_plate_ohm;
+	u32	ts_stab_time;	/* voltage settling time */
+	u8	ts_hw_avg;	/* HW assiseted averaging. Can be
+				   0, 4, 8, 16 samples per reading */
+	u32	ts_touch_pressure;	/* Pressure limit until we report a
+					   touch event. After that we switch
+					   to ts_max_pressure. */
+	u32	ts_pressure_max;/* Samples with bigger pressure value will
+				   be ignored, since the corresponding X, Y
+				   values are unreliable */
+	u32	ts_pressure_fudge;
+	u32	ts_x_max;
+	u32	ts_x_fudge;
+	u32	ts_y_max;
+	u32	ts_y_fudge;
+
+	u32	esd_timeout;    /* msec of inactivity before we check */
+
+	unsigned ts_ignore_last:1;
+
+	void (*set_reset)(bool enable);
+};
+
+#endif
