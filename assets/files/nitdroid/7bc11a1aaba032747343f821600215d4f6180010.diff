diff --git a/.gitignore b/.gitignore
index 946c7ec..290c6b3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -75,3 +75,4 @@ GTAGS
 *.orig
 *~
 \#*#
+*.rej
diff --git a/arch/arm/include/asm/setup.h b/arch/arm/include/asm/setup.h
index 5ccce0a..1e0b93c 100644
--- a/arch/arm/include/asm/setup.h
+++ b/arch/arm/include/asm/setup.h
@@ -143,6 +143,16 @@ struct tag_memclk {
 	__u32 fmemclk;
 };
 
+/* 
+ * TI OMAP specific information
+ * stolen from original Noka code
+ */
+#define ATAG_BOARD       0x414f4d50
+
+struct tag_omap {
+	u8 data[0];
+};
+
 struct tag {
 	struct tag_header hdr;
 	union {
@@ -162,6 +172,12 @@ struct tag {
 		struct tag_acorn	acorn;
 
 		/*
+		 * OMAP specific
+		 * stolen from original Noka code
+                 */
+                struct tag_omap         omap;
+
+		/*
 		 * DC21285 specific
 		 */
 		struct tag_memclk	memclk;
diff --git a/arch/arm/mach-omap2/Makefile b/arch/arm/mach-omap2/Makefile
index a435cd0..2e03009 100644
--- a/arch/arm/mach-omap2/Makefile
+++ b/arch/arm/mach-omap2/Makefile
@@ -23,6 +23,11 @@ obj-$(CONFIG_ARCH_OMAP2420)		+= sram242x.o
 obj-$(CONFIG_ARCH_OMAP2430)		+= sram243x.o
 obj-$(CONFIG_ARCH_OMAP3)		+= sram34xx.o
 
+# Pin multiplexing
+obj-$(CONFIG_ARCH_OMAP2420)		+= mux2420.o
+obj-$(CONFIG_ARCH_OMAP2430)		+= mux2430.o
+obj-$(CONFIG_ARCH_OMAP3)		+= mux34xx.o
+
 # SMS/SDRC
 obj-$(CONFIG_ARCH_OMAP2)		+= sdrc2xxx.o
 # obj-$(CONFIG_ARCH_OMAP3)		+= sdrc3xxx.o
diff --git a/arch/arm/mach-omap2/board-n8x0.c b/arch/arm/mach-omap2/board-n8x0.c
index 764ab1e..d80b5b2 100644
--- a/arch/arm/mach-omap2/board-n8x0.c
+++ b/arch/arm/mach-omap2/board-n8x0.c
@@ -17,25 +17,432 @@
 #include <linux/init.h>
 #include <linux/io.h>
 #include <linux/stddef.h>
+#include <linux/i2c.h>
 #include <linux/spi/spi.h>
 #include <linux/usb/musb.h>
+#include "../../../sound/soc/codecs/tlv320aic3x.h"
+#include <linux/input.h>
 
 #include <asm/mach/arch.h>
 #include <asm/mach-types.h>
 
 #include <plat/board.h>
 #include <plat/common.h>
+#include <plat/menelaus.h>
 #include <mach/irqs.h>
 #include <plat/mcspi.h>
 #include <plat/onenand.h>
+#include <plat/mmc.h>
 #include <plat/serial.h>
+#include <plat/mux.h>
+
+static int slot1_cover_open;
+static int slot2_cover_open;
+static struct device *mmc_device;
+
+#define TUSB6010_ASYNC_CS	1
+#define TUSB6010_SYNC_CS	4
+#define TUSB6010_GPIO_INT	58
+#define TUSB6010_GPIO_ENABLE	0
+#define TUSB6010_DMACHAN	0x3f
+
+#if defined(CONFIG_USB_TUSB6010) || \
+	defined(CONFIG_USB_TUSB6010_MODULE)
+/*
+ * Enable or disable power to TUSB6010. When enabling, turn on 3.3 V and
+ * 1.5 V voltage regulators of PM companion chip. Companion chip will then
+ * provide then PGOOD signal to TUSB6010 which will release it from reset.
+ */
+static int tusb_set_power(int state)
+{
+	int i, retval = 0;
+
+	if (state) {
+		gpio_set_value(TUSB6010_GPIO_ENABLE, 1);
+		msleep(1);
+
+		/* Wait until TUSB6010 pulls INT pin down */
+		i = 100;
+		while (i && gpio_get_value(TUSB6010_GPIO_INT)) {
+			msleep(1);
+			i--;
+		}
+
+		if (!i) {
+			printk(KERN_ERR "tusb: powerup failed\n");
+			retval = -ENODEV;
+		}
+	} else {
+		gpio_set_value(TUSB6010_GPIO_ENABLE, 0);
+		msleep(10);
+	}
+
+	return retval;
+}
+
+static struct musb_hdrc_config musb_config = {
+	.multipoint	= 1,
+	.dyn_fifo	= 1,
+	.num_eps	= 16,
+	.ram_bits	= 12,
+};
+
+static struct musb_hdrc_platform_data tusb_data = {
+#if defined(CONFIG_USB_MUSB_OTG)
+	.mode		= MUSB_OTG,
+#elif defined(CONFIG_USB_MUSB_PERIPHERAL)
+	.mode		= MUSB_PERIPHERAL,
+#else /* defined(CONFIG_USB_MUSB_HOST) */
+	.mode		= MUSB_HOST,
+#endif
+	.set_power	= tusb_set_power,
+	.min_power	= 25,	/* x2 = 50 mA drawn from VBUS as peripheral */
+	.power		= 100,	/* Max 100 mA VBUS for host mode */
+	.config		= &musb_config,
+};
+
+static void __init n8x0_usb_init(void)
+{
+	int ret = 0;
+	static char	announce[] __initdata = KERN_INFO "TUSB 6010\n";
+
+	/* PM companion chip power control pin */
+	ret = gpio_request(TUSB6010_GPIO_ENABLE, "TUSB6010 enable");
+	if (ret != 0) {
+		printk(KERN_ERR "Could not get TUSB power GPIO%i\n",
+		       TUSB6010_GPIO_ENABLE);
+		return;
+	}
+	gpio_direction_output(TUSB6010_GPIO_ENABLE, 0);
+
+	tusb_set_power(0);
+
+	ret = tusb6010_setup_interface(&tusb_data, TUSB6010_REFCLK_19, 2,
+					TUSB6010_ASYNC_CS, TUSB6010_SYNC_CS,
+					TUSB6010_GPIO_INT, TUSB6010_DMACHAN);
+	if (ret != 0)
+		goto err;
+
+	printk(announce);
+
+	return;
+
+err:
+	gpio_free(TUSB6010_GPIO_ENABLE);
+}
+#else
+
+static void __init n8x0_usb_init(void) {}
+
+#endif /*CONFIG_USB_TUSB6010 */
+
 
 static struct omap2_mcspi_device_config p54spi_mcspi_config = {
 	.turbo_mode	= 0,
 	.single_channel = 1,
 };
 
+#if defined(CONFIG_FB_OMAP_LCD_MIPID)
+/* 
+ * BLIZZARD, MIPID
+ * stolen from original Nokia code
+ * gpio api update 
+ */
+#include <linux/omapfb.h>
+#include <plat/lcd_mipid.h>
+#include <plat/blizzard.h>
+#include <../drivers/cbus/tahvo.h>
+
+#define N8X0_BLIZZARD_POWERDOWN_GPIO	15
+
+static struct omap2_mcspi_device_config mipid_mcspi_config = {
+	.turbo_mode	= 0,
+	.single_channel	= 1,
+};
+
+static void mipid_shutdown(struct mipid_platform_data *pdata)
+{
+	if (pdata->nreset_gpio != -1) {
+		pr_info("shutdown LCD\n");
+		gpio_set_value(pdata->nreset_gpio, 0);
+		msleep(120);
+	}
+}
+
+struct mipid_platform_data n8x0_mipid_platform_data = {
+	.shutdown = mipid_shutdown,
+};
+
+void __init n8x0_mipid_init(void)
+{
+	const struct omap_lcd_config *conf;
+
+	conf = omap_get_config(OMAP_TAG_LCD, struct omap_lcd_config);
+	if (conf != NULL) {
+		n8x0_mipid_platform_data.nreset_gpio = conf->nreset_gpio;
+		n8x0_mipid_platform_data.data_lines = conf->data_lines;
+		printk(KERN_INFO "N8x0 MIPID config loaded");
+	}
+	else
+		printk(KERN_INFO "N8x0 MIPID config not provided");
+}
+
+static struct {
+	struct clk *sys_ck;
+} blizzard;
+
+static int blizzard_get_clocks(void)
+{
+	blizzard.sys_ck = clk_get(0, "osc_ck");
+	if (IS_ERR(blizzard.sys_ck)) {
+		printk(KERN_ERR "can't get Blizzard clock\n");
+		return PTR_ERR(blizzard.sys_ck);
+	}
+	return 0;
+}
+
+static unsigned long blizzard_get_clock_rate(struct device *dev)
+{
+	return clk_get_rate(blizzard.sys_ck);
+}
+
+static void blizzard_enable_clocks(int enable)
+{
+	if (enable)
+		clk_enable(blizzard.sys_ck);
+	else
+		clk_disable(blizzard.sys_ck);
+}
+
+static void blizzard_power_up(struct device *dev)
+{
+	/* Vcore to 1.475V */
+	tahvo_set_clear_reg_bits(0x07, 0, 0xf);
+	msleep(10);
+
+	blizzard_enable_clocks(1);
+	gpio_set_value(N8X0_BLIZZARD_POWERDOWN_GPIO, 1);
+}
+
+static void blizzard_power_down(struct device *dev)
+{
+	gpio_set_value(N8X0_BLIZZARD_POWERDOWN_GPIO, 0);
+	blizzard_enable_clocks(0);
+
+	/* Vcore to 1.005V */
+	tahvo_set_clear_reg_bits(0x07, 0xf, 0);
+}
+
+static struct blizzard_platform_data n8x0_blizzard_data = {
+	.power_up	= blizzard_power_up,
+	.power_down	= blizzard_power_down,
+	.get_clock_rate	= blizzard_get_clock_rate,
+	.te_connected	= 1,
+};
+
+void __init n8x0_blizzard_init(void)
+{
+	int r;
+
+	r = gpio_request(N8X0_BLIZZARD_POWERDOWN_GPIO, "Blizzard pd");
+	if (r < 0)
+	{
+		printk(KERN_ERR "Can't get N8x0 Blizzard powerdown GPIO %d\n", N8X0_BLIZZARD_POWERDOWN_GPIO);
+		return;
+	}
+	gpio_direction_output(N8X0_BLIZZARD_POWERDOWN_GPIO, 1);
+
+	blizzard_get_clocks();
+	omapfb_set_ctrl_platform_data(&n8x0_blizzard_data);
+
+	printk(KERN_INFO "N8x0 Blizzard initialized");
+}
+#endif
+
+#if defined(CONFIG_SPI_TSC2301)
+/* 
+ * TCS2301 touchscreen, keyboard driver
+ * stolen from original Nokia code
+ */
+#include <linux/spi/tsc2301.h>
+
+#define N800_KEYB_IRQ_GPIO		109
+#define N800_DAV_IRQ_GPIO		103
+#define N800_TSC2301_RESET_GPIO		118
+
+static struct tsc2301_platform_data tsc2301_config = {
+	.reset_gpio	= N800_TSC2301_RESET_GPIO,
+	.keymap = {
+		-1,		/* Event for bit 0 */
+		KEY_UP,		/* Event for bit 1 (up) */
+		KEY_F5,		/* Event for bit 2 (home) */
+		-1,		/* Event for bit 3 */
+		KEY_LEFT,	/* Event for bit 4 (left) */
+		KEY_ENTER,	/* Event for bit 5 (enter) */
+		KEY_RIGHT,	/* Event for bit 6 (right) */
+		-1,		/* Event for bit 7 */
+		KEY_ESC,	/* Event for bit 8 (cycle) */
+		KEY_DOWN,	/* Event for bit 9 (down) */
+		KEY_F4,		/* Event for bit 10 (menu) */
+		-1,		/* Event for bit 11 */
+		KEY_F8,		/* Event for bit 12 (Zoom-) */
+		KEY_F6,		/* Event for bit 13 (FS) */
+		KEY_F7,		/* Event for bit 14 (Zoom+) */
+		-1,		/* Event for bit 15 */
+	},
+	.kp_rep 	= 0,
+	.keyb_name	= "Internal keypad",
+};
+
+static void tsc2301_dev_init(void)
+{
+	int r;
+	int gpio = N800_KEYB_IRQ_GPIO;
+
+	r = gpio_request(gpio, "tsc2301 KBD IRQ");
+	if (r >= 0) {
+		gpio_direction_input(gpio);
+		tsc2301_config.keyb_int = gpio_to_irq(gpio);
+	} else {
+		printk(KERN_ERR "unable to get KBD GPIO");
+	}
+
+	gpio = N800_DAV_IRQ_GPIO;
+	r = gpio_request(gpio, "tsc2301 DAV IRQ");
+	if (r >= 0) {
+		gpio_direction_input(gpio);
+		tsc2301_config.dav_int = gpio_to_irq(gpio);
+	} else {
+		printk(KERN_ERR "unable to get DAV GPIO");
+	}
+}
+
+static struct omap2_mcspi_device_config tsc2301_mcspi_config = {
+	.turbo_mode	= 0,
+	.single_channel = 1,
+};
+
+static void __init n800_ts_set_config(void)
+{
+	const struct omap_lcd_config *conf;
+
+	conf = omap_get_config(OMAP_TAG_LCD, struct omap_lcd_config);
+	if (conf != NULL) {
+		if (strcmp(conf->panel_name, "lph8923") == 0) {
+			tsc2301_config.ts_x_plate_ohm	= 180;
+			tsc2301_config.ts_hw_avg	= 8;
+			tsc2301_config.ts_max_pressure	= 2048;
+			tsc2301_config.ts_touch_pressure = 400;
+			tsc2301_config.ts_stab_time	= 100;
+			tsc2301_config.ts_pressure_fudge = 2;
+			tsc2301_config.ts_x_max		= 4096;
+			tsc2301_config.ts_x_fudge	= 4;
+			tsc2301_config.ts_y_max		= 4096;
+			tsc2301_config.ts_y_fudge	= 7;
+		} else if (strcmp(conf->panel_name, "ls041y3") == 0) {
+			tsc2301_config.ts_x_plate_ohm	= 280;
+			tsc2301_config.ts_hw_avg	= 8;
+			tsc2301_config.ts_touch_pressure = 400;
+			tsc2301_config.ts_max_pressure	= 2048;
+			tsc2301_config.ts_stab_time	= 1000;
+			tsc2301_config.ts_pressure_fudge = 2;
+			tsc2301_config.ts_x_max		= 4096;
+			tsc2301_config.ts_x_fudge	= 4;
+			tsc2301_config.ts_y_max		= 4096;
+			tsc2301_config.ts_y_fudge	= 7;
+		} else {
+			printk(KERN_ERR "Unknown panel type, set default "
+			       "touchscreen configuration\n");
+			tsc2301_config.ts_x_plate_ohm	= 200;
+			tsc2301_config.ts_stab_time	= 100;
+		}
+	}
+}
+#else
+static inline void n800_ts_set_config(void)
+{
+}
+#endif
+
+#if defined(CONFIG_TOUCHSCREEN_TSC2005)
+#include <linux/spi/tsc2005.h>
+
+static struct tsc2005_platform_data tsc2005_config = {
+	.reset_gpio = 94,
+	.dav_gpio = 106
+};
+
+static struct omap2_mcspi_device_config tsc2005_mcspi_config = {
+	.turbo_mode	= 0,
+	.single_channel = 1,
+};
+
+static void __init rx44_ts_set_config(void)
+{
+	const struct omap_lcd_config *conf;
+
+	conf = omap_get_config(OMAP_TAG_LCD, struct omap_lcd_config);
+	if (conf != NULL) {
+		if (strcmp(conf->panel_name, "lph8923") == 0) {
+			tsc2005_config.ts_x_plate_ohm	= 180;
+			tsc2005_config.ts_hw_avg	= 0;
+			tsc2005_config.ts_ignore_last	= 0;
+			tsc2005_config.ts_touch_pressure= 1500;
+			tsc2005_config.ts_stab_time	= 100;
+			tsc2005_config.ts_pressure_max	= 2048;
+			tsc2005_config.ts_pressure_fudge= 2;
+			tsc2005_config.ts_x_max		= 4096;
+			tsc2005_config.ts_x_fudge	= 4;
+			tsc2005_config.ts_y_max		= 4096;
+			tsc2005_config.ts_y_fudge	= 7;
+		} else if (strcmp(conf->panel_name, "ls041y3") == 0) {
+			tsc2005_config.ts_x_plate_ohm	= 280;
+			tsc2005_config.ts_hw_avg	= 0;
+			tsc2005_config.ts_ignore_last	= 0;
+			tsc2005_config.ts_touch_pressure= 1500;
+			tsc2005_config.ts_stab_time	= 1000;
+			tsc2005_config.ts_pressure_max	= 2048;
+			tsc2005_config.ts_pressure_fudge= 2;
+			tsc2005_config.ts_x_max		= 4096;
+			tsc2005_config.ts_x_fudge	= 4;
+			tsc2005_config.ts_y_max		= 4096;
+			tsc2005_config.ts_y_fudge	= 7;
+		} else {
+			printk(KERN_ERR "Unknown panel type, set default "
+			       "touchscreen configuration\n");
+			tsc2005_config.ts_x_plate_ohm	= 200;
+			tsc2005_config.ts_stab_time	= 100;
+		}
+	}
+}
+
+#else
+static inline void n810_ts_set_config(void)
+{
+}
+#endif
+
 static struct spi_board_info n800_spi_board_info[] __initdata = {
+#if defined(CONFIG_FB_OMAP_LCD_MIPID)
+	{
+		.modalias	= "lcd_mipid",
+		.bus_num	= 1,
+		.chip_select	= 1,
+		.max_speed_hz	= 4000000,
+		.controller_data= &mipid_mcspi_config,
+		.platform_data	= &n8x0_mipid_platform_data,
+	},
+#endif
+#if defined(CONFIG_SPI_TSC2301)
+	{
+		.modalias	= "tsc2301",
+		.bus_num	= 1,
+		.chip_select	= 0,
+		.max_speed_hz   = 6000000,
+		.controller_data= &tsc2301_mcspi_config,
+		.platform_data  = &tsc2301_config,
+	},
+#endif
 	{
 		.modalias	= "p54spi",
 		.bus_num	= 2,
@@ -45,6 +452,58 @@ static struct spi_board_info n800_spi_board_info[] __initdata = {
 	},
 };
 
+static struct spi_board_info rx44_spi_board_info[] __initdata = {
+#if defined(CONFIG_FB_OMAP_LCD_MIPID)
+	{
+		.modalias	= "lcd_mipid",
+		.bus_num	= 1,
+		.chip_select	= 1,
+		.max_speed_hz	= 4000000,
+		.controller_data= &mipid_mcspi_config,
+		.platform_data	= &rx44_mipid_platform_data,
+	}
+#endif
+/*
+	{
+		.modalias	= "cx3110x",
+		.bus_num	= 2,
+		.chip_select	= 0,
+		.max_speed_hz   = 48000000,
+		.controller_data= &cx3110x_mcspi_config,
+	},
+#ifdef CONFIG_NET_PC2400M_MODULE
+	[2] = {
+		.modalias	= "pc2400m",
+		.bus_num	= 2,
+		.chip_select	= 1,
+		.max_speed_hz   = 24000000,
+		.controller_data= &pc2400m_mcspi_config,
+		.irq		= 33,
+	},
+#endif
+*/
+#ifdef CONFIG_TOUCHSCREEN_TSC2005
+	{
+		.modalias	= "tsc2005",
+		.bus_num	= 1,
+		.chip_select	= 0,
+		.max_speed_hz   = 6000000,
+		.controller_data= &tsc2005_mcspi_config,
+		.platform_data  = &tsc2005_config,
+	}
+#endif	
+};
+
+
+static void __init n8x0_ts_set_config(void)
+{
+	if (machine_is_nokia_n800())
+		n800_ts_set_config();
+	else if (machine_is_nokia_n810() || machine_is_nokia_n810_wimax())
+		rx44_ts_set_config();
+}
+
+
 #if defined(CONFIG_MTD_ONENAND_OMAP2) || \
 	defined(CONFIG_MTD_ONENAND_OMAP2_MODULE)
 
@@ -96,10 +555,438 @@ static void __init n8x0_onenand_init(void) {}
 
 #endif
 
+#if defined(CONFIG_MENELAUS) &&						\
+	(defined(CONFIG_MMC_OMAP) || defined(CONFIG_MMC_OMAP_MODULE))
+
+/*
+ * On both N800 and N810, only the first of the two MMC controllers is in use.
+ * The two MMC slots are multiplexed via Menelaus companion chip over I2C.
+ * On N800, both slots are powered via Menelaus. On N810, only one of the
+ * slots is powered via Menelaus. The N810 EMMC is powered via GPIO.
+ *
+ * VMMC				slot 1 on both N800 and N810
+ * VDCDC3_APE and VMCS2_APE	slot 2 on N800
+ * GPIO23 and GPIO9		slot 2 EMMC on N810
+ *
+ */
+#define N8X0_SLOT_SWITCH_GPIO	96
+#define N810_EMMC_VSD_GPIO	23
+#define N810_EMMC_VIO_GPIO	9
+
+static int n8x0_mmc_switch_slot(struct device *dev, int slot)
+{
+#ifdef CONFIG_MMC_DEBUG
+	dev_dbg(dev, "Choose slot %d\n", slot + 1);
+#endif
+	gpio_set_value(N8X0_SLOT_SWITCH_GPIO, slot);
+	return 0;
+}
+
+static int n8x0_mmc_set_power_menelaus(struct device *dev, int slot,
+					int power_on, int vdd)
+{
+	int mV;
+
+#ifdef CONFIG_MMC_DEBUG
+	dev_dbg(dev, "Set slot %d power: %s (vdd %d)\n", slot + 1,
+		power_on ? "on" : "off", vdd);
+#endif
+	if (slot == 0) {
+		if (!power_on)
+			return menelaus_set_vmmc(0);
+		switch (1 << vdd) {
+		case MMC_VDD_33_34:
+		case MMC_VDD_32_33:
+		case MMC_VDD_31_32:
+			mV = 3100;
+			break;
+		case MMC_VDD_30_31:
+			mV = 3000;
+			break;
+		case MMC_VDD_28_29:
+			mV = 2800;
+			break;
+		case MMC_VDD_165_195:
+			mV = 1850;
+			break;
+		default:
+			BUG();
+		}
+		return menelaus_set_vmmc(mV);
+	} else {
+		if (!power_on)
+			return menelaus_set_vdcdc(3, 0);
+		switch (1 << vdd) {
+		case MMC_VDD_33_34:
+		case MMC_VDD_32_33:
+			mV = 3300;
+			break;
+		case MMC_VDD_30_31:
+		case MMC_VDD_29_30:
+			mV = 3000;
+			break;
+		case MMC_VDD_28_29:
+		case MMC_VDD_27_28:
+			mV = 2800;
+			break;
+		case MMC_VDD_24_25:
+		case MMC_VDD_23_24:
+			mV = 2400;
+			break;
+		case MMC_VDD_22_23:
+		case MMC_VDD_21_22:
+			mV = 2200;
+			break;
+		case MMC_VDD_20_21:
+			mV = 2000;
+			break;
+		case MMC_VDD_165_195:
+			mV = 1800;
+			break;
+		default:
+			BUG();
+		}
+		return menelaus_set_vdcdc(3, mV);
+	}
+	return 0;
+}
+
+static void n810_set_power_emmc(struct device *dev,
+					 int power_on)
+{
+	dev_dbg(dev, "Set EMMC power %s\n", power_on ? "on" : "off");
+
+	if (power_on) {
+		gpio_set_value(N810_EMMC_VSD_GPIO, 1);
+		msleep(1);
+		gpio_set_value(N810_EMMC_VIO_GPIO, 1);
+		msleep(1);
+	} else {
+		gpio_set_value(N810_EMMC_VIO_GPIO, 0);
+		msleep(50);
+		gpio_set_value(N810_EMMC_VSD_GPIO, 0);
+		msleep(50);
+	}
+}
+
+static int n8x0_mmc_set_power(struct device *dev, int slot, int power_on,
+			      int vdd)
+{
+	if (machine_is_nokia_n800() || slot == 0)
+		return n8x0_mmc_set_power_menelaus(dev, slot, power_on, vdd);
+
+	n810_set_power_emmc(dev, power_on);
+
+	return 0;
+}
+
+static int n8x0_mmc_set_bus_mode(struct device *dev, int slot, int bus_mode)
+{
+	int r;
+
+	dev_dbg(dev, "Set slot %d bus mode %s\n", slot + 1,
+		bus_mode == MMC_BUSMODE_OPENDRAIN ? "open-drain" : "push-pull");
+	BUG_ON(slot != 0 && slot != 1);
+	slot++;
+	switch (bus_mode) {
+	case MMC_BUSMODE_OPENDRAIN:
+		r = menelaus_set_mmc_opendrain(slot, 1);
+		break;
+	case MMC_BUSMODE_PUSHPULL:
+		r = menelaus_set_mmc_opendrain(slot, 0);
+		break;
+	default:
+		BUG();
+	}
+	if (r != 0 && printk_ratelimit())
+		dev_err(dev, "MMC: unable to set bus mode for slot %d\n",
+			slot);
+	return r;
+}
+
+static int n8x0_mmc_get_cover_state(struct device *dev, int slot)
+{
+	slot++;
+	BUG_ON(slot != 1 && slot != 2);
+	if (slot == 1)
+		return slot1_cover_open;
+	else
+		return slot2_cover_open;
+}
+
+static void n8x0_mmc_callback(void *data, u8 card_mask)
+{
+	int bit, *openp, index;
+
+	if (machine_is_nokia_n800()) {
+		bit = 1 << 1;
+		openp = &slot2_cover_open;
+		index = 1;
+	} else {
+		bit = 1;
+		openp = &slot1_cover_open;
+		index = 0;
+	}
+
+	if (card_mask & bit)
+		*openp = 1;
+	else
+		*openp = 0;
+
+	omap_mmc_notify_cover_event(mmc_device, index, *openp);
+}
+
+static int n8x0_mmc_late_init(struct device *dev)
+{
+	int r, bit, *openp;
+	int vs2sel;
+
+	mmc_device = dev;
+
+	r = menelaus_set_slot_sel(1);
+	if (r < 0)
+		return r;
+
+	if (machine_is_nokia_n800())
+		vs2sel = 0;
+	else
+		vs2sel = 2;
+
+	r = menelaus_set_mmc_slot(2, 0, vs2sel, 1);
+	if (r < 0)
+		return r;
+
+	n8x0_mmc_set_power(dev, 0, MMC_POWER_ON, 16); /* MMC_VDD_28_29 */
+	n8x0_mmc_set_power(dev, 1, MMC_POWER_ON, 16);
+
+	r = menelaus_set_mmc_slot(1, 1, 0, 1);
+	if (r < 0)
+		return r;
+	r = menelaus_set_mmc_slot(2, 1, vs2sel, 1);
+	if (r < 0)
+		return r;
+
+	r = menelaus_get_slot_pin_states();
+	if (r < 0)
+		return r;
+
+	if (machine_is_nokia_n800()) {
+		bit = 1 << 1;
+		openp = &slot2_cover_open;
+	} else {
+		bit = 1;
+		openp = &slot1_cover_open;
+		slot2_cover_open = 0;
+	}
+
+	/* All slot pin bits seem to be inversed until first switch change */
+	if (r == 0xf || r == (0xf & ~bit))
+		r = ~r;
+
+	if (r & bit)
+		*openp = 1;
+	else
+		*openp = 0;
+
+	r = menelaus_register_mmc_callback(n8x0_mmc_callback, NULL);
+
+	return r;
+}
+
+static void n8x0_mmc_shutdown(struct device *dev)
+{
+	int vs2sel;
+
+	if (machine_is_nokia_n800())
+		vs2sel = 0;
+	else
+		vs2sel = 2;
+
+	menelaus_set_mmc_slot(1, 0, 0, 0);
+	menelaus_set_mmc_slot(2, 0, vs2sel, 0);
+}
+
+static void n8x0_mmc_cleanup(struct device *dev)
+{
+	menelaus_unregister_mmc_callback();
+
+	gpio_free(N8X0_SLOT_SWITCH_GPIO);
+
+	if (machine_is_nokia_n810() || machine_is_nokia_n810_wimax()) {
+		gpio_free(N810_EMMC_VSD_GPIO);
+		gpio_free(N810_EMMC_VIO_GPIO);
+	}
+}
+
+/*
+ * MMC controller1 has two slots that are multiplexed via I2C.
+ * MMC controller2 is not in use.
+ */
+static struct omap_mmc_platform_data mmc1_data = {
+	.nr_slots			= 2,
+	.switch_slot			= n8x0_mmc_switch_slot,
+	.init				= n8x0_mmc_late_init,
+	.cleanup			= n8x0_mmc_cleanup,
+	.shutdown			= n8x0_mmc_shutdown,
+	.max_freq			= 24000000,
+	.dma_mask			= 0xffffffff,
+	.slots[0] = {
+		.wires			= 4,
+		.set_power		= n8x0_mmc_set_power,
+		.set_bus_mode		= n8x0_mmc_set_bus_mode,
+		.get_cover_state	= n8x0_mmc_get_cover_state,
+		.ocr_mask		= MMC_VDD_165_195 | MMC_VDD_30_31 |
+						MMC_VDD_32_33   | MMC_VDD_33_34,
+		.name			= "internal",
+	},
+	.slots[1] = {
+		.set_power		= n8x0_mmc_set_power,
+		.set_bus_mode		= n8x0_mmc_set_bus_mode,
+		.get_cover_state	= n8x0_mmc_get_cover_state,
+		.ocr_mask		= MMC_VDD_165_195 | MMC_VDD_20_21 |
+						MMC_VDD_21_22 | MMC_VDD_22_23 |
+						MMC_VDD_23_24 | MMC_VDD_24_25 |
+						MMC_VDD_27_28 | MMC_VDD_28_29 |
+						MMC_VDD_29_30 | MMC_VDD_30_31 |
+						MMC_VDD_32_33 | MMC_VDD_33_34,
+		.name			= "external",
+	},
+};
+
+static struct omap_mmc_platform_data *mmc_data[OMAP24XX_NR_MMC];
+
+static void __init n8x0_mmc_init(void)
+
+{
+	int err;
+
+	if (machine_is_nokia_n810() || machine_is_nokia_n810_wimax()) {
+		mmc1_data.slots[0].name = "external";
+
+		/*
+		 * Some Samsung Movinand chips do not like open-ended
+		 * multi-block reads and fall to braind-dead state
+		 * while doing so. Reducing the number of blocks in
+		 * the transfer or delays in clock disable do not help
+		 */
+		mmc1_data.slots[1].name = "internal";
+		mmc1_data.slots[1].ban_openended = 1;
+	}
+
+	err = gpio_request(N8X0_SLOT_SWITCH_GPIO, "MMC slot switch");
+	if (err)
+		return;
+
+	gpio_direction_output(N8X0_SLOT_SWITCH_GPIO, 0);
+
+	if (machine_is_nokia_n810() || machine_is_nokia_n810_wimax()) {
+		err = gpio_request(N810_EMMC_VSD_GPIO, "MMC slot 2 Vddf");
+		if (err) {
+			gpio_free(N8X0_SLOT_SWITCH_GPIO);
+			return;
+		}
+		gpio_direction_output(N810_EMMC_VSD_GPIO, 0);
+
+		err = gpio_request(N810_EMMC_VIO_GPIO, "MMC slot 2 Vdd");
+		if (err) {
+			gpio_free(N8X0_SLOT_SWITCH_GPIO);
+			gpio_free(N810_EMMC_VSD_GPIO);
+			return;
+		}
+		gpio_direction_output(N810_EMMC_VIO_GPIO, 0);
+	}
+
+	mmc_data[0] = &mmc1_data;
+	omap2_init_mmc(mmc_data, OMAP24XX_NR_MMC);
+}
+#else
+
+void __init n8x0_mmc_init(void)
+{
+}
+#endif	/* CONFIG_MMC_OMAP */
+
+#ifdef CONFIG_MENELAUS
+
+static int n8x0_auto_sleep_regulators(void)
+{
+	u32 val;
+	int ret;
+
+	val = EN_VPLL_SLEEP | EN_VMMC_SLEEP    \
+		| EN_VAUX_SLEEP | EN_VIO_SLEEP \
+		| EN_VMEM_SLEEP | EN_DC3_SLEEP \
+		| EN_VC_SLEEP | EN_DC2_SLEEP;
+
+	ret = menelaus_set_regulator_sleep(1, val);
+	if (ret < 0) {
+		printk(KERN_ERR "Could not set regulators to sleep on "
+			"menelaus: %u\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int n8x0_auto_voltage_scale(void)
+{
+	int ret;
+
+	ret = menelaus_set_vcore_hw(1400, 1050);
+	if (ret < 0) {
+		printk(KERN_ERR "Could not set VCORE voltage on "
+			"menelaus: %u\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int n8x0_menelaus_late_init(struct device *dev)
+{
+	int ret;
+
+	ret = n8x0_auto_voltage_scale();
+	if (ret < 0)
+		return ret;
+	ret = n8x0_auto_sleep_regulators();
+	if (ret < 0)
+		return ret;
+	return 0;
+}
+
+#else
+static int n8x0_menelaus_late_init(struct device *dev)
+{
+	return 0;
+}
+#endif
+
+static struct menelaus_platform_data n8x0_menelaus_platform_data __initdata = {
+	.late_init = n8x0_menelaus_late_init,
+};
+
+static struct i2c_board_info __initdata n8x0_i2c_board_info_1[] __initdata = {
+	{
+		I2C_BOARD_INFO("menelaus", 0x72),
+		.irq = INT_24XX_SYS_NIRQ,
+		.platform_data = &n8x0_menelaus_platform_data,
+	},
+};
+
+static struct aic3x_pdata n810_aic33_data __initdata = {
+	.gpio_reset = 118,
+};
+
+static struct i2c_board_info n810_i2c_board_info_2[] __initdata = {
+	{
+		I2C_BOARD_INFO("tlv320aic3x", 0x18),
+		.platform_data = &n810_aic33_data,
+	},
+};
+
 static void __init n8x0_map_io(void)
 {
 	omap2_set_globals_242x();
-	omap2_map_common_io();
+	omap242x_map_common_io();
 }
 
 static void __init n8x0_init_irq(void)
@@ -109,41 +996,72 @@ static void __init n8x0_init_irq(void)
 	omap_gpio_init();
 }
 
+#ifdef CONFIG_OMAP_MUX
+static struct omap_board_mux board_mux[] __initdata = {
+	/* I2S codec port pins for McBSP block */
+	OMAP2420_MUX(EAC_AC_SCLK, OMAP_MUX_MODE1 | OMAP_PIN_INPUT),
+	OMAP2420_MUX(EAC_AC_FS, OMAP_MUX_MODE1 | OMAP_PIN_INPUT),
+	OMAP2420_MUX(EAC_AC_DIN, OMAP_MUX_MODE1 | OMAP_PIN_INPUT),
+	OMAP2420_MUX(EAC_AC_DOUT, OMAP_MUX_MODE1 | OMAP_PIN_OUTPUT),
+	{ .reg_offset = OMAP_MUX_TERMINATOR },
+};
+#else
+#define board_mux	NULL
+#endif
+
 static void __init n8x0_init_machine(void)
 {
+	omap2420_mux_init(board_mux, OMAP_PACKAGE_ZAC);
 	/* FIXME: add n810 spi devices */
-	spi_register_board_info(n800_spi_board_info,
-				ARRAY_SIZE(n800_spi_board_info));
+	if (machine_is_nokia_n800())
+		spi_register_board_info(n800_spi_board_info,
+					ARRAY_SIZE(n800_spi_board_info));
+	else if (machine_is_nokia_n810() || machine_is_nokia_n810_wimax())
+		spi_register_board_info(rx44_spi_board_info,
+					ARRAY_SIZE(rx44_spi_board_info));
+	omap_register_i2c_bus(1, 400, n8x0_i2c_board_info_1,
+			      ARRAY_SIZE(n8x0_i2c_board_info_1));
+	omap_register_i2c_bus(2, 400, NULL, 0);
+	if (machine_is_nokia_n810() || machine_is_nokia_n810_wimax())
+		i2c_register_board_info(2, n810_i2c_board_info_2,
+					ARRAY_SIZE(n810_i2c_board_info_2));
 
 	omap_serial_init();
 	n8x0_onenand_init();
+	n8x0_mmc_init();
+	n8x0_usb_init();
+#if defined(CONFIG_FB_OMAP_LCD_MIPID)
+	n8x0_mipid_init();
+	n8x0_blizzard_init();
+#endif
+	n8x0_ts_set_config();
+#if defined(CONFIG_TOUCHSCREEN_TSC2301)
+	tsc2301_dev_init();
+#endif
 }
 
 MACHINE_START(NOKIA_N800, "Nokia N800")
-	.phys_io	= 0x48000000,
-	.io_pg_offst	= ((0xfa000000) >> 18) & 0xfffc,
 	.boot_params	= 0x80000100,
 	.map_io		= n8x0_map_io,
+//	.reserve	= omap_reserve,
 	.init_irq	= n8x0_init_irq,
 	.init_machine	= n8x0_init_machine,
 	.timer		= &omap_timer,
 MACHINE_END
 
 MACHINE_START(NOKIA_N810, "Nokia N810")
-	.phys_io	= 0x48000000,
-	.io_pg_offst	= ((0xfa000000) >> 18) & 0xfffc,
 	.boot_params	= 0x80000100,
 	.map_io		= n8x0_map_io,
+//	.reserve	= omap_reserve,
 	.init_irq	= n8x0_init_irq,
 	.init_machine	= n8x0_init_machine,
 	.timer		= &omap_timer,
 MACHINE_END
 
 MACHINE_START(NOKIA_N810_WIMAX, "Nokia N810 WiMAX")
-	.phys_io	= 0x48000000,
-	.io_pg_offst	= ((0xfa000000) >> 18) & 0xfffc,
 	.boot_params	= 0x80000100,
 	.map_io		= n8x0_map_io,
+//	.reserve	= omap_reserve,
 	.init_irq	= n8x0_init_irq,
 	.init_machine	= n8x0_init_machine,
 	.timer		= &omap_timer,
diff --git a/arch/arm/mach-omap2/io.c b/arch/arm/mach-omap2/io.c
index ac31a6c..709198f 100644
--- a/arch/arm/mach-omap2/io.c
+++ b/arch/arm/mach-omap2/io.c
@@ -271,6 +271,53 @@ void __init omap2_map_common_io(void)
 	dspbridge_reserve_sdram();
 }
 
+static void __init _omap2_map_common_io(void)
+{
+	/* Normally devicemaps_init() would flush caches and tlb after
+	 * mdesc->map_io(), but we must also do it here because of the CPU
+	 * revision check below.
+	 */
+	local_flush_tlb_all();
+	flush_cache_all();
+
+	omap2_check_revision();
+	omap_sram_init();
+}
+
+#ifdef CONFIG_ARCH_OMAP2420
+void __init omap242x_map_common_io(void)
+{
+	iotable_init(omap24xx_io_desc, ARRAY_SIZE(omap24xx_io_desc));
+	iotable_init(omap242x_io_desc, ARRAY_SIZE(omap242x_io_desc));
+	_omap2_map_common_io();
+}
+#endif
+
+#ifdef CONFIG_ARCH_OMAP2430
+void __init omap243x_map_common_io(void)
+{
+	iotable_init(omap24xx_io_desc, ARRAY_SIZE(omap24xx_io_desc));
+	iotable_init(omap243x_io_desc, ARRAY_SIZE(omap243x_io_desc));
+	_omap2_map_common_io();
+}
+#endif
+
+#ifdef CONFIG_ARCH_OMAP3
+void __init omap34xx_map_common_io(void)
+{
+	iotable_init(omap34xx_io_desc, ARRAY_SIZE(omap34xx_io_desc));
+	_omap2_map_common_io();
+}
+#endif
+
+#ifdef CONFIG_ARCH_OMAP4
+void __init omap44xx_map_common_io(void)
+{
+	iotable_init(omap44xx_io_desc, ARRAY_SIZE(omap44xx_io_desc));
+	_omap2_map_common_io();
+}
+#endif
+
 /*
  * omap2_init_reprogram_sdrc - reprogram SDRC timing parameters
  *
@@ -306,10 +353,7 @@ static int __init _omap2_init_reprogram_sdrc(void)
 }
 
 void __init omap2_init_common_hw(struct omap_sdrc_params *sdrc_cs0,
-				 struct omap_sdrc_params *sdrc_cs1,
-				 struct omap_opp *mpu_opps,
-				 struct omap_opp *dsp_opps,
-				 struct omap_opp *l3_opps)
+				 struct omap_sdrc_params *sdrc_cs1)
 {
 	struct omap_hwmod **hwmods = NULL;
 
diff --git a/arch/arm/mach-omap2/mux.c b/arch/arm/mach-omap2/mux.c
index 099ef1f..0351c3e 100644
--- a/arch/arm/mach-omap2/mux.c
+++ b/arch/arm/mach-omap2/mux.c
@@ -33,6 +33,20 @@
 #include <plat/control.h>
 #include <plat/mux.h>
 
+#define OMAP_MUX_BASE_OFFSET		0x30	/* Offset from CTRL_BASE */
+#define OMAP_MUX_BASE_SZ		0x5ca
+#define MUXABLE_GPIO_MODE3		BIT(0)
+
+struct omap_mux_entry {
+	struct omap_mux		mux;
+	struct list_head	node;
+};
+
+static unsigned long mux_phys;
+static void __iomem *mux_base;
+static u8 omap_mux_flags;
+
+
 #ifdef CONFIG_OMAP_MUX
 
 static struct omap_mux_cfg arch_mux_cfg;
@@ -853,4 +867,705 @@ int __init omap2_mux_init(void)
 	return omap_mux_register(&arch_mux_cfg);
 }
 
+u16 omap_mux_read(u16 reg)
+{
+	if (cpu_is_omap24xx())
+		return __raw_readb(mux_base + reg);
+	else
+		return __raw_readw(mux_base + reg);
+}
+
+void omap_mux_write(u16 val, u16 reg)
+{
+	if (cpu_is_omap24xx())
+		__raw_writeb(val, mux_base + reg);
+	else
+		__raw_writew(val, mux_base + reg);
+}
+
+void omap_mux_write_array(struct omap_board_mux *board_mux)
+{
+	while (board_mux->reg_offset !=  OMAP_MUX_TERMINATOR) {
+		omap_mux_write(board_mux->value, board_mux->reg_offset);
+		board_mux++;
+	}
+}
+
+static LIST_HEAD(muxmodes);
+static DEFINE_MUTEX(muxmode_mutex);
+
+#ifdef CONFIG_OMAP_MUX
+
+static char *omap_mux_options;
+
+int __init omap_mux_init_gpio(int gpio, int val)
+{
+	struct omap_mux_entry *e;
+	struct omap_mux *gpio_mux = NULL;
+	u16 old_mode;
+	u16 mux_mode;
+	int found = 0;
+
+	if (!gpio)
+		return -EINVAL;
+
+	list_for_each_entry(e, &muxmodes, node) {
+		struct omap_mux *m = &e->mux;
+		if (gpio == m->gpio) {
+			gpio_mux = m;
+			found++;
+		}
+	}
+
+	if (found == 0) {
+		printk(KERN_ERR "mux: Could not set gpio%i\n", gpio);
+		return -ENODEV;
+	}
+
+	if (found > 1) {
+		printk(KERN_INFO "mux: Multiple gpio paths (%d) for gpio%i\n",
+				found, gpio);
+		return -EINVAL;
+	}
+
+	old_mode = omap_mux_read(gpio_mux->reg_offset);
+	mux_mode = val & ~(OMAP_MUX_NR_MODES - 1);
+	if (omap_mux_flags & MUXABLE_GPIO_MODE3)
+		mux_mode |= OMAP_MUX_MODE3;
+	else
+		mux_mode |= OMAP_MUX_MODE4;
+	printk(KERN_DEBUG "mux: Setting signal %s.gpio%i 0x%04x -> 0x%04x\n",
+			gpio_mux->muxnames[0], gpio, old_mode, mux_mode);
+	omap_mux_write(mux_mode, gpio_mux->reg_offset);
+
+	return 0;
+}
+
+int __init omap_mux_init_signal(const char *muxname, int val)
+{
+	struct omap_mux_entry *e;
+	const char *mode_name;
+	int found = 0, mode0_len = 0;
+
+	mode_name = strchr(muxname, '.');
+	if (mode_name) {
+		mode0_len = strlen(muxname) - strlen(mode_name);
+		mode_name++;
+	} else {
+		mode_name = muxname;
+	}
+
+	list_for_each_entry(e, &muxmodes, node) {
+		struct omap_mux *m = &e->mux;
+		char *m0_entry = m->muxnames[0];
+		int i;
+
+		/* First check for full name in mode0.muxmode format */
+		if (mode0_len && strncmp(muxname, m0_entry, mode0_len))
+			continue;
+
+		/* Then check for muxmode only */
+		for (i = 0; i < OMAP_MUX_NR_MODES; i++) {
+			char *mode_cur = m->muxnames[i];
+
+			if (!mode_cur)
+				continue;
+
+			if (!strcmp(mode_name, mode_cur)) {
+				u16 old_mode;
+				u16 mux_mode;
+
+				old_mode = omap_mux_read(m->reg_offset);
+				mux_mode = val | i;
+				printk(KERN_DEBUG "mux: Setting signal "
+					"%s.%s 0x%04x -> 0x%04x\n",
+					m0_entry, muxname, old_mode, mux_mode);
+				omap_mux_write(mux_mode, m->reg_offset);
+				found++;
+			}
+		}
+	}
+
+	if (found == 1)
+		return 0;
+
+	if (found > 1) {
+		printk(KERN_ERR "mux: Multiple signal paths (%i) for %s\n",
+				found, muxname);
+		return -EINVAL;
+	}
+
+	printk(KERN_ERR "mux: Could not set signal %s\n", muxname);
+
+	return -ENODEV;
+}
+
+#ifdef CONFIG_DEBUG_FS
+
+#define OMAP_MUX_MAX_NR_FLAGS	10
+#define OMAP_MUX_TEST_FLAG(val, mask)				\
+	if (((val) & (mask)) == (mask)) {			\
+		i++;						\
+		flags[i] =  #mask;				\
+	}
+
+/* REVISIT: Add checking for non-optimal mux settings */
+static inline void omap_mux_decode(struct seq_file *s, u16 val)
+{
+	char *flags[OMAP_MUX_MAX_NR_FLAGS];
+	char mode[sizeof("OMAP_MUX_MODE") + 1];
+	int i = -1;
+
+	sprintf(mode, "OMAP_MUX_MODE%d", val & 0x7);
+	i++;
+	flags[i] = mode;
+
+	OMAP_MUX_TEST_FLAG(val, OMAP_PIN_OFF_WAKEUPENABLE);
+	if (val & OMAP_OFF_EN) {
+		if (!(val & OMAP_OFFOUT_EN)) {
+			if (!(val & OMAP_OFF_PULL_UP)) {
+				OMAP_MUX_TEST_FLAG(val,
+					OMAP_PIN_OFF_INPUT_PULLDOWN);
+			} else {
+				OMAP_MUX_TEST_FLAG(val,
+					OMAP_PIN_OFF_INPUT_PULLUP);
+			}
+		} else {
+			if (!(val & OMAP_OFFOUT_VAL)) {
+				OMAP_MUX_TEST_FLAG(val,
+					OMAP_PIN_OFF_OUTPUT_LOW);
+			} else {
+				OMAP_MUX_TEST_FLAG(val,
+					OMAP_PIN_OFF_OUTPUT_HIGH);
+			}
+		}
+	}
+
+	if (val & OMAP_INPUT_EN) {
+		if (val & OMAP_PULL_ENA) {
+			if (!(val & OMAP_PULL_UP)) {
+				OMAP_MUX_TEST_FLAG(val,
+					OMAP_PIN_INPUT_PULLDOWN);
+			} else {
+				OMAP_MUX_TEST_FLAG(val, OMAP_PIN_INPUT_PULLUP);
+			}
+		} else {
+			OMAP_MUX_TEST_FLAG(val, OMAP_PIN_INPUT);
+		}
+	} else {
+		i++;
+		flags[i] = "OMAP_PIN_OUTPUT";
+	}
+
+	do {
+		seq_printf(s, "%s", flags[i]);
+		if (i > 0)
+			seq_printf(s, " | ");
+	} while (i-- > 0);
+}
+
+#define OMAP_MUX_DEFNAME_LEN	16
+
+static int omap_mux_dbg_board_show(struct seq_file *s, void *unused)
+{
+	struct omap_mux_entry *e;
+
+	list_for_each_entry(e, &muxmodes, node) {
+		struct omap_mux *m = &e->mux;
+		char m0_def[OMAP_MUX_DEFNAME_LEN];
+		char *m0_name = m->muxnames[0];
+		u16 val;
+		int i, mode;
+
+		if (!m0_name)
+			continue;
+
+		/* REVISIT: Needs to be updated if mode0 names get longer */
+		for (i = 0; i < OMAP_MUX_DEFNAME_LEN; i++) {
+			if (m0_name[i] == '\0') {
+				m0_def[i] = m0_name[i];
+				break;
+			}
+			m0_def[i] = toupper(m0_name[i]);
+		}
+		val = omap_mux_read(m->reg_offset);
+		mode = val & OMAP_MUX_MODE7;
+
+		seq_printf(s, "OMAP%i_MUX(%s, ",
+					cpu_is_omap34xx() ? 3 : 0, m0_def);
+		omap_mux_decode(s, val);
+		seq_printf(s, "),\n");
+	}
+
+	return 0;
+}
+
+static int omap_mux_dbg_board_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, omap_mux_dbg_board_show, &inode->i_private);
+}
+
+static const struct file_operations omap_mux_dbg_board_fops = {
+	.open		= omap_mux_dbg_board_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int omap_mux_dbg_signal_show(struct seq_file *s, void *unused)
+{
+	struct omap_mux *m = s->private;
+	const char *none = "NA";
+	u16 val;
+	int mode;
+
+	val = omap_mux_read(m->reg_offset);
+	mode = val & OMAP_MUX_MODE7;
+
+	seq_printf(s, "name: %s.%s (0x%08lx/0x%03x = 0x%04x), b %s, t %s\n",
+			m->muxnames[0], m->muxnames[mode],
+			mux_phys + m->reg_offset, m->reg_offset, val,
+			m->balls[0] ? m->balls[0] : none,
+			m->balls[1] ? m->balls[1] : none);
+	seq_printf(s, "mode: ");
+	omap_mux_decode(s, val);
+	seq_printf(s, "\n");
+	seq_printf(s, "signals: %s | %s | %s | %s | %s | %s | %s | %s\n",
+			m->muxnames[0] ? m->muxnames[0] : none,
+			m->muxnames[1] ? m->muxnames[1] : none,
+			m->muxnames[2] ? m->muxnames[2] : none,
+			m->muxnames[3] ? m->muxnames[3] : none,
+			m->muxnames[4] ? m->muxnames[4] : none,
+			m->muxnames[5] ? m->muxnames[5] : none,
+			m->muxnames[6] ? m->muxnames[6] : none,
+			m->muxnames[7] ? m->muxnames[7] : none);
+
+	return 0;
+}
+
+#define OMAP_MUX_MAX_ARG_CHAR  7
+
+static ssize_t omap_mux_dbg_signal_write(struct file *file,
+						const char __user *user_buf,
+						size_t count, loff_t *ppos)
+{
+	char buf[OMAP_MUX_MAX_ARG_CHAR];
+	struct seq_file *seqf;
+	struct omap_mux *m;
+	unsigned long val;
+	int buf_size, ret;
+
+	if (count > OMAP_MUX_MAX_ARG_CHAR)
+		return -EINVAL;
+
+	memset(buf, 0, sizeof(buf));
+	buf_size = min(count, sizeof(buf) - 1);
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	ret = strict_strtoul(buf, 0x10, &val);
+	if (ret < 0)
+		return ret;
+
+	if (val > 0xffff)
+		return -EINVAL;
+
+	seqf = file->private_data;
+	m = seqf->private;
+
+	omap_mux_write((u16)val, m->reg_offset);
+	*ppos += count;
+
+	return count;
+}
+
+static int omap_mux_dbg_signal_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, omap_mux_dbg_signal_show, inode->i_private);
+}
+
+static const struct file_operations omap_mux_dbg_signal_fops = {
+	.open		= omap_mux_dbg_signal_open,
+	.read		= seq_read,
+	.write		= omap_mux_dbg_signal_write,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static struct dentry *mux_dbg_dir;
+
+static void __init omap_mux_dbg_init(void)
+{
+	struct omap_mux_entry *e;
+
+	mux_dbg_dir = debugfs_create_dir("omap_mux", NULL);
+	if (!mux_dbg_dir)
+		return;
+
+	(void)debugfs_create_file("board", S_IRUGO, mux_dbg_dir,
+					NULL, &omap_mux_dbg_board_fops);
+
+	list_for_each_entry(e, &muxmodes, node) {
+		struct omap_mux *m = &e->mux;
+
+		(void)debugfs_create_file(m->muxnames[0], S_IWUGO, mux_dbg_dir,
+					m, &omap_mux_dbg_signal_fops);
+	}
+}
+
+#else
+static inline void omap_mux_dbg_init(void)
+{
+}
+#endif	/* CONFIG_DEBUG_FS */
+
+static void __init omap_mux_free_names(struct omap_mux *m)
+{
+	int i;
+
+	for (i = 0; i < OMAP_MUX_NR_MODES; i++)
+		kfree(m->muxnames[i]);
+
+#ifdef CONFIG_DEBUG_FS
+	for (i = 0; i < OMAP_MUX_NR_SIDES; i++)
+		kfree(m->balls[i]);
+#endif
+
+}
+
+/* Free all data except for GPIO pins unless CONFIG_DEBUG_FS is set */
+static int __init omap_mux_late_init(void)
+{
+	struct omap_mux_entry *e, *tmp;
+
+	list_for_each_entry_safe(e, tmp, &muxmodes, node) {
+		struct omap_mux *m = &e->mux;
+		u16 mode = omap_mux_read(m->reg_offset);
+
+		if (OMAP_MODE_GPIO(mode))
+			continue;
+
+#ifndef CONFIG_DEBUG_FS
+		mutex_lock(&muxmode_mutex);
+		list_del(&e->node);
+		mutex_unlock(&muxmode_mutex);
+		omap_mux_free_names(m);
+		kfree(m);
+#endif
+
+	}
+
+	omap_mux_dbg_init();
+
+	return 0;
+}
+late_initcall(omap_mux_late_init);
+
+static void __init omap_mux_package_fixup(struct omap_mux *p,
+					struct omap_mux *superset)
+{
+	while (p->reg_offset !=  OMAP_MUX_TERMINATOR) {
+		struct omap_mux *s = superset;
+		int found = 0;
+
+		while (s->reg_offset != OMAP_MUX_TERMINATOR) {
+			if (s->reg_offset == p->reg_offset) {
+				*s = *p;
+				found++;
+				break;
+			}
+			s++;
+		}
+		if (!found)
+			printk(KERN_ERR "mux: Unknown entry offset 0x%x\n",
+					p->reg_offset);
+		p++;
+	}
+}
+
+#ifdef CONFIG_DEBUG_FS
+
+static void __init omap_mux_package_init_balls(struct omap_ball *b,
+				struct omap_mux *superset)
+{
+	while (b->reg_offset != OMAP_MUX_TERMINATOR) {
+		struct omap_mux *s = superset;
+		int found = 0;
+
+		while (s->reg_offset != OMAP_MUX_TERMINATOR) {
+			if (s->reg_offset == b->reg_offset) {
+				s->balls[0] = b->balls[0];
+				s->balls[1] = b->balls[1];
+				found++;
+				break;
+			}
+			s++;
+		}
+		if (!found)
+			printk(KERN_ERR "mux: Unknown ball offset 0x%x\n",
+					b->reg_offset);
+		b++;
+	}
+}
+
+#else	/* CONFIG_DEBUG_FS */
+
+static inline void omap_mux_package_init_balls(struct omap_ball *b,
+					struct omap_mux *superset)
+{
+}
+
+#endif	/* CONFIG_DEBUG_FS */
+
+static int __init omap_mux_setup(char *options)
+{
+	if (!options)
+		return 0;
+
+	omap_mux_options = options;
+
+	return 1;
+}
+__setup("omap_mux=", omap_mux_setup);
+
+/*
+ * Note that the omap_mux=some.signal1=0x1234,some.signal2=0x1234
+ * cmdline options only override the bootloader values.
+ * During development, please enable CONFIG_DEBUG_FS, and use the
+ * signal specific entries under debugfs.
+ */
+static void __init omap_mux_set_cmdline_signals(void)
+{
+	char *options, *next_opt, *token;
+
+	if (!omap_mux_options)
+		return;
+
+	options = kmalloc(strlen(omap_mux_options) + 1, GFP_KERNEL);
+	if (!options)
+		return;
+
+	strcpy(options, omap_mux_options);
+	next_opt = options;
+
+	while ((token = strsep(&next_opt, ",")) != NULL) {
+		char *keyval, *name;
+		unsigned long val;
+
+		keyval = token;
+		name = strsep(&keyval, "=");
+		if (name) {
+			int res;
+
+			res = strict_strtoul(keyval, 0x10, &val);
+			if (res < 0)
+				continue;
+
+			omap_mux_init_signal(name, (u16)val);
+		}
+	}
+
+	kfree(options);
+}
+
+static int __init omap_mux_copy_names(struct omap_mux *src,
+					struct omap_mux *dst)
+{
+	int i;
+
+	for (i = 0; i < OMAP_MUX_NR_MODES; i++) {
+		if (src->muxnames[i]) {
+			dst->muxnames[i] =
+				kmalloc(strlen(src->muxnames[i]) + 1,
+					GFP_KERNEL);
+			if (!dst->muxnames[i])
+				goto free;
+			strcpy(dst->muxnames[i], src->muxnames[i]);
+		}
+	}
+
+#ifdef CONFIG_DEBUG_FS
+	for (i = 0; i < OMAP_MUX_NR_SIDES; i++) {
+		if (src->balls[i]) {
+			dst->balls[i] =
+				kmalloc(strlen(src->balls[i]) + 1,
+					GFP_KERNEL);
+			if (!dst->balls[i])
+				goto free;
+			strcpy(dst->balls[i], src->balls[i]);
+		}
+	}
+#endif
+
+	return 0;
+
+free:
+	omap_mux_free_names(dst);
+	return -ENOMEM;
+
+}
+
+#endif	/* CONFIG_OMAP_MUX */
+
+static u16 omap_mux_get_by_gpio(int gpio)
+{
+	struct omap_mux_entry *e;
+	u16 offset = OMAP_MUX_TERMINATOR;
+
+	list_for_each_entry(e, &muxmodes, node) {
+		struct omap_mux *m = &e->mux;
+		if (m->gpio == gpio) {
+			offset = m->reg_offset;
+			break;
+		}
+	}
+
+	return offset;
+}
+
+/* Needed for dynamic muxing of GPIO pins for off-idle */
+u16 omap_mux_get_gpio(int gpio)
+{
+	u16 offset;
+
+	offset = omap_mux_get_by_gpio(gpio);
+	if (offset == OMAP_MUX_TERMINATOR) {
+		printk(KERN_ERR "mux: Could not get gpio%i\n", gpio);
+		return offset;
+	}
+
+	return omap_mux_read(offset);
+}
+
+/* Needed for dynamic muxing of GPIO pins for off-idle */
+void omap_mux_set_gpio(u16 val, int gpio)
+{
+	u16 offset;
+
+	offset = omap_mux_get_by_gpio(gpio);
+	if (offset == OMAP_MUX_TERMINATOR) {
+		printk(KERN_ERR "mux: Could not set gpio%i\n", gpio);
+		return;
+	}
+
+	omap_mux_write(val, offset);
+}
+
+static struct omap_mux * __init omap_mux_list_add(struct omap_mux *src)
+{
+	struct omap_mux_entry *entry;
+	struct omap_mux *m;
+
+	entry = kzalloc(sizeof(struct omap_mux_entry), GFP_KERNEL);
+	if (!entry)
+		return NULL;
+
+	m = &entry->mux;
+	memcpy(m, src, sizeof(struct omap_mux_entry));
+
+#ifdef CONFIG_OMAP_MUX
+	if (omap_mux_copy_names(src, m)) {
+		kfree(entry);
+		return NULL;
+	}
+#endif
+
+	mutex_lock(&muxmode_mutex);
+	list_add_tail(&entry->node, &muxmodes);
+	mutex_unlock(&muxmode_mutex);
+
+	return m;
+}
+
+/*
+ * Note if CONFIG_OMAP_MUX is not selected, we will only initialize
+ * the GPIO to mux offset mapping that is needed for dynamic muxing
+ * of GPIO pins for off-idle.
+ */
+static void __init omap_mux_init_list(struct omap_mux *superset)
+{
+	while (superset->reg_offset !=  OMAP_MUX_TERMINATOR) {
+		struct omap_mux *entry;
+
+#ifdef CONFIG_OMAP_MUX
+		if (!superset->muxnames || !superset->muxnames[0]) {
+			superset++;
+			continue;
+		}
+#else
+		/* Skip pins that are not muxed as GPIO by bootloader */
+		if (!OMAP_MODE_GPIO(omap_mux_read(superset->reg_offset))) {
+			superset++;
+			continue;
+		}
+#endif
+
+		entry = omap_mux_list_add(superset);
+		if (!entry) {
+			printk(KERN_ERR "mux: Could not add entry\n");
+			return;
+		}
+		superset++;
+	}
+}
+
+#ifdef CONFIG_OMAP_MUX
+
+static void omap_mux_init_package(struct omap_mux *superset,
+				  struct omap_mux *package_subset,
+				  struct omap_ball *package_balls)
+{
+	if (package_subset)
+		omap_mux_package_fixup(package_subset, superset);
+	if (package_balls)
+		omap_mux_package_init_balls(package_balls, superset);
+}
+
+static void omap_mux_init_signals(struct omap_board_mux *board_mux)
+{
+	omap_mux_set_cmdline_signals();
+	omap_mux_write_array(board_mux);
+}
+
+#else
+
+static void omap_mux_init_package(struct omap_mux *superset,
+				  struct omap_mux *package_subset,
+				  struct omap_ball *package_balls)
+{
+}
+
+static void omap_mux_init_signals(struct omap_board_mux *board_mux)
+{
+}
+
+#endif
+
+int __init omap_mux_init(u32 mux_pbase, u32 mux_size,
+				struct omap_mux *superset,
+				struct omap_mux *package_subset,
+				struct omap_board_mux *board_mux,
+				struct omap_ball *package_balls)
+{
+	if (mux_base)
+		return -EBUSY;
+
+	mux_phys = mux_pbase;
+	mux_base = ioremap(mux_pbase, mux_size);
+	if (!mux_base) {
+		printk(KERN_ERR "mux: Could not ioremap\n");
+		return -ENODEV;
+	}
+
+	if (cpu_is_omap24xx())
+		omap_mux_flags = MUXABLE_GPIO_MODE3;
+
+	omap_mux_init_package(superset, package_subset, package_balls);
+	omap_mux_init_list(superset);
+	omap_mux_init_signals(board_mux);
+
+	return 0;
+}
+
 #endif
diff --git a/arch/arm/mach-omap2/mux2420.c b/arch/arm/mach-omap2/mux2420.c
new file mode 100644
index 0000000..81c9f61
--- /dev/null
+++ b/arch/arm/mach-omap2/mux2420.c
@@ -0,0 +1,688 @@
+/*
+ * Copyright (C) 2010 Nokia
+ * Copyright (C) 2010 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <plat/mux.h>
+
+#ifdef CONFIG_OMAP_MUX
+
+#define _OMAP2420_MUXENTRY(M0, g, m0, m1, m2, m3, m4, m5, m6, m7)		\
+{									\
+	.reg_offset	= (OMAP2420_CONTROL_PADCONF_##M0##_OFFSET),	\
+	.gpio		= (g),						\
+	.muxnames	= { m0, m1, m2, m3, m4, m5, m6, m7 },		\
+}
+
+#else
+
+#define _OMAP2420_MUXENTRY(M0, g, m0, m1, m2, m3, m4, m5, m6, m7)		\
+{									\
+	.reg_offset	= (OMAP2420_CONTROL_PADCONF_##M0##_OFFSET),	\
+	.gpio		= (g),						\
+}
+
+#endif
+
+#define _OMAP2420_BALLENTRY(M0, bb, bt)					\
+{									\
+	.reg_offset	= (OMAP2420_CONTROL_PADCONF_##M0##_OFFSET),	\
+	.balls		= { bb, bt },					\
+}
+
+/*
+ * Superset of all mux modes for omap2420
+ */
+static struct omap_mux __initdata omap2420_muxmodes[] = {
+	_OMAP2420_MUXENTRY(CAM_D0, 54,
+		"cam_d0", "hw_dbg2", "sti_dout", "gpio_54",
+		NULL, NULL, "etk_d2", NULL),
+	_OMAP2420_MUXENTRY(CAM_D1, 53,
+		"cam_d1", "hw_dbg3", "sti_din", "gpio_53",
+		NULL, NULL, "etk_d3", NULL),
+	_OMAP2420_MUXENTRY(CAM_D2, 52,
+		"cam_d2", "hw_dbg4", "mcbsp1_clkx", "gpio_52",
+		NULL, NULL, "etk_d4", NULL),
+	_OMAP2420_MUXENTRY(CAM_D3, 51,
+		"cam_d3", "hw_dbg5", "mcbsp1_dr", "gpio_51",
+		NULL, NULL, "etk_d5", NULL),
+	_OMAP2420_MUXENTRY(CAM_D4, 50,
+		"cam_d4", "hw_dbg6", "mcbsp1_fsr", "gpio_50",
+		NULL, NULL, "etk_d6", NULL),
+	_OMAP2420_MUXENTRY(CAM_D5, 49,
+		"cam_d5", "hw_dbg7", "mcbsp1_clkr", "gpio_49",
+		NULL, NULL, "etk_d7", NULL),
+	_OMAP2420_MUXENTRY(CAM_D6, 0,
+		"cam_d6", "hw_dbg8", NULL, NULL,
+		NULL, NULL, "etk_d8", NULL),
+	_OMAP2420_MUXENTRY(CAM_D7, 0,
+		"cam_d7", "hw_dbg9", NULL, NULL,
+		NULL, NULL, "etk_d9", NULL),
+	_OMAP2420_MUXENTRY(CAM_D8, 54,
+		"cam_d8", "hw_dbg10", NULL, "gpio_54",
+		NULL, NULL, "etk_d10", NULL),
+	_OMAP2420_MUXENTRY(CAM_D9, 53,
+		"cam_d9", "hw_dbg11", NULL, "gpio_53",
+		NULL, NULL, "etk_d11", NULL),
+	_OMAP2420_MUXENTRY(CAM_HS, 55,
+		"cam_hs", "hw_dbg1", "mcbsp1_dx", "gpio_55",
+		NULL, NULL, "etk_d1", NULL),
+	_OMAP2420_MUXENTRY(CAM_LCLK, 57,
+		"cam_lclk", NULL, "mcbsp_clks", "gpio_57",
+		NULL, NULL, "etk_c1", NULL),
+	_OMAP2420_MUXENTRY(CAM_VS, 56,
+		"cam_vs", "hw_dbg0", "mcbsp1_fsx", "gpio_56",
+		NULL, NULL, "etk_d0", NULL),
+	_OMAP2420_MUXENTRY(CAM_XCLK, 0,
+		"cam_xclk", NULL, "sti_clk", NULL,
+		NULL, NULL, "etk_c2", NULL),
+	_OMAP2420_MUXENTRY(DSS_ACBIAS, 48,
+		"dss_acbias", NULL, "mcbsp2_fsx", "gpio_48",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(DSS_DATA10, 40,
+		"dss_data10", NULL, NULL, "gpio_40",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(DSS_DATA11, 41,
+		"dss_data11", NULL, NULL, "gpio_41",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(DSS_DATA12, 42,
+		"dss_data12", NULL, NULL, "gpio_42",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(DSS_DATA13, 43,
+		"dss_data13", NULL, NULL, "gpio_43",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(DSS_DATA14, 44,
+		"dss_data14", NULL, NULL, "gpio_44",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(DSS_DATA15, 45,
+		"dss_data15", NULL, NULL, "gpio_45",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(DSS_DATA16, 46,
+		"dss_data16", NULL, NULL, "gpio_46",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(DSS_DATA17, 47,
+		"dss_data17", NULL, NULL, "gpio_47",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(DSS_DATA8, 38,
+		"dss_data8", NULL, NULL, "gpio_38",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(DSS_DATA9, 39,
+		"dss_data9", NULL, NULL, "gpio_39",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(EAC_AC_DIN, 115,
+		"eac_ac_din", "mcbsp2_dr", NULL, "gpio_115",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(EAC_AC_DOUT, 116,
+		"eac_ac_dout", "mcbsp2_dx", NULL, "gpio_116",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(EAC_AC_FS, 114,
+		"eac_ac_fs", "mcbsp2_fsx", NULL, "gpio_114",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(EAC_AC_MCLK, 117,
+		"eac_ac_mclk", NULL, NULL, "gpio_117",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(EAC_AC_RST, 118,
+		"eac_ac_rst", "eac_bt_din", NULL, "gpio_118",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(EAC_AC_SCLK, 113,
+		"eac_ac_sclk", "mcbsp2_clkx", NULL, "gpio_113",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(EAC_BT_DIN, 73,
+		"eac_bt_din", NULL, NULL, "gpio_73",
+		NULL, NULL, "etk_d9", NULL),
+	_OMAP2420_MUXENTRY(EAC_BT_DOUT, 74,
+		"eac_bt_dout", NULL, "sti_clk", "gpio_74",
+		NULL, NULL, "etk_d8", NULL),
+	_OMAP2420_MUXENTRY(EAC_BT_FS, 72,
+		"eac_bt_fs", NULL, NULL, "gpio_72",
+		NULL, NULL, "etk_d10", NULL),
+	_OMAP2420_MUXENTRY(EAC_BT_SCLK, 71,
+		"eac_bt_sclk", NULL, NULL, "gpio_71",
+		NULL, NULL, "etk_d11", NULL),
+	_OMAP2420_MUXENTRY(GPIO_119, 119,
+		"gpio_119", NULL, "sti_din", "gpio_119",
+		NULL, "sys_boot0", "etk_d12", NULL),
+	_OMAP2420_MUXENTRY(GPIO_120, 120,
+		"gpio_120", NULL, "sti_dout", "gpio_120",
+		"cam_d9", "sys_boot1", "etk_d13", NULL),
+	_OMAP2420_MUXENTRY(GPIO_121, 121,
+		"gpio_121", NULL, NULL, "gpio_121",
+		"jtag_emu2", "sys_boot2", "etk_d14", NULL),
+	_OMAP2420_MUXENTRY(GPIO_122, 122,
+		"gpio_122", NULL, NULL, "gpio_122",
+		"jtag_emu3", "sys_boot3", "etk_d15", NULL),
+	_OMAP2420_MUXENTRY(GPIO_124, 124,
+		"gpio_124", NULL, NULL, "gpio_124",
+		NULL, "sys_boot5", NULL, NULL),
+	_OMAP2420_MUXENTRY(GPIO_125, 125,
+		"gpio_125", "sys_jtagsel1", "sys_jtagsel2", "gpio_125",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPIO_36, 36,
+		"gpio_36", NULL, NULL, "gpio_36",
+		NULL, "sys_boot4", NULL, NULL),
+	_OMAP2420_MUXENTRY(GPIO_62, 62,
+		"gpio_62", "uart1_rx", "usb1_dat", "gpio_62",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPIO_6, 6,
+		"gpio_6", "tv_detpulse", NULL, "gpio_6",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_A10, 3,
+		"gpmc_a10", NULL, "sys_ndmareq5", "gpio_3",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_A1, 12,
+		"gpmc_a1", "dss_data18", NULL, "gpio_12",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_A2, 11,
+		"gpmc_a2", "dss_data19", NULL, "gpio_11",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_A3, 10,
+		"gpmc_a3", "dss_data20", NULL, "gpio_10",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_A4, 9,
+		"gpmc_a4", "dss_data21", NULL, "gpio_9",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_A5, 8,
+		"gpmc_a5", "dss_data22", NULL, "gpio_8",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_A6, 7,
+		"gpmc_a6", "dss_data23", NULL, "gpio_7",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_A7, 6,
+		"gpmc_a7", NULL, "sys_ndmareq2", "gpio_6",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_A8, 5,
+		"gpmc_a8", NULL, "sys_ndmareq3", "gpio_5",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_A9, 4,
+		"gpmc_a9", NULL, "sys_ndmareq4", "gpio_4",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_CLK, 21,
+		"gpmc_clk", NULL, NULL, "gpio_21",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_D10, 18,
+		"gpmc_d10", "ssi2_rdy_rx", NULL, "gpio_18",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_D11, 17,
+		"gpmc_d11", "ssi2_flag_rx", NULL, "gpio_17",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_D12, 16,
+		"gpmc_d12", "ssi2_dat_rx", NULL, "gpio_16",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_D13, 15,
+		"gpmc_d13", "ssi2_rdy_tx", NULL, "gpio_15",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_D14, 14,
+		"gpmc_d14", "ssi2_flag_tx", NULL, "gpio_14",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_D15, 13,
+		"gpmc_d15", "ssi2_dat_tx", NULL, "gpio_13",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_D8, 20,
+		"gpmc_d8", NULL, NULL, "gpio_20",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_D9, 19,
+		"gpmc_d9", "ssi2_wake", NULL, "gpio_19",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_NBE0, 29,
+		"gpmc_nbe0", NULL, NULL, "gpio_29",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_NBE1, 30,
+		"gpmc_nbe1", NULL, NULL, "gpio_30",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_NCS1, 22,
+		"gpmc_ncs1", NULL, NULL, "gpio_22",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_NCS2, 23,
+		"gpmc_ncs2", NULL, NULL, "gpio_23",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_NCS3, 24,
+		"gpmc_ncs3", "gpmc_io_dir", NULL, "gpio_24",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_NCS4, 25,
+		"gpmc_ncs4", NULL, NULL, "gpio_25",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_NCS5, 26,
+		"gpmc_ncs5", NULL, NULL, "gpio_26",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_NCS6, 27,
+		"gpmc_ncs6", NULL, NULL, "gpio_27",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_NCS7, 28,
+		"gpmc_ncs7", "gpmc_io_dir", "gpio_28", NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_NWP, 31,
+		"gpmc_nwp", NULL, NULL, "gpio_31",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_WAIT1, 33,
+		"gpmc_wait1", NULL, NULL, "gpio_33",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_WAIT2, 34,
+		"gpmc_wait2", NULL, NULL, "gpio_34",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(GPMC_WAIT3, 35,
+		"gpmc_wait3", NULL, NULL, "gpio_35",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(HDQ_SIO, 101,
+		"hdq_sio", "usb2_tllse0", "sys_altclk", "gpio_101",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(I2C2_SCL, 99,
+		"i2c2_scl", NULL, "gpt9_pwm_evt", "gpio_99",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(I2C2_SDA, 100,
+		"i2c2_sda", NULL, "spi2_ncs1", "gpio_100",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(JTAG_EMU0, 127,
+		"jtag_emu0", NULL, NULL, "gpio_127",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(JTAG_EMU1, 126,
+		"jtag_emu1", NULL, NULL, "gpio_126",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MCBSP1_CLKR, 92,
+		"mcbsp1_clkr", "ssi2_dat_tx", "vlynq_tx1", "gpio_92",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MCBSP1_CLKX, 98,
+		"mcbsp1_clkx", "ssi2_wake", "vlynq_nla", "gpio_98",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MCBSP1_DR, 95,
+		"mcbsp1_dr", "ssi2_dat_rx", "vlynq_rx1", "gpio_95",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MCBSP1_DX, 94,
+		"mcbsp1_dx", "ssi2_rdy_tx", "vlynq_clk", "gpio_94",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MCBSP1_FSR, 93,
+		"mcbsp1_fsr", "ssi2_flag_tx", "vlynq_tx0", "gpio_93",
+		"spi2_ncs1", NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MCBSP1_FSX, 97,
+		"mcbsp1_fsx", "ssi2_rdy_rx", NULL, "gpio_97",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MCBSP2_CLKX, 12,
+		"mcbsp2_clkx", NULL, "dss_data23", "gpio_12",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MCBSP2_DR, 11,
+		"mcbsp2_dr", NULL, "dss_data22", "gpio_11",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MCBSP_CLKS, 96,
+		"mcbsp_clks", "ssi2_flag_rx", "vlynq_rx0", "gpio_96",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MMC_CLKI, 59,
+		"sdmmc_clki", "ms_clki", NULL, "gpio_59",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MMC_CLKO, 0,
+		"sdmmc_clko", "ms_clko", NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MMC_CMD_DIR, 8,
+		"sdmmc_cmd_dir", NULL, NULL, "gpio_8",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MMC_CMD, 0,
+		"sdmmc_cmd", "ms_bs", NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MMC_DAT_DIR0, 7,
+		"sdmmc_dat_dir0", "ms_dat0_dir", NULL, "gpio_7",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MMC_DAT0, 0,
+		"sdmmc_dat0", "ms_dat0", NULL, NULL,
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MMC_DAT_DIR1, 78,
+		"sdmmc_dat_dir1", "ms_datu_dir", "uart2_rts", "gpio_78",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MMC_DAT1, 75,
+		"sdmmc_dat1", "ms_dat1", NULL, "gpio_75",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MMC_DAT_DIR2, 79,
+		"sdmmc_dat_dir2", "ms_datu_dir", "uart2_tx", "gpio_79",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MMC_DAT2, 76,
+		"sdmmc_dat2", "ms_dat2", "uart2_cts", "gpio_76",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MMC_DAT_DIR3, 80,
+		"sdmmc_dat_dir3", "ms_datu_dir", "uart2_rx", "gpio_80",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(MMC_DAT3, 77,
+		"sdmmc_dat3", "ms_dat3", NULL, "gpio_77",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SDRC_A12, 2,
+		"sdrc_a12", NULL, NULL, "gpio_2",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SDRC_A13, 1,
+		"sdrc_a13", NULL, NULL, "gpio_1",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SDRC_A14, 0,
+		"sdrc_a14", NULL, NULL, "gpio_0",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SDRC_CKE1, 38,
+		"sdrc_cke1", NULL, NULL, "gpio_38",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SDRC_NCS1, 37,
+		"sdrc_ncs1", NULL, NULL, "gpio_37",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SPI1_CLK, 81,
+		"spi1_clk", NULL, NULL, "gpio_81",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SPI1_NCS0, 84,
+		"spi1_ncs0", NULL, NULL, "gpio_84",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SPI1_NCS1, 85,
+		"spi1_ncs1", NULL, NULL, "gpio_85",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SPI1_NCS2, 86,
+		"spi1_ncs2", NULL, NULL, "gpio_86",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SPI1_NCS3, 87,
+		"spi1_ncs3", NULL, NULL, "gpio_87",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SPI1_SIMO, 82,
+		"spi1_simo", NULL, NULL, "gpio_82",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SPI1_SOMI, 83,
+		"spi1_somi", NULL, NULL, "gpio_83",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SPI2_CLK, 88,
+		"spi2_clk", NULL, NULL, "gpio_88",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SPI2_NCS0, 91,
+		"spi2_ncs0", "gpt12_pwm_evt", NULL, "gpio_91",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SPI2_SIMO, 89,
+		"spi2_simo", "gpt10_pwm_evt", NULL, "gpio_89",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SPI2_SOMI, 90,
+		"spi2_somi", "gpt11_pwm_evt", NULL, "gpio_90",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SSI1_DAT_RX, 63,
+		"ssi1_dat_rx", "eac_md_sclk", NULL, "gpio_63",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SSI1_DAT_TX, 59,
+		"ssi1_dat_tx", "uart1_tx", "usb1_se0", "gpio_59",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SSI1_FLAG_RX, 64,
+		"ssi1_flag_rx", "eac_md_din", NULL, "gpio_64",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SSI1_FLAG_TX, 25,
+		"ssi1_flag_tx", "uart1_rts", "usb1_rcv", "gpio_25",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SSI1_RDY_RX, 65,
+		"ssi1_rdy_rx", "eac_md_dout", NULL, "gpio_65",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SSI1_RDY_TX, 61,
+		"ssi1_rdy_tx", "uart1_cts", "usb1_txen", "gpio_61",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SSI1_WAKE, 66,
+		"ssi1_wake", "eac_md_fs", NULL, "gpio_66",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SYS_CLKOUT, 123,
+		"sys_clkout", NULL, NULL, "gpio_123",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SYS_CLKREQ, 52,
+		"sys_clkreq", NULL, NULL, "gpio_52",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(SYS_NIRQ, 60,
+		"sys_nirq", NULL, NULL, "gpio_60",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(UART1_CTS, 32,
+		"uart1_cts", NULL, "dss_data18", "gpio_32",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(UART1_RTS, 8,
+		"uart1_rts", NULL, "dss_data19", "gpio_8",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(UART1_RX, 10,
+		"uart1_rx", NULL, "dss_data21", "gpio_10",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(UART1_TX, 9,
+		"uart1_tx", NULL, "dss_data20", "gpio_9",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(UART2_CTS, 67,
+		"uart2_cts", "usb1_rcv", "gpt9_pwm_evt", "gpio_67",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(UART2_RTS, 68,
+		"uart2_rts", "usb1_txen", "gpt10_pwm_evt", "gpio_68",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(UART2_RX, 70,
+		"uart2_rx", "usb1_dat", "gpt12_pwm_evt", "gpio_70",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(UART2_TX, 69,
+		"uart2_tx", "usb1_se0", "gpt11_pwm_evt", "gpio_69",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(UART3_CTS_RCTX, 102,
+		"uart3_cts_rctx", "uart3_rx_irrx", NULL, "gpio_102",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(UART3_RTS_SD, 103,
+		"uart3_rts_sd", "uart3_tx_irtx", NULL, "gpio_103",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(UART3_RX_IRRX, 105,
+		"uart3_rx_irrx", NULL, NULL, "gpio_105",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(UART3_TX_IRTX, 104,
+		"uart3_tx_irtx", "uart3_cts_rctx", NULL, "gpio_104",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(USB0_DAT, 112,
+		"usb0_dat", "uart3_rx_irrx", "uart2_rx", "gpio_112",
+		"uart2_tx", NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(USB0_PUEN, 106,
+		"usb0_puen", "mcbsp2_dx", NULL, "gpio_106",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(USB0_RCV, 109,
+		"usb0_rcv", "mcbsp2_fsx", NULL, "gpio_109",
+		"uart2_cts", NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(USB0_SE0, 111,
+		"usb0_se0", "uart3_tx_irtx", "uart2_tx", "gpio_111",
+		"uart2_rx", NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(USB0_TXEN, 110,
+		"usb0_txen", "uart3_cts_rctx", "uart2_cts", "gpio_110",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(USB0_VM, 108,
+		"usb0_vm", "mcbsp2_clkx", NULL, "gpio_108",
+		"uart2_rx", NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(USB0_VP, 107,
+		"usb0_vp", "mcbsp2_dr", NULL, "gpio_107",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(VLYNQ_CLK, 13,
+		"vlynq_clk", "usb2_se0", "sys_ndmareq0", "gpio_13",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(VLYNQ_NLA, 58,
+		"vlynq_nla", NULL, NULL, "gpio_58",
+		"cam_d6", NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(VLYNQ_RX0, 15,
+		"vlynq_rx0", "usb2_tllse0", NULL, "gpio_15",
+		"cam_d7", NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(VLYNQ_RX1, 14,
+		"vlynq_rx1", "usb2_rcv", "sys_ndmareq1", "gpio_14",
+		"cam_d8", NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(VLYNQ_TX0, 17,
+		"vlynq_tx0", "usb2_txen", NULL, "gpio_17",
+		NULL, NULL, NULL, NULL),
+	_OMAP2420_MUXENTRY(VLYNQ_TX1, 16,
+		"vlynq_tx1", "usb2_dat", "sys_clkout2", "gpio_16",
+		NULL, NULL, NULL, NULL),
+	{ .reg_offset = OMAP_MUX_TERMINATOR },
+};
+
+/*
+ * Balls for 447-pin POP package
+ */
+#ifdef CONFIG_DEBUG_FS
+static struct omap_ball __initdata omap2420_pop_ball[] = {
+	_OMAP2420_BALLENTRY(CAM_D0, "y4", NULL),
+	_OMAP2420_BALLENTRY(CAM_D1, "y3", NULL),
+	_OMAP2420_BALLENTRY(CAM_D2, "u7", NULL),
+	_OMAP2420_BALLENTRY(CAM_D3, "ab3", NULL),
+	_OMAP2420_BALLENTRY(CAM_D4, "v2", NULL),
+	_OMAP2420_BALLENTRY(CAM_D5, "ad3", NULL),
+	_OMAP2420_BALLENTRY(CAM_D6, "aa4", NULL),
+	_OMAP2420_BALLENTRY(CAM_D7, "ab4", NULL),
+	_OMAP2420_BALLENTRY(CAM_D8, "ac6", NULL),
+	_OMAP2420_BALLENTRY(CAM_D9, "ac7", NULL),
+	_OMAP2420_BALLENTRY(CAM_HS, "v4", NULL),
+	_OMAP2420_BALLENTRY(CAM_LCLK, "ad6", NULL),
+	_OMAP2420_BALLENTRY(CAM_VS, "p7", NULL),
+	_OMAP2420_BALLENTRY(CAM_XCLK, "w4", NULL),
+	_OMAP2420_BALLENTRY(DSS_ACBIAS, "ae8", NULL),
+	_OMAP2420_BALLENTRY(DSS_DATA10, "ac12", NULL),
+	_OMAP2420_BALLENTRY(DSS_DATA11, "ae11", NULL),
+	_OMAP2420_BALLENTRY(DSS_DATA12, "ae13", NULL),
+	_OMAP2420_BALLENTRY(DSS_DATA13, "ad13", NULL),
+	_OMAP2420_BALLENTRY(DSS_DATA14, "ac13", NULL),
+	_OMAP2420_BALLENTRY(DSS_DATA15, "y12", NULL),
+	_OMAP2420_BALLENTRY(DSS_DATA16, "ad14", NULL),
+	_OMAP2420_BALLENTRY(DSS_DATA17, "y13", NULL),
+	_OMAP2420_BALLENTRY(DSS_DATA8, "ad11", NULL),
+	_OMAP2420_BALLENTRY(DSS_DATA9, "ad12", NULL),
+	_OMAP2420_BALLENTRY(EAC_AC_DIN, "ad19", NULL),
+	_OMAP2420_BALLENTRY(EAC_AC_DOUT, "af22", NULL),
+	_OMAP2420_BALLENTRY(EAC_AC_FS, "ad16", NULL),
+	_OMAP2420_BALLENTRY(EAC_AC_MCLK, "y17", NULL),
+	_OMAP2420_BALLENTRY(EAC_AC_RST, "ae22", NULL),
+	_OMAP2420_BALLENTRY(EAC_AC_SCLK, "ac18", NULL),
+	_OMAP2420_BALLENTRY(EAC_BT_DIN, "u8", NULL),
+	_OMAP2420_BALLENTRY(EAC_BT_DOUT, "ad5", NULL),
+	_OMAP2420_BALLENTRY(EAC_BT_FS, "w7", NULL),
+	_OMAP2420_BALLENTRY(EAC_BT_SCLK, "ad4", NULL),
+	_OMAP2420_BALLENTRY(GPIO_119, "af6", NULL),
+	_OMAP2420_BALLENTRY(GPIO_120, "af4", NULL),
+	_OMAP2420_BALLENTRY(GPIO_121, "ae6", NULL),
+	_OMAP2420_BALLENTRY(GPIO_122, "w3", NULL),
+	_OMAP2420_BALLENTRY(GPIO_124, "y19", NULL),
+	_OMAP2420_BALLENTRY(GPIO_125, "ae24", NULL),
+	_OMAP2420_BALLENTRY(GPIO_36, "y18", NULL),
+	_OMAP2420_BALLENTRY(GPIO_6, "d6", NULL),
+	_OMAP2420_BALLENTRY(GPIO_62, "ad18", NULL),
+	_OMAP2420_BALLENTRY(GPMC_A1, "m8", NULL),
+	_OMAP2420_BALLENTRY(GPMC_A10, "d5", NULL),
+	_OMAP2420_BALLENTRY(GPMC_A2, "w9", NULL),
+	_OMAP2420_BALLENTRY(GPMC_A3, "af10", NULL),
+	_OMAP2420_BALLENTRY(GPMC_A4, "w8", NULL),
+	_OMAP2420_BALLENTRY(GPMC_A5, "ae16", NULL),
+	_OMAP2420_BALLENTRY(GPMC_A6, "af9", NULL),
+	_OMAP2420_BALLENTRY(GPMC_A7, "e4", NULL),
+	_OMAP2420_BALLENTRY(GPMC_A8, "j7", NULL),
+	_OMAP2420_BALLENTRY(GPMC_A9, "ae18", NULL),
+	_OMAP2420_BALLENTRY(GPMC_CLK, "p1", "l1"),
+	_OMAP2420_BALLENTRY(GPMC_D10, "t1", "n1"),
+	_OMAP2420_BALLENTRY(GPMC_D11, "u2", "p2"),
+	_OMAP2420_BALLENTRY(GPMC_D12, "u1", "p1"),
+	_OMAP2420_BALLENTRY(GPMC_D13, "p2", "m1"),
+	_OMAP2420_BALLENTRY(GPMC_D14, "h2", "j2"),
+	_OMAP2420_BALLENTRY(GPMC_D15, "h1", "k2"),
+	_OMAP2420_BALLENTRY(GPMC_D8, "v1", "r1"),
+	_OMAP2420_BALLENTRY(GPMC_D9, "y1", "t1"),
+	_OMAP2420_BALLENTRY(GPMC_NBE0, "af12", "aa10"),
+	_OMAP2420_BALLENTRY(GPMC_NBE1, "u3", NULL),
+	_OMAP2420_BALLENTRY(GPMC_NCS1, "af14", "w1"),
+	_OMAP2420_BALLENTRY(GPMC_NCS2, "g4", NULL),
+	_OMAP2420_BALLENTRY(GPMC_NCS3, "t8", NULL),
+	_OMAP2420_BALLENTRY(GPMC_NCS4, "h8", NULL),
+	_OMAP2420_BALLENTRY(GPMC_NCS5, "k3", NULL),
+	_OMAP2420_BALLENTRY(GPMC_NCS6, "m7", NULL),
+	_OMAP2420_BALLENTRY(GPMC_NCS7, "p3", NULL),
+	_OMAP2420_BALLENTRY(GPMC_NWP, "ae15", "y5"),
+	_OMAP2420_BALLENTRY(GPMC_WAIT1, "ae20", "y8"),
+	_OMAP2420_BALLENTRY(GPMC_WAIT2, "n2", NULL),
+	_OMAP2420_BALLENTRY(GPMC_WAIT3, "t4", NULL),
+	_OMAP2420_BALLENTRY(HDQ_SIO, "t23", NULL),
+	_OMAP2420_BALLENTRY(I2C2_SCL, "l2", NULL),
+	_OMAP2420_BALLENTRY(I2C2_SDA, "k19", NULL),
+	_OMAP2420_BALLENTRY(JTAG_EMU0, "n24", NULL),
+	_OMAP2420_BALLENTRY(JTAG_EMU1, "ac22", NULL),
+	_OMAP2420_BALLENTRY(MCBSP1_CLKR, "y24", NULL),
+	_OMAP2420_BALLENTRY(MCBSP1_CLKX, "t19", NULL),
+	_OMAP2420_BALLENTRY(MCBSP1_DR, "u23", NULL),
+	_OMAP2420_BALLENTRY(MCBSP1_DX, "r24", NULL),
+	_OMAP2420_BALLENTRY(MCBSP1_FSR, "r20", NULL),
+	_OMAP2420_BALLENTRY(MCBSP1_FSX, "r23", NULL),
+	_OMAP2420_BALLENTRY(MCBSP2_CLKX, "t24", NULL),
+	_OMAP2420_BALLENTRY(MCBSP2_DR, "p20", NULL),
+	_OMAP2420_BALLENTRY(MCBSP_CLKS, "p23", NULL),
+	_OMAP2420_BALLENTRY(MMC_CLKI, "c23", NULL),
+	_OMAP2420_BALLENTRY(MMC_CLKO, "h23", NULL),
+	_OMAP2420_BALLENTRY(MMC_CMD, "j23", NULL),
+	_OMAP2420_BALLENTRY(MMC_CMD_DIR, "j24", NULL),
+	_OMAP2420_BALLENTRY(MMC_DAT0, "h17", NULL),
+	_OMAP2420_BALLENTRY(MMC_DAT_DIR0, "f23", NULL),
+	_OMAP2420_BALLENTRY(MMC_DAT1, "g19", NULL),
+	_OMAP2420_BALLENTRY(MMC_DAT_DIR1, "d23", NULL),
+	_OMAP2420_BALLENTRY(MMC_DAT2, "h20", NULL),
+	_OMAP2420_BALLENTRY(MMC_DAT_DIR2, "g23", NULL),
+	_OMAP2420_BALLENTRY(MMC_DAT3, "d24", NULL),
+	_OMAP2420_BALLENTRY(MMC_DAT_DIR3, "e23", NULL),
+	_OMAP2420_BALLENTRY(SDRC_A12, "w26", "r21"),
+	_OMAP2420_BALLENTRY(SDRC_A13, "w25", "aa15"),
+	_OMAP2420_BALLENTRY(SDRC_A14, "aa26", "y12"),
+	_OMAP2420_BALLENTRY(SDRC_CKE1, "ae25", "y13"),
+	_OMAP2420_BALLENTRY(SDRC_NCS1, "y25", "t20"),
+	_OMAP2420_BALLENTRY(SPI1_CLK, "y23", NULL),
+	_OMAP2420_BALLENTRY(SPI1_NCS0, "w24", NULL),
+	_OMAP2420_BALLENTRY(SPI1_NCS1, "w23", NULL),
+	_OMAP2420_BALLENTRY(SPI1_NCS2, "v23", NULL),
+	_OMAP2420_BALLENTRY(SPI1_NCS3, "u20", NULL),
+	_OMAP2420_BALLENTRY(SPI1_SIMO, "h10", NULL),
+	_OMAP2420_BALLENTRY(SPI1_SOMI, "v19", NULL),
+	_OMAP2420_BALLENTRY(SPI2_CLK, "v24", NULL),
+	_OMAP2420_BALLENTRY(SPI2_NCS0, "aa24", NULL),
+	_OMAP2420_BALLENTRY(SPI2_SIMO, "u24", NULL),
+	_OMAP2420_BALLENTRY(SPI2_SOMI, "v25", NULL),
+	_OMAP2420_BALLENTRY(SSI1_DAT_RX, "w15", NULL),
+	_OMAP2420_BALLENTRY(SSI1_DAT_TX, "w13", NULL),
+	_OMAP2420_BALLENTRY(SSI1_FLAG_RX, "af11", NULL),
+	_OMAP2420_BALLENTRY(SSI1_FLAG_TX, "ac15", NULL),
+	_OMAP2420_BALLENTRY(SSI1_RDY_RX, "ac16", NULL),
+	_OMAP2420_BALLENTRY(SSI1_RDY_TX, "af15", NULL),
+	_OMAP2420_BALLENTRY(SSI1_WAKE, "ad15", NULL),
+	_OMAP2420_BALLENTRY(SYS_CLKOUT, "ae19", NULL),
+	_OMAP2420_BALLENTRY(SYS_CLKREQ, "ad20", NULL),
+	_OMAP2420_BALLENTRY(SYS_NIRQ, "y20", NULL),
+	_OMAP2420_BALLENTRY(UART1_CTS, "g20", NULL),
+	_OMAP2420_BALLENTRY(UART1_RTS, "k20", NULL),
+	_OMAP2420_BALLENTRY(UART1_RX, "t20", NULL),
+	_OMAP2420_BALLENTRY(UART1_TX, "h12", NULL),
+	_OMAP2420_BALLENTRY(UART2_CTS, "ac24", NULL),
+	_OMAP2420_BALLENTRY(UART2_RTS, "w20", NULL),
+	_OMAP2420_BALLENTRY(UART2_RX, "ad24", NULL),
+	_OMAP2420_BALLENTRY(UART2_TX, "ab24", NULL),
+	_OMAP2420_BALLENTRY(UART3_CTS_RCTX, "k24", NULL),
+	_OMAP2420_BALLENTRY(UART3_RTS_SD, "m20", NULL),
+	_OMAP2420_BALLENTRY(UART3_RX_IRRX, "h24", NULL),
+	_OMAP2420_BALLENTRY(UART3_TX_IRTX, "g24", NULL),
+	_OMAP2420_BALLENTRY(USB0_DAT, "j25", NULL),
+	_OMAP2420_BALLENTRY(USB0_PUEN, "l23", NULL),
+	_OMAP2420_BALLENTRY(USB0_RCV, "k23", NULL),
+	_OMAP2420_BALLENTRY(USB0_SE0, "l24", NULL),
+	_OMAP2420_BALLENTRY(USB0_TXEN, "m24", NULL),
+	_OMAP2420_BALLENTRY(USB0_VM, "n23", NULL),
+	_OMAP2420_BALLENTRY(USB0_VP, "m23", NULL),
+	_OMAP2420_BALLENTRY(VLYNQ_CLK, "w12", NULL),
+	_OMAP2420_BALLENTRY(VLYNQ_NLA, "ae10", NULL),
+	_OMAP2420_BALLENTRY(VLYNQ_RX0, "ad7", NULL),
+	_OMAP2420_BALLENTRY(VLYNQ_RX1, "w10", NULL),
+	_OMAP2420_BALLENTRY(VLYNQ_TX0, "y15", NULL),
+	_OMAP2420_BALLENTRY(VLYNQ_TX1, "w14", NULL),
+	{ .reg_offset = OMAP_MUX_TERMINATOR },
+};
+#else
+#define omap2420_pop_ball	 NULL
+#endif
+
+int __init omap2420_mux_init(struct omap_board_mux *board_subset, int flags)
+{
+	struct omap_ball *package_balls = NULL;
+
+	switch (flags & OMAP_PACKAGE_MASK) {
+	case OMAP_PACKAGE_ZAC:
+		package_balls = omap2420_pop_ball;
+		break;
+	case OMAP_PACKAGE_ZAF:
+		/* REVISIT: Please add data */
+	default:
+		pr_warning("mux: No ball data available for omap2420 package\n");
+	}
+
+	return omap_mux_init(OMAP2420_CONTROL_PADCONF_MUX_PBASE,
+			     OMAP2420_CONTROL_PADCONF_MUX_SIZE,
+				omap2420_muxmodes, NULL, board_subset,
+				package_balls);
+}
diff --git a/arch/arm/mach-omap2/mux2430.c b/arch/arm/mach-omap2/mux2430.c
new file mode 100644
index 0000000..132c08b
--- /dev/null
+++ b/arch/arm/mach-omap2/mux2430.c
@@ -0,0 +1,791 @@
+/*
+ * Copyright (C) 2010 Nokia
+ * Copyright (C) 2010 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+
+#include <plat/mux.h>
+
+#ifdef CONFIG_OMAP_MUX
+
+#define _OMAP2430_MUXENTRY(M0, g, m0, m1, m2, m3, m4, m5, m6, m7)		\
+{									\
+	.reg_offset	= (OMAP2430_CONTROL_PADCONF_##M0##_OFFSET),	\
+	.gpio		= (g),						\
+	.muxnames	= { m0, m1, m2, m3, m4, m5, m6, m7 },		\
+}
+
+#else
+
+#define _OMAP2430_MUXENTRY(M0, g, m0, m1, m2, m3, m4, m5, m6, m7)		\
+{									\
+	.reg_offset	= (OMAP2430_CONTROL_PADCONF_##M0##_OFFSET),	\
+	.gpio		= (g),						\
+}
+
+#endif
+
+#define _OMAP2430_BALLENTRY(M0, bb, bt)					\
+{									\
+	.reg_offset	= (OMAP2430_CONTROL_PADCONF_##M0##_OFFSET),	\
+	.balls		= { bb, bt },					\
+}
+
+/*
+ * Superset of all mux modes for omap2430
+ */
+static struct omap_mux __initdata omap2430_muxmodes[] = {
+	_OMAP2430_MUXENTRY(CAM_D0, 133,
+		"cam_d0", "hw_dbg0", "sti_dout", "gpio_133",
+		NULL, NULL, "etk_d2", "safe_mode"),
+	_OMAP2430_MUXENTRY(CAM_D10, 146,
+		"cam_d10", NULL, NULL, "gpio_146",
+		NULL, NULL, "etk_d12", "safe_mode"),
+	_OMAP2430_MUXENTRY(CAM_D11, 145,
+		"cam_d11", NULL, NULL, "gpio_145",
+		NULL, NULL, "etk_d13", "safe_mode"),
+	_OMAP2430_MUXENTRY(CAM_D1, 132,
+		"cam_d1", "hw_dbg1", "sti_din", "gpio_132",
+		NULL, NULL, "etk_d3", "safe_mode"),
+	_OMAP2430_MUXENTRY(CAM_D2, 129,
+		"cam_d2", "hw_dbg2", "mcbsp1_clkx", "gpio_129",
+		NULL, NULL, "etk_d4", "safe_mode"),
+	_OMAP2430_MUXENTRY(CAM_D3, 128,
+		"cam_d3", "hw_dbg3", "mcbsp1_dr", "gpio_128",
+		NULL, NULL, "etk_d5", "safe_mode"),
+	_OMAP2430_MUXENTRY(CAM_D4, 143,
+		"cam_d4", "hw_dbg4", "mcbsp1_fsr", "gpio_143",
+		NULL, NULL, "etk_d6", "safe_mode"),
+	_OMAP2430_MUXENTRY(CAM_D5, 112,
+		"cam_d5", "hw_dbg5", "mcbsp1_clkr", "gpio_112",
+		NULL, NULL, "etk_d7", "safe_mode"),
+	_OMAP2430_MUXENTRY(CAM_D6, 137,
+		"cam_d6", "hw_dbg6", NULL, "gpio_137",
+		NULL, NULL, "etk_d8", "safe_mode"),
+	_OMAP2430_MUXENTRY(CAM_D7, 136,
+		"cam_d7", "hw_dbg7", NULL, "gpio_136",
+		NULL, NULL, "etk_d9", "safe_mode"),
+	_OMAP2430_MUXENTRY(CAM_D8, 135,
+		"cam_d8", "hw_dbg8", NULL, "gpio_135",
+		NULL, NULL, "etk_d10", "safe_mode"),
+	_OMAP2430_MUXENTRY(CAM_D9, 134,
+		"cam_d9", "hw_dbg9", NULL, "gpio_134",
+		NULL, NULL, "etk_d11", "safe_mode"),
+	_OMAP2430_MUXENTRY(CAM_HS, 11,
+		"cam_hs", "hw_dbg10", "mcbsp1_dx", "gpio_11",
+		NULL, NULL, "etk_d1", "safe_mode"),
+	_OMAP2430_MUXENTRY(CAM_LCLK, 0,
+		"cam_lclk", NULL, "mcbsp_clks", NULL,
+		NULL, NULL, "etk_c1", "safe_mode"),
+	_OMAP2430_MUXENTRY(CAM_VS, 12,
+		"cam_vs", "hw_dbg11", "mcbsp1_fsx", "gpio_12",
+		NULL, NULL, "etk_d0", "safe_mode"),
+	_OMAP2430_MUXENTRY(CAM_XCLK, 0,
+		"cam_xclk", NULL, "sti_clk", NULL,
+		NULL, NULL, "etk_c2", NULL),
+	_OMAP2430_MUXENTRY(DSS_ACBIAS, 48,
+		"dss_acbias", NULL, "mcbsp2_fsx", "gpio_48",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(DSS_DATA0, 40,
+		"dss_data0", "uart1_cts", NULL, "gpio_40",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(DSS_DATA10, 128,
+		"dss_data10", "sdi_data1n", NULL, "gpio_128",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(DSS_DATA11, 129,
+		"dss_data11", "sdi_data1p", NULL, "gpio_129",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(DSS_DATA12, 130,
+		"dss_data12", "sdi_data2n", NULL, "gpio_130",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(DSS_DATA13, 131,
+		"dss_data13", "sdi_data2p", NULL, "gpio_131",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(DSS_DATA14, 132,
+		"dss_data14", "sdi_data3n", NULL, "gpio_132",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(DSS_DATA15, 133,
+		"dss_data15", "sdi_data3p", NULL, "gpio_133",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(DSS_DATA16, 46,
+		"dss_data16", NULL, NULL, "gpio_46",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(DSS_DATA17, 47,
+		"dss_data17", NULL, NULL, "gpio_47",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(DSS_DATA1, 41,
+		"dss_data1", "uart1_rts", NULL, "gpio_41",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(DSS_DATA2, 42,
+		"dss_data2", "uart1_tx", NULL, "gpio_42",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(DSS_DATA3, 43,
+		"dss_data3", "uart1_rx", NULL, "gpio_43",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(DSS_DATA4, 44,
+		"dss_data4", "uart3_rx_irrx", NULL, "gpio_44",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(DSS_DATA5, 45,
+		"dss_data5", "uart3_tx_irtx", NULL, "gpio_45",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(DSS_DATA6, 144,
+		"dss_data6", NULL, NULL, "gpio_144",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(DSS_DATA7, 147,
+		"dss_data7", NULL, NULL, "gpio_147",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(DSS_DATA8, 38,
+		"dss_data8", NULL, NULL, "gpio_38",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(DSS_DATA9, 39,
+		"dss_data9", NULL, NULL, "gpio_39",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(DSS_HSYNC, 110,
+		"dss_hsync", NULL, NULL, "gpio_110",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_113, 113,
+		"gpio_113", "mcbsp2_clkx", NULL, "gpio_113",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_114, 114,
+		"gpio_114", "mcbsp2_fsx", NULL, "gpio_114",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_115, 115,
+		"gpio_115", "mcbsp2_dr", NULL, "gpio_115",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_116, 116,
+		"gpio_116", "mcbsp2_dx", NULL, "gpio_116",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_128, 128,
+		"gpio_128", NULL, "sti_din", "gpio_128",
+		NULL, "sys_boot0", NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_129, 129,
+		"gpio_129", NULL, "sti_dout", "gpio_129",
+		NULL, "sys_boot1", NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_130, 130,
+		"gpio_130", NULL, NULL, "gpio_130",
+		"jtag_emu2", "sys_boot2", NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_131, 131,
+		"gpio_131", NULL, NULL, "gpio_131",
+		"jtag_emu3", "sys_boot3", NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_132, 132,
+		"gpio_132", NULL, NULL, "gpio_132",
+		NULL, "sys_boot4", NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_133, 133,
+		"gpio_133", NULL, NULL, "gpio_133",
+		NULL, "sys_boot5", NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_134, 134,
+		"gpio_134", "ccp_datn", NULL, "gpio_134",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_135, 135,
+		"gpio_135", "ccp_datp", NULL, "gpio_135",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_136, 136,
+		"gpio_136", "ccp_clkn", NULL, "gpio_136",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_137, 137,
+		"gpio_137", "ccp_clkp", NULL, "gpio_137",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_138, 138,
+		"gpio_138", "spi3_clk", NULL, "gpio_138",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_139, 139,
+		"gpio_139", "spi3_cs0", "sys_ndmareq3", "gpio_139",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_140, 140,
+		"gpio_140", "spi3_simo", "sys_ndmareq4", "gpio_140",
+		NULL, NULL, "etk_d14", "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_141, 141,
+		"gpio_141", "spi3_somi", NULL, "gpio_141",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_142, 142,
+		"gpio_142", "spi3_cs1", "sys_ndmareq2", "gpio_142",
+		NULL, NULL, "etk_d15", "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_148, 148,
+		"gpio_148", "mcbsp5_fsx", NULL, "gpio_148",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_149, 149,
+		"gpio_149", "mcbsp5_dx", NULL, "gpio_149",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_150, 150,
+		"gpio_150", "mcbsp5_dr", NULL, "gpio_150",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_151, 151,
+		"gpio_151", "sys_pwrok", NULL, "gpio_151",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_152, 152,
+		"gpio_152", "uart1_cts", "sys_ndmareq1", "gpio_152",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_153, 153,
+		"gpio_153", "uart1_rx", "sys_ndmareq0", "gpio_153",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_154, 154,
+		"gpio_154", "mcbsp5_clkx", NULL, "gpio_154",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_63, 63,
+		"gpio_63", "mcbsp4_clkx", NULL, "gpio_63",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_78, 78,
+		"gpio_78", NULL, "uart2_rts", "gpio_78",
+		"uart3_rts_sd", NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_79, 79,
+		"gpio_79", "secure_indicator", "uart2_tx", "gpio_79",
+		"uart3_tx_irtx", NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_7, 7,
+		"gpio_7", NULL, "uart2_cts", "gpio_7",
+		"uart3_cts_rctx", NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPIO_80, 80,
+		"gpio_80", NULL, "uart2_rx", "gpio_80",
+		"uart3_rx_irrx", NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_A10, 3,
+		"gpmc_a10", NULL, "sys_ndmareq0", "gpio_3",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_A1, 31,
+		"gpmc_a1", NULL, NULL, "gpio_31",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_A2, 30,
+		"gpmc_a2", NULL, NULL, "gpio_30",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_A3, 29,
+		"gpmc_a3", NULL, NULL, "gpio_29",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_A4, 49,
+		"gpmc_a4", NULL, NULL, "gpio_49",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_A5, 53,
+		"gpmc_a5", NULL, NULL, "gpio_53",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_A6, 52,
+		"gpmc_a6", NULL, NULL, "gpio_52",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_A7, 6,
+		"gpmc_a7", NULL, NULL, "gpio_6",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_A8, 5,
+		"gpmc_a8", NULL, NULL, "gpio_5",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_A9, 4,
+		"gpmc_a9", NULL, "sys_ndmareq1", "gpio_4",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_CLK, 21,
+		"gpmc_clk", NULL, NULL, "gpio_21",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_D10, 18,
+		"gpmc_d10", NULL, NULL, "gpio_18",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_D11, 57,
+		"gpmc_d11", NULL, NULL, "gpio_57",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_D12, 77,
+		"gpmc_d12", NULL, NULL, "gpio_77",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_D13, 76,
+		"gpmc_d13", NULL, NULL, "gpio_76",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_D14, 55,
+		"gpmc_d14", NULL, NULL, "gpio_55",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_D15, 54,
+		"gpmc_d15", NULL, NULL, "gpio_54",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_D8, 20,
+		"gpmc_d8", NULL, NULL, "gpio_20",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_D9, 19,
+		"gpmc_d9", NULL, NULL, "gpio_19",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_NCS1, 22,
+		"gpmc_ncs1", NULL, NULL, "gpio_22",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_NCS2, 23,
+		"gpmc_ncs2", NULL, NULL, "gpio_23",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_NCS3, 24,
+		"gpmc_ncs3", "gpmc_io_dir", NULL, "gpio_24",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_NCS4, 25,
+		"gpmc_ncs4", NULL, NULL, "gpio_25",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_NCS5, 26,
+		"gpmc_ncs5", NULL, NULL, "gpio_26",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_NCS6, 27,
+		"gpmc_ncs6", NULL, NULL, "gpio_27",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_NCS7, 28,
+		"gpmc_ncs7", "gpmc_io_dir", NULL, "gpio_28",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_WAIT1, 33,
+		"gpmc_wait1", NULL, NULL, "gpio_33",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_WAIT2, 34,
+		"gpmc_wait2", NULL, NULL, "gpio_34",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(GPMC_WAIT3, 35,
+		"gpmc_wait3", NULL, NULL, "gpio_35",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(HDQ_SIO, 101,
+		"hdq_sio", "usb2_tllse0", "sys_altclk", "gpio_101",
+		"uart3_rx_irrx", NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(I2C1_SCL, 50,
+		"i2c1_scl", NULL, NULL, "gpio_50",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(I2C1_SDA, 51,
+		"i2c1_sda", NULL, NULL, "gpio_51",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(I2C2_SCL, 99,
+		"i2c2_scl", NULL, NULL, "gpio_99",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(I2C2_SDA, 100,
+		"i2c2_sda", NULL, NULL, "gpio_100",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(JTAG_EMU0, 127,
+		"jtag_emu0", "secure_indicator", NULL, "gpio_127",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(JTAG_EMU1, 126,
+		"jtag_emu1", NULL, NULL, "gpio_126",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(MCBSP1_CLKR, 92,
+		"mcbsp1_clkr", "ssi2_dat_tx", NULL, "gpio_92",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(MCBSP1_CLKX, 98,
+		"mcbsp1_clkx", "ssi2_wake", NULL, "gpio_98",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(MCBSP1_DR, 95,
+		"mcbsp1_dr", "ssi2_dat_rx", NULL, "gpio_95",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(MCBSP1_DX, 94,
+		"mcbsp1_dx", "ssi2_rdy_tx", NULL, "gpio_94",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(MCBSP1_FSR, 93,
+		"mcbsp1_fsr", "ssi2_flag_tx", NULL, "gpio_93",
+		"spi2_cs1", NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(MCBSP1_FSX, 97,
+		"mcbsp1_fsx", "ssi2_rdy_rx", NULL, "gpio_97",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(MCBSP2_CLKX, 147,
+		"mcbsp2_clkx", "sdi_clkp", "dss_data23", "gpio_147",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(MCBSP2_DR, 144,
+		"mcbsp2_dr", "sdi_clkn", "dss_data22", "gpio_144",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(MCBSP3_CLKX, 71,
+		"mcbsp3_clkx", NULL, NULL, "gpio_71",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(MCBSP3_DR, 73,
+		"mcbsp3_dr", NULL, NULL, "gpio_73",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(MCBSP3_DX, 74,
+		"mcbsp3_dx", NULL, "sti_clk", "gpio_74",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(MCBSP3_FSX, 72,
+		"mcbsp3_fsx", NULL, NULL, "gpio_72",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(MCBSP_CLKS, 96,
+		"mcbsp_clks", "ssi2_flag_rx", NULL, "gpio_96",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SDMMC1_CLKO, 0,
+		"sdmmc1_clko", "ms_clko", NULL, NULL,
+		NULL, "hw_dbg9", "hw_dbg3", "safe_mode"),
+	_OMAP2430_MUXENTRY(SDMMC1_CMD, 0,
+		"sdmmc1_cmd", "ms_bs", NULL, NULL,
+		NULL, "hw_dbg8", "hw_dbg2", "safe_mode"),
+	_OMAP2430_MUXENTRY(SDMMC1_DAT0, 0,
+		"sdmmc1_dat0", "ms_dat0", NULL, NULL,
+		NULL, "hw_dbg7", "hw_dbg1", "safe_mode"),
+	_OMAP2430_MUXENTRY(SDMMC1_DAT1, 75,
+		"sdmmc1_dat1", "ms_dat1", NULL, "gpio_75",
+		NULL, "hw_dbg6", "hw_dbg0", "safe_mode"),
+	_OMAP2430_MUXENTRY(SDMMC1_DAT2, 0,
+		"sdmmc1_dat2", "ms_dat2", NULL, NULL,
+		NULL, "hw_dbg5", "hw_dbg10", "safe_mode"),
+	_OMAP2430_MUXENTRY(SDMMC1_DAT3, 0,
+		"sdmmc1_dat3", "ms_dat3", NULL, NULL,
+		NULL, "hw_dbg4", "hw_dbg11", "safe_mode"),
+	_OMAP2430_MUXENTRY(SDMMC2_CLKO, 13,
+		"sdmmc2_clko", NULL, NULL, "gpio_13",
+		NULL, "spi3_clk", NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SDMMC2_CMD, 15,
+		"sdmmc2_cmd", "usb2_rcv", NULL, "gpio_15",
+		NULL, "spi3_simo", NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SDMMC2_DAT0, 16,
+		"sdmmc2_dat0", "usb2_tllse0", NULL, "gpio_16",
+		NULL, "spi3_somi", NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SDMMC2_DAT1, 58,
+		"sdmmc2_dat1", "usb2_txen", NULL, "gpio_58",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SDMMC2_DAT2, 17,
+		"sdmmc2_dat2", "usb2_dat", NULL, "gpio_17",
+		NULL, "spi3_cs1", NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SDMMC2_DAT3, 14,
+		"sdmmc2_dat3", "usb2_se0", NULL, "gpio_14",
+		NULL, "spi3_cs0", NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SDRC_A12, 2,
+		"sdrc_a12", NULL, NULL, "gpio_2",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SDRC_A13, 1,
+		"sdrc_a13", NULL, NULL, "gpio_1",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SDRC_A14, 0,
+		"sdrc_a14", NULL, NULL, "gpio_0",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SDRC_CKE1, 36,
+		"sdrc_cke1", NULL, NULL, "gpio_36",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SDRC_NCS1, 37,
+		"sdrc_ncs1", NULL, NULL, "gpio_37",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SPI1_CLK, 81,
+		"spi1_clk", NULL, NULL, "gpio_81",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SPI1_CS0, 84,
+		"spi1_cs0", NULL, NULL, "gpio_84",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SPI1_CS1, 85,
+		"spi1_cs1", NULL, NULL, "gpio_85",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SPI1_CS2, 86,
+		"spi1_cs2", NULL, NULL, "gpio_86",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SPI1_CS3, 87,
+		"spi1_cs3", "spi2_cs1", NULL, "gpio_87",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SPI1_SIMO, 82,
+		"spi1_simo", NULL, NULL, "gpio_82",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SPI1_SOMI, 83,
+		"spi1_somi", NULL, NULL, "gpio_83",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SPI2_CLK, 88,
+		"spi2_clk", "gpt9_pwm_evt", NULL, "gpio_88",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SPI2_CS0, 91,
+		"spi2_cs0", "gpt12_pwm_evt", NULL, "gpio_91",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SPI2_SIMO, 89,
+		"spi2_simo", "gpt10_pwm_evt", NULL, "gpio_89",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SPI2_SOMI, 90,
+		"spi2_somi", "gpt11_pwm_evt", NULL, "gpio_90",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SSI1_DAT_RX, 62,
+		"ssi1_dat_rx", "uart1_rx", "usb1_dat", "gpio_62",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SSI1_DAT_TX, 59,
+		"ssi1_dat_tx", "uart1_tx", "usb1_se0", "gpio_59",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SSI1_FLAG_RX, 64,
+		"ssi1_flag_rx", "mcbsp4_dr", NULL, "gpio_64",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SSI1_FLAG_TX, 60,
+		"ssi1_flag_tx", "uart1_rts", "usb1_rcv", "gpio_60",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SSI1_RDY_RX, 65,
+		"ssi1_rdy_rx", "mcbsp4_dx", NULL, "gpio_65",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SSI1_RDY_TX, 61,
+		"ssi1_rdy_tx", "uart1_cts", "usb1_txen", "gpio_61",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SSI1_WAKE, 66,
+		"ssi1_wake", "mcbsp4_fsx", NULL, "gpio_66",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SYS_CLKOUT, 111,
+		"sys_clkout", NULL, NULL, "gpio_111",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SYS_DRM_MSECURE, 118,
+		"sys_drm_msecure", NULL, "sys_ndmareq6", "gpio_118",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SYS_NIRQ0, 56,
+		"sys_nirq0", NULL, NULL, "gpio_56",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(SYS_NIRQ1, 125,
+		"sys_nirq1", NULL, "sys_ndmareq5", "gpio_125",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(UART1_CTS, 32,
+		"uart1_cts", "sdi_vsync", "dss_data18", "gpio_32",
+		"mcbsp5_clkx", NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(UART1_RTS, 8,
+		"uart1_rts", "sdi_hsync", "dss_data19", "gpio_8",
+		"mcbsp5_fsx", NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(UART1_RX, 10,
+		"uart1_rx", "sdi_stp", "dss_data21", "gpio_10",
+		"mcbsp5_dr", NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(UART1_TX, 9,
+		"uart1_tx", "sdi_den", "dss_data20", "gpio_9",
+		"mcbsp5_dx", NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(UART2_CTS, 67,
+		"uart2_cts", "usb1_rcv", "gpt9_pwm_evt", "gpio_67",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(UART2_RTS, 68,
+		"uart2_rts", "usb1_txen", "gpt10_pwm_evt", "gpio_68",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(UART2_RX, 70,
+		"uart2_rx", "usb1_dat", "gpt12_pwm_evt", "gpio_70",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(UART2_TX, 69,
+		"uart2_tx", "usb1_se0", "gpt11_pwm_evt", "gpio_69",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(UART3_CTS_RCTX, 102,
+		"uart3_cts_rctx", "uart3_rx_irrx", NULL, "gpio_102",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(UART3_RTS_SD, 103,
+		"uart3_rts_sd", "uart3_tx_irtx", NULL, "gpio_103",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(UART3_RX_IRRX, 105,
+		"uart3_rx_irrx", NULL, NULL, "gpio_105",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(UART3_TX_IRTX, 104,
+		"uart3_tx_irtx", "uart3_cts_rctx", NULL, "gpio_104",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(USB0HS_CLK, 120,
+		"usb0hs_clk", NULL, NULL, "gpio_120",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(USB0HS_DATA0, 0,
+		"usb0hs_data0", "uart3_tx_irtx", NULL, NULL,
+		"usb0_txen", NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(USB0HS_DATA1, 0,
+		"usb0hs_data1", "uart3_rx_irrx", NULL, NULL,
+		"usb0_dat", NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(USB0HS_DATA2, 0,
+		"usb0hs_data2", "uart3_rts_sd", NULL, NULL,
+		"usb0_se0", NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(USB0HS_DATA3, 106,
+		"usb0hs_data3", NULL, "uart3_cts_rctx", "gpio_106",
+		"usb0_puen", NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(USB0HS_DATA4, 107,
+		"usb0hs_data4", "mcbsp2_dr", NULL, "gpio_107",
+		"usb0_vp", NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(USB0HS_DATA5, 108,
+		"usb0hs_data5", "mcbsp2_dx", NULL, "gpio_108",
+		"usb0_vm", NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(USB0HS_DATA6, 109,
+		"usb0hs_data6", "mcbsp2_fsx", NULL, "gpio_109",
+		"usb0_rcv", NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(USB0HS_DATA7, 124,
+		"usb0hs_data7", "mcbsp2_clkx", NULL, "gpio_124",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(USB0HS_DIR, 121,
+		"usb0hs_dir", NULL, NULL, "gpio_121",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(USB0HS_NXT, 123,
+		"usb0hs_nxt", NULL, NULL, "gpio_123",
+		NULL, NULL, NULL, "safe_mode"),
+	_OMAP2430_MUXENTRY(USB0HS_STP, 122,
+		"usb0hs_stp", NULL, NULL, "gpio_122",
+		NULL, NULL, NULL, "safe_mode"),
+	{ .reg_offset = OMAP_MUX_TERMINATOR },
+};
+
+/*
+ * Balls for POP package
+ * 447-pin s-PBGA Package, 0.00mm Ball Pitch (Bottom)
+ */
+#ifdef CONFIG_DEBUG_FS
+static struct omap_ball __initdata omap2430_pop_ball[] = {
+	_OMAP2430_BALLENTRY(CAM_D0, "t8", NULL),
+	_OMAP2430_BALLENTRY(CAM_D1, "t4", NULL),
+	_OMAP2430_BALLENTRY(CAM_D10, "r4", NULL),
+	_OMAP2430_BALLENTRY(CAM_D11, "w3", NULL),
+	_OMAP2430_BALLENTRY(CAM_D2, "r2", NULL),
+	_OMAP2430_BALLENTRY(CAM_D3, "u3", NULL),
+	_OMAP2430_BALLENTRY(CAM_D4, "u2", NULL),
+	_OMAP2430_BALLENTRY(CAM_D5, "v1", NULL),
+	_OMAP2430_BALLENTRY(CAM_D6, "t3", NULL),
+	_OMAP2430_BALLENTRY(CAM_D7, "r3", NULL),
+	_OMAP2430_BALLENTRY(CAM_D8, "u7", NULL),
+	_OMAP2430_BALLENTRY(CAM_D9, "t7", NULL),
+	_OMAP2430_BALLENTRY(CAM_HS, "p2", NULL),
+	_OMAP2430_BALLENTRY(CAM_LCLK, "r7", NULL),
+	_OMAP2430_BALLENTRY(CAM_VS, "n2", NULL),
+	_OMAP2430_BALLENTRY(CAM_XCLK, "p3", NULL),
+	_OMAP2430_BALLENTRY(DSS_ACBIAS, "y3", NULL),
+	_OMAP2430_BALLENTRY(DSS_DATA0, "v8", NULL),
+	_OMAP2430_BALLENTRY(DSS_DATA1, "w1", NULL),
+	_OMAP2430_BALLENTRY(DSS_DATA10, "k25", NULL),
+	_OMAP2430_BALLENTRY(DSS_DATA11, "j25", NULL),
+	_OMAP2430_BALLENTRY(DSS_DATA12, "k24", NULL),
+	_OMAP2430_BALLENTRY(DSS_DATA13, "j24", NULL),
+	_OMAP2430_BALLENTRY(DSS_DATA14, "h25", NULL),
+	_OMAP2430_BALLENTRY(DSS_DATA15, "g25", NULL),
+	_OMAP2430_BALLENTRY(DSS_DATA16, "ac3", NULL),
+	_OMAP2430_BALLENTRY(DSS_DATA17, "y7", NULL),
+	_OMAP2430_BALLENTRY(DSS_DATA2, "u8", NULL),
+	_OMAP2430_BALLENTRY(DSS_DATA3, "u4", NULL),
+	_OMAP2430_BALLENTRY(DSS_DATA4, "v3", NULL),
+	_OMAP2430_BALLENTRY(DSS_DATA5, "aa4", NULL),
+	_OMAP2430_BALLENTRY(DSS_DATA6, "w8", NULL),
+	_OMAP2430_BALLENTRY(DSS_DATA7, "y1", NULL),
+	_OMAP2430_BALLENTRY(DSS_DATA8, "aa2", NULL),
+	_OMAP2430_BALLENTRY(DSS_DATA9, "ab4", NULL),
+	_OMAP2430_BALLENTRY(DSS_HSYNC, "v2", NULL),
+	_OMAP2430_BALLENTRY(GPIO_113, "ad16", NULL),
+	_OMAP2430_BALLENTRY(GPIO_114, "ac10", NULL),
+	_OMAP2430_BALLENTRY(GPIO_115, "ad13", NULL),
+	_OMAP2430_BALLENTRY(GPIO_116, "ae15", NULL),
+	_OMAP2430_BALLENTRY(GPIO_128, "p1", NULL),
+	_OMAP2430_BALLENTRY(GPIO_129, "r1", NULL),
+	_OMAP2430_BALLENTRY(GPIO_130, "p7", NULL),
+	_OMAP2430_BALLENTRY(GPIO_131, "l8", NULL),
+	_OMAP2430_BALLENTRY(GPIO_132, "w24", NULL),
+	_OMAP2430_BALLENTRY(GPIO_133, "aa24", NULL),
+	_OMAP2430_BALLENTRY(GPIO_134, "ae12", NULL),
+	_OMAP2430_BALLENTRY(GPIO_135, "ae11", NULL),
+	_OMAP2430_BALLENTRY(GPIO_136, "ad12", NULL),
+	_OMAP2430_BALLENTRY(GPIO_137, "ad11", NULL),
+	_OMAP2430_BALLENTRY(GPIO_138, "y12", NULL),
+	_OMAP2430_BALLENTRY(GPIO_139, "ad17", NULL),
+	_OMAP2430_BALLENTRY(GPIO_140, "l7", NULL),
+	_OMAP2430_BALLENTRY(GPIO_141, "ac24", NULL),
+	_OMAP2430_BALLENTRY(GPIO_142, "m3", NULL),
+	_OMAP2430_BALLENTRY(GPIO_148, "af12", NULL),
+	_OMAP2430_BALLENTRY(GPIO_149, "k7", NULL),
+	_OMAP2430_BALLENTRY(GPIO_150, "m1", NULL),
+	_OMAP2430_BALLENTRY(GPIO_151, "ad14", NULL),
+	_OMAP2430_BALLENTRY(GPIO_152, "ad18", NULL),
+	_OMAP2430_BALLENTRY(GPIO_153, "u24", NULL),
+	_OMAP2430_BALLENTRY(GPIO_154, "ae16", NULL),
+	_OMAP2430_BALLENTRY(GPIO_63, "n3", NULL),
+	_OMAP2430_BALLENTRY(GPIO_7, "ac23", NULL),
+	_OMAP2430_BALLENTRY(GPIO_78, "ad10", NULL),
+	_OMAP2430_BALLENTRY(GPIO_79, "ae10", NULL),
+	_OMAP2430_BALLENTRY(GPIO_80, "ae13", NULL),
+	_OMAP2430_BALLENTRY(GPMC_A1, "a9", NULL),
+	_OMAP2430_BALLENTRY(GPMC_A10, "g12", NULL),
+	_OMAP2430_BALLENTRY(GPMC_A2, "b8", NULL),
+	_OMAP2430_BALLENTRY(GPMC_A3, "g10", NULL),
+	_OMAP2430_BALLENTRY(GPMC_A4, "g11", NULL),
+	_OMAP2430_BALLENTRY(GPMC_A5, "a10", NULL),
+	_OMAP2430_BALLENTRY(GPMC_A6, "g13", NULL),
+	_OMAP2430_BALLENTRY(GPMC_A7, "a6", NULL),
+	_OMAP2430_BALLENTRY(GPMC_A8, "h1", NULL),
+	_OMAP2430_BALLENTRY(GPMC_A9, "c8", NULL),
+	_OMAP2430_BALLENTRY(GPMC_CLK, "n1", "l1"),
+	_OMAP2430_BALLENTRY(GPMC_D10, "d1", "n1"),
+	_OMAP2430_BALLENTRY(GPMC_D11, "d2", "p2"),
+	_OMAP2430_BALLENTRY(GPMC_D12, "e1", "p1"),
+	_OMAP2430_BALLENTRY(GPMC_D13, "e3", "m1"),
+	_OMAP2430_BALLENTRY(GPMC_D14, "c7", "j2"),
+	_OMAP2430_BALLENTRY(GPMC_D15, "f3", "k2"),
+	_OMAP2430_BALLENTRY(GPMC_D8, "e2", "r1"),
+	_OMAP2430_BALLENTRY(GPMC_D9, "ab1", "t1"),
+	_OMAP2430_BALLENTRY(GPMC_NCS1, "ac1", "w1"),
+	_OMAP2430_BALLENTRY(GPMC_NCS2, "c6", NULL),
+	_OMAP2430_BALLENTRY(GPMC_NCS3, "b9", NULL),
+	_OMAP2430_BALLENTRY(GPMC_NCS4, "b4", NULL),
+	_OMAP2430_BALLENTRY(GPMC_NCS5, "a4", NULL),
+	_OMAP2430_BALLENTRY(GPMC_NCS6, "f1", NULL),
+	_OMAP2430_BALLENTRY(GPMC_NCS7, "a7", NULL),
+	_OMAP2430_BALLENTRY(GPMC_WAIT1, "j1", "y8"),
+	_OMAP2430_BALLENTRY(GPMC_WAIT2, "b7", NULL),
+	_OMAP2430_BALLENTRY(GPMC_WAIT3, "g14", NULL),
+	_OMAP2430_BALLENTRY(HDQ_SIO, "h20", NULL),
+	_OMAP2430_BALLENTRY(I2C1_SCL, "y17", NULL),
+	_OMAP2430_BALLENTRY(I2C1_SDA, "ac19", NULL),
+	_OMAP2430_BALLENTRY(I2C2_SCL, "n7", NULL),
+	_OMAP2430_BALLENTRY(I2C2_SDA, "m4", NULL),
+	_OMAP2430_BALLENTRY(JTAG_EMU0, "e25", NULL),
+	_OMAP2430_BALLENTRY(JTAG_EMU1, "e24", NULL),
+	_OMAP2430_BALLENTRY(MCBSP1_CLKR, "ab2", NULL),
+	_OMAP2430_BALLENTRY(MCBSP1_CLKX, "y9", NULL),
+	_OMAP2430_BALLENTRY(MCBSP1_DR, "af3", NULL),
+	_OMAP2430_BALLENTRY(MCBSP1_DX, "aa1", NULL),
+	_OMAP2430_BALLENTRY(MCBSP1_FSR, "ad5", NULL),
+	_OMAP2430_BALLENTRY(MCBSP1_FSX, "ab3", NULL),
+	_OMAP2430_BALLENTRY(MCBSP2_CLKX, "j26", NULL),
+	_OMAP2430_BALLENTRY(MCBSP2_DR, "k26", NULL),
+	_OMAP2430_BALLENTRY(MCBSP3_CLKX, "ac9", NULL),
+	_OMAP2430_BALLENTRY(MCBSP3_DR, "ae2", NULL),
+	_OMAP2430_BALLENTRY(MCBSP3_DX, "af4", NULL),
+	_OMAP2430_BALLENTRY(MCBSP3_FSX, "ae4", NULL),
+	_OMAP2430_BALLENTRY(MCBSP_CLKS, "ad6", NULL),
+	_OMAP2430_BALLENTRY(SDMMC1_CLKO, "n23", NULL),
+	_OMAP2430_BALLENTRY(SDMMC1_CMD, "l23", NULL),
+	_OMAP2430_BALLENTRY(SDMMC1_DAT0, "m24", NULL),
+	_OMAP2430_BALLENTRY(SDMMC1_DAT1, "p23", NULL),
+	_OMAP2430_BALLENTRY(SDMMC1_DAT2, "t20", NULL),
+	_OMAP2430_BALLENTRY(SDMMC1_DAT3, "r20", NULL),
+	_OMAP2430_BALLENTRY(SDMMC2_CLKO, "v26", NULL),
+	_OMAP2430_BALLENTRY(SDMMC2_CMD, "w20", NULL),
+	_OMAP2430_BALLENTRY(SDMMC2_DAT0, "v23", NULL),
+	_OMAP2430_BALLENTRY(SDMMC2_DAT1, "y24", NULL),
+	_OMAP2430_BALLENTRY(SDMMC2_DAT2, "v25", NULL),
+	_OMAP2430_BALLENTRY(SDMMC2_DAT3, "v24", NULL),
+	_OMAP2430_BALLENTRY(SDRC_A12, "w26", "r21"),
+	_OMAP2430_BALLENTRY(SDRC_A13, "af20", "aa15"),
+	_OMAP2430_BALLENTRY(SDRC_A14, "af16", "y12"),
+	_OMAP2430_BALLENTRY(SDRC_CKE1, "af15", "y13"),
+	_OMAP2430_BALLENTRY(SDRC_NCS1, "aa25", "t20"),
+	_OMAP2430_BALLENTRY(SPI1_CLK, "y18", NULL),
+	_OMAP2430_BALLENTRY(SPI1_CS0, "u1", NULL),
+	_OMAP2430_BALLENTRY(SPI1_CS1, "af19", NULL),
+	_OMAP2430_BALLENTRY(SPI1_CS2, "ae19", NULL),
+	_OMAP2430_BALLENTRY(SPI1_CS3, "h24", NULL),
+	_OMAP2430_BALLENTRY(SPI1_SIMO, "ad15", NULL),
+	_OMAP2430_BALLENTRY(SPI1_SOMI, "ae17", NULL),
+	_OMAP2430_BALLENTRY(SPI2_CLK, "y20", NULL),
+	_OMAP2430_BALLENTRY(SPI2_CS0, "y19", NULL),
+	_OMAP2430_BALLENTRY(SPI2_SIMO, "ac20", NULL),
+	_OMAP2430_BALLENTRY(SPI2_SOMI, "ad19", NULL),
+	_OMAP2430_BALLENTRY(SSI1_DAT_RX, "aa26", NULL),
+	_OMAP2430_BALLENTRY(SSI1_DAT_TX, "ad24", NULL),
+	_OMAP2430_BALLENTRY(SSI1_FLAG_RX, "ad23", NULL),
+	_OMAP2430_BALLENTRY(SSI1_FLAG_TX, "ab24", NULL),
+	_OMAP2430_BALLENTRY(SSI1_RDY_RX, "ab25", NULL),
+	_OMAP2430_BALLENTRY(SSI1_RDY_TX, "y25", NULL),
+	_OMAP2430_BALLENTRY(SSI1_WAKE, "ac25", NULL),
+	_OMAP2430_BALLENTRY(SYS_CLKOUT, "r25", NULL),
+	_OMAP2430_BALLENTRY(SYS_DRM_MSECURE, "ae3", NULL),
+	_OMAP2430_BALLENTRY(SYS_NIRQ0, "w25", NULL),
+	_OMAP2430_BALLENTRY(SYS_NIRQ1, "ad21", NULL),
+	_OMAP2430_BALLENTRY(UART1_CTS, "p24", NULL),
+	_OMAP2430_BALLENTRY(UART1_RTS, "p25", NULL),
+	_OMAP2430_BALLENTRY(UART1_RX, "n24", NULL),
+	_OMAP2430_BALLENTRY(UART1_TX, "r24", NULL),
+	_OMAP2430_BALLENTRY(UART2_CTS, "u25", NULL),
+	_OMAP2430_BALLENTRY(UART2_RTS, "t23", NULL),
+	_OMAP2430_BALLENTRY(UART2_RX, "t24", NULL),
+	_OMAP2430_BALLENTRY(UART2_TX, "u20", NULL),
+	_OMAP2430_BALLENTRY(UART3_CTS_RCTX, "m2", NULL),
+	_OMAP2430_BALLENTRY(UART3_RTS_SD, "k2", NULL),
+	_OMAP2430_BALLENTRY(UART3_RX_IRRX, "l3", NULL),
+	_OMAP2430_BALLENTRY(UART3_TX_IRTX, "l2", NULL),
+	_OMAP2430_BALLENTRY(USB0HS_CLK, "ae8", NULL),
+	_OMAP2430_BALLENTRY(USB0HS_DATA0, "ad4", NULL),
+	_OMAP2430_BALLENTRY(USB0HS_DATA1, "ae6", NULL),
+	_OMAP2430_BALLENTRY(USB0HS_DATA2, "af9", NULL),
+	_OMAP2430_BALLENTRY(USB0HS_DATA3, "ad9", NULL),
+	_OMAP2430_BALLENTRY(USB0HS_DATA4, "y11", NULL),
+	_OMAP2430_BALLENTRY(USB0HS_DATA5, "ad7", NULL),
+	_OMAP2430_BALLENTRY(USB0HS_DATA6, "ae7", NULL),
+	_OMAP2430_BALLENTRY(USB0HS_DATA7, "ac7", NULL),
+	_OMAP2430_BALLENTRY(USB0HS_DIR, "ad8", NULL),
+	_OMAP2430_BALLENTRY(USB0HS_NXT, "ae9", NULL),
+	_OMAP2430_BALLENTRY(USB0HS_STP, "ae5", NULL),
+	{ .reg_offset = OMAP_MUX_TERMINATOR },
+};
+#else
+#define omap2430_pop_ball	 NULL
+#endif
+
+int __init omap2430_mux_init(struct omap_board_mux *board_subset, int flags)
+{
+	struct omap_ball *package_balls = NULL;
+
+	switch (flags & OMAP_PACKAGE_MASK) {
+	case OMAP_PACKAGE_ZAC:
+		package_balls = omap2430_pop_ball;
+		break;
+	default:
+		pr_warning("mux: No ball data available for omap2420 package\n");
+	}
+
+	return omap_mux_init(OMAP2430_CONTROL_PADCONF_MUX_PBASE,
+			     OMAP2430_CONTROL_PADCONF_MUX_SIZE,
+				omap2430_muxmodes, NULL, board_subset,
+				package_balls);
+}
diff --git a/arch/arm/mach-omap2/serial.c b/arch/arm/mach-omap2/serial.c
index a27e91e..d11f190 100644
--- a/arch/arm/mach-omap2/serial.c
+++ b/arch/arm/mach-omap2/serial.c
@@ -678,8 +678,11 @@ void __init omap_serial_early_init(void)
 {
 }
 
+/*
 void __init omap_serial_init(int wake_gpio_strobe,
 			     unsigned int wake_strobe_enable_mask)
+*/
+void __init omap_serial_init(void)
 {
 	int i;
 	const struct omap_uart_config *info;
@@ -706,8 +709,10 @@ void __init omap_serial_init(int wake_gpio_strobe,
 			continue;
 		}
 
+                /*
 		if (wake_strobe_enable_mask & (1 << i))
 			p->wake_gpio_strobe = wake_gpio_strobe;
+                */
 
 		sprintf(name, "uart%d_ick", i+1);
 		uart->ick = clk_get(NULL, name);
diff --git a/arch/arm/plat-omap/common.c b/arch/arm/plat-omap/common.c
index 8da1c44..73decd9 100644
--- a/arch/arm/plat-omap/common.c
+++ b/arch/arm/plat-omap/common.c
@@ -43,7 +43,7 @@
 
 #define NO_LENGTH_CHECK 0xffffffff
 
-unsigned char omap_bootloader_tag[512];
+unsigned char omap_bootloader_tag[1024];
 int omap_bootloader_tag_len;
 
 struct omap_board_config_kernel *omap_board_config;
@@ -58,11 +58,74 @@ struct omap_opp *dsp_opps;
 struct omap_opp *l3_opps;
 #endif
 
+/*
+ * BOOTLDR config
+ * stolen from original Noka code
+ */
+static int __init parse_tag_omap(const struct tag *tag)
+{
+	u32 size = tag->hdr.size - (sizeof(tag->hdr) >> 2);
+ 
+	size <<= 2;
+ 	if (size > sizeof(omap_bootloader_tag))
+ 		return -1;
+ 
+ 	memcpy(omap_bootloader_tag, tag->u.omap.data, size);
+ 	omap_bootloader_tag_len = size;
+ 
+         return 0;
+}
+ 
+__tagtable(ATAG_BOARD, parse_tag_omap);
+
 static const void *get_config(u16 tag, size_t len, int skip, size_t *len_out)
 {
 	struct omap_board_config_kernel *kinfo = NULL;
 	int i;
 
+	struct omap_board_config_entry *info = NULL;
+
+	if (omap_bootloader_tag_len > 4)
+		info = (struct omap_board_config_entry *) omap_bootloader_tag;
+	while (info != NULL) {
+		u8 *next;
+
+		if (info->tag == tag) {
+			if (skip == 0)
+				break;
+			skip--;
+		}
+
+		if ((info->len & 0x03) != 0) {
+			/* We bail out to avoid an alignment fault */
+			printk(KERN_ERR "OMAP peripheral config: Length (%d) not word-aligned (tag %04x)\n",
+			       info->len, info->tag);
+			return NULL;
+		}
+		next = (u8 *) info + sizeof(*info) + info->len;
+		if (next >= omap_bootloader_tag + omap_bootloader_tag_len)
+			info = NULL;
+		else
+			info = (struct omap_board_config_entry *) next;
+	}
+	if (info != NULL) {
+		/* Check the length as a lame attempt to check for
+		 * binary inconsistency. */
+		if (len != NO_LENGTH_CHECK) {
+			/* Word-align len */
+			if (len & 0x03)
+				len = (len + 3) & ~0x03;
+			if (info->len != len) {
+				printk(KERN_ERR "OMAP peripheral config: Length mismatch with tag %x (want %d, got %d)\n",
+				       tag, len, info->len);
+				return NULL;
+			}
+		}
+		if (len_out != NULL)
+			*len_out = info->len;
+		return info->data;
+	}
+
 	/* Try to find the config from the board-specific structures
 	 * in the kernel. */
 	for (i = 0; i < omap_board_config_size; i++) {
diff --git a/arch/arm/plat-omap/i2c.c b/arch/arm/plat-omap/i2c.c
index fb447c1..cc96f19 100644
--- a/arch/arm/plat-omap/i2c.c
+++ b/arch/arm/plat-omap/i2c.c
@@ -122,9 +122,11 @@ static void omap_i2c_set_wfc_mpu_wkup_lat(struct device *dev, int val)
 static void __init omap_set_i2c_constraint_func(
 				struct omap_i2c_bus_platform_data *pd)
 {
+#ifdef CONFIG_ARCH_OMAP34XX
 	if (cpu_is_omap34xx())
 		pd->set_mpu_wkup_lat = omap_i2c_set_wfc_mpu_wkup_lat;
 	else
+#endif
 		pd->set_mpu_wkup_lat = NULL;
 }
 
diff --git a/arch/arm/plat-omap/include/plat/io.h b/arch/arm/plat-omap/include/plat/io.h
index b455433..24de69c 100644
--- a/arch/arm/plat-omap/include/plat/io.h
+++ b/arch/arm/plat-omap/include/plat/io.h
@@ -274,11 +274,40 @@ extern void omap1_map_common_io(void);
 extern void omap1_init_common_hw(void);
 
 extern void omap2_map_common_io(void);
+#ifdef CONFIG_ARCH_OMAP2420
+extern void omap242x_map_common_io(void);
+#else
+static inline void omap242x_map_common_io(void)
+{
+}
+#endif
+
+#ifdef CONFIG_ARCH_OMAP2430
+extern void omap243x_map_common_io(void);
+#else
+static inline void omap243x_map_common_io(void)
+{
+}
+#endif
+
+#ifdef CONFIG_ARCH_OMAP3
+extern void omap34xx_map_common_io(void);
+#else
+static inline void omap34xx_map_common_io(void)
+{
+}
+#endif
+
+#ifdef CONFIG_ARCH_OMAP4
+extern void omap44xx_map_common_io(void);
+#else
+static inline void omap44xx_map_common_io(void)
+{
+}
+#endif
+
 extern void omap2_init_common_hw(struct omap_sdrc_params *sdrc_cs0,
-				 struct omap_sdrc_params *sdrc_cs1,
-				 struct omap_opp *mpu_opps,
-				 struct omap_opp *dsp_opps,
-				 struct omap_opp *l3_opps);
+				 struct omap_sdrc_params *sdrc_cs1);
 
 #define __arch_ioremap(p,s,t)	omap_ioremap(p,s,t)
 #define __arch_iounmap(v)	omap_iounmap(v)
diff --git a/arch/arm/plat-omap/include/plat/mux.h b/arch/arm/plat-omap/include/plat/mux.h
index 437d70a..e8fa785 100644
--- a/arch/arm/plat-omap/include/plat/mux.h
+++ b/arch/arm/plat-omap/include/plat/mux.h
@@ -980,4 +980,95 @@ static inline int omap2_mux_init(void) { return 0; }
 static inline int omap_cfg_reg(unsigned long reg_cfg) { return 0; }
 #endif
 
-	#endif
+#define OMAP_MUX_TERMINATOR	0xffff
+
+/* Flags for omap_mux_init */
+#define OMAP_PACKAGE_MASK		0xffff
+#define OMAP_PACKAGE_CBP		6		/* 515-pin 0.40 0.50 */
+#define OMAP_PACKAGE_CUS		5		/* 423-pin 0.65 */
+#define OMAP_PACKAGE_CBB		4		/* 515-pin 0.40 0.50 */
+#define OMAP_PACKAGE_CBC		3		/* 515-pin 0.50 0.65 */
+#define OMAP_PACKAGE_ZAC		2		/* 24xx 447-pin POP */
+#define OMAP_PACKAGE_ZAF		1		/* 2420 447-pin SIP */
+
+#define OMAP_MUX_NR_MODES	8			/* Available modes */
+#define OMAP_MUX_NR_SIDES	2			/* Bottom & top */
+
+/**
+ * struct omap_mux - data for omap mux register offset and it's value
+ * @reg_offset:	mux register offset from the mux base
+ * @gpio:	GPIO number
+ * @muxnames:	available signal modes for a ball
+ */
+struct omap_mux {
+	u16	reg_offset;
+	u16	gpio;
+#ifdef CONFIG_OMAP_MUX
+	char	*muxnames[OMAP_MUX_NR_MODES];
+#ifdef CONFIG_DEBUG_FS
+	char	*balls[OMAP_MUX_NR_SIDES];
+#endif
+#endif
+};
+
+/**
+ * struct omap_ball - data for balls on omap package
+ * @reg_offset:	mux register offset from the mux base
+ * @balls:	available balls on the package
+ */
+struct omap_ball {
+	u16	reg_offset;
+	char	*balls[OMAP_MUX_NR_SIDES];
+};
+
+/**
+ * struct omap_board_mux - data for initializing mux registers
+ * @reg_offset:	mux register offset from the mux base
+ * @mux_value:	desired mux value to set
+ */
+struct omap_board_mux {
+	u16	reg_offset;
+	u16	value;
+};
+
+/**
+ * omap_mux_init - private mux init function, do not call
+ */
+extern int omap_mux_init(u32 mux_pbase, u32 mux_size,
+				struct omap_mux *superset,
+				struct omap_mux *package_subset,
+				struct omap_board_mux *board_mux,
+				struct omap_ball *package_balls);
+
+/* 34xx mux mode options for each pin. See TRM for options */
+#define OMAP_MUX_MODE0      0
+#define OMAP_MUX_MODE1      1
+#define OMAP_MUX_MODE2      2
+#define OMAP_MUX_MODE3      3
+#define OMAP_MUX_MODE4      4
+#define OMAP_MUX_MODE5      5
+#define OMAP_MUX_MODE6      6
+#define OMAP_MUX_MODE7      7
+
+/* 34xx specific mux bit defines */
+#define OMAP_INPUT_EN			(1 << 8)
+#define OMAP_OFF_EN			(1 << 9)
+#define OMAP_OFFOUT_EN			(1 << 10)
+#define OMAP_OFFOUT_VAL			(1 << 11)
+#define OMAP_OFF_PULL_EN		(1 << 12)
+#define OMAP_OFF_PULL_UP		(1 << 13)
+#define OMAP_WAKEUP_EN			(1 << 14)
+
+/* Active pin states */
+#define OMAP_PIN_OUTPUT			0
+#define OMAP_PIN_INPUT			OMAP_INPUT_EN
+#define OMAP_PIN_INPUT_PULLUP		(OMAP_PULL_ENA | OMAP_INPUT_EN \
+						| OMAP_PULL_UP)
+#define OMAP_PIN_INPUT_PULLDOWN		(OMAP_PULL_ENA | OMAP_INPUT_EN)
+
+#define OMAP_MODE_GPIO(x)	(((x) & OMAP_MUX_MODE7) == OMAP_MUX_MODE4)
+
+#include "mux2420.h"
+#include "mux2430.h"
+
+#endif
diff --git a/arch/arm/plat-omap/include/plat/mux2420.h b/arch/arm/plat-omap/include/plat/mux2420.h
new file mode 100644
index 0000000..50b4eb8
--- /dev/null
+++ b/arch/arm/plat-omap/include/plat/mux2420.h
@@ -0,0 +1,288 @@
+/*
+ * Copyright (C) 2009 Nokia
+ * Copyright (C) 2009 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define OMAP2420_CONTROL_PADCONF_MUX_PBASE			0x48000030LU
+
+#define OMAP2420_MUX(mode0, mux_value)					\
+{									\
+	.reg_offset	= (OMAP2420_CONTROL_PADCONF_##mode0##_OFFSET),	\
+	.value		= (mux_value),					\
+}
+
+/*
+ * OMAP2420 CONTROL_PADCONF* register offsets for pin-muxing
+ *
+ * Extracted from the TRM.  Add 0x48000030 to these values to get the
+ * absolute addresses.  The name in the macro is the mode-0 name of
+ * the pin.  NOTE: These registers are 8-bits wide.
+ */
+#define OMAP2420_CONTROL_PADCONF_SDRC_A14_OFFSET			0x000
+#define OMAP2420_CONTROL_PADCONF_SDRC_A13_OFFSET			0x001
+#define OMAP2420_CONTROL_PADCONF_SDRC_A12_OFFSET			0x002
+#define OMAP2420_CONTROL_PADCONF_SDRC_BA1_OFFSET			0x003
+#define OMAP2420_CONTROL_PADCONF_SDRC_BA0_OFFSET			0x004
+#define OMAP2420_CONTROL_PADCONF_SDRC_A11_OFFSET			0x005
+#define OMAP2420_CONTROL_PADCONF_SDRC_A10_OFFSET			0x006
+#define OMAP2420_CONTROL_PADCONF_SDRC_A9_OFFSET				0x007
+#define OMAP2420_CONTROL_PADCONF_SDRC_A8_OFFSET				0x008
+#define OMAP2420_CONTROL_PADCONF_SDRC_A7_OFFSET				0x009
+#define OMAP2420_CONTROL_PADCONF_SDRC_A6_OFFSET				0x00a
+#define OMAP2420_CONTROL_PADCONF_SDRC_A5_OFFSET				0x00b
+#define OMAP2420_CONTROL_PADCONF_SDRC_A4_OFFSET				0x00c
+#define OMAP2420_CONTROL_PADCONF_SDRC_A3_OFFSET				0x00d
+#define OMAP2420_CONTROL_PADCONF_SDRC_A2_OFFSET				0x00e
+#define OMAP2420_CONTROL_PADCONF_SDRC_A1_OFFSET				0x00f
+#define OMAP2420_CONTROL_PADCONF_SDRC_A0_OFFSET				0x010
+#define OMAP2420_CONTROL_PADCONF_SDRC_D31_OFFSET			0x021
+#define OMAP2420_CONTROL_PADCONF_SDRC_D30_OFFSET			0x022
+#define OMAP2420_CONTROL_PADCONF_SDRC_D29_OFFSET			0x023
+#define OMAP2420_CONTROL_PADCONF_SDRC_D28_OFFSET			0x024
+#define OMAP2420_CONTROL_PADCONF_SDRC_D27_OFFSET			0x025
+#define OMAP2420_CONTROL_PADCONF_SDRC_D26_OFFSET			0x026
+#define OMAP2420_CONTROL_PADCONF_SDRC_D25_OFFSET			0x027
+#define OMAP2420_CONTROL_PADCONF_SDRC_D24_OFFSET			0x028
+#define OMAP2420_CONTROL_PADCONF_SDRC_D23_OFFSET			0x029
+#define OMAP2420_CONTROL_PADCONF_SDRC_D22_OFFSET			0x02a
+#define OMAP2420_CONTROL_PADCONF_SDRC_D21_OFFSET			0x02b
+#define OMAP2420_CONTROL_PADCONF_SDRC_D20_OFFSET			0x02c
+#define OMAP2420_CONTROL_PADCONF_SDRC_D19_OFFSET			0x02d
+#define OMAP2420_CONTROL_PADCONF_SDRC_D18_OFFSET			0x02e
+#define OMAP2420_CONTROL_PADCONF_SDRC_D17_OFFSET			0x02f
+#define OMAP2420_CONTROL_PADCONF_SDRC_D16_OFFSET			0x030
+#define OMAP2420_CONTROL_PADCONF_SDRC_D15_OFFSET			0x031
+#define OMAP2420_CONTROL_PADCONF_SDRC_D14_OFFSET			0x032
+#define OMAP2420_CONTROL_PADCONF_SDRC_D13_OFFSET			0x033
+#define OMAP2420_CONTROL_PADCONF_SDRC_D12_OFFSET			0x034
+#define OMAP2420_CONTROL_PADCONF_SDRC_D11_OFFSET			0x035
+#define OMAP2420_CONTROL_PADCONF_SDRC_D10_OFFSET			0x036
+#define OMAP2420_CONTROL_PADCONF_SDRC_D9_OFFSET				0x037
+#define OMAP2420_CONTROL_PADCONF_SDRC_D8_OFFSET				0x038
+#define OMAP2420_CONTROL_PADCONF_SDRC_D7_OFFSET				0x039
+#define OMAP2420_CONTROL_PADCONF_SDRC_D6_OFFSET				0x03a
+#define OMAP2420_CONTROL_PADCONF_SDRC_D5_OFFSET				0x03b
+#define OMAP2420_CONTROL_PADCONF_SDRC_D4_OFFSET				0x03c
+#define OMAP2420_CONTROL_PADCONF_SDRC_D3_OFFSET				0x03d
+#define OMAP2420_CONTROL_PADCONF_SDRC_D2_OFFSET				0x03e
+#define OMAP2420_CONTROL_PADCONF_SDRC_D1_OFFSET				0x03f
+#define OMAP2420_CONTROL_PADCONF_SDRC_D0_OFFSET				0x040
+#define OMAP2420_CONTROL_PADCONF_GPMC_A10_OFFSET			0x041
+#define OMAP2420_CONTROL_PADCONF_GPMC_A9_OFFSET				0x042
+#define OMAP2420_CONTROL_PADCONF_GPMC_A8_OFFSET				0x043
+#define OMAP2420_CONTROL_PADCONF_GPMC_A7_OFFSET				0x044
+#define OMAP2420_CONTROL_PADCONF_GPMC_A6_OFFSET				0x045
+#define OMAP2420_CONTROL_PADCONF_GPMC_A5_OFFSET				0x046
+#define OMAP2420_CONTROL_PADCONF_GPMC_A4_OFFSET				0x047
+#define OMAP2420_CONTROL_PADCONF_GPMC_A3_OFFSET				0x048
+#define OMAP2420_CONTROL_PADCONF_GPMC_A2_OFFSET				0x049
+#define OMAP2420_CONTROL_PADCONF_GPMC_A1_OFFSET				0x04a
+#define OMAP2420_CONTROL_PADCONF_GPMC_D15_OFFSET			0x04b
+#define OMAP2420_CONTROL_PADCONF_GPMC_D14_OFFSET			0x04c
+#define OMAP2420_CONTROL_PADCONF_GPMC_D13_OFFSET			0x04d
+#define OMAP2420_CONTROL_PADCONF_GPMC_D12_OFFSET			0x04e
+#define OMAP2420_CONTROL_PADCONF_GPMC_D11_OFFSET			0x04f
+#define OMAP2420_CONTROL_PADCONF_GPMC_D10_OFFSET			0x050
+#define OMAP2420_CONTROL_PADCONF_GPMC_D9_OFFSET				0x051
+#define OMAP2420_CONTROL_PADCONF_GPMC_D8_OFFSET				0x052
+#define OMAP2420_CONTROL_PADCONF_GPMC_D7_OFFSET				0x053
+#define OMAP2420_CONTROL_PADCONF_GPMC_D6_OFFSET				0x054
+#define OMAP2420_CONTROL_PADCONF_GPMC_D5_OFFSET				0x055
+#define OMAP2420_CONTROL_PADCONF_GPMC_D4_OFFSET				0x056
+#define OMAP2420_CONTROL_PADCONF_GPMC_D3_OFFSET				0x057
+#define OMAP2420_CONTROL_PADCONF_GPMC_D2_OFFSET				0x058
+#define OMAP2420_CONTROL_PADCONF_GPMC_D1_OFFSET				0x059
+#define OMAP2420_CONTROL_PADCONF_GPMC_D0_OFFSET				0x05a
+#define OMAP2420_CONTROL_PADCONF_GPMC_CLK_OFFSET			0x05b
+#define OMAP2420_CONTROL_PADCONF_GPMC_NCS0_OFFSET			0x05c
+#define OMAP2420_CONTROL_PADCONF_GPMC_NCS1_OFFSET			0x05d
+#define OMAP2420_CONTROL_PADCONF_GPMC_NCS2_OFFSET			0x05e
+#define OMAP2420_CONTROL_PADCONF_GPMC_NCS3_OFFSET			0x05f
+#define OMAP2420_CONTROL_PADCONF_GPMC_NCS4_OFFSET			0x060
+#define OMAP2420_CONTROL_PADCONF_GPMC_NCS5_OFFSET			0x061
+#define OMAP2420_CONTROL_PADCONF_GPMC_NCS6_OFFSET			0x062
+#define OMAP2420_CONTROL_PADCONF_GPMC_NCS7_OFFSET			0x063
+#define OMAP2420_CONTROL_PADCONF_GPMC_NALE_ALE_OFFSET			0x064
+#define OMAP2420_CONTROL_PADCONF_GPMC_NOE_OFFSET			0x065
+#define OMAP2420_CONTROL_PADCONF_GPMC_NWE_OFFSET			0x066
+#define OMAP2420_CONTROL_PADCONF_GPMC_NBE0_OFFSET			0x067
+#define OMAP2420_CONTROL_PADCONF_GPMC_NBE1_OFFSET			0x068
+#define OMAP2420_CONTROL_PADCONF_GPMC_NWP_OFFSET			0x069
+#define OMAP2420_CONTROL_PADCONF_GPMC_WAIT0_OFFSET			0x06a
+#define OMAP2420_CONTROL_PADCONF_GPMC_WAIT1_OFFSET			0x06b
+#define OMAP2420_CONTROL_PADCONF_GPMC_WAIT2_OFFSET			0x06c
+#define OMAP2420_CONTROL_PADCONF_GPMC_WAIT3_OFFSET			0x06d
+#define OMAP2420_CONTROL_PADCONF_SDRC_CLK_OFFSET			0x06e
+#define OMAP2420_CONTROL_PADCONF_SDRC_NCLK_OFFSET			0x06f
+#define OMAP2420_CONTROL_PADCONF_SDRC_NCS0_OFFSET			0x070
+#define OMAP2420_CONTROL_PADCONF_SDRC_NCS1_OFFSET			0x071
+#define OMAP2420_CONTROL_PADCONF_SDRC_CKE0_OFFSET			0x072
+#define OMAP2420_CONTROL_PADCONF_SDRC_CKE1_OFFSET			0x073
+#define OMAP2420_CONTROL_PADCONF_SDRC_NRAS_OFFSET			0x074
+#define OMAP2420_CONTROL_PADCONF_SDRC_NCAS_OFFSET			0x075
+#define OMAP2420_CONTROL_PADCONF_SDRC_NWE_OFFSET			0x076
+#define OMAP2420_CONTROL_PADCONF_SDRC_DM0_OFFSET			0x077
+#define OMAP2420_CONTROL_PADCONF_SDRC_DM1_OFFSET			0x078
+#define OMAP2420_CONTROL_PADCONF_SDRC_DM2_OFFSET			0x079
+#define OMAP2420_CONTROL_PADCONF_SDRC_DM3_OFFSET			0x07a
+#define OMAP2420_CONTROL_PADCONF_SDRC_DQS0_OFFSET			0x07f
+#define OMAP2420_CONTROL_PADCONF_SDRC_DQS1_OFFSET			0x080
+#define OMAP2420_CONTROL_PADCONF_SDRC_DQS2_OFFSET			0x081
+#define OMAP2420_CONTROL_PADCONF_SDRC_DQS3_OFFSET			0x082
+#define OMAP2420_CONTROL_PADCONF_DSS_DATA0_OFFSET			0x083
+#define OMAP2420_CONTROL_PADCONF_DSS_DATA1_OFFSET			0x084
+#define OMAP2420_CONTROL_PADCONF_DSS_DATA2_OFFSET			0x085
+#define OMAP2420_CONTROL_PADCONF_DSS_DATA3_OFFSET			0x086
+#define OMAP2420_CONTROL_PADCONF_DSS_DATA4_OFFSET			0x087
+#define OMAP2420_CONTROL_PADCONF_DSS_DATA5_OFFSET			0x088
+#define OMAP2420_CONTROL_PADCONF_DSS_DATA6_OFFSET			0x089
+#define OMAP2420_CONTROL_PADCONF_DSS_DATA7_OFFSET			0x08a
+#define OMAP2420_CONTROL_PADCONF_DSS_DATA8_OFFSET			0x08b
+#define OMAP2420_CONTROL_PADCONF_DSS_DATA9_OFFSET			0x08c
+#define OMAP2420_CONTROL_PADCONF_DSS_DATA10_OFFSET			0x08d
+#define OMAP2420_CONTROL_PADCONF_DSS_DATA11_OFFSET			0x08e
+#define OMAP2420_CONTROL_PADCONF_DSS_DATA12_OFFSET			0x08f
+#define OMAP2420_CONTROL_PADCONF_DSS_DATA13_OFFSET			0x090
+#define OMAP2420_CONTROL_PADCONF_DSS_DATA14_OFFSET			0x091
+#define OMAP2420_CONTROL_PADCONF_DSS_DATA15_OFFSET			0x092
+#define OMAP2420_CONTROL_PADCONF_DSS_DATA16_OFFSET			0x093
+#define OMAP2420_CONTROL_PADCONF_DSS_DATA17_OFFSET			0x094
+#define OMAP2420_CONTROL_PADCONF_UART1_CTS_OFFSET			0x095
+#define OMAP2420_CONTROL_PADCONF_UART1_RTS_OFFSET			0x096
+#define OMAP2420_CONTROL_PADCONF_UART1_TX_OFFSET			0x097
+#define OMAP2420_CONTROL_PADCONF_UART1_RX_OFFSET			0x098
+#define OMAP2420_CONTROL_PADCONF_MCBSP2_DR_OFFSET			0x099
+#define OMAP2420_CONTROL_PADCONF_MCBSP2_CLKX_OFFSET			0x09a
+#define OMAP2420_CONTROL_PADCONF_DSS_PCL_OFFSET				0x09b
+#define OMAP2420_CONTROL_PADCONF_DSS_VSYNC_OFFSET			0x09c
+#define OMAP2420_CONTROL_PADCONF_DSS_HSYNC_OFFSET			0x09d
+#define OMAP2420_CONTROL_PADCONF_DSS_ACBIAS_OFFSET			0x09e
+#define OMAP2420_CONTROL_PADCONF_CAM_D9_OFFSET				0x09f
+#define OMAP2420_CONTROL_PADCONF_CAM_D8_OFFSET				0x0a0
+#define OMAP2420_CONTROL_PADCONF_CAM_D7_OFFSET				0x0a1
+#define OMAP2420_CONTROL_PADCONF_CAM_D6_OFFSET				0x0a2
+#define OMAP2420_CONTROL_PADCONF_CAM_D5_OFFSET				0x0a3
+#define OMAP2420_CONTROL_PADCONF_CAM_D4_OFFSET				0x0a4
+#define OMAP2420_CONTROL_PADCONF_CAM_D3_OFFSET				0x0a5
+#define OMAP2420_CONTROL_PADCONF_CAM_D2_OFFSET				0x0a6
+#define OMAP2420_CONTROL_PADCONF_CAM_D1_OFFSET				0x0a7
+#define OMAP2420_CONTROL_PADCONF_CAM_D0_OFFSET				0x0a8
+#define OMAP2420_CONTROL_PADCONF_CAM_HS_OFFSET				0x0a9
+#define OMAP2420_CONTROL_PADCONF_CAM_VS_OFFSET				0x0aa
+#define OMAP2420_CONTROL_PADCONF_CAM_LCLK_OFFSET			0x0ab
+#define OMAP2420_CONTROL_PADCONF_CAM_XCLK_OFFSET			0x0ac
+#define OMAP2420_CONTROL_PADCONF_SSI1_DAT_TX_OFFSET			0x0ad
+#define OMAP2420_CONTROL_PADCONF_SSI1_FLAG_TX_OFFSET			0x0ae
+#define OMAP2420_CONTROL_PADCONF_SSI1_RDY_TX_OFFSET			0x0af
+#define OMAP2420_CONTROL_PADCONF_GPIO_62_OFFSET				0x0b0
+#define OMAP2420_CONTROL_PADCONF_SSI1_DAT_RX_OFFSET			0x0b1
+#define OMAP2420_CONTROL_PADCONF_SSI1_FLAG_RX_OFFSET			0x0b2
+#define OMAP2420_CONTROL_PADCONF_SSI1_RDY_RX_OFFSET			0x0b3
+#define OMAP2420_CONTROL_PADCONF_SSI1_WAKE_OFFSET			0x0b4
+#define OMAP2420_CONTROL_PADCONF_VLYNQ_CLK_OFFSET			0x0b5
+#define OMAP2420_CONTROL_PADCONF_VLYNQ_RX1_OFFSET			0x0b6
+#define OMAP2420_CONTROL_PADCONF_VLYNQ_RX0_OFFSET			0x0b7
+#define OMAP2420_CONTROL_PADCONF_VLYNQ_TX1_OFFSET			0x0b8
+#define OMAP2420_CONTROL_PADCONF_VLYNQ_TX0_OFFSET			0x0b9
+#define OMAP2420_CONTROL_PADCONF_VLYNQ_NLA_OFFSET			0x0ba
+#define OMAP2420_CONTROL_PADCONF_UART2_CTS_OFFSET			0x0bb
+#define OMAP2420_CONTROL_PADCONF_UART2_RTS_OFFSET			0x0bc
+#define OMAP2420_CONTROL_PADCONF_UART2_TX_OFFSET			0x0bd
+#define OMAP2420_CONTROL_PADCONF_UART2_RX_OFFSET			0x0be
+#define OMAP2420_CONTROL_PADCONF_EAC_BT_SCLK_OFFSET			0x0bf
+#define OMAP2420_CONTROL_PADCONF_EAC_BT_FS_OFFSET			0x0c0
+#define OMAP2420_CONTROL_PADCONF_EAC_BT_DIN_OFFSET			0x0c1
+#define OMAP2420_CONTROL_PADCONF_EAC_BT_DOUT_OFFSET			0x0c2
+#define OMAP2420_CONTROL_PADCONF_MMC_CLKO_OFFSET			0x0c3
+#define OMAP2420_CONTROL_PADCONF_MMC_CMD_OFFSET				0x0c4
+#define OMAP2420_CONTROL_PADCONF_MMC_DAT0_OFFSET			0x0c5
+#define OMAP2420_CONTROL_PADCONF_MMC_DAT1_OFFSET			0x0c6
+#define OMAP2420_CONTROL_PADCONF_MMC_DAT2_OFFSET			0x0c7
+#define OMAP2420_CONTROL_PADCONF_MMC_DAT3_OFFSET			0x0c8
+#define OMAP2420_CONTROL_PADCONF_MMC_DAT_DIR0_OFFSET			0x0c9
+#define OMAP2420_CONTROL_PADCONF_MMC_DAT_DIR1_OFFSET			0x0ca
+#define OMAP2420_CONTROL_PADCONF_MMC_DAT_DIR2_OFFSET			0x0cb
+#define OMAP2420_CONTROL_PADCONF_MMC_DAT_DIR3_OFFSET			0x0cc
+#define OMAP2420_CONTROL_PADCONF_MMC_CMD_DIR_OFFSET			0x0cd
+#define OMAP2420_CONTROL_PADCONF_MMC_CLKI_OFFSET			0x0ce
+#define OMAP2420_CONTROL_PADCONF_SPI1_CLK_OFFSET			0x0cf
+#define OMAP2420_CONTROL_PADCONF_SPI1_SIMO_OFFSET			0x0d0
+#define OMAP2420_CONTROL_PADCONF_SPI1_SOMI_OFFSET			0x0d1
+#define OMAP2420_CONTROL_PADCONF_SPI1_NCS0_OFFSET			0x0d2
+#define OMAP2420_CONTROL_PADCONF_SPI1_NCS1_OFFSET			0x0d3
+#define OMAP2420_CONTROL_PADCONF_SPI1_NCS2_OFFSET			0x0d4
+#define OMAP2420_CONTROL_PADCONF_SPI1_NCS3_OFFSET			0x0d5
+#define OMAP2420_CONTROL_PADCONF_SPI2_CLK_OFFSET			0x0d6
+#define OMAP2420_CONTROL_PADCONF_SPI2_SIMO_OFFSET			0x0d7
+#define OMAP2420_CONTROL_PADCONF_SPI2_SOMI_OFFSET			0x0d8
+#define OMAP2420_CONTROL_PADCONF_SPI2_NCS0_OFFSET			0x0d9
+#define OMAP2420_CONTROL_PADCONF_MCBSP1_CLKR_OFFSET			0x0da
+#define OMAP2420_CONTROL_PADCONF_MCBSP1_FSR_OFFSET			0x0db
+#define OMAP2420_CONTROL_PADCONF_MCBSP1_DX_OFFSET			0x0dc
+#define OMAP2420_CONTROL_PADCONF_MCBSP1_DR_OFFSET			0x0dd
+#define OMAP2420_CONTROL_PADCONF_MCBSP_CLKS_OFFSET			0x0de
+#define OMAP2420_CONTROL_PADCONF_MCBSP1_FSX_OFFSET			0x0df
+#define OMAP2420_CONTROL_PADCONF_MCBSP1_CLKX_OFFSET			0x0e0
+#define OMAP2420_CONTROL_PADCONF_I2C1_SCL_OFFSET			0x0e1
+#define OMAP2420_CONTROL_PADCONF_I2C1_SDA_OFFSET			0x0e2
+#define OMAP2420_CONTROL_PADCONF_I2C2_SCL_OFFSET			0x0e3
+#define OMAP2420_CONTROL_PADCONF_I2C2_SDA_OFFSET			0x0e4
+#define OMAP2420_CONTROL_PADCONF_HDQ_SIO_OFFSET				0x0e5
+#define OMAP2420_CONTROL_PADCONF_UART3_CTS_RCTX_OFFSET			0x0e6
+#define OMAP2420_CONTROL_PADCONF_UART3_RTS_SD_OFFSET			0x0e7
+#define OMAP2420_CONTROL_PADCONF_UART3_TX_IRTX_OFFSET			0x0e8
+#define OMAP2420_CONTROL_PADCONF_UART3_RX_IRRX_OFFSET			0x0e9
+#define OMAP2420_CONTROL_PADCONF_TV_CVBS_OFFSET				0x0ea
+#define OMAP2420_CONTROL_PADCONF_TV_VREF_OFFSET				0x0eb
+#define OMAP2420_CONTROL_PADCONF_TV_RREF_OFFSET				0x0ec
+#define OMAP2420_CONTROL_PADCONF_USB0_PUEN_OFFSET			0x0ed
+#define OMAP2420_CONTROL_PADCONF_USB0_VP_OFFSET				0x0ee
+#define OMAP2420_CONTROL_PADCONF_USB0_VM_OFFSET				0x0ef
+#define OMAP2420_CONTROL_PADCONF_USB0_RCV_OFFSET			0x0f0
+#define OMAP2420_CONTROL_PADCONF_USB0_TXEN_OFFSET			0x0f1
+#define OMAP2420_CONTROL_PADCONF_USB0_SE0_OFFSET			0x0f2
+#define OMAP2420_CONTROL_PADCONF_USB0_DAT_OFFSET			0x0f3
+#define OMAP2420_CONTROL_PADCONF_EAC_AC_SCLK_OFFSET			0x0f4
+#define OMAP2420_CONTROL_PADCONF_EAC_AC_FS_OFFSET			0x0f5
+#define OMAP2420_CONTROL_PADCONF_EAC_AC_DIN_OFFSET			0x0f6
+#define OMAP2420_CONTROL_PADCONF_EAC_AC_DOUT_OFFSET			0x0f7
+#define OMAP2420_CONTROL_PADCONF_EAC_AC_MCLK_OFFSET			0x0f8
+#define OMAP2420_CONTROL_PADCONF_EAC_AC_RST_OFFSET			0x0f9
+#define OMAP2420_CONTROL_PADCONF_SYS_NRESPWRON_OFFSET			0x0fa
+#define OMAP2420_CONTROL_PADCONF_SYS_NRESWARM_OFFSET			0x0fb
+#define OMAP2420_CONTROL_PADCONF_SYS_NIRQ_OFFSET			0x0fc
+#define OMAP2420_CONTROL_PADCONF_SYS_NV_OFFSET				0x0fd
+#define OMAP2420_CONTROL_PADCONF_GPIO_119_OFFSET			0x0fe
+#define OMAP2420_CONTROL_PADCONF_GPIO_120_OFFSET			0x0ff
+#define OMAP2420_CONTROL_PADCONF_GPIO_121_OFFSET			0x100
+#define OMAP2420_CONTROL_PADCONF_GPIO_122_OFFSET			0x101
+#define OMAP2420_CONTROL_PADCONF_SYS_32K_OFFSET				0x102
+#define OMAP2420_CONTROL_PADCONF_SYS_XTALIN_OFFSET			0x103
+#define OMAP2420_CONTROL_PADCONF_SYS_XTALOUT_OFFSET			0x104
+#define OMAP2420_CONTROL_PADCONF_GPIO_36_OFFSET				0x105
+#define OMAP2420_CONTROL_PADCONF_SYS_CLKREQ_OFFSET			0x106
+#define OMAP2420_CONTROL_PADCONF_SYS_CLKOUT_OFFSET			0x107
+#define OMAP2420_CONTROL_PADCONF_GPIO_6_OFFSET				0x108
+#define OMAP2420_CONTROL_PADCONF_GPIO_124_OFFSET			0x109
+#define OMAP2420_CONTROL_PADCONF_GPIO_125_OFFSET			0x10a
+#define OMAP2420_CONTROL_PADCONF_JTAG_EMU1_OFFSET			0x10b
+#define OMAP2420_CONTROL_PADCONF_JTAG_EMU0_OFFSET			0x10c
+#define OMAP2420_CONTROL_PADCONF_JTAG_NTRST_OFFSET			0x10d
+#define OMAP2420_CONTROL_PADCONF_JTAG_TCK_OFFSET			0x10e
+#define OMAP2420_CONTROL_PADCONF_JTAG_RTCK_OFFSET			0x10f
+#define OMAP2420_CONTROL_PADCONF_JTAG_TMS_OFFSET			0x110
+#define OMAP2420_CONTROL_PADCONF_JTAG_TDI_OFFSET			0x111
+#define OMAP2420_CONTROL_PADCONF_JTAG_TDO_OFFSET			0x112
+
+#define OMAP2420_CONTROL_PADCONF_MUX_SIZE			\
+		(OMAP2420_CONTROL_PADCONF_JTAG_TDO_OFFSET + 0x1)
+/**
+ * omap2420_mux_init() - initialize mux system with board specific set
+ * @board_mux:		Board specific mux table
+ * @flags:		OMAP package type used for the board
+ */
+int omap2420_mux_init(struct omap_board_mux *board_mux, int flags);
diff --git a/arch/arm/plat-omap/include/plat/mux2430.h b/arch/arm/plat-omap/include/plat/mux2430.h
new file mode 100644
index 0000000..8ff6d0c
--- /dev/null
+++ b/arch/arm/plat-omap/include/plat/mux2430.h
@@ -0,0 +1,377 @@
+/*
+ * Copyright (C) 2009 Nokia
+ * Copyright (C) 2009 Texas Instruments
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define OMAP2430_CONTROL_PADCONF_MUX_PBASE			0x49002030LU
+
+#define OMAP2430_MUX(mode0, mux_value)					\
+{									\
+	.reg_offset	= (OMAP2430_CONTROL_PADCONF_##mode0##_OFFSET),	\
+	.value		= (mux_value),					\
+}
+
+/*
+ * OMAP2430 CONTROL_PADCONF* register offsets for pin-muxing
+ *
+ * Extracted from the TRM.  Add 0x49002030 to these values to get the
+ * absolute addresses.  The name in the macro is the mode-0 name of
+ * the pin.  NOTE: These registers are 8-bits wide.
+ *
+ * Note that these defines use SDMMC instead of MMC for compability
+ * with signal names used in 3630.
+ */
+#define OMAP2430_CONTROL_PADCONF_GPMC_CLK_OFFSET		0x000
+#define OMAP2430_CONTROL_PADCONF_GPMC_NCS0_OFFSET		0x001
+#define OMAP2430_CONTROL_PADCONF_GPMC_NCS1_OFFSET		0x002
+#define OMAP2430_CONTROL_PADCONF_GPMC_NCS2_OFFSET		0x003
+#define OMAP2430_CONTROL_PADCONF_GPMC_NCS3_OFFSET		0x004
+#define OMAP2430_CONTROL_PADCONF_GPMC_NCS4_OFFSET		0x005
+#define OMAP2430_CONTROL_PADCONF_GPMC_NCS5_OFFSET		0x006
+#define OMAP2430_CONTROL_PADCONF_GPMC_NCS6_OFFSET		0x007
+#define OMAP2430_CONTROL_PADCONF_GPMC_NCS7_OFFSET		0x008
+#define OMAP2430_CONTROL_PADCONF_GPMC_NADV_ALE_OFFSET		0x009
+#define OMAP2430_CONTROL_PADCONF_GPMC_NOE_NRE_OFFSET		0x00a
+#define OMAP2430_CONTROL_PADCONF_GPMC_NWE_OFFSET		0x00b
+#define OMAP2430_CONTROL_PADCONF_GPMC_NBE0_CLE_OFFSET		0x00c
+#define OMAP2430_CONTROL_PADCONF_GPMC_NBE1_OFFSET		0x00d
+#define OMAP2430_CONTROL_PADCONF_GPMC_NWP_OFFSET		0x00e
+#define OMAP2430_CONTROL_PADCONF_GPMC_WAIT0_OFFSET		0x00f
+#define OMAP2430_CONTROL_PADCONF_GPMC_WAIT1_OFFSET		0x010
+#define OMAP2430_CONTROL_PADCONF_GPMC_WAIT2_OFFSET		0x011
+#define OMAP2430_CONTROL_PADCONF_GPMC_WAIT3_OFFSET		0x012
+#define OMAP2430_CONTROL_PADCONF_SDRC_CLK_OFFSET		0x013
+#define OMAP2430_CONTROL_PADCONF_SDRC_NCLK_OFFSET		0x014
+#define OMAP2430_CONTROL_PADCONF_SDRC_NCS0_OFFSET		0x015
+#define OMAP2430_CONTROL_PADCONF_SDRC_NCS1_OFFSET		0x016
+#define OMAP2430_CONTROL_PADCONF_SDRC_CKE0_OFFSET		0x017
+#define OMAP2430_CONTROL_PADCONF_SDRC_CKE1_OFFSET		0x018
+#define OMAP2430_CONTROL_PADCONF_SDRC_NRAS_OFFSET		0x019
+#define OMAP2430_CONTROL_PADCONF_SDRC_NCAS_OFFSET		0x01a
+#define OMAP2430_CONTROL_PADCONF_SDRC_NWE_OFFSET		0x01b
+#define OMAP2430_CONTROL_PADCONF_SDRC_DM0_OFFSET		0x01c
+#define OMAP2430_CONTROL_PADCONF_SDRC_DM1_OFFSET		0x01d
+#define OMAP2430_CONTROL_PADCONF_SDRC_DM2_OFFSET		0x01e
+#define OMAP2430_CONTROL_PADCONF_SDRC_DM3_OFFSET		0x01f
+#define OMAP2430_CONTROL_PADCONF_SDRC_DQS0_OFFSET		0x020
+#define OMAP2430_CONTROL_PADCONF_SDRC_DQS1_OFFSET		0x021
+#define OMAP2430_CONTROL_PADCONF_SDRC_DQS2_OFFSET		0x022
+#define OMAP2430_CONTROL_PADCONF_SDRC_DQS3_OFFSET		0x023
+#define OMAP2430_CONTROL_PADCONF_SDRC_A14_OFFSET		0x024
+#define OMAP2430_CONTROL_PADCONF_SDRC_A13_OFFSET		0x025
+#define OMAP2430_CONTROL_PADCONF_SDRC_A12_OFFSET		0x026
+#define OMAP2430_CONTROL_PADCONF_SDRC_BA1_OFFSET		0x027
+#define OMAP2430_CONTROL_PADCONF_SDRC_BA0_OFFSET		0x028
+#define OMAP2430_CONTROL_PADCONF_SDRC_A11_OFFSET		0x029
+#define OMAP2430_CONTROL_PADCONF_SDRC_A10_OFFSET		0x02a
+#define OMAP2430_CONTROL_PADCONF_SDRC_A9_OFFSET			0x02b
+#define OMAP2430_CONTROL_PADCONF_SDRC_A8_OFFSET			0x02c
+#define OMAP2430_CONTROL_PADCONF_SDRC_A7_OFFSET			0x02d
+#define OMAP2430_CONTROL_PADCONF_SDRC_A6_OFFSET			0x02e
+#define OMAP2430_CONTROL_PADCONF_SDRC_A5_OFFSET			0x02f
+#define OMAP2430_CONTROL_PADCONF_SDRC_A4_OFFSET			0x030
+#define OMAP2430_CONTROL_PADCONF_SDRC_A3_OFFSET			0x031
+#define OMAP2430_CONTROL_PADCONF_SDRC_A2_OFFSET			0x032
+#define OMAP2430_CONTROL_PADCONF_SDRC_A1_OFFSET			0x033
+#define OMAP2430_CONTROL_PADCONF_SDRC_A0_OFFSET			0x034
+#define OMAP2430_CONTROL_PADCONF_SDRC_D31_OFFSET		0x035
+#define OMAP2430_CONTROL_PADCONF_SDRC_D30_OFFSET		0x036
+#define OMAP2430_CONTROL_PADCONF_SDRC_D29_OFFSET		0x037
+#define OMAP2430_CONTROL_PADCONF_SDRC_D28_OFFSET		0x038
+#define OMAP2430_CONTROL_PADCONF_SDRC_D27_OFFSET		0x039
+#define OMAP2430_CONTROL_PADCONF_SDRC_D26_OFFSET		0x03a
+#define OMAP2430_CONTROL_PADCONF_SDRC_D25_OFFSET		0x03b
+#define OMAP2430_CONTROL_PADCONF_SDRC_D24_OFFSET		0x03c
+#define OMAP2430_CONTROL_PADCONF_SDRC_D23_OFFSET		0x03d
+#define OMAP2430_CONTROL_PADCONF_SDRC_D22_OFFSET		0x03e
+#define OMAP2430_CONTROL_PADCONF_SDRC_D21_OFFSET		0x03f
+#define OMAP2430_CONTROL_PADCONF_SDRC_D20_OFFSET		0x040
+#define OMAP2430_CONTROL_PADCONF_SDRC_D19_OFFSET		0x041
+#define OMAP2430_CONTROL_PADCONF_SDRC_D18_OFFSET		0x042
+#define OMAP2430_CONTROL_PADCONF_SDRC_D17_OFFSET		0x043
+#define OMAP2430_CONTROL_PADCONF_SDRC_D16_OFFSET		0x044
+#define OMAP2430_CONTROL_PADCONF_SDRC_D15_OFFSET		0x045
+#define OMAP2430_CONTROL_PADCONF_SDRC_D14_OFFSET		0x046
+#define OMAP2430_CONTROL_PADCONF_SDRC_D13_OFFSET		0x047
+#define OMAP2430_CONTROL_PADCONF_SDRC_D12_OFFSET		0x048
+#define OMAP2430_CONTROL_PADCONF_SDRC_D11_OFFSET		0x049
+#define OMAP2430_CONTROL_PADCONF_SDRC_D10_OFFSET		0x04a
+#define OMAP2430_CONTROL_PADCONF_SDRC_D9_OFFSET			0x04b
+#define OMAP2430_CONTROL_PADCONF_SDRC_D8_OFFSET			0x04c
+#define OMAP2430_CONTROL_PADCONF_SDRC_D7_OFFSET			0x04d
+#define OMAP2430_CONTROL_PADCONF_SDRC_D6_OFFSET			0x04e
+#define OMAP2430_CONTROL_PADCONF_SDRC_D5_OFFSET			0x04f
+#define OMAP2430_CONTROL_PADCONF_SDRC_D4_OFFSET			0x050
+#define OMAP2430_CONTROL_PADCONF_SDRC_D3_OFFSET			0x051
+#define OMAP2430_CONTROL_PADCONF_SDRC_D2_OFFSET			0x052
+#define OMAP2430_CONTROL_PADCONF_SDRC_D1_OFFSET			0x053
+#define OMAP2430_CONTROL_PADCONF_SDRC_D0_OFFSET			0x054
+#define OMAP2430_CONTROL_PADCONF_GPMC_A10_OFFSET		0x055
+#define OMAP2430_CONTROL_PADCONF_GPMC_A9_OFFSET			0x056
+#define OMAP2430_CONTROL_PADCONF_GPMC_A8_OFFSET			0x057
+#define OMAP2430_CONTROL_PADCONF_GPMC_A7_OFFSET			0x058
+#define OMAP2430_CONTROL_PADCONF_GPMC_A6_OFFSET			0x059
+#define OMAP2430_CONTROL_PADCONF_GPMC_A5_OFFSET			0x05a
+#define OMAP2430_CONTROL_PADCONF_GPMC_A4_OFFSET			0x05b
+#define OMAP2430_CONTROL_PADCONF_GPMC_A3_OFFSET			0x05c
+#define OMAP2430_CONTROL_PADCONF_GPMC_A2_OFFSET			0x05d
+#define OMAP2430_CONTROL_PADCONF_GPMC_A1_OFFSET			0x05e
+#define OMAP2430_CONTROL_PADCONF_GPMC_D15_OFFSET		0x05f
+#define OMAP2430_CONTROL_PADCONF_GPMC_D14_OFFSET		0x060
+#define OMAP2430_CONTROL_PADCONF_GPMC_D13_OFFSET		0x061
+#define OMAP2430_CONTROL_PADCONF_GPMC_D12_OFFSET		0x062
+#define OMAP2430_CONTROL_PADCONF_GPMC_D11_OFFSET		0x063
+#define OMAP2430_CONTROL_PADCONF_GPMC_D10_OFFSET		0x064
+#define OMAP2430_CONTROL_PADCONF_GPMC_D9_OFFSET			0x065
+#define OMAP2430_CONTROL_PADCONF_GPMC_D8_OFFSET			0x066
+#define OMAP2430_CONTROL_PADCONF_GPMC_D7_OFFSET			0x067
+#define OMAP2430_CONTROL_PADCONF_GPMC_D6_OFFSET			0x068
+#define OMAP2430_CONTROL_PADCONF_GPMC_D5_OFFSET			0x069
+#define OMAP2430_CONTROL_PADCONF_GPMC_D4_OFFSET			0x06a
+#define OMAP2430_CONTROL_PADCONF_GPMC_D3_OFFSET			0x06b
+#define OMAP2430_CONTROL_PADCONF_GPMC_D2_OFFSET			0x06c
+#define OMAP2430_CONTROL_PADCONF_GPMC_D1_OFFSET			0x06d
+#define OMAP2430_CONTROL_PADCONF_GPMC_D0_OFFSET			0x06e
+#define OMAP2430_CONTROL_PADCONF_DSS_DATA0_OFFSET		0x06f
+#define OMAP2430_CONTROL_PADCONF_DSS_DATA1_OFFSET		0x070
+#define OMAP2430_CONTROL_PADCONF_DSS_DATA2_OFFSET		0x071
+#define OMAP2430_CONTROL_PADCONF_DSS_DATA3_OFFSET		0x072
+#define OMAP2430_CONTROL_PADCONF_DSS_DATA4_OFFSET		0x073
+#define OMAP2430_CONTROL_PADCONF_DSS_DATA5_OFFSET		0x074
+#define OMAP2430_CONTROL_PADCONF_DSS_DATA6_OFFSET		0x075
+#define OMAP2430_CONTROL_PADCONF_DSS_DATA7_OFFSET		0x076
+#define OMAP2430_CONTROL_PADCONF_DSS_DATA8_OFFSET		0x077
+#define OMAP2430_CONTROL_PADCONF_DSS_DATA9_OFFSET		0x078
+#define OMAP2430_CONTROL_PADCONF_DSS_DATA10_OFFSET		0x079
+#define OMAP2430_CONTROL_PADCONF_DSS_DATA11_OFFSET		0x07a
+#define OMAP2430_CONTROL_PADCONF_DSS_DATA12_OFFSET		0x07b
+#define OMAP2430_CONTROL_PADCONF_DSS_DATA13_OFFSET		0x07c
+#define OMAP2430_CONTROL_PADCONF_DSS_DATA14_OFFSET		0x07d
+#define OMAP2430_CONTROL_PADCONF_DSS_DATA15_OFFSET		0x07e
+#define OMAP2430_CONTROL_PADCONF_DSS_DATA16_OFFSET		0x07f
+#define OMAP2430_CONTROL_PADCONF_DSS_DATA17_OFFSET		0x080
+#define OMAP2430_CONTROL_PADCONF_UART1_CTS_OFFSET		0x081
+#define OMAP2430_CONTROL_PADCONF_UART1_RTS_OFFSET		0x082
+#define OMAP2430_CONTROL_PADCONF_UART1_TX_OFFSET		0x083
+#define OMAP2430_CONTROL_PADCONF_UART1_RX_OFFSET		0x084
+#define OMAP2430_CONTROL_PADCONF_MCBSP2_DR_OFFSET		0x085
+#define OMAP2430_CONTROL_PADCONF_MCBSP2_CLKX_OFFSET		0x086
+#define OMAP2430_CONTROL_PADCONF_DSS_PCLK_OFFSET		0x087
+#define OMAP2430_CONTROL_PADCONF_DSS_VSYNC_OFFSET		0x088
+#define OMAP2430_CONTROL_PADCONF_DSS_HSYNC_OFFSET		0x089
+#define OMAP2430_CONTROL_PADCONF_DSS_ACBIAS_OFFSET		0x08a
+#define OMAP2430_CONTROL_PADCONF_SYS_NRESPWRON_OFFSET		0x08b
+#define OMAP2430_CONTROL_PADCONF_SYS_NRESWARM_OFFSET		0x08c
+#define OMAP2430_CONTROL_PADCONF_SYS_NIRQ0_OFFSET		0x08d
+#define OMAP2430_CONTROL_PADCONF_SYS_NIRQ1_OFFSET		0x08e
+#define OMAP2430_CONTROL_PADCONF_SYS_VMODE_OFFSET		0x08f
+#define OMAP2430_CONTROL_PADCONF_GPIO_128_OFFSET		0x090
+#define OMAP2430_CONTROL_PADCONF_GPIO_129_OFFSET		0x091
+#define OMAP2430_CONTROL_PADCONF_GPIO_130_OFFSET		0x092
+#define OMAP2430_CONTROL_PADCONF_GPIO_131_OFFSET		0x093
+#define OMAP2430_CONTROL_PADCONF_SYS_32K_OFFSET			0x094
+#define OMAP2430_CONTROL_PADCONF_SYS_XTALIN_OFFSET		0x095
+#define OMAP2430_CONTROL_PADCONF_SYS_XTALOUT_OFFSET		0x096
+#define OMAP2430_CONTROL_PADCONF_GPIO_132_OFFSET		0x097
+#define OMAP2430_CONTROL_PADCONF_SYS_CLKREQ_OFFSET		0x098
+#define OMAP2430_CONTROL_PADCONF_SYS_CLKOUT_OFFSET		0x099
+#define OMAP2430_CONTROL_PADCONF_GPIO_151_OFFSET		0x09a
+#define OMAP2430_CONTROL_PADCONF_GPIO_133_OFFSET		0x09b
+#define OMAP2430_CONTROL_PADCONF_JTAG_EMU1_OFFSET		0x09c
+#define OMAP2430_CONTROL_PADCONF_JTAG_EMU0_OFFSET		0x09d
+#define OMAP2430_CONTROL_PADCONF_JTAG_NTRST_OFFSET		0x09e
+#define OMAP2430_CONTROL_PADCONF_JTAG_TCK_OFFSET		0x09f
+#define OMAP2430_CONTROL_PADCONF_JTAG_RTCK_OFFSET		0x0a0
+#define OMAP2430_CONTROL_PADCONF_JTAG_TMS_OFFSET		0x0a1
+#define OMAP2430_CONTROL_PADCONF_JTAG_TDI_OFFSET		0x0a2
+#define OMAP2430_CONTROL_PADCONF_JTAG_TDO_OFFSET		0x0a3
+#define OMAP2430_CONTROL_PADCONF_CAM_D9_OFFSET			0x0a4
+#define OMAP2430_CONTROL_PADCONF_CAM_D8_OFFSET			0x0a5
+#define OMAP2430_CONTROL_PADCONF_CAM_D7_OFFSET			0x0a6
+#define OMAP2430_CONTROL_PADCONF_CAM_D6_OFFSET			0x0a7
+#define OMAP2430_CONTROL_PADCONF_CAM_D5_OFFSET			0x0a8
+#define OMAP2430_CONTROL_PADCONF_CAM_D4_OFFSET			0x0a9
+#define OMAP2430_CONTROL_PADCONF_CAM_D3_OFFSET			0x0aa
+#define OMAP2430_CONTROL_PADCONF_CAM_D2_OFFSET			0x0ab
+#define OMAP2430_CONTROL_PADCONF_CAM_D1_OFFSET			0x0ac
+#define OMAP2430_CONTROL_PADCONF_CAM_D0_OFFSET			0x0ad
+#define OMAP2430_CONTROL_PADCONF_CAM_HS_OFFSET			0x0ae
+#define OMAP2430_CONTROL_PADCONF_CAM_VS_OFFSET			0x0af
+#define OMAP2430_CONTROL_PADCONF_CAM_LCLK_OFFSET		0x0b0
+#define OMAP2430_CONTROL_PADCONF_CAM_XCLK_OFFSET		0x0b1
+#define OMAP2430_CONTROL_PADCONF_CAM_D11_OFFSET			0x0b2
+#define OMAP2430_CONTROL_PADCONF_CAM_D10_OFFSET			0x0b3
+#define OMAP2430_CONTROL_PADCONF_GPIO_134_OFFSET		0x0b4
+#define OMAP2430_CONTROL_PADCONF_GPIO_135_OFFSET		0x0b5
+#define OMAP2430_CONTROL_PADCONF_GPIO_136_OFFSET		0x0b6
+#define OMAP2430_CONTROL_PADCONF_GPIO_137_OFFSET		0x0b7
+#define OMAP2430_CONTROL_PADCONF_GPIO_138_OFFSET		0x0b8
+#define OMAP2430_CONTROL_PADCONF_GPIO_139_OFFSET		0x0b9
+#define OMAP2430_CONTROL_PADCONF_GPIO_140_OFFSET		0x0ba
+#define OMAP2430_CONTROL_PADCONF_GPIO_141_OFFSET		0x0bb
+#define OMAP2430_CONTROL_PADCONF_GPIO_142_OFFSET		0x0bc
+#define OMAP2430_CONTROL_PADCONF_GPIO_154_OFFSET		0x0bd
+#define OMAP2430_CONTROL_PADCONF_GPIO_148_OFFSET		0x0be
+#define OMAP2430_CONTROL_PADCONF_GPIO_149_OFFSET		0x0bf
+#define OMAP2430_CONTROL_PADCONF_GPIO_150_OFFSET		0x0c0
+#define OMAP2430_CONTROL_PADCONF_GPIO_152_OFFSET		0x0c1
+#define OMAP2430_CONTROL_PADCONF_GPIO_153_OFFSET		0x0c2
+#define OMAP2430_CONTROL_PADCONF_SDMMC1_CLKO_OFFSET		0x0c3
+#define OMAP2430_CONTROL_PADCONF_SDMMC1_CMD_OFFSET		0x0c4
+#define OMAP2430_CONTROL_PADCONF_SDMMC1_DAT0_OFFSET		0x0c5
+#define OMAP2430_CONTROL_PADCONF_SDMMC1_DAT1_OFFSET		0x0c6
+#define OMAP2430_CONTROL_PADCONF_SDMMC1_DAT2_OFFSET		0x0c7
+#define OMAP2430_CONTROL_PADCONF_SDMMC1_DAT3_OFFSET		0x0c8
+#define OMAP2430_CONTROL_PADCONF_SDMMC2_CLKO_OFFSET		0x0c9
+#define OMAP2430_CONTROL_PADCONF_SDMMC2_DAT3_OFFSET		0x0ca
+#define OMAP2430_CONTROL_PADCONF_SDMMC2_CMD_OFFSET		0x0cb
+#define OMAP2430_CONTROL_PADCONF_SDMMC2_DAT0_OFFSET		0x0cc
+#define OMAP2430_CONTROL_PADCONF_SDMMC2_DAT2_OFFSET		0x0cd
+#define OMAP2430_CONTROL_PADCONF_SDMMC2_DAT1_OFFSET		0x0ce
+#define OMAP2430_CONTROL_PADCONF_UART2_CTS_OFFSET		0x0cf
+#define OMAP2430_CONTROL_PADCONF_UART2_RTS_OFFSET		0x0d0
+#define OMAP2430_CONTROL_PADCONF_UART2_TX_OFFSET		0x0d1
+#define OMAP2430_CONTROL_PADCONF_UART2_RX_OFFSET		0x0d2
+#define OMAP2430_CONTROL_PADCONF_MCBSP3_CLKX_OFFSET		0x0d3
+#define OMAP2430_CONTROL_PADCONF_MCBSP3_FSX_OFFSET		0x0d4
+#define OMAP2430_CONTROL_PADCONF_MCBSP3_DR_OFFSET		0x0d5
+#define OMAP2430_CONTROL_PADCONF_MCBSP3_DX_OFFSET		0x0d6
+#define OMAP2430_CONTROL_PADCONF_SSI1_DAT_TX_OFFSET		0x0d7
+#define OMAP2430_CONTROL_PADCONF_SSI1_FLAG_TX_OFFSET		0x0d8
+#define OMAP2430_CONTROL_PADCONF_SSI1_RDY_TX_OFFSET		0x0d9
+#define OMAP2430_CONTROL_PADCONF_SSI1_DAT_RX_OFFSET		0x0da
+#define OMAP2430_CONTROL_PADCONF_GPIO_63_OFFSET			0x0db
+#define OMAP2430_CONTROL_PADCONF_SSI1_FLAG_RX_OFFSET		0x0dc
+#define OMAP2430_CONTROL_PADCONF_SSI1_RDY_RX_OFFSET		0x0dd
+#define OMAP2430_CONTROL_PADCONF_SSI1_WAKE_OFFSET		0x0de
+#define OMAP2430_CONTROL_PADCONF_SPI1_CLK_OFFSET		0x0df
+#define OMAP2430_CONTROL_PADCONF_SPI1_SIMO_OFFSET		0x0e0
+#define OMAP2430_CONTROL_PADCONF_SPI1_SOMI_OFFSET		0x0e1
+#define OMAP2430_CONTROL_PADCONF_SPI1_CS0_OFFSET		0x0e2
+#define OMAP2430_CONTROL_PADCONF_SPI1_CS1_OFFSET		0x0e3
+#define OMAP2430_CONTROL_PADCONF_SPI1_CS2_OFFSET		0x0e4
+#define OMAP2430_CONTROL_PADCONF_SPI1_CS3_OFFSET		0x0e5
+#define OMAP2430_CONTROL_PADCONF_SPI2_CLK_OFFSET		0x0e6
+#define OMAP2430_CONTROL_PADCONF_SPI2_SIMO_OFFSET		0x0e7
+#define OMAP2430_CONTROL_PADCONF_SPI2_SOMI_OFFSET		0x0e8
+#define OMAP2430_CONTROL_PADCONF_SPI2_CS0_OFFSET		0x0e9
+#define OMAP2430_CONTROL_PADCONF_MCBSP1_CLKR_OFFSET		0x0ea
+#define OMAP2430_CONTROL_PADCONF_MCBSP1_FSR_OFFSET		0x0eb
+#define OMAP2430_CONTROL_PADCONF_MCBSP1_DX_OFFSET		0x0ec
+#define OMAP2430_CONTROL_PADCONF_MCBSP1_DR_OFFSET		0x0ed
+#define OMAP2430_CONTROL_PADCONF_MCBSP_CLKS_OFFSET		0x0ee
+#define OMAP2430_CONTROL_PADCONF_MCBSP1_FSX_OFFSET		0x0ef
+#define OMAP2430_CONTROL_PADCONF_MCBSP1_CLKX_OFFSET		0x0f0
+#define OMAP2430_CONTROL_PADCONF_I2C1_SCL_OFFSET		0x0f1
+#define OMAP2430_CONTROL_PADCONF_I2C1_SDA_OFFSET		0x0f2
+#define OMAP2430_CONTROL_PADCONF_I2C2_SCL_OFFSET		0x0f3
+#define OMAP2430_CONTROL_PADCONF_I2C2_SDA_OFFSET		0x0f4
+#define OMAP2430_CONTROL_PADCONF_HDQ_SIO_OFFSET			0x0f5
+#define OMAP2430_CONTROL_PADCONF_UART3_CTS_RCTX_OFFSET		0x0f6
+#define OMAP2430_CONTROL_PADCONF_UART3_RTS_SD_OFFSET		0x0f7
+#define OMAP2430_CONTROL_PADCONF_UART3_TX_IRTX_OFFSET		0x0f8
+#define OMAP2430_CONTROL_PADCONF_UART3_RX_IRRX_OFFSET		0x0f9
+#define OMAP2430_CONTROL_PADCONF_GPIO_7_OFFSET			0x0fa
+#define OMAP2430_CONTROL_PADCONF_GPIO_78_OFFSET			0x0fb
+#define OMAP2430_CONTROL_PADCONF_GPIO_79_OFFSET			0x0fc
+#define OMAP2430_CONTROL_PADCONF_GPIO_80_OFFSET			0x0fd
+#define OMAP2430_CONTROL_PADCONF_GPIO_113_OFFSET		0x0fe
+#define OMAP2430_CONTROL_PADCONF_GPIO_114_OFFSET		0x0ff
+#define OMAP2430_CONTROL_PADCONF_GPIO_115_OFFSET		0x100
+#define OMAP2430_CONTROL_PADCONF_GPIO_116_OFFSET		0x101
+#define OMAP2430_CONTROL_PADCONF_SYS_DRM_MSECURE_OFFSET		0x102
+#define OMAP2430_CONTROL_PADCONF_USB0HS_DATA3_OFFSET		0x103
+#define OMAP2430_CONTROL_PADCONF_USB0HS_DATA4_OFFSET		0x104
+#define OMAP2430_CONTROL_PADCONF_USB0HS_DATA5_OFFSET		0x105
+#define OMAP2430_CONTROL_PADCONF_USB0HS_DATA6_OFFSET		0x106
+#define OMAP2430_CONTROL_PADCONF_USB0HS_DATA2_OFFSET		0x107
+#define OMAP2430_CONTROL_PADCONF_USB0HS_DATA0_OFFSET		0x108
+#define OMAP2430_CONTROL_PADCONF_USB0HS_DATA1_OFFSET		0x109
+#define OMAP2430_CONTROL_PADCONF_USB0HS_CLK_OFFSET		0x10a
+#define OMAP2430_CONTROL_PADCONF_USB0HS_DIR_OFFSET		0x10b
+#define OMAP2430_CONTROL_PADCONF_USB0HS_STP_OFFSET		0x10c
+#define OMAP2430_CONTROL_PADCONF_USB0HS_NXT_OFFSET		0x10d
+#define OMAP2430_CONTROL_PADCONF_USB0HS_DATA7_OFFSET		0x10e
+#define OMAP2430_CONTROL_PADCONF_TV_OUT_OFFSET			0x10f
+#define OMAP2430_CONTROL_PADCONF_TV_VREF_OFFSET			0x110
+#define OMAP2430_CONTROL_PADCONF_TV_RSET_OFFSET			0x111
+#define OMAP2430_CONTROL_PADCONF_TV_VFB_OFFSET			0x112
+#define OMAP2430_CONTROL_PADCONF_TV_DACOUT_OFFSET		0x113
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD0_OFFSET		0x114
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD1_OFFSET		0x115
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD2_OFFSET		0x116
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD3_OFFSET		0x117
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD4_OFFSET		0x118
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD5_OFFSET		0x119
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD6_OFFSET		0x11a
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD7_OFFSET		0x11b
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD8_OFFSET		0x11c
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD9_OFFSET		0x11d
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD10_OFFSET		0x11e
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD11_OFFSET		0x11f
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD12_OFFSET		0x120
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD13_OFFSET		0x121
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD14_OFFSET		0x122
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD15_OFFSET		0x123
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD16_OFFSET		0x124
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD17_OFFSET		0x125
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD18_OFFSET		0x126
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD19_OFFSET		0x127
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD20_OFFSET		0x128
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD21_OFFSET		0x129
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD22_OFFSET		0x12a
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD23_OFFSET		0x12b
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD24_OFFSET		0x12c
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD25_OFFSET		0x12d
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD26_OFFSET		0x12e
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD27_OFFSET		0x12f
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD28_OFFSET		0x130
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD29_OFFSET		0x131
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD30_OFFSET		0x132
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD31_OFFSET		0x133
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD32_OFFSET		0x134
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD33_OFFSET		0x135
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD34_OFFSET		0x136
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD35_OFFSET		0x137
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD36_OFFSET		0x138
+#define OMAP2430_CONTROL_PADCONF_AD2DMCAD37_OFFSET		0x139
+#define OMAP2430_CONTROL_PADCONF_AD2DMWRITE_OFFSET		0x13a
+#define OMAP2430_CONTROL_PADCONF_D2DCLK26MI_OFFSET		0x13b
+#define OMAP2430_CONTROL_PADCONF_D2DNRESPWRON1_OFFSET		0x13c
+#define OMAP2430_CONTROL_PADCONF_D2DNRESWARM_OFFSET		0x13d
+#define OMAP2430_CONTROL_PADCONF_D2DARM9NIRQ_OFFSET		0x13e
+#define OMAP2430_CONTROL_PADCONF_D2DUMA2P6FIQ_OFFSET		0x13f
+#define OMAP2430_CONTROL_PADCONF_D2DSPINT_OFFSET		0x140
+#define OMAP2430_CONTROL_PADCONF_D2DFRINT_OFFSET		0x141
+#define OMAP2430_CONTROL_PADCONF_D2DDMAREQ0_OFFSET		0x142
+#define OMAP2430_CONTROL_PADCONF_D2DDMAREQ1_OFFSET		0x143
+#define OMAP2430_CONTROL_PADCONF_D2DDMAREQ2_OFFSET		0x144
+#define OMAP2430_CONTROL_PADCONF_D2DDMAREQ3_OFFSET		0x145
+#define OMAP2430_CONTROL_PADCONF_D2DN3GTRST_OFFSET		0x146
+#define OMAP2430_CONTROL_PADCONF_D2DN3GTDI_OFFSET		0x147
+#define OMAP2430_CONTROL_PADCONF_D2DN3GTDO_OFFSET		0x148
+#define OMAP2430_CONTROL_PADCONF_D2DN3GTMS_OFFSET		0x149
+#define OMAP2430_CONTROL_PADCONF_D2DN3GTCK_OFFSET		0x14a
+#define OMAP2430_CONTROL_PADCONF_D2DN3GRTCK_OFFSET		0x14b
+#define OMAP2430_CONTROL_PADCONF_D2DMSTDBY_OFFSET		0x14c
+#define OMAP2430_CONTROL_PADCONF_AD2DSREAD_OFFSET		0x14d
+#define OMAP2430_CONTROL_PADCONF_D2DSWAKEUP_OFFSET		0x14e
+#define OMAP2430_CONTROL_PADCONF_D2DIDLEREQ_OFFSET		0x14f
+#define OMAP2430_CONTROL_PADCONF_D2DIDLEACK_OFFSET		0x150
+#define OMAP2430_CONTROL_PADCONF_D2DSPARE0_OFFSET		0x151
+#define OMAP2430_CONTROL_PADCONF_AD2DSWRITE_OFFSET		0x152
+#define OMAP2430_CONTROL_PADCONF_AD2DMREAD_OFFSET		0x153
+
+#define OMAP2430_CONTROL_PADCONF_MUX_SIZE			\
+		(OMAP2430_CONTROL_PADCONF_AD2DMREAD_OFFSET + 0x1)
+
+/**
+ * omap2430_mux_init() - initialize mux system with board specific set
+ * @board_mux:		Board specific mux table
+ * @flags:		OMAP package type used for the board
+ */
+int omap2430_mux_init(struct omap_board_mux *board_mux, int flags);
diff --git a/arch/arm/plat-omap/include/plat/omap-serial.h b/arch/arm/plat-omap/include/plat/omap-serial.h
index c54c52e..94f72cd 100644
--- a/arch/arm/plat-omap/include/plat/omap-serial.h
+++ b/arch/arm/plat-omap/include/plat/omap-serial.h
@@ -31,6 +31,12 @@
 #define UART_MODULE_BASE(uart_no)	 (UART1 == uart_no ? IO_ADDRESS(OMAP_UART1_BASE) :\
 		                                 ( UART2 == uart_no ? IO_ADDRESS(OMAP_UART2_BASE) :\
 					         IO_ADDRESS(OMAP_UART3_BASE) ))
+
+#define OMAP_MDR1_DISABLE	0x07
+#define OMAP_MDR1_MODE13X	0x03
+#define OMAP_MDR1_MODE16X	0x00
+#define OMAP_MODE13X_SPEED	230400
+
 extern unsigned int fcr[MAX_UARTS];
 #endif /* __OMAP_SERIAL_H__ */
 
diff --git a/arch/arm/plat-omap/include/plat/serial.h b/arch/arm/plat-omap/include/plat/serial.h
index 785fc4a..f70e2b0 100644
--- a/arch/arm/plat-omap/include/plat/serial.h
+++ b/arch/arm/plat-omap/include/plat/serial.h
@@ -43,8 +43,7 @@
 
 #ifndef __ASSEMBLER__
 extern void omap_serial_early_init(void);
-extern void omap_serial_init(int wake_gpio_strobe,
-			     unsigned int wake_strobe_enable_mask);
+extern void omap_serial_init(void);
 extern int omap_uart_can_sleep(void);
 extern void omap_uart_check_wakeup(void);
 extern void omap_uart_prepare_suspend(void);
diff --git a/arch/arm/plat-omap/mux.c b/arch/arm/plat-omap/mux.c
index 05aebca..b7b60ac 100644
--- a/arch/arm/plat-omap/mux.c
+++ b/arch/arm/plat-omap/mux.c
@@ -78,6 +78,6 @@ int __init_or_module omap_cfg_reg(const unsigned long index)
 }
 EXPORT_SYMBOL(omap_cfg_reg);
 #else
-#define omap_mux_init() do {} while(0)
+#define omap_mux_init(a, b, c, d, e, f) do {} while(0)
 #define omap_cfg_reg(x)	do {} while(0)
 #endif	/* CONFIG_OMAP_MUX */
diff --git a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
index ee98b1b..360504a 100644
--- a/drivers/input/keyboard/Kconfig
+++ b/drivers/input/keyboard/Kconfig
@@ -423,4 +423,10 @@ config KEYBOARD_W90P910
 	  To compile this driver as a module, choose M here: the
 	  module will be called w90p910_keypad.
 
+config KEYBOARD_TSC2301
+	tristate "TSC2301 keypad support"
+	depends on SPI_TSC2301
+	help
+	  Say Y here for if you are using the keypad features of TSC2301.
+
 endif
diff --git a/drivers/input/keyboard/Makefile b/drivers/input/keyboard/Makefile
index babad5e..a2f2dc0 100644
--- a/drivers/input/keyboard/Makefile
+++ b/drivers/input/keyboard/Makefile
@@ -37,3 +37,5 @@ obj-$(CONFIG_KEYBOARD_TOSA)		+= tosakbd.o
 obj-$(CONFIG_KEYBOARD_TWL4030)		+= twl4030_keypad.o
 obj-$(CONFIG_KEYBOARD_XTKBD)		+= xtkbd.o
 obj-$(CONFIG_KEYBOARD_W90P910)		+= w90p910_keypad.o
+obj-$(CONFIG_KEYBOARD_TSC2301)		+= tsc2301_kp.o
+
diff --git a/drivers/input/keyboard/tsc2301_kp.c b/drivers/input/keyboard/tsc2301_kp.c
new file mode 100644
index 0000000..0f2cb7f
--- /dev/null
+++ b/drivers/input/keyboard/tsc2301_kp.c
@@ -0,0 +1,475 @@
+/*
+ * TSC2301 keypad driver
+ *
+ * Copyright (C) 2005-2006 Nokia Corporation
+ *
+ * Written by Jarkko Oikarinen
+ * Rewritten by Juha Yrjola <juha.yrjola@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+
+#include <linux/spi/tsc2301.h>
+
+#define TSC2301_KEYBOARD_PRODUCT_ID      0x0051
+#define TSC2301_KEYBOARD_PRODUCT_VERSION 0x0001
+#define TSC2301_DEBOUNCE_TIME_2MS        0x0000
+#define TSC2301_DEBOUNCE_TIME_10MS       0x0800
+#define TSC2301_DEBOUNCE_TIME_20MS       0x1000
+#define TSC2301_DEBOUNCE_TIME_50MS       0x1800
+#define TSC2301_DEBOUNCE_TIME_60MS       0x2000
+#define TSC2301_DEBOUNCE_TIME_80MS       0x2800
+#define TSC2301_DEBOUNCE_TIME_100MS      0x3000
+#define TSC2301_DEBOUNCE_TIME_120MS      0x3800
+
+#define TSC2301_DEBOUNCE_TIME		TSC2301_DEBOUNCE_TIME_20MS
+
+#define TSC2301_RELEASE_TIMEOUT		50
+
+struct tsc2301_kp {
+	struct input_dev	*idev;
+	char			phys[32];
+	spinlock_t		lock;
+	struct mutex		mutex;
+	struct timer_list	timer;
+	u16			keys_pressed;
+	unsigned		pending:1;
+	unsigned		user_disabled:1;
+	unsigned		disable_depth;
+
+	struct spi_transfer	read_xfer[4];
+	struct spi_message	read_msg;
+
+	u16			data;
+	u16			mask;
+
+	int			irq;
+	s16			keymap[16];
+};
+
+static inline int tsc2301_kp_disabled(struct tsc2301 *tsc)
+{
+	return tsc->kp->disable_depth != 0;
+}
+
+static void tsc2301_kp_send_key_events(struct tsc2301 *tsc,
+				       u16 prev_state,
+				       u16 new_state)
+{
+	struct tsc2301_kp *kp = tsc->kp;
+	u16 common, released, pressed;
+	int i;
+
+	common = prev_state & new_state;
+	released = common ^ prev_state;
+	pressed = common ^ new_state;
+	if (!released && !pressed)
+		return;
+	for (i = 0; i < 16 && (released || pressed); i++) {
+		if (released & 1) {
+			dev_dbg(&tsc->spi->dev, "key %d released\n", i);
+			input_report_key(kp->idev, kp->keymap[i], 0);
+		}
+		released >>= 1;
+		if (pressed & 1) {
+			dev_dbg(&tsc->spi->dev, "key %d pressed\n", i);
+			input_report_key(kp->idev, kp->keymap[i], 1);
+		}
+		pressed >>= 1;
+	}
+	input_sync(kp->idev);
+}
+
+static inline void _filter_out(struct tsc2301 *tsc, u16 prev_state,
+			       u16 *new_state, int row1, int row2, u8 rect_pat)
+{
+	u16 mask;
+
+	mask = (rect_pat << (row1 * 4)) | (rect_pat << (row2 * 4));
+	mask &= ~prev_state;
+	*new_state &= ~mask;
+	dev_dbg(&tsc->spi->dev, "filtering ghost keys %02x\n", mask);
+}
+
+static void tsc2301_filter_ghost_keys(struct tsc2301 *tsc, u16 prev_state,
+				      u16 *new_state)
+{
+	int row1, row2;
+	u16 key_map;
+	u16 row1_map;
+	static const u8 rect_pat[] = {
+		0x3, 0x5, 0x9, 0x6, 0xa, 0xc, 0,
+	};
+
+	key_map = *new_state;
+	for (row1 = 0; row1 < 4; row1++) {
+		row1_map = (key_map >> (row1 * 4)) & 0xf;
+		if (!row1_map)
+			continue;
+		for (row2 = row1 + 1; row2 < 4; row2++) {
+			u16 rect_map = (key_map >> (row2 * 4)) & 0xf;
+			const u8 *rp;
+
+			rect_map &= row1_map;
+			if (!rect_map)
+				continue;
+			for (rp = rect_pat; *rp; rp++)
+				if ((rect_map & *rp) == *rp)
+					_filter_out(tsc, prev_state, new_state,
+						    row1, row2, *rp);
+		}
+	}
+}
+
+static void tsc2301_kp_timer(unsigned long arg)
+{
+	struct tsc2301 *tsc = (void *) arg;
+	struct tsc2301_kp *kp = tsc->kp;
+	unsigned long flags;
+
+	tsc2301_kp_send_key_events(tsc, kp->keys_pressed, 0);
+	spin_lock_irqsave(&kp->lock, flags);
+	kp->keys_pressed = 0;
+	spin_unlock_irqrestore(&kp->lock, flags);
+}
+
+static void tsc2301_kp_rx(void *arg)
+{
+	struct tsc2301 *tsc = arg;
+	struct tsc2301_kp *kp = tsc->kp;
+	unsigned long flags;
+	u16 kp_data;
+
+	kp_data = kp->data;
+	dev_dbg(&tsc->spi->dev, "KP data %04x\n", kp_data);
+
+	tsc2301_filter_ghost_keys(tsc, kp->keys_pressed, &kp_data);
+	tsc2301_kp_send_key_events(tsc, kp->keys_pressed, kp_data);
+	spin_lock_irqsave(&kp->lock, flags);
+	kp->keys_pressed = kp_data;
+	kp->pending = 0;
+	spin_unlock_irqrestore(&kp->lock, flags);
+}
+
+static irqreturn_t tsc2301_kp_irq_handler(int irq, void *dev_id)
+{
+	struct tsc2301 *tsc = dev_id;
+	struct tsc2301_kp *kp = tsc->kp;
+	unsigned long flags;
+	int r;
+
+	spin_lock_irqsave(&kp->lock, flags);
+	if (tsc2301_kp_disabled(tsc)) {
+		spin_unlock_irqrestore(&kp->lock, flags);
+		return IRQ_HANDLED;
+	}
+	kp->pending = 1;
+	spin_unlock_irqrestore(&kp->lock, flags);
+	mod_timer(&kp->timer,
+		 jiffies + msecs_to_jiffies(TSC2301_RELEASE_TIMEOUT));
+	r = spi_async(tsc->spi, &tsc->kp->read_msg);
+	if (r)
+		dev_err(&tsc->spi->dev, "kp: spi_async() failed");
+	return IRQ_HANDLED;
+}
+
+static void tsc2301_kp_start_scan(struct tsc2301 *tsc)
+{
+	tsc2301_write_reg(tsc, TSC2301_REG_KPMASK, tsc->kp->mask);
+	tsc2301_write_reg(tsc, TSC2301_REG_KEY, TSC2301_DEBOUNCE_TIME);
+}
+
+static void tsc2301_kp_stop_scan(struct tsc2301 *tsc)
+{
+	tsc2301_write_reg(tsc, TSC2301_REG_KEY, 1 << 14);
+}
+
+/* Must be called with the mutex held */
+static void tsc2301_kp_enable(struct tsc2301 *tsc)
+{
+	struct tsc2301_kp *kp = tsc->kp;
+	unsigned long flags;
+
+	spin_lock_irqsave(&kp->lock, flags);
+	BUG_ON(!tsc2301_kp_disabled(tsc));
+	if (--kp->disable_depth != 0) {
+		spin_unlock_irqrestore(&kp->lock, flags);
+		return;
+	}
+	spin_unlock_irqrestore(&kp->lock, flags);
+
+	set_irq_type(kp->irq, IRQ_TYPE_EDGE_FALLING);
+	tsc2301_kp_start_scan(tsc);
+	enable_irq(kp->irq);
+}
+
+/* Must be called with the mutex held */
+static int tsc2301_kp_disable(struct tsc2301 *tsc, int release_keys)
+{
+	struct tsc2301_kp *kp = tsc->kp;
+	unsigned long flags;
+
+	spin_lock_irqsave(&kp->lock, flags);
+	if (kp->disable_depth++ != 0) {
+		spin_unlock_irqrestore(&kp->lock, flags);
+		goto out;
+	}
+	disable_irq_nosync(kp->irq);
+	set_irq_type(kp->irq, IRQ_TYPE_NONE);
+	spin_unlock_irqrestore(&kp->lock, flags);
+
+	while (kp->pending) {
+		msleep(1);
+	}
+
+	tsc2301_kp_stop_scan(tsc);
+out:
+	if (!release_keys)
+		del_timer(&kp->timer); /* let timeout release keys */
+
+	return 0;
+}
+
+/* The following workaround is needed for a HW bug triggered by the
+ * following:
+ * 1. keep any key pressed
+ * 2. disable keypad
+ * 3. release all keys
+ * 4. reenable keypad
+ * 5. disable touch screen controller
+ *
+ * After this the keypad scanner will get stuck in busy state and won't
+ * report any interrupts for further keypresses. One way to recover is to
+ * restart the keypad scanner whenever we enable / disable the
+ * touchscreen controller.
+ */
+void tsc2301_kp_restart(struct tsc2301 *tsc)
+{
+	if (!tsc2301_kp_disabled(tsc)) {
+		tsc2301_kp_start_scan(tsc);
+	}
+}
+
+static ssize_t tsc2301_kp_disable_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct tsc2301		*tsc = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", tsc2301_kp_disabled(tsc) ? 1 : 0);
+}
+
+static ssize_t tsc2301_kp_disable_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct tsc2301		*tsc = dev_get_drvdata(dev);
+	struct tsc2301_kp	*kp = tsc->kp;
+	char *endp;
+	int i;
+
+	i = simple_strtoul(buf, &endp, 10);
+	i = i ? 1 : 0;
+
+	mutex_lock(&kp->mutex);
+	if (i == kp->user_disabled) {
+		mutex_unlock(&kp->mutex);
+		return count;
+	}
+	kp->user_disabled = i;
+
+	if (i)
+		tsc2301_kp_disable(tsc, 1);
+	else
+		tsc2301_kp_enable(tsc);
+	mutex_unlock(&kp->mutex);
+
+	return count;
+}
+
+static DEVICE_ATTR(disable_kp, 0664, tsc2301_kp_disable_show,
+		   tsc2301_kp_disable_store);
+
+static const u16 tsc2301_kp_read_data = 0x8000 | TSC2301_REG_KPDATA;
+
+static void tsc2301_kp_setup_spi_xfer(struct tsc2301 *tsc)
+{
+	struct tsc2301_kp *kp = tsc->kp;
+	struct spi_message *m = &kp->read_msg;
+	struct spi_transfer *x = &kp->read_xfer[0];
+
+	spi_message_init(&kp->read_msg);
+
+	x->tx_buf = &tsc2301_kp_read_data;
+	x->len = 2;
+	spi_message_add_tail(x, m);
+	x++;
+
+	x->rx_buf = &kp->data;
+	x->len = 2;
+	spi_message_add_tail(x, m);
+
+	m->complete = tsc2301_kp_rx;
+	m->context = tsc;
+}
+
+#ifdef CONFIG_PM
+int tsc2301_kp_suspend(struct tsc2301 *tsc)
+{
+	struct tsc2301_kp *kp = tsc->kp;
+
+	mutex_lock(&kp->mutex);
+	tsc2301_kp_disable(tsc, 1);
+	mutex_unlock(&kp->mutex);
+	return 0;
+}
+
+void tsc2301_kp_resume(struct tsc2301 *tsc)
+{
+	struct tsc2301_kp *kp = tsc->kp;
+
+	mutex_lock(&kp->mutex);
+	tsc2301_kp_enable(tsc);
+	mutex_unlock(&kp->mutex);
+}
+#endif
+
+int __devinit tsc2301_kp_init(struct tsc2301 *tsc,
+			      struct tsc2301_platform_data *pdata)
+{
+	struct input_dev *idev;
+	struct tsc2301_kp *kp;
+	int r, i;
+	u16 mask;
+
+	if (pdata->keyb_int < 0) {
+		dev_err(&tsc->spi->dev, "need kbirq");
+		return -EINVAL;
+	}
+
+	kp = kzalloc(sizeof(*kp), GFP_KERNEL);
+	if (kp == NULL)
+		return -ENOMEM;
+	tsc->kp = kp;
+
+	kp->irq = pdata->keyb_int;
+	spin_lock_init(&kp->lock);
+	mutex_init(&kp->mutex);
+
+	init_timer(&kp->timer);
+	kp->timer.data = (unsigned long) tsc;
+	kp->timer.function = tsc2301_kp_timer;
+
+	idev = input_allocate_device();
+	if (idev == NULL) {
+		r = -ENOMEM;
+		goto err1;
+	}
+	if (pdata->keyb_name)
+		idev->name = pdata->keyb_name;
+	else
+		idev->name = "TSC2301 keypad";
+	snprintf(kp->phys, sizeof(kp->phys), "%s/input-kp", dev_name(&tsc->spi->dev));
+	idev->phys = kp->phys;
+
+	mask = 0;
+	idev->evbit[0] = BIT(EV_KEY);
+	for (i = 0; i < 16; i++) {
+		if (pdata->keymap[i] > 0) {
+			set_bit(pdata->keymap[i], idev->keybit);
+			kp->keymap[i] = pdata->keymap[i];
+		} else {
+			kp->keymap[i] = -1;
+			mask |= 1 << i;
+		}
+	}
+
+	if (pdata->kp_rep)
+		set_bit(EV_REP, idev->evbit);
+
+	kp->idev = idev;
+
+	tsc2301_kp_setup_spi_xfer(tsc);
+
+	r = device_create_file(&tsc->spi->dev, &dev_attr_disable_kp);
+	if (r < 0)
+		goto err2;
+
+	tsc2301_kp_start_scan(tsc);
+
+	/* IRQ mode 0 is faulty, it can cause the KBIRQ to get stuck.
+	 * Mode 2 deasserts the IRQ at:
+	 * - HW or SW reset
+	 * - Setting SCS flag in REG_KEY register
+	 * - Releasing all keys
+	 * - Reading the REG_KPDATA
+	 */
+	tsc2301_write_kbc(tsc, 2);
+
+	tsc2301_write_reg(tsc, TSC2301_REG_KPMASK, mask);
+	kp->mask = mask;
+
+	set_irq_type(kp->irq, IRQ_TYPE_EDGE_FALLING);
+
+	r = request_irq(kp->irq, tsc2301_kp_irq_handler, IRQF_SAMPLE_RANDOM,
+			"tsc2301-kp", tsc);
+	if (r < 0) {
+		dev_err(&tsc->spi->dev, "unable to get kbirq IRQ");
+		goto err3;
+	}
+	set_irq_wake(kp->irq, 1);
+
+	/* We need to read the register once..? */
+	tsc2301_read_reg(tsc, TSC2301_REG_KPDATA);
+
+	r = input_register_device(idev);
+	if (r < 0) {
+		dev_err(&tsc->spi->dev, "can't register keypad device\n");
+		goto err4;
+	}
+
+	return 0;
+
+err4:
+	free_irq(kp->irq, tsc);
+err3:
+	tsc2301_kp_stop_scan(tsc);
+	device_remove_file(&tsc->spi->dev, &dev_attr_disable_kp);
+err2:
+	input_free_device(kp->idev);
+err1:
+	kfree(kp);
+	return r;
+}
+
+void __devexit tsc2301_kp_exit(struct tsc2301 *tsc)
+{
+	struct tsc2301_kp *kp = tsc->kp;
+
+	tsc2301_kp_disable(tsc, 1);
+	input_unregister_device(kp->idev);
+	free_irq(kp->irq, tsc);
+	device_remove_file(&tsc->spi->dev, &dev_attr_disable_kp);
+
+	kfree(kp);
+}
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 62e21b8..bc25f37 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -537,6 +537,17 @@ config TOUCHSCREEN_PCAP
 	  To compile this driver as a module, choose M here: the
 	  module will be called pcap_ts.
 
+config TOUCHSCREEN_TSC2301
+	tristate "TSC2301 touchscreen support"
+	depends on SPI_TSC2301
+	help
+	  Say Y here for if you are using the touchscreen features of TSC2301.
+
+config TOUCHSCREEN_TSC2005
+	tristate "TSC2005 touchscreen support"
+	help
+	  Say Y here for if you are using the touchscreen features of TSC2005.
+
 config TOUCHSCREEN_QUANTUM_OBP
 	tristate "Quantum OBP based touchscreens"
 	depends on I2C
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index b7176b3..a027f77 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -43,4 +43,6 @@ obj-$(CONFIG_TOUCHSCREEN_WM97XX_ATMEL)	+= atmel-wm97xx.o
 obj-$(CONFIG_TOUCHSCREEN_WM97XX_MAINSTONE)	+= mainstone-wm97xx.o
 obj-$(CONFIG_TOUCHSCREEN_WM97XX_ZYLONITE)	+= zylonite-wm97xx.o
 obj-$(CONFIG_TOUCHSCREEN_W90X900)	+= w90p910_ts.o
+obj-$(CONFIG_TOUCHSCREEN_TSC2301)	+= tsc2301_ts.o
+obj-$(CONFIG_TOUCHSCREEN_TSC2005)	+= tsc2005.o
 obj-$(CONFIG_TOUCHSCREEN_PCAP)		+= pcap_ts.o
diff --git a/drivers/input/touchscreen/tsc2005.c b/drivers/input/touchscreen/tsc2005.c
new file mode 100644
index 0000000..c72157b
--- /dev/null
+++ b/drivers/input/touchscreen/tsc2005.c
@@ -0,0 +1,762 @@
+/*
+ * TSC2005 touchscreen driver
+ *
+ * Copyright (C) 2006-2007 Nokia Corporation
+ *
+ * Author: Lauri Leukkunen <lauri.leukkunen@nokia.com>
+ * based on TSC2301 driver by Klaus K. Pedersen <klaus.k.pedersen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+
+#ifdef CONFIG_ARCH_OMAP
+#include <asm/gpio.h>
+#endif
+
+#include <linux/spi/tsc2005.h>
+
+/**
+ * The touchscreen interface operates as follows:
+ *
+ * Initialize:
+ *    Request access to GPIO103 (DAV)
+ *    tsc2005_dav_irq_handler will trigger when DAV line goes down
+ *
+ *  1) Pen is pressed against touchscreeen
+ *  2) TSC2005 performs AD conversion
+ *  3) After the conversion is done TSC2005 drives DAV line down
+ *  4) GPIO IRQ is received and tsc2005_dav_irq_handler is called
+ *  5) tsc2005_ts_irq_handler queues up an spi transfer to fetch
+ *     the x, y, z1, z2 values
+ *  6) tsc2005_ts_rx() reports coordinates to input layer and
+ *     sets up tsc2005_ts_timer() to be called after TSC2005_TS_SCAN_TIME
+ *  7)  When the penup_timer expires, there have not been DAV interrupts
+ *     during the last 20ms which means the pen has been lifted.
+ */
+
+#define TSC2005_HZ	(14000000)
+
+#define TSC2005_CMD	(0x80)
+#define TSC2005_REG	(0x00)
+
+#define TSC2005_CMD_STOP	(1)
+#define TSC2005_CMD_10BIT	(0 << 2)
+#define TSC2005_CMD_12BIT	(1 << 2)
+
+#define TSC2005_CMD_SCAN_XYZZ	(0 << 3)
+#define TSC2005_CMD_SCAN_XY	(1 << 3)
+#define TSC2005_CMD_SCAN_X	(2 << 3)
+#define TSC2005_CMD_SCAN_Y	(3 << 3)
+#define TSC2005_CMD_SCAN_ZZ	(4 << 3)
+#define TSC2005_CMD_AUX_SINGLE	(5 << 3)
+#define TSC2005_CMD_TEMP1	(6 << 3)
+#define TSC2005_CMD_TEMP2	(7 << 3)
+#define TSC2005_CMD_AUX_CONT	(8 << 3)
+#define TSC2005_CMD_TEST_X_CONN	(9 << 3)
+#define TSC2005_CMD_TEST_Y_CONN	(10 << 3)
+/* command 11 reserved */
+#define TSC2005_CMD_TEST_SHORT	(12 << 3)
+#define TSC2005_CMD_DRIVE_XX	(13 << 3)
+#define TSC2005_CMD_DRIVE_YY	(14 << 3)
+#define TSC2005_CMD_DRIVE_YX	(15 << 3)
+
+#define TSC2005_REG_X		(0 << 3)
+#define TSC2005_REG_Y		(1 << 3)
+#define TSC2005_REG_Z1		(2 << 3)
+#define TSC2005_REG_Z2		(3 << 3)
+#define TSC2005_REG_AUX		(4 << 3)
+#define TSC2005_REG_TEMP1	(5 << 3)
+#define TSC2005_REG_TEMP2	(6 << 3)
+#define TSC2005_REG_STATUS	(7 << 3)
+#define TSC2005_REG_AUX_HIGH	(8 << 3)
+#define TSC2005_REG_AUX_LOW	(9 << 3)
+#define TSC2005_REG_TEMP_HIGH	(10 << 3)
+#define TSC2005_REG_TEMP_LOW	(11 << 3)
+#define TSC2005_REG_CFR0	(12 << 3)
+#define TSC2005_REG_CFR1	(13 << 3)
+#define TSC2005_REG_CFR2	(14 << 3)
+#define TSC2005_REG_FUNCTION	(15 << 3)
+
+#define TSC2005_REG_PND0	(1 << 1)
+#define TSC2005_REG_READ	(0x01)
+#define TSC2005_REG_WRITE	(0x00)
+
+
+#define TSC2005_CFR0_LONGSAMPLING	(1)
+#define TSC2005_CFR0_DETECTINWAIT	(1 << 1)
+#define TSC2005_CFR0_SENSETIME_32US	(0)
+#define TSC2005_CFR0_SENSETIME_96US	(1 << 2)
+#define TSC2005_CFR0_SENSETIME_544US	(1 << 3)
+#define TSC2005_CFR0_SENSETIME_2080US	(1 << 4)
+#define TSC2005_CFR0_SENSETIME_2656US	(0x001C)
+#define TSC2005_CFR0_PRECHARGE_20US	(0x0000)
+#define TSC2005_CFR0_PRECHARGE_84US	(0x0020)
+#define TSC2005_CFR0_PRECHARGE_276US	(0x0040)
+#define TSC2005_CFR0_PRECHARGE_1044US	(0x0080)
+#define TSC2005_CFR0_PRECHARGE_1364US	(0x00E0)
+#define TSC2005_CFR0_STABTIME_0US	(0x0000)
+#define TSC2005_CFR0_STABTIME_100US	(0x0100)
+#define TSC2005_CFR0_STABTIME_500US	(0x0200)
+#define TSC2005_CFR0_STABTIME_1MS	(0x0300)
+#define TSC2005_CFR0_STABTIME_5MS	(0x0400)
+#define TSC2005_CFR0_STABTIME_100MS	(0x0700)
+#define TSC2005_CFR0_CLOCK_4MHZ		(0x0000)
+#define TSC2005_CFR0_CLOCK_2MHZ		(0x0800)
+#define TSC2005_CFR0_CLOCK_1MHZ		(0x1000)
+#define TSC2005_CFR0_RESOLUTION12	(0x2000)
+#define TSC2005_CFR0_STATUS		(0x4000)
+#define TSC2005_CFR0_PENMODE		(0x8000)
+
+#define TSC2005_CFR0_INITVALUE	(TSC2005_CFR0_STABTIME_1MS  |	\
+				 TSC2005_CFR0_CLOCK_1MHZ    |	\
+				 TSC2005_CFR0_RESOLUTION12  |	\
+				 TSC2005_CFR0_PRECHARGE_276US | \
+				 TSC2005_CFR0_PENMODE)
+
+#define TSC2005_CFR1_BATCHDELAY_0MS	(0x0000)
+#define TSC2005_CFR1_BATCHDELAY_1MS	(0x0001)
+#define TSC2005_CFR1_BATCHDELAY_2MS	(0x0002)
+#define TSC2005_CFR1_BATCHDELAY_4MS	(0x0003)
+#define TSC2005_CFR1_BATCHDELAY_10MS	(0x0004)
+#define TSC2005_CFR1_BATCHDELAY_20MS	(0x0005)
+#define TSC2005_CFR1_BATCHDELAY_40MS	(0x0006)
+#define TSC2005_CFR1_BATCHDELAY_100MS	(0x0007)
+
+#define TSC2005_CFR1_INITVALUE	(TSC2005_CFR1_BATCHDELAY_2MS)
+
+#define TSC2005_CFR2_MAVE_TEMP	(0x0001)
+#define TSC2005_CFR2_MAVE_AUX	(0x0002)
+#define TSC2005_CFR2_MAVE_Z	(0x0004)
+#define TSC2005_CFR2_MAVE_Y	(0x0008)
+#define TSC2005_CFR2_MAVE_X	(0x0010)
+#define TSC2005_CFR2_AVG_1	(0x0000)
+#define TSC2005_CFR2_AVG_3	(0x0400)
+#define TSC2005_CFR2_AVG_7	(0x0800)
+#define TSC2005_CFR2_MEDIUM_1	(0x0000)
+#define TSC2005_CFR2_MEDIUM_3	(0x1000)
+#define TSC2005_CFR2_MEDIUM_7	(0x2000)
+#define TSC2005_CFR2_MEDIUM_15	(0x3000)
+
+#define TSC2005_CFR2_IRQ_DAV	(0x4000)
+#define TSC2005_CFR2_IRQ_PEN	(0x8000)
+#define TSC2005_CFR2_IRQ_PENDAV	(0x0000)
+
+#define TSC2005_CFR2_INITVALUE	(TSC2005_CFR2_IRQ_DAV   |	\
+				 TSC2005_CFR2_MAVE_X    |	\
+				 TSC2005_CFR2_MAVE_Y    |	\
+				 TSC2005_CFR2_MAVE_Z    |	\
+				 TSC2005_CFR2_MEDIUM_15 |	\
+				 TSC2005_CFR2_AVG_7)
+
+#define MAX_12BIT					((1 << 12) - 1)
+#define TS_SAMPLES					4
+#define P_SAMPLES					16
+#define TS_RECT_SIZE					8
+#define TSC2005_TS_PENUP_TIME		     		20
+
+static const u32 tsc2005_read_reg[] = {
+	(TSC2005_REG | TSC2005_REG_X | TSC2005_REG_READ) << 16,
+	(TSC2005_REG | TSC2005_REG_Y | TSC2005_REG_READ) << 16,
+	(TSC2005_REG | TSC2005_REG_Z1 | TSC2005_REG_READ) << 16,
+	(TSC2005_REG | TSC2005_REG_Z2 | TSC2005_REG_READ) << 16,
+};
+#define NUM_READ_REGS	(sizeof(tsc2005_read_reg)/sizeof(tsc2005_read_reg[0]))
+
+struct tsc2005 {
+	struct spi_device	*spi;
+
+	struct input_dev	*idev;
+	char			phys[32];
+	struct timer_list	penup_timer;
+	spinlock_t		lock;
+	struct mutex		mutex;
+
+	struct spi_message	read_msg;
+	struct spi_transfer	read_xfer[NUM_READ_REGS];
+	u32                     data[NUM_READ_REGS];
+
+	/* previous x,y,z */
+	int			x;
+	int			y;
+	int			p;
+	/* average accumulators for each component */
+	int			sample_cnt;
+	int 			avg_x;
+	int 			avg_y;
+	int 			p_n;
+	int 			p_buf[P_SAMPLES];
+	/* configuration */
+	int			x_plate_ohm;
+	int			hw_avg_max;
+	int			stab_time;
+	int			p_max;
+	int			touch_pressure;
+	int			irq;
+	s16			dav_gpio;
+	/* status */
+	u8			sample_sent;
+	u8			pen_down;
+	u8			pen_active;
+	u8			disabled;
+	u8			disable_depth;
+	u8			spi_active;
+};
+
+static void tsc2005_cmd(struct tsc2005 *ts, u8 cmd)
+{
+	u16 data = TSC2005_CMD | TSC2005_CMD_12BIT | cmd;
+	struct spi_message msg;
+	struct spi_transfer xfer = { 0 };
+
+	spi_message_init(&msg);
+	msg.spi = ts->spi;
+	xfer.tx_buf = &data;
+	xfer.rx_buf = NULL;
+	xfer.len = 2;
+	xfer.bits_per_word = 8;
+
+	spi_message_add_tail(&xfer, &msg);
+	spi_sync(ts->spi, &msg);
+}
+
+static void tsc2005_write(struct tsc2005 *ts, u8 reg, u16 value)
+{
+	u32 tx;
+	struct spi_message msg;
+	struct spi_transfer xfer = { 0 };
+
+	tx = (TSC2005_REG | reg | TSC2005_REG_PND0 |
+	       TSC2005_REG_WRITE) << (2 * 8);
+	tx |= value;
+
+	spi_message_init(&msg);
+	msg.spi = ts->spi;
+	xfer.tx_buf = &tx;
+	xfer.rx_buf = NULL;
+	xfer.len = 4;
+	xfer.bits_per_word = 3 * 8;
+
+	spi_message_add_tail(&xfer, &msg);
+	spi_sync(ts->spi, &msg);
+}
+
+static void tsc2005_ts_update_pen_state(struct tsc2005 *ts,
+					int x, int y, int pressure)
+{
+	if (pressure) {
+		input_report_abs(ts->idev, ABS_X, x);
+		input_report_abs(ts->idev, ABS_Y, y);
+		input_report_abs(ts->idev, ABS_PRESSURE, pressure);
+		if (!ts->pen_down) {
+			input_report_key(ts->idev, BTN_TOUCH, 1);
+			ts->pen_down = 1;
+		}
+	} else {
+		input_report_abs(ts->idev, ABS_PRESSURE, 0);
+		if (ts->pen_down) {
+			input_report_key(ts->idev, BTN_TOUCH, 0);
+		}
+		ts->pen_down = 0;
+	}
+
+	input_sync(ts->idev);
+}
+
+/*
+ * This function is called by the SPI framework after the coordinates
+ * have been read from TSC2005
+ */
+static void tsc2005_ts_rx(void *arg)
+{
+	struct tsc2005 *ts = arg;
+	unsigned long flags;
+	int inside_rect, pressure_limit;
+	int x, y, z1, z2, pressure;
+	int i;
+
+	spin_lock_irqsave(&ts->lock, flags);
+
+	x = ts->data[0];
+	y = ts->data[1];
+	z1 = ts->data[2];
+	z2 = ts->data[3];
+
+	/* validate position */
+	if (x > MAX_12BIT || y > MAX_12BIT)
+		goto out;
+
+	/* validate pressure */
+	if (z1 < 100 || z1 > 4000 || z2 < z1 || z2 > 4000)
+		goto out;
+	
+	pressure = x * (z2 - z1) / z1;
+	pressure = pressure * ts->x_plate_ohm / 4096;
+	pressure_limit = ts->sample_sent ? ts->p_max : ts->touch_pressure;
+
+	if (pressure > pressure_limit)
+		goto out;
+
+	/* start accumulating average */
+	if (!ts->pen_active) {
+		ts->pen_active = 1;
+		ts->sample_cnt = 0;
+		ts->avg_x = 0;
+		ts->avg_y = 0;
+		ts->p_n = 0;
+		for (i = 0; i < P_SAMPLES; i++)
+			ts->p_buf[i] = 0;
+	}
+
+	ts->avg_x += x;
+	ts->avg_y += y;
+	ts->p_buf[ts->p_n++] = pressure;
+
+	if (ts->p_n >= P_SAMPLES)
+		ts->p_n = 0;
+
+	/* only report the average coords every TS_SAMPLES */
+	if (++ts->sample_cnt < TS_SAMPLES)
+		goto out;
+
+	x = ts->avg_x / TS_SAMPLES;
+	y = ts->avg_y / TS_SAMPLES;
+
+	/* report the max pressure out of a sliding window */
+	for (i = 0; i < P_SAMPLES; i++)
+		if (ts->p_buf[i] && ts->p_buf[i] < pressure)
+			pressure = ts->p_buf[i];
+
+	ts->sample_cnt = 0;
+	ts->avg_x = 0;
+	ts->avg_y = 0;
+
+
+	/* discard the event if it still is within the previous rect - unless
+	 * if the pressure is harder, but then use previous x,y position */
+	inside_rect = (ts->sample_sent &&
+		x > (int)ts->x - TS_RECT_SIZE &&
+		x < (int)ts->x + TS_RECT_SIZE &&
+		y > (int)ts->y - TS_RECT_SIZE &&
+		y < (int)ts->y + TS_RECT_SIZE);
+
+	if (inside_rect)
+		x = ts->x, y = ts->y;
+
+	if (!inside_rect || pressure < ts->p) {
+		tsc2005_ts_update_pen_state(ts, x, y, pressure);
+		ts->sample_sent = 1;
+		ts->x = x;
+		ts->y = y;
+		ts->p = pressure;
+	}
+
+out:
+	ts->spi_active = 0;
+
+	spin_unlock_irqrestore(&ts->lock, flags);
+
+	mod_timer(&ts->penup_timer,
+		  jiffies + msecs_to_jiffies(TSC2005_TS_PENUP_TIME));
+}
+
+static void tsc2005_ts_penup_timer_handler(unsigned long data)
+{
+	struct tsc2005 *ts = (struct tsc2005 *)data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ts->lock, flags);
+
+	/* check if we'll be kicked again => do nothing */
+	if (ts->spi_active) {
+		spin_unlock_irqrestore(&ts->lock, flags);
+		return;
+	}
+
+	if (ts->sample_sent) {
+		tsc2005_ts_update_pen_state(ts, 0, 0, 0);
+		ts->sample_sent = 0;
+	}
+
+	ts->pen_active = 0;
+
+	spin_unlock_irqrestore(&ts->lock, flags);
+}
+
+/*
+ * This interrupt is called when pen is down and coordinates are
+ * available. That is indicated by a falling edge on DAV line.
+ */
+static irqreturn_t tsc2005_ts_irq_handler(int irq, void *dev_id)
+{
+	struct tsc2005 *ts = dev_id;
+
+	spin_lock(&ts->lock);
+
+	/* schedule a new read request only if none pending */
+	if (!ts->spi_active) {
+		if (spi_async(ts->spi, &ts->read_msg))
+			dev_err(&ts->spi->dev, "ts: spi_async() failed");
+		else
+			ts->spi_active = 1;
+	}
+
+	spin_unlock(&ts->lock);
+	return IRQ_HANDLED;
+}
+
+static void tsc2005_ts_setup_spi_xfer(struct tsc2005 *ts)
+{
+	struct spi_message *m = &ts->read_msg;
+	struct spi_transfer *x = &ts->read_xfer[0];
+	int i;
+
+	spi_message_init(m);
+	m->spi = ts->spi;
+
+	for (i = 0; i < NUM_READ_REGS; i++, x++ ) {
+		x->tx_buf = &tsc2005_read_reg[i];
+		x->rx_buf = &ts->data[i];
+		x->len = 4;
+		x->bits_per_word = 24;
+		x->cs_change = i < (NUM_READ_REGS - 1);
+		spi_message_add_tail(x, m);
+	}
+
+	m->complete = tsc2005_ts_rx;
+	m->context = ts;
+}
+
+static ssize_t tsc2005_ts_pen_down_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct tsc2005 *tsc = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", tsc->pen_down);
+}
+
+static DEVICE_ATTR(pen_down, S_IRUGO, tsc2005_ts_pen_down_show, NULL);
+
+static int tsc2005_configure(struct tsc2005 *tsc, int flags)
+{
+	tsc2005_write(tsc, TSC2005_REG_CFR0, TSC2005_CFR0_INITVALUE);
+	tsc2005_write(tsc, TSC2005_REG_CFR1, TSC2005_CFR1_INITVALUE);
+	tsc2005_write(tsc, TSC2005_REG_CFR2, TSC2005_CFR2_INITVALUE);
+	tsc2005_cmd(tsc, flags);
+
+	return 0;
+}
+
+static void tsc2005_start_scan(struct tsc2005 *tsc)
+{
+	tsc2005_configure(tsc, TSC2005_CMD_SCAN_XYZZ);
+}
+
+static void tsc2005_stop_scan(struct tsc2005 *tsc)
+{
+	tsc2005_cmd(tsc, TSC2005_CMD_STOP);
+}
+
+/* Must be called with mutex held */
+static void tsc2005_disable(struct tsc2005 *ts)
+{
+	if (ts->disable_depth++ != 0) {
+		return;
+	}
+	disable_irq(ts->irq);
+
+	/* wait until penup timer expire normally */
+	do {
+		msleep(4);
+	} while (ts->sample_sent);
+
+	tsc2005_stop_scan(ts);
+}
+
+static void tsc2005_enable(struct tsc2005 *ts)
+{
+	if (--ts->disable_depth != 0) {
+		return;
+	}
+	enable_irq(ts->irq);
+
+	tsc2005_start_scan(ts);
+}
+
+static ssize_t tsc2005_disable_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct tsc2005 *ts = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", ts->disabled);
+}
+
+static ssize_t tsc2005_disable_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct tsc2005		*tsc = dev_get_drvdata(dev);
+	char *endp;
+	int i;
+
+	i = simple_strtoul(buf, &endp, 10);
+	i = i ? 1 : 0;
+
+	mutex_lock(&tsc->mutex);
+	if (i == tsc->disabled) goto out;
+	tsc->disabled = i;
+
+	if (i)
+		tsc2005_disable(tsc);
+	else
+		tsc2005_enable(tsc);
+out:
+	mutex_unlock(&tsc->mutex);
+	return count;
+}
+
+static DEVICE_ATTR(disable_ts, 0664, tsc2005_disable_show,
+		   tsc2005_disable_store);
+
+
+static int __devinit tsc2005_ts_init(struct tsc2005 *ts,
+				     struct tsc2005_platform_data *pdata)
+{
+	struct input_dev *idev;
+	int dav_gpio, r;
+	int x_max, y_max;
+	int x_fudge, y_fudge, p_fudge;
+
+	if (pdata->dav_gpio < 0) {
+		dev_err(&ts->spi->dev, "need DAV GPIO");
+		return -EINVAL;
+	}
+	dav_gpio = pdata->dav_gpio;
+	ts->dav_gpio = dav_gpio;
+	dev_dbg(&ts->spi->dev, "TSC2005: DAV GPIO = %d\n", dav_gpio);
+
+#ifdef CONFIG_ARCH_OMAP
+	r = gpio_request(dav_gpio, "FIXME");
+	if (r < 0) {
+		dev_err(&ts->spi->dev, "unable to get DAV GPIO");
+		goto err1;
+	}
+	gpio_direction_output(dav_gpio, 1);
+	ts->irq = OMAP_GPIO_IRQ(dav_gpio);
+	dev_dbg(&ts->spi->dev, "TSC2005: DAV IRQ = %d\n", ts->irq);
+#endif
+	init_timer(&ts->penup_timer);
+	setup_timer(&ts->penup_timer, tsc2005_ts_penup_timer_handler,
+			(unsigned long)ts);
+
+	spin_lock_init(&ts->lock);
+	mutex_init(&ts->mutex);
+
+	ts->x_plate_ohm		= pdata->ts_x_plate_ohm ? : 280;
+	ts->hw_avg_max		= pdata->ts_hw_avg;
+	ts->stab_time		= pdata->ts_stab_time;
+	x_max			= pdata->ts_x_max ? : 4096;
+	x_fudge			= pdata->ts_x_fudge ? : 4;
+	y_max			= pdata->ts_y_max ? : 4096;
+	y_fudge			= pdata->ts_y_fudge ? : 8;
+	ts->p_max		= pdata->ts_pressure_max ? : MAX_12BIT;
+	ts->touch_pressure 	= pdata->ts_touch_pressure ? : ts->p_max;
+	p_fudge			= pdata->ts_pressure_fudge ? : 2;
+
+	idev = input_allocate_device();
+	if (idev == NULL) {
+		r = -ENOMEM;
+		goto err2;
+	}
+
+	/*
+	 * TODO: should be "TSC2005 touchscreen", but X has hardcoded these
+	 * strings and doesn't accept TSC2005 yet...
+	 */
+	idev->name = "TSC2301 touchscreen";
+	snprintf(ts->phys, sizeof(ts->phys), "%s/input-ts",
+		 dev_name(&ts->spi->dev));
+	idev->phys = ts->phys;
+
+	idev->evbit[0] = BIT(EV_ABS) | BIT(EV_KEY);
+	idev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y) | BIT(ABS_PRESSURE);
+	ts->idev = idev;
+
+	tsc2005_ts_setup_spi_xfer(ts);
+
+	input_set_abs_params(idev, ABS_X, 0, x_max, x_fudge, 0);
+	input_set_abs_params(idev, ABS_Y, 0, y_max, y_fudge, 0);
+	input_set_abs_params(idev, ABS_PRESSURE, 0, ts->p_max, p_fudge, 0);
+
+	tsc2005_start_scan(ts);
+
+	r = request_irq(ts->irq, tsc2005_ts_irq_handler,
+			IRQF_TRIGGER_FALLING | IRQF_DISABLED |
+			IRQF_SAMPLE_RANDOM, "tsc2005", ts);
+	if (r < 0) {
+		dev_err(&ts->spi->dev, "unable to get DAV IRQ");
+		goto err3;
+	}
+
+	set_irq_wake(ts->irq, 1);
+
+	r = input_register_device(idev);
+	if (r < 0) {
+		dev_err(&ts->spi->dev, "can't register touchscreen device\n");
+		goto err4;
+	}
+
+	/* We can tolerate these failing */
+	if (device_create_file(&ts->spi->dev, &dev_attr_pen_down));
+	if (device_create_file(&ts->spi->dev, &dev_attr_disable_ts));
+
+	return 0;
+err4:
+	free_irq(ts->irq, ts);
+err3:
+	tsc2005_stop_scan(ts);
+	input_free_device(idev);
+err2:
+#ifdef CONFIG_ARCH_OMAP
+	gpio_free(dav_gpio);
+#endif
+err1:
+	return r;
+}
+
+static int __devinit tsc2005_probe(struct spi_device *spi)
+{
+	struct tsc2005			*tsc;
+	struct tsc2005_platform_data	*pdata = spi->dev.platform_data;
+	int r;
+
+	if (!pdata) {
+		dev_dbg(&spi->dev, "no platform data?\n");
+		return -ENODEV;
+	}
+
+	tsc = kzalloc(sizeof(*tsc), GFP_KERNEL);
+	if (tsc == NULL)
+		return -ENOMEM;
+
+	dev_set_drvdata(&spi->dev, tsc);
+	tsc->spi = spi;
+	spi->dev.power.power_state = PMSG_ON;
+
+	spi->mode = SPI_MODE_0;
+	spi->bits_per_word = 8;
+	/* The max speed might've been defined by the board-specific
+	 * struct */
+	if (!spi->max_speed_hz)
+		spi->max_speed_hz = TSC2005_HZ;
+
+	spi_setup(spi);
+
+	r = tsc2005_ts_init(tsc, pdata);
+	if (r)
+		goto err1;
+
+	return 0;
+
+err1:
+	kfree(tsc);
+	return r;
+}
+
+static int __devexit tsc2005_remove(struct spi_device *spi)
+{
+	struct tsc2005 *ts = dev_get_drvdata(&spi->dev);
+	unsigned long flags;
+
+	spin_lock_irqsave(&ts->lock, flags);
+	tsc2005_disable(ts);
+	spin_unlock_irqrestore(&ts->lock, flags);
+
+	device_remove_file(&ts->spi->dev, &dev_attr_disable_ts);
+	device_remove_file(&ts->spi->dev, &dev_attr_pen_down);
+
+	free_irq(ts->irq, ts);
+	input_unregister_device(ts->idev);
+
+#ifdef CONFIG_ARCH_OMAP
+	gpio_free(ts->dav_gpio);
+#endif
+	kfree(ts);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int tsc2005_suspend(struct spi_device *spi, pm_message_t mesg)
+{
+	struct tsc2005 *ts = dev_get_drvdata(&spi->dev);
+
+	mutex_lock(&ts->mutex);
+	tsc2005_disable(ts);
+	mutex_unlock(&ts->mutex);
+
+	return 0;
+}
+
+static int tsc2005_resume(struct spi_device *spi)
+{
+	struct tsc2005 *ts = dev_get_drvdata(&spi->dev);
+
+	mutex_lock(&ts->mutex);
+	tsc2005_enable(ts);
+	mutex_unlock(&ts->mutex);
+
+	return 0;
+}
+#endif
+
+static struct spi_driver tsc2005_driver = {
+	.driver = {
+		.name = "tsc2005",
+		.bus = &spi_bus_type,
+		.owner = THIS_MODULE,
+	},
+#ifdef CONFIG_PM
+	.suspend = tsc2005_suspend,
+	.resume = tsc2005_resume,
+#endif
+	.probe = tsc2005_probe,
+	.remove = __devexit_p(tsc2005_remove),
+};
+
+static int __init tsc2005_init(void)
+{
+	printk("TSC2005 driver initializing\n");
+
+	return spi_register_driver(&tsc2005_driver);
+}
+module_init(tsc2005_init);
+
+static void __exit tsc2005_exit(void)
+{
+	spi_unregister_driver(&tsc2005_driver);
+}
+module_exit(tsc2005_exit);
+
+MODULE_AUTHOR("Lauri Leukkunen <lauri.leukkunen@nokia.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/tsc2301_ts.c b/drivers/input/touchscreen/tsc2301_ts.c
new file mode 100644
index 0000000..8ab6fa3
--- /dev/null
+++ b/drivers/input/touchscreen/tsc2301_ts.c
@@ -0,0 +1,675 @@
+/*
+ * TSC2301 touchscreen driver
+ *
+ * Copyright (C) 2005-2008 Nokia Corporation
+ *
+ * Written by Jarkko Oikarinen, Imre Deak and Juha Yrjola
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+
+#include <linux/spi/tsc2301.h>
+
+/**
+ * The touchscreen interface operates as follows:
+ *
+ * Initialize:
+ *    Request access to GPIO103 (DAV)
+ *    tsc2301_ts_irq_handler will trigger when DAV line goes down
+ *
+ *  1) Pen is pressed against touchscreeen
+ *  2) TSC2301 performs AD conversion
+ *  3) After the conversion is done TSC2301 drives DAV line down
+ *  4) GPIO IRQ is received and tsc2301_ts_irq_handler is called
+ *  5) tsc2301_ts_irq_handler queues up an spi transfer to fetch
+ *     the x, y, z1, z2 values
+ *  6) SPI framework calls tsc2301_ts_rx after the coordinates are read
+ *  7) When the penup_timer expires, there have not been DAV interrupts
+ *     during the last 20ms which means the pen has been lifted.
+ */
+
+
+#define TSC2301_TOUCHSCREEN_PRODUCT_ID      		0x0052
+#define TSC2301_TOUCHSCREEN_PRODUCT_VERSION 		0x0001
+
+#define TSC2301_TS_PENUP_TIME		     		20
+
+#define TSC2301_ADCREG_CONVERSION_CTRL_BY_TSC2301	0x8000
+#define TSC2301_ADCREG_CONVERSION_CTRL_BY_HOST		0x0000
+
+#define TSC2301_ADCREG_FUNCTION_NONE			0x0000
+#define TSC2301_ADCREG_FUNCTION_XY			0x0400
+#define TSC2301_ADCREG_FUNCTION_XYZ			0x0800
+#define TSC2301_ADCREG_FUNCTION_X			0x0C00
+#define TSC2301_ADCREG_FUNCTION_Y			0x1000
+#define TSC2301_ADCREG_FUNCTION_Z			0x1400
+#define TSC2301_ADCREG_FUNCTION_DAT1			0x1800
+#define TSC2301_ADCREG_FUNCTION_DAT2			0x1C00
+#define TSC2301_ADCREG_FUNCTION_AUX1			0x2000
+#define TSC2301_ADCREG_FUNCTION_AUX2			0x2400
+#define TSC2301_ADCREG_FUNCTION_TEMP			0x2800
+
+#define TSC2301_ADCREG_RESOLUTION_8BIT			0x0100
+#define TSC2301_ADCREG_RESOLUTION_10BIT			0x0200
+#define TSC2301_ADCREG_RESOLUTION_12BIT			0x0300
+
+#define TSC2301_ADCREG_AVERAGING_NONE			0x0000
+#define TSC2301_ADCREG_AVERAGING_4AVG			0x0040
+#define TSC2301_ADCREG_AVERAGING_8AVG			0x0080
+#define TSC2301_ADCREG_AVERAGING_16AVG			0x00C0
+
+#define TSC2301_ADCREG_CLOCK_8MHZ			0x0000
+#define TSC2301_ADCREG_CLOCK_4MHZ			0x0010
+#define TSC2301_ADCREG_CLOCK_2MHZ			0x0020
+#define TSC2301_ADCREG_CLOCK_1MHZ			0x0030
+
+#define TSC2301_ADCREG_VOLTAGE_STAB_0US			0x0000
+#define TSC2301_ADCREG_VOLTAGE_STAB_100US		0x0002
+#define TSC2301_ADCREG_VOLTAGE_STAB_500US		0x0004
+#define TSC2301_ADCREG_VOLTAGE_STAB_1MS			0x0006
+#define TSC2301_ADCREG_VOLTAGE_STAB_5MS			0x0008
+#define TSC2301_ADCREG_VOLTAGE_STAB_10MS		0x000A
+#define TSC2301_ADCREG_VOLTAGE_STAB_50MS		0x000C
+#define TSC2301_ADCREG_VOLTAGE_STAB_100MS		0x000E
+
+#define TSC2301_ADCREG_STOP_CONVERSION			0x4000
+
+#define MAX_12BIT					((1 << 12) - 1)
+
+#define TS_RECT_SIZE					8
+#define TSF_MIN_Z1					100
+#define TSF_MAX_Z2					4000
+
+#define TSF_SAMPLES					4
+
+struct ts_filter {
+	int			sample_cnt;
+
+	int 			avg_x;
+	int 			avg_y;
+	int 			avg_z1;
+	int 			avg_z2;
+};
+
+struct ts_coords {
+	u16 			x;
+	u16 			y;
+	u16 			z1;
+	u16 			z2;
+};
+
+struct tsc2301_ts {
+	struct input_dev	*idev;
+	char			phys[32];
+	struct timer_list	penup_timer;
+	struct mutex		mutex;
+
+	struct spi_transfer	read_xfer[2];
+	struct spi_message	read_msg;
+	struct ts_coords	*coords;
+
+	struct ts_filter	filter;
+
+	int			hw_avg_max;
+	u16			x;
+	u16			y;
+	u16			p;
+
+	u16			x_plate_ohm;
+	int			stab_time;
+	int			max_pressure;
+	int			touch_pressure;
+
+	u8			event_sent;
+	u8			pen_down;
+	u8			disabled;
+	u8			disable_depth;
+
+	int			hw_flags;
+	int			irq;
+};
+
+static const u16 tsc2301_ts_read_data = 0x8000 | TSC2301_REG_X;
+
+static int tsc2301_ts_check_config(struct tsc2301_ts *ts, int *hw_flags)
+{
+	int flags;
+
+	flags = 0;
+	switch (ts->hw_avg_max) {
+	case 0:
+		flags |= TSC2301_ADCREG_AVERAGING_NONE;
+		break;
+	case 4:
+		flags |= TSC2301_ADCREG_AVERAGING_4AVG;
+		break;
+	case 8:
+		flags |= TSC2301_ADCREG_AVERAGING_8AVG;
+		break;
+	case 16:
+		flags |= TSC2301_ADCREG_AVERAGING_16AVG;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (ts->stab_time) {
+	case 0:
+		flags |= TSC2301_ADCREG_VOLTAGE_STAB_0US;
+		break;
+	case 100:
+		flags |= TSC2301_ADCREG_VOLTAGE_STAB_100US;
+		break;
+	case 500:
+		flags |= TSC2301_ADCREG_VOLTAGE_STAB_500US;
+		break;
+	case 1000:
+		flags |= TSC2301_ADCREG_VOLTAGE_STAB_1MS;
+		break;
+	case 5000:
+		flags |= TSC2301_ADCREG_VOLTAGE_STAB_5MS;
+		break;
+	case 10000:
+		flags |= TSC2301_ADCREG_VOLTAGE_STAB_10MS;
+		break;
+	case 50000:
+		flags |= TSC2301_ADCREG_VOLTAGE_STAB_50MS;
+		break;
+	case 100000:
+		flags |= TSC2301_ADCREG_VOLTAGE_STAB_100MS;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	*hw_flags = flags;
+	return 0;
+}
+
+/*
+ * This odd three-time initialization is to work around a bug in TSC2301.
+ * See TSC2301 errata for details.
+ */
+static int tsc2301_ts_configure(struct tsc2301 *tsc, int flags)
+{
+	struct spi_transfer xfer[5];
+	struct spi_transfer *x;
+	struct spi_message m;
+	int i;
+	u16 val1, val2, val3;
+	u16 data[10];
+
+	val1 = TSC2301_ADCREG_CONVERSION_CTRL_BY_HOST |
+		TSC2301_ADCREG_STOP_CONVERSION |
+		TSC2301_ADCREG_FUNCTION_NONE |
+		TSC2301_ADCREG_RESOLUTION_12BIT |
+		TSC2301_ADCREG_AVERAGING_NONE |
+		TSC2301_ADCREG_CLOCK_2MHZ |
+		TSC2301_ADCREG_VOLTAGE_STAB_100MS;
+
+	val2 = TSC2301_ADCREG_CONVERSION_CTRL_BY_HOST |
+		TSC2301_ADCREG_FUNCTION_XYZ |
+		TSC2301_ADCREG_RESOLUTION_12BIT |
+		TSC2301_ADCREG_AVERAGING_16AVG |
+		TSC2301_ADCREG_CLOCK_1MHZ |
+		TSC2301_ADCREG_VOLTAGE_STAB_100MS;
+
+	/* Averaging and voltage stabilization settings in flags */
+	val3 = TSC2301_ADCREG_CONVERSION_CTRL_BY_TSC2301 |
+		TSC2301_ADCREG_FUNCTION_XYZ |
+		TSC2301_ADCREG_RESOLUTION_12BIT |
+		TSC2301_ADCREG_CLOCK_2MHZ |
+		flags;
+
+	/* Now we prepare the command for transferring */
+	data[0] = TSC2301_REG_ADC;
+	data[1] = val1;
+	data[2] = TSC2301_REG_ADC;
+	data[3] = val2;
+	data[4] = TSC2301_REG_ADC;
+	data[5] = val3;
+	data[6] = TSC2301_REG_REF;
+	data[7] = 1 << 4 | 1 << 2 | 1; /* intref, 100uS settl, 2.5V ref */
+	data[8] = TSC2301_REG_CONFIG;
+	data[9] = 3 << 3 | 2 << 0; /* 340uS pre-chrg, 544us delay */
+
+	spi_message_init(&m);
+	m.spi = tsc->spi;
+
+	memset(xfer, 0, sizeof(xfer));
+	x = &xfer[0];
+
+	for (i = 0; i < 10; i += 2) {
+		x->tx_buf = &data[i];
+		x->len = 4;
+		if (i != 8)
+			x->cs_change = 1;
+		spi_message_add_tail(x, &m);
+		x++;
+	}
+	spi_sync(m.spi, &m);
+
+	return 0;
+}
+
+static void tsc2301_ts_start_scan(struct tsc2301 *tsc)
+{
+	tsc2301_ts_configure(tsc, tsc->ts->hw_flags);
+	tsc2301_kp_restart(tsc);
+}
+
+static void tsc2301_ts_stop_scan(struct tsc2301 *tsc)
+{
+	tsc2301_write_reg(tsc, TSC2301_REG_ADC, TSC2301_ADCREG_STOP_CONVERSION);
+	tsc2301_kp_restart(tsc);
+}
+
+static void update_pen_state(struct tsc2301_ts *ts, int x, int y, int pressure)
+{
+	if (pressure) {
+		input_report_abs(ts->idev, ABS_X, x);
+		input_report_abs(ts->idev, ABS_Y, y);
+		input_report_abs(ts->idev, ABS_PRESSURE, pressure);
+		if (!ts->pen_down)
+			input_report_key(ts->idev, BTN_TOUCH, 1);
+		ts->pen_down = 1;
+	} else {
+		input_report_abs(ts->idev, ABS_PRESSURE, 0);
+		if (ts->pen_down)
+			input_report_key(ts->idev, BTN_TOUCH, 0);
+		ts->pen_down = 0;
+	}
+
+	input_sync(ts->idev);
+
+#ifdef VERBOSE
+	dev_dbg(&tsc->spi->dev, "x %4d y %4d p %4d\n", x, y, pressure);
+#endif
+}
+
+static int filter(struct tsc2301_ts *ts, int x, int y, int z1, int z2)
+{
+	int inside_rect, pressure_limit, Rt;
+	struct ts_filter *tsf = &ts->filter;
+
+	/* validate pressure and position */
+	if (x > MAX_12BIT || y > MAX_12BIT)
+		return 0;
+
+	/* skip coords if the pressure-components are out of range */
+	if (z1 < TSF_MIN_Z1 || z2 > TSF_MAX_Z2)
+		return 0;
+
+	/* Use the x,y,z1,z2 directly on the first "pen down" event */
+	if (ts->event_sent) {
+		tsf->avg_x  += x;
+		tsf->avg_y  += y;
+		tsf->avg_z1 += z1;
+		tsf->avg_z2 += z2;
+
+		if (++tsf->sample_cnt < TSF_SAMPLES)
+			return 0;
+		x = tsf->avg_x / TSF_SAMPLES;
+		y = tsf->avg_y / TSF_SAMPLES;
+		z1 = tsf->avg_z1 / TSF_SAMPLES;
+		z2 = tsf->avg_z2 / TSF_SAMPLES;
+	}
+	tsf->sample_cnt = 0;
+	tsf->avg_x  = 0;
+	tsf->avg_y  = 0;
+	tsf->avg_z1 = 0;
+	tsf->avg_z2 = 0;
+
+	pressure_limit = ts->event_sent? ts->max_pressure: ts->touch_pressure;
+
+	/* z1 is always at least 100: */
+	Rt = x * (z2 - z1) / z1;
+	Rt = Rt * ts->x_plate_ohm / 4096;
+	if (Rt > pressure_limit)
+		return 0;
+
+	/* discard the event if it still is within the previous rect - unless
+	 * if the pressure is harder, but then use previous x,y position */
+	inside_rect = (
+	    x > (int)ts->x - TS_RECT_SIZE && x < (int)ts->x + TS_RECT_SIZE &&
+	    y > (int)ts->y - TS_RECT_SIZE && y < (int)ts->y + TS_RECT_SIZE);
+
+	if (!ts->event_sent || !inside_rect) {
+		ts->x = x;
+		ts->y = y;
+		ts->p = Rt;
+		return 1;
+	} else if (Rt < ts->p) {
+		ts->p = Rt;
+		return 1;
+	}
+	return 0;
+}
+
+/*
+ * This procedure is called by the SPI framework after the coordinates
+ * have been read from TSC2301
+ */
+static void tsc2301_ts_rx(void *arg)
+{
+	struct tsc2301 *tsc = arg;
+	struct tsc2301_ts *ts = tsc->ts;
+	int send_event;
+	int x, y, z1, z2;
+
+	x  = ts->coords->x;
+	y  = ts->coords->y;
+	z1 = ts->coords->z1;
+	z2 = ts->coords->z2;
+
+	send_event = filter(ts, x, y, z1, z2);
+	if (send_event) {
+		update_pen_state(ts, ts->x, ts->y, ts->p);
+		ts->event_sent = 1;
+	}
+
+	mod_timer(&ts->penup_timer,
+		  jiffies + msecs_to_jiffies(TSC2301_TS_PENUP_TIME));
+}
+
+/*
+ * Timer is called TSC2301_TS_PENUP_TIME after pen is up
+ */
+static void tsc2301_ts_timer_handler(unsigned long data)
+{
+	struct tsc2301 *tsc = (struct tsc2301 *)data;
+	struct tsc2301_ts *ts = tsc->ts;
+
+	if (ts->event_sent) {
+		ts->event_sent = 0;
+		update_pen_state(ts, 0, 0, 0);
+	}
+}
+
+/*
+ * This interrupt is called when pen is down and coordinates are
+ * available. That is indicated by a falling edge on DEV line.
+ */
+static irqreturn_t tsc2301_ts_irq_handler(int irq, void *dev_id)
+{
+	struct tsc2301 *tsc = dev_id;
+	struct tsc2301_ts *ts = tsc->ts;
+	int r;
+
+	r = spi_async(tsc->spi, &ts->read_msg);
+	if (r)
+		dev_err(&tsc->spi->dev, "ts: spi_async() failed");
+
+	mod_timer(&ts->penup_timer,
+		  jiffies + msecs_to_jiffies(TSC2301_TS_PENUP_TIME));
+
+	return IRQ_HANDLED;
+}
+
+static void tsc2301_ts_disable(struct tsc2301 *tsc)
+{
+	struct tsc2301_ts *ts = tsc->ts;
+
+	if (ts->disable_depth++ != 0)
+		return;
+
+	disable_irq(ts->irq);
+
+	/* wait until penup timer expire normally */
+	do {
+		msleep(1);
+	} while (ts->event_sent);
+
+	tsc2301_ts_stop_scan(tsc);
+}
+
+static void tsc2301_ts_enable(struct tsc2301 *tsc)
+{
+	struct tsc2301_ts *ts = tsc->ts;
+
+	if (--ts->disable_depth != 0)
+		return;
+
+	enable_irq(ts->irq);
+
+	tsc2301_ts_start_scan(tsc);
+}
+
+#ifdef CONFIG_PM
+int tsc2301_ts_suspend(struct tsc2301 *tsc)
+{
+	struct tsc2301_ts *ts = tsc->ts;
+
+	mutex_lock(&ts->mutex);
+	tsc2301_ts_disable(tsc);
+	mutex_unlock(&ts->mutex);
+
+	return 0;
+}
+
+void tsc2301_ts_resume(struct tsc2301 *tsc)
+{
+	struct tsc2301_ts *ts = tsc->ts;
+
+	mutex_lock(&ts->mutex);
+	tsc2301_ts_enable(tsc);
+	mutex_unlock(&ts->mutex);
+}
+#endif
+
+static void tsc2301_ts_setup_spi_xfer(struct tsc2301 *tsc)
+{
+	struct tsc2301_ts *ts = tsc->ts;
+	struct spi_message *m = &ts->read_msg;
+	struct spi_transfer *x = &ts->read_xfer[0];
+
+	spi_message_init(m);
+
+	x->tx_buf = &tsc2301_ts_read_data;
+	x->len = 2;
+	spi_message_add_tail(x, m);
+
+	x++;
+	x->rx_buf = ts->coords;
+	x->len = 8;
+	spi_message_add_tail(x, m);
+
+	m->complete = tsc2301_ts_rx;
+	m->context = tsc;
+}
+
+static ssize_t tsc2301_ts_pen_down_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct tsc2301 *tsc = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", tsc->ts->pen_down);
+}
+
+static DEVICE_ATTR(pen_down, S_IRUGO, tsc2301_ts_pen_down_show, NULL);
+
+static ssize_t tsc2301_ts_disable_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct tsc2301		*tsc = dev_get_drvdata(dev);
+	struct tsc2301_ts	*ts = tsc->ts;
+
+	return sprintf(buf, "%u\n", ts->disabled);
+}
+
+static ssize_t tsc2301_ts_disable_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct tsc2301		*tsc = dev_get_drvdata(dev);
+	struct tsc2301_ts	*ts = tsc->ts;
+	char *endp;
+	int i;
+
+	i = simple_strtoul(buf, &endp, 10);
+	i = i ? 1 : 0;
+	mutex_lock(&ts->mutex);
+	if (i == ts->disabled) goto out;
+	ts->disabled = i;
+
+	if (i)
+		tsc2301_ts_disable(tsc);
+	else
+		tsc2301_ts_enable(tsc);
+out:
+	mutex_unlock(&ts->mutex);
+	return count;
+}
+
+static DEVICE_ATTR(disable_ts, 0664, tsc2301_ts_disable_show,
+		   tsc2301_ts_disable_store);
+
+int __devinit tsc2301_ts_init(struct tsc2301 *tsc,
+			      struct tsc2301_platform_data *pdata)
+{
+	struct tsc2301_ts *ts;
+	struct input_dev *idev;
+	int r;
+	int x_max, y_max;
+	int x_fudge, y_fudge, p_fudge;
+
+	if (pdata->dav_int <= 0) {
+		dev_err(&tsc->spi->dev, "need DAV IRQ");
+		return -EINVAL;
+	}
+
+	ts = kzalloc(sizeof(*ts), GFP_KERNEL);
+	if (ts == NULL)
+		return -ENOMEM;
+	tsc->ts = ts;
+
+	ts->coords = kzalloc(sizeof(*ts->coords), GFP_KERNEL);
+	if (ts->coords == NULL) {
+		kfree(ts);
+		return -ENOMEM;
+	}
+
+	ts->irq = pdata->dav_int;
+
+	init_timer(&ts->penup_timer);
+	setup_timer(&ts->penup_timer, tsc2301_ts_timer_handler,
+			(unsigned long)tsc);
+
+	mutex_init(&ts->mutex);
+
+	ts->x_plate_ohm	= pdata->ts_x_plate_ohm ? : 280;
+	ts->hw_avg_max	= pdata->ts_hw_avg;
+	ts->max_pressure = pdata->ts_max_pressure ? : MAX_12BIT;
+	ts->touch_pressure = pdata->ts_touch_pressure ? : ts->max_pressure;
+	ts->stab_time	= pdata->ts_stab_time;
+
+	x_max		= pdata->ts_x_max ? : 4096;
+	y_max		= pdata->ts_y_max ? : 4096;
+	x_fudge		= pdata->ts_x_fudge ? : 4;
+	y_fudge		= pdata->ts_y_fudge ? : 8;
+	p_fudge		= pdata->ts_pressure_fudge ? : 2;
+
+	if ((r = tsc2301_ts_check_config(ts, &ts->hw_flags))) {
+		dev_err(&tsc->spi->dev, "invalid configuration\n");
+		goto err2;
+	}
+
+	idev = input_allocate_device();
+	if (idev == NULL) {
+		r = -ENOMEM;
+		goto err2;
+	}
+	idev->name = "TSC2301 touchscreen";
+	snprintf(ts->phys, sizeof(ts->phys),
+		 "%s/input-ts", dev_name(&tsc->spi->dev));
+	idev->phys = ts->phys;
+	idev->dev.parent = &tsc->spi->dev;
+
+	idev->evbit[0] = BIT(EV_ABS) | BIT(EV_KEY);
+	idev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y) | BIT(ABS_PRESSURE);
+	ts->idev = idev;
+
+	tsc2301_ts_setup_spi_xfer(tsc);
+
+	/* These parameters should perhaps be configurable? */
+	input_set_abs_params(idev, ABS_X, 0, x_max, x_fudge, 0);
+	input_set_abs_params(idev, ABS_Y, 0, y_max, y_fudge, 0);
+	input_set_abs_params(idev, ABS_PRESSURE, 0, ts->max_pressure,
+			     p_fudge, 0);
+
+	tsc2301_ts_start_scan(tsc);
+
+	r = request_irq(ts->irq, tsc2301_ts_irq_handler,
+			IRQF_SAMPLE_RANDOM | IRQF_TRIGGER_FALLING,
+			"tsc2301-ts", tsc);
+	if (r < 0) {
+		dev_err(&tsc->spi->dev, "unable to get DAV IRQ");
+		goto err3;
+	}
+	set_irq_wake(ts->irq, 1);
+
+	if (device_create_file(&tsc->spi->dev, &dev_attr_pen_down) < 0)
+		goto err4;
+	if (device_create_file(&tsc->spi->dev, &dev_attr_disable_ts) < 0)
+		goto err5;
+
+	r = input_register_device(idev);
+	if (r < 0) {
+		dev_err(&tsc->spi->dev, "can't register touchscreen device\n");
+		goto err6;
+	}
+
+	return 0;
+err6:
+	device_remove_file(&tsc->spi->dev, &dev_attr_disable_ts);
+err5:
+	device_remove_file(&tsc->spi->dev, &dev_attr_pen_down);
+err4:
+	free_irq(ts->irq, tsc);
+err3:
+	tsc2301_ts_stop_scan(tsc);
+	input_free_device(idev);
+err2:
+	kfree(ts->coords);
+	kfree(ts);
+	return r;
+}
+
+void __devexit tsc2301_ts_exit(struct tsc2301 *tsc)
+{
+	struct tsc2301_ts *ts = tsc->ts;
+
+	tsc2301_ts_disable(tsc);
+
+	device_remove_file(&tsc->spi->dev, &dev_attr_disable_ts);
+	device_remove_file(&tsc->spi->dev, &dev_attr_pen_down);
+
+	free_irq(ts->irq, tsc);
+	input_unregister_device(ts->idev);
+
+	kfree(ts->coords);
+	kfree(ts);
+}
+MODULE_AUTHOR("Jarkko Oikarinen <jarkko.oikarinen@nokia.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/wireless/p54/p54spi.c b/drivers/net/wireless/p54/p54spi.c
index afd26bf..24d3f4b 100644
--- a/drivers/net/wireless/p54/p54spi.c
+++ b/drivers/net/wireless/p54/p54spi.c
@@ -698,7 +698,7 @@ static struct spi_driver p54spi_driver = {
 	.driver = {
 		/* use cx3110x name because board-n800.c uses that for the
 		 * SPI port */
-		.name		= "cx3110x",
+		.name		= "p54spi",
 		.bus		= &spi_bus_type,
 		.owner		= THIS_MODULE,
 	},
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 4b6f7cb..16082ed 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -276,6 +276,35 @@ config SPI_TLE62X0
 # Add new SPI protocol masters in alphabetical order above this line
 #
 
+config SPI_TSC2301
+	tristate "TSC2301 driver"
+	depends on SPI_MASTER
+	help
+	  Say Y here if you have a TSC2301 chip connected to an SPI
+	  bus on your board.
+
+	  The TSC2301 is a highly integrated PDA analog interface circuit.
+	  It contains a complete 12-bit A/D resistive touch screen
+	  converter (ADC) including drivers, touch pressure measurement
+	  capability, keypad controller, and 8-bit D/A converter (DAC) output
+	  for LCD contrast control.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tsc2301.
+
+config SPI_TSC2005
+	tristate "TSC2005 driver"
+	depends on SPI_MASTER
+	help
+	  Say Y here if you have a TSC2005 chip connected to an SPI
+	  bus on your board.
+
+	  The TSC2005 is a 12-bit A/D resistive touch screen
+	  converter (ADC).
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tsc2005.
+
 endif # SPI_MASTER
 
 # (slave support would go here)
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 21a1182..0cb344b 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -38,6 +38,9 @@ obj-$(CONFIG_SPI_STMP3XXX)		+= spi_stmp.o
 # SPI protocol drivers (device/link on bus)
 obj-$(CONFIG_SPI_SPIDEV)	+= spidev.o
 obj-$(CONFIG_SPI_TLE62X0)	+= tle62x0.o
+obj-$(CONFIG_SPI_TSC2005)	+= tsc2005.o
+obj-$(CONFIG_SPI_TSC2301)	+= tsc2301.o
+tsc2301-objs			:= tsc2301-core.o
 # 	... add above this line ...
 
 # SPI slave controller drivers (upstream link)
diff --git a/drivers/spi/tsc2005.c b/drivers/spi/tsc2005.c
new file mode 100644
index 0000000..d4adadb
--- /dev/null
+++ b/drivers/spi/tsc2005.c
@@ -0,0 +1,784 @@
+/*
+ * TSC2005 touchscreen driver
+ *
+ * Copyright (C) 2006-2007 Nokia Corporation
+ *
+ * Written by Timo O. Karjalainen <timo.o.karjalainen@nokia.com>
+ * based on TSC2301 driver by Jarkko Oikarinen, Imre Deak and Juha Yrjola
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+
+#ifdef CONFIG_ARCH_OMAP
+#include <asm/gpio.h>
+#endif
+
+#include <linux/spi/tsc2005.h>
+
+/**
+ * The touchscreen interface operates as follows:
+ *
+ * Initialize:
+ *    Request access to GPIO103 (DAV)
+ *    tsc2005_dav_irq_handler will trigger when DAV line goes down
+ *
+ *  1) Pen is pressed against touchscreeen
+ *  2) TSC2005 performs AD conversion
+ *  3) After the conversion is done TSC2005 drives DAV line down
+ *  4) GPIO IRQ is received and tsc2005_dav_irq_handler is called
+ *  5) If gpio irq is enabled, irq is disabld and handler calls spi_async()
+ *  6) SPI framework calls tsc2005_ts_rx after the coordinates are read
+ *  7) tsc2005_ts_rx() reports coordinates to input layer and
+ *     sets up tsc2005_ts_timer() to be called after TSC2005_TS_SCAN_TIME
+ *  8) If the pen is down, tsc2005_tx_timer() calls spi_async(), causing
+ *     steps 6 to 8 to repeat.
+ *  9) if tsc2005_tx_timer() notices that the pen has been lifted, the lift
+ *     event is sent, and irq is again enabled.
+ */
+
+#define TSC2005_HZ	(14000000)
+
+#define TSC2005_CMD	(0x80)
+#define TSC2005_REG	(0x00)
+
+#define TSC2005_CMD_STOP	(1)
+#define TSC2005_CMD_10BIT	(0 << 2)
+#define TSC2005_CMD_12BIT	(1 << 2)
+
+#define TSC2005_CMD_SCAN_XYZZ	(0 << 3)
+#define TSC2005_CMD_SCAN_XY	(1 << 3)
+#define TSC2005_CMD_SCAN_X	(2 << 3)
+#define TSC2005_CMD_SCAN_Y	(3 << 3)
+#define TSC2005_CMD_SCAN_ZZ	(4 << 3)
+#define TSC2005_CMD_AUX_SINGLE	(5 << 3)
+#define TSC2005_CMD_TEMP1	(6 << 3)
+#define TSC2005_CMD_TEMP2	(7 << 3)
+#define TSC2005_CMD_AUX_CONT	(8 << 3)
+#define TSC2005_CMD_TEST_X_CONN	(9 << 3)
+#define TSC2005_CMD_TEST_Y_CONN	(10 << 3)
+/* command 11 reserved */
+#define TSC2005_CMD_TEST_SHORT	(12 << 3)
+#define TSC2005_CMD_DRIVE_XX	(13 << 3)
+#define TSC2005_CMD_DRIVE_YY	(14 << 3)
+#define TSC2005_CMD_DRIVE_YX	(15 << 3)
+
+#define TSC2005_REG_X		(0 << 3)
+#define TSC2005_REG_Y		(1 << 3)
+#define TSC2005_REG_Z1		(2 << 3)
+#define TSC2005_REG_Z2		(3 << 3)
+#define TSC2005_REG_AUX		(4 << 3)
+#define TSC2005_REG_TEMP1	(5 << 3)
+#define TSC2005_REG_TEMP2	(6 << 3)
+#define TSC2005_REG_STATUS	(7 << 3)
+#define TSC2005_REG_AUX_HIGH	(8 << 3)
+#define TSC2005_REG_AUX_LOW	(9 << 3)
+#define TSC2005_REG_TEMP_HIGH	(10 << 3)
+#define TSC2005_REG_TEMP_LOW	(11 << 3)
+#define TSC2005_REG_CFR0	(12 << 3)
+#define TSC2005_REG_CFR1	(13 << 3)
+#define TSC2005_REG_CFR2	(14 << 3)
+#define TSC2005_REG_FUNCTION	(15 << 3)
+
+#define TSC2005_REG_READ	(0x01)
+#define TSC2005_REG_WRITE	(0x00)
+
+
+#define TSC2005_CFR0_LONGSAMPLING	(0x0001)
+#define TSC2005_CFR0_DETECTINWAIT	(0x0002)
+#define TSC2005_CFR0_SENSETIME_32US	(0x0000)
+#define TSC2005_CFR0_SENSETIME_96US	(0x0004)
+#define TSC2005_CFR0_SENSETIME_544US	(0x0008)
+#define TSC2005_CFR0_SENSETIME_2080US	(0x0010)
+#define TSC2005_CFR0_SENSETIME_2656US	(0x001C)
+#define TSC2005_CFR0_PRECHARGE_20US	(0x0000)
+#define TSC2005_CFR0_PRECHARGE_84US	(0x0020)
+#define TSC2005_CFR0_PRECHARGE_276US	(0x0040)
+#define TSC2005_CFR0_PRECHARGE_1044US	(0x0080)
+#define TSC2005_CFR0_PRECHARGE_1364US	(0x00E0)
+#define TSC2005_CFR0_STABTIME_0US	(0x0000)
+#define TSC2005_CFR0_STABTIME_100US	(0x0100)
+#define TSC2005_CFR0_STABTIME_500US	(0x0200)
+#define TSC2005_CFR0_STABTIME_1MS	(0x0300)
+#define TSC2005_CFR0_STABTIME_5MS	(0x0400)
+#define TSC2005_CFR0_STABTIME_100MS	(0x0700)
+#define TSC2005_CFR0_CLOCK_4MHZ		(0x0000)
+#define TSC2005_CFR0_CLOCK_2MHZ		(0x0800)
+#define TSC2005_CFR0_CLOCK_1MHZ		(0x1000)
+#define TSC2005_CFR0_RESOLUTION12	(0x2000)
+#define TSC2005_CFR0_STATUS		(0x4000)
+#define TSC2005_CFR0_PENMODE		(0x8000)
+
+#define TSC2005_CFR0_INITVALUE	(TSC2005_CFR0_DETECTINWAIT |	\
+				 TSC2005_CFR0_STABTIME_1MS  |	\
+				 TSC2005_CFR0_CLOCK_1MHZ    |	\
+				 TSC2005_CFR0_RESOLUTION12  |	\
+				 TSC2005_CFR0_PENMODE)
+
+#define TSC2005_CFR1_BATCHDELAY_0MS	(0x0000)
+#define TSC2005_CFR1_BATCHDELAY_1MS	(0x0001)
+#define TSC2005_CFR1_BATCHDELAY_2MS	(0x0002)
+#define TSC2005_CFR1_BATCHDELAY_4MS	(0x0003)
+#define TSC2005_CFR1_BATCHDELAY_10MS	(0x0004)
+#define TSC2005_CFR1_BATCHDELAY_20MS	(0x0005)
+#define TSC2005_CFR1_BATCHDELAY_40MS	(0x0006)
+#define TSC2005_CFR1_BATCHDELAY_100MS	(0x0007)
+
+#define TSC2005_CFR1_INITVALUE	(TSC2005_CFR1_BATCHDELAY_1MS)
+
+#define TSC2005_CFR2_MAVE_TEMP	(0x0001)
+#define TSC2005_CFR2_MAVE_AUX	(0x0002)
+#define TSC2005_CFR2_MAVE_Z	(0x0004)
+#define TSC2005_CFR2_MAVE_Y	(0x0008)
+#define TSC2005_CFR2_MAVE_X	(0x0010)
+#define TSC2005_CFR2_AVG_1	(0x0000)
+#define TSC2005_CFR2_AVG_3	(0x0400)
+#define TSC2005_CFR2_AVG_7	(0x0800)
+#define TSC2005_CFR2_MEDIUM_1	(0x0000)
+#define TSC2005_CFR2_MEDIUM_3	(0x1000)
+#define TSC2005_CFR2_MEDIUM_7	(0x2000)
+#define TSC2005_CFR2_MEDIUM_15	(0x3000)
+
+#define TSC2005_CFR2_IRQ_DAV	(0x4000)
+#define TSC2005_CFR2_IRQ_PEN	(0x8000)
+#define TSC2005_CFR2_IRQ_PENDAV	(0x0000)
+
+#define TSC2005_CFR2_INITVALUE	(TSC2005_CFR2_IRQ_DAV  |	\
+				 TSC2005_CFR2_MAVE_X    |	\
+				 TSC2005_CFR2_MAVE_Y    |	\
+				 TSC2005_CFR2_MAVE_Z    |	\
+				 TSC2005_CFR2_MEDIUM_15 |	\
+				 TSC2005_CFR2_AVG_7)
+
+/*
+  #define TSC2301_TOUCHSCREEN_PRODUCT_ID      		0x0052
+  #define TSC2301_TOUCHSCREEN_PRODUCT_VERSION 		0x0001
+*/
+
+#define TSC2005_TS_SCAN_TIME		     		6
+
+#define MAX_12BIT					((1 << 12) - 1)
+
+
+static const u32 tsc2005_read_reg[] = {
+	(0x100 | TSC2005_REG | TSC2005_REG_X | TSC2005_REG_READ) << 16,
+	(0x100 | TSC2005_REG | TSC2005_REG_Y | TSC2005_REG_READ) << 16,
+	(0x100 | TSC2005_REG | TSC2005_REG_Z1 | TSC2005_REG_READ) << 16,
+	(0x100 | TSC2005_REG | TSC2005_REG_Z2 | TSC2005_REG_READ) << 16,
+	(0x100 | TSC2005_REG | TSC2005_REG_STATUS | TSC2005_REG_READ) << 16
+};
+#define NUM_READ_REGS	(sizeof(tsc2005_read_reg)/sizeof(tsc2005_read_reg[0]))
+
+struct tsc2005 {
+	struct spi_device	*spi;
+
+	s16			reset_gpio;
+	u16			config2_shadow;
+
+	struct input_dev	*idev;
+	char			phys[32];
+	struct timer_list	timer;
+	spinlock_t		lock;
+
+	struct spi_message	read_msg;
+	struct spi_transfer	read_xfer[NUM_READ_REGS];
+	u32                     data[NUM_READ_REGS];
+
+	int			hw_avg_max;
+	u16			x;
+	u16			y;
+	u16			p;
+	int			sample_cnt;
+
+	int			ignore_last : 1;
+	u16			x_plate_ohm;
+	int			stab_time;
+	int			max_pressure;
+	int			touch_pressure;
+	int			pressure_limit;
+
+	u16			irq_enabled:1;
+	u16			pen_down:1;
+	u16			disabled:1;
+	u16			pending:1;
+	u16			pnd:1;	/* power not down */
+
+	int			hw_flags;
+
+	s16			dav_gpio;
+	int			irq;
+};
+
+/* TSC2005 needs a 1-bit followed by 8 bits of command. */
+static void tsc2005_cmd(struct tsc2005 *ts, u8 cmd)
+{
+	u16 data = (1 << 8) | TSC2005_CMD | TSC2005_CMD_12BIT | cmd;
+	struct spi_message msg;
+	struct spi_transfer xfer = { 0 };
+
+	spi_message_init(&msg);
+	msg.spi = ts->spi;
+	xfer.tx_buf = &data;
+	xfer.rx_buf = NULL;
+	xfer.len = 2;
+	xfer.bits_per_word = 9;
+
+	spi_message_add_tail(&xfer, &msg);
+	spi_sync(ts->spi, &msg);
+}
+
+/*
+ *  To write a register, we send a 1-bit + 8 bit command + 16 bits of new
+ * register value.
+ */
+static void tsc2005_write(struct tsc2005 *ts, u8 reg, u16 value)
+{
+	u32 tx;
+	struct spi_message msg;
+	struct spi_transfer xfer = { 0 };
+
+	tx = 1 << (3 * 8);
+	tx |= (TSC2005_REG | reg | (ts->pnd << 1) |
+	       TSC2005_REG_WRITE) << (2 * 8);
+	tx |= value;
+
+	spi_message_init(&msg);
+	msg.spi = ts->spi;
+	xfer.tx_buf = &tx;
+	xfer.rx_buf = NULL;
+	xfer.len = 4;
+	xfer.bits_per_word = 1 + 3 * 8;
+
+	spi_message_add_tail(&xfer, &msg);
+	spi_sync(ts->spi, &msg);
+}
+
+static int tsc2005_ts_check_config(struct tsc2005 *ts, int *hw_flags)
+{
+	int flags;
+
+	flags = TSC2005_CMD_SCAN_XYZZ;
+
+	*hw_flags = flags;
+	return 0;
+}
+
+static int device_suspended(struct device *dev)
+{
+	struct tsc2005 *tsc = dev_get_drvdata(dev);
+	return dev->power.power_state.event != PM_EVENT_ON || tsc->disabled;
+}
+
+static void update_pen_state(struct tsc2005 *ts, int x, int y, int pressure)
+{
+	int sync = 0;
+
+	if (pressure) {
+		input_report_abs(ts->idev, ABS_X, x);
+		input_report_abs(ts->idev, ABS_Y, y);
+		input_report_abs(ts->idev, ABS_PRESSURE, pressure);
+		if (!ts->pen_down)
+			input_report_key(ts->idev, BTN_TOUCH, 1);
+		sync = 1;
+	} else if (ts->pen_down) {
+		input_report_abs(ts->idev, ABS_PRESSURE, 0);
+		input_report_key(ts->idev, BTN_TOUCH, 0);
+		sync = 1;
+	}
+
+	if (sync)
+		input_sync(ts->idev);
+
+	ts->pen_down = pressure ? 1 : 0;
+
+#ifdef VERBOSE
+	dev_dbg(&tsc->spi->dev, "x %4d y %4d p %4d\n", x, y, pressure);
+#endif
+}
+
+/*
+ * This procedure is called by the SPI framework after the coordinates
+ * have been read from TSC2005
+ */
+static void tsc2005_ts_rx(void *arg)
+{
+	struct tsc2005 *ts = arg;
+	unsigned int x, y, z1, z2, pressure;
+
+	x  = ts->data[0];
+	y  = ts->data[1];
+	z1 = ts->data[2];
+	z2 = ts->data[3];
+
+	if (z1) {
+		pressure = ts->x_plate_ohm * x;
+		pressure /= 4096;
+		pressure *= z2 - z1;
+		pressure /= z1;
+	} else
+		pressure = 0;
+
+	/*
+	 * If pressure value is above a preset limit (pen is barely
+	 * touching the screen) we can't trust the coordinate values.
+	 */
+	if (pressure < ts->pressure_limit && x < MAX_12BIT && y < MAX_12BIT) {
+		ts->pressure_limit = ts->max_pressure;
+		if (ts->ignore_last) {
+			if (ts->sample_cnt)
+				update_pen_state(ts, ts->x, ts->y, ts->p);
+			ts->x = x;
+			ts->y = y;
+			ts->p = pressure;
+		} else
+			update_pen_state(ts, x, y, pressure);
+		ts->sample_cnt++;
+	}
+
+	mod_timer(&ts->timer, jiffies +
+		  msecs_to_jiffies(TSC2005_TS_SCAN_TIME));
+}
+
+static int is_pen_down(struct tsc2005 *ts)
+{
+	return ts->pen_down;
+}
+
+/*
+ * Timer is called every TSC2005_TS_SCAN_TIME when the pen is down
+ */
+static void tsc2005_ts_timer(unsigned long arg)
+{
+	struct tsc2005 *ts = (void *) arg;
+	unsigned long flags;
+	int ndav;
+	int r;
+
+	spin_lock_irqsave(&ts->lock, flags);
+	ndav = gpio_get_value(ts->dav_gpio);
+	if (ndav || device_suspended(&ts->spi->dev)) {
+		/* Pen has been lifted */
+		if (!device_suspended(&ts->spi->dev)) {
+			ts->irq_enabled = 1;
+			enable_irq(ts->irq);
+		}
+		update_pen_state(ts, 0, 0, 0);
+		ts->pending = 0;
+		spin_unlock_irqrestore(&ts->lock, flags);
+	} else {
+		ts->pen_down = 1;
+		spin_unlock_irqrestore(&ts->lock, flags);
+		r = spi_async(ts->spi, &ts->read_msg);
+		if (r)
+			dev_err(&ts->spi->dev, "ts: spi_async() failed");
+	}
+}
+
+/*
+ * This interrupt is called when pen is down and first coordinates are
+ * available. That is indicated by a falling edge on DEV line.  IRQ is
+ * disabled here because while the pen is down the coordinates are
+ * read by a timer.
+ */
+static irqreturn_t tsc2005_ts_irq_handler(int irq, void *dev_id)
+{
+	struct tsc2005 *ts = dev_id;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ts->lock, flags);
+
+	if (ts->irq_enabled) {
+		ts->irq_enabled = 0;
+		disable_irq(ts->irq);
+		ts->pending = 1;
+		ts->pressure_limit = ts->touch_pressure;
+		ts->sample_cnt = 0;
+		spi_async(ts->spi, &ts->read_msg);
+	}
+	spin_unlock_irqrestore(&ts->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+
+void tsc2005_ts_prep_for_clk_stop(struct tsc2005 *tsc)
+{
+}
+
+void tsc2005_ts_cont_after_clk_stop(struct tsc2005 *tsc)
+{
+}
+
+static void tsc2005_ts_setup_spi_xfer(struct tsc2005 *ts)
+{
+	struct spi_message *m = &ts->read_msg;
+	struct spi_transfer *x = &ts->read_xfer[0];
+	int i;
+
+	spi_message_init(m);
+	m->spi = ts->spi;
+
+	for (i = 0; i < NUM_READ_REGS; i++, x++ ) {
+		x->tx_buf = &tsc2005_read_reg[i];
+		x->rx_buf = &ts->data[i];
+		x->len = 4;
+		x->bits_per_word = 25;
+		x->cs_change = i < (NUM_READ_REGS - 1);
+		spi_message_add_tail(x, m);
+	}
+
+	m->complete = tsc2005_ts_rx;
+	m->context = ts;
+}
+
+static ssize_t tsc2005_ts_pen_down_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct tsc2005 *tsc = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", is_pen_down(tsc));
+}
+
+static DEVICE_ATTR(pen_down, S_IRUGO, tsc2005_ts_pen_down_show, NULL);
+
+static int tsc2005_configure(struct tsc2005 *tsc, int flags)
+{
+	tsc2005_write(tsc, TSC2005_REG_CFR0, TSC2005_CFR0_INITVALUE);
+	tsc2005_write(tsc, TSC2005_REG_CFR1, TSC2005_CFR1_INITVALUE);
+	tsc2005_write(tsc, TSC2005_REG_CFR2, TSC2005_CFR2_INITVALUE);
+	tsc2005_cmd(tsc, flags);
+
+	return 0;
+}
+
+static void tsc2005_start_scan(struct tsc2005 *tsc)
+{
+	tsc2005_configure(tsc, tsc->hw_flags);
+}
+
+static void tsc2005_stop_scan(struct tsc2005 *tsc)
+{
+	tsc2005_configure(tsc, TSC2005_CMD_STOP);
+}
+
+/* Must be called with ts->lock held */
+static void tsc2005_disable(struct tsc2005 *ts)
+{
+	if (ts->disabled)
+		return;
+
+	ts->disabled = 1;
+	if (!ts->pending) {
+		ts->irq_enabled = 0;
+		disable_irq(ts->irq);
+	} else {
+		while (ts->pending) {
+			spin_unlock_irq(&ts->lock);
+			msleep(1);
+			spin_lock_irq(&ts->lock);
+		}
+	}
+
+	spin_unlock_irq(&ts->lock);
+	tsc2005_stop_scan(ts);
+	spin_lock_irq(&ts->lock);
+}
+
+static void tsc2005_enable(struct tsc2005 *ts)
+{
+	if (!ts->disabled)
+		return;
+
+	ts->disabled = 0;
+	ts->irq_enabled = 1;
+	enable_irq(ts->irq);
+
+	spin_unlock_irq(&ts->lock);
+	tsc2005_start_scan(ts);
+	spin_lock_irq(&ts->lock);
+}
+
+static ssize_t tsc2005_disable_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct tsc2005 *ts = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", ts->disabled);
+}
+
+static ssize_t tsc2005_disable_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct tsc2005		*tsc = dev_get_drvdata(dev);
+	char *endp;
+	int i;
+
+	i = simple_strtoul(buf, &endp, 10);
+	spin_lock_irq(&tsc->lock);
+
+	if (i)
+		tsc2005_disable(tsc);
+	else
+		tsc2005_enable(tsc);
+
+	spin_unlock_irq(&tsc->lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(disable_ts, 0664, tsc2005_disable_show,
+		   tsc2005_disable_store);
+
+
+static int __devinit tsc2005_ts_init(struct tsc2005 *ts,
+				     struct tsc2005_platform_data *pdata)
+{
+	struct input_dev *idev;
+	int dav_gpio, r;
+
+	if (pdata->dav_gpio < 0) {
+		dev_err(&ts->spi->dev, "need DAV GPIO");
+		return -EINVAL;
+	}
+	dav_gpio = pdata->dav_gpio;
+	ts->dav_gpio = dav_gpio;
+	dev_dbg(&ts->spi->dev, "TSC2005: DAV GPIO = %d\n", dav_gpio);
+
+#ifdef CONFIG_ARCH_OMAP
+	r = gpio_request(dav_gpio, "FIXME");
+	if (r < 0) {
+		dev_err(&ts->spi->dev, "unable to get DAV GPIO");
+		goto err1;
+	}
+	gpio_direction_output(dav_gpio, 1);
+	ts->irq = OMAP_GPIO_IRQ(dav_gpio);
+	dev_dbg(&ts->spi->dev, "TSC2005: DAV IRQ = %d\n", ts->irq);
+#endif
+	init_timer(&ts->timer);
+	ts->timer.data = (unsigned long) ts;
+	ts->timer.function = tsc2005_ts_timer;
+
+	spin_lock_init(&ts->lock);
+
+	ts->x_plate_ohm	= pdata->ts_x_plate_ohm ? : 280;
+	ts->hw_avg_max	= pdata->ts_hw_avg;
+	ts->max_pressure= pdata->ts_pressure_max ? : MAX_12BIT;
+	ts->touch_pressure = pdata->ts_touch_pressure ? : ts->max_pressure;
+	ts->ignore_last	= pdata->ts_ignore_last;
+	ts->stab_time	= pdata->ts_stab_time;
+
+	if ((r = tsc2005_ts_check_config(ts, &ts->hw_flags))) {
+		dev_err(&ts->spi->dev, "invalid configuration\n");
+		goto err2;
+	}
+
+	idev = input_allocate_device();
+	if (idev == NULL) {
+		r = -ENOMEM;
+		goto err2;
+	}
+
+	/*
+	 * TODO: should be "TSC2005 touchscreen", but X has hardcoded these
+	 * strings and doesn't accept TSC2005 yet...
+	 */
+	idev->name = "TSC2301 touchscreen";
+	snprintf(ts->phys, sizeof(ts->phys), "%s/input-ts",
+		 dev_name(&ts->spi->dev));
+	idev->phys = ts->phys;
+
+	idev->evbit[0] = BIT(EV_ABS) | BIT(EV_KEY);
+	idev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y) | BIT(ABS_PRESSURE);
+	ts->idev = idev;
+
+	tsc2005_ts_setup_spi_xfer(ts);
+
+	/* These parameters should perhaps be configurable? */
+	input_set_abs_params(idev, ABS_X, 0, 4096, 4, 0);
+	input_set_abs_params(idev, ABS_Y, 0, 4096, 7, 0);
+	input_set_abs_params(idev, ABS_PRESSURE, 0, 1024, 2, 0);
+
+	tsc2005_start_scan(ts);
+
+	ts->irq_enabled = 1;
+	r = request_irq(ts->irq, tsc2005_ts_irq_handler,
+			IRQF_TRIGGER_FALLING | IRQF_DISABLED |
+			IRQF_SAMPLE_RANDOM, "tsc2005", ts);
+	if (r < 0) {
+		dev_err(&ts->spi->dev, "unable to get DAV IRQ");
+		goto err3;
+	}
+
+	set_irq_wake(ts->irq, 1);
+
+	r = input_register_device(idev);
+	if (r < 0) {
+		dev_err(&ts->spi->dev, "can't register touchscreen device\n");
+		goto err4;
+	}
+
+	/* We can tolerate these failing */
+	if (device_create_file(&ts->spi->dev, &dev_attr_pen_down));
+	if (device_create_file(&ts->spi->dev, &dev_attr_disable_ts));
+
+	return 0;
+err4:
+	free_irq(ts->irq, ts);
+err3:
+	tsc2005_stop_scan(ts);
+	input_free_device(idev);
+err2:
+#ifdef CONFIG_ARCH_OMAP
+	gpio_free(dav_gpio);
+#endif
+err1:
+	return r;
+}
+
+static int __devinit tsc2005_probe(struct spi_device *spi)
+{
+	struct tsc2005			*tsc;
+	struct tsc2005_platform_data	*pdata = spi->dev.platform_data;
+	int r;
+
+	if (!pdata) {
+		dev_dbg(&spi->dev, "no platform data?\n");
+		return -ENODEV;
+	}
+
+	tsc = kzalloc(sizeof(*tsc), GFP_KERNEL);
+	if (tsc == NULL)
+		return -ENOMEM;
+
+	dev_set_drvdata(&spi->dev, tsc);
+	tsc->spi = spi;
+	spi->dev.power.power_state = PMSG_ON;
+
+	if (pdata->reset_gpio >= 0) {
+		tsc->reset_gpio = pdata->reset_gpio;
+#ifdef CONFIG_ARCH_OMAP
+		r = gpio_request(tsc->reset_gpio, "FIXME");
+		if (r < 0)
+			goto err1;
+#endif
+	} else
+		tsc->reset_gpio = -1;
+
+	spi->mode = SPI_MODE_3;
+	spi->bits_per_word = 8;
+	/* The max speed might've been defined by the board-specific
+	 * struct */
+	if (!spi->max_speed_hz)
+		spi->max_speed_hz = TSC2005_HZ;
+
+	spi_setup(spi);
+
+	r = tsc2005_ts_init(tsc, pdata);
+	if (r)
+		goto err1;
+
+	return 0;
+
+err1:
+	kfree(tsc);
+	return r;
+}
+
+static int __devexit tsc2005_remove(struct spi_device *spi)
+{
+	struct tsc2005 *ts = dev_get_drvdata(&spi->dev);
+	unsigned long flags;
+
+	spin_lock_irqsave(&ts->lock, flags);
+	tsc2005_disable(ts);
+	spin_unlock_irqrestore(&ts->lock, flags);
+
+	device_remove_file(&ts->spi->dev, &dev_attr_disable_ts);
+	device_remove_file(&ts->spi->dev, &dev_attr_pen_down);
+
+	free_irq(ts->irq, ts);
+	input_unregister_device(ts->idev);
+
+#ifdef CONFIG_ARCH_OMAP
+	gpio_free(ts->dav_gpio);
+#endif
+	kfree(ts);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int tsc2005_suspend(struct spi_device *spi, pm_message_t mesg)
+{
+	struct tsc2005 *ts = dev_get_drvdata(&spi->dev);
+
+	spin_lock_irq(&ts->lock);
+	tsc2005_disable(ts);
+	spin_unlock_irq(&ts->lock);
+
+	return 0;
+}
+
+static int tsc2005_resume(struct spi_device *spi)
+{
+	struct tsc2005 *ts = dev_get_drvdata(&spi->dev);
+
+	spin_lock_irq(&ts->lock);
+	tsc2005_enable(ts);
+	spin_unlock_irq(&ts->lock);
+
+	return 0;
+}
+#endif
+
+static struct spi_driver tsc2005_driver = {
+	.driver = {
+		.name = "tsc2005",
+		.bus = &spi_bus_type,
+		.owner = THIS_MODULE,
+	},
+#ifdef CONFIG_PM
+	.suspend = tsc2005_suspend,
+	.resume = tsc2005_resume,
+#endif
+	.probe = tsc2005_probe,
+	.remove = __devexit_p(tsc2005_remove),
+};
+
+static int __init tsc2005_init(void)
+{
+	printk("TSC2005 driver initializing\n");
+
+	return spi_register_driver(&tsc2005_driver);
+}
+module_init(tsc2005_init);
+
+static void __exit tsc2005_exit(void)
+{
+	spi_unregister_driver(&tsc2005_driver);
+}
+module_exit(tsc2005_exit);
+
+MODULE_AUTHOR("Timo O. Karjalainen <timo.o.karjalainen@nokia.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/spi/tsc2301-core.c b/drivers/spi/tsc2301-core.c
new file mode 100644
index 0000000..5328722
--- /dev/null
+++ b/drivers/spi/tsc2301-core.c
@@ -0,0 +1,287 @@
+/*
+ * TSC2301 driver
+ *
+ * Copyright (C) 2005, 2006 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/tsc2301.h>
+
+u16 tsc2301_read_reg(struct tsc2301 *tsc, int reg)
+{
+	struct spi_transfer t[2];
+	struct spi_message m;
+	u16 data = 0, cmd;
+
+	cmd = reg;
+	cmd |= 0x8000;
+
+	memset(t, 0, sizeof(t));
+	spi_message_init(&m);
+	m.spi = tsc->spi;
+
+	t[0].tx_buf = &cmd;
+	t[0].rx_buf = NULL;
+	t[0].len = 2;
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].tx_buf = NULL;
+	t[1].rx_buf = &data;
+	t[1].len = 2;
+	spi_message_add_tail(&t[1], &m);
+
+	spi_sync(m.spi, &m);
+
+	return data;
+}
+
+void tsc2301_write_reg(struct tsc2301 *tsc, int reg, u16 val)
+{
+	struct spi_transfer t;
+	struct spi_message m;
+	u16 data[2];
+
+	/* Now we prepare the command for transferring */
+	data[0] = reg;
+	data[1] = val;
+
+	spi_message_init(&m);
+	m.spi = tsc->spi;
+
+	memset(&t, 0, sizeof(t));
+	t.tx_buf = data;
+	t.rx_buf = NULL;
+	t.len = 4;
+	spi_message_add_tail(&t, &m);
+
+	spi_sync(m.spi, &m);
+}
+
+void tsc2301_write_kbc(struct tsc2301 *tsc, int val)
+{
+	u16 w;
+
+	w = tsc->config2_shadow;
+	w &= ~(0x03 << 14);
+	w |= (val & 0x03) << 14;
+	tsc2301_write_reg(tsc, TSC2301_REG_CONFIG2, w);
+	tsc->config2_shadow = w;
+}
+
+void tsc2301_write_pll(struct tsc2301 *tsc,
+		       int pll_n, int pll_a, int pll_pdc, int pct_e, int pll_o)
+{
+	u16 w;
+
+	w = tsc->config2_shadow;
+	w &= ~0x3fff;
+	w |= (pll_n & 0x0f) | ((pll_a & 0x0f) << 4) | ((pll_pdc & 0x0f) << 8);
+	w |= pct_e ? (1 << 12) : 0;
+	w |= pll_o ? (1 << 13) : 0;
+	tsc2301_write_reg(tsc, TSC2301_REG_CONFIG2, w);
+	tsc->config2_shadow = w;
+}
+
+void tsc2301_read_buf(struct tsc2301 *tsc, int reg, u16 *rx_buf, int len)
+{
+	struct spi_transfer t[2];
+	struct spi_message m;
+	u16 cmd, i;
+
+	cmd = reg;
+	cmd |= 0x8000;
+
+	spi_message_init(&m);
+	m.spi = tsc->spi;
+
+	memset(t, 0, sizeof(t));
+	t[0].tx_buf = &cmd;
+	t[0].rx_buf = NULL;
+	t[0].len = 2;
+	spi_message_add_tail(&t[0], &m);
+
+	t[1].tx_buf = NULL;
+	t[1].rx_buf = rx_buf;
+	t[1].len = 2 * len;
+	spi_message_add_tail(&t[1], &m);
+
+	spi_sync(m.spi, &m);
+
+	for (i = 0; i < len; i++)
+		printk(KERN_DEBUG "rx_buf[%d]: %04x\n", i, rx_buf[i]);
+}
+
+static int __devinit tsc2301_probe(struct spi_device *spi)
+{
+	struct tsc2301			*tsc;
+	struct tsc2301_platform_data	*pdata = spi->dev.platform_data;
+	int r;
+	u16 w;
+
+	if (!pdata) {
+		dev_dbg(&spi->dev, "no platform data?\n");
+		return -ENODEV;
+	}
+
+	tsc = kzalloc(sizeof(*tsc), GFP_KERNEL);
+	if (tsc == NULL)
+		return -ENOMEM;
+
+	dev_set_drvdata(&spi->dev, tsc);
+	tsc->spi = spi;
+
+	tsc->enable_clock = pdata->enable_clock;
+	tsc->disable_clock = pdata->disable_clock;
+
+	if (pdata->reset_gpio >= 0) {
+		tsc->reset_gpio = pdata->reset_gpio;
+		r = gpio_request(tsc->reset_gpio, "TSC2301 reset");
+		if (r < 0)
+			goto err1;
+		gpio_direction_output(tsc->reset_gpio, 1);
+		mdelay(1);
+		gpio_set_value(tsc->reset_gpio, 0);
+	} else
+		tsc->reset_gpio = -1;
+
+	spi->mode = SPI_MODE_1;
+	spi->bits_per_word = 16;
+	/* The max speed might've been defined by the board-specific
+	 * struct */
+	if (!spi->max_speed_hz)
+		spi->max_speed_hz = TSC2301_HZ;
+	spi_setup(spi);
+
+	/* Soft reset */
+	tsc2301_write_reg(tsc, TSC2301_REG_RESET, 0xbb00);
+	msleep(1);
+
+	w = tsc2301_read_reg(tsc, TSC2301_REG_ADC);
+	if (!(w & (1 << 14))) {
+		dev_err(&spi->dev, "invalid ADC reg value: %04x\n", w);
+		r = -ENODEV;
+		goto err1;
+	}
+
+	w = tsc2301_read_reg(tsc, TSC2301_REG_DAC);
+	if (!(w & (1 << 15))) {
+		dev_err(&spi->dev, "invalid DAC reg value: %04x\n", w);
+		r = -ENODEV;
+		goto err1;
+	}
+
+	/* Stop keypad scanning */
+	tsc2301_write_reg(tsc, TSC2301_REG_KEY, 0x4000);
+
+	/* We have to cache this for read-modify-write, since we can't
+	 * read back BIT15 */
+	w = tsc2301_read_reg(tsc, TSC2301_REG_CONFIG2);
+	/* By default BIT15 is set */
+	w |= 1 << 15;
+	tsc->config2_shadow = w;
+
+	r = tsc2301_kp_init(tsc, pdata);
+	if (r)
+		goto err1;
+	r = tsc2301_ts_init(tsc, pdata);
+	if (r)
+		goto err2;
+	return 0;
+
+	tsc2301_ts_exit(tsc);
+err2:
+	tsc2301_kp_exit(tsc);
+err1:
+	kfree(tsc);
+	return r;
+}
+
+static int __devexit tsc2301_remove(struct spi_device *spi)
+{
+	struct tsc2301 *tsc = dev_get_drvdata(&spi->dev);
+
+	tsc2301_ts_exit(tsc);
+	tsc2301_kp_exit(tsc);
+	if (tsc->reset_gpio >= 0)
+		gpio_free(tsc->reset_gpio);
+	kfree(tsc);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int tsc2301_suspend(struct spi_device *spi, pm_message_t mesg)
+{
+	struct tsc2301 *tsc = dev_get_drvdata(&spi->dev);
+	int r;
+
+	if ((r = tsc2301_kp_suspend(tsc)) < 0)
+		return r;
+	if ((r = tsc2301_ts_suspend(tsc)) < 0) {
+		tsc2301_kp_resume(tsc);
+		return r;
+	}
+
+	return 0;
+}
+
+static int tsc2301_resume(struct spi_device *spi)
+{
+	struct tsc2301 *tsc = dev_get_drvdata(&spi->dev);
+
+	tsc2301_ts_resume(tsc);
+	tsc2301_kp_resume(tsc);
+
+	return 0;
+}
+#endif
+
+static struct spi_driver tsc2301_driver = {
+	.driver = {
+		   .name = "tsc2301",
+		   .bus = &spi_bus_type,
+		   .owner = THIS_MODULE,
+	},
+#ifdef CONFIG_PM
+	.suspend = tsc2301_suspend,
+	.resume = tsc2301_resume,
+#endif
+	.probe = tsc2301_probe,
+	.remove = __devexit_p(tsc2301_remove),
+};
+
+static int __init tsc2301_init(void)
+{
+	printk("TSC2301 driver initializing\n");
+
+	return spi_register_driver(&tsc2301_driver);
+}
+module_init(tsc2301_init);
+
+static void __exit tsc2301_exit(void)
+{
+	spi_unregister_driver(&tsc2301_driver);
+}
+module_exit(tsc2301_exit);
+
+MODULE_AUTHOR("Juha Yrjl <juha.yrjola@nokia.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/omap/omapfb.h b/drivers/video/omap/omapfb.h
index 46e4714..e80d40b 100644
--- a/drivers/video/omap/omapfb.h
+++ b/drivers/video/omap/omapfb.h
@@ -203,6 +203,7 @@ struct omapfb_device {
 
 	struct omapfb_mem_desc		mem_desc;
 	struct fb_info			*fb_info[OMAPFB_PLANE_NUM];
+        struct platform_device  *dssdev;
 };
 
 #ifdef CONFIG_ARCH_OMAP1
@@ -223,5 +224,4 @@ extern int  omapfb_update_window_async(struct fb_info *fbi,
 				       struct omapfb_update_window *win,
 				       void (*callback)(void *),
 				       void *callback_data);
-
 #endif /* __OMAPFB_H */
diff --git a/drivers/video/omap/omapfb_main.c b/drivers/video/omap/omapfb_main.c
index c7f59a5..63a2b8e 100644
--- a/drivers/video/omap/omapfb_main.c
+++ b/drivers/video/omap/omapfb_main.c
@@ -26,6 +26,7 @@
  */
 #include <linux/platform_device.h>
 #include <linux/mm.h>
+#include <linux/slab.h>
 #include <linux/uaccess.h>
 
 #include <plat/dma.h>
@@ -83,6 +84,19 @@ static struct caps_table_struct color_caps[] = {
 	{ 1 << OMAPFB_COLOR_YUY422,	"YUY422", },
 };
 
+static void omapdss_release(struct device *dev)
+{
+}
+
+/* dummy device for clocks */
+struct platform_device omapdss_device = {
+	.name		= "omapdss",
+	.id		= -1,
+	.dev            = {
+		.release = omapdss_release,
+	},
+};
+
 /*
  * ---------------------------------------------------------------------------
  * LCD panel
@@ -473,10 +487,11 @@ static int set_color_mode(struct omapfb_plane_struct *plane,
 		return 0;
 	case 12:
 		var->bits_per_pixel = 16;
-		plane->color_mode = OMAPFB_COLOR_RGB444;
-		return 0;
 	case 16:
-		plane->color_mode = OMAPFB_COLOR_RGB565;
+		if (plane->fbdev->panel->bpp == 12)
+			plane->color_mode = OMAPFB_COLOR_RGB444;
+		else
+			plane->color_mode = OMAPFB_COLOR_RGB565;
 		return 0;
 	default:
 		return -EINVAL;
@@ -1700,6 +1715,7 @@ static int omapfb_do_probe(struct platform_device *pdev,
 
 	fbdev->dev = &pdev->dev;
 	fbdev->panel = panel;
+	fbdev->dssdev = &omapdss_device;
 	platform_set_drvdata(pdev, fbdev);
 
 	mutex_init(&fbdev->rqueue_mutex);
@@ -1814,8 +1830,16 @@ cleanup:
 
 static int omapfb_probe(struct platform_device *pdev)
 {
+	int r;
+
 	BUG_ON(fbdev_pdev != NULL);
 
+	r = platform_device_register(&omapdss_device);
+	if (r) {
+		dev_err(&pdev->dev, "can't register omapdss device\n");
+		return r;
+	}
+
 	/* Delay actual initialization until the LCD is registered */
 	fbdev_pdev = pdev;
 	if (fbdev_panel != NULL)
@@ -1843,6 +1867,9 @@ static int omapfb_remove(struct platform_device *pdev)
 	fbdev->state = OMAPFB_DISABLED;
 	omapfb_free_resources(fbdev, saved_state);
 
+	platform_device_unregister(&omapdss_device);
+	fbdev->dssdev = NULL;
+
 	return 0;
 }
 
diff --git a/drivers/video/omap/rfbi.c b/drivers/video/omap/rfbi.c
index fed7b1b..188e621 100644
--- a/drivers/video/omap/rfbi.c
+++ b/drivers/video/omap/rfbi.c
@@ -26,6 +26,7 @@
 #include <linux/interrupt.h>
 #include <linux/clk.h>
 #include <linux/io.h>
+#include <linux/platform_device.h>
 
 #include "omapfb.h"
 #include "dispc.h"
@@ -83,13 +84,13 @@ static inline u32 rfbi_read_reg(int idx)
 
 static int rfbi_get_clocks(void)
 {
-	rfbi.dss_ick = clk_get(rfbi.fbdev->dev, "ick");
+	rfbi.dss_ick = clk_get(&omapdss_device.dev, "ick");
 	if (IS_ERR(rfbi.dss_ick)) {
 		dev_err(rfbi.fbdev->dev, "can't get ick\n");
 		return PTR_ERR(rfbi.dss_ick);
 	}
 
-	rfbi.dss1_fck = clk_get(rfbi.fbdev->dev, "dss1_fck");
+	rfbi.dss1_fck = clk_get(&omapdss_device.dev, "dss1_fck");
 	if (IS_ERR(rfbi.dss1_fck)) {
 		dev_err(rfbi.fbdev->dev, "can't get dss1_fck\n");
 		clk_put(rfbi.dss_ick);
diff --git a/include/linux/spi/tsc2005.h b/include/linux/spi/tsc2005.h
new file mode 100644
index 0000000..dbc01f7
--- /dev/null
+++ b/include/linux/spi/tsc2005.h
@@ -0,0 +1,29 @@
+#ifndef _LINUX_SPI_TSC2005_H
+#define _LINUX_SPI_TSC2005_H
+
+#include <linux/types.h>
+
+struct tsc2005_platform_data {
+	s16	reset_gpio;
+	s16	dav_gpio;
+	s16	pen_int_gpio;
+	u16	ts_x_plate_ohm;
+	u32	ts_stab_time;	/* voltage settling time */
+	u8	ts_hw_avg;	/* HW assiseted averaging. Can be
+				   0, 4, 8, 16 samples per reading */
+	u32	ts_touch_pressure;	/* Pressure limit until we report a
+					   touch event. After that we switch
+					   to ts_max_pressure. */
+	u32	ts_pressure_max;/* Samples with bigger pressure value will
+				   be ignored, since the corresponding X, Y
+				   values are unreliable */
+	u32	ts_pressure_fudge;
+	u32	ts_x_max;
+	u32	ts_x_fudge;
+	u32	ts_y_max;
+	u32	ts_y_fudge;
+
+	unsigned ts_ignore_last : 1;
+};
+
+#endif
diff --git a/include/linux/spi/tsc2301.h b/include/linux/spi/tsc2301.h
new file mode 100644
index 0000000..62e5862
--- /dev/null
+++ b/include/linux/spi/tsc2301.h
@@ -0,0 +1,197 @@
+#ifndef _LINUX_SPI_TSC2301_H
+#define _LINUX_SPI_TSC2301_H
+
+#include <linux/types.h>
+#include <linux/timer.h>
+
+struct tsc2301_platform_data {
+	/*
+	 * Keypad
+	 */
+	s16	reset_gpio;
+	s16	keyb_int;
+	s16	keymap[16];	/* Set a key to a negative value if not used */
+	unsigned kp_rep:1;	/* Enable keypad repeating */
+	char    *keyb_name;     /* Keyboard device name */
+
+	/*
+	 * Touchscreen
+	 */
+	s16	dav_int;
+	u16	ts_x_plate_ohm;
+	u32	ts_stab_time;	/* voltage settling time */
+	u8	ts_hw_avg;	/* HW assiseted averaging. Can be
+				   0, 4, 8, 16 samples per reading */
+	u32	ts_max_pressure;/* Samples with bigger pressure value will
+				   be ignored, since the corresponding X, Y
+				   values are unreliable */
+	u32	ts_touch_pressure;	/* Pressure limit until we report a
+					   touch event. After that we switch
+					   to ts_max_pressure. */
+	u32	ts_pressure_fudge;
+	u32	ts_x_max;
+	u32	ts_x_fudge;
+	u32	ts_y_max;
+	u32	ts_y_fudge;
+
+	/*
+	 * Audio
+	 */
+	unsigned	pll_pdc:4;
+	unsigned	pll_a:4;
+	unsigned	pll_n:4;
+	unsigned	pll_output:1; /* Output PLL on GPIO_0 */
+
+	unsigned	mclk_ratio:2;
+	unsigned	i2s_sample_rate:4;
+	unsigned	i2s_format:2;
+	/* Mask for audio blocks to be powered down */
+	u16		power_down_blocks;
+
+	/* Called after codec has been initialized, can be NULL */
+	int (* codec_init)(struct device *tsc2301_dev);
+	/* Called when codec is being removed, can be NULL */
+	void (* codec_cleanup)(struct device *tsc2301_dev);
+	int	(*enable_clock)(struct device *dev);
+	void	(*disable_clock)(struct device *dev);
+
+	const struct tsc2301_mixer_gpio {
+		const char	*name;
+		unsigned	gpio:4;
+		unsigned	inverted:1;
+		unsigned	def_enable:1; /* enable by default */
+		unsigned	deactivate_on_pd:1; /* power-down flag */
+	} *mixer_gpios;
+	int	n_mixer_gpios;
+};
+
+struct tsc2301_kp;
+struct tsc2301_ts;
+struct tsc2301_mixer;
+
+struct tsc2301 {
+	struct spi_device	*spi;
+
+	s16			reset_gpio;
+	u16			config2_shadow;
+
+        struct tsc2301_kp	*kp;
+	struct tsc2301_ts	*ts;
+	struct tsc2301_mixer	*mixer;
+
+	int			(*enable_clock)(struct device *dev);
+	void			(*disable_clock)(struct device *dev);
+};
+
+
+#define TSC2301_HZ	33000000
+
+#define TSC2301_REG(page, addr)  (((page) << 11) | ((addr) << 5))
+#define TSC2301_REG_TO_PAGE(reg) (((reg) >> 11) & 0x03)
+#define TSC2301_REG_TO_ADDR(reg) (((reg) >> 5)  & 0x1f)
+
+#define TSC2301_REG_X		TSC2301_REG(0, 0)
+#define TSC2301_REG_Y		TSC2301_REG(0, 1)
+#define TSC2301_REG_Z1		TSC2301_REG(0, 2)
+#define TSC2301_REG_Z2		TSC2301_REG(0, 3)
+#define TSC2301_REG_KPDATA	TSC2301_REG(0, 4)
+#define TSC2301_REG_ADC		TSC2301_REG(1, 0)
+#define TSC2301_REG_KEY		TSC2301_REG(1, 1)
+#define TSC2301_REG_DAC		TSC2301_REG(1, 2)
+#define TSC2301_REG_REF		TSC2301_REG(1, 3)
+#define TSC2301_REG_RESET	TSC2301_REG(1, 4)
+#define TSC2301_REG_CONFIG	TSC2301_REG(1, 5)
+#define TSC2301_REG_CONFIG2	TSC2301_REG(1, 6)
+#define TSC2301_REG_KPMASK	TSC2301_REG(1, 16)
+#define TSC2301_REG_AUDCNTL	TSC2301_REG(2, 0)
+#define TSC2301_REG_ADCVOL	TSC2301_REG(2, 1)
+#define TSC2301_REG_DACVOL	TSC2301_REG(2, 2)
+#define TSC2301_REG_BPVOL	TSC2301_REG(2, 3)
+#define TSC2301_REG_KEYCTL	TSC2301_REG(2, 4)
+#define TSC2301_REG_PD_MISC	TSC2301_REG(2, 5)
+#define TSC2301_REG_GPIO	TSC2301_REG(2, 6)
+#define TSC2301_REG_ADCLKCFG	TSC2301_REG(2, 27)
+
+#define TSC2301_REG_PD_MISC_APD		(1 << 15)
+#define TSC2301_REG_PD_MISC_AVPD	(1 << 14)
+#define TSC2301_REG_PD_MISC_ABPD	(1 << 13)
+#define TSC2301_REG_PD_MISC_HAPD	(1 << 12)
+#define TSC2301_REG_PD_MISC_MOPD	(1 << 11)
+#define TSC2301_REG_PD_MISC_DAPD	(1 << 10)
+#define TSC2301_REG_PD_MISC_ADPDL	(1 << 9)
+#define TSC2301_REG_PD_MISC_ADPDR	(1 << 8)
+#define TSC2301_REG_PD_MISC_PDSTS	(1 << 7)
+#define TSC2301_REG_PD_MISC_MIBPD	(1 << 6)
+#define TSC2301_REG_PD_MISC_OTSYN	(1 << 2)
+
+/* I2S sample rate */
+#define TSC2301_I2S_SR_48000	0x00
+#define TSC2301_I2S_SR_44100	0x01
+#define TSC2301_I2S_SR_32000	0x02
+#define TSC2301_I2S_SR_24000	0x03
+#define TSC2301_I2S_SR_22050	0x04
+#define TSC2301_I2S_SR_16000	0x05
+#define TSC2301_I2S_SR_12000	0x06
+#define TSC2301_I2S_SR_11050	0x07
+#define TSC2301_I2S_SR_8000	0x08
+
+/* 16-bit, MSB-first. DAC Right-Justified, ADC Left-Justified */
+#define TSC2301_I2S_FORMAT0	0x00
+/* 20-bit, MSB-first. DAC Right-Justified, ADC Left-Justified */
+#define TSC2301_I2S_FORMAT1	0x01
+/* 20-bit, MSB-first. DAC Left-Justified, ADC Left-Justified */
+#define TSC2301_I2S_FORMAT2	0x02
+/* 20-bit, MSB-first */
+#define TSC2301_I2S_FORMAT3	0x03
+
+/* Master Clock Ratio */
+#define TSC2301_MCLK_256xFS	0x00 /* default */
+#define TSC2301_MCLK_384xFS	0x01
+#define TSC2301_MCLK_512xFS	0x02
+
+
+extern u16 tsc2301_read_reg(struct tsc2301 *tsc, int reg);
+extern void tsc2301_write_reg(struct tsc2301 *tsc, int reg, u16 val);
+extern void tsc2301_write_kbc(struct tsc2301 *tsc, int val);
+extern void tsc2301_write_pll(struct tsc2301 *tsc, int pll_n, int pll_a,
+			      int pll_pdc, int pct_e, int pll_o);
+extern void tsc2301_read_buf(struct tsc2301 *tsc, int reg, u16 *buf, int len);
+
+#define TSC2301_DECL_MOD(module)					\
+extern int  tsc2301_##module##_init(struct tsc2301 *tsc,		\
+			   struct tsc2301_platform_data *pdata);	\
+extern void tsc2301_##module##_exit(struct tsc2301 *tsc);		\
+extern int  tsc2301_##module##_suspend(struct tsc2301 *tsc);		\
+extern void tsc2301_##module##_resume(struct tsc2301 *tsc);
+
+#define TSC2301_DECL_EMPTY_MOD(module)					\
+static inline int tsc2301_##module##_init(struct tsc2301 *tsc,		\
+			   struct tsc2301_platform_data *pdata)		\
+{									\
+	return 0;							\
+}									\
+static inline void tsc2301_##module##_exit(struct tsc2301 *tsc) {}	\
+static inline int  tsc2301_##module##_suspend(struct tsc2301 *tsc)	\
+{									\
+	return 0;							\
+}									\
+static inline void tsc2301_##module##_resume(struct tsc2301 *tsc) {}
+
+#ifdef CONFIG_KEYBOARD_TSC2301
+TSC2301_DECL_MOD(kp)
+void tsc2301_kp_restart(struct tsc2301 *tsc);
+#else
+TSC2301_DECL_EMPTY_MOD(kp)
+static inline void tsc2301_kp_restart(struct tsc2301 *tsc) {}
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_TSC2301
+TSC2301_DECL_MOD(ts)
+#else
+TSC2301_DECL_EMPTY_MOD(ts)
+#endif
+
+extern void tsc2301_mixer_enable_mclk(struct device *tsc_dev);
+extern void tsc2301_mixer_disable_mclk(struct device *tsc_dev);
+
+#endif
diff --git a/sound/soc/codecs/tlv320aic3x.h b/sound/soc/codecs/tlv320aic3x.h
index 9af1c88..690b760 100644
--- a/sound/soc/codecs/tlv320aic3x.h
+++ b/sound/soc/codecs/tlv320aic3x.h
@@ -285,6 +285,11 @@ struct aic3x_setup_data {
 	unsigned int gpio_func[2];
 };
 
+struct aic3x_pdata {
+	int gpio_reset;
+        struct aic3x_setup_data *setup;
+};
+
 extern struct snd_soc_dai aic3x_dai;
 extern struct snd_soc_codec_device soc_codec_dev_aic3x;
 
