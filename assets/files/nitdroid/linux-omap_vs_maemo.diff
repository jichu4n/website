diff -ruN linux-omap-2.6/arch/arm/configs/n800_defconfig maemo_src/arch/arm/configs/n800_defconfig
--- linux-omap-2.6/arch/arm/configs/n800_defconfig	2011-02-06 20:17:24.756666605 -0500
+++ maemo_src/arch/arm/configs/n800_defconfig	2007-10-02 03:09:30.000000000 -0400
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.21-rc7-omap1
-# Mon Apr 23 08:46:31 2007
+# Linux kernel version: 2.6.21-omap1
+# Tue May 15 13:09:06 2007
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
@@ -146,6 +146,8 @@
 #
 # OMAP Feature Selections
 #
+# CONFIG_MACH_OMAP2420_DVFS is not set
+# CONFIG_ARCH_OMAP2420_DEBUG is not set
 CONFIG_OMAP_RESET_CLOCKS=y
 CONFIG_OMAP_BOOT_TAG=y
 CONFIG_OMAP_BOOT_REASON=y
@@ -181,6 +183,7 @@
 # OMAP Board Type
 #
 CONFIG_MACH_NOKIA_N800=y
+CONFIG_MACH_NOKIA_RX44=y
 CONFIG_MACH_OMAP2_TUSB6010=y
 # CONFIG_MACH_OMAP_H4 is not set
 # CONFIG_MACH_OMAP_APOLLON is not set
@@ -756,6 +759,7 @@
 # CONFIG_TOUCHSCREEN_TOUCHWIN is not set
 # CONFIG_TOUCHSCREEN_UCB1400 is not set
 CONFIG_TOUCHSCREEN_TSC2301=y
+# CONFIG_TOUCHSCREEN_TSC2046 is not set
 # CONFIG_INPUT_MISC is not set
 
 #
@@ -778,15 +782,13 @@
 #
 # Serial drivers
 #
-CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_8250_CONSOLE=y
-CONFIG_SERIAL_8250_NR_UARTS=4
-CONFIG_SERIAL_8250_RUNTIME_UARTS=4
-# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250 is not set
 
 #
 # Non-8250 serial port support
 #
+CONFIG_SERIAL_OMAP=y
+CONFIG_SERIAL_OMAP_CONSOLE=y
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
 CONFIG_UNIX98_PTYS=y
@@ -858,7 +860,11 @@
 # CONFIG_ISP1301_OMAP is not set
 # CONFIG_TPS65010 is not set
 # CONFIG_SENSORS_TLV320AIC23 is not set
+# CONFIG_TLV320AIC33_AUDIO is not set
+# CONFIG_SENSORS_TSL2563 is not set
 # CONFIG_GPIOEXPANDER_OMAP is not set
+# CONFIG_LM8323 is not set
+# CONFIG_LP5521 is not set
 CONFIG_MENELAUS=y
 # CONFIG_TWL4030_CORE is not set
 # CONFIG_SENSORS_MAX6875 is not set
@@ -884,6 +890,7 @@
 # SPI Protocol Masters
 #
 # CONFIG_SPI_AT25 is not set
+# CONFIG_SPI_TSC2005 is not set
 # CONFIG_SPI_TSC2101 is not set
 # CONFIG_SPI_TSC2102 is not set
 CONFIG_SPI_TSC2301=y
@@ -932,6 +939,7 @@
 # CONFIG_SENSORS_SMSC47M1 is not set
 # CONFIG_SENSORS_SMSC47M192 is not set
 # CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_TMP105 is not set
 # CONFIG_SENSORS_VT1211 is not set
 # CONFIG_SENSORS_W83781D is not set
 # CONFIG_SENSORS_W83791D is not set
@@ -996,7 +1004,9 @@
 #
 # CONFIG_VIDEO_PVRUSB2 is not set
 # CONFIG_VIDEO_USBVISION is not set
-# CONFIG_VIDEO_OMAP_CAMERA is not set
+CONFIG_VIDEO_OMAP_CAMERA=y
+# CONFIG_VIDEO_CAMERA_SENSOR_OV9640 is not set
+CONFIG_VIDEO_CAMERA_SENSOR_TCM825X=y
 
 #
 # Radio Adapters
@@ -1008,6 +1018,7 @@
 # Digital Video Broadcasting Devices
 #
 # CONFIG_DVB is not set
+CONFIG_VIDEO_BUF=y
 # CONFIG_USB_DABUSB is not set
 
 #
@@ -1027,7 +1038,7 @@
 # CONFIG_FB_TILEBLITTING is not set
 
 #
-# Frambuffer hardware drivers
+# Frame buffer hardware drivers
 #
 # CONFIG_FB_S1D13XXX is not set
 CONFIG_FB_OMAP=y
@@ -1136,6 +1147,7 @@
 # CONFIG_USB_SL811_HCD is not set
 CONFIG_USB_MUSB_HDRC=y
 CONFIG_USB_TUSB6010=y
+# CONFIG_USB_TUSB6010_TEST is not set
 # CONFIG_USB_MUSB_HOST is not set
 # CONFIG_USB_MUSB_PERIPHERAL is not set
 CONFIG_USB_MUSB_OTG=y
@@ -1287,7 +1299,10 @@
 #
 # MMC/SD Card support
 #
-# CONFIG_MMC is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_OMAP=y
 
 #
 # Real Time Clock
@@ -1307,7 +1322,7 @@
 CONFIG_CBUS_RETU_POWERBUTTON=y
 CONFIG_CBUS_RETU_RTC=y
 CONFIG_CBUS_RETU_WDT=y
-# CONFIG_CBUS_RETU_HEADSET is not set
+CONFIG_CBUS_RETU_HEADSET=y
 
 #
 # File systems
diff -ruN linux-omap-2.6/arch/arm/configs/nokia_2420_defconfig maemo_src/arch/arm/configs/nokia_2420_defconfig
--- linux-omap-2.6/arch/arm/configs/nokia_2420_defconfig	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/configs/nokia_2420_defconfig	2011-02-06 20:12:09.463333273 -0500
@@ -0,0 +1,1634 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.21-omap1
+# Wed Jul 30 11:33:54 2008
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_IPC_NS is not set
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_UTS_NS is not set
+# CONFIG_AUDIT is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_SYSFS_DEPRECATED=y
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_SLAB=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# Block layer
+#
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+CONFIG_ARCH_OMAP=y
+
+#
+# TI OMAP Implementations
+#
+CONFIG_ARCH_OMAP_OTG=y
+# CONFIG_ARCH_OMAP1 is not set
+CONFIG_ARCH_OMAP2=y
+
+#
+# OMAP Feature Selections
+#
+CONFIG_MACH_OMAP2420_DVFS=y
+CONFIG_ARCH_OMAP2420_DEBUG=y
+CONFIG_ARCH_OMAP2420_OBSERVABILITY=m
+CONFIG_ARCH_OMAP2420_PEEK_N_POKE=m
+CONFIG_ARCH_OMAP2420_SNAPSHOT=m
+CONFIG_ARCH_OMAP2420_DMA_DRAIN=y
+CONFIG_OMAP_RESET_CLOCKS=y
+CONFIG_OMAP_BOOT_TAG=y
+CONFIG_OMAP_BOOT_REASON=y
+CONFIG_OMAP_COMPONENT_VERSION=y
+CONFIG_OMAP_GPIO_SWITCH=y
+# CONFIG_OMAP_MUX is not set
+CONFIG_OMAP_SEC=m
+CONFIG_OMAP_STI=y
+CONFIG_OMAP_STI_CONSOLE=y
+# CONFIG_OMAP_MCBSP is not set
+CONFIG_OMAP_MMU_FWK=y
+CONFIG_OMAP_MBOX_FWK=y
+# CONFIG_OMAP_MPU_TIMER is not set
+CONFIG_OMAP_32K_TIMER=y
+CONFIG_OMAP_32K_TIMER_HZ=128
+CONFIG_OMAP_DM_TIMER=y
+# CONFIG_OMAP_LL_DEBUG_UART1 is not set
+# CONFIG_OMAP_LL_DEBUG_UART2 is not set
+CONFIG_OMAP_LL_DEBUG_UART3=y
+CONFIG_OMAP_DSP=y
+# CONFIG_OMAP_DSP_MBCMD_VERBOSE is not set
+CONFIG_OMAP_DSP_TASK_MULTIOPEN=y
+CONFIG_OMAP_DSP_FBEXPORT=y
+CONFIG_OMAP_DSP_PAUSING=y
+# CONFIG_MACH_OMAP_GENERIC is not set
+
+#
+# OMAP Core Type
+#
+CONFIG_ARCH_OMAP24XX=y
+CONFIG_ARCH_OMAP2420=y
+# CONFIG_ARCH_OMAP2430 is not set
+CONFIG_ARCH_OMAP2420_HS=m
+
+#
+# OMAP Board Type
+#
+CONFIG_MACH_NOKIA_N800=y
+CONFIG_MACH_NOKIA_RX44=y
+CONFIG_MACH_NOKIA_RX48=y
+CONFIG_MACH_OMAP2_TUSB6010=y
+# CONFIG_MACH_OMAP_H4 is not set
+# CONFIG_MACH_OMAP_APOLLON is not set
+# CONFIG_MACH_OMAP_2430SDP is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_V6=y
+# CONFIG_CPU_32v6K is not set
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+# CONFIG_OUTER_CACHE is not set
+
+#
+# Bus support
+#
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+# CONFIG_PREEMPT is not set
+CONFIG_NO_IDLE_HZ=y
+CONFIG_HZ=128
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_LEDS=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x10C08000
+CONFIG_ZBOOT_ROM_BSS=0x10200000
+# CONFIG_ZBOOT_ROM is not set
+CONFIG_CMDLINE="root=1f03 rootfstype=jffs2 ro console=tty0 console=ttyMTD5"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+# CONFIG_CPU_FREQ_DEBUG is not set
+CONFIG_CPU_FREQ_STAT=y
+# CONFIG_CPU_FREQ_STAT_DETAILS is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_NULL=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_NULL=y
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_LEGACY is not set
+# CONFIG_PM_DEBUG is not set
+# CONFIG_PM_SYSFS_DEPRECATED is not set
+# CONFIG_APM_EMULATION is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=m
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+CONFIG_IPV6=m
+# CONFIG_IPV6_PRIVACY is not set
+CONFIG_IPV6_ROUTER_PREF=y
+# CONFIG_IPV6_ROUTE_INFO is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=m
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_NETLABEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+# CONFIG_NF_CONNTRACK_ENABLED is not set
+CONFIG_NETFILTER_XTABLES=y
+# CONFIG_NETFILTER_XT_TARGET_CLASSIFY is not set
+# CONFIG_NETFILTER_XT_TARGET_MARK is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_COMMENT is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+# CONFIG_NETFILTER_XT_MATCH_LIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_MAC is not set
+# CONFIG_NETFILTER_XT_MATCH_MARK is not set
+# CONFIG_NETFILTER_XT_MATCH_POLICY is not set
+# CONFIG_NETFILTER_XT_MATCH_MULTIPORT is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+# CONFIG_NETFILTER_XT_MATCH_STATISTIC is not set
+# CONFIG_NETFILTER_XT_MATCH_STRING is not set
+# CONFIG_NETFILTER_XT_MATCH_TCPMSS is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_IPRANGE is not set
+# CONFIG_IP_NF_MATCH_TOS is not set
+# CONFIG_IP_NF_MATCH_RECENT is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_AH is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+# CONFIG_IP_NF_MATCH_OWNER is not set
+# CONFIG_IP_NF_MATCH_ADDRTYPE is not set
+CONFIG_IP_NF_FILTER=y
+# CONFIG_IP_NF_TARGET_REJECT is not set
+# CONFIG_IP_NF_TARGET_LOG is not set
+# CONFIG_IP_NF_TARGET_ULOG is not set
+CONFIG_IP_NF_TARGET_IDLETIMER=y
+# CONFIG_IP_NF_MANGLE is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# IPv6: Netfilter Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP6_NF_QUEUE is not set
+CONFIG_IP6_NF_IPTABLES=m
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_OWNER is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+CONFIG_IP6_NF_FILTER=m
+# CONFIG_IP6_NF_TARGET_LOG is not set
+# CONFIG_IP6_NF_TARGET_REJECT is not set
+# CONFIG_IP6_NF_MANGLE is not set
+# CONFIG_IP6_NF_RAW is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+CONFIG_BT=y
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+# CONFIG_BT_BNEP_MC_FILTER is not set
+# CONFIG_BT_BNEP_PROTO_FILTER is not set
+CONFIG_BT_HIDP=y
+
+#
+# Bluetooth device drivers
+#
+# CONFIG_BT_HCIUSB is not set
+# CONFIG_BT_HCIUART is not set
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+# CONFIG_BT_HCIBRF6150 is not set
+CONFIG_BT_HCIH4P=y
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_IEEE80211 is not set
+CONFIG_WIRELESS_EXT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+# CONFIG_CONNECTOR is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+CONFIG_MTD_OOPS=y
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+CONFIG_MTD_ONENAND=y
+# CONFIG_MTD_ONENAND_VERIFY_WRITE is not set
+# CONFIG_MTD_ONENAND_GENERIC is not set
+CONFIG_MTD_ONENAND_OMAP2=y
+CONFIG_MTD_ONENAND_OTP=y
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+# CONFIG_PNPACPI is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Serial ATA (prod) and Parallel ATA (experimental) drivers
+#
+# CONFIG_ATA is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+
+#
+# PHY device support
+#
+
+#
+# Ethernet (10 or 100Mbit)
+#
+# CONFIG_NET_ETHERNET is not set
+CONFIG_MII=y
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+# CONFIG_NET_WIRELESS_RTNETLINK is not set
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_HOSTAP is not set
+
+#
+# WiMAX (IEEE 802.16)
+#
+CONFIG_NET_PC2400M=m
+# CONFIG_NET_PC2400M_SPI_48MHZ is not set
+CONFIG_NET_PC2400M_ALLOW_SPI_AGGREGATION=y
+# CONFIG_NET_PC2400M_ENABLE_CHIPSET_INTERNAL_RESET is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+CONFIG_PPP=y
+# CONFIG_PPP_MULTILINK is not set
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_BSDCOMP=y
+# CONFIG_PPP_MPPE is not set
+# CONFIG_PPPOE is not set
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_OMAP is not set
+# CONFIG_KEYBOARD_GPIO is not set
+CONFIG_KEYBOARD_TSC2301=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_UCB1400 is not set
+CONFIG_TOUCHSCREEN_TSC2005=y
+CONFIG_TOUCHSCREEN_TSC2301=y
+# CONFIG_TOUCHSCREEN_TSC2046 is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_OMAP=y
+CONFIG_SERIAL_OMAP_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_OMAP_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_HW_RANDOM=m
+CONFIG_HW_RANDOM_OMAP=m
+# CONFIG_NVRAM is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+# CONFIG_I2C_CHARDEV is not set
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_OMAP=y
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_ISP1301_OMAP is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_SENSORS_TLV320AIC23 is not set
+CONFIG_SENSORS_TSL2563=y
+# CONFIG_GPIOEXPANDER_OMAP is not set
+CONFIG_LM8323=y
+CONFIG_LP5521=y
+CONFIG_MENELAUS=y
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+CONFIG_SPI_OMAP24XX=y
+CONFIG_SPI_OMAP_PAUSING=y
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_AT25 is not set
+# CONFIG_SPI_TSC2005 is not set
+# CONFIG_SPI_TSC2101 is not set
+# CONFIG_SPI_TSC2102 is not set
+CONFIG_SPI_TSC2301=y
+CONFIG_SPI_TSC2301_AUDIO=y
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Hardware Monitoring support
+#
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_FSCPOS is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+CONFIG_SENSORS_TMP105=y
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Misc devices
+#
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_SM501 is not set
+
+#
+# LED devices
+#
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_OMAP_DEBUG is not set
+# CONFIG_LEDS_OMAP is not set
+CONFIG_LEDS_OMAP_PWM=y
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+
+#
+# Multimedia devices
+#
+CONFIG_VIDEO_DEV=y
+# CONFIG_VIDEO_V4L1 is not set
+# CONFIG_VIDEO_V4L1_COMPAT is not set
+CONFIG_VIDEO_V4L2=y
+
+#
+# Video Capture Adapters
+#
+
+#
+# Video Capture Adapters
+#
+# CONFIG_VIDEO_ADV_DEBUG is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+
+#
+# V4L USB devices
+#
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_USBVISION is not set
+CONFIG_VIDEO_OMAP_CAMERA=y
+# CONFIG_VIDEO_CAMERA_SENSOR_OV9640 is not set
+CONFIG_VIDEO_CAMERA_SENSOR_TCM825X=y
+
+#
+# Radio Adapters
+#
+CONFIG_RADIO_TEA5761=y
+# CONFIG_USB_DSBR is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+CONFIG_VIDEO_BUF=y
+# CONFIG_USB_DABUSB is not set
+
+#
+# Graphics support
+#
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_CFB_FILLRECT is not set
+# CONFIG_FB_CFB_COPYAREA is not set
+# CONFIG_FB_CFB_IMAGEBLIT is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_OMAP=y
+CONFIG_FB_OMAP_LCDC_EXTERNAL=y
+# CONFIG_FB_OMAP_LCDC_HWA742 is not set
+CONFIG_FB_OMAP_LCDC_BLIZZARD=y
+CONFIG_FB_OMAP_MANUAL_UPDATE=y
+CONFIG_FB_OMAP_LCD_MIPID=y
+CONFIG_FB_OMAP_BOOTLOADER_INIT=y
+CONFIG_FB_OMAP_CONSISTENT_DMA_SIZE=4
+CONFIG_FB_OMAP_PAUSING=y
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+
+#
+# Logo configuration
+#
+# CONFIG_LOGO is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA ARM devices
+#
+# CONFIG_SND_OMAP_AIC23 is not set
+CONFIG_SND_AIC33=y
+# CONFIG_SND_OMAP_TSC2101 is not set
+# CONFIG_SND_SX1 is not set
+# CONFIG_SND_OMAP_TSC2102 is not set
+CONFIG_SND_OMAP24XX_EAC=y
+
+#
+# USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+
+#
+# SoC audio support
+#
+# CONFIG_SND_SOC is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# HID Devices
+#
+CONFIG_HID=y
+# CONFIG_HID_DEBUG is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+CONFIG_USB_DEBUG=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DYNAMIC_MINORS=y
+CONFIG_USB_SUSPEND=y
+CONFIG_USB_OTG=y
+CONFIG_USB_OTG_WHITELIST=y
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+CONFIG_USB_MUSB_HDRC=y
+CONFIG_USB_TUSB6010=y
+CONFIG_USB_TUSB6010_TEST=y
+# CONFIG_USB_MUSB_HOST is not set
+# CONFIG_USB_MUSB_PERIPHERAL is not set
+CONFIG_USB_MUSB_OTG=y
+CONFIG_USB_GADGET_MUSB_HDRC=y
+CONFIG_USB_MUSB_HDRC_HCD=y
+CONFIG_USB_MUSB_HSET=y
+# CONFIG_MUSB_PIO_ONLY is not set
+# CONFIG_USB_INVENTRA_DMA is not set
+# CONFIG_USB_TI_CPPI_DMA is not set
+CONFIG_USB_TUSB_OMAP_DMA=y
+CONFIG_USB_MUSB_LOGLEVEL=1
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+CONFIG_USB_LIBUSUAL=y
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_TOUCHSCREEN is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_ATI_REMOTE2 is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+# CONFIG_USB_GTCO is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+CONFIG_USB_RTL8150=y
+# CONFIG_USB_USBNET_MII is not set
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_CDCETHER=y
+# CONFIG_USB_NET_DM9601 is not set
+# CONFIG_USB_NET_GL620A is not set
+CONFIG_USB_NET_NET1080=y
+CONFIG_USB_NET_PLUSB=y
+# CONFIG_USB_NET_MCS7830 is not set
+CONFIG_USB_NET_RNDIS_HOST=y
+CONFIG_USB_NET_CDC_SUBSET=y
+# CONFIG_USB_ALI_M5632 is not set
+# CONFIG_USB_AN2720 is not set
+CONFIG_USB_BELKIN=y
+CONFIG_USB_ARMLINUX=y
+# CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_KC2190 is not set
+CONFIG_USB_NET_ZAURUS=y
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+CONFIG_USB_SISUSBVGA=m
+# CONFIG_USB_SISUSBVGA_CON is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+CONFIG_USB_TEST=y
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=m
+CONFIG_USB_GADGET_DEBUG_FILES=y
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+CONFIG_USB_GADGETFS=m
+CONFIG_USB_FILE_STORAGE=m
+CONFIG_USB_FILE_STORAGE_TEST=y
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_OMAP=y
+CONFIG_MMC_PAUSING=y
+
+#
+# Real Time Clock
+#
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+
+#
+# CBUS support
+#
+CONFIG_CBUS=y
+CONFIG_CBUS_TAHVO=y
+CONFIG_CBUS_TAHVO_USER=y
+# CONFIG_CBUS_TAHVO_USB is not set
+CONFIG_CBUS_RETU=y
+CONFIG_CBUS_RETU_USER=y
+CONFIG_CBUS_RETU_POWERBUTTON=y
+CONFIG_CBUS_RETU_RTC=y
+CONFIG_CBUS_RETU_WDT=y
+CONFIG_CBUS_RETU_HEADSET=y
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=m
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=m
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+# CONFIG_EXT4DEV_FS is not set
+CONFIG_JBD=m
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=m
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+CONFIG_JFFS2_SUMMARY=y
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_SYSFS is not set
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_LZO=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_JFFS2_CMODE_NONE is not set
+CONFIG_JFFS2_CMODE_PRIORITY=y
+# CONFIG_JFFS2_CMODE_SIZE is not set
+# CONFIG_JFFS2_CMODE_FAVOURLZO is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+CONFIG_NLS_ISO8859_15=y
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Distributed Lock Manager
+#
+# CONFIG_DLM is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_DETECT_SOFTLOCKUP=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_LIST is not set
+CONFIG_FRAME_POINTER=y
+CONFIG_FORCED_INLINING=y
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_FAULT_INJECTION is not set
+
+#
+# GCOV coverage profiling
+#
+# CONFIG_GCOV_PROFILE is not set
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_LL is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+CONFIG_SECURITY=y
+# CONFIG_SECURITY_NETWORK is not set
+# CONFIG_SECURITY_CAPABILITIES is not set
+# CONFIG_SECURITY_ROOTPLUG is not set
+CONFIG_SECURITY_LOWMEM=y
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
diff -ruN linux-omap-2.6/arch/arm/kernel/module.c maemo_src/arch/arm/kernel/module.c
--- linux-omap-2.6/arch/arm/kernel/module.c	2011-02-06 19:44:42.433333274 -0500
+++ maemo_src/arch/arm/kernel/module.c	2007-10-02 03:09:30.000000000 -0400
@@ -33,6 +33,10 @@
 #define MODULE_START	(((unsigned long)&_etext + ~PGDIR_MASK) & PGDIR_MASK)
 #endif
 
+#ifdef CONFIG_GCOV_PROFILE
+#define R_ARM_TARGET1 38
+#endif
+
 #ifdef CONFIG_MMU
 void *module_alloc(unsigned long size)
 {
@@ -103,6 +107,10 @@
 		loc = dstsec->sh_addr + rel->r_offset;
 
 		switch (ELF32_R_TYPE(rel->r_info)) {
+
+#ifdef CONFIG_GCOV_PROFILE
+		case R_ARM_TARGET1:
+#endif
 		case R_ARM_ABS32:
 			*(u32 *)loc += sym->st_value;
 			break;
diff -ruN linux-omap-2.6/arch/arm/mach-omap1/mailbox.c maemo_src/arch/arm/mach-omap1/mailbox.c
--- linux-omap-2.6/arch/arm/mach-omap1/mailbox.c	2011-02-06 20:17:24.869999939 -0500
+++ maemo_src/arch/arm/mach-omap1/mailbox.c	2007-10-02 03:09:30.000000000 -0400
@@ -1,12 +1,24 @@
 /*
  * Mailbox reservation modules for DSP
  *
- * Copyright (C) 2006 Nokia Corporation
- * Written by: Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
+ * Copyright (C) 2006-2007 Nokia Corporation
+ *
+ * Contact: Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
  *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 
 #include <linux/kernel.h>
diff -ruN linux-omap-2.6/arch/arm/mach-omap1/mmu.c maemo_src/arch/arm/mach-omap1/mmu.c
--- linux-omap-2.6/arch/arm/mach-omap1/mmu.c	2011-02-06 20:17:24.869999939 -0500
+++ maemo_src/arch/arm/mach-omap1/mmu.c	2007-10-02 03:09:30.000000000 -0400
@@ -3,25 +3,29 @@
  *
  * Support for non-MPU OMAP1 MMUs.
  *
- * Copyright (C) 2002-2005 Nokia Corporation
+ * Copyright (C) 2002-2007 Nokia Corporation
+ *
+ * Contact: Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
  *
  * Written by Toshihiro Kobayashi <toshihiro.kobayashi@nokia.com>
- *        and Paul Mundt <paul.mundt@nokia.com>
+ *        and Paul Mundt <lethal@linux-sh.org>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
  */
+
 #include <linux/types.h>
 #include <linux/init.h>
 #include <linux/rwsem.h>
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/board-n800-audio.c maemo_src/arch/arm/mach-omap2/board-n800-audio.c
--- linux-omap-2.6/arch/arm/mach-omap2/board-n800-audio.c	2011-02-06 20:17:25.069999940 -0500
+++ maemo_src/arch/arm/mach-omap2/board-n800-audio.c	2011-02-06 20:12:09.866666606 -0500
@@ -21,23 +21,30 @@
  *
  */
 
+#include <linux/delay.h>
 #include <linux/err.h>
 #include <linux/clk.h>
 #include <linux/platform_device.h>
 #include <linux/spi/tsc2301.h>
+#include <linux/tlv320aic33.h>
 
 #include <asm/io.h>
+#include <asm/mach-types.h>
 #include <asm/arch/eac.h>
+#include <asm/arch/gpio.h>
 
 #include "../plat-omap/dsp/dsp_common.h"
 
-#if defined(CONFIG_SPI_TSC2301_AUDIO) && defined(CONFIG_SND_OMAP24XX_EAC)
+#if (defined(CONFIG_SPI_TSC2301_AUDIO) || defined(CONFIG_SND_AIC33)) && \
+     defined(CONFIG_SND_OMAP24XX_EAC)
 #define AUDIO_ENABLED
 
 static struct clk *sys_clkout2;
+/* eac_fck is used only to keep sys_clkout2 active while in autoidle */
+static struct clk *eac_fck;
 static struct clk *func96m_clk;
 static struct device *eac_device;
-static struct device *tsc2301_device;
+static struct device *codec_device;
 
 static int enable_audio;
 static int audio_ok;
@@ -97,38 +104,69 @@
 
 static int n800_eac_enable_ext_clocks(struct device *dev)
 {
-	BUG_ON(tsc2301_device == NULL);
-	n800_enable_eac_mux();
-	tsc2301_mixer_enable_mclk(tsc2301_device);
+	BUG_ON(codec_device == NULL);
+	tsc2301_mixer_enable_mclk(codec_device);
 
 	return 0;
 }
 
 static void n800_eac_disable_ext_clocks(struct device *dev)
 {
-	BUG_ON(tsc2301_device == NULL);
-	tsc2301_mixer_disable_mclk(tsc2301_device);
-	n800_disable_eac_mux();
+	BUG_ON(codec_device == NULL);
+	tsc2301_mixer_disable_mclk(codec_device);
 }
 
 static int n800_audio_set_power(void *pdata, int dac, int adc)
 {
-	BUG_ON(pdata != tsc2301_device);
-	tsc2301_mixer_set_power(tsc2301_device, dac, adc);
+	int enable = (dac || adc);
+
+	BUG_ON(codec_device == NULL);
+	if (enable)
+		n800_enable_eac_mux();
+
+	tsc2301_mixer_set_power(codec_device, dac, adc);
+
+	if (!enable)
+		n800_disable_eac_mux();
+
+	return 0;
+}
+
+static int rx44_audio_set_power(void *pdata, int dac, int adc)
+{
+	int enable = (dac || adc);
+
+	BUG_ON(codec_device == NULL);
+	if (enable) {
+		n800_enable_eac_mux();
+		aic33_enable_mclk(codec_device);
+	}
+
+	aic33_mixer_set_power(codec_device, dac, adc);
+
+	if (!enable) {
+		aic33_disable_mclk(codec_device);
+		n800_disable_eac_mux();
+	}
 
 	return 0;
 }
 
 static int n800_audio_register_controls(void *pdata, struct snd_card *card)
 {
-	BUG_ON(pdata != tsc2301_device);
-	return tsc2301_mixer_register_controls(tsc2301_device, card);
+	BUG_ON(codec_device == NULL);
+	if (machine_is_nokia_n800())
+		return tsc2301_mixer_register_controls(codec_device, card);
+	else if (machine_is_nokia_rx44() || machine_is_nokia_rx48())
+		return aic33_mixer_register_controls(codec_device, card);
+
+	return 0;
 }
 
 static struct eac_codec n800_eac_codec = {
 	.mclk_src = EAC_MCLK_EXT_2x12288000,
 	.codec_mode = EAC_CODEC_I2S_MASTER,
-	.codec_conf.i2s.polarity_changed_mode = 0,
+	.codec_conf.i2s.polarity_changed_mode = 1,
 	.codec_conf.i2s.sync_delay_enable = 0,
 	.default_rate = 48000,
 	.set_power = n800_audio_set_power,
@@ -136,13 +174,31 @@
 	.short_name = "TSC2301",
 };
 
+static struct eac_codec rx44_eac_codec = {
+	.mclk_src = EAC_MCLK_INT_11290000,
+	.codec_mode = EAC_CODEC_I2S_SLAVE,
+	.codec_conf.i2s.polarity_changed_mode = 0,
+	.codec_conf.i2s.sync_delay_enable = 1,
+	.default_rate = 48000,
+	.set_power = rx44_audio_set_power,
+	.register_controls = n800_audio_register_controls,
+	.short_name = "TLV320AIC33",
+};
+
 static int n800_register_codec(void)
 {
 	int r, do_enable = 0;
 	unsigned long flags;
 
-	n800_eac_codec.private_data = tsc2301_device;
-	r = eac_register_codec(eac_device, &n800_eac_codec);
+	if (machine_is_nokia_n800()) {
+		n800_eac_codec.private_data = codec_device;
+		r = eac_register_codec(eac_device, &n800_eac_codec);
+	} else if (machine_is_nokia_rx44() || machine_is_nokia_rx48()) {
+		rx44_eac_codec.private_data = codec_device;
+		r = eac_register_codec(eac_device, &rx44_eac_codec);
+	} else
+		return 0;
+
 	if (r < 0)
 		return r;
 	spin_lock_irqsave(&audio_lock, flags);
@@ -168,7 +224,7 @@
 
 	BUG_ON(eac_device != NULL);
 	eac_device = dev;
-	if (tsc2301_device != NULL) {
+	if (codec_device != NULL) {
 		r = n800_register_codec();
 		if (r < 0)
 			return r;
@@ -180,7 +236,7 @@
 static void n800_eac_cleanup(struct device *dev)
 {
 	eac_device = NULL;
-	if (tsc2301_device != NULL)
+	if (codec_device != NULL)
 		n800_unregister_codec();
 }
 
@@ -189,25 +245,43 @@
 	sys_clkout2 = clk_get(dev, "sys_clkout2");
 	if (IS_ERR(sys_clkout2)) {
 		dev_err(dev, "Could not get sys_clkout2\n");
-		return -ENODEV;
+		goto err1;
 	}
-	/* configure 12 MHz output on SYS_CLKOUT2. Therefore we must use
-	 * 96 MHz as its parent in order to get 12 MHz */
+	/*
+	 * configure 12 MHz output on SYS_CLKOUT2. Therefore we must use
+	 * 96 MHz as its parent in order to get 12 MHz
+	 */
 	func96m_clk = clk_get(dev, "func_96m_ck");
 	if (IS_ERR(func96m_clk)) {
 		dev_err(dev, "Could not get func 96M clock\n");
-		clk_put(sys_clkout2);
-		return -ENODEV;
+		goto err2;
+	}
+	/*
+	 * REVISIT: only use for eac_fck is to keep 96 MHz APLL active while
+	 * MPU is in idle since sys_clkout2 cannot prevent it. This could be
+	 * removed if one invents SW workaround in OMAP2 clock framework
+	 */
+	eac_fck = clk_get(dev, "eac_fck");
+	if (IS_ERR(eac_fck)) {
+		dev_err(dev, "Could not get eac_fck\n");
+		goto err3;
 	}
 
 	clk_set_parent(sys_clkout2, func96m_clk);
 	clk_set_rate(sys_clkout2, 12000000);
 
 	return 0;
+err3:
+	clk_put(func96m_clk);
+err2:
+	clk_put(sys_clkout2);
+err1:
+	return -ENODEV;
 }
 
 static void n800_codec_put_clocks(struct device *dev)
 {
+	clk_put(eac_fck);
 	clk_put(func96m_clk);
 	clk_put(sys_clkout2);
 }
@@ -215,12 +289,14 @@
 static int n800_codec_enable_clock(struct device *dev)
 {
 	n800_enable_clkout2_mux();
+	clk_enable(eac_fck);
 	return clk_enable(sys_clkout2);
 }
 
 static void n800_codec_disable_clock(struct device *dev)
 {
 	clk_disable(sys_clkout2);
+	clk_disable(eac_fck);
 	n800_disable_clkout2_mux();
 }
 
@@ -228,8 +304,8 @@
 {
 	int r;
 
-	BUG_ON(tsc2301_device != NULL);
-	tsc2301_device = dev;
+	BUG_ON(codec_device != NULL);
+	codec_device = dev;
 	if ((r = n800_codec_get_clocks(dev)) < 0)
 		return r;
 	if (eac_device != NULL) {
@@ -244,7 +320,7 @@
 
 static void n800_codec_cleanup(struct device *dev)
 {
-	tsc2301_device = NULL;
+	codec_device = NULL;
 	if (eac_device != NULL)
 		n800_unregister_codec();
 	n800_codec_put_clocks(dev);
@@ -257,6 +333,11 @@
 	.disable_ext_clocks = n800_eac_disable_ext_clocks,
 };
 
+static struct eac_platform_data rx44_eac_data = {
+	.init = n800_eac_init,
+	.cleanup = n800_eac_cleanup,
+};
+
 static const struct tsc2301_mixer_gpio n800_mixer_gpios[] = {
 	{
 		.name			= "Headset Amplifier",
@@ -305,11 +386,98 @@
 	tc->disable_clock = n800_codec_disable_clock;
 }
 
+#define RX44_AIC33_RESET_GPIO	118
+#define RX44_HEADSET_AMP_GPIO	10
+#define RX44_SPEAKER_AMP_GPIO	101
+
+static void rx44_aic33_reset(int reset_active)
+{
+	omap_set_gpio_dataout(RX44_AIC33_RESET_GPIO, !reset_active);
+}
+
+static void rx44_headset_amplifier_ctrl(struct device *dev, int on)
+{
+	/*
+	 * Wait until AIC33 HP output to amplifier is biased before activating
+	 * the amplifier. This is approximately 100 ms in our HW
+	 */
+	if (on)
+		msleep(100);
+	omap_set_gpio_dataout(RX44_HEADSET_AMP_GPIO, on);
+}
+
+static void rx44_speaker_amplifier_ctrl(struct device *dev, int on)
+{
+	omap_set_gpio_dataout(RX44_SPEAKER_AMP_GPIO, on);
+}
+
+static struct aic33_dmic_data rx44_dmic_config = {
+	.dmic_rate		= AIC33_DMIC_OVERSAMPLING_64,
+	.needs_bias		= 1,
+	.dmic_bias		= AIC33_MICBIAS_2V,
+};
+
+static struct aic33_hp_data rx44_hp_config = {
+	.ac_coupled		= 1,
+	.pd_tri_stated		= 0,
+};
+
+static struct aic33_platform_data aic33_config = {
+	.codec_reset		= rx44_aic33_reset,
+	.codec_init		= n800_codec_init,
+	.codec_cleanup		= n800_codec_cleanup,
+	.enable_clock		= n800_codec_enable_clock,
+	.disable_clock		= n800_codec_disable_clock,
+	.ext_hp_amplifier_ctrl	= rx44_headset_amplifier_ctrl,
+	.ext_lo_amplifier_ctrl	= rx44_speaker_amplifier_ctrl,
+	.bclk_output		= 1,
+	.wclk_output		= 1,
+	.pll_p			= 1,
+	.pll_r			= 1,
+	.pll_j			= 8,
+	.pll_d			= 1920,
+	.adc_hp_filter		= AIC33_ADC_HP_0_0045xFS,
+	.dmic_data		= &rx44_dmic_config,
+	.hp_data		= &rx44_hp_config,
+};
+
+static struct platform_device rx44_aic33_device = {
+	.name		= "aic33-driver",
+	.id		= -1,
+	.dev		= {
+		.platform_data	= &aic33_config,
+	},
+};
+
+void __init rx44_audio_init(void)
+{
+	spin_lock_init(&audio_lock);
+
+	if (omap_request_gpio(RX44_AIC33_RESET_GPIO) < 0)
+		BUG();
+	if (omap_request_gpio(RX44_HEADSET_AMP_GPIO) < 0)
+		BUG();
+	if (omap_request_gpio(RX44_SPEAKER_AMP_GPIO) < 0)
+		BUG();
+	omap_set_gpio_direction(RX44_AIC33_RESET_GPIO, 0);
+	omap_set_gpio_direction(RX44_HEADSET_AMP_GPIO, 0);
+	omap_set_gpio_direction(RX44_SPEAKER_AMP_GPIO, 0);
+	if (platform_device_register(&retu_headset_device) < 0)
+		BUG();
+	if (platform_device_register(&rx44_aic33_device) < 0)
+		BUG();
+
+	omap_init_eac(&rx44_eac_data);
+}
+
 #else
 
 void __init n800_audio_init(void)
 {
 }
+void __init rx44_audio_init(void)
+{
+}
 
 #endif
 
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/board-n800.c maemo_src/arch/arm/mach-omap2/board-n800.c
--- linux-omap-2.6/arch/arm/mach-omap2/board-n800.c	2011-02-06 20:17:25.126666606 -0500
+++ maemo_src/arch/arm/mach-omap2/board-n800.c	2011-02-06 20:12:09.749999939 -0500
@@ -42,7 +42,6 @@
 
 #define N800_BLIZZARD_POWERDOWN_GPIO 15
 #define N800_STI_GPIO		62
-#define N800_CAM_SENSOR_RESET_GPIO	53
 #define N800_KEYB_IRQ_GPIO		109
 
 static void __init nokia_n800_init_irq(void)
@@ -87,11 +86,11 @@
 };
 
 static struct omap_fbmem_config n800_fbmem1_config __initdata = {
-	.size = 752 * 1024,
+	.size = 768 * 1024,
 };
 
 static struct omap_fbmem_config n800_fbmem2_config __initdata = {
-	.size = 752 * 1024,
+	.size = 1536 * 1024,
 };
 
 static struct omap_tmp105_config n800_tmp105_config __initdata = {
@@ -190,122 +189,35 @@
 	omapfb_set_ctrl_platform_data(&n800_blizzard_data);
 }
 
-#if defined(CONFIG_CBUS_RETU) && defined(CONFIG_VIDEO_CAMERA_SENSOR_TCM825X) && \
-	defined(CONFIG_MENELAUS)
-#define SUPPORT_SENSOR
+#if defined(CONFIG_VIDEO_CAMERA_SENSOR_TCM825X) \
+	|| defined(CONFIG_VIDEO_CAMERA_SENSOR_TCM825X_MODULE)
+extern struct omap_camera_sensor_config n800_camera_sensor_config;
 #endif
 
-#ifdef SUPPORT_SENSOR
-
-static int sensor_okay;
-
-/*
- * VSIM1	--> CAM_IOVDD	--> IOVDD (1.8 V)
- */
-static int tcm825x_sensor_power_on(void *data)
-{
-	int ret;
-
-	if (!sensor_okay)
-		return -ENODEV;
-
-	/* Set VMEM to 1.5V and VIO to 2.5V */
-	ret = menelaus_set_vmem(1500);
-	if (ret < 0) {
-		/* Try once more, it seems the sensor power up causes
-		 * some problems on the I2C bus. */
-		ret = menelaus_set_vmem(1500);
-		if (ret < 0)
-			return ret;
-	}
-	msleep(1);
-
-	ret = menelaus_set_vio(2500);
-	if (ret < 0)
-		return ret;
-
-	/* Set VSim1 on */
-	retu_write_reg(RETU_REG_CTRL_SET, 0x0080);
-	msleep(100);
-
-	omap_set_gpio_dataout(N800_CAM_SENSOR_RESET_GPIO, 1);
-	msleep(1);
-
-	return 0;
-}
-
-static int tcm825x_sensor_power_off(void * data)
-{
-	int ret;
-
-	omap_set_gpio_dataout(N800_CAM_SENSOR_RESET_GPIO, 0);
-	msleep(1);
-
-	/* Set VSim1 off */
-	retu_write_reg(RETU_REG_CTRL_CLR, 0x0080);
-	msleep(1);
-
-	/* Set VIO_MODE to off */
-	ret = menelaus_set_vio(0);
-	if (ret < 0)
-		return ret;
-	msleep(1);
-
-	/* Set VMEM_MODE to off */
-	ret = menelaus_set_vmem(0);
-	if (ret < 0)
-		return ret;
-	msleep(1);
-
-	return 0;
-}
-
-static struct omap_camera_sensor_config n800_sensor_config = {
-	.power_on   = tcm825x_sensor_power_on,
-	.power_off  = tcm825x_sensor_power_off,
+static struct omap_mmc_config n800_mmc_config __initdata = {
+	.mmc [0] = {
+		.enabled		= 1,
+		.wire4			= 1,
+	},
 };
 
-static void __init n800_cam_init(void)
-{
-	int r;
-
-	r = omap_request_gpio(N800_CAM_SENSOR_RESET_GPIO);
-	if (r < 0)
-		return;
-
-	omap_set_gpio_dataout(N800_CAM_SENSOR_RESET_GPIO, 0);
-	omap_set_gpio_direction(N800_CAM_SENSOR_RESET_GPIO, 0);
-
-	sensor_okay = 1;
-}
-
-#else
-
-static inline void n800_cam_init(void) {}
-
-#endif
-
+extern struct omap_mmc_platform_data n800_mmc_data;
 static struct omap_board_config_kernel n800_config[] = {
 	{ OMAP_TAG_UART,	                &n800_uart_config },
-#ifdef SUPPORT_SENSOR
-	{ OMAP_TAG_CAMERA_SENSOR,		&n800_sensor_config },
+#if defined(CONFIG_VIDEO_CAMERA_SENSOR_TCM825X) \
+	|| defined(CONFIG_VIDEO_CAMERA_SENSOR_TCM825X_MODULE)
+	{ OMAP_TAG_CAMERA_SENSOR,		&n800_camera_sensor_config },
 #endif
 	{ OMAP_TAG_FBMEM,			&n800_fbmem0_config },
 	{ OMAP_TAG_FBMEM,			&n800_fbmem1_config },
 	{ OMAP_TAG_FBMEM,			&n800_fbmem2_config },
 	{ OMAP_TAG_TMP105,			&n800_tmp105_config },
+	{ OMAP_TAG_MMC,			        &n800_mmc_config },
 };
 
-
-static int n800_get_keyb_irq_state(struct device *dev)
-{
-	return !omap_get_gpio_datain(N800_KEYB_IRQ_GPIO);
-}
-
 static struct tsc2301_platform_data tsc2301_config = {
 	.reset_gpio	= 118,
 	.dav_gpio	= 103,
-	.pen_int_gpio	= 106,
 	.keymap = {
 		-1,		/* Event for bit 0 */
 		KEY_UP,		/* Event for bit 1 (up) */
@@ -325,7 +237,7 @@
 		-1,		/* Event for bit 15 */
 	},
 	.kp_rep 	= 0,
-	.get_keyb_irq_state = n800_get_keyb_irq_state,
+	.keyb_name	= "Internal keypad",
 };
 
 static void tsc2301_dev_init(void)
@@ -409,7 +321,8 @@
 };
 #endif
 
-#if defined(CONFIG_TOUCHSCREEN_TSC2301)
+#if defined(CONFIG_TOUCHSCREEN_TSC2301) || defined(CONFIG_TOUCHSCREEN_TSC2005)
+
 static void __init n800_ts_set_config(void)
 {
 	const struct omap_lcd_config *conf;
@@ -418,16 +331,26 @@
 	if (conf != NULL) {
 		if (strcmp(conf->panel_name, "lph8923") == 0) {
 			tsc2301_config.ts_x_plate_ohm	= 180;
-			tsc2301_config.ts_hw_avg	= 4;
-			tsc2301_config.ts_ignore_last	= 1;
-			tsc2301_config.ts_max_pressure	= 255;
+			tsc2301_config.ts_hw_avg	= 8;
+			tsc2301_config.ts_touch_pressure = 400;
 			tsc2301_config.ts_stab_time	= 100;
+			tsc2301_config.ts_pressure_max	= 2048;
+			tsc2301_config.ts_pressure_fudge= 2;
+			tsc2301_config.ts_x_max		= 4096;
+			tsc2301_config.ts_x_fudge	= 4;
+			tsc2301_config.ts_y_max		= 4096;
+			tsc2301_config.ts_y_fudge	= 7;
 		} else if (strcmp(conf->panel_name, "ls041y3") == 0) {
 			tsc2301_config.ts_x_plate_ohm	= 280;
-			tsc2301_config.ts_hw_avg	= 16;
-			tsc2301_config.ts_touch_pressure= 215;
-			tsc2301_config.ts_max_pressure	= 255;
-			tsc2301_config.ts_ignore_last	= 1;
+			tsc2301_config.ts_hw_avg	= 8;
+			tsc2301_config.ts_touch_pressure = 400;
+			tsc2301_config.ts_stab_time	= 1000;
+			tsc2301_config.ts_pressure_max	= 2048;
+			tsc2301_config.ts_pressure_fudge= 2;
+			tsc2301_config.ts_x_max		= 4096;
+			tsc2301_config.ts_x_fudge	= 4;
+			tsc2301_config.ts_y_max		= 4096;
+			tsc2301_config.ts_y_fudge	= 7;
 		} else {
 			printk(KERN_ERR "Unknown panel type, set default "
 			       "touchscreen configuration\n");
@@ -474,8 +397,18 @@
 #endif
 };
 
+extern void __init n800_flash_init(void);
+extern void __init n800_mmc_init(void);
+extern void __init n800_bt_init(void);
+extern void __init n800_audio_init(struct tsc2301_platform_data *);
+extern void __init n800_dsp_init(void);
+extern void __init n800_usb_init(void);
+extern void __init n800_cam_init(void);
+extern void __init n800_pm_init(void);
+
 static void __init nokia_n800_init(void)
 {
+	omap_serial_init();
 	platform_add_devices(n800_devices, ARRAY_SIZE(n800_devices));
 	n800_flash_init();
 	n800_mmc_init();
@@ -487,7 +420,6 @@
 	n800_ts_set_config();
 	spi_register_board_info(n800_spi_board_info,
 				ARRAY_SIZE(n800_spi_board_info));
-	omap_serial_init();
 	mipid_dev_init();
 	blizzard_dev_init();
 	tsc2301_dev_init();
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/board-n800-camera.c maemo_src/arch/arm/mach-omap2/board-n800-camera.c
--- linux-omap-2.6/arch/arm/mach-omap2/board-n800-camera.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/mach-omap2/board-n800-camera.c	2011-02-06 20:12:09.766666606 -0500
@@ -0,0 +1,248 @@
+/*
+ * board-n800-camera.c
+ *
+ * Copyright (C) 2007 Nokia Corporation
+ *
+ * Contact: Sakari Ailus <sakari.ailus@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/platform_device.h>
+
+#include <linux/delay.h>
+#include <asm/mach-types.h>                                  
+#include <asm/arch/menelaus.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/board.h>
+
+#include <../drivers/cbus/retu.h>
+
+#include "../../../drivers/media/video/omap/tcm825x.h"
+
+#if defined(CONFIG_VIDEO_CAMERA_SENSOR_TCM825X)			\
+	|| defined(CONFIG_VIDEO_CAMERA_SENSOR_TCM825X_MODULE)
+
+#if !defined(CONFIG_CBUS_RETU) && !defined(CONFIG_CBUS_RETU_MODULE)
+#error Please select CONFIG_CBUS_RETU
+#endif
+
+#if !defined(CONFIG_MENELAUS) && !defined(CONFIG_MENELAUS_MODULE)
+#error Please select CONFIG_MENELAUS
+#endif
+
+#define N800_CAM_SENSOR_RESET_GPIO	53
+
+static int sensor_okay;
+
+/* common TCM825X register initialization for all image sizes, pixel
+ * formats, and frame rates
+ */
+
+#ifdef CONFIG_MACH_NOKIA_N800
+const static struct tcm825x_reg tcm825x_regs_n800[] = {
+	/* initial settings for 2.5 V */
+	{0x00, 0x03}, {0x03, 0x29}, {0xaa, 0x2a}, {0xc0, 0x2b},
+	{0x10, 0x2c}, {0x4c, 0x2d}, {0x9c, 0x3f},
+
+	/* main settings */
+	{0x00, 0x00}, {0x30, 0x01}, {0x0e, 0x02}, /* initial */
+	{0x0f, 0x04}, {0x02, 0x05}, {0x0d, 0x06}, {0xc0, 0x07},
+	{0x38, 0x08}, {0x50, 0x09}, {0x80, 0x0a}, {0x40, 0x0b},
+	{0x40, 0x0c}, {0x00, 0x0d}, {0x04, 0x0e}, {0x04, 0x0f},
+	{0x22, 0x10}, {0x96, 0x11}, {0xf0, 0x12}, {0x08, 0x13},
+	{0x08, 0x14}, {0x30, 0x15}, {0x30, 0x16}, {0x01, 0x17},
+	{0x40, 0x18}, {0x87, 0x19}, {0x2b, 0x1a}, {0x84, 0x1b},
+	{0x52, 0x1c}, {0x44, 0x1d}, {0x68, 0x1e}, {0x00, 0x1f},
+	{0x00, 0x20}, {0x01, 0x21}, {0x27, 0x22}, {0x40, 0x23},
+	{0x27, 0x24}, {0x5f, 0x25}, {0x00, 0x26}, {0x16, 0x27},
+	{0x23, 0x28}, /* initial */ /* initial */ /* initial */
+	/* initial */ /* initial */ {0x00, 0x2e}, {0x00, 0x2f},
+	{0x00, 0x30}, {0x00, 0x31}, {0x00, 0x32}, {0x00, 0x33},
+	{0x00, 0x34}, {0x00, 0x35}, {0x00, 0x36}, {0x00, 0x37},
+	{0x00, 0x38}, {0x8c, 0x39}, {0xc8, 0x3A}, {0x80, 0x3b},
+	{0x00, 0x3c}, {0x17, 0x3d}, {0x85, 0x3e}, /* initial */
+	{0xa0, 0x40}, {0x00, 0x41}, {0x00, 0x42}, {0x00, 0x43},
+	{0x08, 0x44}, {0x12, 0x45}, {0x00, 0x46}, {0x20, 0x47},
+	{0x30, 0x48}, {0x18, 0x49}, {0x20, 0x4a}, {0x4d, 0x4b},
+	{0x0c, 0x4c}, {0xe0, 0x4d}, {0x20, 0x4e}, {0x89, 0x4f},
+	{0x21, 0x50}, {0x80, 0x51}, {0x02, 0x52}, {0x00, 0x53},
+	{0x30, 0x54}, {0x90, 0x55}, {0x40, 0x56}, {0x06, 0x57},
+	{0x0f, 0x58}, {0x23, 0x59}, {0x08, 0x5A}, {0x04, 0x5b},
+	{0x08, 0x5c}, {0x08, 0x5d}, {0x08, 0x5e}, {0x08, 0x5f},
+	{TCM825X_VAL_TERM, TCM825X_REG_TERM}
+};
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_RX44
+const static struct tcm825x_reg tcm825x_regs_rx44[] = {
+	/* initial settings for 2.5 V */
+	{0x00, 0x03}, {0x03, 0x29}, {0xaa, 0x2a}, {0xc0, 0x2b},
+	{0x10, 0x2c}, {0x4c, 0x2d}, {0x9c, 0x3f},
+
+	/* main settings */
+	{0x00, 0x00}, {0x30, 0x01}, {0x0e, 0x02}, /* initial */
+	{0xcf, 0x04}, {0x02, 0x05}, {0x0d, 0x06}, {0xc0, 0x07},
+	{0x38, 0x08}, {0x50, 0x09}, {0x80, 0x0a}, {0x40, 0x0b},
+	{0x40, 0x0c}, {0x00, 0x0d}, {0x04, 0x0e}, {0x04, 0x0f},
+	{0x22, 0x10}, {0x96, 0x11}, {0xf0, 0x12}, {0x08, 0x13},
+	{0x08, 0x14}, {0x30, 0x15}, {0x30, 0x16}, {0x01, 0x17},
+	{0x40, 0x18}, {0x87, 0x19}, {0x2b, 0x1a}, {0x84, 0x1b},
+	{0x52, 0x1c}, {0x44, 0x1d}, {0x68, 0x1e}, {0x00, 0x1f},
+	{0x00, 0x20}, {0x01, 0x21}, {0x27, 0x22}, {0x40, 0x23},
+	{0x27, 0x24}, {0x5f, 0x25}, {0x00, 0x26}, {0x16, 0x27},
+	{0x23, 0x28}, /* initial */ /* initial */ /* initial */
+	/* initial */ /* initial */ {0x00, 0x2e}, {0x00, 0x2f},
+	{0x00, 0x30}, {0x00, 0x31}, {0x00, 0x32}, {0x00, 0x33},
+	{0x00, 0x34}, {0x00, 0x35}, {0x00, 0x36}, {0x00, 0x37},
+	{0x00, 0x38}, {0x8c, 0x39}, {0xc8, 0x3A}, {0x80, 0x3b},
+	{0x00, 0x3c}, {0x17, 0x3d}, {0x85, 0x3e}, /* initial */
+	{0xa0, 0x40}, {0x00, 0x41}, {0x00, 0x42}, {0x00, 0x43},
+	{0x08, 0x44}, {0x12, 0x45}, {0x00, 0x46}, {0x20, 0x47},
+	{0x30, 0x48}, {0x18, 0x49}, {0x20, 0x4a}, {0x4d, 0x4b},
+	{0x0c, 0x4c}, {0xe0, 0x4d}, {0x20, 0x4e}, {0x89, 0x4f},
+	{0x21, 0x50}, {0x80, 0x51}, {0x02, 0x52}, {0x00, 0x53},
+	{0x30, 0x54}, {0x90, 0x55}, {0x40, 0x56}, {0x06, 0x57},
+	{0x0f, 0x58}, {0x23, 0x59}, {0x08, 0x5A}, {0x04, 0x5b},
+	{0x08, 0x5c}, {0x08, 0x5d}, {0x08, 0x5e}, {0x08, 0x5f},
+	{TCM825X_VAL_TERM, TCM825X_REG_TERM}
+};
+#endif
+
+/*
+ * VSIM1	--> CAM_IOVDD	--> IOVDD (1.8 V)
+ */
+static int tcm825x_sensor_power_on(void)
+{
+	int ret;
+
+	/* Set VMEM to 1.5V and VIO to 2.5V */
+	ret = menelaus_set_vmem(1500);
+	if (ret < 0) {
+		/* Try once more, it seems the sensor power up causes
+		 * some problems on the I2C bus. */
+		ret = menelaus_set_vmem(1500);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = menelaus_set_vio(2500);
+	if (ret < 0)
+		return ret;
+
+	/* Disable automatic VSim1 powersaving */
+	ret = retu_read_reg(RETU_REG_CC2);
+	retu_write_reg(RETU_REG_CC2, ret | 0x11);
+
+	/* Set VSim1 on */
+	retu_write_reg(RETU_REG_CTRL_SET, 0x0080);
+	msleep(1);
+
+	omap_set_gpio_dataout(N800_CAM_SENSOR_RESET_GPIO, 1);
+	msleep(1);
+
+	return 0;
+}
+
+static int tcm825x_sensor_power_off(void)
+{
+	int ret;
+
+	omap_set_gpio_dataout(N800_CAM_SENSOR_RESET_GPIO, 0);
+	msleep(1);
+
+	/* Set VSim1 off */
+	retu_write_reg(RETU_REG_CTRL_CLR, 0x0080);
+	msleep(1);
+
+	/* Set VIO_MODE to off */
+	ret = menelaus_set_vio(0);
+	if (ret < 0)
+		return ret;
+	msleep(1);
+
+	/* Set VMEM_MODE to off */
+	ret = menelaus_set_vmem(0);
+	if (ret < 0)
+		return ret;
+	msleep(1);
+
+	return 0;
+}
+
+static int tcm825x_sensor_power_set(int power) {
+	BUG_ON(!sensor_okay);
+	
+	if (power)
+		return tcm825x_sensor_power_on();
+	else
+		return tcm825x_sensor_power_off();
+}
+
+static int tcm825x_sensor_is_okay(void) {
+	return sensor_okay;
+}
+
+static const struct tcm825x_reg *tcm825x_default_regs(void) {
+	if (machine_is_nokia_n800())
+		return tcm825x_regs_n800;
+	if (machine_is_nokia_rx44() || machine_is_nokia_rx48())
+		return tcm825x_regs_rx44;
+
+	BUG();
+
+	return NULL;
+}
+
+static int tcm825x_is_upside_down(void)
+{
+	if (machine_is_nokia_rx44() || machine_is_nokia_rx48())
+		return 1;
+
+	return 0;
+}
+
+struct omap_camera_sensor_config n800_camera_sensor_config = {
+	.is_okay	= &tcm825x_sensor_is_okay,
+	.power_set	= &tcm825x_sensor_power_set,
+	.default_regs	= &tcm825x_default_regs,
+	.is_upside_down = &tcm825x_is_upside_down,
+};
+
+void __init n800_cam_init(void)
+{
+	int r;
+
+	r = omap_request_gpio(N800_CAM_SENSOR_RESET_GPIO);
+	if (r < 0) {
+		printk(KERN_WARNING "%s: failed to request gpio\n",
+			__FUNCTION__);
+		return;
+	}
+
+	omap_set_gpio_dataout(N800_CAM_SENSOR_RESET_GPIO, 0);
+	omap_set_gpio_direction(N800_CAM_SENSOR_RESET_GPIO, 0);
+
+	sensor_okay = 1;
+}
+
+#else
+void __init n800_cam_init(void)
+{
+}
+
+#endif
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/board-n800-dvfs.c maemo_src/arch/arm/mach-omap2/board-n800-dvfs.c
--- linux-omap-2.6/arch/arm/mach-omap2/board-n800-dvfs.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/mach-omap2/board-n800-dvfs.c	2011-02-06 20:12:09.786666607 -0500
@@ -0,0 +1,282 @@
+/*
+ * arch/arm/mach-omap2/board-n800-dvfs.c
+ *
+ * Copyright (C) 2007 Nokia Corporation.
+ *
+ * Contact: Igor Stoppa <igor.stoppa@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <linux/cpufreq.h>
+#include <asm/mach-types.h>
+#include <asm/arch/board.h>
+#include <asm/arch/dvfs.h>
+#include "dvfs.h"
+
+enum op_indexes {
+	OP_0 = 0,
+	OP_1,
+	OP_2,
+	OP_3,
+	NUM_OP,
+	DEFAULT_OP = OP_1,
+	OP_DSP_H   = OP_1,
+	OP_CPU_H   = OP_0,
+	OP_CPU_ONDEMAND = 255,
+};
+
+static unsigned int op_list[NUM_OP][NUM_OP_PARMS] = {
+	[OP_0] = {
+		[_54M_SRC_CLK_KHZ]	=  54000,
+		[_48M_SRC_CLK_KHZ]	=  96000,
+		[DPLL_CLK_KHZ]		= 400000,
+		[CORE_CLK_KHZ]		= 800000,
+		[MPU_CLK_KHZ]		= 400000,
+		[DSP_CLK_KHZ]		= 133000,
+		[DSP_IF_CLK_KHZ]	= 133000,
+		[DSP_SYNC]		= SYNC_DISABLED,
+		[IVA_CLK_KHZ]		= 200000,
+		[IVA_SYNC]		= SYNC_DISABLED,
+		[GFX_CLK_KHZ]		=  66000,
+		[L3_CLK_KHZ]		= 133000,
+		[L4_CLK_KHZ]		= 133000,
+		[DSS1_CLK_KHZ]		= 133000,
+		[DSS2_CLK_KHZ]		= SYS_CLK,
+		[VLYNQ_CLK_KHZ]		=  66000,
+		[SSI_CLK_KHZ]		= 266000,
+		[USB_CLK_KHZ]		=  66000,
+		[VCORE_ROOF_MV]		=   1375,
+	},
+	[OP_1] = {
+		[_54M_SRC_CLK_KHZ]	=  54000,
+		[_48M_SRC_CLK_KHZ]	=  96000,
+		[DPLL_CLK_KHZ]		= 330000,
+		[CORE_CLK_KHZ]		= 660000,
+		[MPU_CLK_KHZ]		= 330000,
+		[DSP_CLK_KHZ]		= 220000,
+		[DSP_IF_CLK_KHZ]	= 110000,
+		[DSP_SYNC]		= SYNC_DISABLED,
+		[IVA_CLK_KHZ]		= 165000,
+		[IVA_SYNC]		= SYNC_DISABLED,
+		[GFX_CLK_KHZ]		=  55000,
+		[L3_CLK_KHZ]		= 110000,
+		[L4_CLK_KHZ]		= 110000,
+		[DSS1_CLK_KHZ]		= 110000,
+		[DSS2_CLK_KHZ]		= SYS_CLK,
+		[VLYNQ_CLK_KHZ]		=  55000,
+		[SSI_CLK_KHZ]		= 220000,
+		[USB_CLK_KHZ]		=  55000,
+		[VCORE_ROOF_MV]		=   1375,
+	},
+	[OP_2] = {
+		[_54M_SRC_CLK_KHZ]	=  54000,
+		[_48M_SRC_CLK_KHZ]	=  96000,
+		[DPLL_CLK_KHZ]		= 266000,
+		[CORE_CLK_KHZ]		= 532000,
+		[MPU_CLK_KHZ]		= 266000,
+		[DSP_CLK_KHZ]		= 177000,
+		[DSP_IF_CLK_KHZ]	=  88000,
+		[DSP_SYNC]		= SYNC_DISABLED,
+		[IVA_CLK_KHZ]		= 133000,
+		[IVA_SYNC]		= SYNC_DISABLED,
+		[GFX_CLK_KHZ]		=  88000,
+		[L3_CLK_KHZ]		=  88000,
+		[L4_CLK_KHZ]		=  44000,
+		[DSS1_CLK_KHZ]		=  88000,
+		[DSS2_CLK_KHZ]		= SYS_CLK,
+		[VLYNQ_CLK_KHZ]		=  44000,
+		[SSI_CLK_KHZ]		= 177000,
+		[USB_CLK_KHZ]		=  44000,
+		[VCORE_ROOF_MV]		=   1300,
+	},
+	[OP_3] = {
+		[_54M_SRC_CLK_KHZ]	=  54000,
+		[_48M_SRC_CLK_KHZ]	=  96000,
+		[DPLL_CLK_KHZ]		= 330000,
+		[CORE_CLK_KHZ]		= 330000,
+		[MPU_CLK_KHZ]		= 165000,
+		[DSP_CLK_KHZ]		= 110000,
+		[DSP_IF_CLK_KHZ]	=  55000,
+		[DSP_SYNC]		= SYNC_DISABLED,
+		[IVA_CLK_KHZ]		=  82000,
+		[IVA_SYNC]		= SYNC_DISABLED,
+		[GFX_CLK_KHZ]		=  55000,
+		[L3_CLK_KHZ]		=  55000,
+		[L4_CLK_KHZ]		=  27500,
+		[DSS1_CLK_KHZ]		= 110000,
+		[DSS2_CLK_KHZ]		= SYS_CLK,
+		[VLYNQ_CLK_KHZ]		=  27500,
+		[SSI_CLK_KHZ]		= 110000,
+		[USB_CLK_KHZ]		=  27500,
+		[VCORE_ROOF_MV]		=   1225,
+	},
+};
+
+extern struct dvfs_cfg_data dvfs_cfg;
+
+extern void omap2_clk_recalc_tree(void);
+
+/**
+ * op_policy - OP performance policy
+ *
+ * Set
+ *  - when the DSP-GW indicates that the DSP need full performance,
+ *  - when the camera don't want frequency transistions or
+ *  - when we detect that a ARM side codec is playing.
+ * It is used by the CPUFREQ_POLICY_NOTIFIER chain to constrain the
+ * available frequencies.
+ */
+static struct {
+	u8                      current_op;
+	u8                      path;
+	u8                      task;
+	u8                      cam;
+	struct mutex            lock;
+	struct workqueue_struct *dvfs_wq;
+	struct work_struct      update_policy_work;
+} op_policy;
+
+static int update_op(enum dvfs_op_policy_change type, int data)
+{
+	int new_op;
+	int ret = 0;
+
+	mutex_lock(&op_policy.lock);
+	switch (type) {
+	case DSP_DYNAMIC_TASK_CHANGED:
+		op_policy.task = (data > 0);
+		break;
+	case DSP_AUDIO_PATH_CHANGED:
+		op_policy.path = (data > 0);
+		break;
+	case CAM_STREAMING_CHANGED:
+		op_policy.cam = (data > 0);
+	default:
+		break;
+	}
+
+	if (op_policy.task)
+		new_op = OP_DSP_H;
+	else if (op_policy.cam)
+		new_op = OP_DSP_H;
+	else if (op_policy.path)
+		new_op = OP_CPU_H;
+	else
+		new_op = OP_CPU_ONDEMAND;
+
+	if (new_op != op_policy.current_op) {
+		op_policy.current_op = new_op;
+		ret = 1;
+	}
+	mutex_unlock(&op_policy.lock);
+
+	return ret;
+}
+
+/**
+ * dvfs_op_policy_update - called by drivers to set and clear OP policies
+ *
+ * @type: type of information
+ * @data: data associated
+ *
+ * Currently this function is called when a dynamic task is loaded
+ * or unloaded on the DSP.
+ * The problem addressed here is that if the DSP has at least one
+ * dynamic task loaded then we should use the DSP-HI operating point.
+ */
+void dvfs_op_policy_update(enum dvfs_op_policy_change type, int data)
+{
+	if (update_op(type, data))
+		cpufreq_update_policy(0);
+}
+EXPORT_SYMBOL(dvfs_op_policy_update);
+
+/**
+ * dvfs_op_policy_update_delayed - called by drivers to set and clear OP policies
+ *
+ * @type: type of information
+ * @data: data associated
+ *
+ * Currently this function is called when a dynamic task is loaded
+ * or unloaded on the DSP.
+ * The problem addressed here is that if the DSP has at least one
+ * dynamic task loaded then we should use the DSP-HI operating point.
+ */
+void dvfs_op_policy_update_delayed(enum dvfs_op_policy_change type, int data)
+{
+	if (update_op(type, data))
+		queue_work(op_policy.dvfs_wq,
+			  &op_policy.update_policy_work);
+}
+EXPORT_SYMBOL(dvfs_op_policy_update_delayed);
+
+static void update_policy_work(struct work_struct *work)
+{
+	cpufreq_update_policy(0);
+}
+
+/**
+ * op_policy_notifier - called by CPUFREQ_POLICY_NOTIFIER chain
+ *
+ * @nb: calling notifier_block
+ * @event: reason we are called
+ * @data:  associated data
+ *
+ * This function is called in response to a call to cpufreq_update_policy.
+ * If "op_policy" is active, then we force DSP-HI operation-point.
+ */
+static int op_policy_notifier(struct notifier_block *nb,
+				     unsigned long event, void *data)
+{
+	struct cpufreq_policy *policy = data;
+
+	if (event != CPUFREQ_INCOMPATIBLE)
+		return 0;
+
+	if (op_policy.current_op != OP_CPU_ONDEMAND) {
+		cpufreq_verify_within_limits(policy,
+			     op_list[op_policy.current_op][MPU_CLK_KHZ],
+			     op_list[op_policy.current_op][MPU_CLK_KHZ]);
+	}
+	return 0;
+}
+
+static struct notifier_block dsp_state_change_block = {
+       .notifier_call = op_policy_notifier,
+};
+
+int __init n800_dvfs_init(void)
+{
+	mutex_init(&op_policy.lock);
+	op_policy.dvfs_wq = create_workqueue("dvfs");
+	INIT_WORK(&op_policy.update_policy_work, update_policy_work);
+
+	op_policy.current_op = OP_CPU_ONDEMAND;
+
+	omap242x_load_op_list((const unsigned int (*)[NUM_OP_PARMS])op_list,
+			      NUM_OP, DEFAULT_OP);
+	cpufreq_register_notifier(&dsp_state_change_block,
+				  CPUFREQ_POLICY_NOTIFIER);
+	return 0;
+}
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/board-n800-flash.c maemo_src/arch/arm/mach-omap2/board-n800-flash.c
--- linux-omap-2.6/arch/arm/mach-omap2/board-n800-flash.c	2011-02-06 20:17:25.069999940 -0500
+++ maemo_src/arch/arm/mach-omap2/board-n800-flash.c	2011-02-06 20:12:09.749999939 -0500
@@ -21,7 +21,7 @@
 
 static struct mtd_partition n800_partitions[8];
 
-static int n800_onenand_setup(void __iomem *);
+static int n800_onenand_setup(void __iomem *, int freq);
 
 static struct omap_onenand_platform_data n800_onenand_data = {
 	.cs = 0,
@@ -49,56 +49,103 @@
 	writew(value, addr);
 }
 
-static int omap2_onenand_set_sync_mode(int cs, void __iomem *onenand_base)
+static int omap2_onenand_set_sync_mode(int cs, void __iomem *onenand_base,
+				       int freq)
 {
-	const int min_gpmc_clk_period = 18;
 	struct gpmc_timings t;
+	int min_gpmc_clk_period, t_ces, t_avds, t_avdh, t_avdp, t_wpl, t_wea;
 	int tick_ns, div, fclk_offset_ns, fclk_offset, gpmc_clk_ns, latency;
+	int err;
 	u32 reg;
 
-	tick_ns = gpmc_round_ns_to_ticks(1);
+again:
+	switch (freq) {
+	case 83:
+		min_gpmc_clk_period = 12; /* 83 MHz */
+		t_ces  = 5;
+		t_avds = 5;
+		t_avdh = 6;
+		t_avdp = 12;
+		t_wpl  = 40;
+		t_wea  = 15;
+		break;
+	case 66:
+		min_gpmc_clk_period = 15; /* 66 MHz */
+		t_ces  = 6;
+		t_avds = 5;
+		t_avdh = 6;
+		t_avdp = 12;
+		t_wpl  = 40;
+		t_wea  = 15;
+		break;
+	default:
+		min_gpmc_clk_period = 18; /* 54 MHz */
+		t_ces  = 7;
+		t_avds = 7;
+		t_avdh = 7;
+		t_avdp = 12;
+		t_wpl  = 40;
+		t_wea  = 15;
+		break;
+	}
+
+	tick_ns = gpmc_ticks_to_ns(1);
 	div = gpmc_cs_calc_divider(cs, min_gpmc_clk_period);
-	gpmc_clk_ns = div * tick_ns;
-	if (gpmc_clk_ns >= 24)
+	gpmc_clk_ns = gpmc_ticks_to_ns(div);
+	if (gpmc_clk_ns >= 25) /* 40 MHz*/
 		latency = 3;
 	else
 		latency = 4;
 
-	/* Configure OneNAND for sync read */
-	reg = omap2_onenand_readw(onenand_base + ONENAND_REG_SYS_CFG1);
-	reg &= ~((0x7 << ONENAND_SYS_CFG1_BRL_SHIFT) | (0x7 << 9));
-	reg |=	(latency << ONENAND_SYS_CFG1_BRL_SHIFT) |
-		ONENAND_SYS_CFG1_SYNC_READ |
-		ONENAND_SYS_CFG1_BL_16;
-	omap2_onenand_writew(reg, onenand_base + ONENAND_REG_SYS_CFG1);
+	if (div == 1) {
+		reg = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG2);
+		reg |= (1 << 7);
+		gpmc_cs_write_reg(cs, GPMC_CS_CONFIG2, reg);
+		reg = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG3);
+		reg |= (1 << 7);
+		gpmc_cs_write_reg(cs, GPMC_CS_CONFIG3, reg);
+		reg = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG4);
+		reg |= (1 << 7);
+		reg |= (1 << 23);
+		gpmc_cs_write_reg(cs, GPMC_CS_CONFIG4, reg);
+	} else {
+		reg = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG2);
+		reg &= ~(1 << 7);
+		gpmc_cs_write_reg(cs, GPMC_CS_CONFIG2, reg);
+		reg = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG3);
+		reg &= ~(1 << 7);
+		gpmc_cs_write_reg(cs, GPMC_CS_CONFIG3, reg);
+		reg = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG4);
+		reg &= ~(1 << 7);
+		reg &= ~(1 << 23);
+		gpmc_cs_write_reg(cs, GPMC_CS_CONFIG4, reg);
+	}
 
-	/* FIXME: Get timings from platform data */
 	/* Set syncronous read timings */
 	memset(&t, 0, sizeof(t));
 	t.sync_clk = min_gpmc_clk_period;
 	t.cs_on = 0;
-	t.adv_on = gpmc_round_ns_to_ticks(7);
-	fclk_offset_ns = t.adv_on + gpmc_round_ns_to_ticks(7);
-	fclk_offset = fclk_offset_ns / gpmc_round_ns_to_ticks(1);
+	t.adv_on = 0;
+	fclk_offset_ns = gpmc_round_ns_to_ticks(max_t(int, t_ces, t_avds));
+	fclk_offset = gpmc_ns_to_ticks(fclk_offset_ns);
 	t.page_burst_access = gpmc_clk_ns;
 
 	/* Read */
-	t.adv_rd_off = fclk_offset_ns + gpmc_round_ns_to_ticks(7);
+	t.adv_rd_off = gpmc_ticks_to_ns(fclk_offset + gpmc_ns_to_ticks(t_avdh));
 	t.oe_on = t.adv_rd_off;
-	t.access = fclk_offset_ns + (latency + 1) * gpmc_clk_ns;
+	t.access = gpmc_ticks_to_ns(fclk_offset + (latency + 1) * div);
 	t.oe_off = t.access + gpmc_round_ns_to_ticks(1);
 	t.cs_rd_off = t.oe_off;
-	t.rd_cycle = t.cs_rd_off + gpmc_round_ns_to_ticks(17);
+	t.rd_cycle = gpmc_ticks_to_ns(fclk_offset + (latency + 1) * div + div);
 
 	/* Write */
-	t.adv_wr_off = t.adv_on + gpmc_round_ns_to_ticks(12);
-	t.we_on = t.adv_wr_off + gpmc_round_ns_to_ticks(1);
-	t.we_off = t.we_on + gpmc_round_ns_to_ticks(40);
+	t.adv_wr_off = t.adv_on + gpmc_round_ns_to_ticks(t_avdp);
+	t.we_on = t.adv_wr_off + gpmc_round_ns_to_ticks(t_avdh);
+	t.we_off = t.we_on + gpmc_round_ns_to_ticks(t_wpl);
 	t.cs_wr_off = t.we_off + gpmc_round_ns_to_ticks(1);
-	t.wr_cycle = t.cs_wr_off + gpmc_round_ns_to_ticks(1);
+	t.wr_cycle = t.we_off + gpmc_round_ns_to_ticks(t_wea);
 
 	/* Configure GPMC for synchronous read */
-	fclk_offset %= div;
 	gpmc_cs_write_reg(cs, GPMC_CS_CONFIG1,
 			  GPMC_CONFIG1_WRAPBURST_SUPP |
 			  GPMC_CONFIG1_READMULTIPLE_SUPP |
@@ -111,16 +158,49 @@
 			  GPMC_CONFIG1_DEVICETYPE_NOR |
 			  GPMC_CONFIG1_MUXADDDATA);
 
-	return gpmc_cs_set_timings(cs, &t);
+	err = gpmc_cs_set_timings(cs, &t);
+	if (err)
+		return err;
+
+	if (!freq) {
+		/* Very first call freq is not known */
+		reg = omap2_onenand_readw(onenand_base + ONENAND_REG_VERSION_ID);
+		switch ((reg >> 4) & 0xf) {
+		case 0:
+			freq = 40;
+			break;
+		case 1:
+			freq = 54;
+			break;
+		case 2:
+			freq = 66;
+			break;
+		case 3:
+			freq = 83;
+			break;
+		}
+		if (freq && freq != 54)
+			goto again;
+	}
+
+	/* Configure OneNAND for sync read */
+	reg = omap2_onenand_readw(onenand_base + ONENAND_REG_SYS_CFG1);
+	reg &= ~((0x7 << ONENAND_SYS_CFG1_BRL_SHIFT) | (0x7 << 9));
+	reg |=	(latency << ONENAND_SYS_CFG1_BRL_SHIFT) |
+		ONENAND_SYS_CFG1_SYNC_READ |
+		ONENAND_SYS_CFG1_BL_16;
+	omap2_onenand_writew(reg, onenand_base + ONENAND_REG_SYS_CFG1);
+
+	return 0;
 }
 
-static int n800_onenand_setup(void __iomem *onenand_base)
+static int n800_onenand_setup(void __iomem *onenand_base, int freq)
 {
 	struct omap_onenand_platform_data *datap = &n800_onenand_data;
 	struct device *dev = &n800_onenand_device.dev;
 
 	/* Set sync timings in GPMC */
-	if (omap2_onenand_set_sync_mode(datap->cs, onenand_base) < 0) {
+	if (omap2_onenand_set_sync_mode(datap->cs, onenand_base, freq) < 0) {
 		dev_err(dev, "Unable to set synchronous mode\n");
 		return -EINVAL;
 	}
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/board-n800-mmc.c maemo_src/arch/arm/mach-omap2/board-n800-mmc.c
--- linux-omap-2.6/arch/arm/mach-omap2/board-n800-mmc.c	2011-02-06 20:17:25.086666604 -0500
+++ maemo_src/arch/arm/mach-omap2/board-n800-mmc.c	2011-02-06 20:12:09.756666606 -0500
@@ -13,26 +13,31 @@
 #include <asm/arch/menelaus.h>
 #include <asm/arch/gpio.h>
 
+#include <asm/mach-types.h>
+#include <linux/delay.h>
+
 #ifdef CONFIG_MMC_OMAP
 
 static const int slot_switch_gpio = 96;
-static const int slot1_wp_gpio = 23;
-static const int slot2_wp_gpio = 8;
-static int slot1_cover_closed;
-static int slot2_cover_closed;
+
+static const int rx44_slot2_pw_vddf = 23;
+static const int rx44_slot2_pw_vdd = 9;
+
+static int slot1_cover_open;
+static int slot2_cover_open;
 static struct device *mmc_device;
 
 /*
- * VMMC --> slot 1
- * VDCDC3_APE, VMCS2_APE --> slot 2
+ * VMMC   --> slot 1 (N800 & RX44)
+ * VDCDC3_APE, VMCS2_APE --> slot 2 on N800
  * GPIO96 --> Menelaus GPIO2
+ * GPIO23 --> controls slot2 VSD    (RX44 only)
+ * GPIO9  --> controls slot2 VIO_SD (RX44 only)
  */
 
 static int n800_mmc_switch_slot(struct device *dev, int slot)
 {
-#ifdef CONFIG_MMC_DEBUG
 	dev_dbg(dev, "Choose slot %d\n", slot + 1);
-#endif
 	if (slot == 0)
 		omap_set_gpio_dataout(slot_switch_gpio, 0);
 	else
@@ -40,18 +45,18 @@
 	return 0;
 }
 
-static int n800_mmc_set_power(struct device *dev, int slot, int power_on,
-				int vdd)
+static int n800_mmc_set_power_menelaus(struct device *dev, int slot,
+				       int power_mode, int vdd)
 {
 	int mV;
+	int low_power;
 
-#ifdef CONFIG_MMC_DEBUG
 	dev_dbg(dev, "Set slot %d power: %s (vdd %d)\n", slot + 1,
-		power_on ? "on" : "off", vdd);
-#endif
+		power_mode != MMC_POWER_OFF ? "on" : "off", vdd);
+
 	if (slot == 0) {
-		if (!power_on)
-			return menelaus_set_vmmc(0);
+		if (power_mode == MMC_POWER_OFF)
+			return menelaus_set_vmmc(0, 0);
 		switch (1 << vdd) {
 		case MMC_VDD_33_34:
 		case MMC_VDD_32_33:
@@ -64,16 +69,17 @@
 		case MMC_VDD_28_29:
 			mV = 2800;
 			break;
-		case MMC_VDD_18_19:
+		case MMC_VDD_165_195:
 			mV = 1850;
 			break;
 		default:
 			BUG();
 		}
-		return menelaus_set_vmmc(mV);
+		low_power = (power_mode == MMC_POWER_STANDBY);
+		return menelaus_set_vmmc(mV, low_power);
 	} else {
-		if (!power_on)
-			return menelaus_set_vdcdc(3, 0);
+		if (power_mode == MMC_POWER_OFF)
+			return menelaus_set_vdcdc(3, 0, 0);
 		switch (1 << vdd) {
 		case MMC_VDD_33_34:
 		case MMC_VDD_32_33:
@@ -96,22 +102,47 @@
 			mV = 2200;
 			break;
 		case MMC_VDD_20_21:
-		case MMC_VDD_19_20:
 			mV = 2000;
 			break;
-		case MMC_VDD_18_19:
-		case MMC_VDD_17_18:
+		case MMC_VDD_165_195:
 			mV = 1800;
 			break;
-		case MMC_VDD_150_155:
-		case MMC_VDD_145_150:
-			mV = 1500;
-			break;
 		default:
 			BUG();
 		}
-		return menelaus_set_vdcdc(3, mV);
+		low_power = (power_mode == MMC_POWER_STANDBY);
+		return menelaus_set_vdcdc(3, mV, low_power);
+	}
+	return 0;
+}
+
+static void nokia_mmc_set_power_internal(struct device *dev,
+					 int power_on)
+{
+	dev_dbg(dev, "Set internal slot power %s\n",
+		power_on ? "on" : "off");
+
+	if (power_on) {
+		omap_set_gpio_dataout(rx44_slot2_pw_vddf, 1);
+		udelay(30);
+		omap_set_gpio_dataout(rx44_slot2_pw_vdd, 1);
+		udelay(100);
+	} else {
+		omap_set_gpio_dataout(rx44_slot2_pw_vdd, 0);
+		msleep(50);
+		omap_set_gpio_dataout(rx44_slot2_pw_vddf, 0);
+		msleep(50);
 	}
+}
+
+static int n800_mmc_set_power(struct device *dev, int slot, int power_on,
+			      int vdd)
+{
+	if (machine_is_nokia_n800() || slot == 0)
+		return n800_mmc_set_power_menelaus(dev, slot, power_on, vdd);
+
+	nokia_mmc_set_power_internal(dev, power_on);
+
 	return 0;
 }
 
@@ -119,10 +150,8 @@
 {
 	int r;
 
-#ifdef CONFIG_MMC_DEBUG
 	dev_dbg(dev, "Set slot %d bus mode %s\n", slot + 1,
 		bus_mode == MMC_BUSMODE_OPENDRAIN ? "open-drain" : "push-pull");
-#endif
 	BUG_ON(slot != 0 && slot != 1);
 	slot++;
 	switch (bus_mode) {
@@ -141,55 +170,51 @@
 	return r;
 }
 
-#if 0
-static int n800_mmc_get_ro(struct device *dev, int slot)
-{
-	int ro;
-
-	slot++;
-	if (slot == 1)
-		ro = omap_get_gpio_datain(slot1_wp_gpio);
-	else
-		ro = omap_get_gpio_datain(slot2_wp_gpio);
-#ifdef CONFIG_MMC_DEBUG
-	dev_dbg(dev, "Get RO slot %d: %s\n",
-		slot, ro ? "read-only" : "read-write");
-#endif
-	return ro;
-}
-#endif
-
 static int n800_mmc_get_cover_state(struct device *dev, int slot)
 {
 	slot++;
 	BUG_ON(slot != 1 && slot != 2);
 	if (slot == 1)
-		return slot1_cover_closed;
+		return slot1_cover_open;
 	else
-		return slot2_cover_closed;
+		return slot2_cover_open;
 }
 
 static void n800_mmc_callback(void *data, u8 card_mask)
 {
-	if (card_mask & (1 << 1))
-		slot2_cover_closed = 0;
+	int bit, *openp, index;
+
+	if (machine_is_nokia_n800()) {
+		bit = 1 << 1;
+		openp = &slot2_cover_open;
+		index = 1;
+	} else {
+		bit = 1;
+		openp = &slot1_cover_open;
+		index = 0;
+	}
+
+	if (card_mask & bit)
+		*openp = 1;
 	else
-		slot2_cover_closed = 1;
-        omap_mmc_notify_cover_event(mmc_device, 1, slot2_cover_closed);
+		*openp = 0;
+
+        omap_mmc_notify_cover_event(mmc_device, index, *openp);
 }
 
-void n800_mmc_slot1_cover_handler(void *arg, int state)
+void n800_mmc_slot1_cover_handler(void *arg, int closed_state)
 {
 	if (mmc_device == NULL)
 		return;
 
-	slot1_cover_closed = state;
-	omap_mmc_notify_cover_event(mmc_device, 0, state);
+	slot1_cover_open = !closed_state;
+	omap_mmc_notify_cover_event(mmc_device, 0, closed_state);
 }
 
 static int n800_mmc_late_init(struct device *dev)
 {
-	int r;
+	int r, bit, *openp;
+	int vs2sel;
 
 	mmc_device = dev;
 
@@ -197,10 +222,22 @@
 	if (r < 0)
 		return r;
 
+	if (machine_is_nokia_n800())
+		vs2sel = 0;
+	else
+		vs2sel = 2;
+
+	r = menelaus_set_mmc_slot(2, 0, vs2sel, 1);
+	if (r < 0)
+		return r;
+
+	n800_mmc_set_power(dev, 0, MMC_POWER_ON, 16); /* MMC_VDD_28_29 */
+	n800_mmc_set_power(dev, 1, MMC_POWER_ON, 16);
+
 	r = menelaus_set_mmc_slot(1, 1, 0, 1);
 	if (r < 0)
 		return r;
-	r = menelaus_set_mmc_slot(2, 1, 0, 1);
+	r = menelaus_set_mmc_slot(2, 1, vs2sel, 1);
 	if (r < 0)
 		return r;
 
@@ -208,35 +245,68 @@
 	if (r < 0)
 		return r;
 
-	if (r & (1 << 1))
-		slot2_cover_closed = 1;
+	if (machine_is_nokia_n800()) {
+		bit = 1 << 1;
+		openp = &slot2_cover_open;
+	} else {
+		bit = 1;
+		openp = &slot1_cover_open;
+		slot2_cover_open = 0;
+	}
+
+	/* All slot pin bits seem to be inversed until first swith change */
+	if (r == 0xf || r == (0xf & ~bit))
+		r = ~r;
+
+	if (r & bit)
+		*openp = 1;
 	else
-		slot2_cover_closed = 0;
+		*openp = 0;
 
 	r = menelaus_register_mmc_callback(n800_mmc_callback, NULL);
 
 	return r;
 }
 
+static void n800_mmc_shutdown(struct device *dev)
+{
+	int vs2sel;
+
+	if (machine_is_nokia_n800())
+		vs2sel = 0;
+	else
+		vs2sel = 2;
+
+	menelaus_set_mmc_slot(1, 0, 0, 0);
+	menelaus_set_mmc_slot(2, 0, vs2sel, 0);
+}
+
 static void n800_mmc_cleanup(struct device *dev)
 {
 	menelaus_unregister_mmc_callback();
+
+	omap_free_gpio(slot_switch_gpio);
+
+	if (machine_is_nokia_rx44() || machine_is_nokia_rx48()) {
+		omap_free_gpio(rx44_slot2_pw_vddf);
+		omap_free_gpio(rx44_slot2_pw_vdd);
+	}
 }
 
 static struct omap_mmc_platform_data n800_mmc_data = {
-	.enabled		= 1,
 	.nr_slots		= 2,
-	.wire4			= 1,
 	.switch_slot		= n800_mmc_switch_slot,
 	.init			= n800_mmc_late_init,
 	.cleanup		= n800_mmc_cleanup,
+	.shutdown		= n800_mmc_shutdown,
+	.max_freq               = 24000000,
 	.slots[0] = {
 		.set_power	= n800_mmc_set_power,
 		.set_bus_mode	= n800_mmc_set_bus_mode,
 		.get_ro		= NULL,
 		.get_cover_state= n800_mmc_get_cover_state,
-		.ocr_mask	= MMC_VDD_18_19 | MMC_VDD_28_29 | MMC_VDD_30_31 |
-				  MMC_VDD_32_33 | MMC_VDD_33_34,
+		.ocr_mask	= MMC_VDD_165_195 | MMC_VDD_30_31 |
+				  MMC_VDD_32_33   | MMC_VDD_33_34,
 		.name		= "internal",
 	},
 	.slots[1] = {
@@ -244,8 +314,7 @@
 		.set_bus_mode	= n800_mmc_set_bus_mode,
 		.get_ro		= NULL,
 		.get_cover_state= n800_mmc_get_cover_state,
-		.ocr_mask	= MMC_VDD_150_155 | MMC_VDD_145_150 | MMC_VDD_17_18 |
-				  MMC_VDD_18_19 | MMC_VDD_19_20 | MMC_VDD_20_21 |
+		.ocr_mask	= MMC_VDD_165_195 | MMC_VDD_20_21 |
 				  MMC_VDD_21_22 | MMC_VDD_22_23 | MMC_VDD_23_24 |
 				  MMC_VDD_24_25 | MMC_VDD_27_28 | MMC_VDD_28_29 |
 				  MMC_VDD_29_30 | MMC_VDD_30_31 | MMC_VDD_32_33 |
@@ -255,20 +324,39 @@
 };
 
 void __init n800_mmc_init(void)
+
 {
+	if (machine_is_nokia_rx44() || machine_is_nokia_rx48()) {
+		n800_mmc_data.slots[0].name = "external";
+
+		/* 
+		 * Some Samsung Movinand chips do not like open-ended
+		 * multi-block reads and fall to braind-dead state
+		 * while doing so. Reducing the number of blocks in
+		 * the transfer or delays in clock disable do not help
+		 */
+		n800_mmc_data.slots[1].name = "internal";
+		n800_mmc_data.slots[1].ban_openended_read = 1;
+	}
+
 	omap_set_mmc_info(1, &n800_mmc_data);
 	if (omap_request_gpio(slot_switch_gpio) < 0)
 		BUG();
 	omap_set_gpio_dataout(slot_switch_gpio, 0);
 	omap_set_gpio_direction(slot_switch_gpio, 0);
-	if (omap_request_gpio(slot1_wp_gpio) < 0)
-		BUG();
-	if (omap_request_gpio(slot2_wp_gpio) < 0)
-		BUG();
-	omap_set_gpio_direction(slot1_wp_gpio, 1);
-	omap_set_gpio_direction(slot2_wp_gpio, 1);
-}
 
+	if (machine_is_nokia_rx44() || machine_is_nokia_rx48()) {
+		if (omap_request_gpio(rx44_slot2_pw_vddf) < 0)
+			BUG();
+		omap_set_gpio_dataout(rx44_slot2_pw_vddf, 0);
+		omap_set_gpio_direction(rx44_slot2_pw_vddf, 0);
+
+		if (omap_request_gpio(rx44_slot2_pw_vdd) < 0)
+			BUG();
+		omap_set_gpio_dataout(rx44_slot2_pw_vdd, 0);
+		omap_set_gpio_direction(rx44_slot2_pw_vdd, 0);
+	}
+}
 #else
 
 void __init n800_mmc_init(void)
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/board-n800-pm.c maemo_src/arch/arm/mach-omap2/board-n800-pm.c
--- linux-omap-2.6/arch/arm/mach-omap2/board-n800-pm.c	2011-02-06 20:17:25.086666604 -0500
+++ maemo_src/arch/arm/mach-omap2/board-n800-pm.c	2011-02-06 20:12:09.783333274 -0500
@@ -13,6 +13,8 @@
 #include <linux/module.h>
 #include <asm/arch/menelaus.h>
 
+#include "dvfs.h"
+
 #ifdef CONFIG_MENELAUS
 
 static int n800_auto_sleep_regulators(void)
@@ -20,9 +22,9 @@
 	u32 val;
 	int ret;
 
-	val = EN_VPLL_SLEEP | EN_VMMC_SLEEP    \
-		| EN_VAUX_SLEEP | EN_VIO_SLEEP \
-		| EN_VMEM_SLEEP | EN_DC3_SLEEP \
+	val = EN_VPLL_SLEEP
+		| EN_VAUX_SLEEP | EN_VIO_SLEEP
+		| EN_VMEM_SLEEP
 		| EN_VC_SLEEP | EN_DC2_SLEEP;
 
 	ret = menelaus_set_regulator_sleep(1, val);
@@ -64,16 +66,25 @@
 	.late_init = n800_menelaus_init,
 };
 
-void __init n800_pm_init(void)
+static inline void menelaus_config(void)
 {
 	menelaus_set_platform_data(&n800_menelaus_platform_data);
 }
+#else
+#error
+#define menelaus_config()
+
+#endif
 
+#ifdef CONFIG_MACH_OMAP2420_DVFS
+extern int __init n800_dvfs_init(void);
 #else
+#define n800_dvfs_init()
+#endif
 
 void __init n800_pm_init(void)
 {
+	menelaus_config();
+	dvfs_init();
+	n800_dvfs_init();
 }
-
-#endif
-
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/board-n800-usb.c maemo_src/arch/arm/mach-omap2/board-n800-usb.c
--- linux-omap-2.6/arch/arm/mach-omap2/board-n800-usb.c	2011-02-06 20:17:25.123333273 -0500
+++ maemo_src/arch/arm/mach-omap2/board-n800-usb.c	2007-10-02 03:09:30.000000000 -0400
@@ -41,6 +41,7 @@
 	.set_power	= tusb_set_power,
 	.set_clock	= tusb_set_clock,
 	.min_power	= 25,	/* x2 = 50 mA drawn from VBUS as peripheral */
+	.power		= 100,	/* Max 100 mA VBUS for host mode */
 	.clock		= "osc_ck",
 };
 
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/board-n810.c maemo_src/arch/arm/mach-omap2/board-n810.c
--- linux-omap-2.6/arch/arm/mach-omap2/board-n810.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/mach-omap2/board-n810.c	2011-02-06 20:12:09.799999939 -0500
@@ -0,0 +1,494 @@
+/*
+ * board-rx44.c - Nokia RX-44 specific initialization
+ *
+ * Copyright (C) 2007 Nokia Corporation
+ * Contact: Jarkko Nikula <jarkko.nikula@nokia.com>
+ *
+ * Based on board-n800.c by Juha Yrjola <juha.yrjola@nokia.com>
+ *
+ * RX-44 specific configurations from:
+ *
+ * Timo Karjalainen
+ * Eero Nurkkala
+ * Henrik Saari
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/tsc2005.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/tsl2563.h>
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/usb.h>
+#include <asm/arch/board.h>
+#include <asm/arch/common.h>
+#include <asm/arch/mcspi.h>
+#include <asm/arch/menelaus.h>
+#include <asm/arch/lcd_mipid.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/gpio-switch.h>
+#include <asm/arch/omapfb.h>
+#include <asm/arch/blizzard.h>
+#include <asm/arch/pm.h>
+
+#include <../drivers/cbus/tahvo.h>
+
+#define RX44_BLIZZARD_POWERDOWN_GPIO	15
+#define RX44_STI_GPIO			62
+
+static void __init nokia_rx44_init_irq(void)
+{
+	omap2_init_common_hw();
+	omap_init_irq();
+	omap_gpio_init();
+
+#ifdef CONFIG_OMAP_STI
+	if (omap_request_gpio(RX44_STI_GPIO) < 0) {
+		printk(KERN_ERR "Failed to request GPIO %d for STI\n",
+		       RX44_STI_GPIO);
+		return;
+	}
+
+	omap_set_gpio_direction(RX44_STI_GPIO, 0);
+	omap_set_gpio_dataout(RX44_STI_GPIO, 0);
+#endif
+}
+
+#if defined(CONFIG_MENELAUS) && defined(CONFIG_SENSORS_TMP105)
+
+static int rx44_tmp105_set_power(int enable)
+{
+	return menelaus_set_vaux(enable ? 2800 : 0);
+}
+
+#else
+
+#define rx44_tmp105_set_power NULL
+
+#endif
+
+static struct omap_uart_config rx44_uart_config __initdata = {
+	.enabled_uarts = (1 << 0) | (1 << 2),
+};
+
+#include "../../../drivers/cbus/retu.h"
+
+static struct omap_fbmem_config rx44_fbmem0_config __initdata = {
+	.size = 752 * 1024,
+};
+
+static struct omap_fbmem_config rx44_fbmem1_config __initdata = {
+	.size = 768 * 1024,
+};
+
+static struct omap_fbmem_config rx44_fbmem2_config __initdata = {
+	.size = 1536 * 1024,
+};
+
+static struct omap_tmp105_config rx44_tmp105_config __initdata = {
+	.tmp105_irq_pin = 125,
+	.set_power = rx44_tmp105_set_power,
+};
+
+static struct omap_mmc_config rx44_mmc_config __initdata = {
+	.mmc [0] = {
+		.enabled		= 1,
+		.wire4			= 1,
+	},
+};
+
+static void mipid_shutdown(struct mipid_platform_data *pdata)
+{
+	if (pdata->nreset_gpio != -1) {
+		pr_info("shutdown LCD\n");
+		omap_set_gpio_dataout(pdata->nreset_gpio, 0);
+		msleep(120);
+	}
+}
+
+static struct mipid_platform_data rx44_mipid_platform_data = {
+	.shutdown = mipid_shutdown,
+};
+
+static void __init mipid_dev_init(void)
+{
+	const struct omap_lcd_config *conf;
+
+	conf = omap_get_config(OMAP_TAG_LCD, struct omap_lcd_config);
+	if (conf != NULL) {
+		rx44_mipid_platform_data.nreset_gpio = conf->nreset_gpio;
+		rx44_mipid_platform_data.data_lines = conf->data_lines;
+	}
+}
+
+static struct {
+	struct clk *sys_ck;
+} blizzard;
+
+static int blizzard_get_clocks(void)
+{
+	blizzard.sys_ck = clk_get(0, "osc_ck");
+	if (IS_ERR(blizzard.sys_ck)) {
+		printk(KERN_ERR "can't get Blizzard clock\n");
+		return PTR_ERR(blizzard.sys_ck);
+	}
+	return 0;
+}
+
+static unsigned long blizzard_get_clock_rate(struct device *dev)
+{
+	return clk_get_rate(blizzard.sys_ck);
+}
+
+static void blizzard_enable_clocks(int enable)
+{
+	if (enable)
+		clk_enable(blizzard.sys_ck);
+	else
+		clk_disable(blizzard.sys_ck);
+}
+
+static void blizzard_power_up(struct device *dev)
+{
+	/* Vcore to 1.475V */
+	tahvo_set_clear_reg_bits(0x07, 0, 0xf);
+	msleep(10);
+
+	blizzard_enable_clocks(1);
+	omap_set_gpio_dataout(RX44_BLIZZARD_POWERDOWN_GPIO, 1);
+}
+
+static void blizzard_power_down(struct device *dev)
+{
+	omap_set_gpio_dataout(RX44_BLIZZARD_POWERDOWN_GPIO, 0);
+	blizzard_enable_clocks(0);
+
+	/* Vcore to 1.005V */
+	tahvo_set_clear_reg_bits(0x07, 0xf, 0);
+}
+
+static struct blizzard_platform_data rx44_blizzard_data = {
+	.power_up	= blizzard_power_up,
+	.power_down	= blizzard_power_down,
+	.get_clock_rate	= blizzard_get_clock_rate,
+	.te_connected	= 1,
+};
+
+static void __init blizzard_dev_init(void)
+{
+	int r;
+
+	r = omap_request_gpio(RX44_BLIZZARD_POWERDOWN_GPIO);
+	if (r < 0)
+		return;
+	omap_set_gpio_direction(RX44_BLIZZARD_POWERDOWN_GPIO, 0);
+	omap_set_gpio_dataout(RX44_BLIZZARD_POWERDOWN_GPIO, 1);
+
+	blizzard_get_clocks();
+	omapfb_set_ctrl_platform_data(&rx44_blizzard_data);
+}
+
+#if defined(CONFIG_VIDEO_CAMERA_SENSOR_TCM825X) \
+	|| defined(CONFIG_VIDEO_CAMERA_SENSOR_TCM825X_MODULE)
+extern struct omap_camera_sensor_config n800_camera_sensor_config;
+#endif
+
+#ifdef CONFIG_SENSORS_TSL2563
+/* FIXME: Remove when bootloader passes this information */
+static struct tsl2563_config rx44_tsl2563_config = {
+	.irq_gpio	= 8,
+};
+#endif
+
+static struct omap_board_config_kernel rx44_config[] = {
+	{ OMAP_TAG_UART,	                &rx44_uart_config },
+#ifdef SUPPORT_SENSOR
+	{ OMAP_TAG_CAMERA_SENSOR,		&rx44_sensor_config },
+#endif
+	{ OMAP_TAG_FBMEM,			&rx44_fbmem0_config },
+	{ OMAP_TAG_FBMEM,			&rx44_fbmem1_config },
+	{ OMAP_TAG_FBMEM,			&rx44_fbmem2_config },
+	{ OMAP_TAG_TMP105,			&rx44_tmp105_config },
+	{ OMAP_TAG_MMC,                         &rx44_mmc_config },
+#if defined(CONFIG_VIDEO_CAMERA_SENSOR_TCM825X) \
+	|| defined(CONFIG_VIDEO_CAMERA_SENSOR_TCM825X_MODULE)
+	{ OMAP_TAG_CAMERA_SENSOR,		&n800_camera_sensor_config },
+#endif
+#ifdef CONFIG_SENSORS_TSL2563
+	{ OMAP_TAG_TSL2563,			&rx44_tsl2563_config },
+#endif
+};
+
+#ifdef CONFIG_TOUCHSCREEN_TSC2005
+static struct tsc2005_platform_data tsc2005_config = {
+	.reset_gpio = 94,
+	.dav_gpio = 106
+};
+#endif
+
+#ifdef CONFIG_SENSORS_TSL2563
+
+static struct {
+	struct clk *block_sleepx;
+} tsl2563;
+
+static void rx44_tsl2563_set_power(struct device *dev, int on)
+{
+	/*
+	 * on RX-44, TSL2563 is getting its power from the regulator which is
+	 * controlled with OMAP SYS_CLKREQ signal, i.e. regulator is shutdown
+	 * when OMAP is in retention. Therefore we'll block the retention when
+	 * TSL2563 needs to be powered
+	 */
+	if (on)
+		clk_enable(tsl2563.block_sleepx);
+	else
+		clk_disable(tsl2563.block_sleepx);
+}
+
+static struct tsl2563_platform_data tsl2563_data = {
+	.set_power	= rx44_tsl2563_set_power,
+};
+
+static struct platform_device rx44_tsl2563_device = {
+	.name		= "tsl2563",
+	.id		= -1,
+	.dev		= {
+		.platform_data = &tsl2563_data,
+	},
+};
+
+static void tsl2563_dev_init(void)
+{
+	const struct tsl2563_config *config;
+	int gpio;
+
+	config = omap_get_config(OMAP_TAG_TSL2563,
+				 struct tsl2563_config);
+	if (config != NULL) {
+		gpio = config->irq_gpio;
+		tsl2563_data.irq = OMAP_GPIO_IRQ(gpio);
+
+		tsl2563.block_sleepx = clk_get(0, "osc_ck");
+
+		if (omap_request_gpio(gpio) < 0) {
+			printk(KERN_ERR "Cannot get TSL2563 GPIO\n");
+			return;
+		}
+		omap_set_gpio_direction(gpio, 1);
+
+		if (platform_device_register(&rx44_tsl2563_device) < 0) {
+			printk(KERN_ERR "Cannot register TSL2563\n");
+			return;
+		}
+	}
+}
+#else
+static void tsl2563_dev_init(void) {}
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_TSC2005
+static struct omap2_mcspi_device_config tsc2005_mcspi_config = {
+	.turbo_mode	= 0,
+	.single_channel = 1,
+};
+#endif
+
+static struct omap2_mcspi_device_config mipid_mcspi_config = {
+	.turbo_mode	= 0,
+	.single_channel	= 1,
+};
+
+static struct omap2_mcspi_device_config cx3110x_mcspi_config = {
+	.turbo_mode	= 0,
+	.single_channel = 1,
+};
+
+#ifdef CONFIG_NET_PC2400M_MODULE
+static struct omap2_mcspi_device_config pc2400m_mcspi_config = {
+	.turbo_mode	= 1,
+	.single_channel = 1,
+};
+#endif
+
+static struct spi_board_info rx44_spi_board_info[] __initdata = {
+	[0] = {
+		.modalias	= "lcd_mipid",
+		.bus_num	= 1,
+		.chip_select	= 1,
+		.max_speed_hz	= 4000000,
+		.controller_data= &mipid_mcspi_config,
+		.platform_data	= &rx44_mipid_platform_data,
+	}, [1] = {
+		.modalias	= "cx3110x",
+		.bus_num	= 2,
+		.chip_select	= 0,
+		.max_speed_hz   = 48000000,
+		.controller_data= &cx3110x_mcspi_config,
+	},
+#ifdef CONFIG_NET_PC2400M_MODULE
+	[2] = {
+		.modalias	= "pc2400m",
+		.bus_num	= 2,
+		.chip_select	= 1,
+		.max_speed_hz   = 24000000,
+		.controller_data= &pc2400m_mcspi_config,
+		.irq		= 33,
+	},
+#endif
+#ifdef CONFIG_TOUCHSCREEN_TSC2005
+	{
+		.modalias	= "tsc2005",
+		.bus_num	= 1,
+		.chip_select	= 0,
+		.max_speed_hz   = 6000000,
+		.controller_data= &tsc2005_mcspi_config,
+		.platform_data  = &tsc2005_config,
+	}
+#endif	
+};
+
+static void __init rx44_ts_set_config(void)
+{
+	const struct omap_lcd_config *conf;
+
+	conf = omap_get_config(OMAP_TAG_LCD, struct omap_lcd_config);
+	if (conf != NULL) {
+#ifdef CONFIG_TOUCHSCREEN_TSC2005
+		if (strcmp(conf->panel_name, "lph8923") == 0) {
+			tsc2005_config.ts_x_plate_ohm	= 180;
+			tsc2005_config.ts_hw_avg	= 0;
+			tsc2005_config.ts_ignore_last	= 0;
+			tsc2005_config.ts_touch_pressure= 1500;
+			tsc2005_config.ts_stab_time	= 100;
+			tsc2005_config.ts_pressure_max	= 2048;
+			tsc2005_config.ts_pressure_fudge= 2;
+			tsc2005_config.ts_x_max		= 4096;
+			tsc2005_config.ts_x_fudge	= 4;
+			tsc2005_config.ts_y_max		= 4096;
+			tsc2005_config.ts_y_fudge	= 7;
+		} else if (strcmp(conf->panel_name, "ls041y3") == 0) {
+			tsc2005_config.ts_x_plate_ohm	= 280;
+			tsc2005_config.ts_hw_avg	= 0;
+			tsc2005_config.ts_ignore_last	= 0;
+			tsc2005_config.ts_touch_pressure= 1500;
+			tsc2005_config.ts_stab_time	= 1000;
+			tsc2005_config.ts_pressure_max	= 2048;
+			tsc2005_config.ts_pressure_fudge= 2;
+			tsc2005_config.ts_x_max		= 4096;
+			tsc2005_config.ts_x_fudge	= 4;
+			tsc2005_config.ts_y_max		= 4096;
+			tsc2005_config.ts_y_fudge	= 7;
+		} else {
+			printk(KERN_ERR "Unknown panel type, set default "
+			       "touchscreen configuration\n");
+			tsc2005_config.ts_x_plate_ohm	= 200;
+			tsc2005_config.ts_stab_time	= 100;
+		}
+#endif
+	}
+}
+
+static struct omap_gpio_switch rx44_gpio_switches[] __initdata = {
+	{
+		.name			= "headphone",
+		.gpio			= -1,
+		.debounce_rising	= 200,
+		.debounce_falling	= 200,
+	}, {
+		.name			= "cam_act",
+		.gpio			= -1,
+		.debounce_rising	= 200,
+		.debounce_falling	= 200,
+	}, {
+		.name			= "cam_turn",
+		.gpio			= -1,
+		.debounce_rising	= 100,
+		.debounce_falling	= 100,
+	}, {
+		.name			= "slide",
+		.gpio			= -1,
+		.debounce_rising	= 200,
+		.debounce_falling	= 200,
+	}, {
+		.name			= "kb_lock",
+		.gpio			= -1,
+		.debounce_rising	= 200,
+		.debounce_falling	= 200,
+	},
+};
+
+extern void __init n800_flash_init(void);
+extern void __init n800_mmc_init(void);
+extern void __init n800_bt_init(void);
+extern void __init rx44_audio_init(void);
+extern void __init n800_dsp_init(void);
+extern void __init n800_usb_init(void);
+extern void __init n800_cam_init(void);
+extern void __init n800_pm_init(void);
+extern void __init rx44_keyboard_init(void);
+
+static void __init nokia_rx44_init(void)
+{
+	n800_flash_init();
+	n800_mmc_init();
+	n800_bt_init();
+	rx44_audio_init();
+	n800_dsp_init();
+	n800_usb_init();
+	n800_cam_init();
+	rx44_ts_set_config();
+	rx44_keyboard_init();
+	spi_register_board_info(rx44_spi_board_info,
+				ARRAY_SIZE(rx44_spi_board_info));
+	omap_serial_init();
+	mipid_dev_init();
+	blizzard_dev_init();
+	tsl2563_dev_init();
+	omap_register_gpio_switches(rx44_gpio_switches,
+				    ARRAY_SIZE(rx44_gpio_switches));
+	n800_pm_init();
+}
+
+static void __init nokia_rx44_map_io(void)
+{
+	omap_board_config = rx44_config;
+	omap_board_config_size = ARRAY_SIZE(rx44_config);
+
+	omap2_map_common_io();
+}
+
+MACHINE_START(NOKIA_RX44, "Nokia RX-44")
+	.phys_io	= 0x48000000,
+	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.boot_params	= 0x80000100,
+	.map_io		= nokia_rx44_map_io,
+	.init_irq	= nokia_rx44_init_irq,
+	.init_machine	= nokia_rx44_init,
+	.timer		= &omap_timer,
+MACHINE_END
+
+MACHINE_START(NOKIA_RX48, "Nokia RX-48")
+	.phys_io	= 0x48000000,
+	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.boot_params	= 0x80000100,
+	.map_io		= nokia_rx44_map_io,
+	.init_irq	= nokia_rx44_init_irq,
+	.init_machine	= nokia_rx44_init,
+	.timer		= &omap_timer,
+MACHINE_END
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/board-n810-keyboard.c maemo_src/arch/arm/mach-omap2/board-n810-keyboard.c
--- linux-omap-2.6/arch/arm/mach-omap2/board-n810-keyboard.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/mach-omap2/board-n810-keyboard.c	2011-02-06 20:12:09.803333272 -0500
@@ -0,0 +1,108 @@
+/*
+ * arch/arm/mach-omap2/board-rx44-keyboard.c
+ *
+ * Copyright (C) 2007 Nokia Corporation
+ * Author: Daniel Stone <daniel.stone@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/lm8323.h>
+#include <asm/arch/gpio.h>
+
+#define RX44_KEYB_IRQ_GPIO		109
+
+#ifdef CONFIG_LM8323
+static s16 rx44_keymap[LM8323_KEYMAP_SIZE] = {
+	[0x01] = KEY_Q,
+	[0x02] = KEY_K,
+	[0x03] = KEY_O,
+	[0x04] = KEY_P,
+	[0x05] = KEY_BACKSPACE,
+	[0x06] = KEY_A,
+	[0x07] = KEY_S,
+	[0x08] = KEY_D,
+	[0x09] = KEY_F,
+	[0x0a] = KEY_G,
+	[0x0b] = KEY_H,
+	[0x0c] = KEY_J,
+
+	[0x11] = KEY_W,
+	[0x12] = KEY_F4,
+	[0x13] = KEY_L,
+	[0x14] = KEY_APOSTROPHE,
+	[0x16] = KEY_Z,
+	[0x17] = KEY_X,
+	[0x18] = KEY_C,
+	[0x19] = KEY_V,
+	[0x1a] = KEY_B,
+	[0x1b] = KEY_N,
+	[0x1c] = KEY_LEFTSHIFT, /* Actually, this is both shift keys */
+	[0x1f] = KEY_F7,
+
+	[0x21] = KEY_E,
+	[0x22] = KEY_SEMICOLON,
+	[0x23] = KEY_MINUS,
+	[0x24] = KEY_EQUAL,
+	[0x2b] = KEY_FN,
+	[0x2c] = KEY_M,
+	[0x2f] = KEY_F8,
+
+	[0x31] = KEY_R,
+	[0x32] = KEY_RIGHTCTRL,
+	[0x34] = KEY_SPACE,
+	[0x35] = KEY_COMMA,
+	[0x37] = KEY_UP,
+	[0x3c] = KEY_COMPOSE,
+	[0x3f] = KEY_F6,
+
+	[0x41] = KEY_T,
+	[0x44] = KEY_DOT,
+	[0x46] = KEY_RIGHT,
+	[0x4f] = KEY_F5,
+	[0x51] = KEY_Y,
+	[0x53] = KEY_DOWN,
+	[0x55] = KEY_ENTER,
+	[0x5f] = KEY_ESC,
+
+	[0x61] = KEY_U,
+	[0x64] = KEY_LEFT,
+
+	[0x71] = KEY_I,
+	[0x75] = KEY_KPENTER,
+};
+
+static struct lm8323_platform_data lm8323_config = {
+	.repeat = 0, /* Repeat is handled in userspace for now. */
+	.keymap = rx44_keymap,
+
+	.name = "Internal keyboard",
+	.pwm1_name = "keyboard",
+	.pwm2_name = "cover",
+};
+
+static void lm8323_dev_init(void)
+{
+	int gpio = RX44_KEYB_IRQ_GPIO;
+
+	if (omap_request_gpio(gpio) < 0) {
+		printk("can't get lm8323 GPIO\n");
+		return;
+	}
+	omap_set_gpio_direction(gpio, 1);
+	lm8323_config.irq_gpio = OMAP_GPIO_IRQ(gpio);
+
+	lm8323_set_platform_data(&lm8323_config);
+}
+#endif
+
+void __init rx44_keyboard_init(void)
+{
+#ifdef CONFIG_LM8323
+	lm8323_dev_init();
+#endif
+}
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/board-rx44.c maemo_src/arch/arm/mach-omap2/board-rx44.c
--- linux-omap-2.6/arch/arm/mach-omap2/board-rx44.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/mach-omap2/board-rx44.c	2007-10-02 03:09:30.000000000 -0400
@@ -0,0 +1,465 @@
+/*
+ * board-rx44.c - Nokia RX-44 specific initialization
+ *
+ * Copyright (C) 2007 Nokia Corporation
+ * Contact: Jarkko Nikula <jarkko.nikula@nokia.com>
+ *
+ * Based on board-n800.c by Juha Yrjola <juha.yrjola@nokia.com>
+ *
+ * RX-44 specific configurations from:
+ *
+ * Timo Karjalainen
+ * Eero Nurkkala
+ * Henrik Saari
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/tsc2005.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/tsl2563.h>
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/usb.h>
+#include <asm/arch/board.h>
+#include <asm/arch/common.h>
+#include <asm/arch/mcspi.h>
+#include <asm/arch/menelaus.h>
+#include <asm/arch/lcd_mipid.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/gpio-switch.h>
+#include <asm/arch/omapfb.h>
+#include <asm/arch/blizzard.h>
+#include <asm/arch/pm.h>
+
+#include <../drivers/cbus/tahvo.h>
+
+#define RX44_BLIZZARD_POWERDOWN_GPIO	15
+#define RX44_STI_GPIO			62
+
+static void __init nokia_rx44_init_irq(void)
+{
+	omap2_init_common_hw();
+	omap_init_irq();
+	omap_gpio_init();
+
+#ifdef CONFIG_OMAP_STI
+	if (omap_request_gpio(RX44_STI_GPIO) < 0) {
+		printk(KERN_ERR "Failed to request GPIO %d for STI\n",
+		       RX44_STI_GPIO);
+		return;
+	}
+
+	omap_set_gpio_direction(RX44_STI_GPIO, 0);
+	omap_set_gpio_dataout(RX44_STI_GPIO, 0);
+#endif
+}
+
+#if defined(CONFIG_MENELAUS) && defined(CONFIG_SENSORS_TMP105)
+
+static int rx44_tmp105_set_power(int enable)
+{
+	return menelaus_set_vaux(enable ? 2800 : 0);
+}
+
+#else
+
+#define rx44_tmp105_set_power NULL
+
+#endif
+
+static struct omap_uart_config rx44_uart_config __initdata = {
+	.enabled_uarts = (1 << 0) | (1 << 2),
+};
+
+#include "../../../drivers/cbus/retu.h"
+
+static struct omap_fbmem_config rx44_fbmem0_config __initdata = {
+	.size = 752 * 1024,
+};
+
+static struct omap_fbmem_config rx44_fbmem1_config __initdata = {
+	.size = 768 * 1024,
+};
+
+static struct omap_fbmem_config rx44_fbmem2_config __initdata = {
+	.size = 1536 * 1024,
+};
+
+static struct omap_tmp105_config rx44_tmp105_config __initdata = {
+	.tmp105_irq_pin = 125,
+	.set_power = rx44_tmp105_set_power,
+};
+
+static struct omap_mmc_config rx44_mmc_config __initdata = {
+	.mmc [0] = {
+		.enabled		= 1,
+		.wire4			= 1,
+	},
+};
+
+static void mipid_shutdown(struct mipid_platform_data *pdata)
+{
+	if (pdata->nreset_gpio != -1) {
+		pr_info("shutdown LCD\n");
+		omap_set_gpio_dataout(pdata->nreset_gpio, 0);
+		msleep(120);
+	}
+}
+
+static struct mipid_platform_data rx44_mipid_platform_data = {
+	.shutdown = mipid_shutdown,
+};
+
+static void __init mipid_dev_init(void)
+{
+	const struct omap_lcd_config *conf;
+
+	conf = omap_get_config(OMAP_TAG_LCD, struct omap_lcd_config);
+	if (conf != NULL) {
+		rx44_mipid_platform_data.nreset_gpio = conf->nreset_gpio;
+		rx44_mipid_platform_data.data_lines = conf->data_lines;
+	}
+}
+
+static struct {
+	struct clk *sys_ck;
+} blizzard;
+
+static int blizzard_get_clocks(void)
+{
+	blizzard.sys_ck = clk_get(0, "osc_ck");
+	if (IS_ERR(blizzard.sys_ck)) {
+		printk(KERN_ERR "can't get Blizzard clock\n");
+		return PTR_ERR(blizzard.sys_ck);
+	}
+	return 0;
+}
+
+static unsigned long blizzard_get_clock_rate(struct device *dev)
+{
+	return clk_get_rate(blizzard.sys_ck);
+}
+
+static void blizzard_enable_clocks(int enable)
+{
+	if (enable)
+		clk_enable(blizzard.sys_ck);
+	else
+		clk_disable(blizzard.sys_ck);
+}
+
+static void blizzard_power_up(struct device *dev)
+{
+	/* Vcore to 1.475V */
+	tahvo_set_clear_reg_bits(0x07, 0, 0xf);
+	msleep(10);
+
+	blizzard_enable_clocks(1);
+	omap_set_gpio_dataout(RX44_BLIZZARD_POWERDOWN_GPIO, 1);
+}
+
+static void blizzard_power_down(struct device *dev)
+{
+	omap_set_gpio_dataout(RX44_BLIZZARD_POWERDOWN_GPIO, 0);
+	blizzard_enable_clocks(0);
+
+	/* Vcore to 1.005V */
+	tahvo_set_clear_reg_bits(0x07, 0xf, 0);
+}
+
+static struct blizzard_platform_data rx44_blizzard_data = {
+	.power_up	= blizzard_power_up,
+	.power_down	= blizzard_power_down,
+	.get_clock_rate	= blizzard_get_clock_rate,
+	.te_connected	= 1,
+};
+
+static void __init blizzard_dev_init(void)
+{
+	int r;
+
+	r = omap_request_gpio(RX44_BLIZZARD_POWERDOWN_GPIO);
+	if (r < 0)
+		return;
+	omap_set_gpio_direction(RX44_BLIZZARD_POWERDOWN_GPIO, 0);
+	omap_set_gpio_dataout(RX44_BLIZZARD_POWERDOWN_GPIO, 1);
+
+	blizzard_get_clocks();
+	omapfb_set_ctrl_platform_data(&rx44_blizzard_data);
+}
+
+#if defined(CONFIG_VIDEO_CAMERA_SENSOR_TCM825X) \
+	|| defined(CONFIG_VIDEO_CAMERA_SENSOR_TCM825X_MODULE)
+extern struct omap_camera_sensor_config n800_camera_sensor_config;
+#endif
+
+#ifdef CONFIG_SENSORS_TSL2563
+/* FIXME: Remove when bootloader passes this information */
+static struct tsl2563_config rx44_tsl2563_config = {
+	.irq_gpio	= 8,
+};
+#endif
+
+static struct omap_board_config_kernel rx44_config[] = {
+	{ OMAP_TAG_UART,	                &rx44_uart_config },
+#ifdef SUPPORT_SENSOR
+	{ OMAP_TAG_CAMERA_SENSOR,		&rx44_sensor_config },
+#endif
+	{ OMAP_TAG_FBMEM,			&rx44_fbmem0_config },
+	{ OMAP_TAG_FBMEM,			&rx44_fbmem1_config },
+	{ OMAP_TAG_FBMEM,			&rx44_fbmem2_config },
+	{ OMAP_TAG_TMP105,			&rx44_tmp105_config },
+	{ OMAP_TAG_MMC,                         &rx44_mmc_config },
+#if defined(CONFIG_VIDEO_CAMERA_SENSOR_TCM825X) \
+	|| defined(CONFIG_VIDEO_CAMERA_SENSOR_TCM825X_MODULE)
+	{ OMAP_TAG_CAMERA_SENSOR,		&n800_camera_sensor_config },
+#endif
+#ifdef CONFIG_SENSORS_TSL2563
+	{ OMAP_TAG_TSL2563,			&rx44_tsl2563_config },
+#endif
+};
+
+#ifdef CONFIG_SPI_TSC2005
+static struct tsc2005_platform_data tsc2005_config = {
+	.reset_gpio = 94,
+	.dav_gpio = 106
+};
+#endif
+
+#ifdef CONFIG_SENSORS_TSL2563
+static void rx44_tsl2563_set_power(struct device *dev, int on)
+{
+	/*
+	 * on RX-44, TSL2563 is getting its power from the regulator which is
+	 * controlled with OMAP SYS_CLKREQ signal, i.e. regulator is shutdown
+	 * when OMAP is in retention. Therefore we'll block the retention when
+	 * TSL2563 needs to be powered
+	 */
+	if (on)
+		omap2_block_sleep();
+	else
+		omap2_allow_sleep();
+}
+
+static struct tsl2563_platform_data tsl2563_data = {
+	.set_power	= rx44_tsl2563_set_power,
+};
+
+static struct platform_device rx44_tsl2563_device = {
+	.name		= "tsl2563",
+	.id		= -1,
+	.dev		= {
+		.platform_data = &tsl2563_data,
+	},
+};
+
+static void tsl2563_dev_init(void)
+{
+	const struct tsl2563_config *config;
+	int gpio;
+
+	config = omap_get_config(OMAP_TAG_TSL2563,
+				 struct tsl2563_config);
+	if (config != NULL) {
+		gpio = config->irq_gpio;
+		tsl2563_data.irq = OMAP_GPIO_IRQ(gpio);
+
+		if (omap_request_gpio(gpio) < 0) {
+			printk(KERN_ERR "Cannot get TSL2563 GPIO\n");
+			return;
+		}
+		omap_set_gpio_direction(gpio, 1);
+
+		if (platform_device_register(&rx44_tsl2563_device) < 0) {
+			printk(KERN_ERR "Cannot register TSL2563\n");
+			return;
+		}
+	}
+}
+#else
+static void tsl2563_dev_init(void) {}
+#endif
+
+#ifdef CONFIG_SPI_TSC2005
+static struct omap2_mcspi_device_config tsc2005_mcspi_config = {
+	.turbo_mode	= 0,
+	.single_channel = 1,
+};
+#endif
+
+static struct omap2_mcspi_device_config mipid_mcspi_config = {
+	.turbo_mode	= 0,
+	.single_channel	= 1,
+};
+
+static struct omap2_mcspi_device_config cx3110x_mcspi_config = {
+	.turbo_mode	= 0,
+	.single_channel = 1,
+};
+
+#ifdef CONFIG_NET_PC2400M_MODULE
+static struct omap2_mcspi_device_config pc2400m_mcspi_config = {
+	.turbo_mode	= 1,
+	.single_channel = 1,
+};
+#endif
+
+static struct spi_board_info rx44_spi_board_info[] __initdata = {
+	[0] = {
+		.modalias	= "lcd_mipid",
+		.bus_num	= 1,
+		.chip_select	= 1,
+		.max_speed_hz	= 4000000,
+		.controller_data= &mipid_mcspi_config,
+		.platform_data	= &rx44_mipid_platform_data,
+	}, [1] = {
+		.modalias	= "cx3110x",
+		.bus_num	= 2,
+		.chip_select	= 0,
+		.max_speed_hz   = 48000000,
+		.controller_data= &cx3110x_mcspi_config,
+	},
+#ifdef CONFIG_NET_PC2400M_MODULE
+	[2] = {
+		.modalias	= "pc2400m",
+		.bus_num	= 2,
+		.chip_select	= 1,
+		.max_speed_hz   = 24000000,
+		.controller_data= &pc2400m_mcspi_config,
+		.irq		= 33,
+	},
+#endif
+#ifdef CONFIG_SPI_TSC2005
+	{
+		.modalias	= "tsc2005",
+		.bus_num	= 1,
+		.chip_select	= 0,
+		.max_speed_hz   = 6000000,
+		.controller_data= &tsc2005_mcspi_config,
+		.platform_data  = &tsc2005_config,
+	}
+#endif	
+};
+
+static void __init rx44_ts_set_config(void)
+{
+	const struct omap_lcd_config *conf;
+
+	conf = omap_get_config(OMAP_TAG_LCD, struct omap_lcd_config);
+	if (conf != NULL) {
+#ifdef CONFIG_SPI_TSC2005
+		if (strcmp(conf->panel_name, "lph8923") == 0) {
+			tsc2005_config.ts_x_plate_ohm	= 180;
+			tsc2005_config.ts_hw_avg	= 4;
+			tsc2005_config.ts_ignore_last	= 1;
+			tsc2005_config.ts_max_pressure	= 255;
+			tsc2005_config.ts_stab_time	= 100;
+		} else if (strcmp(conf->panel_name, "ls041y3") == 0) {
+			tsc2005_config.ts_x_plate_ohm	= 280;
+			tsc2005_config.ts_hw_avg	= 16;
+			tsc2005_config.ts_touch_pressure= 1500;
+			tsc2005_config.ts_max_pressure	= 1500;
+			tsc2005_config.ts_ignore_last	= 1;
+		} else {
+			printk(KERN_ERR "Unknown panel type, set default "
+			       "touchscreen configuration\n");
+			tsc2005_config.ts_x_plate_ohm	= 200;
+			tsc2005_config.ts_stab_time	= 100;
+		}
+#endif
+	}
+}
+
+static struct omap_gpio_switch rx44_gpio_switches[] __initdata = {
+	{
+		.name			= "headphone",
+		.gpio			= -1,
+		.debounce_rising	= 200,
+		.debounce_falling	= 200,
+	}, {
+		.name			= "cam_act",
+		.gpio			= -1,
+		.debounce_rising	= 200,
+		.debounce_falling	= 200,
+	}, {
+		.name			= "cam_turn",
+		.gpio			= -1,
+		.debounce_rising	= 100,
+		.debounce_falling	= 100,
+	}, {
+		.name			= "slide",
+		.gpio			= -1,
+		.debounce_rising	= 200,
+		.debounce_falling	= 200,
+	}, {
+		.name			= "kb_lock",
+		.gpio			= -1,
+		.debounce_rising	= 200,
+		.debounce_falling	= 200,
+	},
+};
+
+extern void __init n800_flash_init(void);
+extern void __init n800_mmc_init(void);
+extern void __init n800_bt_init(void);
+extern void __init rx44_audio_init(void);
+extern void __init n800_dsp_init(void);
+extern void __init n800_usb_init(void);
+extern void __init n800_cam_init(void);
+extern void __init n800_pm_init(void);
+extern void __init rx44_keyboard_init(void);
+
+static void __init nokia_rx44_init(void)
+{
+	n800_flash_init();
+	n800_mmc_init();
+	n800_bt_init();
+	rx44_audio_init();
+	n800_dsp_init();
+	n800_usb_init();
+	n800_cam_init();
+	rx44_ts_set_config();
+	rx44_keyboard_init();
+	spi_register_board_info(rx44_spi_board_info,
+				ARRAY_SIZE(rx44_spi_board_info));
+	omap_serial_init();
+	mipid_dev_init();
+	blizzard_dev_init();
+	tsl2563_dev_init();
+	omap_register_gpio_switches(rx44_gpio_switches,
+				    ARRAY_SIZE(rx44_gpio_switches));
+	n800_pm_init();
+}
+
+static void __init nokia_rx44_map_io(void)
+{
+	omap_board_config = rx44_config;
+	omap_board_config_size = ARRAY_SIZE(rx44_config);
+
+	omap2_map_common_io();
+}
+
+MACHINE_START(NOKIA_RX44, "Nokia RX-44")
+	.phys_io	= 0x48000000,
+	.io_pg_offst	= ((0xd8000000) >> 18) & 0xfffc,
+	.boot_params	= 0x80000100,
+	.map_io		= nokia_rx44_map_io,
+	.init_irq	= nokia_rx44_init_irq,
+	.init_machine	= nokia_rx44_init,
+	.timer		= &omap_timer,
+MACHINE_END
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/board-rx44-keyboard.c maemo_src/arch/arm/mach-omap2/board-rx44-keyboard.c
--- linux-omap-2.6/arch/arm/mach-omap2/board-rx44-keyboard.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/mach-omap2/board-rx44-keyboard.c	2007-10-02 03:09:30.000000000 -0400
@@ -0,0 +1,108 @@
+/*
+ * arch/arm/mach-omap2/board-rx44-keyboard.c
+ *
+ * Copyright (C) 2007 Nokia Corporation
+ * Author: Daniel Stone <daniel.stone@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/lm8323.h>
+#include <asm/arch/gpio.h>
+
+#define RX44_KEYB_IRQ_GPIO		109
+
+#ifdef CONFIG_LM8323
+static s16 rx44_keymap[LM8323_KEYMAP_SIZE] = {
+	[0x01] = KEY_Q,
+	[0x02] = KEY_K,
+	[0x03] = KEY_O,
+	[0x04] = KEY_P,
+	[0x05] = KEY_BACKSPACE,
+	[0x06] = KEY_A,
+	[0x07] = KEY_S,
+	[0x08] = KEY_D,
+	[0x09] = KEY_F,
+	[0x0a] = KEY_G,
+	[0x0b] = KEY_H,
+	[0x0c] = KEY_J,
+
+	[0x11] = KEY_W,
+	[0x12] = KEY_F4,
+	[0x13] = KEY_L,
+	[0x14] = KEY_APOSTROPHE,
+	[0x16] = KEY_Z,
+	[0x17] = KEY_X,
+	[0x18] = KEY_C,
+	[0x19] = KEY_V,
+	[0x1a] = KEY_B,
+	[0x1b] = KEY_N,
+	[0x1c] = KEY_LEFTSHIFT, /* Actually, this is both shift keys */
+	[0x1f] = KEY_F7,
+
+	[0x21] = KEY_E,
+	[0x22] = KEY_SEMICOLON,
+	[0x23] = KEY_MINUS,
+	[0x24] = KEY_EQUAL,
+	[0x2b] = KEY_FN,
+	[0x2c] = KEY_M,
+	[0x2f] = KEY_F8,
+
+	[0x31] = KEY_R,
+	[0x32] = KEY_RIGHTCTRL,
+	[0x34] = KEY_SPACE,
+	[0x35] = KEY_COMMA,
+	[0x37] = KEY_UP,
+	[0x3c] = KEY_COMPOSE,
+	[0x3f] = KEY_F6,
+
+	[0x41] = KEY_T,
+	[0x44] = KEY_DOT,
+	[0x46] = KEY_RIGHT,
+	[0x4f] = KEY_F5,
+	[0x51] = KEY_Y,
+	[0x53] = KEY_DOWN,
+	[0x55] = KEY_ENTER,
+	[0x5f] = KEY_ESC,
+
+	[0x61] = KEY_U,
+	[0x64] = KEY_LEFT,
+
+	[0x71] = KEY_I,
+	[0x75] = KEY_KPENTER,
+};
+
+static struct lm8323_platform_data lm8323_config = {
+	.repeat = 0, /* Repeat is handled in userspace for now. */
+	.keymap = rx44_keymap,
+
+	.name = "Internal keyboard",
+	.pwm1_name = "keyboard",
+	.pwm2_name = "cover",
+};
+
+static void lm8323_dev_init(void)
+{
+	int gpio = RX44_KEYB_IRQ_GPIO;
+
+	if (omap_request_gpio(gpio) < 0) {
+		printk("can't get lm8323 GPIO\n");
+		return;
+	}
+	omap_set_gpio_direction(gpio, 1);
+	lm8323_config.irq_gpio = OMAP_GPIO_IRQ(gpio);
+
+	lm8323_set_platform_data(&lm8323_config);
+}
+#endif
+
+void __init rx44_keyboard_init(void)
+{
+#ifdef CONFIG_LM8323
+	lm8323_dev_init();
+#endif
+}
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/clock.c maemo_src/arch/arm/mach-omap2/clock.c
--- linux-omap-2.6/arch/arm/mach-omap2/clock.c	2011-02-06 20:17:25.126666606 -0500
+++ maemo_src/arch/arm/mach-omap2/clock.c	2007-10-02 03:09:30.000000000 -0400
@@ -1089,6 +1089,14 @@
 }
 
 /*
+ * DFS scaled clocks, refresh rates
+ */
+void omap2_clk_recalc_tree(void)
+{
+	propagate_rate(&osc_ck);
+}
+
+/*
  * Switch the MPU rate if specified on cmdline.
  * We cannot do this early until cmdline is parsed.
  */
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/clock.h maemo_src/arch/arm/mach-omap2/clock.h
--- linux-omap-2.6/arch/arm/mach-omap2/clock.h	2011-02-06 20:17:25.129999939 -0500
+++ maemo_src/arch/arm/mach-omap2/clock.h	2007-10-02 03:09:30.000000000 -0400
@@ -29,6 +29,8 @@
 static u32 omap2_clksel_to_divisor(u32 div_sel, u32 field_val);
 static u32 omap2_clksel_get_divisor(struct clk *clk);
 
+void omap2_clk_recalc_tree(void);
+
 /* REVISIT: should use a clock flag for this, not a magic number */
 #define PARENT_CONTROLS_CLOCK	0xff
 
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/cpu.c maemo_src/arch/arm/mach-omap2/cpu.c
--- linux-omap-2.6/arch/arm/mach-omap2/cpu.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/mach-omap2/cpu.c	2007-10-02 03:09:30.000000000 -0400
@@ -0,0 +1,241 @@
+/*
+ * File: linux/arch/arm/mach-omap2/cpu.c
+ *
+ * Copyright (C) 2007 Nokia Corporation.
+ *
+ * Klaus Pedersen <klaus.k.pedersen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/cpufreq.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/clk.h>
+
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/system.h>
+
+#include "dvfs.h"
+
+#define dprintk(msg...) \
+	cpufreq_debug_printk(CPUFREQ_DEBUG_DRIVER, "omap-dvfs", msg)
+
+static struct cpufreq_driver omap_driver;
+
+static struct cpu_model *omap_model;
+
+#define OP(mhz, op) { \
+	.frequency = (mhz) * 1000,  \
+	.index = op,                \
+}
+
+static struct cpufreq_frequency_table omap242x_std[] = {
+	OP(165,  3),
+	OP(266,  2),
+	OP(330,  1),
+	OP(400,  0),
+	{ .frequency = CPUFREQ_TABLE_END }
+};
+
+struct cpu_model {
+	unsigned	cpu_id;
+	const char	*model_name;
+	unsigned	max_freq; /* max clock in kHz */
+	struct cpufreq_frequency_table *op_points;  /* clock/OP pairs */
+};
+
+#define _OMAP(cpuid, max, op_s, name) { \
+	.cpu_id         = cpuid,	                          \
+	.model_name     = "Texas(R) OMAP(R) " name " processor ", \
+	.max_freq       = (max)*1000,	                          \
+	.op_points      = op_s,	                                  \
+}
+
+/* CPU models, their operating frequency range, and freq/voltage
+   operating points */
+static struct cpu_model models[] = {
+	_OMAP(2420, 400, omap242x_std, "242x-std"),
+	{ .cpu_id = UINT_MAX, }
+};
+#undef _OMAP
+#undef OP
+
+static int omap_verify_cpu_id(int model_id)
+{
+    return 1;  /* Just say yes */
+}
+
+static int omap_cpu_init_table(struct cpufreq_policy *policy)
+{
+	struct cpu_model *model;
+
+	for (model = models; model->cpu_id != UINT_MAX; model++)
+		if (omap_verify_cpu_id(model->cpu_id))
+			break;
+
+	omap_model = model;
+
+	dprintk("found \"%s\": max frequency: %dkHz\n",
+	        model->model_name, model->max_freq);
+
+	return 0;
+}
+
+static unsigned extract_clock(unsigned op)
+{
+	int i;
+	struct cpufreq_frequency_table *p;
+
+	if (!omap_model || !omap_model->op_points)
+		return 0;
+
+	p = omap_model->op_points;
+	for (i = 0; p[i].frequency != CPUFREQ_TABLE_END; i++) {
+		if (op == p[i].index)
+			return p[i].frequency;
+	}
+	BUG_ON(i == 0);
+	return p[i-1].frequency;
+}
+
+/**
+ * omap_verify_speed - verifies a new CPUFreq policy
+ * @policy: new policy
+ *
+ * Limit must be within this model's frequency range at least one
+ * border included.
+ */
+static int omap_verify_speed(struct cpufreq_policy *policy)
+{
+	return cpufreq_frequency_table_verify(policy, omap_model->op_points);
+}
+
+/**
+ * omap_get_speed - get the current frequency
+ * @cpu: for cpu
+ *
+ * Return the current clock freq of cpu: @cpu
+ */
+static unsigned int omap_get_speed(unsigned int cpu)
+{
+	if (cpu)
+		return 0;
+	return extract_clock(omap242x_dvfs_get_op());
+}
+
+/**
+ * omap_setpolicy - set a new CPUFreq policy
+ * @policy: new policy
+ * @target_freq: the target frequency
+ * @relation: how that frequency relates to achieved frequency 
+ *            (CPUFREQ_RELATION_L or CPUFREQ_RELATION_H)
+ *
+ * Sets a new CPUFreq policy.
+ */
+static int omap_target(struct cpufreq_policy *policy,
+		       unsigned int target_freq,
+		       unsigned int relation)
+{
+	struct cpufreq_freqs freqs;
+	unsigned int         newstate = 0;
+	unsigned int         op;
+
+	if (policy->cpu != 0)
+		return -ENODEV;
+
+	if (unlikely(cpufreq_frequency_table_target(policy,
+		     omap_model->op_points,
+		     target_freq,
+		     relation,
+		     &newstate))) {
+		return -EINVAL;
+	}
+
+	op = omap_model->op_points[newstate].index;
+
+	if (op == omap242x_dvfs_get_op()) {
+		dprintk("no change needed - OP was and needs to be %x\n", op);
+		return 0;
+	}
+
+	freqs.cpu = 0;
+	freqs.old = extract_clock(omap242x_dvfs_get_op());
+	freqs.new = extract_clock(op);
+
+	dprintk("target=%dkHz old=%d new=%d op=%d\n",
+		target_freq, freqs.old, freqs.new, op);
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+
+	omap242x_dvfs_set_op(op);
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+
+	return 0;
+}
+
+static int __init omap_cpu_init(struct cpufreq_policy *policy)
+{
+	unsigned freq;
+	int ret;
+
+	if (omap_cpu_init_table(policy))
+		return -ENODEV;
+
+	freq = omap_get_speed(policy->cpu);
+
+	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
+	policy->cpuinfo.transition_latency = 100000;  /* 100us */
+	policy->cur = freq;
+
+	dprintk("omap_cpu_init: cur=%dkHz\n", policy->cur);
+
+	ret = cpufreq_frequency_table_cpuinfo(policy, omap_model->op_points);
+	if (ret)
+		return (ret);
+
+	cpufreq_frequency_table_get_attr(omap_model->op_points, policy->cpu);
+
+	return 0;
+}
+
+static struct freq_attr *omap_attr[] = {
+	&cpufreq_freq_attr_scaling_available_freqs,
+	NULL,
+};
+
+static struct cpufreq_driver omap_driver = {
+	.name           = "omap",
+	.flags          = CPUFREQ_STICKY,
+	.init           = omap_cpu_init,
+	.verify         = omap_verify_speed,
+	.target         = omap_target,
+	.get            = omap_get_speed,
+	.attr           = omap_attr,
+};
+
+static int __init omap_cpufreq_init(void)
+{
+	return cpufreq_register_driver(&omap_driver);
+}
+
+arch_initcall(omap_cpufreq_init);
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/devices.c maemo_src/arch/arm/mach-omap2/devices.c
--- linux-omap-2.6/arch/arm/mach-omap2/devices.c	2011-02-06 20:17:25.163333273 -0500
+++ maemo_src/arch/arm/mach-omap2/devices.c	2007-10-02 03:09:30.000000000 -0400
@@ -25,6 +25,40 @@
 #include <asm/arch/gpio.h>
 #include <asm/arch/eac.h>
 
+
+#if defined(CONFIG_VIDEO_OMAP_CAMERA) || defined(CONFIG_VIDEO_OMAP_CAMERA_MODULE)
+
+#define OMAP2_CAM_BASE		0x48052000
+#define OMAP2_CAM_MPU_IRQ	24
+
+static struct resource cam_resources[] = {
+	{
+		.start		= OMAP2_CAM_BASE,
+		.end		= OMAP2_CAM_BASE + 0xfff,
+		.flags		= IORESOURCE_MEM,
+	},
+	{
+		.start		= OMAP2_CAM_MPU_IRQ,
+		.flags		= IORESOURCE_IRQ,
+	}
+};
+
+static struct platform_device omap_cam_device = {
+	.name		= "omap24xxcam",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(cam_resources),
+	.resource	= cam_resources,
+};
+
+static inline void omap_init_camera(void)
+{
+	platform_device_register(&omap_cam_device);
+}
+#else
+static inline void omap_init_camera(void) {}
+#endif
+
+
 #if	!defined(CONFIG_ARCH_OMAP243X)
 #if	defined(CONFIG_I2C_OMAP) || defined(CONFIG_I2C_OMAP_MODULE)
 
@@ -246,6 +280,7 @@
 	/* please keep these calls, and their implementations above,
 	 * in alphabetical order so they're easier to sort through.
 	 */
+	omap_init_camera();
 	if (!cpu_is_omap2430()) {
 		omap_init_i2c();
 	}
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/dvfs.c maemo_src/arch/arm/mach-omap2/dvfs.c
--- linux-omap-2.6/arch/arm/mach-omap2/dvfs.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/mach-omap2/dvfs.c	2011-02-06 20:12:09.759999940 -0500
@@ -0,0 +1,660 @@
+/*
+ * arch/arm/mach-omap2/dvfs.c
+ *
+ * Copyright (C) 2007 Nokia Corporation.
+ *
+ * Contact: Igor Stoppa <igor.stoppa@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <asm/arch/dma.h>
+#include <asm/arch/mmc.h>
+#include <asm/arch/mcspi.h>
+#include <asm/arch/dsp.h>
+#include <asm/arch/onenand.h>
+#include <asm/mach-types.h>
+#include <asm/arch/menelaus.h>
+#include <asm/arch/sram.h>
+#include <asm/arch/omapfb.h>
+#include <asm/io.h>
+#include "scale_freq.h"
+#include "dvfs.h"
+#include "irq.h"
+
+/* A HW bug on 2420 prevents dividers greater than 8 */
+#define MAX_DPLL_DIV		8
+#define MAX_DPLL_MULT		((1 << 10) - 1)
+
+#define CORE_VTG_FLOOR		1050
+
+#define PRCM_BASE		0x48008000
+#define PRCM_VOLTCTRL		0x050
+
+enum omap242x_packed_op_parms {
+	CM_CLKSEL_MPU = 0,
+	CM_CLKSEL_GFX,
+	CM_CLKSEL_DSP,
+	CM_CLKSEL1_CORE,
+	NUM_MMAPPED_PARMS,
+	OTHER_PARMS = NUM_MMAPPED_PARMS - 1,
+	CM_CLKSEL1_PLL,
+	CM_CLKSEL2_PLL,
+	VCORE_ROOF,
+	NUM_PACKED_OP_PARMS,
+};
+
+enum omap242x_bitfields {
+	CLKSEL_MPU = 0,
+	CLKSEL_GFX,
+	CLKSEL_DSP,
+	CLKSEL_DSP_IF,
+	CLKSEL_IVA,
+	CLKSEL_L3,
+	CLKSEL_L4,
+	CLKSEL_DSS1,
+	CLKSEL_DSS2,
+	CLKSEL_VLYNQ,
+	CLKSEL_SSI,
+	CLKSEL_USB,
+	NUM_DIVIDERS,
+	OTHER_BITFIELDS = NUM_DIVIDERS - 1,
+	_48M_SOURCE,
+	_54M_SOURCE,
+	DPLL_DIV,
+	DPLL_MULT,
+	APLLS_CLKIN,
+	CORE_CLK_SRC,
+	SYNC_DSP,
+	SYNC_IVA,
+	NUM_BITFIELDS,
+};
+
+enum omap242x_bitfield_parms{
+	REG = 0,
+	OFFS,
+	LEN,
+	NUM_BITFIELD_PARMS,
+};
+
+static const u32 mmapped_parms_addr[NUM_MMAPPED_PARMS] = {
+	[CM_CLKSEL_MPU]		= 0x48008140,
+	[CM_CLKSEL_DSP]		= 0x48008840,
+	[CM_CLKSEL_GFX]		= 0x48008340,
+	[CM_CLKSEL1_CORE]	= 0x48008240,
+};
+
+static const u8 bitfields[NUM_BITFIELDS][NUM_BITFIELD_PARMS] = {
+	[CLKSEL_MPU]	= {[REG] = CM_CLKSEL_MPU,   [OFFS] =  0, [LEN] =  5,},
+	[CLKSEL_GFX]	= {[REG] = CM_CLKSEL_GFX,   [OFFS] =  0, [LEN] =  5,},
+	[CLKSEL_DSP]	= {[REG] = CM_CLKSEL_DSP,   [OFFS] =  0, [LEN] =  5,},
+	[CLKSEL_DSP_IF]	= {[REG] = CM_CLKSEL_DSP,   [OFFS] =  5, [LEN] =  2,},
+	[SYNC_DSP]	= {[REG] = CM_CLKSEL_DSP,   [OFFS] =  7, [LEN] =  1,},
+	[CLKSEL_IVA]	= {[REG] = CM_CLKSEL_DSP,   [OFFS] =  8, [LEN] =  5,},
+	[SYNC_IVA]	= {[REG] = CM_CLKSEL_DSP,   [OFFS] = 13, [LEN] =  1,},
+	[CLKSEL_L3]	= {[REG] = CM_CLKSEL1_CORE, [OFFS] =  0, [LEN] =  5,},
+	[CLKSEL_L4]	= {[REG] = CM_CLKSEL1_CORE, [OFFS] =  5, [LEN] =  2,},
+	[CLKSEL_DSS1]	= {[REG] = CM_CLKSEL1_CORE, [OFFS] =  8, [LEN] =  5,},
+	[CLKSEL_DSS2]	= {[REG] = CM_CLKSEL1_CORE, [OFFS] = 13, [LEN] =  1,},
+	[CLKSEL_VLYNQ]	= {[REG] = CM_CLKSEL1_CORE, [OFFS] = 15, [LEN] =  5,},
+	[CLKSEL_SSI]	= {[REG] = CM_CLKSEL1_CORE, [OFFS] = 20, [LEN] =  5,},
+	[CLKSEL_USB]	= {[REG] = CM_CLKSEL1_CORE, [OFFS] = 25, [LEN] =  3,},
+	[_48M_SOURCE]	= {[REG] = CM_CLKSEL1_PLL,  [OFFS] =  3, [LEN] =  1,},
+	[_54M_SOURCE]	= {[REG] = CM_CLKSEL1_PLL,  [OFFS] =  5, [LEN] =  1,},
+	[DPLL_DIV]	= {[REG] = CM_CLKSEL1_PLL,  [OFFS] =  8, [LEN] =  4,},
+	[DPLL_MULT]	= {[REG] = CM_CLKSEL1_PLL,  [OFFS] = 12, [LEN] = 10,},
+	[APLLS_CLKIN]	= {[REG] = CM_CLKSEL1_PLL,  [OFFS] = 23, [LEN] =  3,},
+	[CORE_CLK_SRC]	= {[REG] = CM_CLKSEL2_PLL,  [OFFS] =  0, [LEN] =  2,},
+};
+
+static const unsigned int (*op_list)[NUM_OP_PARMS];
+static unsigned int op_num;
+static unsigned cur_op;
+static u32 (*packed_op_list)[NUM_PACKED_OP_PARMS];
+static u32 *trends;
+static struct cpufreq_frequency_table *freq_tables[NUM_TABLES];
+
+static u32 (*op_packer[NUM_PACKED_OP_PARMS])(const unsigned int op);
+
+void omap2_clk_recalc_tree(void);
+
+void omap24xx_scale_freq(u32 dpll_ctl, u32 sdram_refresh);
+
+extern u32 omap24xx_scale_freq_sz;
+
+static void (*omap2_scale_freq)(u32 dpll_ctl, u32 sdram_refresh);
+
+static DEFINE_MUTEX(dvfs_mutex);
+static DEFINE_SPINLOCK(dvfs_lock);
+
+static const u32 prcm_base = IO_ADDRESS(PRCM_BASE);
+
+
+static inline void prcm_write_reg(int idx, u32 val)
+{
+	__raw_writel(val, prcm_base + idx);
+}
+
+static inline u32 prcm_read_reg(int idx)
+{
+	return __raw_readl(prcm_base + idx);
+}
+
+static inline unsigned int get_op_parm(unsigned int op, int parm)
+{
+	return op_list[op][parm];
+}
+
+static inline u32 bitfield(u32 val, int id)
+{
+	u32 offs, mask;
+
+	offs = bitfields[id][OFFS];
+	mask = (1 << bitfields[id][LEN]) - 1;
+
+	return (val& mask) << offs;
+}
+
+static inline u32 get_packed_op_bitfield(unsigned int packed_op, int id)
+{
+	u32 val, offs, mask;
+
+	val  = packed_op_list[packed_op][bitfields[id][REG]];
+	offs = bitfields[id][OFFS];
+	mask = (1 << bitfields[id][LEN]) - 1;
+
+	return (val >> offs) & mask;
+}
+
+static inline u32 get_packed_op_parm(unsigned int packed_op, int id)
+{
+	return packed_op_list[packed_op][id];
+}
+
+static inline u32 get_packed_op_parm_addr(int id)
+{
+	return mmapped_parms_addr[id];
+}
+
+static inline u32 get_trend(unsigned int src, unsigned int dst)
+{
+	return trends[src * op_num + dst];
+}
+
+static inline void set_trend(u32 val, unsigned int src, unsigned int dst)
+{
+	 trends[src * op_num + dst] = val;
+}
+
+static u32 omap242x_pack_cm_clksel1_pll(unsigned int op)
+{
+	u32 ret = 0;
+	u32 m = 0, n = 0, delta, apll;
+	int tmp, i;
+
+	tmp = get_op_parm(op, _48M_SRC_CLK_KHZ) == 96000 ? 0 : 1;
+	ret |= bitfield(tmp, _48M_SOURCE);
+
+	tmp = get_op_parm(op, _54M_SRC_CLK_KHZ) == 54000 ? 0 : 1;
+	ret |= bitfield(tmp, _54M_SOURCE);
+
+	apll = 19200;				/* FIXME: add autodetection */
+	ret |= bitfield(0, APLLS_CLKIN);	/* FIXME: add autodetection */
+
+	/* Find the best pair (multiplier, divider) that gives a freq smaller
+	 * or equal than the one requested */
+	delta = apll;
+	for (i = 1; i < MAX_DPLL_DIV; i++) {
+		u32 tmp_m, tmp_delta;
+
+		tmp_m = get_op_parm(op, DPLL_CLK_KHZ) * i / apll;
+		if (tmp_m <= MAX_DPLL_MULT) {
+			tmp_delta = get_op_parm(op, DPLL_CLK_KHZ) * i % apll;
+			if (tmp_delta < delta) {
+				n = i - 1;
+				delta = tmp_delta;
+				m = tmp_m;
+			}
+		}
+	}
+	ret |= bitfield(m, DPLL_MULT);
+	ret |= bitfield(n, DPLL_DIV);
+	return ret;
+}
+
+static u32 omap242x_pack_cm_clksel2_pll(const unsigned int op)
+{
+	u32 clk_src;
+
+	if (get_op_parm(op, CORE_CLK_KHZ) == 32000)
+		clk_src = 0;
+	else
+		clk_src =  get_op_parm(op, CORE_CLK_KHZ) /
+			   get_op_parm(op, DPLL_CLK_KHZ);
+
+	return bitfield(clk_src, CORE_CLK_SRC);
+}
+
+static u32 omap242x_pack_cm_clksel_mpu(const unsigned int op)
+{
+	u32 div;
+
+	div =  get_op_parm(op, CORE_CLK_KHZ) /
+	       get_op_parm(op, MPU_CLK_KHZ);
+	return bitfield(div, CLKSEL_MPU);
+}
+
+static u32 omap242x_pack_cm_clksel_dsp(const unsigned int op)
+{
+	u32 ret = 0, val;
+
+	val =  get_op_parm(op, CORE_CLK_KHZ) /
+	       get_op_parm(op, DSP_CLK_KHZ);
+	ret |= bitfield(val, CLKSEL_DSP);
+
+	val =  get_op_parm(op, DSP_CLK_KHZ) /
+	       get_op_parm(op, DSP_IF_CLK_KHZ);
+	ret |= bitfield(val, CLKSEL_DSP_IF);
+
+	ret |= bitfield(get_op_parm(op, DSP_SYNC), SYNC_DSP);
+
+	val =  get_op_parm(op, CORE_CLK_KHZ) /
+	       get_op_parm(op, IVA_CLK_KHZ);
+	ret |= bitfield(val, CLKSEL_IVA);
+
+	ret |= bitfield(get_op_parm(op, IVA_SYNC), SYNC_IVA);
+
+	return ret;
+}
+
+static u32 omap242x_pack_cm_clksel_gfx(const unsigned int op)
+{
+	u32 div;
+
+	div =  get_op_parm(op, L3_CLK_KHZ) / get_op_parm(op, GFX_CLK_KHZ);
+	return bitfield(div, CLKSEL_GFX);
+}
+
+static u32 omap242x_pack_cm_clksel1_core(const unsigned int op)
+{
+	u32 ret = 0, val;
+
+	val =  get_op_parm(op, CORE_CLK_KHZ) /
+	       get_op_parm(op, L3_CLK_KHZ);
+	ret |= bitfield(val, CLKSEL_L3);
+
+	val =  get_op_parm(op, L3_CLK_KHZ) /
+	       get_op_parm(op, L4_CLK_KHZ);
+	ret |= bitfield(val, CLKSEL_L4);
+
+	val =  get_op_parm(op, CORE_CLK_KHZ) /
+	       get_op_parm(op, DSS1_CLK_KHZ);
+	ret |= bitfield(val, CLKSEL_DSS1);
+
+	val =  get_op_parm(op, CORE_CLK_KHZ) /
+	       get_op_parm(op, VLYNQ_CLK_KHZ);
+	ret |= bitfield(val, CLKSEL_VLYNQ);
+
+	val =  get_op_parm(op, DSS1_CLK_KHZ) == 48000 ? 1 : 0;
+	ret |= bitfield(val, CLKSEL_DSS2);
+
+	val =  get_op_parm(op, CORE_CLK_KHZ) /
+	       get_op_parm(op, SSI_CLK_KHZ);
+	ret |= bitfield(val, CLKSEL_SSI);
+
+	val =  get_op_parm(op, L3_CLK_KHZ) /
+	       get_op_parm(op, USB_CLK_KHZ);
+	ret |= bitfield(val, CLKSEL_USB);
+
+	return ret;
+}
+
+static u32 omap242x_pack_vcore_roof(const unsigned int op)
+{
+	return get_op_parm(op, VCORE_ROOF_MV);
+}
+
+static int pack_op_list(void)
+{
+	unsigned int i, j;
+
+	packed_op_list = kmalloc(sizeof(u32) * NUM_PACKED_OP_PARMS * op_num,
+				 GFP_KERNEL);
+	if (!packed_op_list)
+		return -ENOMEM;
+
+	for (i = 0; i < op_num; i++)
+		for (j = 0; j < NUM_PACKED_OP_PARMS; j++)
+			if (op_packer[j])
+				packed_op_list[i][j] = op_packer[j](i);
+	return 0;
+}
+
+static u32 dvfs_calc_trend(unsigned int src, unsigned int dst)
+{
+	u32 ret;
+	u32 src_dblr, dst_dblr;
+	u32 src_div, dst_div;
+	u32 vcore_d, vcore_s;
+	unsigned int i, found_divider_growing = 0;
+
+	/* Use the low bits to hold the PLL settings */
+	ret = get_packed_op_parm(dst, CM_CLKSEL1_PLL)
+		>> CM_CLKSEL1_PLL_SHIFT;
+
+	if (op_list[src][DPLL_CLK_KHZ] > op_list[dst][DPLL_CLK_KHZ])
+		ret |= DPLL_SCALES_DOWN;
+	else if (op_list[src][DPLL_CLK_KHZ] < op_list[dst][DPLL_CLK_KHZ])
+		ret |= DPLL_SCALES_UP;
+
+	src_dblr = get_packed_op_bitfield(src, CORE_CLK_SRC);
+	dst_dblr = get_packed_op_bitfield(dst, CORE_CLK_SRC);
+	if (src_dblr > dst_dblr)
+		ret |= DOUBLER_SCALES_DOWN;
+	else if (src_dblr < dst_dblr)
+		ret |= DOUBLER_SCALES_UP;
+
+	vcore_s = get_packed_op_parm(src, VCORE_ROOF);
+	vcore_d = get_packed_op_parm(dst, VCORE_ROOF);
+	if (vcore_d > vcore_s)
+		ret |= VOLTAGE_SCALE_UP;
+	else if (vcore_d < vcore_s)
+		ret |= VOLTAGE_SCALE_DOWN;
+
+	/* Check the trend of every divider; even a single one scaling up is
+	 * enough to set the trend, otherwise check for decreasing cases */
+	for (i = 0; i < NUM_DIVIDERS; i++) {
+		src_div = get_packed_op_bitfield(src, i);
+		dst_div = get_packed_op_bitfield(dst, i);
+		if (src_div > dst_div)
+			return ret | DOMAINS_SCALE_UP;
+		else if (src_div < dst_div)
+			found_divider_growing = 1;
+	}
+
+	/* No divider is shrinking */
+	if (found_divider_growing)
+		return ret | DOMAINS_SCALE_DOWN;
+
+	return ret;
+
+}
+
+static int create_trends_table(void)
+{
+	unsigned int src, dst;
+
+	trends = kmalloc(sizeof(u32) * op_num * op_num, GFP_KERNEL);
+	if (!trends)
+		return -ENOMEM;
+
+	for (src = 0; src < op_num; src++)
+		for (dst = 0; dst < op_num; dst++)
+			set_trend(dvfs_calc_trend(src, dst), src, dst);
+	return 0;
+}
+
+static int create_freq_tables(void)
+{
+	unsigned int i, j, k;
+
+	for (i = 0; i < NUM_TABLES; i++) {
+		freq_tables[i] =
+			kmalloc(sizeof(struct cpufreq_frequency_table) *
+				(op_num + 1), GFP_KERNEL);
+
+		if (!freq_tables[i]) {
+			for (; i > 0; i--)
+				kfree(freq_tables[i - 1]);
+			return -ENOMEM;
+		}
+
+		for (j = 0; j < op_num; j++) {
+			freq_tables[i][j].frequency = op_list[j][i];
+			freq_tables[i][j].index = j;
+		}
+
+		for (j = op_num - 1; j; j--) /* inplace bubblesort */
+			for (k = 0; k < j; k++)
+				if (freq_tables[i][k].frequency <
+				    freq_tables[i][k + 1].frequency) {
+					struct cpufreq_frequency_table tmp;
+
+					tmp = freq_tables[i][k];
+					freq_tables[i][k] = freq_tables[i][k + 1];
+					freq_tables[i][k + 1] = tmp;
+				}
+		freq_tables[i][op_num].frequency = CPUFREQ_TABLE_END;
+	}
+	return 0;
+}
+
+int omap242x_load_op_list(const unsigned int list[][NUM_OP_PARMS], unsigned int num,
+			  unsigned int active)
+{
+	if (!(list && num && (active < num)))
+		return -EINVAL;
+
+	op_list = list;
+	op_num = num;
+	cur_op = active;
+
+	if (pack_op_list())
+		return -EINVAL;
+
+	if (create_trends_table())
+		goto trend_error;
+
+	if (create_freq_tables())
+		goto freq_tables_error;
+
+	return 0;
+
+freq_tables_error:
+	kfree(trends);
+trend_error:
+	kfree(packed_op_list);
+	return -EINVAL;
+}
+EXPORT_SYMBOL(omap242x_load_op_list);
+
+unsigned int omap242x_dvfs_get_op(void)
+{
+	return cur_op;
+}
+EXPORT_SYMBOL(omap242x_dvfs_get_op);
+
+int omap242x_dvfs_set_op(unsigned int dst)
+{
+	unsigned int i, src;
+	unsigned int rfr, l3_rate;
+	u32 trend, vcore, voltctrl = 0;
+	int ret;
+	int vtg_is_scaled;
+
+	if (unlikely(op_num <= dst))
+		return -EINVAL;
+
+	mutex_lock(&dvfs_mutex);
+
+	src = cur_op;
+	if (unlikely(src == dst)) {
+		mutex_unlock(&dvfs_mutex);
+		return 0;
+	}
+
+	trend = get_trend(src, dst);
+	vtg_is_scaled =
+		(trend & (VOLTAGE_SCALE_DOWN | VOLTAGE_SCALE_UP)) ? 1 : 0;
+	vcore = get_packed_op_parm(dst, VCORE_ROOF);
+
+	l3_rate = get_op_parm(dst, L3_CLK_KHZ);
+	rfr = 1 | ((64 * l3_rate / 8192 - 50) << 8);
+	if (l3_rate < 66000)
+		rfr |= L3_LESS_THAN_66M;
+	else if (l3_rate > 133000)
+		rfr |= L3_HIGHER_THAN_133M;
+
+	for (i = 0; i < NUM_MMAPPED_PARMS; i++)
+		omap_writel(get_packed_op_parm(dst, i),
+			    get_packed_op_parm_addr(i));
+
+	mmc_pause();
+	omapfb_pause_set(OMAPFB_DVFS_PAUSE);
+	omap2_spi_pause();
+
+	ret = dsp_pause();
+	if (ret) {
+		printk(KERN_ERR "DSP Pausing failed, skipping OP change!\n");
+		goto restore_dsp_state;
+	}
+
+	if (vtg_is_scaled) {
+		voltctrl = prcm_read_reg(PRCM_VOLTCTRL) & ~VOLT_LEVEL(3);
+		/* FORCE ROOF */
+		prcm_write_reg(PRCM_VOLTCTRL, voltctrl | FORCE_EXTVOLT);
+		menelaus_set_vcore_hw(vcore, vcore);
+	}
+
+	spin_lock_irq(&dvfs_lock);
+
+	omap2_dma_pause(); /* sic -> drain */
+
+	omap2_scale_freq(trend, rfr);
+	omap2_clk_recalc_tree();
+	omap2_onenand_rephase();
+
+	cur_op = dst;
+	spin_unlock_irq(&dvfs_lock);
+
+	if (vtg_is_scaled) {
+		menelaus_set_vcore_hw(vcore, CORE_VTG_FLOOR);
+		prcm_write_reg(PRCM_VOLTCTRL, voltctrl);
+	}
+
+restore_dsp_state:
+	/*
+	 * If the dsp problem is recovable, dsp_dld can try to restart
+	 * the dsp system automatically with "poll error", otherwise,
+	 * no way to recover except rebooting the target.
+	 */
+	ret = dsp_continue();
+	if (!ret) {
+		ret = (cur_op == dst) ? 0 : -EAGAIN;
+	} else {
+		printk(KERN_ERR "DSP Continuing failed!\n");
+		ret = -EIO;
+	}
+
+	omap2_spi_continue();
+	omapfb_pause_set(OMAPFB_DVFS_CONTINUE);
+	mmc_continue();
+
+	mutex_unlock(&dvfs_mutex);
+
+	return ret;
+}
+EXPORT_SYMBOL(omap242x_dvfs_set_op);
+
+static ssize_t op_list_show(struct subsystem * subsys, char *buf)
+{
+	unsigned int i, j;
+
+	j = 0;
+	for (i = 0; i < op_num; i++)
+		j += sprintf(buf + j, "%u ", i);
+	sprintf(buf + j - 1, "\n");
+
+	return j;
+}
+
+static struct subsys_attribute op_list_attr = {
+	.attr   = {
+		.name = __stringify(op_list),
+		.mode = 0444,
+	},
+	.show   = op_list_show,
+};
+
+static ssize_t op_active_show(struct subsystem * subsys, char *buf)
+{
+	return sprintf(buf, "%u\n", cur_op);
+}
+
+static ssize_t op_active_store(struct subsystem * subsys,
+			      const char * buf, size_t n)
+{
+	unsigned value;
+
+	if (sscanf(buf, "%u", &value) != 1 || (value >= op_num)) {
+		printk(KERN_ERR "OP: Invalid index\n");
+		return -EINVAL;
+	}
+
+	omap242x_dvfs_set_op(value);
+	return n;
+}
+
+static struct subsys_attribute op_active_attr = {
+	.attr   = {
+		.name = __stringify(op_active),
+		.mode = 0644,
+	},
+	.show   = op_active_show,
+	.store  = op_active_store,
+};
+
+extern struct subsystem power_subsys;
+
+int __init dvfs_init(void)
+{
+	int ret;
+
+	printk(KERN_INFO "DVFS for OMAP2 initializing\n");
+
+	op_packer[CM_CLKSEL1_PLL]  = omap242x_pack_cm_clksel1_pll;
+	op_packer[CM_CLKSEL2_PLL]  = omap242x_pack_cm_clksel2_pll;
+	op_packer[CM_CLKSEL_MPU]   = omap242x_pack_cm_clksel_mpu;
+	op_packer[CM_CLKSEL_DSP]   = omap242x_pack_cm_clksel_dsp;
+	op_packer[CM_CLKSEL_GFX]   = omap242x_pack_cm_clksel_gfx;
+	op_packer[CM_CLKSEL1_CORE] = omap242x_pack_cm_clksel1_core;
+	op_packer[VCORE_ROOF]	   = omap242x_pack_vcore_roof;
+
+	ret = subsys_create_file(&power_subsys, &op_list_attr);
+	if (ret)
+		printk(KERN_ERR "subsys_create_file failed: %d\n", ret);
+
+	ret = subsys_create_file(&power_subsys, &op_active_attr);
+	if (ret)
+		printk(KERN_ERR "subsys_create_file failed: %d\n", ret);
+
+#if 1 // #ifdef CONFIG_CPU_ICACHE_DISABLE
+	omap2_scale_freq = omap_sram_push(omap24xx_scale_freq,
+					  omap24xx_scale_freq_sz);
+#else
+	omap2_scale_freq = omap24xx_scale_freq;
+#endif
+	return ret;
+}
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/dvfs.h maemo_src/arch/arm/mach-omap2/dvfs.h
--- linux-omap-2.6/arch/arm/mach-omap2/dvfs.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/mach-omap2/dvfs.h	2007-10-02 03:09:30.000000000 -0400
@@ -0,0 +1,79 @@
+/*
+ * arch/arm/mach-omap2/dvfs.h
+ *
+ * Copyright (C) 2007 Nokia Corporation.
+ *
+ * Contact: Igor Stoppa <igor.stoppa@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __DVFS_H
+#define __DVFS_H
+
+#define SYNC_DISABLED	0
+#define SYNC_ENABLED	1
+
+#define SYS_CLK		0
+
+enum omap242x_op_parms {
+	MPU_CLK_KHZ = 0,
+	DSP_CLK_KHZ,
+	GFX_CLK_KHZ,
+	IVA_CLK_KHZ,
+	L3_CLK_KHZ,
+	L4_CLK_KHZ,
+	_54M_SRC_CLK_KHZ,
+	_48M_SRC_CLK_KHZ,
+	DPLL_CLK_KHZ,
+	CORE_CLK_KHZ,
+	DSP_IF_CLK_KHZ,
+	DSP_SYNC,
+	IVA_SYNC,
+	DSS1_CLK_KHZ,
+	DSS2_CLK_KHZ,
+	VLYNQ_CLK_KHZ,
+	SSI_CLK_KHZ,
+	USB_CLK_KHZ,
+	VCORE_ROOF_MV,
+	NUM_OP_PARMS,
+};
+
+/* Note: the members of omap242x_op_parms that are used in freq_tables
+   _must_ be grouped at the beginning of the enum.*/
+enum freq_tables {
+	MPU_TABLE = MPU_CLK_KHZ,
+	DSP_TABLE = DSP_CLK_KHZ,
+	GFX_TABLE = GFX_CLK_KHZ,
+	IVA_TABLE = IVA_CLK_KHZ,
+	L3_TABLE = L3_CLK_KHZ,
+	L4_TABLE = L4_CLK_KHZ,
+	NUM_TABLES,
+};
+
+struct omap242x_freq_tables *omap242x_get_freq_tableset(void);
+int omap242x_load_op_list(const unsigned int list[][NUM_OP_PARMS],
+			  unsigned int num, unsigned int active);
+int omap242x_dvfs_set_op(const unsigned int target);
+unsigned int omap242x_dvfs_get_op(void);
+
+#ifdef CONFIG_MACH_OMAP2420_DVFS
+int dvfs_init(void) __init;
+#else
+static inline int __init dvfs_init(void) { return 0; }
+#endif
+
+#endif
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/dvfs_notif.c maemo_src/arch/arm/mach-omap2/dvfs_notif.c
--- linux-omap-2.6/arch/arm/mach-omap2/dvfs_notif.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/mach-omap2/dvfs_notif.c	2007-10-02 03:09:30.000000000 -0400
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2006, Nomad Global Solutions, Inc.
+ * Author: Eugeny S. Mints <eugeny.mints@gmail.com>
+ *
+ * Copyright (C) 2007 Nokia Corporation.
+ * Rewritten by: Igor Stoppa <igor.stoppa@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/kmod.h>
+#include <linux/module.h>
+#include <linux/stat.h>
+#include <linux/string.h>
+#include <linux/device.h>
+#include <linux/sched.h>
+#include <linux/param.h>
+#include <linux/freezer.h>
+#include <asm/arch/dvfs_notif.h>
+
+/* FIXME: Eventually it should it be 0 */
+#define MIN_NOTIFICATIONS_TIMEOUT 100
+
+static LIST_HEAD(drivers_list);
+static BLOCKING_NOTIFIER_HEAD(notifier_list);
+static DECLARE_WAIT_QUEUE_HEAD(queue);
+static DEFINE_MUTEX(dvfs_notif_mutex);
+static atomic_t missing_cb;
+static atomic_t failing_drivers;
+static struct completion nf_completion;
+static int dvfs_event;
+static int clients_count;
+static int target_state;
+static unsigned long timeout;
+
+static inline int set_starting_state(int event) { return event - 1;}
+
+static void update_target_state(int event)
+{
+	struct dvfs_notif *curs;
+
+	target_state = event;
+	list_for_each_entry(curs, &drivers_list, list) {
+		curs->err = 0;
+		curs->state = set_starting_state(event);
+	}
+}
+
+static void update_timeout(void)
+{
+	struct dvfs_notif *curs;
+	unsigned long tmp;
+
+	timeout = msecs_to_jiffies(MIN_NOTIFICATIONS_TIMEOUT);
+	list_for_each_entry(curs, &drivers_list, list) {
+		tmp = msecs_to_jiffies(curs->timeout);
+		timeout = timeout >= tmp ? timeout : tmp;
+	}
+}
+
+static void list_erratic_drivers(void)
+{
+	struct dvfs_notif *curs;
+
+	list_for_each_entry(curs, &drivers_list, list) {
+		if (curs->state != target_state)
+			printk(KERN_ERR "DVFS: driver %s - %s\n",
+			       curs->err ? "error" : "timeout", curs->name);
+	}
+}
+
+int dvfs_run_notifications(enum dvfs_notifications event)
+{
+	int ret = 0;
+
+	if (event == DVFS_PRE_NOTIFICATION)
+		mutex_lock(&dvfs_notif_mutex);
+
+	dvfs_event = event;
+
+	init_completion(&nf_completion);
+	update_target_state(event);
+	atomic_set(&missing_cb, clients_count);
+	atomic_set(&failing_drivers, 0);
+
+	preempt_disable();
+	wake_up_all(&queue);
+	blocking_notifier_call_chain(&notifier_list, dvfs_event, NULL);
+	preempt_enable();
+
+	wait_for_completion_timeout(&nf_completion, timeout);
+
+	if (atomic_read(&missing_cb) || atomic_read(&failing_drivers)) {
+		if (atomic_read(&missing_cb))
+			printk(KERN_ERR "DVFS: Timeout!\n");
+		if (atomic_read(&failing_drivers))
+			printk(KERN_ERR
+			       "DVFS: Driver(s) failing notification!\n");
+		list_erratic_drivers();
+		ret = -EIO;
+	}
+
+	if (event == DVFS_POST_NOTIFICATION)
+		mutex_unlock(&dvfs_notif_mutex);
+
+	return ret;
+
+}
+EXPORT_SYMBOL_GPL(dvfs_run_notifications);
+
+void dvfs_client_notification_cb(struct dvfs_notif *n)
+{
+	atomic_dec(&missing_cb);
+
+	if (n->err)
+		atomic_inc(&failing_drivers);
+	else
+		n->state = target_state;
+
+	if (unlikely(atomic_read(&missing_cb) == 0))
+		complete(&nf_completion);
+}
+EXPORT_SYMBOL_GPL(dvfs_client_notification_cb);
+
+static int notifier_thread(void *arg)
+{
+	struct dvfs_notif *n = (struct dvfs_notif *)arg;
+	DEFINE_WAIT(__wait);
+
+	for (;;) {
+		prepare_to_wait(&queue, &__wait, TASK_INTERRUPTIBLE);
+		schedule();
+		if (signal_pending(current)) {
+			if (try_to_freeze())
+				continue;
+			break;
+		}
+		n->nb.notifier_call(&n->nb, dvfs_event, n);
+	}
+	finish_wait(&queue, &__wait);
+
+	return 0;
+}
+
+int dvfs_notif_set(struct dvfs_notif *target, const char *name,
+		   int (*callback)(struct notifier_block *,
+		   unsigned long dvfs_notifications, void *),
+		   enum dvfs_threaded threaded, unsigned long timeout)
+{
+	if (!target)
+		return -EINVAL;
+
+	target->name = name;
+	target->nb.notifier_call = callback;
+	target->timeout = timeout;
+	target->threaded = threaded;
+
+	return 0;
+}
+
+int dvfs_register_notifier(struct dvfs_notif *n)
+{
+	if (unlikely((!n) || (!n->name) || (!n->nb.notifier_call) ||
+		     ((n->threaded == DVFS_THREADED_NOTIF) && !n->timeout) ||
+		     ((n->threaded == DVFS_CHAINED_NOTIF) && n->timeout)))
+		return -EINVAL;
+
+	mutex_lock(&dvfs_notif_mutex);
+
+	if (n->threaded == DVFS_THREADED_NOTIF) {
+		n->task = kthread_run(notifier_thread, n, n->name);
+		if (IS_ERR(n->task)) {
+			mutex_unlock(&dvfs_notif_mutex);
+			return -ENOMEM;
+		}
+		n->err = 0;
+	} else {
+		blocking_notifier_chain_register(&notifier_list, &n->nb);
+	}
+
+	list_add(&n->list, &drivers_list);
+	clients_count++;
+	update_timeout();
+
+	pr_info("DVFS - Registered %s with timeout %u ms - "
+		"notification global timeout: %d ms\n",
+		n->name, n->timeout, jiffies_to_msecs(timeout));
+	mutex_unlock(&dvfs_notif_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dvfs_register_notifier);
+
+
+int dvfs_unregister_notifier(struct dvfs_notif *n)
+{
+	if (unlikely(!n))
+		return -EINVAL;
+
+	mutex_lock(&dvfs_notif_mutex);
+
+	if (n->task)
+		kthread_stop(n->task);
+	else
+		blocking_notifier_chain_unregister(&notifier_list, &n->nb);
+
+	list_del(&n->list);
+	clients_count--;
+	update_timeout();
+
+	pr_info("DVFS - Unregistered %s with timeout %u ms - "
+		"notification global timeout: %d ms\n",
+		n->name, n->timeout, jiffies_to_msecs(timeout));
+	mutex_unlock(&dvfs_notif_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dvfs_unregister_notifier);
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/dvs.c maemo_src/arch/arm/mach-omap2/dvs.c
--- linux-omap-2.6/arch/arm/mach-omap2/dvs.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/mach-omap2/dvs.c	2011-02-06 20:12:09.763333273 -0500
@@ -0,0 +1,109 @@
+/*
+ * arch/arm/mach-omap2/dvs.c
+ *
+ * OMAP2 Dynamic Voltage Scaling
+ *
+ * Copyright (C) 2006 Nokia Corporation
+ * Amit Kucheria <amit.kucheria@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+
+#include <asm/io.h>
+
+#include <asm/arch/menelaus.h>
+
+#define PRCM_BASE		0x48008000
+#define PRCM_VOLTCTRL		0x050
+#define		AUTO_EXTVOLT	(1 << 15)
+#define		FORCE_EXTVOLT	(1 << 14)
+#define		SETOFF_LEVEL(x)	(((x) & 0x3) << 12)
+#define		MEMRETCTRL	(1 << 8)
+#define		SETRET_LEVEL(x)	(((x) & 0x3) << 6)
+#define		VOLT_LEVEL(x)	(((x) & 0x3) << 0)
+#define PRCM_VOLTSETUP		0x090
+
+static struct clk *l3_ck;
+
+static u32 prcm_base = IO_ADDRESS(PRCM_BASE);
+
+static inline void prcm_write_reg(int idx, u32 val)
+{
+	__raw_writel(val, prcm_base + idx);
+}
+
+static inline u32 prcm_read_reg(int idx)
+{
+	return __raw_readl(prcm_base + idx);
+}
+
+static void omap2_toggle_vmode(void)
+{
+	u32 saved, l;
+	unsigned long delay; /* microseconds */
+
+	/* There is a bug in OMAP that makes the state of VMODE line
+	 * inconsistent when Voltage scaling mode is toggled between
+	 * AUTO and FORCE mode. We work around it by first FORCE scaling
+	 * to FLOOR and then scaling to ROOF.
+	 */
+	saved = prcm_read_reg(PRCM_VOLTCTRL);
+
+	/* FORCE voltage to FLOOR */
+	l = (saved & ~AUTO_EXTVOLT) | FORCE_EXTVOLT | VOLT_LEVEL(1);
+	prcm_write_reg(PRCM_VOLTCTRL, l);
+
+	/* Wait for ~1000 L3 clock cycles + VOLTSETUP time */
+#define VCORE_WAIT_L3_CYCLES 1000
+	delay = (VCORE_WAIT_L3_CYCLES / (clk_get_rate(l3_ck) / 1000000)) +
+		(prcm_read_reg(PRCM_VOLTSETUP) * (1000000 / 32000));
+	udelay(delay+1);
+
+	/* FORCE voltage to ROOF */
+	l = (saved & ~AUTO_EXTVOLT) | FORCE_EXTVOLT | VOLT_LEVEL(0);
+	prcm_write_reg(PRCM_VOLTCTRL, l);
+
+        /* Back to AUTO mode */
+	prcm_write_reg(PRCM_VOLTCTRL, saved);
+
+	/* FIXME: Try to use Voltage transition interrupt,
+	 * MPU and Core need to be ON
+	 */
+
+}
+
+void omap2_scale_voltage(unsigned int roof_mV, unsigned int floor_mV)
+{
+	menelaus_set_vcore_hw(roof_mV, roof_mV);
+	omap2_toggle_vmode();
+	menelaus_set_vcore_hw(roof_mV, floor_mV);
+}
+EXPORT_SYMBOL(omap2_scale_voltage);
+
+int __init omap2_dvs_init(void)
+{
+	printk(KERN_INFO "DVS for OMAP2 initializing\n");
+
+	l3_ck = clk_get(NULL, "core_l3_ck");
+
+	return 0;
+}
+
+late_initcall(omap2_dvs_init);
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/gpmc.c maemo_src/arch/arm/mach-omap2/gpmc.c
--- linux-omap-2.6/arch/arm/mach-omap2/gpmc.c	2011-02-06 20:17:25.193333271 -0500
+++ maemo_src/arch/arm/mach-omap2/gpmc.c	2011-02-06 20:12:09.753333272 -0500
@@ -110,6 +110,11 @@
 	return (time_ns * 1000 + tick_ps - 1) / tick_ps;
 }
 
+unsigned int gpmc_ticks_to_ns(unsigned int ticks)
+{
+	return ticks * gpmc_get_fclk_period() / 1000;
+}
+
 unsigned int gpmc_round_ns_to_ticks(unsigned int time_ns)
 {
 	unsigned long ticks = gpmc_ns_to_ticks(time_ns);
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/hs.c maemo_src/arch/arm/mach-omap2/hs.c
--- linux-omap-2.6/arch/arm/mach-omap2/hs.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/mach-omap2/hs.c	2011-02-06 20:12:09.786666607 -0500
@@ -0,0 +1,662 @@
+/*
+ * linux/arch/arm/mach-omap2/hs.c
+ *
+ * Copyright (C) 2007 Nokia Corporation
+ * Author: Sami Tolvanen
+ * Maintainer: Timo O. Karjalainen <timo.o.karjalainen@nokia.com>
+ *
+ * OMAP2420 HS secure side interface module
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/firmware.h>
+#include <linux/mutex.h>
+#include <linux/random.h>
+#include <asm/cacheflush.h>
+#include <asm/io.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/sec.h>
+#include <asm/arch/pa.h>
+
+MODULE_LICENSE("GPL v2");
+
+#define HS_NAME					"omap2_hs"
+
+#define OMAP2420_RANDOM_SIZE			512
+
+#define OMAP2420_KEYS_PHYS			0x40204080
+#define OMAP2420_ROM_START_PHYS			0x00000000
+#define OMAP2420_ROM_SIZE			(64 * 1024)
+#define OMAP2420_SDRAM_START_PHYS		0x80000000
+#define OMAP2420_SDRAM_END_PHYS			0x9FFFFFFF
+#define OMAP2420_TESTRAM_START_PHYS		0x4029FA00
+#define OMAP2420_TESTRAM_SIZE			512
+
+#define OMAP2420_REV_10				0x0
+#define OMAP2420_REV_20				0x1
+#define OMAP2420_REV_205			0x2
+#define OMAP2420_REV_21				0x3
+#define OMAP2420_REV_211			0x4
+#define OMAP2420_REV_22				0x5
+
+#define OMAP2420_REV_10_ROM_ENTRY_OFFSET	(0x00002108 + 1)
+#define OMAP2420_REV_20_ROM_ENTRY_OFFSET	(0x00002228 + 1)
+#define OMAP2420_REV_21_ROM_ENTRY_OFFSET	(0x00002258 + 1)
+#define OMAP2420_REV_22_ROM_ENTRY_OFFSET	(0x00002268 + 1)
+
+#define OMAP2420_REV_21_SDRAM_VIRTUAL_OFFSET	0x20000000
+
+#define OMAP2420_ROM_MMU_ENABLE_MASK		0x0001
+#define OMAP2420_ROM_ICACHE_ENABLE_MASK		0x0002
+#define OMAP2420_ROM_DCACHE_ENABLE_MASK		0x0004
+#define OMAP2420_ROM_IRQ_ENABLE_MASK		0x0008
+#define OMAP2420_ROM_FIQ_ENABLE_MASK		0x0010
+#define OMAP2420_ROM_UL2_CACHE_ENABLE_MASK	0x0020
+
+#define OMAP2420_ROM_NORMAL_FLAGS_MASK \
+		(OMAP2420_ROM_MMU_ENABLE_MASK | \
+		 OMAP2420_ROM_ICACHE_ENABLE_MASK | \
+		 OMAP2420_ROM_DCACHE_ENABLE_MASK | \
+		 OMAP2420_ROM_IRQ_ENABLE_MASK    | \
+		 OMAP2420_ROM_FIQ_ENABLE_MASK)
+
+#define OMAP2420_FIRMWARE_PA			"omap2420_pa.bin"
+#define OMAP2420_FIRMWARE_PAFMT			"omap2420_pafmt.bin"
+#define OMAP2420_FIRMWARE_PAPUB			"omap2420_papub.bin"
+#define OMAP2420_FIRMWARE_WRAP			"omap2420_wrap.bin"
+
+#define OMAP2420_PA_OFFSET			0x00000018
+#define OMAP2420_PAPUB_OFFSET			0x00000083
+#define OMAP2420_WRAP_SETPHYS_OFFSET		(0x00000004 + 1)
+
+/* Space for magic pointer and flags */
+#define OMAP2420_ROM_HEAD_ARGS	2
+
+enum {
+	RPC_SETTINGS,
+	RPC_ALLOC,
+	RPC_DEALLOC,
+	RPC_SECS_WRITE,
+};
+
+struct omap2420_revision {
+	u8 cpu_rev;
+	const char *name;
+	u32 entry_offset;
+	int (*init_fixup)(struct device *dev);
+};
+
+#define OMAP2420_ROM_CREATOR_SIZE  12
+#define OMAP2420_ROM_APPL_ID_SIZE   3
+
+struct omap2420_rom_appl_id {
+	u8 creator[OMAP2420_ROM_CREATOR_SIZE];
+	u8 appl_id[OMAP2420_ROM_APPL_ID_SIZE];
+	u8 sub_appl_id;
+};
+
+#define OMAP2420_ROM_COMMON_CREATOR \
+	0xAB, 0x0F, 0xBD, 0x96, 0xAF, 0x2A, 0xC2, 0x71, 0xD2, 0x62, 0x64, 0xAF
+
+static const struct omap2420_rom_appl_id papub_id = {
+	{ OMAP2420_ROM_COMMON_CREATOR },
+	{ 0x00,0x00,0x1A },
+	0
+};
+
+static const struct omap2420_rom_appl_id secenv_init_id = {
+	{ OMAP2420_ROM_COMMON_CREATOR },
+	{ 0x00,0x00,0x13 },
+	0
+};
+
+static const struct omap2420_rom_appl_id random_get_id = {
+	{ OMAP2420_ROM_COMMON_CREATOR },
+	{ 0x00,0x00,0x0A },
+	0
+};
+
+static const struct omap2420_rom_appl_id pa_msg_id = {
+	{ OMAP2420_ROM_COMMON_CREATOR },
+	{ 0x00,0x00,0x12 },
+	0
+};
+
+typedef u32 omap2420_rom_entry(const struct omap2420_rom_appl_id *id,
+			       u32 *stack);
+
+struct hs_rom_entry {
+	omap2420_rom_entry *addr;
+	u32 flags;
+};
+
+struct hs_iomap {
+	void *addr;
+	struct resource *rgn;
+};
+
+struct hs_firmware {
+	void *data;
+	size_t size;
+};
+
+struct hs_status {
+	struct mutex lock;
+	struct omap2420_revision *cpu;
+	struct hs_firmware pa_bin;
+	struct hs_firmware pafmt_bin;
+	struct hs_firmware papub_bin;
+	struct hs_firmware wrapper_bin;
+	struct hs_iomap rom_map;
+	struct hs_iomap testram_map;
+	struct hs_rom_entry entry;
+	struct pa_format format;
+};
+
+static struct hs_status hs;
+static void *storage = NULL;
+static size_t storage_size = 0;
+
+static inline int omap2420_has_addrconv_bug(u8 rev)
+{
+	return (rev == OMAP2420_REV_21) || (rev == OMAP2420_REV_211);
+}
+
+static inline int omap2420_addr_in_sdram(const void *phys)
+{
+	return (phys >= (void *) OMAP2420_SDRAM_START_PHYS)
+		&& (phys <= (void *) OMAP2420_SDRAM_END_PHYS);
+}
+
+/*
+ * Functions for converting between virtual and physical memory addresses,
+ * with workaround fixes for OMAP2420 v2.1 ASIC due to SDRAM virtual address
+ * handling error in ROM code.
+ */
+static void *__omap_vtp(const void *virt)
+{
+	void *phys = (void *) __pa(virt);
+
+	if (omap2420_has_addrconv_bug(hs.cpu->cpu_rev)
+	    && omap2420_addr_in_sdram(phys))
+		phys += OMAP2420_REV_21_SDRAM_VIRTUAL_OFFSET;
+
+	return phys;
+}
+
+static void *__omap_ptv(const void *phys)
+{
+	const void *shifted = phys - OMAP2420_REV_21_SDRAM_VIRTUAL_OFFSET;
+
+	if (omap2420_has_addrconv_bug(hs.cpu->cpu_rev)
+	    && omap2420_addr_in_sdram(shifted))
+		phys = shifted;
+
+	return __va(phys);
+}
+
+static void init_stack_head(u32 *stack)
+{
+	stack[0] = (u32) &stack[1];
+	stack[1] = hs.entry.flags;
+}
+
+static u32 sec_entry(const struct omap2420_rom_appl_id *id, u32 *args)
+{
+	u32 rv;
+
+	init_stack_head(args);
+
+	mutex_lock(&hs.lock);
+
+	/*
+	 * Workaround fix for OMAP2420 v2.1 asic due to SDRAM virtual address
+ 	 * handling error in ROM code: service ID has to be copied to Internal
+ 	 * SRAM.
+ 	 */
+	if (hs.testram_map.addr)
+		memcpy_toio(hs.testram_map.addr, id, sizeof(*id));
+
+	/*
+	 * Wrapper handles address conversion for the service ID.
+	 */
+	if (!hs.wrapper_bin.data)
+		id = __omap_vtp(id);
+
+	rv = hs.entry.addr(id, args);
+
+	flush_cache_all();
+	mutex_unlock(&hs.lock);
+
+	if (rv != SEC_OK)
+		printk(KERN_WARNING HS_NAME ": Error %08x calling ROM\n", rv);
+
+	return rv;
+}
+
+static u32 papub_import(void)
+{
+	u32 args[OMAP2420_ROM_HEAD_ARGS + 1];
+	
+	args[OMAP2420_ROM_HEAD_ARGS] = (u32) __omap_vtp(hs.papub_bin.data);
+
+	return sec_entry(&papub_id, args);
+}
+
+static u32 rpc_alloc(u32 size)
+{
+	void *p;
+
+	if (!size)
+		return 0;
+
+	p = kzalloc(size, GFP_KERNEL);
+	if (!p)
+		return 0;
+
+	return (u32) __omap_vtp(p);
+}
+
+static void rpc_dealloc(u32 phys)
+{
+	kfree(__omap_ptv((void *) phys));
+}
+
+static u32 rpc_handler(u32 service, u32 a1, u32 a2, u32 a3)
+{
+	u32 rv = 0;
+
+	switch (service) {
+	case RPC_SETTINGS:
+		break;
+	case RPC_ALLOC:
+		rv = rpc_alloc(a1);
+		break;
+	case RPC_DEALLOC:
+		rpc_dealloc(a1);
+		break;
+	case RPC_SECS_WRITE:
+		sec_storage_write(storage, storage_size);
+		break;
+	}
+
+	return rv;
+}
+
+static u32 secenv_init(void *data, u32 len)
+{
+	u32 args[OMAP2420_ROM_HEAD_ARGS + 3];
+	u32 rv;
+
+	if (len > SEC_STORAGE_SIZE)
+		return 13; /* secure storage size fail */
+
+	memcpy(storage, data, min(storage_size, len));
+
+	if (hs.wrapper_bin.data) {
+		void *wrap_start = storage + SEC_STORAGE_SIZE;
+
+		memcpy(wrap_start, hs.wrapper_bin.data, hs.wrapper_bin.size);
+		hs.entry.addr = (omap2420_rom_entry *) (wrap_start + 1);
+	}
+
+	args[OMAP2420_ROM_HEAD_ARGS] = (u32) rpc_handler; /* Virtual */
+	args[OMAP2420_ROM_HEAD_ARGS + 1] = (u32) __omap_vtp(storage);
+	args[OMAP2420_ROM_HEAD_ARGS + 2] = SEC_STORAGE_SIZE;
+
+	rv = sec_entry(&secenv_init_id, args);
+
+	if (rv == SEC_OK)
+		rv = papub_import();
+
+	return rv;
+}
+
+static u32 random_get(void *buf, u32 len)
+{
+	u32 args[OMAP2420_ROM_HEAD_ARGS + 2];
+	
+	args[OMAP2420_ROM_HEAD_ARGS] = (u32) __omap_vtp(buf);
+	args[OMAP2420_ROM_HEAD_ARGS + 1] = len;
+
+	return sec_entry(&random_get_id, args);
+}
+
+static u32 pa_msg_send(struct pa_command *c, void *par, void *res)
+{
+	u32 args[OMAP2420_ROM_HEAD_ARGS + 5];
+	void *pa_addr;
+
+	pa_addr = pa_image_address(hs.pa_bin.data, c->cmd);
+	if (!pa_addr)
+		return SEC_ENOPA;
+
+	args[OMAP2420_ROM_HEAD_ARGS] = (u32) __omap_vtp(pa_addr);
+	args[OMAP2420_ROM_HEAD_ARGS + 1] = 0;
+	args[OMAP2420_ROM_HEAD_ARGS + 2] = (u32) __omap_vtp(par);
+	args[OMAP2420_ROM_HEAD_ARGS + 3] = (u32) __omap_vtp(res);
+	args[OMAP2420_ROM_HEAD_ARGS + 4] = c->cmd->sa;
+			
+	return sec_entry(&pa_msg_id, args);
+}
+
+static u32 pa_query(u32 cmd, u8 *input, u32 cinp, u32 *mininp, u32 *maxout)
+{
+	if (pa_command_query(cmd, input, cinp, mininp, maxout, &hs.format) < 0)
+		return SEC_ENOPA;
+
+	return SEC_OK;
+}
+
+static void pa_service(u32 cmd, u8 *in, u32 cinp, struct sec_pa_result *output,
+		       u32 coup)
+{
+	struct pa_command_data p;
+	u32 rv;
+
+	if (!output)
+		return;
+
+	p.format = &hs.format;
+	p.vtp    = __omap_vtp;
+	p.ptv    = __omap_ptv;
+	p.cinp   = cinp;
+	p.coup   = coup;
+	p.input  = in;
+	p.output = output->data;
+	p.keys   = (void *) OMAP2420_KEYS_PHYS;
+
+	if (hs.papub_bin.data)
+		p.papub = __omap_vtp(hs.papub_bin.data);
+
+	if (pa_command_prepare(cmd, &p) < 0) {
+		rv = SEC_FAIL;
+		goto out;
+	}
+
+	rv = pa_msg_send(p.c, p.par, p.res);
+	if (rv == SEC_OK)
+		output->pa_rv = *(u32 *) p.res;
+
+	if (pa_command_finish(&p) < 0 && rv == SEC_OK)
+		rv = SEC_FAIL;
+
+out:
+	output->rom_rv = rv;
+}
+
+static int load_firmware(struct device *dev, const char *name,
+			 struct hs_firmware *fw, u32 offset)
+{
+	const struct firmware *p;
+	int rv;
+
+	printk(KERN_INFO HS_NAME ": Loading firmware: %s\n", name);
+	rv = request_firmware(&p, name, dev);
+
+	if (rv < 0)
+		goto done;
+
+	if (p->size <= offset) {
+		rv = -EINVAL;
+		goto done;
+	}
+
+	fw->size = p->size - offset;
+	fw->data = kzalloc(fw->size, GFP_KERNEL);
+
+	if (fw->data)
+		memcpy(fw->data, p->data + offset, fw->size);
+	else
+		rv = -ENOMEM;
+
+	release_firmware(p);
+done:
+	if (rv < 0)
+		printk(KERN_WARNING HS_NAME ": Error loading %s\n", name);
+	return rv;
+}
+
+static int load_wrapper(struct device *dev)
+{
+	int rv;
+
+	rv = load_firmware(dev, OMAP2420_FIRMWARE_WRAP, &hs.wrapper_bin, 0);
+	if (rv < 0)
+		return rv;
+
+	hs.entry.addr = (omap2420_rom_entry *) (hs.wrapper_bin.data + 1);
+	return 0;
+}
+
+static int map_rom_entry(void)
+{
+	if (hs.entry.addr)
+		return 0;
+
+	hs.rom_map.rgn = request_mem_region(OMAP2420_ROM_START_PHYS,
+					    OMAP2420_ROM_SIZE, "omap2420_rom");
+	if (!hs.rom_map.rgn)
+		return -ENODEV;
+
+	hs.rom_map.addr = __ioremap(OMAP2420_ROM_START_PHYS,
+				    OMAP2420_ROM_SIZE, L_PTE_EXEC);
+	if (!hs.rom_map.addr)
+		return -ENOMEM;
+
+	hs.entry.addr = (omap2420_rom_entry *)
+			(hs.rom_map.addr + hs.cpu->entry_offset);
+	return 0;
+}
+
+static int omap2420vx0_init_fixup(struct device *dev)
+{
+	hs.entry.flags = OMAP2420_ROM_ICACHE_ENABLE_MASK;
+	return 0;
+}
+
+static int omap2420v21_init_fixup(struct device *dev)
+{
+	hs.testram_map.rgn = request_mem_region(OMAP2420_TESTRAM_START_PHYS,
+				OMAP2420_TESTRAM_SIZE, "omap2420_testram");
+	if (!hs.testram_map.rgn)
+		return -ENODEV;
+
+	hs.testram_map.addr = ioremap_nocache(OMAP2420_TESTRAM_START_PHYS,
+					      OMAP2420_TESTRAM_SIZE);
+	if (!hs.testram_map.addr)
+		return -ENOMEM;
+
+	return load_wrapper(dev);
+}
+
+static int omap2420v22_init_fixup(struct device *dev)
+{
+	return load_wrapper(dev);
+}
+
+static struct omap2420_revision asic_rev_confs[] = {
+	{
+		.cpu_rev	= OMAP2420_REV_10,
+		.name	 	= "OMAP2420 v1.0",
+		.entry_offset	= OMAP2420_REV_10_ROM_ENTRY_OFFSET,
+		.init_fixup 	= omap2420vx0_init_fixup
+	}, {
+		.cpu_rev	= OMAP2420_REV_20,
+		.name		= "OMAP2420 v2.0",
+		.entry_offset	= OMAP2420_REV_20_ROM_ENTRY_OFFSET,
+		.init_fixup	= omap2420vx0_init_fixup
+	}, {
+		.cpu_rev	= OMAP2420_REV_205,
+		.name		= "OMAP2420 v2.05",
+		.entry_offset	= OMAP2420_REV_20_ROM_ENTRY_OFFSET,
+		.init_fixup	= NULL
+	}, {
+		.cpu_rev	= OMAP2420_REV_21,
+		.name		= "OMAP2420 v2.1",
+		.entry_offset	= OMAP2420_REV_21_ROM_ENTRY_OFFSET,
+		.init_fixup	= omap2420v21_init_fixup
+	}, {
+		.cpu_rev	= OMAP2420_REV_211,
+		.name		= "OMAP2420 v2.11",
+		.entry_offset	= OMAP2420_REV_21_ROM_ENTRY_OFFSET,
+		.init_fixup	= omap2420v21_init_fixup
+	}, {
+		.cpu_rev	= OMAP2420_REV_22,
+		.name		= "OMAP2420 v2.2",
+		.entry_offset	= OMAP2420_REV_22_ROM_ENTRY_OFFSET,
+		.init_fixup	= omap2420v22_init_fixup
+	},
+};
+
+static void cleanup(void)
+{
+	kfree(hs.pa_bin.data);
+	kfree(hs.pafmt_bin.data);
+	kfree(hs.papub_bin.data);
+	kfree(hs.wrapper_bin.data);
+	kfree(storage);
+	
+	if (hs.rom_map.addr)
+		iounmap(hs.rom_map.addr);
+
+	if (hs.rom_map.rgn)
+		release_mem_region(OMAP2420_ROM_START_PHYS, OMAP2420_ROM_SIZE);
+
+	if (hs.testram_map.addr)
+		iounmap(hs.testram_map.addr);
+
+	if (hs.testram_map.rgn)
+		release_mem_region(OMAP2420_TESTRAM_START_PHYS,
+			OMAP2420_TESTRAM_SIZE);
+
+	if (hs.format.cmd)
+		pa_format_free(&hs.format);
+
+	memset(&hs, 0, sizeof(hs));
+}
+
+static int asic_init(struct device *dev)
+{
+	int i;
+	u8 cpu_rev;
+
+	cpu_rev = omap2_cpu_rev();
+
+	for (i = 0; i < ARRAY_SIZE(asic_rev_confs); ++i) {
+		if (cpu_rev == asic_rev_confs[i].cpu_rev) {
+			hs.cpu = &asic_rev_confs[i];
+			break;
+		}
+	}
+
+	if (!hs.cpu) {
+		printk(KERN_WARNING HS_NAME ": Unsupported ASIC revision\n");
+		return -ENODEV;
+	}
+
+	if (hs.cpu->name)
+		printk(KERN_INFO HS_NAME ": Detected %s\n", hs.cpu->name);
+
+	hs.entry.flags = OMAP2420_ROM_NORMAL_FLAGS_MASK;
+
+	if (hs.cpu->init_fixup)
+		return hs.cpu->init_fixup(dev);
+
+	return 0;
+}
+
+static int firmware_init(struct device *dev)
+{
+	int rv;
+
+	rv = load_firmware(dev, OMAP2420_FIRMWARE_PA, &hs.pa_bin,
+			   OMAP2420_PA_OFFSET);
+	if (rv)
+		return rv;
+
+	rv = load_firmware(dev, OMAP2420_FIRMWARE_PAFMT, &hs.pafmt_bin, 0);
+	if (rv)
+		return rv;
+
+	rv = load_firmware(dev, OMAP2420_FIRMWARE_PAPUB, &hs.papub_bin,
+			   OMAP2420_PAPUB_OFFSET);
+	if (rv)
+		return rv;
+
+	return pa_format_parse(hs.pafmt_bin.data, hs.pafmt_bin.size,
+			       &hs.format);
+}
+
+static void sec_exit(void)
+{
+	mutex_lock(&hs.lock);
+	cleanup();
+	mutex_unlock(&hs.lock);
+}
+
+static struct sec_operations omap2420_ops = {
+	.exit		= sec_exit,
+	.secenv_init	= secenv_init,
+	.random_get	= random_get,
+	.pa_query	= pa_query,
+	.pa_service	= pa_service,
+};
+
+static int __init hs_init(void)
+{
+	int rv;
+	struct device *dev;
+	
+	if (!cpu_is_omap2420()) {
+		printk(KERN_WARNING HS_NAME ": Unsupported architecture\n");
+		return -ENODEV;
+	}
+
+	memset(&hs, 0, sizeof(hs));
+	mutex_init(&hs.lock);
+
+	dev = sec_get_device();
+
+	rv = asic_init(dev);
+	if (rv < 0)
+		goto out;
+
+	rv = firmware_init(dev);
+	if (rv < 0)
+		goto out;
+
+	storage_size = SEC_STORAGE_SIZE;
+	storage = kzalloc(storage_size + hs.wrapper_bin.size, GFP_KERNEL);
+	if (!storage) {
+		rv = -ENOMEM;
+		goto out;
+	}
+
+	rv = map_rom_entry();
+	if (rv < 0)
+		goto out;
+
+	return sec_register(&omap2420_ops);
+
+out:
+	cleanup();
+	return rv;
+}
+
+static void __exit hs_exit(void)
+{
+	sec_unregister(&omap2420_ops);
+}
+
+module_init(hs_init);
+module_exit(hs_exit);
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/irq.c maemo_src/arch/arm/mach-omap2/irq.c
--- linux-omap-2.6/arch/arm/mach-omap2/irq.c	2011-02-06 20:17:25.226666606 -0500
+++ maemo_src/arch/arm/mach-omap2/irq.c	2011-02-06 20:12:09.803333272 -0500
@@ -3,13 +3,26 @@
  *
  * Interrupt handler for OMAP2 boards.
  *
- * Copyright (C) 2005 Nokia Corporation
- * Author: Paul Mundt <paul.mundt@nokia.com>
+ * Copyright (C) 2005-2007 Nokia Corporation
+ * Author: Paul Mundt <lethal@linux-sh.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
  *
- * This file is subject to the terms and conditions of the GNU General Public
- * License. See the file "COPYING" in the main directory of this archive
- * for more details.
  */
+
+
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
@@ -18,6 +31,8 @@
 #include <asm/irq.h>
 #include <asm/io.h>
 
+#include "irq.h"
+
 #define INTC_REVISION	0x0000
 #define INTC_SYSCONFIG	0x0010
 #define INTC_SYSSTATUS	0x0014
@@ -25,6 +40,10 @@
 #define INTC_MIR_CLEAR0	0x0088
 #define INTC_MIR_SET0	0x008c
 
+#define GLOBALMASK	0x0004
+#define NEWFIQAGR	0x0002
+#define NEWIRQAGR	0x0001
+
 /*
  * OMAP2 has a number of different interrupt controllers, each interrupt
  * controller is identified as its own "bank". Register definitions are
@@ -35,19 +54,18 @@
 	unsigned long base_reg;
 	unsigned int nr_irqs;
 } __attribute__ ((aligned(4))) irq_banks[] = {
-	{
-		/* MPU INTC */
+	[MPU_INTC] = {
 		.base_reg	= IO_ADDRESS(OMAP24XX_IC_BASE),
 		.nr_irqs	= 96,
-	}, {
-		/* XXX: DSP INTC */
+	},
+	[DSP_INTC] = {
 	}
 };
 
 /* XXX: FIQ and additional INTC support (only MPU at the moment) */
 static void omap_ack_irq(unsigned int irq)
 {
-	__raw_writel(0x1, irq_banks[0].base_reg + INTC_CONTROL);
+	__raw_writel(NEWIRQAGR, irq_banks[MPU_INTC].base_reg + INTC_CONTROL);
 }
 
 static void omap_mask_irq(unsigned int irq)
@@ -60,7 +78,8 @@
 		irq %= 32;
 	}
 
-	__raw_writel(1 << irq, irq_banks[0].base_reg + INTC_MIR_SET0 + offset);
+	__raw_writel(1 << irq,
+		     irq_banks[MPU_INTC].base_reg + INTC_MIR_SET0 + offset);
 }
 
 static void omap_unmask_irq(unsigned int irq)
@@ -73,7 +92,7 @@
 		irq %= 32;
 	}
 
-	__raw_writel(1 << irq, irq_banks[0].base_reg + INTC_MIR_CLEAR0 + offset);
+	__raw_writel(1 << irq, irq_banks[MPU_INTC].base_reg + INTC_MIR_CLEAR0 + offset);
 }
 
 static void omap_mask_ack_irq(unsigned int irq)
@@ -89,6 +108,100 @@
 	.unmask	= omap_unmask_irq,
 };
 
+void omap_mask_irqs(const int intc_id, u32 irqs_mask[])
+{
+	unsigned int i;
+	u32 flags;
+
+	omap_irq_fiq_save_flags(intc_id, &flags);
+
+	for (i = 0; i < (irq_banks[intc_id].nr_irqs + 31) / 32; i++) {
+		u32 tmp;
+
+		tmp = __raw_readl(irq_banks[intc_id].base_reg +
+				  INTC_MIR_CLEAR0 + i);
+		tmp &= ~irqs_mask[i];
+
+		__raw_writel(tmp, irq_banks[intc_id].base_reg +
+			     INTC_MIR_CLEAR0 + i);
+	}
+
+	omap_irq_fiq_restore_flags(intc_id, flags);
+}
+
+void omap_unmask_irqs(const int intc_id, u32 irqs_mask[])
+{
+	unsigned int i;
+	u32 flags;
+
+	omap_irq_fiq_save_flags(intc_id, &flags);
+
+	for (i = 0; i < (irq_banks[intc_id].nr_irqs + 31) / 32; i++) {
+		u32 tmp;
+
+		tmp = __raw_readl(irq_banks[intc_id].base_reg +
+				  INTC_MIR_CLEAR0 + i);
+		tmp &= ~irqs_mask[i];
+
+		__raw_writel(tmp, irq_banks[intc_id].base_reg +
+			     INTC_MIR_CLEAR0 + i);
+	}
+
+	omap_irq_fiq_restore_flags(intc_id, flags);
+}
+
+void omap_save_irqs_mask(const int intc_id, u32 irqs_mask[])
+{
+	unsigned int i;
+	u32 flags;
+
+	omap_irq_fiq_save_flags(intc_id, &flags);
+
+	for (i = 0; i < (irq_banks[intc_id].nr_irqs + 31) / 32; i++) {
+		irqs_mask[i] = __raw_readl(irq_banks[intc_id].base_reg +
+					   INTC_MIR_CLEAR0 + i);
+		__raw_writel(0, irq_banks[intc_id].base_reg +
+			     INTC_MIR_CLEAR0 + i);
+	}
+
+	omap_irq_fiq_restore_flags(intc_id, flags);
+}
+
+void omap_restore_irqs_mask(const int intc_id, u32 irqs_mask[])
+{
+	unsigned int i;
+	u32 flags;
+
+	omap_irq_fiq_save_flags(intc_id, &flags);
+
+	for (i = 0; i < (irq_banks[intc_id].nr_irqs + 31) / 32; i++)
+		__raw_writel(irqs_mask[i], irq_banks[intc_id].base_reg +
+			     INTC_MIR_CLEAR0 + i);
+
+	omap_irq_fiq_restore_flags(intc_id, flags);
+}
+
+void omap_irq_fiq_enable(const int intc_id)
+{
+	__raw_writel(0x0, irq_banks[intc_id].base_reg + INTC_CONTROL);
+}
+
+void omap_irq_fiq_disable(const int intc_id)
+{
+	__raw_writel(GLOBALMASK, irq_banks[intc_id].base_reg + INTC_CONTROL);
+}
+
+void omap_irq_fiq_save_flags(const int intc_id, u32 *flags)
+{
+	*flags = __raw_readl(irq_banks[intc_id].base_reg + INTC_CONTROL);
+	__raw_writel(GLOBALMASK, irq_banks[intc_id].base_reg + INTC_CONTROL);
+}
+
+void omap_irq_fiq_restore_flags(const int intc_id, const u32 flags)
+{
+	__raw_writel(flags, irq_banks[intc_id].base_reg + INTC_CONTROL);
+}
+
 static void __init omap_irq_bank_init_one(struct omap_irq_bank *bank)
 {
 	unsigned long tmp;
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/irq.h maemo_src/arch/arm/mach-omap2/irq.h
--- linux-omap-2.6/arch/arm/mach-omap2/irq.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/mach-omap2/irq.h	2011-02-06 20:12:09.749999939 -0500
@@ -0,0 +1,139 @@
+/*
+ * linux/arch/arm/mach-omap2/irq.h
+ *
+ * Interrupt handler for OMAP2 boards.
+ *
+ * Copyright (C) 2005-2007 Nokia Corporation
+ * Contact: Igor Stoppa <igor.stoppa@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __OMAP_IRQ_H
+#define __OMAP_IRQ_H
+
+
+/* List MPU irqs */
+#define MPU_EMUINT		 0
+#define MPU_COMMRX		 1
+#define MPU_COMMTX		 2
+#define MPU_BENCH		 3
+#define MPU_XTI_IRQ		 4
+#define MPU_XTI_WKUP_IRQ	 5
+#define MPU_SSM_ABORT_IRQ	 6
+#define MPU_SYS_nIRQ		 7
+#define MPU_L3_IRQ		10
+#define MPU_PRCM_MPU_IRQ	11
+#define MPU_SDMA_IRQ0		12
+#define MPU_SDMA_IRQ1		13
+#define MPU_SDMA_IRQ2		14
+#define MPU_SDMA_IRQ3		15
+#define MPU_GPMC_IRQ		20
+#define MPU_GFX_IRQ		21
+#define MPU_IVA_IRQ		22
+#define MPU_EAC_IRQ		23
+#define MPU_CAM_IRQ0		24
+#define MPU_DSS_IRQ		25
+#define MPU_MAIL_MPU_IRQ	26
+#define MPU_DSP_MMU_IRQ		28
+#define MPU_GPIO1_MPU_IRQ	29
+#define MPU_GPIO2_MPU_IRQ	30
+#define MPU_GPIO3_MPU_IRQ	31
+#define MPU_GPIO4_MPU_IRQ	32
+#define MPU_MAIL_U3_MPU_IRQ	34
+#define MPU_WDT3_IRQ		35
+#define MPU_WDT4_IRQ		36
+#define MPU_GPT1_IRQ		37
+#define MPU_GPT2_IRQ		38
+#define MPU_GPT3_IRQ		39
+#define MPU_GPT4_IRQ		40
+#define MPU_GPT5_IRQ		41
+#define MPU_GPT6_IRQ		42
+#define MPU_GPT7_IRQ		43
+#define MPU_GPT8_IRQ		44
+#define MPU_GPT9_IRQ		45
+#define MPU_GPT10_IRQ		46
+#define MPU_GPT11_IRQ		47
+#define MPU_GPT12_IRQ		48
+#define MPU_PKA_IRQ		50
+#define MPU_SHA1MD5_IRQ		51
+#define MPU_RNG_IRQ		52
+#define MPU_MG_IRQ		53
+#define MPU_I2C1_IRQ		56
+#define MPU_I2C2_IRQ		57
+#define MPU_HDQ_IRQ		58
+#define MPU_McBSP1_IRQ_TX	59
+#define MPU_McBSP1_IRQ_RX	60
+#define MPU_McBSP2_IRQ_TX	62
+#define MPU_McBSP2_IRQ_RX	63
+#define MPU_SPI1_IRQ		65
+#define MPU_SPI2_IRQ		66
+#define MPU_SSI_P1_MPU_IRQ0	67
+#define MPU_SSI_P1_MPU_IRQ1	68
+#define MPU_SSI_P2_MPU_IRQ0	69
+#define MPU_SSI_P2_MPU_IRQ1	70
+#define MPU_SSI_GDD_MPU_IRQ	71
+#define MPU_UART1_IRQ		72
+#define MPU_UART2_IRQ		73
+#define MPU_UART3_IRQ		74
+#define MPU_USB_IRQ_GEN		75
+#define MPU_USB_IRQ_NISO	76
+#define MPU_USB_IRQ_ISO		77
+#define MPU_USB_IRQ_HGEN	78
+#define MPU_USB_IRQ_HSOF	79
+#define MPU_USB_IRQ_OTG		80
+#define MPU_VLYNQ_IRQ		81
+#define MPU_MMC_IRQ		83
+#define MPU_MS_IRQ		84
+#define MPU_FAC_IRQ		85
+
+enum intc_id{
+	MPU_INTC = 0,
+	DSP_INTC,
+	IVA_INTC,
+};
+
+void omap_irq_fiq_enable(const int intc_id);
+void omap_irq_fiq_disable(const int intc_id);
+void omap_irq_fiq_save_flags(const int intc_id, u32 *flags);
+void omap_irq_fiq_restore_flags(const int intc_id, const u32 flags);
+
+static inline void omap_irqs_mask_set(unsigned int irq, u32 irqs_mask[])
+{
+	irqs_mask[irq / 32] |= 1 << (irq % 32);
+}
+
+static inline void omap_irqs_mask_clear(unsigned int irq, u32 irqs_mask[])
+{
+	irqs_mask[irq / 32] &= ~(1 << (irq % 32));
+}
+
+static inline void omap_irqs_mask_set_all(u32 irqs_mask[])
+{
+	irqs_mask[0] = irqs_mask[1] = irqs_mask[2] = ~0;
+}
+
+static inline void omap_irqs_mask_clear_all(u32 irqs_mask[])
+{
+	irqs_mask[0] = irqs_mask[1] = irqs_mask[2] = 0;
+}
+
+void omap_mask_irqs(const int intc_id, u32 irqs_mask[]);
+void omap_unmask_irqs(const int intc_id, u32 irqs_mask[]);
+void omap_save_irqs_mask(const int intc_id, u32 irqs_mask[]);
+void omap_restore_irqs_mask(const int intc_id, u32 irqs_mask[]);
+
+#endif
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/Kconfig maemo_src/arch/arm/mach-omap2/Kconfig
--- linux-omap-2.6/arch/arm/mach-omap2/Kconfig	2011-02-06 20:17:24.873333273 -0500
+++ maemo_src/arch/arm/mach-omap2/Kconfig	2011-02-06 20:12:09.789999940 -0500
@@ -15,6 +15,10 @@
 	bool "OMAP2430 support"
 	depends on ARCH_OMAP24XX
 
+config ARCH_OMAP2420_HS
+	tristate "OMAP2420 HS support"
+	depends on ARCH_OMAP2420 && OMAP_SEC
+
 comment "OMAP Board Type"
 	depends on ARCH_OMAP2
 
@@ -26,6 +30,16 @@
 	bool "Nokia N800"
 	depends on ARCH_OMAP24XX
 
+config MACH_NOKIA_RX44
+	bool "Nokia RX44"
+	depends on ARCH_OMAP24XX && MACH_NOKIA_N800
+	select MACH_OMAP2_TUSB6010
+
+config MACH_NOKIA_RX48
+	bool "Nokia RX48"
+	depends on ARCH_OMAP24XX && MACH_NOKIA_N800
+	select MACH_OMAP2_TUSB6010
+
 config MACH_OMAP2_TUSB6010
 	bool
 	depends on ARCH_OMAP2 && ARCH_OMAP2420
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/mailbox.c maemo_src/arch/arm/mach-omap2/mailbox.c
--- linux-omap-2.6/arch/arm/mach-omap2/mailbox.c	2011-02-06 20:17:25.226666606 -0500
+++ maemo_src/arch/arm/mach-omap2/mailbox.c	2007-10-02 03:09:30.000000000 -0400
@@ -1,13 +1,27 @@
 /*
  * Mailbox reservation modules for OMAP2
  *
- * Copyright (C) 2006 Nokia Corporation
+ * Copyright (C) 2006-2007 Nokia Corporation
+ *
+ * Contact: Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
+ *
  * Written by: Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
- *        and  Paul Mundt <paul.mundt@nokia.com>
+ *        and  Paul Mundt <lethal@linux-sh.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
  *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 
 #include <linux/kernel.h>
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/Makefile maemo_src/arch/arm/mach-omap2/Makefile
--- linux-omap-2.6/arch/arm/mach-omap2/Makefile	2011-02-06 20:17:25.056666605 -0500
+++ maemo_src/arch/arm/mach-omap2/Makefile	2011-02-06 20:12:09.786666607 -0500
@@ -11,12 +11,26 @@
 # Power Management
 obj-$(CONFIG_PM) += pm.o sleep.o
 
+# 2420 DVFS
+obj-$(CONFIG_MACH_OMAP2420_DVFS) += omap2_dvfs.o
+omap2_dvfs-objs := dvs.o scale_freq.o dvfs.o board-n800-dvfs.o
+omap2_dvfs-$(CONFIG_CPU_FREQ) += cpu.o
+
 # DSP
 obj-$(CONFIG_OMAP_MMU_FWK)	+= mmu_mach.o
 obj-$(CONFIG_OMAP_MBOX_FWK)	+= mailbox_mach.o
 mailbox_mach-objs		:= mailbox.o
 mmu_mach-objs			:= mmu.o
 
+# OMAP2 Observability
+obj-$(CONFIG_ARCH_OMAP2420_OBSERVABILITY) += observability.o
+
+# OMAP2 Memory peeking & pooking
+obj-$(CONFIG_ARCH_OMAP2420_PEEK_N_POKE) += peeknpoke.o
+
+# OMAP2 Memory snapshot
+obj-$(CONFIG_ARCH_OMAP2420_SNAPSHOT) += snapshot.o
+
 # Specific board support
 obj-$(CONFIG_MACH_OMAP_GENERIC)		+= board-generic.o
 obj-$(CONFIG_MACH_OMAP_H4)		+= board-h4.o
@@ -27,8 +41,13 @@
 obj-$(CONFIG_MACH_NOKIA_N800)		+= board-n800.o board-n800-flash.o \
 					   board-n800-mmc.o board-n800-bt.o \
 					   board-n800-audio.o board-n800-usb.o \
-					   board-n800-dsp.o board-n800-pm.o
+					   board-n800-dsp.o board-n800-pm.o \
+					   board-n800-camera.o
+obj-$(CONFIG_MACH_NOKIA_RX44)		+= board-n810.o board-n810-keyboard.o
 
 # TUSB 6010 chips
 obj-$(CONFIG_MACH_OMAP2_TUSB6010)	+= usb-tusb6010.o
 
+# HS
+obj-$(CONFIG_ARCH_OMAP2420_HS)		+= omap2_hs.o
+omap2_hs-objs				+= hs.o
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/memory.c maemo_src/arch/arm/mach-omap2/memory.c
--- linux-omap-2.6/arch/arm/mach-omap2/memory.c	2011-02-06 20:17:25.229999939 -0500
+++ maemo_src/arch/arm/mach-omap2/memory.c	2011-02-06 20:12:09.866666606 -0500
@@ -109,6 +109,7 @@
 	l = SMS_SYSCONFIG;
 	l &= ~(0x3 << 3);
 	l |= (0x2 << 3);
+	l |= (0x1 << 0);
 	SMS_SYSCONFIG = l;
 
 	l = SDRC_SYSCONFIG;
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/mmu.c maemo_src/arch/arm/mach-omap2/mmu.c
--- linux-omap-2.6/arch/arm/mach-omap2/mmu.c	2011-02-06 20:17:25.229999939 -0500
+++ maemo_src/arch/arm/mach-omap2/mmu.c	2007-10-02 03:09:30.000000000 -0400
@@ -5,25 +5,27 @@
  *
  * Copyright (C) 2002-2007 Nokia Corporation
  *
+ * Contact: Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
+ *
  * Written by Toshihiro Kobayashi <toshihiro.kobayashi@nokia.com>
  *        and Paul Mundt <paul.mundt@nokia.com>
  *
- * TWL support: Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
  */
+
 #include <linux/types.h>
 #include <linux/init.h>
 #include <linux/rwsem.h>
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/observability.c maemo_src/arch/arm/mach-omap2/observability.c
--- linux-omap-2.6/arch/arm/mach-omap2/observability.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/mach-omap2/observability.c	2007-10-02 03:09:30.000000000 -0400
@@ -0,0 +1,1018 @@
+/*
+ * linux/arch/arm/mach-omap2/observability.c
+ *
+ * OMAP2 Debug Interface Routines
+ *
+ * Copyright (C) 2007 Nokia Corporation
+ * Igor Stoppa <igor.stoppa@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/pm.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/pm.h>
+#include <linux/interrupt.h>
+#include <linux/sysfs.h>
+#include <linux/module.h>
+#include <linux/debugfs.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/atomic.h>
+#include <asm/uaccess.h>
+#include <asm/mach/time.h>
+#include <asm/mach/irq.h>
+#include <asm/mach-types.h>
+
+#include <asm/arch/irqs.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/sram.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/pm.h>
+#include <asm/arch/gpio.h>
+
+#include <asm/arch/observability.h>
+
+
+#define CONTROL_PADCONF_CAM_D8		0x480000d0
+#define CONTROL_PADCONF_CAM_D4		0x480000d4
+#define CONTROL_PADCONF_CAM_D0		0x480000d8
+#define CONTROL_PADCONF_CAM_XCLK	0x480000dc
+#define CONTROL_DEBOBS			0x48000270
+
+static struct dentry *observability_root;
+
+/* OBSMUX handling: insert and remove OBSMUX entry */
+static struct dentry *obs_mux_f;
+
+static ssize_t omap_obs_mux_show(struct file *file, char __user *user_buf,
+				 size_t count, loff_t *ppos)
+{
+	char buf[6];
+
+	sprintf(buf, "0x%02X\n", omap_readl(CONTROL_DEBOBS) & 0x7f);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, 5);
+}
+
+static ssize_t
+omap_obs_mux_store(struct file *file, const char __user *user_buf,
+		   size_t count, loff_t *ppos)
+{
+	char buf[6];
+	int buf_size;
+	u32 val;
+	u32 old;
+
+	buf_size = min(count, (sizeof(buf)-1));
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	if (sscanf(buf, "%i", &val) != 1) {
+		printk(KERN_ERR "HW Debug: Invalid OBSMUX\n");
+		return -EINVAL;
+	}
+
+	old = omap_readl(CONTROL_DEBOBS) & ~0x7f;
+	omap_writel(old | val, CONTROL_DEBOBS);
+
+	return count;
+}
+
+static const struct file_operations fops_obs_mux = {
+	.read =		omap_obs_mux_show,
+	.write =	omap_obs_mux_store,
+};
+
+static inline void enable_dbg_obs(void)
+{
+	obs_mux_f = debugfs_create_file("obs_mux", 0644, observability_root,
+				      NULL, &fops_obs_mux);
+}
+
+static inline void disable_dbg_obs(void)
+{
+	debugfs_remove(obs_mux_f);
+}
+
+/* GPIO handling: insert and remove GPIOs entries */
+
+struct dbg_gpio {
+#ifdef CONFIG_OMAP_MUX
+	unsigned	index; /* index has to be sorted ascending*/
+#endif
+	u8		num;
+	u8		dir;
+};
+
+static u8 dbg_gpios_val[OMAP2420_HW_DBG_GPIOS_NUM];
+
+#ifdef CONFIG_OMAP_MUX
+static const struct dbg_gpio dbg_gpios_def[] = {
+	{
+		.index	= V4_242X_GPIO49,
+		.num	= 49,
+		.dir	= 0
+	},
+	{
+		.index	= W2_242X_GPIO50,
+		.num	= 50,
+		.dir	= 0
+	},
+	{
+		.index	= U4_242X_GPIO51,
+		.num	= 51,
+		.dir	= 0
+	},
+	{
+		.index	= V3_242X_GPIO52,
+		.num	= 52,
+		.dir	= 0
+	},
+	{
+		.index	= V2_242X_GPIO53,
+		.num	= 53,
+		.dir	= 0
+	},
+	{
+		.index	= T4_242X_GPIO54,
+		.num	= 54,
+		.dir	= 0
+	},
+	{
+		.index	= T3_242X_GPIO55,
+		.num	= 55,
+		.dir	= 0
+	},
+	{
+		.index	= U2_242X_GPIO56,
+		.num	= 56,
+		.dir	= 0
+	}
+};
+
+#else
+
+static const struct dbg_gpio dbg_gpios_def[] = {
+	{
+		.num	= 49,
+		.dir	= 0
+	},
+	{
+		.num	= 50,
+		.dir	= 0
+	},
+	{
+		.num	= 51,
+		.dir	= 0
+	},
+	{
+		.num	= 52,
+		.dir	= 0
+	},
+	{
+		.num	= 53,
+		.dir	= 0
+	},
+	{
+		.num	= 54,
+		.dir	= 0
+	},
+	{
+		.num	= 55,
+		.dir	= 0
+	},
+	{
+		.num	= 56,
+		.dir	= 0
+	}
+};
+#endif
+
+static enum dbg_gpios current_dbg_gpio;
+
+/* Handle dbg_gpio selection */
+static struct dentry *available_gpios_f;
+
+static ssize_t
+omap_available_gpios_show(struct file *file, char __user *user_buf,
+			  size_t count, loff_t *ppos)
+{
+	unsigned gpio;
+
+/* 4 -> 3 digits for gpio number + 1 separator, 1 -> terminator */
+	char buf[sizeof(dbg_gpios_def) / sizeof(struct dbg_gpio) * 4 + 1];
+	char * start = buf;
+	char * cursor = buf;
+
+	for (gpio = 0; gpio < OMAP2420_HW_DBG_GPIOS_NUM; gpio++) {
+		cursor += sprintf(cursor,"%d ", dbg_gpios_def[gpio].num);
+	}
+	strcat(cursor, "\n");
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf,
+				       cursor - start);
+}
+
+static const struct file_operations fops_available_gpios = {
+	.read =		omap_available_gpios_show,
+};
+
+
+
+static struct dentry *gpio_num_f;
+
+static ssize_t omap_gpio_num_show(struct file *file, char __user *user_buf,
+			      size_t count, loff_t *ppos)
+{
+	char buf[5];
+	int len;
+
+	len = sprintf(buf, "%d\n", dbg_gpios_def[current_dbg_gpio].num);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t
+omap_gpio_num_store(struct file *file, const char __user *user_buf,
+		    size_t count, loff_t *ppos)
+{
+	char buf[5];
+	int buf_size;
+	unsigned num;
+	unsigned gpio;
+
+	buf_size = min(count, (sizeof(buf)-1));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	if (sscanf(buf, "%u", &num) != 1) {
+		printk(KERN_ERR "HW Debug: Invalid gpio number\n");
+		return -EINVAL;
+	}
+
+	for (gpio = 0; gpio < OMAP2420_HW_DBG_GPIOS_NUM; gpio++) {
+		if (dbg_gpios_def[gpio].num == num) {
+			current_dbg_gpio = gpio;
+			return count;
+		}
+	}
+
+	printk(KERN_ERR "HW Debug: Invalid gpio number\n");
+	return -EINVAL;
+}
+
+static const struct file_operations fops_gpio_num = {
+	.read =		omap_gpio_num_show,
+	.write =	omap_gpio_num_store,
+};
+
+/* Handle dbg_gpio setting/resetting */
+int omap_set_dbg_gpio_val(enum dbg_gpios gpio, u8 val)
+{
+	if (val != 0 && val != 1)
+		return -EINVAL;
+
+	dbg_gpios_val[gpio] = val;
+	omap_set_gpio_dataout(dbg_gpios_def[gpio].num, val);
+
+	return 0;
+}
+EXPORT_SYMBOL(omap_set_dbg_gpio_val);
+
+
+
+static struct dentry *gpio_val_f;
+
+static ssize_t omap_gpio_val_show(struct file *file, char __user *user_buf,
+				  size_t count, loff_t *ppos)
+{
+	char buf[3];
+
+	sprintf(buf, "%d\n", dbg_gpios_val[current_dbg_gpio]);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, 3);
+}
+
+static ssize_t
+omap_gpio_val_store(struct file *file, const char __user *user_buf,
+		    size_t count, loff_t *ppos)
+{
+	char buf[3];
+	int buf_size;
+	unsigned val;
+
+	buf_size = min(count, (sizeof(buf)-1));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	if (sscanf(buf, "%u", &val) != 1 ||
+	    !(val == 0 || val == 1)) {
+		printk(KERN_ERR "HW Debug: Invalid gpio value\n");
+		return -EINVAL;
+	}
+
+	omap_set_dbg_gpio_val(current_dbg_gpio, val);
+	return count;
+
+}
+
+static const struct file_operations fops_gpio_val = {
+	.read =		omap_gpio_val_show,
+	.write =	omap_gpio_val_store,
+};
+
+
+/* Handle dbg_gpio setting/resetting as a 8 bit word */
+
+int omap_get_dbg_gpio_word(void)
+{
+	unsigned gpio;
+	int val = 0;
+
+	for (gpio = 0; gpio < OMAP2420_HW_DBG_GPIOS_NUM; gpio++) {
+		val |= dbg_gpios_val[gpio] << gpio;
+	}
+
+	return val;
+}
+EXPORT_SYMBOL(omap_get_dbg_gpio_word);
+
+int omap_set_dbg_gpio_word(u8 val)
+{
+	unsigned gpio;
+	u8 v;
+
+	for (gpio = 0; gpio < OMAP2420_HW_DBG_GPIOS_NUM; gpio++) {
+		v = (val >> gpio) & 1;
+		dbg_gpios_val[gpio] = v;
+		omap_set_gpio_dataout(dbg_gpios_def[gpio].num, v);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(omap_set_dbg_gpio_word);
+
+
+static struct dentry *gpio_word_f;
+
+static ssize_t omap_gpio_word_show(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+	char buf[6];
+
+	sprintf(buf, "0x%02X\n", omap_get_dbg_gpio_word());
+	return simple_read_from_buffer(user_buf, count, ppos, buf, 6);
+}
+
+static ssize_t
+omap_gpio_word_store(struct file *file, const char __user *user_buf,
+		   size_t count, loff_t *ppos)
+{
+	char buf[6];
+	int buf_size;
+	unsigned val;
+
+	buf_size = min(count, (sizeof(buf)-1));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	if (sscanf(buf, "%i", &val) != 1) {
+		printk(KERN_ERR "HW Debug: Invalid gpio value\n");
+		return -EINVAL;
+	}
+
+	omap_set_dbg_gpio_word(val);
+
+	return count;
+
+}
+
+static const struct file_operations fops_gpio_word = {
+	.read =		omap_gpio_word_show,
+	.write =	omap_gpio_word_store,
+};
+
+
+/* Actual handling of entries */
+static inline void enable_dbg_gpio(void)
+{
+	available_gpios_f = debugfs_create_file("available_gpios", 0444,
+						observability_root, NULL,
+						&fops_available_gpios);
+	gpio_num_f = debugfs_create_file("gpio_num", 0644, observability_root,
+					 NULL, &fops_gpio_num);
+	gpio_val_f = debugfs_create_file("gpio_val", 0644, observability_root,
+					 NULL, &fops_gpio_val);
+	gpio_word_f = debugfs_create_file("gpio_word", 0644, observability_root,
+					  NULL, &fops_gpio_word);
+}
+
+static inline void disable_dbg_gpio(void)
+{
+	debugfs_remove(available_gpios_f);
+	debugfs_remove(gpio_num_f);
+	debugfs_remove(gpio_val_f);
+	debugfs_remove(gpio_word_f);
+}
+
+static int omap_dbg_gpio_init(void)
+{
+	int ret = 0;
+	enum dbg_gpios gpio;
+
+	for (gpio = 0; gpio < OMAP2420_HW_DBG_GPIOS_NUM && !ret; gpio++) {
+#ifdef CONFIG_OMAP_MUX
+		omap_cfg_reg(dbg_gpios_def[gpio].index);
+#endif
+		ret = omap_request_gpio(dbg_gpios_def[gpio].num);
+		omap_set_gpio_direction(dbg_gpios_def[gpio].num,
+					dbg_gpios_def[gpio].dir);
+		omap_set_dbg_gpio_val(gpio, 0);
+	}
+
+	for (; ret && gpio >= 0; gpio--)
+		omap_free_gpio(dbg_gpios_def[gpio].num);
+	return ret;
+}
+
+static void omap_dbg_gpio_exit(void)
+{
+	enum dbg_gpios gpio;
+
+	for (gpio = 0; gpio < OMAP2420_HW_DBG_GPIOS_NUM; gpio++)
+		omap_free_gpio(dbg_gpios_def[gpio].num);
+}
+
+/* Peeking: exposure of 1 byte from a selectable memory location */
+
+static const unsigned register_sizes[] = {1, 2, 4};
+
+static enum omap_dbg_register_sizes register_size;
+
+static struct dentry *available_register_sizes_f;
+
+static ssize_t
+omap_available_register_sizes_show(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+	char buf[6];
+	char * start = buf;
+	char * cursor = buf;
+	int i;
+
+	for (i = 0; i < OMAP2420_HW_DBG_REG_SIZES_NUM; i++)
+		cursor += sprintf(cursor, "%d ", register_sizes[i]);
+	cursor += sprintf(buf, "\n");
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf,
+				       cursor - start);
+}
+
+static const struct file_operations fops_available_register_sizes = {
+	.read =		omap_available_register_sizes_show,
+};
+
+
+void omap_dbg_set_register_size(const enum omap_dbg_register_sizes new_size)
+{
+	register_size = new_size;
+	if (omap_dbg_get_position() >= register_sizes[register_size]) {
+		omap_dbg_set_position(register_sizes[register_size] - 1);
+	}
+	omap_dbg_update_visible_byte();
+}
+EXPORT_SYMBOL(omap_dbg_set_register_size);
+
+enum omap_dbg_register_sizes omap_dbg_get_register_size(void)
+{
+	return register_sizes[register_size];
+}
+EXPORT_SYMBOL(omap_dbg_get_register_size);
+
+
+static struct dentry *register_size_f;
+
+static ssize_t omap_register_size_show(struct file *file, char __user *user_buf,
+				       size_t count, loff_t *ppos)
+{
+	char buf[3];
+
+	sprintf(buf, "%u\n", omap_dbg_get_register_size());
+	return simple_read_from_buffer(user_buf, count, ppos, buf, 3);
+}
+
+static ssize_t
+omap_register_size_store(struct file *file, const char __user *user_buf,
+		   size_t count, loff_t *ppos)
+{
+	char buf[3];
+	int buf_size;
+	unsigned val;
+	int i;
+
+	buf_size = min(count, (sizeof(buf)-1));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	if (sscanf(buf, "%u", &val) != 1) {
+		printk(KERN_ERR "HW Debug: Invalid word size value\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < OMAP2420_HW_DBG_REG_SIZES_NUM; i++)
+		if (val == register_sizes[i])
+			break;
+	if (i == OMAP2420_HW_DBG_REG_SIZES_NUM) {
+		printk(KERN_ERR "HW Debug: Invalid word size value\n");
+		return -EINVAL;
+	}
+
+	omap_dbg_set_register_size(i);
+
+	return count;
+
+}
+
+static const struct file_operations fops_register_size = {
+	.read =		omap_register_size_show,
+	.write =	omap_register_size_store,
+};
+
+static unsigned *address;
+
+void omap_dbg_set_address(unsigned * new_address)
+{
+	address = new_address;
+	omap_dbg_set_position(0);
+	omap_dbg_set_register_size(register_sizes[0]);
+}
+EXPORT_SYMBOL(omap_dbg_set_address);
+
+unsigned * omap_dbg_get_address(void)
+{
+	return address;
+}
+EXPORT_SYMBOL(omap_dbg_get_address);
+
+
+static struct dentry *address_f;
+
+static ssize_t omap_dbg_address_show(struct file *file, char __user *user_buf,
+				     size_t count, loff_t *ppos)
+{
+	char buf[12];
+
+	sprintf(buf, "0x%08x\n", (unsigned)omap_dbg_get_address());
+	return simple_read_from_buffer(user_buf, count, ppos, buf, 12);
+}
+
+static ssize_t
+omap_dbg_address_store(struct file *file, const char __user *user_buf,
+		       size_t count, loff_t *ppos)
+{
+	char buf[12];
+	int buf_size;
+	unsigned val;
+
+	buf_size = min(count, sizeof(buf));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	buf[buf_size - 1] = '\0';
+
+	if (sscanf(buf, "%i", &val) != 1) {
+		printk(KERN_ERR "HW Debug: Invalid address\n");
+		return -EINVAL;
+	} else if (val % register_size) {
+		printk(KERN_ERR "HW Debug: Address must be"
+				"aligned to max word size\n");
+		return -EINVAL;
+	}
+
+	omap_dbg_set_address((unsigned *)val);
+
+	return count;
+
+}
+
+static const struct file_operations fops_address = {
+	.read =		omap_dbg_address_show,
+	.write =	omap_dbg_address_store,
+};
+
+static unsigned position;
+
+void omap_dbg_set_position(unsigned new_position)
+{
+	position = new_position;
+	omap_dbg_update_visible_byte();
+}
+EXPORT_SYMBOL(omap_dbg_set_position);
+
+unsigned omap_dbg_get_position(void)
+{
+	return position;
+}
+EXPORT_SYMBOL(omap_dbg_get_position);
+
+static struct dentry *position_f;
+
+static ssize_t omap_dbg_position_show(struct file *file, char __user *user_buf,
+				      size_t count, loff_t *ppos)
+{
+	char buf[3];
+
+	sprintf(buf, "%u\n", (unsigned)omap_dbg_get_position());
+	return simple_read_from_buffer(user_buf, count, ppos, buf, 3);
+}
+
+static ssize_t 
+omap_dbg_position_store(struct file *file, const char __user *user_buf,
+			size_t count, loff_t *ppos)
+{
+	char buf[6];
+	int buf_size;
+	unsigned val;
+
+	buf_size = min(count, (sizeof(buf)-1));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	if (sscanf(buf, "%u", &val) != 1 ||
+	    val >= register_sizes[register_size]) {
+		printk(KERN_ERR "HW Debug: Invalid position\n");
+		return -EINVAL;
+	}
+
+	omap_dbg_set_position(val);
+
+	return count;
+
+}
+
+static const struct file_operations fops_position = {
+	.read =		omap_dbg_position_show,
+	.write =	omap_dbg_position_store,
+};
+
+
+void omap_dbg_update_visible_byte(void)
+{
+	omap_set_dbg_gpio_word(omap_readb((u32)position + (u32)address));
+}
+EXPORT_SYMBOL(omap_dbg_update_visible_byte);
+
+void omap_dbg_set_visible_byte(u8 new_visible_byte)
+{
+	u32 tmp;
+	u32 mask = ((u32)0xff) << (8 * position);
+	u32 new_val = ((u32)new_visible_byte) << (8 * position);
+
+	switch (register_size) {
+	case OMAP2420_HW_DBG_REG_SIZE_4:
+		tmp = omap_readl((u32)address);
+		tmp = (tmp & (~mask)) | new_val;
+		omap_writel((u32)tmp, (u32)address);
+		break;
+	case OMAP2420_HW_DBG_REG_SIZE_2:
+		tmp = omap_readw((u32)address);
+		tmp = (tmp & (~mask)) | new_val;
+		omap_writew((u16)tmp, (u32)address);
+		break;
+	case OMAP2420_HW_DBG_REG_SIZE_1:
+		tmp = omap_readb((u32)address);
+		tmp = (tmp & (~mask)) | new_val;
+		omap_writeb((u8)tmp, (u32)address);
+		break;
+	default:
+		break;
+	}
+
+	omap_dbg_update_visible_byte();
+}
+EXPORT_SYMBOL(omap_dbg_set_visible_byte);
+
+u8 omap_dbg_get_visible_byte(void)
+{
+	return omap_readb(position + (u8*)address);
+}
+EXPORT_SYMBOL(omap_dbg_get_visible_byte);
+
+
+static struct dentry *visible_byte_f;
+
+static ssize_t
+omap_dbg_visible_byte_show(struct file *file, char __user *user_buf,
+			   size_t count, loff_t *ppos)
+{
+	char buf[6];
+
+	sprintf(buf, "0x%x\n", (unsigned)omap_dbg_get_visible_byte());
+	return simple_read_from_buffer(user_buf, count, ppos, buf, 6);
+}
+
+static ssize_t 
+omap_dbg_visible_byte_store(struct file *file, const char __user *user_buf,
+			    size_t count, loff_t *ppos)
+{
+	char buf[6];
+	int buf_size;
+	unsigned val;
+
+	buf_size = min(count, (sizeof(buf)-1));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	if (sscanf(buf, "%i", &val) != 1 || val >= 256) {
+		printk(KERN_ERR "HW Debug: Invalid value\n");
+		return -EINVAL;
+	}
+
+	omap_dbg_set_visible_byte((u8)val);
+
+	return count;
+
+}
+
+static const struct file_operations fops_visible_byte = {
+	.read =		omap_dbg_visible_byte_show,
+	.write =	omap_dbg_visible_byte_store,
+};
+
+
+
+static struct dentry *update_f;
+
+static ssize_t
+omap_dbg_update_store(struct file *file, const char __user *user_buf,
+		      size_t count, loff_t *ppos)
+{
+	char buf[6];
+	int buf_size;
+
+	buf_size = min(count, (sizeof(buf)-1));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	omap_dbg_update_visible_byte();
+
+	return count;
+}
+
+static const struct file_operations fops_update = {
+	.write =	omap_dbg_update_store,
+};
+
+static inline void enable_dbg_peek(void)
+{
+	omap_dbg_set_address((unsigned*)0x48008000);
+	available_register_sizes_f =
+		debugfs_create_file("available_register_sizes", 0444,
+				    observability_root, NULL,
+				    &fops_available_register_sizes);
+
+	register_size_f =
+		debugfs_create_file("register_size", 0644, observability_root,
+				    NULL, &fops_register_size);
+
+	address_f = debugfs_create_file("address", 0644, observability_root,
+					NULL, &fops_address);
+
+	position_f = debugfs_create_file("position", 0644, observability_root,
+					 NULL, &fops_position);
+
+	visible_byte_f =
+		debugfs_create_file("visible_byte", 0644, observability_root,
+				    NULL, &fops_visible_byte);
+
+	update_f = debugfs_create_file("update", 0200, observability_root,
+					 NULL, &fops_update);
+}
+
+static inline void disable_dbg_peek(void)
+{
+	debugfs_remove(available_register_sizes_f);
+	debugfs_remove(register_size_f);
+	debugfs_remove(address_f);
+	debugfs_remove(position_f);
+	debugfs_remove(visible_byte_f);
+	debugfs_remove(update_f);
+}
+
+
+/*
+ *	Debug modes handling: insert and remove mode-specific
+ *	entries	upon selection/deselection of debug mode
+ */
+
+#define DBG_MODE_NAME_MAX_LEN	10
+
+struct dbg_mode {
+	char	name[10];
+	u32	pattern;
+};
+
+static const struct dbg_mode dbg_modes_def[] = {
+	{
+		.name		= "camera",
+		.pattern	= 0x00000000
+	},
+	{
+		.name		= "obs",
+		.pattern	= 0x01010101
+	},
+	{
+		.name		= "gpio",
+		.pattern	= 0x03030303
+	},
+	{
+		.name		= "peek",
+		.pattern	= 0x03030303
+	}
+};
+
+static enum omap_dbg_modes current_dbg_mode;
+
+void omap_set_dbg_mode(const enum omap_dbg_modes mode)
+{
+	if (mode == current_dbg_mode)
+		return;
+	switch (current_dbg_mode) {
+	case OMAP2420_HW_DBG_MODE_OBS:
+		disable_dbg_obs();
+		break;
+
+	case OMAP2420_HW_DBG_MODE_GPIO:
+		disable_dbg_gpio();
+		break;
+
+	case OMAP2420_HW_DBG_MODE_PEEK:
+		disable_dbg_peek();
+		break;
+
+	case OMAP2420_HW_DBG_MODE_CAMERA:
+	default:
+		break;
+	}
+
+	omap_writel(dbg_modes_def[mode].pattern, CONTROL_PADCONF_CAM_D8);
+	omap_writel(dbg_modes_def[mode].pattern, CONTROL_PADCONF_CAM_D4);
+	omap_writel(dbg_modes_def[mode].pattern, CONTROL_PADCONF_CAM_D0);
+	omap_writel(dbg_modes_def[mode].pattern, CONTROL_PADCONF_CAM_XCLK);
+
+	switch (mode) {
+	case OMAP2420_HW_DBG_MODE_OBS:
+		enable_dbg_obs();
+		break;
+
+	case OMAP2420_HW_DBG_MODE_GPIO:
+		enable_dbg_gpio();
+		break;
+
+	case OMAP2420_HW_DBG_MODE_PEEK:
+		enable_dbg_peek();
+		break;
+
+	case OMAP2420_HW_DBG_MODE_CAMERA:
+	default:
+		break;
+	}
+	current_dbg_mode = mode;
+}
+EXPORT_SYMBOL(omap_set_dbg_mode);
+
+static struct dentry *available_debug_modes_f;
+
+static ssize_t 
+omap_available_debug_modes_show(struct file *file, char __user *user_buf,
+			  size_t count, loff_t *ppos)
+{
+	unsigned mode;
+	char buf[sizeof(dbg_modes_def[0].name) * OMAP2420_HW_DBG_MODES_NUM + 2];
+	char * start = buf;
+	char * cursor = buf;
+
+	for (mode = 0; mode < OMAP2420_HW_DBG_MODES_NUM; mode++) {
+		cursor += sprintf(cursor, "%s ", dbg_modes_def[mode].name);
+	}
+	strcat(cursor - 1, "\n");
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf,
+				       cursor - start);
+}
+
+static const struct file_operations fops_available_debug_modes = {
+	.read =		omap_available_debug_modes_show,
+};
+
+static struct dentry *debug_mode_f;
+
+static ssize_t omap_dbg_debug_mode_show(struct file *file, char __user *user_buf,
+					size_t count, loff_t *ppos)
+{
+	char buf[sizeof(dbg_modes_def[0].name) + 2];
+	unsigned buf_size;
+
+	buf_size = sprintf(buf, "%s\n", dbg_modes_def[current_dbg_mode].name);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, buf_size);
+}
+
+static ssize_t 
+omap_dbg_debug_mode_store(struct file *file, const char __user *user_buf,
+			  size_t count, loff_t *ppos)
+{
+	char buf[sizeof(dbg_modes_def[0].name) + 1];
+	int buf_size;
+	unsigned mode;
+
+	buf_size = min(count, sizeof(buf));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	buf[buf_size - 1] = '\0';
+
+	for (mode = 0; mode < OMAP2420_HW_DBG_MODES_NUM; mode++) {
+		if (strncmp(buf, dbg_modes_def[mode].name, buf_size) == 0) {
+			omap_set_dbg_mode(mode);
+			return count;
+		}
+	}
+
+	printk(KERN_ERR "HW Debug: Invalid mode\n");
+	return -EINVAL;
+
+}
+
+static const struct file_operations fops_debug_mode = {
+	.read =		omap_dbg_debug_mode_show,
+	.write =	omap_dbg_debug_mode_store,
+};
+
+
+
+int __init omap2_hw_debug_init(void)
+{
+	printk("HW Debug interface for TI OMAP.\n");
+
+	current_dbg_mode = OMAP2420_HW_DBG_MODE_CAMERA;
+
+	if (omap_dbg_gpio_init()) {
+		printk("Failed to initialise gpio.\n");
+		return -EINVAL;
+	}
+
+	observability_root = debugfs_create_dir("observability", NULL);
+
+	debug_mode_f = debugfs_create_file("debug_mode", 0644,
+					   observability_root, NULL,
+					   &fops_debug_mode);
+
+	available_debug_modes_f =
+		debugfs_create_file("available_debug_modes", 0644,
+				    observability_root, NULL,
+				    &fops_available_debug_modes);
+
+	return 0;
+}
+
+static void __exit omap2_hw_debug_exit(void)
+{
+	omap_set_dbg_mode(OMAP2420_HW_DBG_MODE_CAMERA);
+	debugfs_remove(debug_mode_f);
+	debugfs_remove(available_debug_modes_f);
+	debugfs_remove(observability_root);
+	omap_dbg_gpio_exit();
+}
+
+#ifndef MODULE
+late_initcall(omap2_hw_debug_init);
+#else
+module_init(omap2_hw_debug_init);
+module_exit(omap2_hw_debug_exit);
+
+MODULE_DESCRIPTION("OMAP2 HW Observability");
+MODULE_LICENSE("GPL");
+#endif
+
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/peeknpoke.c maemo_src/arch/arm/mach-omap2/peeknpoke.c
--- linux-omap-2.6/arch/arm/mach-omap2/peeknpoke.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/mach-omap2/peeknpoke.c	2007-10-02 03:09:30.000000000 -0400
@@ -0,0 +1,347 @@
+/*
+ * linux/arch/arm/mach-omap2/peeknpoke.c
+ *
+ * OMAP2 Debug Routines: memory peek 'n poke
+ *
+ * Copyright (C) 2007 Nokia Corporation
+ * Igor Stoppa <igor.stoppa@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License 
+ * version 2 as published by the Free Software Foundation. 
+ * 
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/pm.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/sysfs.h>
+#include <linux/module.h>
+#include <linux/debugfs.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/atomic.h>
+#include <asm/uaccess.h>
+#include <asm/mach/time.h>
+#include <asm/mach/irq.h>
+#include <asm/mach-types.h>
+
+#include <asm/arch/irqs.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/sram.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/pm.h>
+#include <asm/arch/gpio.h>
+
+static struct dentry *peeknpoke_root;
+static struct dentry *address32_f;
+static struct dentry *address16_f;
+static struct dentry *address8_f;
+static struct dentry *data32_f;
+static struct dentry *data16_f;
+static struct dentry *data8_f;
+
+/* Direct R/W access to phisical memory; 32, 16 an 8 bits */
+
+static u32 address32;
+
+static ssize_t omap_address32_show(struct file *file, char __user *user_buf,
+				size_t count, loff_t *ppos)
+{
+	char buf[12];
+
+	sprintf(buf, "0x%08X\n", address32);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, 12);
+}
+
+static ssize_t
+omap_address32_store(struct file *file, const char __user *user_buf,
+		  size_t count, loff_t *ppos)
+{
+        char buf[12];
+	int buf_size;
+	unsigned val;
+
+	buf_size = min(count, sizeof(buf));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	buf[buf_size - 1] = '\0';
+
+	if (sscanf(buf, "0x%08x", &val) != 1) {
+		printk(KERN_ERR "poke 32: Invalid data\n");
+		return -EINVAL;
+	}
+
+	address32 = val;
+
+	return count;
+}
+
+static const struct file_operations fops_address32 = {
+        .read =         omap_address32_show,
+	.write =        omap_address32_store,
+};
+
+
+static ssize_t omap_data32_show(struct file *file, char __user *user_buf,
+				size_t count, loff_t *ppos)
+{
+	char buf[12];
+
+	sprintf(buf, "0x%08X\n", omap_readl(address32));
+	return simple_read_from_buffer(user_buf, count, ppos, buf, 12);
+}
+
+static ssize_t
+omap_data32_store(struct file *file, const char __user *user_buf,
+		  size_t count, loff_t *ppos)
+{
+        char buf[12];
+	int buf_size;
+	unsigned val;
+
+	buf_size = min(count, sizeof(buf));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	buf[buf_size - 1] = '\0';
+
+	if (sscanf(buf, "0x%08x", &val) != 1) {
+		printk(KERN_ERR "poke 32: Invalid data\n");
+		return -EINVAL;
+	}
+
+	omap_writel((u32)val, address32);
+	return count;
+}
+
+static const struct file_operations fops_data32 = {
+        .read =         omap_data32_show,
+	.write =        omap_data32_store,
+};
+
+static u32 address16;
+
+static ssize_t omap_address16_show(struct file *file, char __user *user_buf,
+				size_t count, loff_t *ppos)
+{
+	char buf[12];
+
+	sprintf(buf, "0x%08X\n", address16);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, 12);
+}
+
+static ssize_t
+omap_address16_store(struct file *file, const char __user *user_buf,
+		  size_t count, loff_t *ppos)
+{
+        char buf[12];
+	int buf_size;
+	unsigned val;
+
+	buf_size = min(count, sizeof(buf));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	buf[buf_size - 1] = '\0';
+
+	if (sscanf(buf, "0x%08x", &val) != 1) {
+		printk(KERN_ERR "poke 16: Invalid data\n");
+		return -EINVAL;
+	}
+
+	address16 = val;
+
+	return count;
+}
+
+static const struct file_operations fops_address16 = {
+        .read =         omap_address16_show,
+	.write =        omap_address16_store,
+};
+
+
+static ssize_t omap_data16_show(struct file *file, char __user *user_buf,
+				size_t count, loff_t *ppos)
+{
+	char buf[8];
+
+	sprintf(buf, "0x%04X\n", omap_readw(address16));
+	return simple_read_from_buffer(user_buf, count, ppos, buf, 8);
+}
+
+static ssize_t
+omap_data16_store(struct file *file, const char __user *user_buf,
+		  size_t count, loff_t *ppos)
+{
+        char buf[8];
+	int buf_size;
+	unsigned val;
+
+	buf_size = min(count, sizeof(buf));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	buf[buf_size - 1] = '\0';
+
+	if (sscanf(buf, "0x%04x", &val) != 1) {
+		printk(KERN_ERR "poke 16: Invalid data\n");
+		return -EINVAL;
+	}
+
+	omap_writew((u16)val, address16);
+	return count;
+}
+
+static const struct file_operations fops_data16 = {
+        .read =         omap_data16_show,
+	.write =        omap_data16_store,
+};
+
+static u32 address8;
+
+static ssize_t omap_address8_show(struct file *file, char __user *user_buf,
+				size_t count, loff_t *ppos)
+{
+	char buf[12];
+
+	sprintf(buf, "0x%08X\n", address8);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, 12);
+}
+
+static ssize_t
+omap_address8_store(struct file *file, const char __user *user_buf,
+		  size_t count, loff_t *ppos)
+{
+        char buf[12];
+	int buf_size;
+	unsigned val;
+
+	buf_size = min(count, sizeof(buf));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	buf[buf_size - 1] = '\0';
+
+	if (sscanf(buf, "0x%08x", &val) != 1) {
+		printk(KERN_ERR "poke 8: Invalid data\n");
+		return -EINVAL;
+	}
+
+	address8 = val;
+
+	return count;
+}
+
+static const struct file_operations fops_address8 = {
+        .read =         omap_address8_show,
+	.write =        omap_address8_store,
+};
+
+
+static ssize_t omap_data8_show(struct file *file, char __user *user_buf,
+			       size_t count, loff_t *ppos)
+{
+	char buf[6];
+
+	sprintf(buf, "0x%02X\n", omap_readb(address8));
+	return simple_read_from_buffer(user_buf, count, ppos, buf, 6);
+}
+
+static ssize_t
+omap_data8_store(struct file *file, const char __user *user_buf,
+		 size_t count, loff_t *ppos)
+{
+        char buf[6];
+	int buf_size;
+	unsigned val;
+
+	buf_size = min(count, sizeof(buf));
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	buf[buf_size - 1] = '\0';
+
+	if (sscanf(buf, "0x%02x", &val) != 1) {
+		printk(KERN_ERR "poke 8: Invalid data\n");
+		return -EINVAL;
+	}
+
+	omap_writeb((u8)val, address8);
+	return count;
+}
+
+static const struct file_operations fops_data8 = {
+        .read =         omap_data8_show,
+	.write =        omap_data8_store,
+};
+
+static int __init omap2_peeknpoke_init(void)
+{
+	printk("Peek and Poke for TI OMAP.\n");
+
+	peeknpoke_root = debugfs_create_dir("peeknpoke", NULL);
+
+	address32  = address16 = address8 = 0x48008000;
+
+	address32_f = debugfs_create_file("address32", 0644, peeknpoke_root,
+					  NULL, &fops_address32);
+	data32_f    = debugfs_create_file("data32", 0644, peeknpoke_root, NULL,
+					  &fops_data32);
+
+	address16_f = debugfs_create_file("address16", 0644, peeknpoke_root,
+					  NULL, &fops_address16);
+	data16_f    = debugfs_create_file("data16", 0644, peeknpoke_root, NULL,
+					  &fops_data16);
+
+	address8_f = debugfs_create_file("address8", 0644, peeknpoke_root, NULL,
+					 &fops_address8);
+
+	data8_f     = debugfs_create_file("data8", 0644, peeknpoke_root, NULL,
+					  &fops_data8);
+
+	return 0;
+}
+
+static void __exit omap2_peeknpoke_exit(void)
+{
+	debugfs_remove(address32_f);
+	debugfs_remove(data32_f);
+
+	debugfs_remove(address16_f);
+	debugfs_remove(data16_f);
+
+	debugfs_remove(address8_f);
+	debugfs_remove(data8_f);
+
+	debugfs_remove(peeknpoke_root);
+}
+
+#ifndef MODULE
+late_initcall(omap2_peeknpoke_init);
+#else
+module_init(omap2_peeknpoke_init);
+module_exit(omap2_peeknpoke_exit);
+
+MODULE_DESCRIPTION("8/16/32 bit Memory Peek & Poke");
+MODULE_LICENSE("GPL");
+#endif
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/pm.c maemo_src/arch/arm/mach-omap2/pm.c
--- linux-omap-2.6/arch/arm/mach-omap2/pm.c	2011-02-06 20:17:25.229999939 -0500
+++ maemo_src/arch/arm/mach-omap2/pm.c	2011-02-06 20:12:09.723333274 -0500
@@ -160,6 +160,9 @@
         return omap_readl(0x48004010);
 }
 
+
+static struct clk *dss_ick;
+
 #ifdef CONFIG_PM_DEBUG
 int omap2_pm_debug = 0;
 
@@ -434,9 +437,12 @@
 	.store  = omap_pm_sleep_while_idle_store,
 };
 
+extern struct subsystem power_subsys;
+
 static struct clk *osc_ck, *emul_ck;
 
 #define CONTROL_DEVCONF		__REG32(0x48000274)
+#define CONTROL_SYSCONFIG	__REG32(0x48000010)
 #define SDRC_DLLA_CTRL		__REG32(0x68009060)
 
 static int omap2_fclks_active(void)
@@ -456,7 +462,7 @@
 	u32 pending_reg = IO_ADDRESS(0x480fe098);
 	int i;
 
-	for (i = 0; i < 4; i++) {
+	for (i = 0; i < 3; i++) {
 		if (__raw_readl(pending_reg))
 			return 1;
 		pending_reg += 0x20;
@@ -479,6 +485,9 @@
 	BUG_ON(i < 0);
 }
 
+EXPORT_SYMBOL(omap2_block_sleep);
+EXPORT_SYMBOL(omap2_allow_sleep);
+
 static void omap2_enter_full_retention(void)
 {
 	u32 sleep_time = 0;
@@ -531,7 +540,6 @@
 	omap2_gpio_resume_after_retention();
 
 	clk_enable(osc_ck);
-
 }
 
 static int omap2_i2c_active(void)
@@ -782,8 +790,10 @@
 	 * stabilisation */
 	prcm_write_reg(PRCM_CLKSSETUP, 15);
 
-	/* Configure automatic voltage transition */
-	prcm_write_reg(PRCM_VOLTSETUP, 2);
+	/* Configure automatic voltage transition
+	   Level 0 = Roof, Level 1 = Floor
+	 */
+	prcm_write_reg(PRCM_VOLTSETUP, 1);
 	l = AUTO_EXTVOLT | SETOFF_LEVEL(1) | MEMRETCTRL | \
 		SETRET_LEVEL(1) | VOLT_LEVEL(0);
 	prcm_write_reg(PRCM_VOLTCTRL, l);
@@ -800,6 +810,8 @@
 	l = prcm_read_reg(PRCM_REVISION);
 	printk(KERN_INFO "PRCM revision %d.%d\n", (l >> 4) & 0x0f, l & 0x0f);
 
+	dss_ick = clk_get(NULL, "dss_ick");
+
 	osc_ck = clk_get(NULL, "osc_ck");
 	if (IS_ERR(osc_ck)) {
 		printk(KERN_ERR "could not get osc_ck\n");
@@ -815,6 +827,9 @@
 
 	prcm_setup_regs();
 
+	/* Enable smart idle and autoidle */
+	CONTROL_SYSCONFIG |= (2 << 3) | (1 << 0);
+
 	pm_init_serial_console();
 
 	/* Hack to prevent MPU retention when STI console is enabled. */
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/prcm.c maemo_src/arch/arm/mach-omap2/prcm.c
--- linux-omap-2.6/arch/arm/mach-omap2/prcm.c	2011-02-06 19:44:42.576666606 -0500
+++ maemo_src/arch/arm/mach-omap2/prcm.c	2011-02-06 20:12:09.753333272 -0500
@@ -30,6 +30,14 @@
 /* Resets clock rates and reboots the system. Only called from system.h */
 void omap_prcm_arch_reset(char mode)
 {
+	struct clk *iclk, *fclk;
+
 	omap2_clk_prepare_for_reboot();
+
+	iclk = clk_get(NULL, "uart3_ick");
+	fclk = clk_get(NULL, "uart3_fck");
+	clk_enable(fclk);
+	clk_enable(iclk);
+
 	RM_RSTCTRL_WKUP |= 2;
 }
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/scale_freq.h maemo_src/arch/arm/mach-omap2/scale_freq.h
--- linux-omap-2.6/arch/arm/mach-omap2/scale_freq.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/mach-omap2/scale_freq.h	2011-02-06 20:12:09.806666606 -0500
@@ -0,0 +1,119 @@
+/*
+ * (C) Copyright 2005
+ * Texas Instruments, <www.ti.com>
+ *
+ * (C) Copyright 2007 Nokia Corporation
+ * Contact: Igor Stoppa <igor.stoppa@nokia.com>
+ * Selective frequency scaling
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __MACH_OMAP24XX_SCALE_H
+#define __MACH_OMAP24XX_SCALE_H
+
+/*Get the Base Address */
+#ifdef CONFIG_ARCH_OMAP24XX
+#include <asm/arch/omap24xx.h>
+#elif CONFIG_ARCH_OMAP243X
+#include <asm/arch/omap2430.h>
+#else
+#error "Unsupported configuration"
+#endif
+
+
+#define A_OMAP24XX_PRCM_BASE	IO_ADDRESS(OMAP24XX_PRCM_BASE)
+#define A_PRCM_CLKCFG_CTRL	IO_ADDRESS(OMAP24XX_PRCM_BASE + 0x80)
+#define PRCM_CLKCFG_CTRL_OFFS	(A_PRCM_CLKCFG_CTRL - A_OMAP24XX_PRCM_BASE)
+
+#define A_PRCM_VOLTCTRL		IO_ADDRESS(OMAP24XX_PRCM_BASE + 0x50)
+#define PRCM_VOLTCTRL_OFFS	(A_PRCM_VOLTCTRL - A_OMAP24XX_PRCM_BASE)
+#define		AUTO_EXTVOLT	(1 << 15)
+#define		FORCE_EXTVOLT	(1 << 14)
+#define		SETOFF_LEVEL(x)	(((x) & 0x3) << 12)
+#define		MEMRETCTRL	(1 << 8)
+#define		SETRET_LEVEL(x)	(((x) & 0x3) << 6)
+#define		VOLT_LEVEL(x)	(((x) & 0x3) << 0)
+
+#define A_PRCM_VOLTSETUP	IO_ADDRESS(OMAP24XX_PRCM_BASE + 0x090)
+#define PRCM_VOLTSETUP_OFFS	(A_PRCM_VOLTSETUP - A_OMAP24XX_PRCM_BASE)
+
+#define OMAP24XX_CM_BASE	(OMAP24XX_PRCM_BASE + 0x500)
+#define A_OMAP24XX_CM_BASE	IO_ADDRESS(OMAP24XX_CM_BASE)
+
+#define A_CM_CLKEN_PLL		IO_ADDRESS(OMAP24XX_CM_BASE + 0x00)
+#define CM_CLKEN_PLL_OFFS	(A_CM_CLKEN_PLL - A_OMAP24XX_CM_BASE)
+
+#define A_CM_IDLEST_CKGEN	IO_ADDRESS(OMAP24XX_CM_BASE + 0x20)
+#define CM_IDLEST_CKGEN_OFFS	(A_CM_IDLEST_CKGEN - A_OMAP24XX_CM_BASE)
+
+#define A_CM_CLKSEL1_PLL	IO_ADDRESS(OMAP24XX_CM_BASE + 0x40)
+#define CM_CLKSEL1_PLL_OFFS	(A_CM_CLKSEL1_PLL - A_OMAP24XX_CM_BASE)
+
+#define A_CM_CLKSEL2_PLL	IO_ADDRESS(OMAP24XX_CM_BASE + 0x44)
+#define CM_CLKSEL2_PLL_OFFS	(A_CM_CLKSEL2_PLL - A_OMAP24XX_CM_BASE)
+
+#define A_OMAP24XX_SDRC_BASE	IO_ADDRESS(OMAP24XX_SDRC_BASE)
+
+#define A_SDRC_DLLA_CTRL	IO_ADDRESS(OMAP24XX_SDRC_BASE + 0x60)
+#define SDRC_DLLA_CTRL_OFFS	(A_SDRC_DLLA_CTRL - A_OMAP24XX_SDRC_BASE)
+#define		SDRC_DLLx_CTRL_DELAY(x)	((((x)|0x03) & 0xff) << 8)
+#define 	SDRC_DLLx_CTRL_ENADLL	(1 << 3)
+#define 	SDRC_DLLx_CTRL_LOADDLL	(1 << 2)
+#define 	SDRC_DLLx_CTRL_DLLPHASE	(1 << 1)
+
+#define A_SDRC_DLLA_STATUS	IO_ADDRESS(OMAP24XX_SDRC_BASE + 0x64)
+#define SDRC_DLLA_STATUS_OFFS	(A_SDRC_DLLA_STATUS - A_OMAP24XX_SDRC_BASE)
+
+#define A_SDRC_DLLB_CTRL	IO_ADDRESS(OMAP24XX_SDRC_BASE + 0x68)
+#define SDRC_DLLB_CTRL_OFFS	(A_SDRC_DLLB_CTRL - A_OMAP24XX_SDRC_BASE)
+
+#define A_SDRC_RFR_CTRL0	IO_ADDRESS(OMAP24XX_SDRC_BASE + 0xA4)
+#define SDRC_RFR_CTRL0_OFFS	(A_SDRC_RFR_CTRL0 - A_OMAP24XX_SDRC_BASE)
+
+#define A_SDRC_RFR_CTRL1	IO_ADDRESS(OMAP24XX_SDRC_BASE + 0xD4)
+#define SDRC_RFR_CTRL1_OFFS	(A_SDRC_RFR_CTRL1 - A_OMAP24XX_SDRC_BASE)
+
+#define A_OMAP24XX_32KSYNCT_BASE IO_ADDRESS(OMAP24XX_32KSYNCT_BASE)
+
+#define A_32KSYNCT_CR		IO_ADDRESS(OMAP24XX_32KSYNCT_BASE + 0x10)
+#define _32KSYNCT_CR_OFFS	(A_32KSYNCT_CR - A_OMAP24XX_32KSYNCT_BASE)
+
+/*
+ * Parameters in omap24xx_scale_freq(): R0 (
+ */
+#define CM_CLKSEL1_PLL_MASK     0x00ffffff
+#define CM_CLKSEL1_PLL_SHIFT    3
+#define DPLL_SCALES_DOWN	0x80000000
+#define DOUBLER_SCALES_DOWN	0x40000000
+#define DOMAINS_SCALE_DOWN	0x20000000
+#define DPLL_SCALES_UP		0x10000000
+#define DOUBLER_SCALES_UP	0x08000000
+#define DOMAINS_SCALE_UP	0x04000000
+#define VOLTAGE_SCALE_UP	0x02000000
+#define VOLTAGE_SCALE_DOWN	0x01000000
+
+
+/*
+ * Parameters in omap24xx_scale_freq(): R1 (Refresh rate)
+ */
+#define SDRC_RFR_CTRL0_MASK	0x00ffffff
+#define L3_LESS_THAN_66M	0x80000000
+#define L3_HIGHER_THAN_133M	0x40000000
+
+#define QUICK_PRESCALER_x1	1
+#define QUICK_PRESCALER_x2	2
+
+#endif
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/scale_freq.S maemo_src/arch/arm/mach-omap2/scale_freq.S
--- linux-omap-2.6/arch/arm/mach-omap2/scale_freq.S	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/mach-omap2/scale_freq.S	2011-02-06 20:12:09.796666606 -0500
@@ -0,0 +1,264 @@
+/*
+ * (C) Copyright 2004
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <r-woodruff2@ti.com>
+ *
+ * (C) Copyright 2007 Nokia Corporation
+ * Contact: Igor Stoppa <igor.stoppa@nokia.com>
+ * Rewritten, adding selective scaling
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <asm/arch/io.h>
+#include <asm/arch/pm.h>
+#include "scale_freq.h"
+
+#define DPLL_RELOCK_LOOPS	1000
+#define VALIDATE_RELOCK_LOOPS	100
+#define DLL_RELOCK_LOOPS	0x800	/* min 0x400 L3 clocks */
+
+		.text
+
+/*
+ * omap24xx_scale_freq() - set dividers and pll in the safety of SRAM.
+ *  A positive side effect of this is the DLL value for DDR and unlock
+ *  mode will be recalculated.
+ *
+ *
+ *  Inputs: R0 = bit31: DPLL transition first pass
+ *		 bit30: Doubler inversion in first pass
+ *		 bit29: Verify and apply new scalings in first pass
+ *		 bit28: DPLL transition second pass
+ *		 bit27: Doubler inversion in second pass
+ *		 bit26: Verify and apply new scalings in second pass
+ *		 bit25: Voltage scales up
+ *		 bit24: Voltage scales down
+ *		 bit23-0: CM_CLKSEL1_PLL (the 8 highest bits are reserved)
+ *          R1 = sdram refresh timing (SRDC_RFR_CTRL_0)
+ * 		 bit31: L3_LESS_THAN_66M
+ *		 bit30: L3_HIGHER_THAN_133M
+ *
+ * First perform all the transitions that scale down the frequency.
+ *
+ * This one will be touchy.  We need to:
+ *      - irs's off on entry.
+ *      - do the icache block preload
+ *      - go to bypass
+ *      - wait till there
+ *      - validate the new dividers.
+ *      - set the new dpll values.
+ *      - if target mode is NOT bypass -
+ *          - set source back to dpll
+ *          - wait for a lock.
+ *      - dump in the new sdrc reg setting.
+ *      - unlock the dll so it adjusts.
+ *      - give it time to lock.
+ *      - head out.
+ */
+ENTRY(omap24xx_scale_freq)
+	stmfd	sp!, {r9-r12, lr}	@ regs to stack
+
+	ldr	r9,  sync32k_base	@ base for the 32ksynct offsets
+	ldr	r10, prcm_base		@ base for all the prcm offsets
+	ldr	r11, cm_base		@ base for all the cm offsets
+	ldr	r12, sdrc_base		@ base for all the sdrc offsets
+#if 0 // #ifndef CONFIG_CPU_ICACHE_DISABLE
+	mov	r2, #0
+	mcr	p15,0,r2,c7,c10,4	@ explicit memory barrier
+	adr	r2, pbegin		@ addr of preload start
+	adr	r3, pend		@ addr of preload end
+	mcrr	p15,1,r3,r2,c12		@ preload into icache.
+.L1:	mrc	p15,0,r2,c7,c12,4	@ wait for preload to finish
+	cmp	r2, #0
+	bne	.L1
+#endif
+pbegin:
+	/*
+	 * Update memory refresh timings
+	 */
+	and	r3, r1, #SDRC_RFR_CTRL0_MASK
+	str	r3, [r12, #SDRC_RFR_CTRL0_OFFS]	@ update refresh timing
+	str	r3, [r12, #SDRC_RFR_CTRL1_OFFS]	@ update refresh timing
+
+	/* scaling_sequence: */
+	tst	r0, #VOLTAGE_SCALE_UP		@ Voltage transition 1. pass
+	blne	handle_vmode
+
+	tst	r0, #DPLL_SCALES_DOWN		@ DPLL transition 1. pass
+	blne	handle_dpll
+
+	tst	r0, #DOUBLER_SCALES_DOWN	@ Doubler inversion in 1. pass
+	movne	r2, #QUICK_PRESCALER_x1
+	strne	r2, [r11, #CM_CLKSEL2_PLL_OFFS]	@ handle_quick_divisor
+
+	tst	r0, #DOMAINS_SCALE_DOWN		@ Verify and apply new scalings in 1. pass
+	blne	handle_divisors
+
+	tst	r0, #DPLL_SCALES_UP		@ DPLL transition 2. pass
+	blne	handle_dpll
+
+	tst	r0, #DOUBLER_SCALES_UP		@ Doubler inversion in 2. pass
+	movne	r2, #QUICK_PRESCALER_x2
+	strne	r2, [r11, #CM_CLKSEL2_PLL_OFFS]	@ handle_quick_divisor
+
+	tst	r0, #DOMAINS_SCALE_UP		@ Verify and apply new scalings in 2. pass
+	blne	handle_divisors
+
+	tst	r0, #VOLTAGE_SCALE_DOWN		@ Voltage transition 2. pass
+	blne	handle_vmode
+
+	bl	handle_dll
+
+	nop
+	ldmfd	sp!, {r9-r12, pc}		@ restore regs and return
+
+
+	/*
+	 * DPLL Divisor and Multiplier
+	 */
+handle_dpll:
+	/* Move into fast relock bypass by setting core_clk to ref_clk */
+	ldr	r3, [r11, #CM_CLKEN_PLL_OFFS]	@ get val
+	bic	r3, r3, #0x3			@ clear field EN_DPLL
+	orr	r3, r3, #0x2			@ fast relock val
+	str	r3, [r11, #CM_CLKEN_PLL_OFFS]	@ go to fast relock.
+
+.L3:	ldr	r2, [r11, #CM_IDLEST_CKGEN_OFFS]@ state value
+	and	r2, r2, #0x3			@ mask for stat ST_CORE_CLK
+	cmp	r2, #0x1			@ is core clock == ref clock?
+	bne	.L3				@ loop if not
+	/* core_clk is now set to ref_clk */
+
+	/* set new dpll dividers */
+	and	r2, r0, #CM_CLKSEL1_PLL_MASK	@ r0 contains the new cm_clksel1_pll
+	lsl	r2, r2, #CM_CLKSEL1_PLL_SHIFT
+	str	r2, [r11, #CM_CLKSEL1_PLL_OFFS]	@ set dpll ctrl val from r0
+
+	/* relock DPLL with new vals */
+	orr	r3, r3, #0x3			@ val for lock dpll
+	str	r3, [r11, #CM_CLKEN_PLL_OFFS]	@ set val
+
+	mov	r2, #DPLL_RELOCK_LOOPS		@ dead spin a bit
+.L4:	subs	r2, r2, #0x1			@ dec loop
+	bne	.L4				@ delay done?
+
+.L5:	ldr	r2, [r11, #CM_IDLEST_CKGEN_OFFS]@ state value
+	and	r2, r2, #0x3			@ mask for stat ST_CORE_CLK
+	cmp	r2, #0x2			@ core_clk == DPLL freq? locked
+	bne	.L5				@ wait if not
+
+	mov	pc, lr				@ return to sequencer
+
+
+	/*
+	 * Validation of clock divisors
+	 */
+handle_divisors:
+	mov	r2, #1				@ vaild cfg msk
+	str	r2, [r10, #PRCM_CLKCFG_CTRL_OFFS] @ activate dividers
+
+	mov	r2, #VALIDATE_RELOCK_LOOPS	@ dead spin a bit
+.L6:	subs	r2, r2, #1			@ dec loop
+	bne	.L6				@ delay done?
+
+	mov	pc, lr				@ return to sequencer
+
+
+	/*
+	 * Change the voltage to VROOF in Menelaus
+	 */
+handle_vmode:
+	ldr	r3, [r10, #PRCM_VOLTCTRL_OFFS]
+	orr	r3, r3, #VOLT_LEVEL(1)
+	str	r3, [r10, #PRCM_VOLTCTRL_OFFS]
+
+	/* Wait PRCM_VOLTSETUP 32KHz clock cycles.
+	 * Round up to next 32KHz cycle */
+	ldr	r2, [r9, #_32KSYNCT_CR_OFFS]
+	add	r2, #2
+	ldr	r3, [r10, #PRCM_VOLTSETUP_OFFS]
+	add	r3, r3, r2			@ calculate the absolute time to stop polling
+.L7:	ldr	r2, [r9, #_32KSYNCT_CR_OFFS]
+	cmp	r2, r3				@ did we reach terminal count yet?
+	bne	.L7				@ no - continue
+	mov	pc, lr				@ return to sequencer
+
+
+	/*
+	 * Calculate new dll delay, unlock the dll
+	 */
+handle_dll:
+/*
+   To setup the controlled delay block for un-lock mode (normal mode):
+    - Write into the SDRC_DLLx_CTRL register, with ENADLL set, LOADDLL
+      set, Delay field set to 0x77 to minimize the locking time.
+    - Write into the SDRC_DLLx_CTRL register, with LOADLL reset, to launch
+      the tracking process.
+    - Wait for at least 480 TC clock cycles to be sure the DLL is locked before
+      accessing the memory.
+    - Read DLL Count from SDRC_DLLx_STATUS register and write back to the CTRL
+      register.
+*/
+	tst	r1, #L3_HIGHER_THAN_133M	@ if L3 freq > 133MHz - 72  else 90 degree
+	mov	r3, #SDRC_DLLx_CTRL_ENADLL | SDRC_DLLx_CTRL_LOADDLL | 0x300	@ 0 = 72 degree
+	orreq	r3, r3, #SDRC_DLLx_CTRL_DLLPHASE @ 1 = 90 degree
+
+	tst	r1, #L3_LESS_THAN_66M
+	movne	r2, #0x7700
+	bne	no_locks
+
+	orr	r2, r3, #SDRC_DLLx_CTRL_DELAY(0x77)
+	str	r2, [r12, #SDRC_DLLA_CTRL_OFFS]	@ commit to DLLA_CTRL
+	nop
+	nop
+
+	/* Let the DLL lock */
+	bic	r2, r2, #SDRC_DLLx_CTRL_LOADDLL
+	str	r2, [r12, #SDRC_DLLA_CTRL_OFFS]	@ commit to DLLA_CTRL
+
+	/* Here wait for 480 TC cycles */
+	mov	r2, #DLL_RELOCK_LOOPS		@ relock time
+.L2:	subs	r2, r2, #0x1
+	bne	.L2
+
+	ldr	r2, [r12, #SDRC_DLLA_STATUS_OFFS]	@ get DLLA_CNT
+	and	r2, r2, #SDRC_DLLx_CTRL_DELAY(0xFF)
+
+no_locks:
+	orr	r2, r2, r3
+	str	r2, [r12, #SDRC_DLLA_CTRL_OFFS]	@ commit to DLLA_CTRL
+	str	r2, [r12, #SDRC_DLLB_CTRL_OFFS]	@ commit to DLLB_CTRL
+
+	nop
+	mov	pc, lr				@ return to sequencer
+pend:
+
+
+prcm_base:
+	.word A_OMAP24XX_PRCM_BASE
+cm_base:
+	.word A_OMAP24XX_CM_BASE
+sdrc_base:
+	.word A_OMAP24XX_SDRC_BASE
+sync32k_base:
+	.word A_OMAP24XX_32KSYNCT_BASE
+
+ENTRY(omap24xx_scale_freq_sz)
+	.word	. - omap24xx_scale_freq
+
+
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/serial.c maemo_src/arch/arm/mach-omap2/serial.c
--- linux-omap-2.6/arch/arm/mach-omap2/serial.c	2011-02-06 20:17:25.233333272 -0500
+++ maemo_src/arch/arm/mach-omap2/serial.c	2007-10-02 03:09:30.000000000 -0400
@@ -1,5 +1,5 @@
 /*
- * arch/arm/mach-omap2/serial.c
+ * arch/arm/mach-omap/omap2/serial.c
  *
  * OMAP2 serial support.
  *
@@ -14,82 +14,79 @@
  */
 #include <linux/kernel.h>
 #include <linux/init.h>
-#include <linux/serial_8250.h>
 #include <linux/serial_reg.h>
 #include <linux/clk.h>
+#include <linux/platform_device.h>
+#include <linux/ioport.h>
 
 #include <asm/io.h>
 
-#include <asm/arch/common.h>
+#include <asm/arch/serial.h>
 #include <asm/arch/board.h>
 
-static struct clk * uart1_ick = NULL;
-static struct clk * uart1_fck = NULL;
-static struct clk * uart2_ick = NULL;
-static struct clk * uart2_fck = NULL;
-static struct clk * uart3_ick = NULL;
-static struct clk * uart3_fck = NULL;
-
-static struct plat_serial8250_port serial_platform_data[] = {
+static struct resource omap2_uart1_resources[] = {
 	{
-		.membase	= (char *)IO_ADDRESS(OMAP_UART1_BASE),
-		.mapbase	= (unsigned long)OMAP_UART1_BASE,
-		.irq		= 72,
-		.flags		= UPF_BOOT_AUTOCONF,
-		.iotype		= UPIO_MEM,
-		.regshift	= 2,
-		.uartclk	= OMAP16XX_BASE_BAUD * 16,
+		.start		= OMAP_UART1_BASE,
+		.end		= OMAP_UART1_BASE + 0x3ff,
+		.flags		= IORESOURCE_MEM,
 	}, {
-		.membase	= (char *)IO_ADDRESS(OMAP_UART2_BASE),
-		.mapbase	= (unsigned long)OMAP_UART2_BASE,
-		.irq		= 73,
-		.flags		= UPF_BOOT_AUTOCONF,
-		.iotype		= UPIO_MEM,
-		.regshift	= 2,
-		.uartclk	= OMAP16XX_BASE_BAUD * 16,
+		.start		= 72,
+		.flags		= IORESOURCE_IRQ,
+	}
+};
+
+static struct resource omap2_uart2_resources[] = {
+	{
+		.start		= OMAP_UART2_BASE,
+		.end		= OMAP_UART2_BASE + 0x3ff,
+		.flags		= IORESOURCE_MEM,
 	}, {
-		.membase	= (char *)IO_ADDRESS(OMAP_UART3_BASE),
-		.mapbase	= (unsigned long)OMAP_UART3_BASE,
-		.irq		= 74,
-		.flags		= UPF_BOOT_AUTOCONF,
-		.iotype		= UPIO_MEM,
-		.regshift	= 2,
-		.uartclk	= OMAP16XX_BASE_BAUD * 16,
+		.start		= 73,
+		.flags		= IORESOURCE_IRQ,
+	}
+};
+
+static struct resource omap2_uart3_resources[] = {
+	{
+		.start		= OMAP_UART3_BASE,
+		.end		= OMAP_UART3_BASE + 0x3ff,
+		.flags		= IORESOURCE_MEM,
 	}, {
-		.flags		= 0
+		.start		= 74,
+		.flags		= IORESOURCE_IRQ,
 	}
 };
 
-static inline unsigned int serial_read_reg(struct plat_serial8250_port *up,
-					   int offset)
-{
-	offset <<= up->regshift;
-	return (unsigned int)__raw_readb(up->membase + offset);
-}
+static struct platform_device uart1_device = {
+	.name			= "omap-uart",
+	.id			= 1,
+	.num_resources		= ARRAY_SIZE(omap2_uart1_resources),
+	.resource		= omap2_uart1_resources,
+};
 
-static inline void serial_write_reg(struct plat_serial8250_port *p, int offset,
-				    int value)
-{
-	offset <<= p->regshift;
-	__raw_writeb(value, (unsigned long)(p->membase + offset));
-}
+static struct platform_device uart2_device = {
+	.name			= "omap-uart",
+	.id			= 2,
+	.num_resources		= ARRAY_SIZE(omap2_uart2_resources),
+	.resource		= omap2_uart2_resources,
+};
 
-/*
- * Internal UARTs need to be initialized for the 8250 autoconfig to work
- * properly. Note that the TX watermark initialization may not be needed
- * once the 8250.c watermark handling code is merged.
- */
-static inline void __init omap_serial_reset(struct plat_serial8250_port *p)
-{
-	serial_write_reg(p, UART_OMAP_MDR1, 0x07);
-	serial_write_reg(p, UART_OMAP_SCR, 0x08);
-	serial_write_reg(p, UART_OMAP_MDR1, 0x00);
-	serial_write_reg(p, UART_OMAP_SYSC, (0x02 << 3) | (1 << 2) | (1 << 0));
-}
+static struct platform_device uart3_device = {
+	.name			= "omap-uart",
+	.id			= 3,
+	.num_resources		= ARRAY_SIZE(omap2_uart3_resources),
+	.resource		= omap2_uart3_resources,
+};
 
-void __init omap_serial_init()
+static struct platform_device *uart_devices[] = {
+	&uart1_device,
+	&uart2_device,
+	&uart3_device
+};
+
+void __init omap_serial_init(void)
 {
-	int i;
+	int i, r;
 	const struct omap_uart_config *info;
 
 	/*
@@ -100,19 +97,18 @@
 
 	info = omap_get_config(OMAP_TAG_UART,
 			       struct omap_uart_config);
-
 	if (info == NULL)
 		return;
 
-	for (i = 0; i < OMAP_MAX_NR_PORTS; i++) {
-		struct plat_serial8250_port *p = serial_platform_data + i;
-
-		if (!(info->enabled_uarts & (1 << i))) {
-			p->membase = 0;
-			p->mapbase = 0;
+	for (i = 0; i < ARRAY_SIZE(uart_devices); i++) {
+		if (!(info->enabled_uarts & (1 << i)))
 			continue;
-		}
+		r = platform_device_register(uart_devices[i]);
+		if (r < 0)
+			printk("Failed to register UART%d\n", i + 1);
+	}
 
+#if 0
 		switch (i) {
 		case 0:
 			uart1_ick = clk_get(NULL, "uart1_ick");
@@ -161,20 +157,6 @@
 			break;
 		}
 
-		omap_serial_reset(p);
-	}
-}
-
-static struct platform_device serial_device = {
-	.name			= "serial8250",
-	.id			= PLAT8250_DEV_PLATFORM,
-	.dev			= {
-		.platform_data	= serial_platform_data,
-	},
-};
-
-static int __init omap_init(void)
-{
-	return platform_device_register(&serial_device);
+//		omap_serial_reset(p);
+#endif
 }
-arch_initcall(omap_init);
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/sleep.S maemo_src/arch/arm/mach-omap2/sleep.S
--- linux-omap-2.6/arch/arm/mach-omap2/sleep.S	2011-02-06 20:17:25.233333272 -0500
+++ maemo_src/arch/arm/mach-omap2/sleep.S	2007-10-02 03:09:30.000000000 -0400
@@ -44,14 +44,14 @@
  * omap24xx_idle_loop_suspend() - This bit of code just executes the WFI
  * for normal idles.
  *
- * Note: This code get's copied to internal SRAM at boot. When the OMAP
+ * Note: This code gets copied to internal SRAM at boot. When the OMAP
  *	 wakes up it continues execution at the point it went to sleep.
  */
 ENTRY(omap24xx_idle_loop_suspend)
-	stmfd	sp!, {r0, lr}		@ save registers on stack
+	stmfd	sp!, {lr}		@ save registers on stack
 	mov	r0, #0x0		@ clear for mrc call
 	mcr	p15, 0, r0, c7, c0, 4	@ wait for interrupt
-	ldmfd	sp!, {r0, pc}		@ restore regs and return
+	ldmfd	sp!, {pc}		@ restore regs and return
 
 ENTRY(omap24xx_idle_loop_suspend_sz)
 	.word	. - omap24xx_idle_loop_suspend
@@ -81,7 +81,7 @@
  * at wake
  */
 ENTRY(omap24xx_cpu_suspend)
-	stmfd	sp!, {r0 - r12, lr}	@ save registers on stack
+	stmfd	sp!, {r4 - r12, lr}	@ save registers on stack
 	mov	r3, #0x0		@ clear for mrc call
 	mcr	p15, 0, r3, c7, c10, 4	@ memory barrier, hope SDR/DDR finished
 	nop
@@ -116,7 +116,7 @@
 	subs	r5, r5, #0x1
 	bne	loop2
 	/* resume*/
-	ldmfd	sp!, {r0 - r12, pc}	@ restore regs and return
+	ldmfd	sp!, {r4 - r12, pc}	@ restore regs and return
 
 A_SDRC_POWER:
 	.word A_SDRC_POWER_V
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/snapshot.c maemo_src/arch/arm/mach-omap2/snapshot.c
--- linux-omap-2.6/arch/arm/mach-omap2/snapshot.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/mach-omap2/snapshot.c	2007-10-02 03:09:30.000000000 -0400
@@ -0,0 +1,213 @@
+/*
+ * linux/arch/arm/mach-omap2/snapshot.c
+ *
+ * OMAP2 Debug Snapshot
+ *
+ * Copyright (C) 2006 Nokia Corporation
+ * Igor Stoppa <igor.stoppa@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/pm.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/pm.h>
+#include <linux/interrupt.h>
+#include <linux/sysfs.h>
+#include <linux/module.h>
+#include <linux/debugfs.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/atomic.h>
+#include <asm/uaccess.h>
+#include <asm/mach/time.h>
+#include <asm/mach/irq.h>
+#include <asm/mach-types.h>
+
+#include <asm/arch/irqs.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/sram.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/pm.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/sram.h>
+
+#include <asm/arch/snapshot.h>
+
+/* Accepts a set of phisical memory locations and takes a snapshot of
+ * their values, then returns them */
+
+static struct dentry *snapshot_root;
+static struct dentry *snapshot_f;
+static struct dentry *take_snapshot_f;
+
+/* The code and address / value pairs are stored in SRAM to allow
+ * triggering the snapshot even when executing from SRAM */
+
+static snapshot_t *omap_snapshot;
+
+static unsigned *omap_index = NULL;
+
+static void omap_snap_shot(void)
+{
+	unsigned i;
+	static unsigned *local_index = NULL;
+	static snapshot_t *local_snapshot = NULL;
+	if (local_index == NULL) {
+		local_index = omap_index;
+		local_snapshot = omap_snapshot;
+	}
+	else {
+		for (i = 0; i < *local_index; i++)
+			local_snapshot[i][1] = omap_readl(local_snapshot[i][0]);
+	}
+}
+
+void (*omap_snap_shot_ptr)(void);
+EXPORT_SYMBOL(omap_snap_shot_ptr);
+
+int omap_snapshot_pop_data(snapshot_t *read)
+{
+	if ((*omap_index) != 0) {
+		(*omap_index)--;
+
+		(*read)[0] = omap_snapshot[*omap_index][0];
+		(*read)[1] = omap_snapshot[*omap_index][1];
+
+		omap_snapshot[*omap_index][0] = 0;
+		omap_snapshot[*omap_index][1] = 0;
+
+		return 1;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(omap_snapshot_pop_data);
+
+static struct dentry *snapshot_f;
+
+static ssize_t omap_snapshot_show(struct file *file, char __user *user_buf,
+				  size_t count, loff_t *ppos)
+{
+	char buf[23]; /* "0xaaaaaaaa 0xdddddddd\n" */
+	snapshot_t read;
+	int ret = 0;
+	static int i = 0;
+
+/*This is a temporary workaround: the show method is modeled after the bool
+ * handling code in fs/debugfs/file.c, which is broken; for some reason this
+ * method is called twice and only the first time the buffer is shown.
+ * Generally it is not harmful but if the showing actually affects the internal
+ * status, like doing a pop ... only one entry every 2 is shown :-P */
+	if (i) {
+		i = 0;
+		return 0;
+	}
+	i++;
+	if (omap_snapshot_pop_data(&read))
+		ret = sprintf(buf, "0x%08x 0x%08x\n", read[0], read[1]);
+
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, ret);
+}
+
+
+void omap_snapshot_push_address(u32 address)
+{
+	if (*omap_index == (OMAP_SNAPSHOT_SIZE - 2)) {
+		printk(KERN_ERR "List full\n");
+		return;
+	}
+	omap_snapshot[*omap_index][0] = address;
+	(*omap_index)++;
+	omap_snapshot[*omap_index][0] = omap_snapshot[*omap_index][1] = 0;
+}
+EXPORT_SYMBOL(omap_snapshot_push_address);
+
+static ssize_t
+omap_snapshot_store(struct file *file, const char __user *user_buf,
+		   size_t count, loff_t *ppos)
+{
+	char buf[12];
+	int buf_size;
+	unsigned address;
+
+	buf_size = min(count, (sizeof(buf)-1));
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+
+	if (sscanf(buf, "0x%08X", &address) != 1) {
+		printk(KERN_ERR "Invalid address\n");
+		return -EINVAL;
+	}
+
+	omap_snapshot_push_address(address);
+
+	return count;
+}
+
+static const struct file_operations fops_snapshot = {
+	.read =		omap_snapshot_show,
+	.write =	omap_snapshot_store,
+};
+
+static ssize_t
+omap_take_snapshot_store(struct file *file, const char __user *user_buf,
+			 size_t count, loff_t *ppos)
+{
+	(*omap_snap_shot_ptr)();
+	return count;
+}
+
+static const struct file_operations fops_take_snapshot = {
+	.write =	omap_take_snapshot_store,
+};
+
+int __init omap2_snapshot_init(void)
+{
+	snapshot_t dummy_snapshot[OMAP_SNAPSHOT_SIZE] = {{0, 0}, };
+	unsigned dummy_index = 0;
+
+	printk("HW Debug interface for TI OMAP.\n");
+
+#ifdef MODULE
+/*unsafe to remove because it allocates sram and it's not possible to free it*/
+	__unsafe(THIS_MODULE);
+#endif
+	omap_index = omap_sram_push(&dummy_index, sizeof(dummy_index));
+	omap_snapshot = omap_sram_push(dummy_snapshot, sizeof(dummy_snapshot));
+	omap_snap_shot_ptr = omap_sram_push(omap_snap_shot, 1024);
+	(*omap_snap_shot_ptr)();
+
+	snapshot_root = debugfs_create_dir("snapshot", NULL);
+	snapshot_f = debugfs_create_file("snapshot", 0644, snapshot_root,
+					   NULL, &fops_snapshot);
+
+	take_snapshot_f =
+		debugfs_create_file("take_snapshot", 0644, snapshot_root,
+				    NULL, &fops_take_snapshot);
+
+	return 0;
+}
+
+#ifndef MODULE
+late_initcall(omap2_snapshot_init);
+#else
+module_init(omap2_snapshot_init);
+MODULE_DESCRIPTION("Takes a snapshot of the values of memory locations");
+MODULE_LICENSE("GPL");
+#endif
diff -ruN linux-omap-2.6/arch/arm/mach-omap2/usb-tusb6010.c maemo_src/arch/arm/mach-omap2/usb-tusb6010.c
--- linux-omap-2.6/arch/arm/mach-omap2/usb-tusb6010.c	2011-02-06 20:17:25.233333272 -0500
+++ maemo_src/arch/arm/mach-omap2/usb-tusb6010.c	2011-02-06 20:12:09.756666606 -0500
@@ -19,11 +19,9 @@
 #include <asm/arch/gpio.h>
 #include <asm/arch/mux.h>
 
-
 static u8		async_cs, sync_cs;
 static unsigned		refclk_psec;
 
-
 /* t2_ps, when quantized to fclk units, must happen no earlier than
  * the clock after after t1_NS.
  *
diff -ruN linux-omap-2.6/arch/arm/mm/abort-ev6.S maemo_src/arch/arm/mm/abort-ev6.S
--- linux-omap-2.6/arch/arm/mm/abort-ev6.S	2011-02-06 19:44:42.646666607 -0500
+++ maemo_src/arch/arm/mm/abort-ev6.S	2011-02-06 20:12:09.866666606 -0500
@@ -23,6 +23,7 @@
 #ifdef CONFIG_CPU_32v6K
 	clrex
 #else
+	ldr	r1, [sp]			@ Load r1 in case strex succeeds
 	strex	r0, r1, [sp]			@ Clear the exclusive monitor
 #endif
 	mrc	p15, 0, r1, c5, c0, 0		@ get FSR
diff -ruN linux-omap-2.6/arch/arm/mm/cache-v6.S maemo_src/arch/arm/mm/cache-v6.S
--- linux-omap-2.6/arch/arm/mm/cache-v6.S	2011-02-06 19:44:42.649999940 -0500
+++ maemo_src/arch/arm/mm/cache-v6.S	2011-02-06 20:12:09.869999940 -0500
@@ -20,6 +20,39 @@
 #define D_CACHE_LINE_SIZE	32
 #define BTB_FLUSH_SIZE		8
 
+#ifndef CONFIG_SMP
+/*
+ * Invalidate the entire I cache (this code is a workaround for the ARM1136
+ * Errata 411920 - Invalidate Instruction Cache operation can fail. This
+ * Errata is present in 1136, 1156 and 1176. It does not affect the MPCore
+ *
+ * Registers:
+ *   r0 - set to 0
+ *   r1 - corrupted
+ */
+ENTRY(v6_icache_inval_all)
+	mov	r0, #0
+	mrs	r1, cpsr
+	cpsid	ifa				@ disable interrupts
+	mcr	p15, 0, r0, c7, c5, 0		@ invalidate entire I-cache
+	mcr	p15, 0, r0, c7, c5, 0		@ invalidate entire I-cache
+	mcr	p15, 0, r0, c7, c5, 0		@ invalidate entire I-cache
+	mcr	p15, 0, r0, c7, c5, 0		@ invalidate entire I-cache
+	msr	cpsr_cx, r1			@ restore interrupts
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	nop
+	mov	pc, lr
+#endif
+
 /*
  *	v6_flush_cache_all()
  *
@@ -31,8 +64,12 @@
 	mov	r0, #0
 #ifdef HARVARD_CACHE
 	mcr	p15, 0, r0, c7, c14, 0		@ D cache clean+invalidate
+#ifdef CONFIG_SMP
 	mcr	p15, 0, r0, c7, c5, 0		@ I+BTB cache invalidate
 #else
+	b	v6_icache_inval_all
+#endif
+#else
 	mcr	p15, 0, r0, c7, c15, 0		@ Cache clean+invalidate
 #endif
 	mov	pc, lr
@@ -103,8 +140,12 @@
 	mov	r0, #0
 #ifdef HARVARD_CACHE
 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
+#ifdef CONFIG_SMP
 	mcr	p15, 0, r0, c7, c5, 0		@ I+BTB cache invalidate
 #else
+	b	v6_icache_inval_all
+#endif
+#else
 	mcr	p15, 0, r0, c7, c5, 6		@ invalidate BTB
 #endif
 	mov	pc, lr
diff -ruN linux-omap-2.6/arch/arm/mm/flush.c maemo_src/arch/arm/mm/flush.c
--- linux-omap-2.6/arch/arm/mm/flush.c	2011-02-06 19:44:42.656666606 -0500
+++ maemo_src/arch/arm/mm/flush.c	2011-02-06 20:12:09.866666606 -0500
@@ -31,10 +31,14 @@
 
 	asm(	"mcrr	p15, 0, %1, %0, c14\n"
 	"	mcr	p15, 0, %2, c7, c10, 4\n"
+#if __LINUX_ARM_ARCH__ != 6 || defined(CONFIG_SMP)
 	"	mcr	p15, 0, %2, c7, c5, 0\n"
+#else
+	"	bl	v6_icache_inval_all\n"
+#endif
 	    :
 	    : "r" (to), "r" (to + PAGE_SIZE - L1_CACHE_BYTES), "r" (zero)
-	    : "cc");
+	    : "r0", "r1", "lr");
 }
 
 void flush_cache_mm(struct mm_struct *mm)
@@ -47,11 +51,15 @@
 
 	if (cache_is_vipt_aliasing()) {
 		asm(	"mcr	p15, 0, %0, c7, c14, 0\n"
+		"	mcr	p15, 0, %0, c7, c10, 4\n"
+#if __LINUX_ARM_ARCH__ != 6 || defined(CONFIG_SMP)
 		"	mcr	p15, 0, %0, c7, c5, 0\n"
-		"	mcr	p15, 0, %0, c7, c10, 4"
+#else
+		"	bl	v6_icache_inval_all\n"
+#endif
 		    :
 		    : "r" (0)
-		    : "cc");
+		    : "r0", "r1", "lr", "cc");
 	}
 }
 
@@ -66,11 +74,15 @@
 
 	if (cache_is_vipt_aliasing()) {
 		asm(	"mcr	p15, 0, %0, c7, c14, 0\n"
+		"	mcr	p15, 0, %0, c7, c10, 4\n"
+#if __LINUX_ARM_ARCH__ != 6 || defined(CONFIG_SMP)
 		"	mcr	p15, 0, %0, c7, c5, 0\n"
-		"	mcr	p15, 0, %0, c7, c10, 4"
+#else
+		"	bl	v6_icache_inval_all\n"
+#endif
 		    :
 		    : "r" (0)
-		    : "cc");
+		    : "r0", "r1", "lr", "cc");
 	}
 }
 
diff -ruN linux-omap-2.6/arch/arm/mm/proc-v6.S maemo_src/arch/arm/mm/proc-v6.S
--- linux-omap-2.6/arch/arm/mm/proc-v6.S	2011-02-06 19:44:42.673333274 -0500
+++ maemo_src/arch/arm/mm/proc-v6.S	2011-02-06 20:12:09.869999940 -0500
@@ -128,6 +128,14 @@
  *	  110x   0   1   0	r/w	r/o
  *	  11x0   0   1   0	r/w	r/o
  *	  1111   0   1   1	r/w	r/w
+ *
+ *	Extended PTE mapping encoding (L_PTE_EXTENDED=1):
+ *	ECB
+ *	0xx - standard C and B encoding
+ *	101 - inner WB, outer WB, write-allocate
+ *	110 - inner WB, outer WT
+ *	100 - inner WB, outer non-cacheable, non-bufferable
+ *	111 - non-shared device (accesses go thru peripheral bus)
  */
 ENTRY(cpu_v6_set_pte_ext)
 #ifdef CONFIG_MMU
@@ -138,6 +146,24 @@
 	orr	r3, r3, r2
 	orr	r3, r3, #PTE_EXT_AP0 | 2
 
+	tst	r1, #L_PTE_EXTENDED
+	beq	1f
+	/* If CB = 11, set PTE to non-shared device */
+	tst	r1, #L_PTE_CACHEABLE
+	tstne	r1, #L_PTE_BUFFERABLE
+	orrne	r3, r3, #PTE_EXT_TEX(2)
+	bicne	r3, r3, #L_PTE_CACHEABLE | L_PTE_BUFFERABLE
+	bne	1f
+
+	/* Set outer cache according to C and B bits */
+	orr	r3, r3, #PTE_EXT_TEX(4)
+	tst	r1, #L_PTE_CACHEABLE
+	orrne	r3, r3, #PTE_EXT_TEX(2)
+	tst	r1, #L_PTE_BUFFERABLE
+	orrne	r3, r3, #PTE_EXT_TEX(1)
+	/* Set inner cache to writeback */
+	orr	r3, r3, #PTE_BUFFERABLE | PTE_CACHEABLE
+1:
 	tst	r1, #L_PTE_WRITE
 	tstne	r1, #L_PTE_DIRTY
 	orreq	r3, r3, #PTE_EXT_APX
@@ -218,6 +244,22 @@
 	mrc	p15, 0, r0, c1, c0, 0		@ read control register
 	bic	r0, r0, r5			@ clear bits them
 	orr	r0, r0, r6			@ set them
+
+	/* Workaround for the 364296 ARM1136 r0pX errata (possible cache data
+	 * corruption with hit-under-miss enabled). The conditional code below
+	 * (setting the undocumented bit 31 in the auxiliary control register
+	 * and the FI bit in the control register) disables hit-under-miss
+	 * without putting the processor into full low interrupt latency mode.
+	 */
+	ldr	r6, =0x4107b360			@ id for ARM1136 r0pX
+	mrc	p15, 0, r5, c0, c0, 0		@ get processor id
+	bic	r5, r5, #0xf			@ mask out part bits [3:0]
+	teq	r5, r6				@ check for the faulty core
+	mrceq	p15, 0, r5, c1, c0, 1		@ load aux control reg
+	orreq	r5, r5, #(1 << 31)		@ set the undocumented bit 31
+	mcreq	p15, 0, r5, c1, c0, 1		@ write aux control reg
+	orreq	r0, r0, #(1 << 21)		@ low interrupt latency configuration
+
 	mov	pc, lr				@ return to head.S:__ret
 
 	/*
diff -ruN linux-omap-2.6/arch/arm/plat-omap/clock.c maemo_src/arch/arm/plat-omap/clock.c
--- linux-omap-2.6/arch/arm/plat-omap/clock.c	2011-02-06 20:17:25.289999939 -0500
+++ maemo_src/arch/arm/plat-omap/clock.c	2007-10-02 03:09:30.000000000 -0400
@@ -135,9 +135,17 @@
 		return;
 
 	spin_lock_irqsave(&clockfw_lock, flags);
-	BUG_ON(clk->usecount == 0);
+	if (clk->usecount == 0) {
+		printk(KERN_ERR "Trying disable clock %s with 0 usecount\n",
+		       clk->name);
+		WARN_ON(1);
+		goto out;
+	}
+
 	if (arch_clock->clk_disable)
 		arch_clock->clk_disable(clk);
+
+out:
 	spin_unlock_irqrestore(&clockfw_lock, flags);
 }
 EXPORT_SYMBOL(clk_disable);
diff -ruN linux-omap-2.6/arch/arm/plat-omap/common.c maemo_src/arch/arm/plat-omap/common.c
--- linux-omap-2.6/arch/arm/plat-omap/common.c	2011-02-06 20:17:25.289999939 -0500
+++ maemo_src/arch/arm/plat-omap/common.c	2007-10-02 03:09:30.000000000 -0400
@@ -34,7 +34,7 @@
 
 #define NO_LENGTH_CHECK 0xffffffff
 
-unsigned char omap_bootloader_tag[512];
+unsigned char omap_bootloader_tag[1024];
 int omap_bootloader_tag_len;
 
 struct omap_board_config_kernel *omap_board_config;
diff -ruN linux-omap-2.6/arch/arm/plat-omap/cpu-omap.c maemo_src/arch/arm/plat-omap/cpu-omap.c
--- linux-omap-2.6/arch/arm/plat-omap/cpu-omap.c	2011-02-06 19:44:42.699999940 -0500
+++ maemo_src/arch/arm/plat-omap/cpu-omap.c	2007-10-02 03:09:30.000000000 -0400
@@ -33,43 +33,33 @@
 #define MPU_CLK		"virt_prcm_set"
 #endif
 
+static struct clk *mpu_clk;
+
 /* TODO: Add support for SDRAM timing changes */
 
 int omap_verify_speed(struct cpufreq_policy *policy)
 {
-	struct clk * mpu_clk;
-
 	if (policy->cpu)
 		return -EINVAL;
 
 	cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,
 				     policy->cpuinfo.max_freq);
-	mpu_clk = clk_get(NULL, MPU_CLK);
-	if (IS_ERR(mpu_clk))
-		return PTR_ERR(mpu_clk);
+
 	policy->min = clk_round_rate(mpu_clk, policy->min * 1000) / 1000;
 	policy->max = clk_round_rate(mpu_clk, policy->max * 1000) / 1000;
 	cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,
 				     policy->cpuinfo.max_freq);
-	clk_put(mpu_clk);
-
 	return 0;
 }
 
 unsigned int omap_getspeed(unsigned int cpu)
 {
-	struct clk * mpu_clk;
 	unsigned long rate;
 
 	if (cpu)
 		return 0;
 
-	mpu_clk = clk_get(NULL, MPU_CLK);
-	if (IS_ERR(mpu_clk))
-		return 0;
 	rate = clk_get_rate(mpu_clk) / 1000;
-	clk_put(mpu_clk);
-
 	return rate;
 }
 
@@ -77,14 +67,9 @@
 		       unsigned int target_freq,
 		       unsigned int relation)
 {
-	struct clk * mpu_clk;
 	struct cpufreq_freqs freqs;
 	int ret = 0;
 
-	mpu_clk = clk_get(NULL, MPU_CLK);
-	if (IS_ERR(mpu_clk))
-		return PTR_ERR(mpu_clk);
-
 	freqs.old = omap_getspeed(0);
 	freqs.new = clk_round_rate(mpu_clk, target_freq * 1000) / 1000;
 	freqs.cpu = 0;
@@ -92,15 +77,12 @@
 	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
 	ret = clk_set_rate(mpu_clk, target_freq * 1000);
 	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
-	clk_put(mpu_clk);
 
 	return ret;
 }
 
 static int __init omap_cpu_init(struct cpufreq_policy *policy)
 {
-	struct clk * mpu_clk;
-
 	mpu_clk = clk_get(NULL, MPU_CLK);
 	if (IS_ERR(mpu_clk))
 		return PTR_ERR(mpu_clk);
@@ -112,17 +94,23 @@
 	policy->cpuinfo.min_freq = clk_round_rate(mpu_clk, 0) / 1000;
 	policy->cpuinfo.max_freq = clk_round_rate(mpu_clk, VERY_HI_RATE) / 1000;
 	policy->cpuinfo.transition_latency = CPUFREQ_ETERNAL;
-	clk_put(mpu_clk);
 
 	return 0;
 }
 
+static int omap_cpu_exit(struct cpufreq_policy *policy)
+{
+	clk_put(mpu_clk);
+	return 0;
+}
+
 static struct cpufreq_driver omap_driver = {
 	.flags		= CPUFREQ_STICKY,
 	.verify		= omap_verify_speed,
 	.target		= omap_target,
 	.get		= omap_getspeed,
 	.init		= omap_cpu_init,
+	.exit		= omap_cpu_exit,
 	.name		= "omap",
 };
 
diff -ruN linux-omap-2.6/arch/arm/plat-omap/devices.c maemo_src/arch/arm/plat-omap/devices.c
--- linux-omap-2.6/arch/arm/plat-omap/devices.c	2011-02-06 20:17:25.293333273 -0500
+++ maemo_src/arch/arm/plat-omap/devices.c	2007-10-02 03:09:30.000000000 -0400
@@ -21,6 +21,7 @@
 
 #include <asm/arch/tc.h>
 #include <asm/arch/board.h>
+#include <asm/arch/mmc.h>
 #include <asm/arch/mux.h>
 #include <asm/arch/gpio.h>
 #include <asm/arch/menelaus.h>
@@ -231,7 +232,7 @@
 #endif
 #define	OMAP_MMC2_BASE		0xfffb7c00	/* omap16xx only */
 
-static struct omap_mmc_conf mmc1_conf;
+static struct omap_mmc_platform_data mmc1_data;
 
 static u64 mmc1_dmamask = 0xffffffff;
 
@@ -252,7 +253,7 @@
 	.id		= 1,
 	.dev = {
 		.dma_mask	= &mmc1_dmamask,
-		.platform_data	= &mmc1_conf,
+		.platform_data	= &mmc1_data,
 	},
 	.num_resources	= ARRAY_SIZE(mmc1_resources),
 	.resource	= mmc1_resources,
@@ -260,7 +261,7 @@
 
 #ifdef	CONFIG_ARCH_OMAP16XX
 
-static struct omap_mmc_conf mmc2_conf;
+static struct omap_mmc_platform_data mmc2_data;
 
 static u64 mmc2_dmamask = 0xffffffff;
 
@@ -282,7 +283,7 @@
 	.id		= 2,
 	.dev = {
 		.dma_mask	= &mmc2_dmamask,
-		.platform_data	= &mmc2_conf,
+		.platform_data	= &mmc2_data,
 	},
 	.num_resources	= ARRAY_SIZE(mmc2_resources),
 	.resource	= mmc2_resources,
@@ -339,7 +340,7 @@
 				omap_cfg_reg(MMC_DAT3);
 			}
 		}
-		mmc1_conf = *mmc;
+		mmc1_data.conf = *mmc;
 		(void) platform_device_register(&mmc_omap_device1);
 	}
 
@@ -368,12 +369,29 @@
 		if (cpu_is_omap1710())
 			omap_writel(omap_readl(MOD_CONF_CTRL_1) | (1 << 24),
 				     MOD_CONF_CTRL_1);
-		mmc2_conf = *mmc;
+		mmc2_data.conf = *mmc;
 		(void) platform_device_register(&mmc_omap_device2);
 	}
 #endif
 	return;
 }
+
+void omap_set_mmc_info(int host, const struct omap_mmc_platform_data *info)
+{
+	switch (host) {
+	case 1:
+		mmc1_data = *info;
+		break;
+#ifdef	CONFIG_ARCH_OMAP16XX
+	case 2:
+		mmc2_data = *info;
+		break;
+#endif
+	default:
+		BUG();
+	}
+}
+
 #else
 static inline void omap_init_mmc(void) {}
 #endif
diff -ruN linux-omap-2.6/arch/arm/plat-omap/dma.c maemo_src/arch/arm/plat-omap/dma.c
--- linux-omap-2.6/arch/arm/plat-omap/dma.c	2011-02-06 20:17:25.329999940 -0500
+++ maemo_src/arch/arm/plat-omap/dma.c	2011-02-06 20:12:09.643333273 -0500
@@ -1348,6 +1348,24 @@
 }
 
 /*----------------------------------------------------------------------------*/
+#ifdef CONFIG_ARCH_OMAP2420_DMA_DRAIN
+
+#define OMAP2420_DMA_CCR_NUM	32
+
+void omap2_dma_pause(void)
+{
+	int i, busy;
+
+	do {
+		busy = 0;
+		for (i = 0; i < OMAP2420_DMA_CCR_NUM; i++)
+			while (OMAP_DMA_CCR_REG(i) & ((1 << 10) | (1 << 9)))
+				busy = 1;
+	} while (busy);
+}
+
+#endif
+/*----------------------------------------------------------------------------*/
 
 static int __init omap_init_dma(void)
 {
@@ -1390,6 +1408,8 @@
 		printk(KERN_INFO "OMAP DMA hardware revision %d.%d\n",
 		       revision >> 4, revision & 0xf);
 		dma_chan_count = OMAP_LOGICAL_DMA_CH_COUNT;
+		/* Enable smart idle and autoidle */
+		omap_writew(omap_readw(OMAP_DMA4_SYSCONFIG) | (1 << 0), OMAP_DMA4_SYSCONFIG);
 	} else {
 		dma_chan_count = 0;
 		return 0;
diff -ruN linux-omap-2.6/arch/arm/plat-omap/dmtimer.c maemo_src/arch/arm/plat-omap/dmtimer.c
--- linux-omap-2.6/arch/arm/plat-omap/dmtimer.c	2011-02-06 20:17:25.329999940 -0500
+++ maemo_src/arch/arm/plat-omap/dmtimer.c	2011-02-06 20:12:09.646666607 -0500
@@ -38,34 +38,113 @@
 #include <asm/arch/irqs.h>
 
 /* register offsets */
-#define OMAP_TIMER_ID_REG		0x00
-#define OMAP_TIMER_OCP_CFG_REG		0x10
-#define OMAP_TIMER_SYS_STAT_REG		0x14
-#define OMAP_TIMER_STAT_REG		0x18
-#define OMAP_TIMER_INT_EN_REG		0x1c
-#define OMAP_TIMER_WAKEUP_EN_REG	0x20
-#define OMAP_TIMER_CTRL_REG		0x24
-#define OMAP_TIMER_COUNTER_REG		0x28
-#define OMAP_TIMER_LOAD_REG		0x2c
-#define OMAP_TIMER_TRIGGER_REG		0x30
-#define OMAP_TIMER_WRITE_PEND_REG 	0x34
-#define OMAP_TIMER_MATCH_REG		0x38
-#define OMAP_TIMER_CAPTURE_REG		0x3c
-#define OMAP_TIMER_IF_CTRL_REG		0x40
-
-/* timer control reg bits */
-#define OMAP_TIMER_CTRL_GPOCFG		(1 << 14)
-#define OMAP_TIMER_CTRL_CAPTMODE	(1 << 13)
-#define OMAP_TIMER_CTRL_PT		(1 << 12)
-#define OMAP_TIMER_CTRL_TCM_LOWTOHIGH	(0x1 << 8)
-#define OMAP_TIMER_CTRL_TCM_HIGHTOLOW	(0x2 << 8)
-#define OMAP_TIMER_CTRL_TCM_BOTHEDGES	(0x3 << 8)
-#define OMAP_TIMER_CTRL_SCPWM		(1 << 7)
-#define OMAP_TIMER_CTRL_CE		(1 << 6)	/* compare enable */
-#define OMAP_TIMER_CTRL_PRE		(1 << 5)	/* prescaler enable */
-#define OMAP_TIMER_CTRL_PTV_SHIFT	2		/* how much to shift the prescaler value */
-#define OMAP_TIMER_CTRL_AR		(1 << 1)	/* auto-reload enable */
-#define OMAP_TIMER_CTRL_ST		(1 << 0)	/* start timer */
+#define _OMAP_TIMER_ID_OFFSET		0x00
+#define _OMAP_TIMER_OCP_CFG_OFFSET	0x10
+#define _OMAP_TIMER_SYS_STAT_OFFSET	0x14
+#define _OMAP_TIMER_STAT_OFFSET		0x18
+#define _OMAP_TIMER_INT_EN_OFFSET	0x1c
+#define _OMAP_TIMER_WAKEUP_EN_OFFSET	0x20
+#define _OMAP_TIMER_CTRL_OFFSET		0x24
+#define		OMAP_TIMER_CTRL_GPOCFG		(1 << 14)
+#define		OMAP_TIMER_CTRL_CAPTMODE	(1 << 13)
+#define		OMAP_TIMER_CTRL_PT		(1 << 12)
+#define		OMAP_TIMER_CTRL_TCM_LOWTOHIGH	(0x1 << 8)
+#define		OMAP_TIMER_CTRL_TCM_HIGHTOLOW	(0x2 << 8)
+#define		OMAP_TIMER_CTRL_TCM_BOTHEDGES	(0x3 << 8)
+#define		OMAP_TIMER_CTRL_SCPWM		(1 << 7)
+#define		OMAP_TIMER_CTRL_CE		(1 << 6) /* compare enable */
+#define		OMAP_TIMER_CTRL_PRE		(1 << 5) /* prescaler enable */
+#define		OMAP_TIMER_CTRL_PTV_SHIFT	2 /* prescaler value shift */
+#define		OMAP_TIMER_CTRL_POSTED		(1 << 2)
+#define		OMAP_TIMER_CTRL_AR		(1 << 1) /* auto-reload enable */
+#define		OMAP_TIMER_CTRL_ST		(1 << 0) /* start timer */
+#define _OMAP_TIMER_COUNTER_OFFSET	0x28
+#define _OMAP_TIMER_LOAD_OFFSET		0x2c
+#define _OMAP_TIMER_TRIGGER_OFFSET	0x30
+#define _OMAP_TIMER_WRITE_PEND_OFFSET	0x34
+#define		WP_NONE			0	/* no write pending bit */
+#define		WP_TCLR			(1 << 0)
+#define		WP_TCRR			(1 << 1)
+#define		WP_TLDR			(1 << 2)
+#define		WP_TTGR			(1 << 3)
+#define		WP_TMAR			(1 << 4)
+#define		WP_TPIR			(1 << 5)
+#define		WP_TNIR			(1 << 6)
+#define		WP_TCVR			(1 << 7)
+#define		WP_TOCR			(1 << 8)
+#define		WP_TOWR			(1 << 9)
+#define _OMAP_TIMER_MATCH_OFFSET	0x38
+#define _OMAP_TIMER_CAPTURE_OFFSET	0x3c
+#define _OMAP_TIMER_IF_CTRL_OFFSET	0x40
+#define _OMAP_TIMER_CAPTURE2_OFFSET		0x44	/* TCAR2, 34xx only */
+#define _OMAP_TIMER_TICK_POS_OFFSET		0x48	/* TPIR, 34xx only */
+#define _OMAP_TIMER_TICK_NEG_OFFSET		0x4c	/* TNIR, 34xx only */
+#define _OMAP_TIMER_TICK_COUNT_OFFSET		0x50	/* TCVR, 34xx only */
+#define _OMAP_TIMER_TICK_INT_MASK_SET_OFFSET	0x54	/* TOCR, 34xx only */
+#define _OMAP_TIMER_TICK_INT_MASK_COUNT_OFFSET	0x58	/* TOWR, 34xx only */
+
+/* register offsets with the write pending bit encoded */
+#define	WPSHIFT					16
+
+#define OMAP_TIMER_ID_REG			(_OMAP_TIMER_ID_OFFSET \
+							| (WP_NONE << WPSHIFT))
+
+#define OMAP_TIMER_OCP_CFG_REG			(_OMAP_TIMER_OCP_CFG_OFFSET \
+							| (WP_NONE << WPSHIFT))
+
+#define OMAP_TIMER_SYS_STAT_REG			(_OMAP_TIMER_SYS_STAT_OFFSET \
+							| (WP_NONE << WPSHIFT))
+
+#define OMAP_TIMER_STAT_REG			(_OMAP_TIMER_STAT_OFFSET \
+							| (WP_NONE << WPSHIFT))
+
+#define OMAP_TIMER_INT_EN_REG			(_OMAP_TIMER_INT_EN_OFFSET \
+							| (WP_NONE << WPSHIFT))
+
+#define OMAP_TIMER_WAKEUP_EN_REG		(_OMAP_TIMER_WAKEUP_EN_OFFSET \
+							| (WP_NONE << WPSHIFT))
+
+#define OMAP_TIMER_CTRL_REG			(_OMAP_TIMER_CTRL_OFFSET \
+							| (WP_TCLR << WPSHIFT))
+
+#define OMAP_TIMER_COUNTER_REG			(_OMAP_TIMER_COUNTER_OFFSET \
+							| (WP_TCRR << WPSHIFT))
+
+#define OMAP_TIMER_LOAD_REG			(_OMAP_TIMER_LOAD_OFFSET \
+							| (WP_TLDR << WPSHIFT))
+
+#define OMAP_TIMER_TRIGGER_REG			(_OMAP_TIMER_TRIGGER_OFFSET \
+							| (WP_TTGR << WPSHIFT))
+
+#define OMAP_TIMER_WRITE_PEND_REG		(_OMAP_TIMER_WRITE_PEND_OFFSET \
+							| (WP_NONE << WPSHIFT))
+
+#define OMAP_TIMER_MATCH_REG			(_OMAP_TIMER_MATCH_OFFSET \
+							| (WP_TMAR << WPSHIFT))
+
+#define OMAP_TIMER_CAPTURE_REG			(_OMAP_TIMER_CAPTURE_OFFSET \
+							| (WP_NONE << WPSHIFT))
+
+#define OMAP_TIMER_IF_CTRL_REG			(_OMAP_TIMER_IF_CTRL_OFFSET \
+							| (WP_NONE << WPSHIFT))
+
+#define OMAP_TIMER_CAPTURE2_REG			(_OMAP_TIMER_CAPTURE2_OFFSET \
+							| (WP_NONE << WPSHIFT))
+
+#define OMAP_TIMER_TICK_POS_REG			(_OMAP_TIMER_TICK_POS_OFFSET \
+							| (WP_TPIR << WPSHIFT))
+
+#define OMAP_TIMER_TICK_NEG_REG			(_OMAP_TIMER_TICK_NEG_OFFSET \
+							| (WP_TNIR << WPSHIFT))
+
+#define OMAP_TIMER_TICK_COUNT_REG		(_OMAP_TIMER_TICK_COUNT_OFFSET \
+							| (WP_TCVR << WPSHIFT))
+
+#define OMAP_TIMER_TICK_INT_MASK_SET_REG				\
+		(_OMAP_TIMER_TICK_INT_MASK_SET_OFFSET | (WP_TOCR << WPSHIFT))
+
+#define OMAP_TIMER_TICK_INT_MASK_COUNT_REG				\
+		(_OMAP_TIMER_TICK_INT_MASK_COUNT_OFFSET | (WP_TOWR << WPSHIFT))
 
 struct omap_dm_timer {
 	unsigned long phys_base;
@@ -76,6 +155,7 @@
 	void __iomem *io_base;
 	unsigned reserved:1;
 	unsigned enabled:1;
+	unsigned posted:1;
 };
 
 #ifdef CONFIG_ARCH_OMAP1
@@ -131,16 +211,34 @@
 static const int dm_timer_count = ARRAY_SIZE(dm_timers);
 static spinlock_t dm_timer_lock;
 
-static inline u32 omap_dm_timer_read_reg(struct omap_dm_timer *timer, int reg)
+/*
+ * Reads timer registers in posted and non-posted mode. The posted mode bit
+ * is encoded in reg. Note that in posted mode write pending bit must be
+ * checked. Otherwise a read of a non completed write will produce an error.
+ */
+static inline u32 omap_dm_timer_read_reg(struct omap_dm_timer *timer, u32 reg)
 {
-	return readl(timer->io_base + reg);
+	if (timer->posted)
+		while (readl(timer->io_base + (OMAP_TIMER_WRITE_PEND_REG & 0xff))
+				& (reg >> WPSHIFT))
+			cpu_relax();
+	return readl(timer->io_base + (reg & 0xff));
 }
 
-static void omap_dm_timer_write_reg(struct omap_dm_timer *timer, int reg, u32 value)
+/*
+ * Writes timer registers in posted and non-posted mode. The posted mode bit
+ * is encoded in reg. Note that in posted mode the write pending bit must be
+ * checked. Otherwise a write on a register which has a pending write will be
+ * lost.
+ */
+static void omap_dm_timer_write_reg(struct omap_dm_timer *timer, u32 reg,
+						u32 value)
 {
-	writel(value, timer->io_base + reg);
-	while (omap_dm_timer_read_reg(timer, OMAP_TIMER_WRITE_PEND_REG))
-		;
+	if (timer->posted)
+		while (readl(timer->io_base + (OMAP_TIMER_WRITE_PEND_REG & 0xff))
+				& (reg >> WPSHIFT))
+			cpu_relax();
+	writel(value, timer->io_base + (reg & 0xff));
 }
 
 static void omap_dm_timer_wait_for_reset(struct omap_dm_timer *timer)
@@ -167,17 +265,23 @@
 	}
 	omap_dm_timer_set_source(timer, OMAP_TIMER_SRC_32_KHZ);
 
-	/* Set to smart-idle mode */
 	l = omap_dm_timer_read_reg(timer, OMAP_TIMER_OCP_CFG_REG);
-	l |= 0x02 << 3;
+	l |= 0x02 << 3;  /* Set to smart-idle mode */
+	l |= 0x2 << 8;   /* Set clock activity to perserve f-clock on idle */
 
-	if (cpu_class_is_omap2() && timer == &dm_timers[0]) {
-		/* Enable wake-up only for GPT1 on OMAP2 CPUs*/
+	/*
+	 * Enable wake-up only for GPT1 on OMAP2 CPUs.
+	 * FIXME: All timers should have wake-up enabled and clear
+	 * PRCM status.
+	 */
+	if (cpu_class_is_omap2() && (timer == &dm_timers[0]))
 		l |= 1 << 2;
-		/* Non-posted mode */
-		omap_dm_timer_write_reg(timer, OMAP_TIMER_IF_CTRL_REG, 0);
-	}
 	omap_dm_timer_write_reg(timer, OMAP_TIMER_OCP_CFG_REG, l);
+
+	/* Match hardware reset default of posted mode */
+	omap_dm_timer_write_reg(timer, OMAP_TIMER_IF_CTRL_REG,
+			OMAP_TIMER_CTRL_POSTED);
+	timer->posted = 1;
 }
 
 static void omap_dm_timer_prepare(struct omap_dm_timer *timer)
@@ -384,6 +488,11 @@
 		l &= ~OMAP_TIMER_CTRL_AR;
 	omap_dm_timer_write_reg(timer, OMAP_TIMER_CTRL_REG, l);
 	omap_dm_timer_write_reg(timer, OMAP_TIMER_LOAD_REG, load);
+
+	/* REVISIT: hw feature, ttgr overtaking tldr? */
+	while (readl(timer->io_base + (OMAP_TIMER_WRITE_PEND_REG & 0xff)))
+		cpu_relax();
+
 	omap_dm_timer_write_reg(timer, OMAP_TIMER_TRIGGER_REG, 0);
 }
 
diff -ruN linux-omap-2.6/arch/arm/plat-omap/dsp/dsp_common.h maemo_src/arch/arm/plat-omap/dsp/dsp_common.h
--- linux-omap-2.6/arch/arm/plat-omap/dsp/dsp_common.h	2011-02-06 20:17:25.329999940 -0500
+++ maemo_src/arch/arm/plat-omap/dsp/dsp_common.h	2011-02-06 20:12:09.463333273 -0500
@@ -169,6 +169,9 @@
 }
 #endif
 
+#define DSP_KFUNC_DEV_TYPE_COMMON	(1<<0)
+#define DSP_KFUNC_DEV_TYPE_AUDIO	(1<<1)
+
 struct dsp_kfunc_device {
 	char		*name;
 	struct clk	*fck;
@@ -176,9 +179,6 @@
 	spinlock_t	 lock;
 	int		 enabled;
 	int		 type;
-#define DSP_KFUNC_DEV_TYPE_COMMON	1
-#define DSP_KFUNC_DEV_TYPE_AUDIO	2
-
 	struct list_head	entry;
 
 	int	(*probe)(struct dsp_kfunc_device *, int);
@@ -195,26 +195,25 @@
 
 struct omap_dsp {
 	struct mutex		lock;
-	int			enabled;	/* stored peripheral status */
+	unsigned long		state;		/* device status */
+	unsigned long		suspend_state;	/* Keep dsp device state
+						   during suspend()/resume() */
+	unsigned long		notify_state;	/* device status to monitor */
 	struct omap_mmu		*mmu;
 	struct omap_mbox	*mbox;
 	struct device		*dev;
 	struct list_head	*kdev_list;
 	int			initialized;
-};
-
-#if defined(CONFIG_ARCH_OMAP1)
-#define command_dvfs_stop(m) (0)
-#define command_dvfs_start(m) (0)
-#elif defined(CONFIG_ARCH_OMAP2)
-#define command_dvfs_stop(m) \
-	(((m)->cmd_l == KFUNC_POWER) && ((m)->data == DVFS_STOP))
-#define command_dvfs_start(m) \
-	(((m)->cmd_l == KFUNC_POWER) && ((m)->data == DVFS_START))
+#ifdef CONFIG_OMAP_DSP_PAUSING
+	struct completion	dsp_paused;
 #endif
+};
 
 extern struct omap_dsp *omap_dsp;
 
 extern int dsp_late_init(void);
+extern int dsp_mem_late_init(void);
+
+#define dsp_activated(dsp) (dsp->mbox != NULL)
 
 #endif /* DRIVER_DSP_COMMON_H */
diff -ruN linux-omap-2.6/arch/arm/plat-omap/dsp/dsp_core.c maemo_src/arch/arm/plat-omap/dsp/dsp_core.c
--- linux-omap-2.6/arch/arm/plat-omap/dsp/dsp_core.c	2011-02-06 20:17:25.333333273 -0500
+++ maemo_src/arch/arm/plat-omap/dsp/dsp_core.c	2011-02-06 20:12:09.496666606 -0500
@@ -28,9 +28,9 @@
 #include <linux/mutex.h>
 #include <linux/err.h>
 #include <linux/clk.h>
-#include <asm/delay.h>
+#include <linux/delay.h>
 #include <asm/arch/mailbox.h>
-#include <asm/arch/dsp_common.h>
+#include <asm/arch/dvfs.h>
 #include "dsp_mbcmd.h"
 #include "dsp.h"
 #include "ipbuf.h"
@@ -44,8 +44,6 @@
 static u16 mbseq_expect_tmp;
 static u16 *mbseq_expect = &mbseq_expect_tmp;
 
-extern int dsp_mem_late_init(void);
-
 /*
  * mailbox commands
  */
@@ -132,6 +130,29 @@
 	[MBOX_CMD_DSP_DBG]      = &cif_dbg,
 };
 
+
+static ssize_t dsp_state_store(struct device *dev,
+			       struct device_attribute *attr, const char *buf,
+			       size_t count)
+{
+	unsigned long val;
+	struct omap_dsp *dsp = dev_get_drvdata(dev);
+
+	sscanf(buf, "%lu", &val);
+	dsp->notify_state = val;
+	return count;
+}
+
+static ssize_t dsp_state_show(struct device *dev,
+			      struct device_attribute *attr, char *buf)
+{
+	struct omap_dsp *dsp = dev_get_drvdata(dev);
+	return sprintf(buf, "%ld\n", dsp->state);
+}
+
+static DEVICE_ATTR(state, S_IRUGO | S_IWUSR, dsp_state_show, dsp_state_store);
+
+
 #define list_for_each_entry_safe_natural(p,n,h,m) \
 			list_for_each_entry_safe(p,n,h,m)
 #define __BUILD_KFUNC(fn, dir)							\
@@ -151,7 +172,22 @@
 			fail++;							\
 		}								\
 	}									\
-	return fail;								\
+	if (fail)								\
+		return fail;							\
+	if (strcmp(#fn, "probe") == 0) {					\
+		return device_create_file(dsp->dev, &dev_attr_state);		\
+	} else if (strcmp(#fn, "remove") == 0) {				\
+		device_remove_file(dsp->dev, &dev_attr_state);			\
+	} else if (strcmp(#fn, "enable") == 0) {				\
+		dsp->state |= type;						\
+		if (type & dsp->notify_state)					\
+			sysfs_notify(&dsp->dev->kobj, NULL, "state");		\
+	} else if (strcmp(#fn, "disable") == 0)	{				\
+		dsp->state &= ~type;						\
+		if (type & dsp->notify_state)					\
+			sysfs_notify(&dsp->dev->kobj, NULL, "state");		\
+	}									\
+	return 0;								\
 }
 #define BUILD_KFUNC(fn, dir)						\
 __BUILD_KFUNC(fn, dir)							\
@@ -219,6 +255,102 @@
 	return ret;
 }
 
+static inline int __omap_mbox_send_sync(struct omap_mbox *mbox,
+					mbox_msg_t msg, void* arg)
+{
+	int ret = omap_mbox_send_sync(omap_dsp->mbox, msg, NULL);
+	if (ret)
+		return ret;
+	if (mbseq)
+		mbseq->ad_arm++;
+	mblog_add((struct mbcmd *)&msg, DIR_A2D);
+	return 0;
+}
+
+#ifdef CONFIG_OMAP_DSP_PAUSING
+
+/*
+ * This timeout is intended for emergency cases, like DSP death and
+ * mostly DSP returns ACK immediately, but it takes bit longer to
+ * deliver the messages from queue to dspgw in ARM if it is under heavy
+ * load because mailbox shares the system workqueue for delivering its
+ * messages. Basically this latency cannot be ensured.
+ */
+#define DSP_PAUSING_MBOX_TIMEOUT	100
+
+enum {
+	DSP_PAUSE = 0xf,
+	DSP_CONTINUE = 0xf0,
+};
+
+static struct platform_driver dsp_driver;
+
+static int dsp_pause_continue(struct device *dev, void *command)
+{
+	mbox_msg_t msg;
+	int ret = 0;
+	unsigned long timeout = msecs_to_jiffies(DSP_PAUSING_MBOX_TIMEOUT);
+	struct omap_dsp *info;
+
+	if (!dsp_activated(omap_dsp))
+		return 0;
+	
+	info = dev_get_drvdata(dev);
+
+	/*
+	 * DSP_PAUSE and DSP_CONTINUE should be paired in the upper
+	 * layer to keep track of the consistency of DSP state in any
+	 * cases.
+	 */
+	switch ((int)command) {
+	case DSP_PAUSE:
+		down_write(&info->mmu->exmap_sem);
+		INIT_COMPLETION(info->dsp_paused);
+		BUILD_MBCMD(&msg, MBOX_CMD_DSP_KFUNC, KFUNC_POWER, PAUSE);
+		mbox_queue_suspend(info->mbox->txq);
+		ret = __omap_mbox_send_sync(omap_dsp->mbox, msg, NULL);
+		if (ret) {
+			printk(KERN_ERR "DSP PAUSE: Error sending PAUSE\n");
+			break;
+		}
+		timeout = wait_for_completion_timeout(&info->dsp_paused,
+						      timeout);
+		if (timeout == 0)
+			ret = -1;
+		break;
+	case DSP_CONTINUE:
+		BUILD_MBCMD(&msg, MBOX_CMD_DSP_KFUNC, KFUNC_POWER, CONTINUE);
+		ret = __omap_mbox_send_sync(omap_dsp->mbox, msg, NULL);
+		if (ret)
+			printk(KERN_ERR
+			       "DSP CONTINUE: Error sending CONTINUE\n");
+		mbox_queue_resume(info->mbox->txq);
+		up_write(&info->mmu->exmap_sem);
+		break;
+	default:
+		BUG();
+		break;
+	}
+
+	return ret;
+}
+
+int dsp_pause(void)
+{
+	return driver_for_each_device(&dsp_driver.driver,
+				      NULL, (void *)DSP_PAUSE,
+				      dsp_pause_continue);
+}
+
+int dsp_continue(void)
+{
+	return driver_for_each_device(&dsp_driver.driver,
+				      NULL, (void *)DSP_CONTINUE,
+				      dsp_pause_continue);
+}
+
+#endif
+
 /*
  * __dsp_mbcmd_send_exarg(): mailbox dispatcher
  */
@@ -227,13 +359,9 @@
 {
 	int ret = 0;
 
-	if (unlikely(omap_dsp->enabled == 0)) {
+	if (unlikely(omap_dsp->state == 0))
 		ret = dsp_kfunc_enable_devices(omap_dsp,
 					       DSP_KFUNC_DEV_TYPE_COMMON, 0);
-		if (ret == 0)
-			omap_dsp->enabled = 1;
-	}
-
 	/*
 	 * while MMU fault is set,
 	 * only recovery command can be executed
@@ -245,8 +373,7 @@
 		goto out;
 	}
 
-	ret = omap_mbox_msg_send(omap_dsp->mbox,
-				 *(mbox_msg_t *)mb, (void*)arg);
+	ret = omap_mbox_send(omap_dsp->mbox, *(mbox_msg_t *)mb, (void*)arg);
 	if (ret)
 		goto out;
 
@@ -399,28 +526,28 @@
 	int ret = -1;
 
 	switch (data) {
-	case DVFS_START: /* ACK from DSP */
-		/* TBD */
+#ifdef CONFIG_OMAP_DSP_PAUSING
+	case PAUSE: /* ACK from DSP */
+		complete(&omap_dsp->dsp_paused);
+		ret = 0;
 		break;
+#endif
 	case AUDIO_PWR_UP:
 		ret = dsp_kfunc_enable_devices(omap_dsp,
 					       DSP_KFUNC_DEV_TYPE_AUDIO, 0);
+		dvfs_op_policy_update_delayed(DSP_AUDIO_PATH_CHANGED, 1);
 		if (ret == 0)
 			ret++;
 		break;
-	case AUDIO_PWR_DOWN: /* == AUDIO_PWR_DOWN1 */
-		ret = dsp_kfunc_disable_devices(omap_dsp,
-						DSP_KFUNC_DEV_TYPE_AUDIO, 1);
-		break;
+	case AUDIO_PWR_DOWN: /* AUDIO_PWR_DOWN1 */
 	case AUDIO_PWR_DOWN2:
 		ret = dsp_kfunc_disable_devices(omap_dsp,
-						DSP_KFUNC_DEV_TYPE_AUDIO, 2);
+						DSP_KFUNC_DEV_TYPE_AUDIO, data);
+		dvfs_op_policy_update_delayed(DSP_AUDIO_PATH_CHANGED, 0);
 		break;
 	case DSP_PWR_DOWN:
 		ret = dsp_kfunc_disable_devices(omap_dsp,
 						DSP_KFUNC_DEV_TYPE_COMMON, 0);
-		if (ret == 0)
-			omap_dsp->enabled = 0;
 		break;
 	default:
 		printk(KERN_ERR
@@ -472,7 +599,9 @@
 				       DSP_KFUNC_DEV_TYPE_COMMON, 0);
 	if (ret)
 		goto fail_kfunc;
-	omap_dsp->enabled = 1;
+#ifdef CONFIG_OMAP_DSP_PAUSING
+	init_completion(&omap_dsp->dsp_paused);
+#endif
 
 	return 0;
 
@@ -596,8 +725,64 @@
 	return 0;
 }
 #else
-#define dsp_drv_suspend		NULL
-#define dsp_drv_resume		NULL
+static int dsp_drv_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct omap_dsp *info = platform_get_drvdata(pdev);
+	const unsigned long pm_pwstst_dsp = 0x480088e4;
+	unsigned long val;
+	int retry = 100;
+
+	if (!dsp_activated(info))
+		return 0;
+
+	/* Stop sending mailbox messages to DSP any more */
+	mbox_queue_suspend(info->mbox->txq);
+
+	/* Wait until DSP power state is OFF or RETENTION */
+	while (retry--) {
+		val = omap_readl(pm_pwstst_dsp);
+		if (val & 0x1)
+			break;
+		msleep(1);
+	}
+
+	if (!retry) {
+		dev_err(&pdev->dev, "Time out for suspend(%08lx)\n", val);
+		return -ETIME;
+	}
+
+	/* Save current dsp device state to restore it later */
+	omap_dsp->suspend_state = omap_dsp->state;
+
+	if (omap_dsp->suspend_state & DSP_KFUNC_DEV_TYPE_AUDIO)
+		dsp_kfunc_disable_devices(omap_dsp,
+					  DSP_KFUNC_DEV_TYPE_AUDIO, 1);
+	if (omap_dsp->suspend_state & DSP_KFUNC_DEV_TYPE_COMMON)
+		dsp_kfunc_disable_devices(omap_dsp,
+					  DSP_KFUNC_DEV_TYPE_COMMON, 0);
+	return 0;
+}
+
+static int dsp_drv_resume(struct platform_device *pdev)
+{
+	struct omap_dsp *info = platform_get_drvdata(pdev);
+
+	if (!dsp_activated(info))
+		return 0;
+
+	/* Restore the previous dsp device state */
+	if (omap_dsp->suspend_state & DSP_KFUNC_DEV_TYPE_COMMON)
+		dsp_kfunc_enable_devices(omap_dsp,
+					 DSP_KFUNC_DEV_TYPE_COMMON, 0);
+	if (omap_dsp->suspend_state & DSP_KFUNC_DEV_TYPE_AUDIO)
+		dsp_kfunc_enable_devices(omap_dsp,
+					 DSP_KFUNC_DEV_TYPE_AUDIO, 1);
+
+	/* Resume sending pending mailbox messages again */
+	mbox_queue_resume(info->mbox->txq);
+
+	return 0;
+}
 #endif /* CONFIG_PM */
 
 static struct platform_driver dsp_driver = {
diff -ruN linux-omap-2.6/arch/arm/plat-omap/dsp/dsp.h maemo_src/arch/arm/plat-omap/dsp/dsp.h
--- linux-omap-2.6/arch/arm/plat-omap/dsp/dsp.h	2011-02-06 20:17:25.329999940 -0500
+++ maemo_src/arch/arm/plat-omap/dsp/dsp.h	2007-10-02 03:09:30.000000000 -0400
@@ -113,6 +113,13 @@
 		.data  = (d), \
 	}
 
+#define BUILD_MBCMD(p, h, l, d)			\
+do {						\
+	((struct mbcmd *)(p))->cmd_h = (h);	\
+	((struct mbcmd *)(p))->cmd_l = (l);	\
+	((struct mbcmd *)(p))->data  = (d);	\
+} while(0)
+
 struct mb_exarg {
 	u8 tid;
 	int argc;
diff -ruN linux-omap-2.6/arch/arm/plat-omap/dsp/dsp_mbcmd.h maemo_src/arch/arm/plat-omap/dsp/dsp_mbcmd.h
--- linux-omap-2.6/arch/arm/plat-omap/dsp/dsp_mbcmd.h	2011-02-06 20:17:25.333333273 -0500
+++ maemo_src/arch/arm/plat-omap/dsp/dsp_mbcmd.h	2011-02-06 20:12:09.463333273 -0500
@@ -85,8 +85,8 @@
 #define AUDIO_PWR_DOWN2		0x0002
 #define DSP_PWR_UP		0x0003	/* ARM(exe/snd)	->  DSP(exe)	*/
 #define DSP_PWR_DOWN		0x0004	/* ARM(exe)	<-  DSP(req)	*/
-#define DVFS_START		0x0006	/* ARM(req)	<-> DSP(exe/ack)*/
-#define DVFS_STOP		0x0007	/* ARM(req)	 -> DSP(exe)	*/
+#define PAUSE			0x0006	/* ARM(req)	<-> DSP(exe/ack)*/
+#define CONTINUE		0x0007	/* ARM(req)	 -> DSP(exe)	*/
 
 #define TDEL_SAFE		0x0000
 #define TDEL_KILL		0x0001
diff -ruN linux-omap-2.6/arch/arm/plat-omap/dsp/error.c maemo_src/arch/arm/plat-omap/dsp/error.c
--- linux-omap-2.6/arch/arm/plat-omap/dsp/error.c	2011-02-06 20:17:25.333333273 -0500
+++ maemo_src/arch/arm/plat-omap/dsp/error.c	2007-10-02 03:09:30.000000000 -0400
@@ -99,15 +99,9 @@
 /* DSP MMU */
 static void dsp_err_mmu_set(unsigned long arg)
 {
-	disable_irq(omap_dsp->mmu->irq);
 	mmu_fadr = (u32)arg;
 }
 
-static void dsp_err_mmu_clr(void)
-{
-	enable_irq(omap_dsp->mmu->irq);
-}
-
 /* WDT */
 static void dsp_err_wdt_set(unsigned long arg)
 {
@@ -122,7 +116,7 @@
 	void (*set)(unsigned long arg);
 	void (*clr)(void);
 } dsp_err_desc[ERRCODE_MAX] = {
-	[ERRCODE_MMU] = { DSP_ERR_MMU, dsp_err_mmu_set, dsp_err_mmu_clr },
+	[ERRCODE_MMU] = { DSP_ERR_MMU, dsp_err_mmu_set, NULL },
 	[ERRCODE_WDT] = { DSP_ERR_WDT, dsp_err_wdt_set, NULL },
 };
 
diff -ruN linux-omap-2.6/arch/arm/plat-omap/dsp/Kconfig maemo_src/arch/arm/plat-omap/dsp/Kconfig
--- linux-omap-2.6/arch/arm/plat-omap/dsp/Kconfig	2011-02-06 20:17:25.329999940 -0500
+++ maemo_src/arch/arm/plat-omap/dsp/Kconfig	2011-02-06 20:12:09.463333273 -0500
@@ -29,3 +29,11 @@
 	  By doing this, DSP can access the frame buffer directly without
 	  bothering ARM.
 
+config OMAP_DSP_PAUSING
+	bool "DSP Pausing"
+	depends on OMAP_DSP
+	help
+          With this option the DSP can be set in busy waiting and stops any
+	  activity, including DMA, till it receives a continue message.
+	  This mode can be used for DVFS.
+
diff -ruN linux-omap-2.6/arch/arm/plat-omap/dsp/mblog.c maemo_src/arch/arm/plat-omap/dsp/mblog.c
--- linux-omap-2.6/arch/arm/plat-omap/dsp/mblog.c	2011-02-06 20:17:25.333333273 -0500
+++ maemo_src/arch/arm/plat-omap/dsp/mblog.c	2011-02-06 20:12:09.493333272 -0500
@@ -54,8 +54,8 @@
 			 (mb->data == AUDIO_PWR_DOWN2)	? "PWR AUD /DOWN(2)":
 			 (mb->data == DSP_PWR_UP)	? "PWR DSP /UP":
 			 (mb->data == DSP_PWR_DOWN)	? "PWR DSP /DOWN":
-			 (mb->data == DVFS_START)	? "PWR DVFS/START":
-			 (mb->data == DVFS_STOP)	? "PWR DVFS/STOP":
+			 (mb->data == PAUSE)		? "PWR DSP /PAUSE":
+			 (mb->data == CONTINUE)		? "PWR DSP /CONTINUE":
 			 NULL):
 
 		    NULL;
diff -ruN linux-omap-2.6/arch/arm/plat-omap/dsp/task.c maemo_src/arch/arm/plat-omap/dsp/task.c
--- linux-omap-2.6/arch/arm/plat-omap/dsp/task.c	2011-02-06 20:17:25.349999938 -0500
+++ maemo_src/arch/arm/plat-omap/dsp/task.c	2011-02-06 20:12:09.486666606 -0500
@@ -37,6 +37,7 @@
 #include <asm/io.h>
 #include <asm/arch/mailbox.h>
 #include <asm/arch/dsp.h>
+#include <asm/arch/dvfs.h>
 #include "uaccess_dsp.h"
 #include "dsp_mbcmd.h"
 #include "dsp.h"
@@ -44,8 +45,6 @@
 #include "fifo.h"
 #include "proclist.h"
 
-#define is_aligned(adr,align)	(!((adr)&((align)-1)))
-
 /*
  * devstate: task device state machine
  * NOTASK:	task is not attached.
@@ -111,9 +110,10 @@
 	struct bus_type *bus;
 	struct device dev;	/* Generic device interface */
 
-	long state;
+	long state, last_state;
 	struct rw_semaphore state_sem;
 	wait_queue_head_t state_wait_q;
+
 	struct mutex usecount_lock;
 	unsigned int usecount;
 	char name[TNM_LEN];
@@ -203,10 +203,12 @@
 static u16 cfg_cmd;
 static u8 cfg_tid;
 static DECLARE_WAIT_QUEUE_HEAD(cfg_wait_q);
-static u8 n_task;	/* static task count */
-static void *heap;
 
-#define is_dynamic_task(tid)	((tid) >= n_task)
+static int num_static_task;
+static int num_dynamic_task;
+#define is_dynamic_task(tid)	((tid) >= num_static_task)
+
+static void *heap;
 
 #define devstate_read_lock(dev, devstate) \
 		devstate_read_lock_timeout(dev, devstate, 0)
@@ -255,14 +257,39 @@
 static struct device_attribute dev_attr_wsz       = __ATTR_RO(wsz);
 static struct device_attribute dev_attr_mmap      = __ATTR_RO(mmap);
 
-static inline void set_taskdev_state(struct taskdev *dev, int state)
+/* Expected to hold state_sem in caller function */
+static void set_taskdev_state(struct taskdev *dev, long state)
 {
+	if (dev->state == state)
+		return;
+
 	pr_debug("omapdsp: devstate: CHANGE %s[%d]:\"%s\"->\"%s\"\n",
 		 dev->name,
 		 (dev->task ? dev->task->tid : -1),
 		 devstate_name(dev->state),
 		 devstate_name(state));
+
+	dev->last_state = dev->state;
 	dev->state = state;
+
+	if ((dev->task) && is_dynamic_task(dev->task->tid)) {
+		int temp = num_dynamic_task;
+
+		if (dev->state & TASKDEV_ST_ATTACHED)
+			num_dynamic_task++;
+		else if (dev->last_state & TASKDEV_ST_ATTACHED)
+			num_dynamic_task--;
+		else
+			return;
+
+		BUG_ON(num_dynamic_task < 0);
+		BUG_ON(num_static_task + num_dynamic_task >= TASKDEV_MAX);
+
+		/* Change only if there's any dynamic task or not */
+		if (!(temp * num_dynamic_task))
+			dvfs_op_policy_update(DSP_DYNAMIC_TASK_CHANGED,
+					      num_dynamic_task);
+	}
 }
 
 /*
@@ -490,8 +517,8 @@
 
 	/* mmap buffer configuration check */
 	if ((task->map_length > 0) &&
-	    ((!is_aligned((unsigned long)task->map_base, PAGE_SIZE)) ||
-	     (!is_aligned(task->map_length, PAGE_SIZE)) ||
+	    ((!ALIGN((unsigned long)task->map_base, PAGE_SIZE)) ||
+	     (!ALIGN(task->map_length, PAGE_SIZE)) ||
 	     (dsp_mem_type(task->map_base, task->map_length) != MEM_TYPE_EXTERN))) {
 		printk(KERN_ERR
 		       "omapdsp: illegal mmap buffer address(0x%p) or "
@@ -537,7 +564,9 @@
 	devheap  = heap;
 	taskheap = heap + devheapsz;
 
-	n_task = n;
+	num_dynamic_task = 0;
+
+	num_static_task = n;
 	for (i = 0; i < n; i++) {
 		struct taskdev *dev  = &devheap[i];
 		struct dsptask *task = &taskheap[i];
@@ -566,7 +595,7 @@
 	u8 tid;
 	struct dsptask *task;
 
-	for (minor = 0; minor < n_task; minor++) {
+	for (minor = 0; minor < num_static_task; minor++) {
 		/*
 		 * taskdev[minor] can be NULL in case of
 		 * configuration failure
@@ -579,7 +608,7 @@
 			dsp_rmdev_minor(minor);
 	}
 
-	for (tid = 0; tid < n_task; tid++) {
+	for (tid = 0; tid < num_static_task; tid++) {
 		/*
 		 * dsptask[tid] can be NULL in case of
 		 * configuration failure
@@ -605,7 +634,8 @@
 		heap = NULL;
 	}
 
-	n_task = 0;
+	num_static_task = 0;
+	num_dynamic_task = 0;
 }
 
 static struct device_driver dsptask_driver = {
@@ -615,7 +645,7 @@
 
 u8 dsp_task_count(void)
 {
-	return n_task;
+	return num_static_task;
 }
 
 int dsp_taskmod_busy(void)
@@ -633,10 +663,6 @@
 			       dev->name, usecount);
 			return 1;
 		}
-/*
-		if ((dev->state & (TASKDEV_ST_ADDREQ |
-				   TASKDEV_ST_DELREQ)) {
-*/
 		if (dev->state & TASKDEV_ST_ADDREQ) {
 			printk("dsp_taskmod_busy(): %s is in %s\n",
 			       dev->name, devstate_name(dev->state));
@@ -1301,7 +1327,6 @@
 	struct dsptask *task;
 	size_t len = vma->vm_end - vma->vm_start;
 
-	BUG_ON(!(dev->state & TASKDEV_ST_ATTACHED));
 	task = dev->task;
 	omap_mmu_exmap_unuse(&dsp_mmu, task->map_base, len);
 }
@@ -1432,13 +1457,14 @@
 	/* wake up twch daemon for tadd */
 	dsp_twch_touch();
 	up_write(&dev->state_sem);
-	if (devstate_write_lock(dev, TASKDEV_ST_ATTACHED |
-				TASKDEV_ST_ADDFAIL) < 0) {
+	if (devstate_write_lock_timeout(dev, TASKDEV_ST_ATTACHED |
+					TASKDEV_ST_ADDFAIL,
+					msecs_to_jiffies(3000)) < 0) {
 		/* cancelled */
 		if (!devstate_write_lock_and_test(dev, TASKDEV_ST_ADDREQ)) {
 			mutex_unlock(&dev->usecount_lock);
 			/* out of control ??? */
-			return -EINTR;
+			return -EAGAIN;
 		}
 		set_taskdev_state(dev, TASKDEV_ST_NOTASK);
 		ret = -EINTR;
@@ -1564,7 +1590,7 @@
 	}
 
 	/* find free minor number */
-	for (minor = n_task; minor < TASKDEV_MAX; minor++) {
+	for (minor = num_static_task; minor < TASKDEV_MAX; minor++) {
 		if (taskdev[minor] == NULL)
 			goto do_make;
 	}
@@ -1604,13 +1630,13 @@
 		return -EINTR;
 
 	/* find in dynamic devices */
-	for (minor = n_task; minor < TASKDEV_MAX; minor++) {
+	for (minor = num_static_task; minor < TASKDEV_MAX; minor++) {
 		if (taskdev[minor] && !strcmp(taskdev[minor]->name, name))
 			goto do_remove;
 	}
 
 	/* find in static devices */
-	for (minor = 0; minor < n_task; minor++) {
+	for (minor = 0; minor < num_static_task; minor++) {
 		if (taskdev[minor] && !strcmp(taskdev[minor]->name, name)) {
 			printk(KERN_ERR
 			       "omapdsp: task device %s is static.\n", name);
@@ -1744,7 +1770,7 @@
 
 	strncpy(dev->name, name, TNM_LEN);
 	dev->name[TNM_LEN-1] = '\0';
-	set_taskdev_state(dev, (minor < n_task) ? TASKDEV_ST_ATTACHED : TASKDEV_ST_NOTASK);
+	set_taskdev_state(dev, (minor < num_static_task) ? TASKDEV_ST_ATTACHED : TASKDEV_ST_NOTASK);
 	dev->usecount = 0;
 	mutex_init(&dev->usecount_lock);
 	memcpy(&dev->fops, &dsp_task_fops, sizeof(struct file_operations));
@@ -1771,7 +1797,7 @@
 	task_dev = device_create(dsp_task_class, NULL,
 				 MKDEV(OMAP_DSP_TASK_MAJOR, minor),
 				 "dsptask%d", (int)minor);
-	
+
 	if (unlikely(IS_ERR(task_dev))) {
 		ret = -EINVAL;
 		goto fail_create_taskclass;
@@ -1935,7 +1961,9 @@
 	dev->fops.write = NULL;
 	dev->wsz = 0;
 
-	pr_info("omapdsp: taskdev %s disabled.\n", dev->name);
+	pr_info("omapdsp: taskdev %s disabled(%d)\n", dev->name,
+		num_dynamic_task);
+
 	dev->task = NULL;
 }
 
@@ -2002,7 +2030,7 @@
 		ret = -EINVAL;
 		goto fail_out;
 	}
-	if ((tid < n_task) || dsptask[tid]) {
+	if ((tid < num_static_task) || dsptask[tid]) {
 		printk(KERN_ERR "omapdsp: illegal tid (%d)!\n", tid);
 		ret = -EINVAL;
 		goto fail_out;
@@ -2027,9 +2055,13 @@
 		goto free_out;
 
 	dsp_task_init(task);
-	pr_info("omapdsp: taskdev %s enabled.\n", dev->name);
+
 	set_taskdev_state(dev, TASKDEV_ST_ATTACHED);
+	pr_info("omapdsp: taskdev %s enabled(%d)\n", dev->name,
+		num_dynamic_task);
+
 	wake_up_interruptible_all(&dev->state_wait_q);
+
 	return 0;
 
 free_out:
diff -ruN linux-omap-2.6/arch/arm/plat-omap/gpio-switch.c maemo_src/arch/arm/plat-omap/gpio-switch.c
--- linux-omap-2.6/arch/arm/plat-omap/gpio-switch.c	2011-02-06 20:17:25.389999939 -0500
+++ maemo_src/arch/arm/plat-omap/gpio-switch.c	2007-10-02 03:09:30.000000000 -0400
@@ -131,11 +131,12 @@
 
 	str = get_sw_str(sw);
 	if (strcmp(state, str[0]) == 0)
-		enable = 0;
+		sw->state = enable = 0;
 	else if (strcmp(state, str[1]) == 0)
-		enable = 1;
+		sw->state = enable = 1;
 	else
 		return -EINVAL;
+
 	if (sw->flags & OMAP_GPIO_SWITCH_FLAG_INVERTED)
 		enable = !enable;
 	omap_set_gpio_dataout(sw->gpio, enable);
diff -ruN linux-omap-2.6/arch/arm/plat-omap/Kconfig maemo_src/arch/arm/plat-omap/Kconfig
--- linux-omap-2.6/arch/arm/plat-omap/Kconfig	2011-02-06 20:17:25.233333272 -0500
+++ maemo_src/arch/arm/plat-omap/Kconfig	2011-02-06 20:12:09.643333273 -0500
@@ -19,6 +19,44 @@
 
 comment "OMAP Feature Selections"
 
+config MACH_OMAP2420_DVFS
+	bool "OMAP2420 DVFS support"
+	depends on PM && ARCH_OMAP2420 && MENELAUS
+	select OMAP_DSP_PAUSING
+	select MMC_PAUSING
+	select ARCH_OMAP2420_DMA_DRAIN
+	select FB_OMAP_PAUSING
+	select SPI_OMAP_PAUSING
+
+menuconfig ARCH_OMAP2420_DEBUG
+	bool "OMAP2420 debug support"
+	depends on ARCH_OMAP2420
+	select DEBUG_FS
+	default y
+
+config ARCH_OMAP2420_OBSERVABILITY
+	tristate "OMAP2420 observability"
+	depends on ARCH_OMAP2420_DEBUG
+	default m
+
+config ARCH_OMAP2420_PEEK_N_POKE
+	tristate "OMAP2420 sysfs memory peek and poke"
+	depends on ARCH_OMAP2420_DEBUG
+	default m
+
+config ARCH_OMAP2420_SNAPSHOT
+	tristate "OMAP2420 sysfs for memory snapshot"
+	depends on ARCH_OMAP2420_DEBUG
+	default m
+
+config ARCH_OMAP2420_DMA_DRAIN
+	bool "OMAP2420 drain DMA buffers"
+	depends on ARCH_OMAP2420
+	help
+	  Makes sure that all the DMA buffers are empty and all ongoing
+	  transfers have completed. Supported only for non sync,
+	  non chained transfers. SW must ensure that irqs are disabled.
+
 config OMAP_DEBUG_DEVICES
 	bool
 	help
@@ -100,6 +138,11 @@
 	  to change the pin multiplexing setup.  When there are no warnings
 	  printed, it's safe to deselect OMAP_MUX for your product.
 
+config OMAP_SEC
+	tristate "OMAP HS secure mode support"
+	depends on ARCH_OMAP16XX || ARCH_OMAP24XX
+	default n
+
 config OMAP_STI
 	bool "STI/XTI support"
 	depends on ARCH_OMAP16XX || ARCH_OMAP24XX
diff -ruN linux-omap-2.6/arch/arm/plat-omap/mailbox.c maemo_src/arch/arm/plat-omap/mailbox.c
--- linux-omap-2.6/arch/arm/plat-omap/mailbox.c	2011-02-06 20:17:25.446666606 -0500
+++ maemo_src/arch/arm/plat-omap/mailbox.c	2011-02-06 20:12:09.646666607 -0500
@@ -71,7 +71,18 @@
 	return ret;
 }
 
-int omap_mbox_msg_send(struct omap_mbox *mbox, mbox_msg_t msg, void* arg)
+int omap_mbox_send_sync(struct omap_mbox *mbox, mbox_msg_t msg, void* arg)
+{
+	int ret = __mbox_msg_send(mbox, msg, arg);
+	if (ret) {
+		enable_mbox_irq(mbox, IRQ_TX);
+		ret = -EAGAIN;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(omap_mbox_send_sync);
+
+int omap_mbox_send(struct omap_mbox *mbox, mbox_msg_t msg, void* arg)
 {
 	struct request *rq;
 	struct request_queue *q = mbox->txq->queue;
@@ -86,11 +97,12 @@
 	rq->data = (void *)msg;
 	blk_insert_request(q, rq, 0, arg);
 
-	schedule_work(&mbox->txq->work);
+	if (mbox_queue_ok(mbox->txq))
+		queue_work(mbox->txq->wq, &mbox->txq->work);
  fail:
 	return ret;
 }
-EXPORT_SYMBOL(omap_mbox_msg_send);
+EXPORT_SYMBOL(omap_mbox_send);
 
 static void mbox_tx_work(struct work_struct *work)
 {
@@ -101,6 +113,9 @@
 	struct omap_mbox *mbox = mq->queue->queuedata;
 	struct request_queue *q = mbox->txq->queue;
 
+	if (!mbox_queue_ok(mbox->txq))
+		return;
+
 	while (1) {
 		spin_lock(q->queue_lock);
 		rq = elv_next_request(q);
@@ -173,7 +188,8 @@
 {
 	disable_mbox_irq(mbox, IRQ_TX);
 	ack_mbox_irq(mbox, IRQ_TX);
-	schedule_work(&mbox->txq->work);
+	if (mbox_queue_ok(mbox->txq))
+		queue_work(mbox->txq->wq, &mbox->txq->work);
 }
 
 static void __mbox_rx_interrupt(struct omap_mbox *mbox)
@@ -206,8 +222,9 @@
 	/* no more messages in the fifo. clear IRQ source. */
 	ack_mbox_irq(mbox, IRQ_RX);
 	enable_mbox_irq(mbox, IRQ_RX);
-	nomem:
-	schedule_work(&mbox->rxq->work);
+ nomem:
+	if (mbox_queue_ok(mbox->rxq))
+		queue_work(mbox->rxq->wq, &mbox->rxq->work);
 }
 
 static irqreturn_t mbox_interrupt(int irq, void *p)
@@ -235,7 +252,7 @@
 	struct omap_mbox *mbox = dev_get_drvdata(dev);
 
 	for (; count >= sizeof(mbox_msg_t); count -= sizeof(mbox_msg_t)) {
-		ret = omap_mbox_msg_send(mbox, be32_to_cpu(*p), NULL);
+		ret = omap_mbox_send(mbox, be32_to_cpu(*p), NULL);
 		if (ret)
 			return -EAGAIN;
 		p++;
@@ -308,20 +325,29 @@
 
 	q = blk_init_queue(proc, &mq->lock);
 	if (!q)
-		goto error;
+		goto fail_rq;
 	q->queuedata = mbox;
 	mq->queue = q;
 
 	INIT_WORK(&mq->work, work);
+	mq->wq = create_workqueue(mbox->name);
+	if (!mq->wq)
+		goto fail_wq;
+	mq->state = MBOX_QUEUE_READY;
 
 	return mq;
-error:
+
+fail_wq:
+	blk_cleanup_queue(mq->queue);
+fail_rq:
 	kfree(mq);
 	return NULL;
 }
 
 static void mbox_queue_free(struct omap_mbox_queue *q)
 {
+	q->state = MBOX_QUEUE_SUSPEND;
+	destroy_workqueue(q->wq);
 	blk_cleanup_queue(q->queue);
 	kfree(q);
 }
@@ -445,6 +471,10 @@
 }
 EXPORT_SYMBOL(omap_mbox_put);
 
+static void mbox_release(struct device * dev)
+{
+}
+
 int omap_mbox_register(struct omap_mbox *mbox)
 {
 	int ret = 0;
@@ -455,6 +485,8 @@
 	if (mbox->next)
 		return -EBUSY;
 
+	mbox->dev.release = mbox_release;
+
 	write_lock(&mboxes_lock);
 	tmp = find_mboxes(mbox->name);
 	if (*tmp)
diff -ruN linux-omap-2.6/arch/arm/plat-omap/Makefile maemo_src/arch/arm/plat-omap/Makefile
--- linux-omap-2.6/arch/arm/plat-omap/Makefile	2011-02-06 20:17:25.289999939 -0500
+++ maemo_src/arch/arm/plat-omap/Makefile	2007-10-02 03:09:30.000000000 -0400
@@ -19,7 +19,9 @@
 
 obj-$(CONFIG_OMAP_MCBSP) += mcbsp.o
 
+ifndef CONFIG_MACH_OMAP2420_DVFS
 obj-$(CONFIG_CPU_FREQ) += cpu-omap.o
+endif
 obj-$(CONFIG_OMAP_DM_TIMER) += dmtimer.o
 obj-$(CONFIG_OMAP_BOOT_REASON) += bootreason.o
 obj-$(CONFIG_OMAP_COMPONENT_VERSION) += component-version.o
@@ -35,3 +37,7 @@
 
 # DSP subsystem
 obj-y += dsp/
+
+# HS
+obj-$(CONFIG_OMAP_SEC) += omap_sec.o
+omap_sec-objs += pa.o sec.o
diff -ruN linux-omap-2.6/arch/arm/plat-omap/mmu.c maemo_src/arch/arm/plat-omap/mmu.c
--- linux-omap-2.6/arch/arm/plat-omap/mmu.c	2011-02-06 20:17:25.456666607 -0500
+++ maemo_src/arch/arm/plat-omap/mmu.c	2011-02-06 20:12:09.596666607 -0500
@@ -3,27 +3,29 @@
  *
  * OMAP MMU management framework
  *
- * Copyright (C) 2002-2006 Nokia Corporation
+ * Copyright (C) 2002-2007 Nokia Corporation
+ *
+ * Contact: Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
  *
  * Written by Toshihiro Kobayashi <toshihiro.kobayashi@nokia.com>
  *        and Paul Mundt <lethal@linux-sh.org>
  *
- * TWL support: Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
  *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
  */
+
 #include <linux/module.h>
 #include <linux/mempool.h>
 #include <linux/init.h>
@@ -1037,6 +1039,8 @@
 
 	if (likely(reset))
 		omap_mmu_reset(mmu);
+	omap_mmu_write_reg(mmu, omap_mmu_read_reg(mmu,MMU_SYSCONFIG) |
+			   (1 << 0), MMU_SYSCONFIG);
 
 	if (mmu->ops->pte_get_attr) {
 		omap_mmu_write_reg(mmu, pa, MMU_TTB);
@@ -1110,7 +1114,11 @@
 	if (unlikely(mmu->ops->mem_enable))
 		return mmu->ops->mem_enable(mmu, addr);
 
-	down_read(&mmu->exmap_sem);
+	mutex_lock(&mmu->deadlock_skipper);
+	if (mmu->deadlock_counter == 0)
+		down_read(&mmu->exmap_sem);
+	mmu->deadlock_counter++;
+	mutex_unlock(&mmu->deadlock_skipper);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(omap_mmu_mem_enable);
@@ -1122,7 +1130,12 @@
 		return;
 	}
 
-	up_read(&mmu->exmap_sem);
+	mutex_lock(&mmu->deadlock_skipper);
+	mmu->deadlock_counter--;
+	if (mmu->deadlock_counter == 0)
+		up_read(&mmu->exmap_sem);
+	BUG_ON(mmu->deadlock_counter < 0);
+	mutex_unlock(&mmu->deadlock_skipper);
 }
 EXPORT_SYMBOL_GPL(omap_mmu_mem_disable);
 
@@ -1471,6 +1484,8 @@
 		goto err_dev_register;
 
 	init_rwsem(&mmu->exmap_sem);
+	mmu->deadlock_counter = 0;
+	mutex_init(&mmu->deadlock_skipper);
 
 	ret = omap_mmu_read_reg(mmu, MMU_REVISION);
 	printk(KERN_NOTICE "MMU: OMAP %s MMU initialized (HW v%d.%d)\n",
diff -ruN linux-omap-2.6/arch/arm/plat-omap/pa.c maemo_src/arch/arm/plat-omap/pa.c
--- linux-omap-2.6/arch/arm/plat-omap/pa.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/plat-omap/pa.c	2011-02-06 20:12:09.523333273 -0500
@@ -0,0 +1,658 @@
+/*
+ * linux/arch/arm/plat-omap/pa.c
+ *
+ * Copyright (C) 2007 Nokia Corporation
+ * Author: Sami Tolvanen
+ * Maintainer: Timo O. Karjalainen <timo.o.karjalainen@nokia.com>
+ *
+ * OMAP HS protected application (PA) format handling
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <asm/arch/pa.h>
+#include <asm/arch/sec.h>
+
+MODULE_LICENSE("GPL v2");
+
+#define PA_NAME			"omap2_pa"
+#define PA_FMT_MAGIC		0x4D464150
+#define PA_MAX_NCMD		128
+
+enum {
+	PA_TYPE_DATA,
+	PA_TYPE_PTR_VIRT,
+	PA_TYPE_PTR_PHYS,
+	PA_TYPE_PTR_KEYS,
+	PA_TYPE_PTR_PAPUB,
+};
+
+enum {
+	PA_IO_NORMAL,
+	PA_IO_RESERVED,
+	PA_IO_DEFOUT,
+	PA_IO_SIZE_VAL,
+	PA_IO_SIZE_PAR,
+	PA_IO_ONLY,
+};
+
+struct pa_format_header {
+	u32 magic;
+	u32 ncmd;
+};
+
+struct pa_image_toc_entry {
+	u32 start;
+	u32 size;
+	u32 spare0;
+	u32 spare1;
+	u32 spare2;
+	u8 filename[12];
+};
+
+struct pa_format_entry {
+	u32 type;
+	u32 size;
+	u32 ref;
+	u32 value;
+};
+
+struct pa_par_common {
+	u16 length;
+	u8 index;
+	u8 reserved;
+};
+
+static int error_buffer_size(void)
+{
+	printk(KERN_ERR PA_NAME ": buffer too small\n");
+	return -1;
+}
+
+static int error_format_invalid(void)
+{
+	printk(KERN_ERR PA_NAME ": invalid format\n");
+	return -1;
+}
+
+static int error_entry_invalid(struct pa_format_entry *entry)
+{
+	printk(KERN_ERR PA_NAME ": invalid type %u for ref %u\n",
+		entry->type, entry->ref);
+	return -1;
+}
+
+static int error_entry_unsupported(struct pa_format_entry *entry)
+{
+	printk(KERN_ERR PA_NAME ": unsupported type %u\n", entry->type);
+	return -1;
+}
+
+static int error_entry_reference(struct pa_format_entry *entry)
+{
+	printk(KERN_ERR PA_NAME ": invalid parameter reference %u\n",
+		entry->value);
+	return -1;
+}
+
+static int buffer_skip(u8 **buf, u8 *end, u32 size)
+{
+	if (end < *buf + size)
+		return error_buffer_size();
+	*buf += size;
+	return 0;
+}
+
+static int buffer_copy(u8 **buf, u8 *end, void *data, u32 size)
+{
+	if (end < *buf + size)
+		return error_buffer_size();
+	memcpy(*buf, data, size);
+	*buf += size;
+	return 0;
+}
+
+static int buffer_move(u8 **dbuf, u8 *dend, u8 **sbuf, u8 *send, u32 size)
+{
+	if (dend < *dbuf + size || send < *sbuf + size)
+		return error_buffer_size();
+	memcpy(*dbuf, *sbuf, size);
+	*dbuf += size;
+	*sbuf += size;
+	return 0;
+}
+
+static inline int buffer_aligned(u8 *ptr)
+{
+	return ((u32) ptr % sizeof(ptr) == 0);
+}
+
+void *pa_image_address(u8 *base, struct pa_format_command *cmd)
+{
+	const struct pa_image_toc_entry *p;
+
+	for (p = (void *) base; p->filename[0] != 0xFF; ++p) {
+		if (!strcmp(cmd->filename, p->filename))
+			return base + p->start;
+	}
+
+	return NULL;
+}
+EXPORT_SYMBOL(pa_image_address);
+
+void pa_format_free(struct pa_format *p)
+{
+	kfree(p->cmd);
+	memset(p, 0, sizeof(*p));
+}
+EXPORT_SYMBOL(pa_format_free);
+
+int pa_format_parse(u8 *base, u32 size, struct pa_format *p)
+{
+	struct pa_format_header *hdr = (struct pa_format_header *) base;
+	struct pa_command *c;
+	u32 i;
+	u8 *end = base + size;
+
+	if (hdr->magic != PA_FMT_MAGIC || hdr->ncmd > PA_MAX_NCMD)
+		return error_format_invalid();
+
+	if (buffer_skip(&base, end, sizeof(*hdr)) < 0)
+		return -1;
+
+	p->ncmd = hdr->ncmd;
+	p->cmd  = kzalloc(p->ncmd * sizeof(*p->cmd), GFP_KERNEL);
+
+	if (!p->cmd)
+		return -ENOMEM;
+
+	for (i = 0; i < p->ncmd; ++i) {
+		c = &p->cmd[i];
+		c->cmd = (struct pa_format_command *) base;
+
+		if (buffer_skip(&base, end, sizeof(*c->cmd)) < 0)
+			goto err;
+
+		c->par = (struct pa_format_entry *) base;
+		if (buffer_skip(&base, end, c->cmd->npar * sizeof(*c->par)) < 0)
+			goto err;
+
+		c->res = (struct pa_format_entry *) base;
+		if (buffer_skip(&base, end, c->cmd->nres * sizeof(*c->res)) < 0)
+			goto err;
+	}
+
+	return 0;
+
+err:	
+	pa_format_free(p);
+	return -1;
+}
+EXPORT_SYMBOL(pa_format_parse);
+
+static inline void copy_value(u32 *dst, u8 *src, u32 n)
+{
+	memcpy(dst, src, n);
+#ifdef __BIG_ENDIAN /* Preserve the numeric value */
+	*dst >>= (sizeof(*dst) - n) << 3;
+#endif
+}
+
+static int entry_io_size(struct pa_format_entry *p, int n, struct pa_command *c, u8 *input,
+		u32 cinp, u32 *size);
+
+static int entry_input_value(struct pa_command *c, u32 n, u8 *input, u32 cinp,
+		u32 *value)
+{
+	struct pa_format_entry *entry = &c->par[n];
+	u32 i, size;
+	u8 *end = input + cinp;
+	*value = 0;
+
+	if (entry->type != PA_TYPE_DATA || entry->size > sizeof(*value))
+		return error_entry_invalid(entry);
+
+	for (i = 0; i < n; ++i) {
+		if (entry_io_size(c->par, i, c, input, cinp, &size) < 0)
+			return -1;
+		if (buffer_skip(&input, end, size) < 0)
+			return -1;
+	}
+
+	if (end < input + entry->size)
+		return error_buffer_size();
+
+	copy_value(value, input, entry->size);
+	return 0;
+}
+
+static int entry_io_size(struct pa_format_entry *p, int n, struct pa_command *c,
+			 u8 *input, u32 cinp, u32 *size)
+{
+	struct pa_format_entry *entry = &p[n];
+
+	*size = 0;
+
+	switch (entry->ref) {
+	default:
+		if (entry->type == PA_TYPE_DATA ||
+		    entry->type == PA_TYPE_PTR_VIRT ||
+		    entry->type == PA_TYPE_PTR_PHYS)
+			*size = entry->size;
+		break;
+	case PA_IO_RESERVED:
+		if (entry->type != PA_TYPE_DATA)
+			return error_entry_invalid(entry);
+		break;
+	case PA_IO_ONLY:
+		if (entry->type != PA_TYPE_DATA)
+			return error_entry_invalid(entry);
+		*size = entry->size;
+		break;
+	case PA_IO_SIZE_VAL:
+		if (entry->type != PA_TYPE_PTR_VIRT &&
+		    entry->type != PA_TYPE_PTR_PHYS)
+			return error_entry_invalid(entry);
+		if (p == c->par && n <= entry->value)
+			return error_entry_reference(entry);
+		if (entry_input_value(c, entry->value, input, cinp, size) < 0)
+			return -1;
+		*size += entry->size;
+		break;
+	case PA_IO_SIZE_PAR:
+		if (entry->type != PA_TYPE_PTR_VIRT &&
+		    entry->type != PA_TYPE_PTR_PHYS)
+			return error_entry_invalid(entry);
+		if (c->cmd->npar < entry->value)
+			return error_entry_reference(entry);
+		if (entry_io_size(c->par, entry->value, c, input, cinp,
+				size) < 0)
+			return -1;
+		*size += entry->size;
+		break;
+	}
+	return 0;
+}
+
+static int command_io_size(struct pa_command *c, u8 *buf, u32 bufsize,
+			   u32 *mininp, u32 *maxout)
+{
+	u32 i, size;
+
+	*mininp = 0;
+	*maxout = 0;
+
+	for (i = 0; i < c->cmd->npar; ++i) {
+		if (entry_io_size(c->par, i, c, buf, bufsize, &size) < 0)
+			return -1;
+		*mininp += size;
+	}
+
+	for (i = 0; i < c->cmd->nres; ++i) {
+		if (entry_io_size(c->res, i, c, buf, bufsize, &size) < 0)
+			return -1;
+		*maxout += size;
+	}
+
+	return 0;
+}
+
+static struct pa_command *command_find(u32 cmd, struct pa_format *p)
+{
+	u32 i;
+
+	for (i = 0; i < p->ncmd; ++i)
+		if (p->cmd[i].cmd->cmd == cmd)
+			return &p->cmd[i];
+
+	return NULL;
+}
+
+int pa_command_query(u32 cmd, u8 *input, u32 cinp, u32 *mininp, u32 *maxout,
+		     struct pa_format *p)
+{
+	struct pa_command *c = command_find(cmd, p);
+
+	if (!c)
+		return -1;
+
+	return command_io_size(c, input, cinp, mininp, maxout);
+}
+EXPORT_SYMBOL(pa_command_query);
+
+static u32 entry_size(struct pa_format_entry *entry)
+{
+	if (entry->type != PA_TYPE_DATA)
+		return sizeof(u8 *);
+
+	if (entry->ref != PA_IO_ONLY)
+		return entry->size;
+
+	return 0;
+}
+
+static void command_size(struct pa_command *c, u32 *cpar, u32 *cres)
+{
+	u32 i;
+
+	*cpar = 0;
+	*cres = 0;
+
+	for (i = 0; i < c->cmd->npar; ++i)
+		*cpar += entry_size(&c->par[i]);
+
+	for (i = 0; i < c->cmd->nres; ++i)
+		*cres += entry_size(&c->res[i]);
+}
+
+static int prepare_par_data(struct pa_command_data *p, u32 n, u8 **ppos,
+			    u8 *pend, u8 **ipos, u8 *iend)
+{
+	struct pa_format_entry *entry = &p->c->par[n];
+
+	if (entry->ref == PA_IO_ONLY)
+		return buffer_skip(ipos, iend, entry->size);
+
+	if (entry->ref == PA_IO_RESERVED)
+		return buffer_copy(ppos, pend, &entry->value, entry->size);
+
+	return buffer_move(ppos, pend, ipos, iend, entry->size);
+}
+
+static int prepare_entry_ptr(struct pa_command_data *p,
+			     struct pa_format_entry *entry,
+			     u32 n, u8 **epos, u8 *eend, u8 **spos, u8 *send)
+{
+	u32 size;
+	u8 *buf = *spos;
+
+	if (entry_io_size(entry, n, p->c, p->input, p->cinp, &size) < 0)
+		return -1;
+
+	/* Pointers passed to secure mode must be word-aligned */
+	if (!buffer_aligned(buf)) {
+		if (buffer_skip(&buf, send, size) < 0)
+			return -1;
+		buf = kmalloc(size, GFP_KERNEL);
+		if (!buf)
+			return -ENOMEM;
+		memcpy(buf, *spos, size);
+	}
+
+	if (entry[n].type == PA_TYPE_PTR_PHYS)
+		buf = p->vtp(buf);
+
+	if (buffer_copy(epos, eend, &buf, sizeof(buf)) < 0 ||
+	    buffer_skip(spos, send, size) < 0)
+		return -1;
+
+	return 0;
+}
+
+static int prepare_par(struct pa_command_data *p)
+{
+	int rv = 0;
+	struct pa_par_common *sp = (struct pa_par_common *) p->par;
+	u32 i;
+	u8 *ipos = p->input;
+	u8 *iend = p->input + p->cinp;
+	u8 *ppos = p->par + sizeof(*sp);
+	u8 *pend = ppos + p->cpar;
+
+	sp->length = p->cpar + sizeof(*sp);
+	sp->index  = p->c->cmd->index;
+
+	for (i = 0; i < p->c->cmd->npar && !rv; ++i) {
+		switch (p->c->par[i].type) {
+		default:
+			return error_entry_unsupported(&p->c->par[i]);
+		case PA_TYPE_DATA:
+			rv = prepare_par_data(p, i, &ppos, pend, &ipos, iend);
+			break;
+		case PA_TYPE_PTR_VIRT:
+		case PA_TYPE_PTR_PHYS:
+			rv = prepare_entry_ptr(p, p->c->par, i, &ppos, pend,
+				&ipos, iend);
+			break;
+		case PA_TYPE_PTR_KEYS:
+			if (!p->keys)
+				return -1;
+			rv = buffer_copy(&ppos, pend, &p->keys,
+				sizeof(p->keys));
+			break;
+		case PA_TYPE_PTR_PAPUB:
+			if (!p->papub)
+				return -1;
+			rv = buffer_copy(&ppos, pend, &p->papub,
+				sizeof(p->papub));
+			break;
+		}
+	}
+
+	return rv;
+}
+
+static int prepare_res_data(struct pa_command_data *p, u32 n, u8 **rpos,
+			    u8 *rend, u8 **opos, u8 *oend)
+{
+	struct pa_format_entry *entry = &p->c->res[n];
+
+	if (entry->ref == PA_IO_RESERVED)
+		return buffer_copy(rpos, rend, &entry->value, entry->size);
+
+	if (entry->ref == PA_IO_DEFOUT) {
+		if (buffer_skip(opos, oend, entry->size) < 0 ||
+		    buffer_copy(rpos, rend, &entry->value, entry->size) < 0)
+			return -1;
+
+		return 0;
+	}
+
+	if (buffer_skip(opos, oend, entry->size) < 0 ||
+	    buffer_skip(rpos, rend, entry->size) < 0)
+		return -1;
+
+	return 0;
+}
+
+static int prepare_res(struct pa_command_data *p)
+{
+	int rv = 0;
+	u32 i;
+	u8 *opos = p->output;
+	u8 *oend = p->output + p->coup;
+	u8 *rpos = p->res + sizeof(struct sec_result);
+	u8 *rend = rpos + p->cres;
+
+	for (i = 0; i < p->c->cmd->nres && !rv; ++i) {
+		switch (p->c->res[i].type) {
+		default:
+			return error_entry_unsupported(&p->c->res[i]);
+		case PA_TYPE_DATA:
+			rv = prepare_res_data(p, i, &rpos, rend, &opos, oend);
+			break;
+		case PA_TYPE_PTR_VIRT:
+		case PA_TYPE_PTR_PHYS:
+			rv = prepare_entry_ptr(p, p->c->res, i, &rpos, rend,
+				&opos, oend);
+			break;
+		}
+	}
+
+	return rv;
+}
+
+static int finish_par_data(struct pa_command_data *p, u32 n, u8 **ppos,
+			   u8 *pend, u8 **ipos, u8 *iend)
+{
+	struct pa_format_entry *entry = &p->c->par[n];
+
+	if (entry->ref == PA_IO_ONLY)
+		return buffer_skip(ipos, iend, entry->size);
+
+	if (entry->ref == PA_IO_RESERVED)
+		return buffer_skip(ppos, pend, entry->size);
+
+	if  (buffer_skip(ppos, pend, entry->size) < 0 ||
+	     buffer_skip(ipos, iend, entry->size) < 0)
+		return -1;
+
+	return 0;
+}
+
+static int finish_entry_ptr(struct pa_command_data *p,
+			    struct pa_format_entry *entry, u32 n,
+			    u8 **epos, u8 *eend, u8 **spos, u8 *send, int copy)
+{
+	u32 size;
+	u8 *buf = *(u8 **) *epos;
+
+	if (entry_io_size(entry, n, p->c, p->input, p->cinp, &size) < 0)
+		return -1;
+
+	if (buf) {
+		if (entry[n].type == PA_TYPE_PTR_PHYS)
+			buf = p->ptv(buf);
+
+		if (buf != *spos) {
+			if (copy)
+				memcpy(*spos, buf, size);
+			kfree(buf);
+		}
+	}
+
+	if (buffer_skip(epos, eend, sizeof(buf)) < 0 ||
+	    buffer_skip(spos, send, size) < 0)
+		return -1;
+
+	return 0;
+}
+
+static int finish_par(struct pa_command_data *p)
+{
+	int rv = 0;
+	u32 i;
+	u8 *ipos = p->input;
+	u8 *iend = p->input + p->cinp;
+	u8 *ppos = p->par + sizeof(struct pa_par_common);
+	u8 *pend = ppos + p->cpar;
+
+	for (i = 0; i < p->c->cmd->npar && !rv; ++i) {
+		switch (p->c->par[i].type) {
+		default:
+			return error_entry_unsupported(&p->c->par[i]);
+		case PA_TYPE_DATA:
+			rv = finish_par_data(p, i, &ppos, pend, &ipos, iend);
+			break;
+		case PA_TYPE_PTR_VIRT:
+		case PA_TYPE_PTR_PHYS:
+			rv = finish_entry_ptr(p, p->c->par, i, &ppos, pend,
+				&ipos, iend, 0);
+			break;
+		case PA_TYPE_PTR_KEYS:
+		case PA_TYPE_PTR_PAPUB:
+			rv = buffer_skip(&ppos, pend, sizeof(u8 *));
+			break;
+		}
+	}
+
+	return rv;
+}
+
+static int finish_res_data(struct pa_command_data *p, u32 n, u8 **rpos,
+			   u8 *rend, u8 **opos, u8 *oend)
+{
+	struct pa_format_entry *entry = &p->c->res[n];
+
+	if (entry->ref == PA_IO_RESERVED)
+		return buffer_skip(rpos, rend, entry->size);
+
+	return buffer_move(opos, oend, rpos, rend, entry->size);
+}
+
+static int finish_res(struct pa_command_data *p)
+{
+	int rv = 0;
+	u32 i;
+	u8 *opos = p->output;
+	u8 *oend = p->output + p->coup;
+	u8 *rpos = p->res + sizeof(struct sec_result);
+	u8 *rend = rpos + p->cres;
+
+	for (i = 0; i < p->c->cmd->nres && !rv; ++i) {
+		switch (p->c->res[i].type) {
+		default:
+			return error_entry_unsupported(&p->c->res[i]);
+		case PA_TYPE_DATA:
+			rv = finish_res_data(p, i, &rpos, rend, &opos, oend);
+			break;
+		case PA_TYPE_PTR_VIRT:
+		case PA_TYPE_PTR_PHYS:
+			rv = finish_entry_ptr(p, p->c->res, i, &rpos, rend,
+				&opos, oend, 1);
+			break;
+		}
+	}
+
+	return rv;
+}
+
+int pa_command_prepare(u32 cmd, struct pa_command_data *p)
+{
+	int rv = -ENOMEM;
+
+	p->c = command_find(cmd, p->format);
+	if (!p->c)
+		return -1;
+
+	command_size(p->c, &p->cpar, &p->cres);
+
+	p->par = kzalloc(p->cpar + sizeof(struct pa_par_common), GFP_KERNEL);
+	p->res = kzalloc(p->cres + sizeof(struct sec_result), GFP_KERNEL);
+
+	if (!p->par || !p->res)
+		goto out;
+
+	rv = prepare_par(p);
+	if (rv < 0)
+		goto out;
+
+	rv = prepare_res(p);
+	if (rv < 0)
+		goto out;
+
+	return 0;
+out:
+	if (p->par) {
+		finish_par(p);
+		kfree(p->par);
+	}
+	if (p->res) {
+		finish_res(p);
+		kfree(p->res);
+	}
+	memset(p, 0, sizeof(*p));
+	return rv;
+}
+EXPORT_SYMBOL(pa_command_prepare);
+
+int pa_command_finish(struct pa_command_data *p)
+{
+	int rv = 0;
+
+	if (finish_par(p) < 0)
+		rv = -1;
+	if (finish_res(p) < 0)
+		rv = -1;
+
+	kfree(p->res);
+	kfree(p->par);
+	memset(p, 0, sizeof(*p));
+	return rv;
+}
+EXPORT_SYMBOL(pa_command_finish);
diff -ruN linux-omap-2.6/arch/arm/plat-omap/sec.c maemo_src/arch/arm/plat-omap/sec.c
--- linux-omap-2.6/arch/arm/plat-omap/sec.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/arch/arm/plat-omap/sec.c	2011-02-06 20:12:09.593333274 -0500
@@ -0,0 +1,697 @@
+/*
+ * linux/arch/arm/plat-omap/sec.c
+ *
+ * Copyright (C) 2007 Nokia Corporation
+ * Author: Sami Tolvanen
+ * Maintainer: Timo O. Karjalainen <timo.o.karjalainen@nokia.com>
+ *
+ * OMAP HS secure mode driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/poll.h>
+#include <linux/stat.h>
+#include <asm/arch/sec.h>
+
+MODULE_LICENSE("GPL v2");
+
+#define SEC_NAME		"omap_sec"
+
+#define SEC_MAX_DATA_SIZE	4096
+#define SEC_MAX_OBUF_SIZE	16384
+
+#define SECS_SLOTS		2	/* Max. simultaneous SEC_CMD_SECS */
+
+struct sec_status {
+	struct mutex lock;
+	u32 cmd;		/* Command identifier */
+	struct sec_cmd_header param;
+	u8 *ip;			/* Input pointer */
+	u8 *data;		/* Parameter data */
+	u8 *obuf;		/* Output buffer */
+	u8 *rp;			/* Read position */
+	u8 *wp;			/* Write position */
+	u8 *end;
+	wait_queue_head_t inq;
+	wait_queue_head_t outq;
+};
+
+struct sec_device {
+	struct mutex lock; /* For secsd */
+	struct sec_status *secsd[SECS_SLOTS];
+	struct device dev;
+	struct miscdevice misc_dev;
+};
+
+struct sec {
+	struct mutex lock;
+	struct sec_operations *ops;
+};
+
+static int sec_minor = MISC_DYNAMIC_MINOR;
+static struct sec_device dev;
+static struct sec sec;
+
+module_param(sec_minor, uint, S_IRUGO);
+
+/*
+ * Treats ss->obuf as a circular buffer and copies size bytes of data
+ * to it starting from ss->wp. Doesn't care if ss->rp overflows.
+ */
+static void obufcpy(struct sec_status *ss, void *src, size_t size)
+{
+	size_t count;
+
+	if (ss->wp == ss->end)
+		ss->wp = ss->obuf;
+
+	count = min(size, (size_t) (ss->end - ss->wp));
+
+	memcpy(ss->wp, src, count);
+	ss->wp += count;
+
+	if (count < size)
+		obufcpy(ss, src + count, size - count);
+}
+
+static void reset_status(struct sec_status *ss)
+{
+	if (ss->data) {
+		kfree(ss->data);
+		ss->data = NULL;
+	}
+	if (ss->obuf) {
+		kfree(ss->obuf);
+		ss->obuf = NULL;
+	}
+	ss->cmd = SEC_CMD_NONE;
+	ss->ip   = (u8 *) &ss->param;
+	ss->rp   = NULL;
+	ss->wp   = NULL;
+	ss->end  = NULL;
+}
+
+static void *set_obuf(struct sec_status *ss, size_t size)
+{
+	if (ss->obuf) {
+		kfree(ss->obuf);
+		ss->obuf = NULL;
+		ss->rp   = NULL;
+		ss->wp   = NULL;
+		ss->end  = NULL;
+	}
+
+	if (size > SEC_MAX_OBUF_SIZE)
+		return NULL;
+
+	ss->obuf = kzalloc(size, GFP_KERNEL);
+
+	if (ss->obuf) {
+		ss->rp  = ss->obuf;
+		ss->wp  = ss->obuf;
+		ss->end = ss->obuf + size;
+	}
+
+	return ss->obuf;
+}
+
+/*
+ * Copies ss->obuf contents to user space from ss->rp to ss->wp (at most). This
+ * never blocks the reading process and assumes there is data to read. Once all
+ * data has been read, the command for the descriptor is completed and if there
+ * are any processes waiting to write another command, they are woken up.
+ */
+static ssize_t read_obuf(struct sec_status *ss, char __user *buf, size_t count)
+{
+	ssize_t rv = -EIO;
+
+	if (ss->wp <= ss->rp)
+		goto done;
+
+	count = min(count, (size_t) (ss->wp - ss->rp));
+
+	if (copy_to_user(buf, ss->rp, count)) {
+		rv = -EFAULT;
+		goto done;
+	}
+
+	ss->rp += count;
+	rv = count;
+
+	if (ss->wp == ss->rp)
+		goto done;
+
+	mutex_unlock(&ss->lock);
+	return rv;
+
+done:	/* Command completed, wake up any pending writers */
+	reset_status(ss);
+	wake_up_interruptible(&ss->inq);
+	mutex_unlock(&ss->lock);
+	return rv;
+}
+
+/*
+ * Treats ss->obuf as a circular buffer, copies available contents to user
+ * space and blocks if nothing is available. SEC_CMD_SECS never completes.
+ */
+static ssize_t read_secs(struct file *filp, struct sec_status *ss,
+			 char __user *buf, size_t count)
+{
+	/* Block until there is data in the output buffer */
+	while (ss->wp == ss->rp) {
+		mutex_unlock(&ss->lock);
+
+		if (filp->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+
+		if (wait_event_interruptible(ss->outq, (ss->wp != ss->rp)))
+			return -ERESTARTSYS;
+
+		if (mutex_lock_interruptible(&ss->lock))
+			return -ERESTARTSYS;
+	}
+
+	if (ss->rp == ss->end)
+		ss->rp = ss->obuf;
+
+	if (ss->wp > ss->rp)
+		count = min(count, (size_t) (ss->wp  - ss->rp));
+	else
+		count = min(count, (size_t) (ss->end - ss->rp));
+
+	if (copy_to_user(buf, ss->rp, count)) {
+		mutex_unlock(&ss->lock);
+		return -EFAULT;
+	}
+
+	ss->rp += count;
+
+	mutex_unlock(&ss->lock);
+	return count;
+}
+
+/* Reads command-specific results from ss->obuf, blocks if nothing to read */
+static ssize_t sec_read(struct file *filp, char __user *buf, size_t count,
+			loff_t *f_pos)
+{
+	struct sec_status *ss = (struct sec_status *) filp->private_data;
+
+	if (mutex_lock_interruptible(&ss->lock))
+		return -ERESTARTSYS;
+
+	/*
+	 * There is always something to read when we have a command, or the
+	 * command-specific read function does the blocking.
+	 */
+	while (ss->cmd == SEC_CMD_NONE) {
+		mutex_unlock(&ss->lock);
+
+		if (filp->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+
+		if (wait_event_interruptible(ss->outq, (ss->cmd != SEC_CMD_NONE)))
+			return -ERESTARTSYS;
+
+		if (mutex_lock_interruptible(&ss->lock))
+			return -ERESTARTSYS;
+	}
+
+	if (ss->cmd == SEC_CMD_SECS)
+		return read_secs(filp, ss, buf, count);
+	else
+		return read_obuf(ss, buf, count);
+}
+
+/*
+ * Writes secure storage buffer contents to the ss->obuf for those processes
+ * who have requested it (SEC_CMD_SECS). If the ss->obuf buffer is full, simply
+ * skip the process.
+ */
+void sec_storage_write(void *storage, u32 size)
+{
+	int i;
+	size_t space, output_size;
+	struct sec_status *ss;
+
+	output_size = sizeof(size) + size;
+	mutex_lock(&dev.lock);
+
+	for (i = 0; i < SECS_SLOTS; ++i) {
+ 		ss = dev.secsd[i];
+
+		if (!ss || !ss->obuf)
+			continue;
+
+		mutex_lock(&ss->lock);
+
+		/* Rewind to replace the first unread block */
+		if (ss->wp > ss->rp) {
+			while ((ss->wp - ss->rp) > output_size)
+				ss->wp -= output_size;
+
+			space = (ss->end - ss->wp) + (ss->rp - ss->obuf);
+		} else if (ss->wp < ss->rp) {
+			while ((ss->wp - ss->obuf) > output_size)
+				ss->wp -= output_size;
+
+			space = ss->rp - ss->wp;
+		} else {
+			space = ss->end - ss->obuf;
+		}
+
+		if (space >= output_size) {
+			obufcpy(ss, &size, sizeof(size));
+			obufcpy(ss, storage, size);
+			wake_up_interruptible(&ss->outq);
+		}
+
+		mutex_unlock(&ss->lock);
+	}
+
+	mutex_unlock(&dev.lock);
+}
+EXPORT_SYMBOL(sec_storage_write);
+
+static int check_cmd_arg_length(size_t got, size_t shouldhave)
+{
+	if (got > shouldhave)
+		return -E2BIG;
+
+	if (got < shouldhave)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int process_cmd_init(struct sec_status *ss)
+{
+	struct sec_result *output;
+
+	if (!sec.ops)
+		return -ENODEV;
+
+	output = set_obuf(ss, sizeof(*output));
+	if (!output)
+		return -ENOMEM;
+
+	output->rv = sec.ops->secenv_init(ss->data, ss->param.length);
+	ss->wp += sizeof(output->rv);
+
+	wake_up_interruptible(&ss->outq);
+	return 0;
+}
+
+static int process_cmd_secs(struct sec_status *ss)
+{
+	int rv, i;
+
+	/*
+	 * If >= 2 * sizeof(struct cmd_op_secs), there is always enough space
+	 * for secure storage in the buffer.
+	 */
+	if (!set_obuf(ss, 2 * sizeof(struct sec_cmd_secs_output)))
+		return -ENOMEM;
+
+	/* Set the descriptor to receive secure storage contents. */
+	rv = -EBUSY;
+	mutex_lock(&dev.lock);
+
+	for (i = 0; i < SECS_SLOTS; ++i) {
+		if (!dev.secsd[i]) {
+			dev.secsd[i] = ss;
+			rv = 0; /* Found a slot */
+			break;
+		}
+	}
+
+	mutex_unlock(&dev.lock);
+
+	/*
+	 * Release any pending writers that may have been competing for
+	 * descriptor access.
+	 */
+	if (!rv)
+		wake_up_interruptible(&ss->inq);
+
+	return rv;
+}
+
+static int process_cmd_random(struct sec_status *ss)
+{
+	int rv;
+	struct sec_result *output;
+	struct sec_cmd_random_args *args = (struct sec_cmd_random_args *)
+					   ss->data;
+
+	if (!sec.ops)
+		return -ENODEV;
+
+	rv = check_cmd_arg_length(ss->param.length, sizeof(*args));
+	if (rv)
+		return rv;
+
+	output = set_obuf(ss, sizeof(*output) + args->len);
+	if (!output)
+		return -ENOMEM;
+
+	output->rv = sec.ops->random_get(output->data, args->len);
+	ss->wp += sizeof(output->rv);
+
+	if (output->rv == SEC_OK)
+		ss->wp += args->len;
+
+	wake_up_interruptible(&ss->outq);
+	return 0;
+}
+
+static int process_cmd_pa(struct sec_status *ss)
+{
+	struct sec_pa_result *output;
+	u32 cpar, cres;
+	int rv;
+
+	if (!sec.ops)
+		return -ENODEV;
+
+	if (SEC_OK != sec.ops->pa_query(ss->cmd, ss->data, ss->param.length,
+					&cpar, &cres))
+		return -EACCES;
+
+	rv = check_cmd_arg_length(ss->param.length, cpar);
+	if (rv)
+		return rv;
+
+	output = set_obuf(ss, sizeof(*output) + cres);
+	if (!output)
+		return -ENOMEM;
+
+	sec.ops->pa_service(ss->cmd, ss->data, ss->param.length, output, cres);
+	ss->wp += sizeof(output->rom_rv);
+
+	if (output->rom_rv == SEC_OK) {
+		ss->wp += sizeof(output->pa_rv);
+
+		if (output->pa_rv == SEC_OK)
+			ss->wp += cres;
+	}
+
+	wake_up_interruptible(&ss->outq);
+	return 0;
+}
+
+static inline int process_cmd(struct sec_status *ss)
+{
+	int rv = -EACCES;
+
+	mutex_lock(&sec.lock);
+	ss->cmd = ss->param.cmd;
+
+	switch (ss->cmd) {
+	case SEC_CMD_INIT:
+		rv = process_cmd_init(ss);
+		break;
+	case SEC_CMD_SECS:
+		rv = process_cmd_secs(ss);
+		break;
+	case SEC_CMD_RANDOM:
+		rv = process_cmd_random(ss);
+		break;
+	default:
+		if (ss->cmd >= SEC_CMD_PA_FIRST)
+			rv = process_cmd_pa(ss);
+		break;
+	}
+
+	mutex_unlock(&sec.lock);
+	return rv;
+}
+
+static ssize_t sec_write(struct file *filp, const char __user *buf,
+			size_t count, loff_t *f_pos)
+{
+	size_t size;
+	ssize_t rv = 0;
+	struct sec_status *ss = (struct sec_status *) filp->private_data;
+
+	if (mutex_lock_interruptible(&ss->lock))
+		return -ERESTARTSYS;
+
+	while (ss->cmd != SEC_CMD_NONE) {
+		if (ss->cmd == SEC_CMD_SECS) {
+			/* This will never complete, no sense in waiting */
+			mutex_unlock(&ss->lock);
+			return -EBUSY;
+		}
+
+		mutex_unlock(&ss->lock);
+
+		if (filp->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+
+		if (wait_event_interruptible(ss->inq, (ss->cmd == SEC_CMD_NONE)))
+			return -ERESTARTSYS;
+
+		if (mutex_lock_interruptible(&ss->lock))
+			return -ERESTARTSYS;
+	}
+
+	/*
+	 * The amount of data we are still expecting to receive before a
+	 * command can be processed.
+	 */
+	if (ss->data)
+		size = ss->param.length  - (size_t) (ss->ip - ss->data);
+	else
+		size = sizeof(ss->param) - (size_t) (ss->ip - (u8 *) &ss->param);
+
+	count = min(count, size);
+
+	if (copy_from_user(ss->ip, buf, count)) {
+		rv = -EFAULT;
+		goto done;
+	}
+
+	ss->ip += count;
+
+	if (size > count)
+		goto done;
+
+	/* Process the command or continue waiting for parameter data */
+	size = ss->param.length;
+
+	if (size > 0 && !ss->data) {
+		if (size > SEC_MAX_DATA_SIZE) {
+			rv = -EFBIG;
+		} else {
+			ss->data = kmalloc(size, GFP_KERNEL);
+
+			if (!ss->data)
+				rv = -ENOMEM;
+
+			/* Continue with the parameter data */
+			ss->ip = ss->data;
+		}
+		goto done;
+	}
+
+	/*
+	 * This blocks the parent process until the secure mode operation
+	 * completes.
+	 */
+	rv = process_cmd(ss);
+
+done:
+	if (rv < 0) {
+		/* Command failed, wake up any pending writers */
+		reset_status(ss);
+		wake_up_interruptible(&ss->inq);
+	} else
+		rv = count;
+
+	mutex_unlock(&ss->lock);
+	return rv;
+}
+
+static unsigned int sec_poll(struct file *filp, struct poll_table_struct *wait)
+{
+	struct sec_status *ss = (struct sec_status *) filp->private_data;
+	unsigned int mask = 0;
+
+	mutex_lock(&ss->lock);
+
+	poll_wait(filp, &ss->inq,  wait);
+	poll_wait(filp, &ss->outq, wait);
+
+	if (ss->cmd == SEC_CMD_NONE)
+		mask |= POLLOUT | POLLWRNORM;
+	else if (ss->obuf && ss->rp != ss->wp)
+		mask |= POLLIN | POLLRDNORM;
+
+	mutex_unlock(&ss->lock);
+	return mask;
+}
+
+static int sec_open(struct inode *inode, struct file *filp)
+{
+	struct sec_status *ss;
+
+	if (!capable(CAP_SYS_RAWIO))
+		return -EPERM;
+
+	ss = kzalloc(sizeof(*ss), GFP_KERNEL);
+	if (!ss)
+		return -ENOMEM;
+
+	mutex_init(&ss->lock);
+	init_waitqueue_head(&ss->inq);
+	init_waitqueue_head(&ss->outq);
+	reset_status(ss);
+
+	filp->private_data = ss;
+	return nonseekable_open(inode, filp);
+}
+
+static int sec_release(struct inode *inode, struct file *filp)
+{
+	int i;
+	struct sec_status *ss = (struct sec_status *) filp->private_data;
+
+	mutex_lock(&ss->lock);
+
+	if (ss->cmd == SEC_CMD_SECS) {
+		/* Release the command slot */
+		mutex_lock(&dev.lock);
+
+		for (i = 0; i < SECS_SLOTS; ++i) {
+			if (dev.secsd[i] == ss) {
+				dev.secsd[i] = NULL;
+				break;
+			}
+		}
+
+		mutex_unlock(&dev.lock);
+	}
+
+	reset_status(ss);
+	kfree(ss);
+
+	return 0;
+}
+
+int sec_register(struct sec_operations *ops)
+{
+	int rv = -EBUSY;
+
+	mutex_lock(&sec.lock);
+
+	if (ops && !sec.ops) {
+		rv = 0;
+		sec.ops = ops;
+	}
+
+	mutex_unlock(&sec.lock);
+	return rv;
+}
+EXPORT_SYMBOL(sec_register);
+
+int sec_unregister(struct sec_operations *ops)
+{
+	int rv = -ENODEV;
+
+	mutex_lock(&sec.lock);
+
+	if (ops && sec.ops == ops) {
+		sec.ops->exit();
+		sec.ops = NULL;
+		rv = 0;
+	}
+
+	mutex_unlock(&sec.lock);
+	return rv;
+}
+EXPORT_SYMBOL(sec_unregister);
+
+static void sec_sysfs_release(struct device *dev)
+{
+}
+
+struct file_operations sec_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.read		= sec_read,
+	.write		= sec_write,
+	.poll		= sec_poll,
+	.open		= sec_open,
+	.release	= sec_release,
+};
+
+struct device *sec_get_device(void)
+{
+	return &dev.dev;
+};
+EXPORT_SYMBOL(sec_get_device);
+
+	
+static int __init sec_init(void)
+{
+	int rv = -ENODEV;
+
+	printk(KERN_INFO SEC_NAME ": OMAP HS Secure Mode Driver\n");
+
+	memset(&dev, 0, sizeof(dev));
+	memset(&sec, 0, sizeof(sec));
+	mutex_init(&dev.lock);
+	mutex_init(&sec.lock);
+
+	strncpy(dev.dev.bus_id, SEC_NAME, BUS_ID_SIZE);
+	dev.dev.release = sec_sysfs_release;
+
+	rv = device_register(&dev.dev);
+
+	if (rv < 0) {
+		printk(KERN_WARNING SEC_NAME
+			": Error registering sysfs device\n");
+		goto errptr;
+	}
+
+	dev.misc_dev.minor = sec_minor;
+	dev.misc_dev.name  = SEC_NAME;
+	dev.misc_dev.fops  = &sec_fops;
+
+	rv = misc_register(&dev.misc_dev);
+
+	if (rv < 0) {
+		printk(KERN_WARNING SEC_NAME
+			": Error registering misc device\n");
+		goto errdev;
+	}
+
+	return 0;
+
+errdev:
+	device_unregister(&dev.dev);
+errptr:
+	printk(KERN_WARNING SEC_NAME ": Error %d initializing device\n", rv);
+	return rv;
+}
+
+static void __exit sec_exit(void)
+{
+	misc_deregister(&dev.misc_dev);
+	sec_unregister(sec.ops);
+	device_unregister(&dev.dev);
+}
+
+module_init(sec_init);
+module_exit(sec_exit);
diff -ruN linux-omap-2.6/arch/arm/plat-omap/sram.c maemo_src/arch/arm/plat-omap/sram.c
--- linux-omap-2.6/arch/arm/plat-omap/sram.c	2011-02-06 20:17:25.456666607 -0500
+++ maemo_src/arch/arm/plat-omap/sram.c	2011-02-06 20:12:09.463333273 -0500
@@ -31,6 +31,9 @@
 #define OMAP2_SRAM_VA		0xd0000000
 #define OMAP2_SRAM_PUB_VA	0xd0000800
 
+#define OMAP2_SRAM_SECURE_SIZE	(16*1024)
+#define OMAP2_SRAM_TOTAL_SIZE	(640*1024)
+
 #if defined(CONFIG_ARCH_OMAP24XX)
 #define SRAM_BOOTLOADER_SZ	0x00
 #else
@@ -57,6 +60,15 @@
 					 unsigned long pstart_avail,
 					 unsigned long size_avail);
 
+static int omap24xx_is_gp_device(void)
+{
+	int type;
+
+	type = __raw_readl(VA_CONTROL_STAT) & TYPE_MASK;
+
+	return (type == GP_DEVICE) ? 1 : 0;
+}
+
 /*
  * Depending on the target RAMFS firewall setup, the public usable amount of
  * SRAM varies.  The default accessable size for all device types is 2k. A GP
@@ -65,21 +77,18 @@
  */
 static int is_sram_locked(void)
 {
-	int type = 0;
-
-	if (cpu_is_omap242x())
-		type = __raw_readl(VA_CONTROL_STAT) & TYPE_MASK;
-
-	if (type == GP_DEVICE) {
-		/* RAMFW: R/W access to all initators for all qualifier sets */
-		if (cpu_is_omap242x()) {
+	if (cpu_is_omap242x()) {
+		if (omap24xx_is_gp_device ()) {
+			/* RAMFW: R/W access to all initators for all qualifier sets */
 			__raw_writel(0xFF, VA_REQINFOPERM0); /* all q-vects */
 			__raw_writel(0xCFDE, VA_READPERM0);  /* all i-read */
 			__raw_writel(0xCFDE, VA_WRITEPERM0); /* all i-write */
+
+			return 0;
 		}
-		return 0;
-	} else
-		return 1; /* assume locked with no PPA or security driver */
+	}
+
+	return 1; /* assume locked with no PPA or security driver */
 }
 
 /*
@@ -93,7 +102,11 @@
 	unsigned long reserved;
 
 	if (cpu_is_omap24xx()) {
-		if (is_sram_locked()) {
+		if (!omap24xx_is_gp_device ()) {
+			omap_sram_base = OMAP2_SRAM_VA + OMAP2_SRAM_SECURE_SIZE;
+			omap_sram_start = OMAP2_SRAM_PUB_PA + OMAP2_SRAM_SECURE_SIZE;
+			omap_sram_size = OMAP2_SRAM_TOTAL_SIZE - OMAP2_SRAM_SECURE_SIZE;
+		} else if (is_sram_locked()) {
 			omap_sram_base = OMAP2_SRAM_PUB_VA;
 			omap_sram_start = OMAP2_SRAM_PUB_PA;
 			omap_sram_size = 0x800; /* 2K */
@@ -172,13 +185,6 @@
 	 */
 	local_flush_tlb_all();
 	flush_cache_all();
-
-	/*
-	 * Looks like we need to preserve some bootloader code at the
-	 * beginning of SRAM for jumping to flash for reboot to work...
-	 */
-	memset((void *)omap_sram_base + SRAM_BOOTLOADER_SZ, 0,
-	       omap_sram_size - SRAM_BOOTLOADER_SZ);
 }
 
 void * omap_sram_push(void * start, unsigned long size)
@@ -194,6 +200,7 @@
 
 	return (void *)omap_sram_ceil;
 }
+EXPORT_SYMBOL(omap_sram_push);
 
 static void omap_sram_error(void)
 {
diff -ruN linux-omap-2.6/arch/arm/plat-omap/timer32k.c maemo_src/arch/arm/plat-omap/timer32k.c
--- linux-omap-2.6/arch/arm/plat-omap/timer32k.c	2011-02-06 20:17:25.456666607 -0500
+++ maemo_src/arch/arm/plat-omap/timer32k.c	2011-02-06 20:12:09.593333274 -0500
@@ -123,6 +123,29 @@
 
 static struct omap_dm_timer *gptimer;
 
+#ifdef CONFIG_ARCH_OMAP2420
+#define OMAP2420_GP_TIMER0_BASE		0x48028000
+#define GP_TIMER_TCLR			0x24
+#define GP_TIMER_TCRR			0x28
+#define GP_TIMER_TWPS			0x34
+#define		TWPS_MASK		0x3	/* Check for TCLR and TCRR */
+
+/*
+ * Reloads gp_timer0 value. Assumes that gp_timer0 has be set into posted mode
+ * during init. Bypassess the gp_timer functions to optimize timer reloading
+ * during timer interrupts.
+ */
+static inline void omap2420_gp_timer0_reload(unsigned long load_val)
+{
+	while (__raw_readl(IO_ADDRESS(OMAP2420_GP_TIMER0_BASE + GP_TIMER_TWPS))
+					& TWPS_MASK)
+		cpu_relax();
+	__raw_writel(0xffffffff - load_val,
+			IO_ADDRESS(OMAP2420_GP_TIMER0_BASE + GP_TIMER_TCRR));
+	__raw_writel(0x3, IO_ADDRESS(OMAP2420_GP_TIMER0_BASE + GP_TIMER_TCLR));
+}
+#endif
+
 static inline void omap_32k_timer_start(unsigned long load_val)
 {
 	omap_dm_timer_set_load(gptimer, 1, 0xffffffff - load_val);
@@ -204,7 +227,12 @@
 	 * latencies during high system load. During dynamic tick operation the
 	 * continuous timer can be overridden from pm_idle to be longer.
 	 */
+#ifdef CONFIG_ARCH_OMAP2420
+	omap2420_gp_timer0_reload(omap_32k_last_tick
+					+ OMAP_32K_TICKS_PER_HZ - now);
+#else
 	omap_32k_timer_start(omap_32k_last_tick + OMAP_32K_TICKS_PER_HZ - now);
+#endif
 
 	return IRQ_HANDLED;
 }
diff -ruN linux-omap-2.6/arch/arm/plat-omap/usb.c maemo_src/arch/arm/plat-omap/usb.c
--- linux-omap-2.6/arch/arm/plat-omap/usb.c	2011-02-06 20:17:25.459999940 -0500
+++ maemo_src/arch/arm/plat-omap/usb.c	2007-10-02 03:09:30.000000000 -0400
@@ -76,38 +76,6 @@
 
 /*-------------------------------------------------------------------------*/
 
-#ifdef	CONFIG_ARCH_OMAP_OTG
-
-static struct otg_transceiver *xceiv;
-
-/**
- * otg_get_transceiver - find the (single) OTG transceiver driver
- *
- * Returns the transceiver driver, after getting a refcount to it; or
- * null if there is no such transceiver.  The caller is responsible for
- * releasing that count.
- */
-struct otg_transceiver *otg_get_transceiver(void)
-{
-	if (xceiv)
-		get_device(xceiv->dev);
-	return xceiv;
-}
-EXPORT_SYMBOL(otg_get_transceiver);
-
-int otg_set_transceiver(struct otg_transceiver *x)
-{
-	if (xceiv && x)
-		return -EBUSY;
-	xceiv = x;
-	return 0;
-}
-EXPORT_SYMBOL(otg_set_transceiver);
-
-#endif
-
-/*-------------------------------------------------------------------------*/
-
 #if defined(CONFIG_ARCH_OMAP_OTG) || defined(CONFIG_ARCH_OMAP15XX)
 
 static u32 __init omap_usb0_init(unsigned nwires, unsigned is_device)
diff -ruN linux-omap-2.6/arch/arm/tools/mach-types maemo_src/arch/arm/tools/mach-types
--- linux-omap-2.6/arch/arm/tools/mach-types	2011-02-06 19:44:42.746666606 -0500
+++ maemo_src/arch/arm/tools/mach-types	2011-02-06 20:12:09.459999940 -0500
@@ -16,6 +16,8 @@
 #
 # machine_is_xxx	CONFIG_xxxx		MACH_TYPE_xxx		number
 #
+nokia_rx48		MACH_NOKIA_RX48		NOKIA_RX48		1727
+nokia_rx44		MACH_NOKIA_RX44		NOKIA_RX44		1548
 ebsa110			ARCH_EBSA110		EBSA110			0
 riscpc			ARCH_RPC		RISCPC			1
 nexuspci		ARCH_NEXUSPCI		NEXUSPCI		3
diff -ruN linux-omap-2.6/changelog maemo_src/changelog
--- linux-omap-2.6/changelog	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/changelog	2011-02-06 19:38:22.573333274 -0500
@@ -0,0 +1,3434 @@
+kernel-source-diablo (2.6.21-200842maemo1) unstable; urgency=low
+
+  * Week 42 release
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Tue, 14 Oct 2008 09:30:23 +0300
+
+kernel-source-diablo (2.6.21-200838maemo1) unstable; urgency=low
+
+  * WiWLAN release 2008.38.001, Fixes: NB#86574
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Tue, 16 Sep 2008 11:54:24 +0300
+
+kernel-source-diablo (2.6.21-200837maemo4) unstable; urgency=low
+
+  * Revert: Futex patch
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Fri, 12 Sep 2008 08:49:32 +0300
+
+kernel-source-diablo (2.6.21-200837maemo2) unstable; urgency=low
+
+  * WiWLAN release 2008.37.001, Fixes: NB#87549
+  * Futex patch, Fixes: NB#86909
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Tue,  9 Sep 2008 12:32:08 +0300
+
+[Akernel-source-diablo (2.6.21-200835maemo1) unstable; urgency=low
+
+  * Tearsync issues in OPO mode, Fixes: NB#86447
+
+ -- Timo Poikola <timo.poikola@nokia.com>  Tue, 26 Aug 2008 15:23:29 +0300
+
+kernel-source-diablo (2.6.21-200834maemo1) unstable; urgency=low
+
+  * WiWLAN release 2008.34.003
+
+ -- Timo Poikola <timo.poikola@nokia.com>  Wed, 20 Aug 2008 13:18:19 +0300
+
+kernel-source-diablo (2.6.21-200833maemo2) unstable; urgency=low
+
+  * WiWLAN release 2008.33.001
+  * Configure HW RNG as modules
+  * random: fix seeding with zero entropy
+
+ -- Timo Poikola <timo.poikola@nokia.com>  Wed, 13 Aug 2008 12:39:42 +0300
+
+kernel-source-diablo (2.6.21-200828maemo1) unstable; urgency=low
+
+  * WiWLAN release 2008.28.001
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Wed,  9 Jul 2008 08:37:52 +0300
+
+kernel-source-diablo (2.6.21-200827maemo1) unstable; urgency=low
+
+  * WiWLAN release 2008.27.001
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Tue,  1 Jul 2008 12:50:38 +0300
+
+kernel-source-diablo (2.6.21-200826maemo1) unstable; urgency=low
+
+  * WiWLAN release 2008.26.001-1
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Mon, 23 Jun 2008 16:02:13 +0300
+
+kernel-source-diablo (2.6.21-200823maemo6) unstable; urgency=low
+
+  * Wimax driver removed
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Thu, 19 Jun 2008 09:47:01 +0300
+
+kernel-source-diablo (2.6.21-200823maemo3) unstable; urgency=low
+
+  * Ignore disconnect on suspend, Fixes: NB#86007
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Wed, 11 Jun 2008 14:20:41 +0300
+
+kernel-source-diablo (2.6.21-200823maemo2) unstable; urgency=low
+
+  * Fix v6_early_abort to not trash r0 if strex succeeds. Fixes: NB#85198
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Mon,  9 Jun 2008 12:39:38 +0300
+
+
+kernel-source-diablo (2.6.21-200823maemo1) unstable; urgency=low
+
+  * WiWLAN release 2008.23.001
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Tue,  3 Jun 2008 11:17:57 +0300
+
+kernel-source-diablo (2.6.21-200822maemo2) unstable; urgency=low
+
+  * WiWLAN release 2008.22.001, Wimax Driver API v3.6
+  * Added USB-VGA adapter to whitelist, Fixes: NB#85797
+  * Fixes: NB#83873
+  * Try to make swapoff work with read-only fs, Fixes: NB#82666
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Mon, 26 May 2008 11:45:15 +0300
+
+kernel-source-diablo (2.6.21-200821maemo2) unstable; urgency=low
+
+  * WiWLAN release 2008.21.001, Fixes: NB#83482
+  * USB: OTG: Error messaging fix, Fixes NB#83903
+  * ARM: OMAP: Optimize timer32k writes, Fixes NB#85569
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Tue, 20 May 2008 13:59:22 +0300
+
+kernel-source-diablo (2.6.21-200820maemo1) unstable; urgency=low
+
+  * WiWLAN release 2008.20.001
+  * Exported omap2_block_sleep and omap2_allow_sleep functions for modules usage also
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Tue, 13 May 2008 13:53:13 +0300
+
+kernel-source-diablo (2.6.21-200819maemo2) unstable; urgency=low
+
+  * WiWLAN release 2008.19.001
+  * USB: OTG TPL: Add rx-48 to its whitelists. Fixes: NB#84933
+  * I2C: MENELAUS: minor cleanups
+  * Device freezes and restarts randomly bugfix, Fixes: NB#83873
+  * Long reboot time fix, Fixes: NB#80979
+  * MMC: Fix eMMC write problem on some N810s. Fixes: NB#79366
+  * Issue a new spi read in ts_rx if there has been more than one interrupt,
+    Fixes: NB#83496
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Tue,  6 May 2008 13:35:36 +0300
+
+kernel-source-diablo (2.6.21-200818maemo1) unstable; urgency=low
+
+  * WiWLAN release 2008.18.001
+  * Device freezes and restarts randomly bugfix, Fixes: NB#83873
+  * Long reboot time fix, Fixes NB#80979
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Mon, 28 Apr 2008 14:30:12 +0300
+
+kernel-source-diablo (2.6.21-200817maemo2) unstable; urgency=low
+
+  * USB: GADGET: Fix descriptors for n810 wimax hw
+  * WiWLAN release 2008.17.001
+  * Define RX-48 as its own machine. Partial: NB#84123
+  * Fixes: NB#83872
+  * Fix multiple definitions of clk_deny_idle
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Tue, 22 Apr 2008 15:19:59 +0300
+
+kernel-source-diablo (2.6.21-200816maemo1) unstable; urgency=low
+
+  * Revert: Long reboot time fix
+  * Revert "Spi read request chaining in the irq handler &tsc2005_ts_rx()."
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Wed, 16 Apr 2008 08:55:16 +0300
+
+kernel-source-diablo (2.6.21-200815maemo2) unstable; urgency=low
+
+  * WiWLAN release 2008.15.001, Fixes: NB#80678, NB#80463, NB#79162
+  * WiWLAN release 2008.14.002
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Tue,  8 Apr 2008 10:27:47 +0300
+
+kernel-source-diablo (2.6.21-200814maemo2) unstable; urgency=low
+
+  * i2c correction to WiWLAN release 2008.13.001 
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Fri,  4 Apr 2008 10:20:23 +0300
+
+kernel-source-diablo (2.6.21-200814maemo1) unstable; urgency=low
+
+  * Disabled unnecessary mmu read lockings
+  * Fix multiple definitions of clk_deny_idle
+  * Define RX-48 as its own machine. Partial: NB#84123
+  * USB: GADGET: Fix descriptors for n810 Wimax hw
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Tue,  1 Apr 2008 10:33:03 +0300
+
+kernel-source-diablo (2.6.21-200813maemo1) unstable; urgency=low
+
+  * pc2400m driver update (wk13 release)
+  * Spi read request chaining in the irq handler &tsc2005_ts_rx().
+    Pressure is now filtered by reporting the max pressure (= min
+    resistance) from a sliding window. Fixes: NB#75613
+
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Tue, 25 Mar 2008 14:53:11 +0200
+
+kernel-source-diablo (2.6.21-200812maemo1) unstable; urgency=low
+
+  * MMC patches. Fixes: NB#78601, NB#79672, NB#81054, NB#80118, NB#79360
+    mmc_block: check card state after write. Patch backported from 2.6.24.
+    mmc_block: Remove the block device if probe fails
+    OMAP: Do not wait forever for end of command
+    Wait for 8 mmc cycles before sending stop command (fixes issues
+    with 4Gb Transcend cards).
+    Use non-blocking host claiming and run the work queue later if the host
+    is already claimed.
+  * pc2400m driver update (wk12 release)
+  * rx-44, rx-48 machine types changed from 5555 to 1548 (official N810 machine
+    ID)
+  * I2C clock race fix
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Tue, 18 Mar 2008 12:41:06 +0200
+
+kernel-source-diablo (2.6.21-200811maemo1) unstable; urgency=low
+
+  * pc2400m driver update (wk11 release)
+  * Bluetooth workaround. Fixes NB#67793
+  * mtdoops patches
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Tue, 11 Mar 2008 14:48:19 +0200
+
+kernel-source-diablo (2.6.21-200809maemo2) unstable; urgency=low
+
+  * Week 09 pc2400m patches
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Thu, 28 Feb 2008 08:26:23 +0200
+
+kernel-source-diablo (2.6.21-200809maemo1) unstable; urgency=low
+
+  * SPI fix, Fixes: NB#80769
+  * 2420: Set autoidle bits in sysconfig registers
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Tue, 26 Feb 2008 13:56:02 +0200
+
+kernel-source-diablo (2.6.21-200808maemo1) unstable; urgency=low
+
+  * Added support for USB-VGA adapter
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Tue, 19 Feb 2008 10:11:54 +0200
+
+kernel-source-diablo (2.6.21-200807osso1) unstable; urgency=low
+
+  * pc2400m driver update (wk07 release)
+  * Enabled pc2400m SPI aggregation
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Tue, 12 Feb 2008 13:17:13 +0200
+
+kernel-source-diablo (2.6.21-200806osso1) unstable; urgency=low
+
+  * Serial sluggishness fix
+  * pc2400m driver update (wk06 release)
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Tue,  5 Feb 2008 12:25:09 +0200
+
+kernel-source-diablo (2.6.21-200805osso3) unstable; urgency=low
+
+  * HS OMAP support added
+  * PC2400M related code added (wk05 release)
+  * SPI related patches added
+  * GCOV related code added
+  * MMC patches added
+  * Defer timers. Fixes: NB#72570
+  * IPv4/IPv6 idle timer
+  * Dirty ratio limit changed
+
+ -- Grigori Timonen <grigori.timonen@nokia.com>  Tue, 29 Jan 2008 14:13:26 +0200
+
+kernel-source-rx-34 (2.6.21.0-osso71) unstable; urgency=low
+
+  * week200749-2 release. Fixes: NB#78085
+  * Fix tsc2005 & tsc2301 lockup in disable 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri,  7 Dec 2007 10:37:14 +0200
+
+kernel-source-rx-34 (2.6.21.0-osso70) unstable; urgency=low
+
+  * week200749-1 release. Fixes: NB#73908
+  * Fix tsc2301, tsc2005 touchscreen locking
+  * tsc2301 - fix keyboard lockup issue 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed,  5 Dec 2007 15:57:19 +0200
+
+kernel-source-rx-34 (2.6.21.0-osso69) unstable; urgency=low
+
+  * week200748-1 release. Fixes: NB#76738, NB#73908
+  * Fix for n800 keyboard stuck problem
+  * fat: don't use free_clusters for fat32
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 27 Nov 2007 15:40:45 +0200
+
+kernel-source-rx-34 (2.6.21.0-osso68) unstable; urgency=low
+
+  * week200747-3 release. Fixes: NB#73908, NB#73999
+  * FB: OMAP: Mipid: Init esd_work as a deferrable delayed work
+  * Fix SPI confusion in TSC2005 driver
+  * Fix for n800 keyboard stuck problem
+  * TSC2005 cleanup.
+  * USB: MUSB: Allow non-root users to start SRP
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 23 Nov 2007 16:41:25 +0200
+
+kernel-source-rx-34 (2.6.21.0-osso67) unstable; urgency=low
+
+  * week200747-1 release
+  * Fixes: NB#75876, NB#75823, NB#74723, NB#75935, NB#75648
+  * ARM:MM: Fix cache coherency issue on ARM based on patch from
+    bitshrine.org.
+  * DSPGW: Fix "BUG at arch/arm/plat-omap/dsp/task.c:1330!"
+  * DSPGW: Fix incorrect comparison of dsp dynamic task state
+  * MMC: OMAP: Ban open-ended multiblock access in N810 internal slot
+  * MMC: OMAP: Lazy clock shutdown
+  * MMC: cull sg list to match mmc request size
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Mon, 19 Nov 2007 16:19:50 +0200
+
+kernel-source-rx-34 (2.6.21.0-osso66) unstable; urgency=low
+
+  * week200746-1 release. 
+    Fixes: NB#74493, NB#74369, NB#75500, NB#66609, NB#75557
+  * ALSA: Call aic33_power_ctrl only for changed input gain control in AIC33
+  * ALSA: Cleanup AIC33 by removing aic33_setreg and aic33_getreg functions
+  * ALSA: Do not expose struct aic33 outside of AIC33 driver
+  * ALSA: Implement aic33_enable_adcs function in AIC33
+  * ALSA: Minor coding style cleanups to AIC33
+  * ALSA: Remove DAC power down delay from AIC33
+  * ALSA: Shorten PLL delay and regroup PLL and DAC control functions in AIC33
+  * CBUS: Do not BUG_ON in retu-headset in case of spurious release event
+  * Change tsc2005 config symbol
+  * Fix TSC2301 keyboard and touchscreen
+  * LED: OMAP PWM: Turn regulator power off in omap_pwm_led_probe()
+  * MMC: OMAP: Fix Vdcdc3 and slot 2 enable misconfiguration in Menelaus
+  * MMC: OMAP: Use correct power source for slot 2 and fix init order
+  * N810: Update board-n810 to use correct tsc2005 config option
+  * tsc2005: Move tsc2005 to drivers/input/touchscreen
+  * tsc2005: fix disabling the driver and initialize pnd to 1
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 13 Nov 2007 12:42:51 +0200
+
+kernel-source-rx-34 (2.6.21.0-osso65) unstable; urgency=low
+
+  * week200745-1 release. Fixes: NB#72580, NB#73122
+  * ARM: OMAP2: Adjust OneNAND GPMC timings for 166MHz L3
+  * ARM: OMAP2: OneNAND 66MHz timings
+  * ARM: OMAP: Use eac_fck clock in board-n800-audio to keep sys_clkout2 stable
+  * DSPGW: Fix for kernel BUG at arch/arm/plat-omap/dsp/task.c:281!
+  * Only 3 INTC_PENDING_IRQ registers
+  * Revert "ARM: OMAP: Add extra delay to EAC ext clock activation in board-n800-audio"
+  * musb_hdrc: Clean up after OPT cert test fixes
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue,  6 Nov 2007 16:51:04 +0200
+
+kernel-source-rx-34 (2.6.21.0-osso64) unstable; urgency=low
+
+  * week200744-1 release.
+    Fixes: NB#74319
+  * N800 1.1 USB Pre-certification tests fails
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 30 Oct 2007 15:48:46 +0200
+
+kernel-source-rx-34 (2.6.21.0-osso63) unstable; urgency=low
+
+  * week200743-1 release. Fixes: NB#73077
+  * mmc mounts messed up and load of other weirdness   
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 23 Oct 2007 17:47:25 +0300
+
+kernel-source-rx-34 (2.6.21.0-osso62) unstable; urgency=low
+
+  * Bugfix back. Fixes: NB#68077 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 19 Oct 2007 17:04:21 +0300
+
+kernel-source-rx-34 (2.6.21.0-osso61) unstable; urgency=low
+
+  * Removed bugfix 68077.
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 19 Oct 2007 16:36:22 +0300
+
+kernel-source-rx-34 (2.6.21.0-osso59) unstable; urgency=low
+
+  * week200742-4 release.
+  * Revert "Reduce dirty ratio granularity to 0.1%."
+  * USB: FSG: Do not use DELAYED_STATUS for SET_CONFIGURATION
+  * musb_hdrc: OPT PM fixes for tusb, take 3
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 19 Oct 2007 16:15:04 +0300
+
+kernel-source-rx-34 (2.6.21.0-osso58) unstable; urgency=low
+
+  * week200742-3 release. Fixes: NB#72047, NB#70546
+  * FB: OMAP: Mipid: Enter Sleep In before asserting RESETX
+  * ARM: OMAP: Add extra delay to EAC ext clock activation inboard-n800-audio
+  * ALSA: Keep OMAP24xx EAC functional clock active over external clock
+  * FB: OMAP: Mipid: Add SPI shutdown hook
+  * USB: MUSB: Do not notify sysfs if vbus_error is less than 3 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 17 Oct 2007 17:16:34 +0300
+
+kernel-source-rx-34 (2.6.21.0-osso57) unstable; urgency=low
+
+  * week200742-2 release. Fixes: NB#66365 
+  * MMC: OMAP: Add host shutdown code
+  * ALSA: Implement workaround to AIC33 for avoiding extra current consumption
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 16 Oct 2007 15:21:32 +0300
+
+kernel-source-rx-34 (2.6.21.0-osso56) unstable; urgency=low
+
+  * week200742-1 release. Fixes: NB#73033, NB#71923, NB#72859
+  * misc musb tweaks
+  * USB: MUSB: HSET: Fix HSET tool when running host mode tests
+  * DVFS: Workaround for "Unhandled fault: external abort on linefetch"
+  * musb_hdrc: Allow suspend if host is already suspended
+  * musb_hdrc: Fix stall handling as OTG peripheral
+  * USB: OTG: Fix compile when CONFIG_USB_OTG is not set
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Mon, 15 Oct 2007 11:21:19 +0300
+
+kernel-source-rx-34 (2.6.21.0-osso55) unstable; urgency=low
+
+  * week200741-2 release
+  * Fixes: NB#72086, NB#72075
+  * Revert "JFFS2: Reduce time for which erase_free_sem is held during erase."
+  * USB: OTG: Disable autosuspend for whitelisted nokia devices
+  * USB: MUSB: Add missing otg_set_error when device draws too much current
+  * Reduce dirty ratio granularity to 0.1%.
+  * MMC: OMAP: Cleanups and fixes for mmc clock management.
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue,  9 Oct 2007 19:01:56 +0300
+
+kernel-source-rx-34 (2.6.21.0-osso54) unstable; urgency=low
+
+  * Updated bugfixes. Fixes: NB#71677, NB#72396
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Mon,  8 Oct 2007 18:33:31 +0300
+
+kernel-source-rx-34 (2.6.21.0-osso53) unstable; urgency=low
+
+  * week200741-1 release
+  * MTD: OneNAND: Ensure reset operation is successful
+  * OMAP2: OneNAND: Return only negative error codes
+  * MTD: OneNAND: Return only negative error codes
+  * MTD: OneNAND: Synchronize block locking operations
+  * USB: MUSB: Make vbus sysfs entry report current Vbus status
+  * USB: OTG: Add "Hub is not supported" message
+  * DVFS: Move mutex_lock earlier to keep consistency of original state
+  * MMC: OMAP: Disable SD and MMC high speed modes.
+  * MMC: OMAP: Remove 2.8v from Vmmc regulator
+  * Fix: DSP crash after copying files from internal to external memory card
+  * TSL2563: Save power while reading the sensor
+  * Revert "ARM: N800: TCM825x: Decrease maximum ALC gain."
+  * Hid large payload support
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Mon,  8 Oct 2007 17:21:59 +0300
+
+kernel-source-rx-34 (2.6.21.0-osso52) unstable; urgency=low
+
+  * USB: GADGET: Fix file_storage strings with official RX-44 name 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu,  4 Oct 2007 20:19:54 +0300
+
+kernel-source-rx-34 (2.6.21.0-osso51) unstable; urgency=low
+
+  * week200740-2 release. Fixes: NB#70695, NB#71353, NB#71800
+  * ARM: OMAP: Move board-rx44*.c to board-n810*.c
+  * DVFS: MBOX: Use its own workqueues for robustness during PM operation
+  * USB: Check that NOR flash in TUS6010 is accessible in irq handler.
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu, 04 Oct 2007 18:28:41 +0300
+
+kernel-source-rx-34 (2.6.21.0-osso50) unstable; urgency=low
+
+  * Clear .orig.tar.gz rebuild
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 03 Oct 2007 16:45:42 +0300
+
+kernel-source-rx-34 (2.6.21.0-osso49) unstable; urgency=low
+
+  * week200740-1 release
+  * Enable CONFIG_RADIO_TEA5761 in nokia_2420_defconfig
+  * ARM: OMAP2: Camera: Retry sensor initialisation in error cases
+  * TCM825x: Retry I2C accesses in error cases
+  * MMC: OMAP: Remove unneeded clock divisor increase
+  * MMC: OMAP: Power up and down Movinand properly
+  * MMC: Use tasklet instead of workqueue for cover switch notification
+  * Fix build error without DVFS
+  * DVFS: Fix bug for counting dynamically loaded task number
+  * DVFS: FB: Refrain from printing noisy "setting update mode"
+  * musb_hdrc: Make HNP more reliable
+  * musb_hdrc: Fix vbus error notification
+  * USB: OTG: Continue enumeration of unsupported device if HNP fails
+  * musb_hdrc: Add timer for returning to host mode from HNP
+  * USB: MUSB: Set OTG_ERR_DEVICE_NOT_SUPPORTED for devices drawing too much power
+  * USB: OTG: OTG TPL finalization
+  * USB: OTG: USB Root Hub should be always targeted
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 02 Oct 2007 18:48:25 +0300
+
+kernel-source-rx-34 (2.6.21.0-osso48) unstable; urgency=low
+
+  * week200739-4 release.
+  * USB: OTG: Fix RX44 ProductID
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu, 27 Sep 2007 16:42:46 +0300
+
+kernel-source-rx-34 (2.6.21.0-osso47) unstable; urgency=low
+
+  * week200739-3 release. Fixes: NB#69588, NB#62847
+  * MMC: OMAP: Put host into a standby only after the cards are idle.
+  * FB: OMAP: Blizzard: Coalesce redundant window update requests
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu, 27 Sep 2007 15:40:29 +0300
+
+kernel-source-rx-34 (2.6.21.0-osso46) unstable; urgency=low
+
+  * week200739-2 release. Fixes: NB#66133, NB#59608
+  * USB: MUSB: Do not retry on Vbus error
+  * USB: OTG: Remove Lynn and SanDisk reader from whitelist
+  * musb_hdrc: Fix idling as b-device broken by earlier a-host idle patch
+  * I2C: LM8323: Allow interrupts while executing lm8323_work
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu, 27 Sep 2007 12:57:27 +0300
+
+kernel-source-rx-34 (2.6.21.0-osso45) unstable; urgency=low
+
+  * week200739-1 release.
+    Fixes: NB#68385, NB#70521, NB#68790, NB#70272
+  * musb_hdrc: Fix HNP again
+  * MTD: OneNAND: fix numerous races
+  * USB: OTG: Nokia customizations on OTG Whitelist
+  * MMC: Enable explicit control of menelaus regulator low power mode
+  * Menelaus: Cleanup of the regulator control
+  * Fix menelaus voltage handling
+  * DSPGW: Fix lockup of MM system in opening dsp device file
+  * DVFS: DSPGW: Make DSP_PAUSE and DSP_CONTINUE paired
+  * DVFS: Workaround for sleep under spinlock for RFBI
+  * DVFS: Workaround for sleep under spinlock for MMC
+  * ARM: OMAP: Fix build warning for menelaus
+  * DVFS: Avoid unnecessary call for "cpufreq_op_policy()" for stability
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 25 Sep 2007 18:56:10 +0300
+
+kernel-source-rx-34 (2.6.21.0-osso44) unstable; urgency=low
+
+  * week200738-1 release. Fixes: NB#61743, NB#65391, NB#65830
+  * ARM: OMAP: Reduce Nokia RX-44 headset port start-up pop in
+    board-n800-audio
+  * ARM: OMAP: Remove Nokia RX-44 amplifier start-up delays in board-n800-audio
+  * ARM: OMAP2: Camera: Tell DVFS about camera status
+  * CBUS: A workaround for ADC S/H HW bug: always keep ch 8 selected when S/H is used
+  * Disable automatic VSim1 powersaving
+  * DVFS: CPUFreq null-governor now ignore policy changes
+  * I2C: LM8323: Read whole key event fifo buffer at key events
+  * LZO1X: fix lzo1x_worst_compress
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 18 Sep 2007 16:42:59 +0300
+
+kernel-source-rx-34 (2.6.21.0-osso43+nondvfs1) unstable; urgency=low
+
+  * week200737-1-no-dvfs release
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 12 Sep 2007 19:13:44 +0300
+
+kernel-source-rx-34 (2.6.21.0-osso43) unstable; urgency=low
+
+  * week200737-1 release
+  * Making correct .orig.tar.gz
+  * tsc2005: sensitivity and fudge fix
+  * USB: OTG: Add check for roothub initialization
+  * musb_hdrc: Fix HNP for OPT quirks, take 2
+  * musb_hdrc: Add support for USB OPT HS A TD.5.7 error device not responding
+  * USB: OTG: Nokia customizations on OTG Whitelist
+  * USB: OTG: Add OPT HS A electrical test devices to supported list
+  * USB: OTG: Add support for enabling and disabling whitelist via sys
+  * USB: OTG: Make whitelist scan use the new list
+  * USB: OTG: Add functions to support dynamic OTG whitelist, remove otg_whitelist.h
+  * USB: OTG: Make otg_get_transceiver() and otg_set_transceiver() generic
+  * USB: OTG: Introduce new otg.c code
+  * USB: Fix apparent typo CONFIG_USB_CDCETHER.
+  * Revert "OTG WHITELIST"
+  * musb_hdrc: Start using otg_set_transceiver()
+  * musb_hdrc: Fix tusb3.1 revsision check again
+  * ALSA: Update file description and contact information in AIC33 files
+  * ALSA: Move AIC33 header file to more appropriate include directory
+  * ALSA: Rename AIC33 source file as tlv320aic33.c
+  * LM8323: Ensure proper synchronisation of kp_enabled.
+  * LM8323: Try to set keys_down correctly.
+  * musb_hdrc: Fix tusb3.1 detection for newer chips
+  * musb_hdrc: Change tusb DMA log level to be less verbose
+  * musb_hdrc: Fix tusb DMA corruption
+  * musb_hdrc: Standardize to use tbase for tusb specific registers
+  * musb_hdrc, CamelCase begone (rest of CPPI)
+  * musb_hdrc, CamelCase begone (cppi struct, locals ...)
+  * musb_hdrc, CamelCase begone (cppi descriptors, ...)
+  * MUSB: Kill compile warnings at drivers/usb/musb/tusb6010.c
+  * usb: Nokia changes for file_storage gadget
+  * DVFS: API for generic OP policy setting
+  * FB: OMAP: Check if rfbi is initialized before pausing/continuing
+  * Menelaus: remove unnecessary delay
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 11 Sep 2007 17:19:40 +0300
+
+kernel-source-rx-34 (2.6.21-osso42) unstable; urgency=low
+
+  * week200736-2 release. Fixes: NB#66706
+  * dvfs-v2 applied on top of w36-1
+  * I2C: LM8323: Fix PM suspend and resume functionality
+  * I2C: LM8323: Remove two useless flags from chip structure
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 05 Sep 2007 17:15:25 +0300
+
+kernel-source-rx-34 (2.6.21-osso41) unstable; urgency=low
+
+  * week200736-1 release. Fixes: NB#65163, NB#56025
+  * ARM: OMAP2: Nokia 2420: Increase fb reserved regions again
+  * I2C: LM8323: Fix configuration sequence
+  * I2C: LM8323: Remove unused variables
+  * Disable CPU_FREQ from nokia_2420_defconfig
+  * DSPGW: Fix broken suspend()/resume() operations
+  * ARM: OMAP: Fix sleep under spinlock for cpufreq
+  * ARM: OMAP: Fix EAC dynamic pin multiplexing in board-n800-audio
+  * ARM: OMAP: Fix RX-44 audio clock specific design flaw in board-n800-audio
+  * ALSA: Combine two AIC33 source files into one
+  * ARM: OMAP: Update AIC33 config name in board-n800-audio
+  * ARM: OMAP: Update AIC33 config name in nokia_2420_defconfig
+  * CBUS: Cleanup retu-headset driver
+  * CBUS: Manage bias voltage in retu-headset suspend/resume code
+  * I2C: TSL2563 Light sensor integration time fix
+  * ARM: OMAP2: Camera: Reset camera a bit more civilised way.
+  * Add quirk for SU-8W
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 04 Sep 2007 19:34:02 +0300
+
+kernel-source-rx-34 (2.6.21-osso40) unstable; urgency=low
+
+  * week200735-3 release
+  * dvfs-v2 on top of rx-44-2007-35-2 tag.
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu, 30 Aug 2007 17:33:10 +0300
+
+kernel-source-rx-34 (2.6.21-osso39) unstable; urgency=low
+
+  * week200735-2 release.
+    Non-DVFS  release. Fixes: NB#66705.
+  * MUSB: Coding style cleanup, kill all CPP style comments
+  * musb_hdrc: Some more cleanup
+  * musb_hdrc: Cannot stall an endpoint 0 control transfer from
+    a data stage cal lback function
+  * <linux/usb/musb.h> tusb6010 timings
+  * musb_hdrc cleanup -- comments, dates
+  * musb_hdrc cleanup -- cppi and sparse
+  * LM8323: Add reset and clear interrupts on initialization
+  * I2C: TSL2563 Use different gain modes depending on brightness.
+  * musb_hdrc: Remove nasty temporary hack that's no longer needed
+  * musb_hdrc: Make tusb use musb_set_vbus() to turn on VBUS
+  * musb_hdrc: Fix OPT A error "B-OPT Did not detect reset after connecting"
+  * musb_hdrc: Add sysfs notification to mode, only show changes
+  * musb_hdrc: Clean-up patch to sync with linux-omap tree
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 28 Aug 2007 17:00:12 +0300
+
+kernel-source-rx-34 (2.6.21-osso38) unstable; urgency=low
+
+  * week200735-1 release. Fixes: NB#65325, NB#66400
+  * Tweak STEP_PER bits to lower voltage stabilisation time and busy loop
+  * DVFS: Make DVS delay shorter based on TRM
+  * MUSB: Coding style cleanup, kill all CPP style comments
+  * musb_hdrc: Some more cleanup
+  * musb_hdrc: Cannot stall an endpoint 0 control transfer from a data stage callback function
+  * <linux/usb/musb.h> tusb6010 timings
+  * Enable DVFS in nokia_2420_defconfig
+  * DVFS: Drop Notifications
+  * DVFS: Framebuffer: Remove notification
+  * DVFS: Tusb : Remove DVFS
+  * DVFS: DMA : Remove explicit support
+  * DVFS: Camera : Drop notifications
+  * DVFS: SPI : Remove notifications
+  * DVFS: tsc2005 : Remove notifications
+  * DVFS: DSP GW : Change DVFS into Pause/Continue
+  * OMAP2: OneNAND: Support for adjusting the timing.
+  * OMAP2: MCSPI: Pause spi dma
+  * OMAP2: MMC: Pause mmc dma
+  * OMAP2: DMA: Drain DMA FIFOs
+  * OMAP2: RFBI: Pause DMA to external framebuffer.
+  * ARM: OMAP2: Mask / Unmask FIQ & IRQ
+  * DVFS: Remove locking on get-OP functionality
+  * MENELAUS: Convert printk to dev_* macros
+  * DVFS: Fix for dividers scaling down case never detected
+  * DVFS: Version 2 - dvfs.c : Replace notifications
+  * OMAP2 DVFS: dsp audio policy
+  * Revert "OMAP2 DVFS: dsp audio policy"
+  * DVFS: Menelaus: Disable traces of VCore changes
+  * DVFS: Merge voltage and frequency change (1)
+  * DVFS: Merge voltage and frequency change (2)
+  * I2C: TSL2563 Use different gain modes depending on brightness.
+  * musb_hdrc: Remove nasty temporary hack that's no longer needed
+  * musb_hdrc: Make tusb use musb_set_vbus() to turn on VBUS
+  * musb_hdrc: Fix OPT A error "B-OPT Did not detect reset after connecting"
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Mon, 27 Aug 2007 16:58:54 +0300
+
+kernel-source-rx-34 (2.6.21-osso37) unstable; urgency=low
+
+  * week200734-3 release
+  * Disable DVFS from nokia_2420_defconfig
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 24 Aug 2007 16:26:46 +0300
+
+kernel-source-rx-34 (2.6.21-osso36.1) unstable; urgency=low
+
+  * week200734-2 release
+  * DVFSv2 release
+  * Tweak STEP_PER bits to lower voltage stabilisation time and busy loop
+  * DVFS: Make DVS delay shorter based on TRM
+  * DVFS: Drop Notifications
+  * DVFS: Framebuffer: Remove notification
+  * DVFS: Tusb : Remove DVFS
+  * DVFS: DMA : Remove explicit support
+  * DVFS: Camera : Drop notifications
+  * DVFS: SPI : Remove notifications
+  * DVFS: tsc2005 : Remove notifications
+  * DVFS: DSP GW : Change DVFS into Pause/Continue
+  * OMAP2: OneNAND: Support for adjusting the timing.
+  * OMAP2: MCSPI: Pause spi dma
+  * OMAP2: MMC: Pause mmc dma
+  * OMAP2: DMA: Drain DMA FIFOs
+  * OMAP2: RFBI: Pause DMA to external framebuffer.
+  * ARM: OMAP2: Mask / Unmask FIQ & IRQ
+  * DVFS: Remove locking on get-OP functionality
+  * MENELAUS: Convert printk to dev_* macros
+  * DVFS: Fix for dividers scaling down case never detected
+  * DVFS: Version 2 - dvfs.c : Replace notifications
+  * OMAP2 DVFS: dsp audio policy
+  * DVFS: Merge voltage and frequency change (1)
+  * DVFS: Merge voltage and frequency change (2)
+  * musb_hdrc: Make tusb do a_idle, make OPT A tests more reliable
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu, 23 Aug 2007 18:10:19 +0300
+
+kernel-source-rx-34 (2.6.21-osso36) unstable; urgency=low
+
+  * week200734-1 release
+    Fixes: NB#65271, NB#66180, NB#64046, NB#64101, NB#65635, NB#64942
+  * I2C: Remove useless ioctl like callback from AIC33 driver
+  * musb_hdrc: Remove old unused delay_port_power_off
+  * ARM: OMAP: MUSB: IRQ reset: babble handling is host only
+  * musb_hdrc: Fix various build warnings for peripheral
+  * musb: Search and replace USB_INVENTRA_FIFO with MUSB_PIO_ONLY
+  * musb: Search and replace USB_INVENTRA_HCD_LOGGING with USB_MUSB_LOGLEVEL
+  * musb: Rename plat_uds.c to musb_core.c, plat_arc.h to musb_io.h
+  * musb: Rename musbhdrc.h to musb_regs.h
+  * musb: Rename musbdefs.h to musb_core.h
+  * musb_hdrc: Update tusb non-standard loopback test for changed file name
+  * musb: Rename g_ep0.c musb_gadget_ep0.c
+  * musb: Rename virthub.c musb_virthub.c
+  * musb: Rename dma.h to musb_dma.h
+  * musb: Rename debug.h to musb_debug.h
+  * Update RX-44 config for renamed musb options
+  * musb_hdrc: Optimize g_ether with NET_IP_ALIGN to align buffers
+  * musb_hdrc: Fix musb_hnp_stop() to return to device mode
+  * MMC: Merge with Langdale's SDHC code
+  * MMC: Use sector addressing only for mmc cards bigger than 2GB.
+  * TCM825x: Don't export camera orientation.
+  * ARM: OMAP2: Camera: reset camera block every five seconds.
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 22 Aug 2007 16:49:24 +0300
+
+kernel-source-rx-34 (2.6.21-osso35) unstable; urgency=low
+
+  * week200733-3 release
+  * Mount initfs RO
+  * JFFS2: add reserved pool feature
+  * JFFS2: fix buffer sise calculations in jffs2_get_inode_nodes()
+  * JFFS2: Fix buffer length calculations in jffs2_get_inode_nodes()
+  * JFFS2: Improve failure mode if inode checking leaves unchecked space.
+  * JFFS2: Improve read_inode memory usage, v2.
+  * JFFS2: Handle inodes with only a single metadata node with non-zero isize
+  * JFFS2: Remember to calculate overlap on nodes which replace older nodes
+  * JFFS2: Remove broken insert_point optimisation in jffs2_add_tn_to_tree()
+  * JFFS2: Remove another bogus optimisation in jffs2_add_tn_to_tree()
+  * JFFS2: Simplify and clean up jffs2_add_tn_to_tree() some more.
+  * JFFS2: Fix obsoletion of metadata nodes in jffs2_add_tn_to_tree()
+  * JFFS2: Fix suspend failure with JFFS2 GC thread.
+  * JFFS2: Deletion dirents should be REF_NORMAL, not REF_PRISTINE.
+  * JFFS2: Fix readinode failure when read_dnode() detects CRC failure.
+  * JFFS2: Correct cleanmarker checks -- we should use only 8 bytes
+  * JFFS2: Print correct node offset when complaining about broken data CRC
+  * JFFS2: Whitespace cleanups.
+  * Revert "musb_hdrc: Stop VBUS draw on usb_gadget_unregister_driver"
+  * ARM: OMAP: Fix inconsistency of completion in retu-rtc
+  * JFFS2: Better fix for all-zero node headers
+  * JFFS2: Fix hanging close for /dev/mtd character device.
+  * JFFS2: Prevent oops after 'node added in wrong place' debug check
+  * JFFS2: Reduce time for which erase_free_sem is held during erase.
+  * ARM: OMAP: MUSB: fix compile for non-OTG modes
+  * JFFS2: switch jffs2 compression to priority mode
+  * musb_hdrc: Stop VBUS draw on usb_gadget_unregister_driver
+  * musb_hdrc: Fix ambiguous else warning
+  * musb_hdrc: Keep tusb host clock on when VBUS is on
+  * musb_hdrc: Search and replace MGC_O_HDRC_ with MUSB_
+  * musb_hdrc: Search and replace MGC_M_ with MUSB_
+  * musb_hdrc: Search and replace MGC_S_XXX with MUSB_XXX_SHIFT
+  * musb_hdrc: Search and replace MGC_END0_FIFOSIZE with
+    MUSB_EP0_FIFOSIZE, remove MGC_MAX_USB_ENDS
+  * musb_hdrc: Search and replace _bOffset with _offset
+  * musb_hdrc: Search and replace MGC_XXX_OFFSET with MUSB_XXX_OFFSET
+  * musb_hdrc: Remove old unsed MGC_TYPE_SPEED_XXX
+  * musb_hdrc: Tabify and clean-up musbhdrc.h
+  * musb_hdrc: Fix TUSB loopback test for changed variable names
+  * musb_hdrc: Add Nokia copyright, make GPLv2 license generic
+  * musb_hdrc: Search and replace wCsr with csr
+  * musb_hdrc: Search and replace bIntrUSB with int_usb
+  * musb_hdrc: Search and replace bIntr with int_hsdma
+  * musb_hdrc: Search and replace bTransmit with transmit
+  * musb_hdrc: Search and replace pUrb with urb
+  * musb_hdrc: Search and replace pBuffer with buf
+  * musb_hdrc: Search and replace dwLength with len
+  * musb_hdrc: Search and replace wEndMask with epmask
+  * musb_hdrc: Search and replace pDmaChannel with dma_channel
+  * musb_hdrc: Search and replace wRxCount with rx_count
+  * musb_hdrc: Search and replace bDone with done
+  * musb_hdrc: Search and replace nPipe with pipe
+  * musb_hdrc: Search and replace wLoadCount with load_count
+  * musb_hdrc: Search and replace bDmaOk with dma_ok
+  * musb_hdrc: Search and replace pFifoDest with fifo_dest
+  * musb_hdrc: Search and replace pFifoSource with fifo_src
+  * musb_hdrc: Search and replace bIsochError with iso_err
+  * musb_hdrc: Search and replace wVal with val, except for wValue
+  * musb_hdrc: Search and replace wBestDiff with best_diff
+  * musb_hdrc: Search and replace nBestEnd with best_end
+  * musb_hdrc: Search and replace nEnd with epnum
+  * musb_hdrc: Search and replace wFrame with frame
+  * musb_hdrc: Search and replace wRelease with hwvers
+  * musb_hdrc: Search and replace wRelMajor with rev_major
+  * musb_hdrc: Search and replace wRelMinor with rev_minor
+  * musb_hdrc: Search and replace dwData with data
+  * musb_hdrc: Search and replace pController with controller
+  * musb_hdrc: Search and replace wType with musb_type
+  * musb_hdrc: Search and replace bReg with reg
+  * musb_hdrc: Search and replace bMore with more
+  * musb_hdrc: Search and replace bComplete with complete
+  * musb_hdrc: Get rid of unnecessary DMA typedef & fix a comment typo
+  * musb_hdrc: Search and replace MGC_DMA with MUSB_DMA
+  * musb_hdrc: Search and replace MGC_END0 with MUSB_EP0
+  * musb_hdrc: Search and replace MGC_END_OFFSET with MUSB_EP_OFFSET
+  * musb_hdrc: Search and replace MGC_O_HSDMA with MUSB_HSDMA
+  * musb_hdrc: Search and replace MGC_HSDMA with MUSB_HSDMA
+  * musb_hdrc: Fix SRP locking
+  * musb_hdrc: Keep state as b_idle if disconnected as b_idle
+  * musb_hdrc: Fix doing HNP multiple times
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 17 Aug 2007 15:08:05 +0300
+
+kernel-source-rx-34 (2.6.21-osso34) unstable; urgency=low
+
+  * week200733-2 release.
+    Fixes: NB#62740, NB#57306, NB#57268, NB#61915, NB#61215, NB#52619, NB#58673
+  * Remove noisy printk messages
+  * I2C: LM8323: Whitespace cleanup
+  * I2C: LM8323: Keep chip active while keys down
+  * Enable JFFS2_CMODE_FAVOURLZO in nokia_2420_defconfig
+  * DSPGW: Fix Unbalanced enable for IRQ in DSP MMU
+  * Make GPL licensing legal dept. compliant
+  * Make GPL licensing legal dept. compliant
+  * DSPGW: PM: Workaround for testserver suspend
+  * ALSA: Cleanup AIC33 header file
+  * ALSA: Add more AIC33 configuration options via platform data
+  * ARM: OMAP: Update Nokia RX-44 AIC33 configuration in board-n800-audio
+  * ALSA: Add OMAP24xx EAC internal DMA path volume controls
+  * Ignore stolen time in the softlockup watchdog
+  * add touch_all_softlockup_watchdogs()
+  * lib: add LZO1X compression support to the kernel
+  * crypto: Add LZO compression support to the crypto interface
+  * JFFS2: Add LZO compression support to jffs2
+  * JFFS2: Allow selection of compression mode via a sysfs attribute
+  * JFFS2: Add a "favourlzo" compression mode to jffs2
+  * musb_hdrc: Search and replace pThis with musb
+  * musb_hdrc: Search and replace pEndPt with hw_ep
+  * musb_hdrc: Search and replace pEnd with musb_ep when struct musb_ep
+  * musb_hdrc: Search and replace pEnd with musb_ep when struct musb_hw_ep
+  * musb_hdrc: Search and replace pRegs with mregs
+  * musb_hdrc: Search and replace pBase with mbase
+  * musb_hdrc: Search and replace pSource with src
+  * musb_hdrc: Search and replace pDest with dst
+  * musb_hdrc: Search and replace dwCount with len
+  * musb_hdrc: Search and replace wFifoCount with fifo_count
+  * musb_hdrc: Search and replace wCount with len
+  * musb_hdrc: Search and replace bLocalEnd with epnum
+  * musb_hdrc: Search and replace aLocalEnd with endpoints
+  * musb_hdrc: Search and replace bEndCount with nr_endpoints
+  * musb_hdrc: Search and replace bEndNumber with current_epnum
+  * musb_hdrc: Search and replace bEnd0Stage with ep0_stage
+  * musb_hdrc: Search and replace bEnd with epnum
+  * musb_hdrc: Search and replace Lock with lock
+  * musb_hdrc: Search and replace MGC_SelectEnd with musb_ep_select
+  * musb_hdrc: Search and replace _pthis with _musb
+  * musb_hdrc: Search and replace bIsHost with is_host
+  * musb_hdrc: Get rid of old unused MUSB_EpFifoDescriptor
+  * musb_hdrc: Search and replace bIsSharedFifo with is_shared_fifo
+  * musb_hdrc: Search and replace wMaxPacketSizeTx with max_packet_sz_tx
+  * musb_hdrc: Search and replace wMaxPacketSizeRx with max_packet_sz_rx
+  * musb_hdrc: Search and replace pDmaController with dma_controller
+  * musb_hdrc: Search and replace bIsMultipoint with is_multipoint
+  * musb_hdrc: Search and replace bIgnoreDisconnect with ignore_disconnect
+  * musb_hdrc: Search and replace bBulkSplit with bulk_split
+  * musb_hdrc: Search and replace bBulkCombine with bulk_combine
+  * musb_hdrc: Search and replace bAddress with address
+  * musb_hdrc: Search and replace bTestModeValue with test_mode_nr
+  * musb_hdrc: Search and replace bTestMode with test_mode
+  * musb_hdrc: Search and replace pGadgetDriver with gadget_driver
+  * musb_hdrc: Search and replace bDelayPortPowerOff with delay_port_power_off
+  * musb_hdrc: Search and replace pProcEntry with proc_entry
+  * musb_hdrc: Search and replace pPrivateData with private_data
+  * musb_hdrc: Search and replace dwMaxLength with max_len
+  * musb_hdrc: Search and replace dwActualLength with actual_len
+  * musb_hdrc: Search and replace bStatus with status
+  * musb_hdrc: Search and replace bDesiredMode with desired_mode
+  * musb_hdrc: Search and replace bMode with mode
+  * musb_hdrc: Search and replace MGC_pfDmaProgramChannel with dma_program_channel
+  * musb_hdrc: Search and replace pControlRequest with ctrlrequest
+  * musb_hdrc: Search and replace bResult with result
+  * musb_hdrc: Search and replace bSetAddress with set_address
+  * musb_hdrc: Search and replace bRecip with recip
+  * musb_hdrc: Search and replace pRequest with request
+  * musb_hdrc: Search and replace wCsrVal with csr
+  * musb_hdrc: Search and replace bTx with tx
+  * musb_hdrc: Search and replace wPacketSize with packet_sz
+  * musb_hdrc: Search and replace channelNum with chnum
+  * musb_hdrc: Search and replace pThis with musb for looptest
+  * musb_hdrc: Fix revision check for tusb3.1
+  * musb_hdrc: Keep tusb osc_ck enabled during idle even in OTG mode
+  * BLUETOOTH: HCI_H4P: Don't touch the configuration registers while in init
+  * musb_hdrc: Stop VBUS draw on usb_gadget_unregister_driver
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 14 Aug 2007 17:32:56 +0300
+
+kernel-source-rx-34 (2.6.21-osso33) unstable; urgency=low
+
+  * week200732-2 release
+  * ARM: OMAP: Fix misconfigured Nokia N800 EAC codec port configuration
+  * musb_hdrc: Set tusb host max VBUS to 100mA
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 10 Aug 2007 15:31:35 +0300
+
+kernel-source-rx-34 (2.6.21-osso32) unstable; urgency=low
+
+  * week200732-1 release
+  * musb_hdrc: Fixes for OPT HS A tests
+  * ARM: OMAP: Warn on disabling clocks with no users
+  * musb_hdrc: Fix clock usage for suspend
+  * Serial omap: Fix suspend
+  * USB: gadgetfs: use queue for setup requests for userspace
+  * Serial omap: Fix clock usecount
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed,  8 Aug 2007 17:57:35 +0300
+
+kernel-source-rx-34 (2.6.21-osso31) unstable; urgency=low
+
+  * week200731-1 release
+  * Enable usb gadgetfs in nokia_2420_defconfig
+  * ARM: OMAP2: Camera: Fix DVFS state transition.
+  * ARM: N800: TCM825x: Decrease maximum ALC gain.
+  * ARM: N800: Camera: Wait only 1 ms for retu voltage stabilisation.
+  * Make GPL licensing legal dept. compliant
+  * MTD: oops and panic message logging to MTD
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 31 Jul 2007 17:38:29 +0300
+
+kernel-source-rx-34 (2.6.21-osso30) unstable; urgency=low
+
+  * 2007 w28-1 release.
+  * Input: evdev: Allow non-exclusive grabs
+  * Revert "Revert "Menelaus - Turn off annoying voltage scale messages""
+  * Revert "Turn off Menelaus debug"
+  * ARM: OMAP: RX-44: Camera: Turn image 180 degrees.
+  * ARM: OMAP2: DVFS: Fix omap24xx_scale_freq cache preloading
+  * ARM: OMAP: RX-44: Introduce Nokia RX-44 specific TSL2563 power control
+  * I2C: Add platform specific power control into TSL2563 driver
+  * I2C: Harmonize parameter passing and variable names in TSL2563
+  * ARM: OMAP: RX-44: Introduce tsl2563 platform device
+  * ARM: OMAP: Rename field irq in struct tsl2563_config as irq_gpio
+  * I2C: Add tsl2563 platfrom driver in TSL2563
+  * I2C: Clean-ups and coding style fixes to TSL2563
+  * JFFS2: check error code
+  * TUSB6010: Add sysfs notify event to mode attribute
+
+ -- Daniel Stone <daniel.stone@nokia.com>  Fri, 13 Jul 2007 00:52:15 +0300
+
+kernel-source-rx-34 (2.6.21-osso29) unstable; urgency=low
+
+  * 2007 w27-1 release.
+  * Revert "Menelaus - Turn off annoying voltage scale messages"
+  * Turn off Menelaus debug
+  * ALSA: Remove hard-coded gain for right ADC in AIC33
+  * ALSA: Miscellaneous minor fixes to AIC33
+  * ALSA: Keep AIC33 HP outputs in weak common-mode voltage while power-down
+  * ARM: OMAP2: Camera: tiny cleanups and a compile fix.
+  * musb_hdrc: Fix tusb phy_otg_ctrl register access
+  * musb_hdrc: Get rid of sysfs HNP interface, make HNP automatic
+  * musb_hdrc: Keep tusb in reset for OPT
+  * musb_hdrc: Add support for VBUS timeout, clean-up host-idling
+  * musb_hdrc: Clean-up SRP
+  * musb_hdrc: Make SRP reliable and fix timer value
+
+ -- Daniel Stone <daniel.stone@nokia.com>  Tue,  3 Jul 2007 14:07:08 +0000
+
+kernel-source-rx-34 (2.6.21-osso28) unstable; urgency=low
+
+  * week200726-1 release
+  * DMA: Get rid of sysfs warning
+  * Menelaus - Turn off annoying voltage scale messages
+  * ARM: OMAP: RX-44: Invert Home and Escape mapping
+  * musb_hdrc: Change SRP function to use existing musb_gadget_wakeup code
+  * ALSA: Fix DAC and audio output deactivation order in AIC33
+  * ALSA: Fix audio output path activation/deactivation order in AIC33
+  * ARM: OMAP2: DVFS: Change dma DVFS notification timeout to 1 second.
+  * I2C: LP5521 RGB LED: Correct channels are now used in hw.
+  * Revert "USB: Fix OTG HNP for hub.c"
+  * USB: Skip port reset for OTG ports
+  * musb_hdrc: Add support for host mode idling
+  * musb_hdrc: Allow BABBLE for non-HS host
+  * musb_hdrc: Fix peripheral SRP by blocking idle for 1s
+  * musb_hdrc: Fix HNP for OPT FS A tests
+  * musb_hdrc: Fix OPT A tests for most part
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 26 Jun 2007 15:45:45 +0300
+
+kernel-source-rx-34 (2.6.21-osso27) unstable; urgency=low
+
+  * week200725-2 release
+  * DVFS: tsc2005: Add missing unlock_irq on one exit path 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 19 Jun 2007 18:56:59 +0300
+
+kernel-source-rx-34 (2.6.21-osso26) unstable; urgency=low
+
+  * week200725-1 release. Fixes: NB#59197, NB#57267
+  * MTD: OneNAND: Revert "OneNAND: Respond faster to DVFS"
+  * MTD: OneNAND: Simplify DVFS handling
+  * DVFS: Fix DSP timeout problem when loading dynamic codecs
+  * DVFS: Fix obsolete function argument type
+  * ARM: OMAP2: Dynamic Idle: avoid managing scratch registers
+  * DVFS: Convert to_dvfs_notif() to DVFS_NOTIF()
+  * ARM: OMAP2: DVFS: Change notifications timeout unit
+  * ARM: OMAP2: N800: Fix misleading error notification.
+  * DVFS: tsc2005: Fix reaction to dvfs notifications
+  * ALSA: Remove one needless assumed HW bug workaround in AIC33
+  * ALSA: Remove DAC muting/unmuting from AIC33 DAC enable/disable functions
+  * NF: IDLETIMER module didn't set the IPv4 protocol when registering callback
+  * DVFS: cpufreq_set_policy() is removed from upstream kernel
+  * Remove a race condition from dispc interrupt handler.
+  * ALSA: Tweak bluetooth port settings in EAC
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 19 Jun 2007 16:09:44 +0300
+
+kernel-source-rx-34 (2.6.21-osso25) unstable; urgency=low
+
+  * week200724-2 release
+  * DVFS: make DVFS header compile when DVFS is disabled.
+  * ARM: OMAP: DMA: Make DMA code compile with DVFS disabled.
+  * V4L: Add sensor interface proposal.
+  * TCM825x: use new interface and other updates.
+  * ARM: OMAP2: Camera: update to new interface, other fixes.
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu, 14 Jun 2007 16:49:57 +0300
+
+kernel-source-rx-34 (2.6.21-osso24) unstable; urgency=low
+
+  * week200724-1 release. Fixes: NB#59657, NB#59823
+  * OneNAND: Respond faster to DVFS
+  * Enable Voltage scaling with workaround for VMODE bug
+  * ARM: OMAP: RX-44: Swap Enter and KP_Enter
+  * ARM: OMAP: RX-44: Fix LED PWM definitions
+  * I2C: LM8323: Re-enable PWM3
+  * I2C: LM8323: Add disable_kp interface
+  * ARM: OMAP: Fix warning in tusb6010_omap.c
+  * MUSB_HDRC: Fix usb production test issues
+  * Revert "musb_hdrc: Implement workaround for tusb3.0 wbus bug rev2"
+  * DVFS: Add printk to check DSP PRE_NOTIFICATION timeout on console
+  * DVFS: DSPGW: Fix to eliminate the possibility of DSP status change
+  * DVFS: Fix missing update along with DVFS FW
+  * DVFS: Fix trivial typo
+  * DVFS: Fix error when dsp is not used yet during DVFS
+  * DVFS: DSP: Add error recovery for PRE_NOTIFICATION failing
+  * DVFS: Add return value check for (pre)notification
+  * ARM: OMAP2: DVFS: Fix frequency scaling function
+  * ARM: OMAP2: DVFS: disable DVS and OP3
+  * ARM: OMAP2: DVFS: Header and internal structures.
+  * ARM: OMAP2: DVFS: Notifications helper functions
+  * ARM: OMAP2: DVFS: Add/remove drivers to notification
+  * ARM: OMAP2: DVFS: Send notifications
+  * ARM: OMAP2: DVFS: USB registration fix.
+  * ARM: OMAP2: DVFS: DMA registration fix.
+  * ARM: OMAP2: DVFS: DSP registration fix.
+  * ARM: OMAP2: DVFS: Cam registration fix.
+  * ARM: OMAP2: DVFS: OneNAND registration fix.
+  * ARM: OMAP2: DVFS: MCSPI registration fix.
+  * ARM: OMAP2: DVFS: tsc2005 registration fix.
+  * ARM: OMAP2: DVFS: framebuffer registration fix.
+  * ARM: OMAP2: DVFS: Notifications, cleanup
+  * MTD: ONENAND: Whitespaces cleanup
+  * ARM: OMAP2: DVFS: Fix min notification timeout cap
+  * ARM: OMAP2: DVFS: Cosmetic fix to messages to syslog
+  * ARM: OMAP2: DVFS: Improve comments upon driver reg/unreg
+  * ARM: OMAP2: DVFS: Improve error tracking for notifications
+  * ALSA: Hack to prevent strong audiple pop in AIC33
+  * ALSA: Do not cache reserved and unused registers in AIC33
+  * ALSA: Synchronize AIC33 register cache with the chip during initialization
+  * ALSA: Remove forced write hack from AIC33 put callbacks
+  * ARM: OMAP2: DVFS: Re-enable OP3
+  * ARM: OMAP: Support for HS-USB on 2430SDP
+  * Fixed dsp_state_updated to properly restore frequency
+  * Increase DVFS transition latency
+  * Add type parameter to dsp_state_updated()
+  * tsc2301-ts: update to use median + avg filtering
+  * Use in-kernel sockets API
+  * Fix L2CAP configuration parameter handling
+  * ARM: OMAP2: Camera: invert lclk polarity.
+  * ARM: OMAP: TCM825x: invert dclk polarity.
+  * musb_hdrc: PM & interrupt fixes for tusb6010
+  * Revert "HSET tool for the MUSB Controler"
+  * Revert "musb_hdrc: PM & interrupt fixes for tusb6010"
+  * musb_hdrc: Improve tusb revision checking
+  * musb_hdrc: Workaround for tusb spontaneous wake-up issue
+  * musb_hdrc: Mask tusb interrupts while being handled
+  * musb_hdrc: Fixes to improve mode switching and VBUS detection for tusb
+  * Revert "Fix mis-reporting USB Mode on sysfs"
+  * musb_hdrc: Sync up tusb6010.c with linux-omap
+  * musb_hdrc: Minor fixes to changing tusb role via sysfs
+  * musb_hdrc: Fix non-standard loopback test to support ID pin
+  * DVFS: Don't change tusb to use internal clock
+  * musb_hdrc: Fix non-standard loopback test
+  * Add support for deferrable timers
+  * Add a new deferrable delayed work init
+  * musb_hdrc: MUSB HOST support on 2430SDP
+  * musb_hdrc: MUSB plat_uds.c fix
+  * Enable uart clocks while shutting down dev
+  * BLUETOOTH: Use cpu_to_le{16,32}() where appropriate.
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 13 Jun 2007 15:19:31 +0300
+
+kernel-source-rx-34 (2.6.21-osso23) unstable; urgency=low
+
+  * week200723-2 release
+  * Keep rfcomm_dev in list until it is freed
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed,  6 Jun 2007 14:21:31 +0300
+
+kernel-source-rx-34 (2.6.21-osso22) unstable; urgency=low
+
+  * week200723-1 release. Fixes: NB#56874, NB#58953
+  * Removed debian changelog entries
+  * Recalculate SDRAM refresh timer upon OP change
+  * Input: TSC2301: Add optional keypad name via platform data
+  * I2C: LM8323: Add device name via platform data
+  * ARM: OMAP: N800: Give internal keypad a sensible name
+  * ARM: OMAP: RX-44: Give internal keyboard a sensible name
+  * MUSB_HDRC: Put the production in better shape
+  * ARM: OMAP2: DVFS: Remove all the write memory barriers
+  * ARM: OMAP2: DVFS: Fix notifications timeout
+  * Expose streaming state to sysfs
+  * MMC: Avoid using a null pointer when preparing a request
+  * MMC: Abort stuck commands
+  * TSC2301 Mixer: GPIO restore fix
+  * ALSA: Enable AIC33 output state power control with switch controls as well
+  * ALSA: Keep AIC33 outputs muted by default and let the user space active them
+  * ALSA: Redefine Digital Mic control in AIC33
+  * ALSA: Redefine Digital Mic control rules in AIC33
+  * ALSA: Change output state powering and unmuting order in AIC33
+  * I2C: LP5521 RGB LED: Add sysfs entry for modifying led current
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue,  5 Jun 2007 17:09:37 +0300
+
+kernel-source-rx-34 (2.6.21-osso21) unstable; urgency=low
+
+  * Fixed bugfixes in changelog. Fixes: NB#57858, NB#55241, NB#57582,
+    NB#56403.
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 29 May 2007 17:24:40 +0300
+
+kernel-source-rx-34 (2.6.21-osso20) unstable; urgency=low
+
+  * week200722-3 release
+  * OneNAND: Fix timings for DVFS
+  * Remove duplicate DVFS notification callback
+  * musb_hdrc: Add SRP Interface and control it through sysfs
+  * Add Sysfs Interface to Control Vbus states
+  * Add more Test Modes
+  * HSET tool for the MUSB Controler
+  * Leave GPIO[7:6] pullups enabled.
+  * Remove unnecessary state machine sysfs entry
+  * Make SRP pass in all Electrical Tests
+  * Security: Kernel OOM-killer and allocation denial use different rules
+  * Fix blizzard to not enable osc_ck on every DVFS notify (second try, no ws)
+  * Pass process information to userspace coredump helper
+  * USB: Disable file_storage USB_CONFIG_ATT_WAKEUP
+  * musb_hdrc: Implement workaround for tusb3.0 wbus bug rev2
+  * musb_hdrc: Make HNP work
+  * USB: Fix OTG HNP for hub.c
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 29 May 2007 17:18:58 +0300
+
+kernel-source-rx-34 (2.6.21-osso19) unstable; urgency=low
+
+  * week200722-2 release 
+  * ARM: OMAP2: DVFS: remove all the temporary code
+  * ARM: OMAP2: DVFS: OMAP2 DVFS driver interface
+  * ARM: OMAP2: DVFS: Processor driver internal data.
+  * ARM: OMAP2: DVFS: OP packing
+  * ARM: OMAP2: DVFS: Creation of transition table.
+  * ARM: OMAP2: DVFS: Create sorted list of frequencies.
+  * ARM: OMAP2: DVFS: Add interface to load OP configurations
+  * ARM: OMAP2: DVFS: Add get/set OP functionality
+  * ARM: OMAP2: DVFS: Debug interface for get/set OP
+  * ARM: OMAP2: DVFS: DVFS Initialisation function.
+  * ARM: OMAP2: DVFS: Fix initialization of DVFS
+  * ARM: OMAP2: DVFS: Configuration of supported OPs
+  * ARM: OMAP2: CPUFREQ: Update hardcoded OP.
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 25 May 2007 15:48:58 +0300
+
+kernel-source-rx-34 (2.6.21-osso18) unstable; urgency=low
+
+  * week200722-1 release
+  * OMAP2 DVFS support for McSPI
+  * Fix threaded DVFS notification logic and corresponding drivers
+  * ALSA: Trivial fix to AIC33 input gain get function
+  * ALSA: Hack: Force register write always in AIC33 put callbacks
+  * I2C: LM8323: Fix keyboard and keypad LED illuminatium issues
+  * Hot fix. For lcd_omap_selftest.
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 25 May 2007 15:15:08 +0300
+
+kernel-source-rx-34 (2.6.21-osso17) unstable; urgency=low
+
+  * week200721-1 release
+  * OneNAND: DVFS workaround
+  * OMAP2 DVFS support for TUSB6010
+  * LED: OMAP PWM: Use work queue for brightness
+  * Fix mis-reporting USB Mode on sysfs
+  * Sysfs USB OTG State Machine Interface
+  * Re-enable DMA on TUSB6010.
+  * OMAP: MMC: Add error recovery in ISR when a command/data error
+  * ARM: OMAP2: RX-34/RX-44: Revised Operating points
+  * RX-44: tsc2005: DVFS support
+  * ARM: OMAP2: PM: Remove duplicated code.
+  * ARM: OMAP2: DVFS: TSC2005: Cleanup notifications handling.
+  * OMAP: MMC: Fix timeout calculation
+  * MMC: Use 1.8V correctly on slots 0 and 1
+  * MMC: Enable highspeed MMC and SD capability
+  * I2C: LM8323: Coding style update
+  * ARM: OMAP: Remove support for TLV320AIC33 from Nokia N800 defconfig
+  * ALSA: Gradual update patch to AIC33. Code removal for re-implementation
+  * ALSA: Gradual update patch to AIC33. Add support to digital microphone
+  * ARM: OMAP: Add digital microphone into Nokia RX-44 AIC33 configuration
+  * ALSA: Clean-up AIC33
+  * ARM: OMAP: RX-44: Remove unused rx44_devices array
+  * ARM: OMAP: RX-44: Call tsl2563_dev_init in board-rx44.c
+  * ALSA: Add one missing register into AIC33 header file
+  * ALSA: Rename DOUBLE control build macros in AIC33 to DOUBLE_R
+  * ALSA: Add build macros for input gain controls in AIC33
+  * ALSA: Implement AIC33_IGAIN_DOUBLE_R control functions in AIC33
+  * ALSA: Hack-add Nokia RX-44 specific Mic1 input gain controls into AIC33
+  * I2C: LP5521: Set current to 4,7mA for RGB LEDs
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 22 May 2007 16:45:58 +0300
+
+kernel-source-rx-34 (2.6.21-osso16) unstable; urgency=low
+
+  * week200720-1 release. Fixes: NB#55509
+  * ARM: OMAP: Enable support for retu-headset driver in Nokia N800 and RX-44 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 15 May 2007 13:40:10 +0300
+
+kernel-source-rx-34 (2.6.21-osso15) unstable; urgency=low
+
+  * Changelog cleanup 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 11 May 2007 15:58:22 +0300
+
+kernel-source-rx-34 (2.6.21-osso14) unstable; urgency=low
+
+  * week200719-4 release
+  * I2C: LM8323: Use work queue for PWM writes
+  * ARM: OMAP2: RX-34/RX-44: Fix plat description of retu-rtc
+  * ARM: OMAP2: RX-34/RX-44: Fix plat description of tahvo
+  * ARM: OMAP2: RX-34/RX-44: Fix plat description of tahvo-usb
+  * Add tsl2563 to hwmon class
+  * ALSA: Add bypass path controls from input PGA to output stages in AIC33
+  * ALSA: Add some register definitions into AIC33 header file
+  * ALSA: Gradual update patch to AIC33. Removal of OMAP GPIO dependencies
+  * ARM: OMAP: Update board-n800-audio with AIC33 changes
+  * ALSA: Miscellaneous clean-ups to AIC33
+  * ALSA: Rename function tlv320aic33_write_value to tlv320aic33_write in AIC33
+  * ALSA: HACK: Activate high-power and line outputs by default in AIC33
+  * ALSA: Two fixes to AIC33 "Capture Volume" control
+  * Add and enable new CPUFREQ null govenor
+  * Add support for CPUFREQ 
+  * Add interface to track DSP state change
+  * I2C: LP5521: Enable automatic power save mode for RGB LED
+  * Check that device is in rfcomm_dev_list before deleting
+  * Disconnect l2cap connection after last dlc
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 11 May 2007 15:31:07 +0300
+
+kernel-source-rx-34 (2.6.21-osso13) unstable; urgency=low
+
+  * week200719-2 release
+  * 8250: fix possible deadlock between serial8250_handle_port() and serial8250_interrupt()
+  * ALSA: Fix OMAP24xx EAC codec port I2S master/slave support
+  * ARM: OMAP2: Force APLLs always active
+  * ARM: OMAP2: Place SMS and SDRC into smart idle mode
+  * ARM: OMAP: /sys/kernel/debug/omap_gpio
+  * ARM: OMAP: 2430SDP support for omap2 OneNAND driver
+  * ARM: OMAP: 243x: Add mappings for SDRC and SMS
+  * ARM: OMAP: 24xx pinmux updates
+  * ARM: OMAP: Add DMA IRQ sanity checks
+  * ARM: OMAP: Add DSP common code
+  * ARM: OMAP: Add apollon gpio keys using gpio-keys input
+  * ARM: OMAP: Add function to print clock usecounts
+  * ARM: OMAP: Add mailbox support for IVA
+  * ARM: OMAP: Add minimal OMAP2430 support
+  * ARM: OMAP: Add omap osk defconfig
+  * ARM: OMAP: Add omap2430 watchdog IO mapping
+  * ARM: OMAP: Add support for Amstrad Delta keypad
+  * ARM: OMAP: Add support for high-speed I2C init
+  * ARM: OMAP: Avoid updating system time for sub-jiffy interrupts
+  * ARM: OMAP: Basic support for siemens sx1
+  * ARM: OMAP: Board Apollon update, fix boot
+  * ARM: OMAP: Device init for OMAP24xx Enhanced Audio Controller
+  * ARM: OMAP: Enable 24xx GPIO autoidling
+  * ARM: OMAP: Enable DSP clocks for McBSP on omap310
+  * ARM: OMAP: Enable serial idling and wakeup features
+  * ARM: OMAP: FB sync with N800 tree (support for dynamic SRAM allocations)
+  * ARM: OMAP: FB: add controller platform data
+  * ARM: OMAP: Finish converting retu and retu-wdt to platform devices
+  * ARM: OMAP: Fix GCC-reported compile time bug
+  * ARM: OMAP: Fix PRCM base register usage for 243x
+  * ARM: OMAP: Fix gpmc header
+  * ARM: OMAP: Fix typo in board-h4.h
+  * ARM: OMAP: Fix warning in lcdc.c
+  * ARM: OMAP: Fix warning in timer32k.c
+  * ARM: OMAP: H2 lcd updates for SPI framework
+  * ARM: OMAP: H3 workqueue fixes
+  * ARM: OMAP: Implement workaround for GPIO wakeup bug in OMAP2420 silicon
+  * ARM: OMAP: MPUIO wake updates
+  * ARM: OMAP: Merge PM code from N800 tree
+  * ARM: OMAP: Merge board specific files from N800 tree
+  * ARM: OMAP: Merge driver headers from N800 tree
+  * ARM: OMAP: Merge gpmc changes from N800 tree
+  * ARM: OMAP: Mostly cosmetic to sync up with linux-omap tree
+  * ARM: OMAP: N770: add missing LCD, LCD controller, touchscreen device registration 
+  * ARM: OMAP: OSK led fixes
+  * ARM: OMAP: Optimize INTC register accesses and enable autoidling
+  * ARM: OMAP: Palm Tungsten E board update
+  * ARM: OMAP: Palm Tungsten|T support
+  * ARM: OMAP: Palm T|E board definition update
+  * ARM: OMAP: PalmZ71 support
+  * ARM: OMAP: Register tsc2102 on Palm Tungsten E
+  * ARM: OMAP: Replace mach-omap/omap2 with mach-omap2
+  * ARM: OMAP: Sync H4 board init with linux-omap
+  * ARM: OMAP: Sync board specific files with linux-omap
+  * ARM: OMAP: Sync core code with linux-omap
+  * ARM: OMAP: Sync framebuffer headers with N800 tree
+  * ARM: OMAP: Sync headers with linux-omap
+  * ARM: OMAP: TSC2101: add platform init / registration to board files
+  * ARM: OMAP: TUSB EVM init
+  * ARM: OMAP: Tabify mux.c
+  * ARM: OMAP: USB peripheral support on H4
+  * ARM: OMAP: Update EAC codec port mode in board-n800-audio.c
+  * ARM: OMAP: Update Nokia N800 defconfig
+  * ARM: OMAP: Update omap h2 defconfig
+  * ARM: OMAP: Update timer32k.c to compile
+  * ARM: OMAP: abstract debug card setup (smc, leds)
+  * ARM: OMAP: add 24xx GPIO debounce support
+  * ARM: OMAP: add SoSSI clock
+  * ARM: OMAP: add SoSSI clock (call propagate_rate for childrens)
+  * ARM: OMAP: add SoSSI clock (remove manual checking of SoSSI state from idle)
+  * ARM: OMAP: cleanup apollon board
+  * ARM: OMAP: fix OMAP1 dmtimer build warning
+  * ARM: OMAP: fix OMAP1 mpuio suspend/resume oops
+  * ARM: OMAP: gpio init section cleanups
+  * ARM: OMAP: gpio object shrinkage, cleanup
+  * ARM: OMAP: h4 must have blinky leds!!
+  * ARM: OMAP: omap camera builds again; Mistral init and mux
+  * ARM: OMAP: omap2/gpmc updates
+  * ARM: OMAP: omap2/memory.c compile fixes
+  * ARM: OMAP: osk+mistral backlight, power, board specific
+  * ARM: OMAP: partial LED fixes
+  * ARM: OMAP: plat-omap changes for 2430 SDP
+  * ARM: OMAP: restore CONFIG_GENERIC_TIME
+  * ARM: OMAP: rx-44 depends on n800, remove duplicate linking
+  * ARM: OMAP: speed up gpio irq handling
+  * ARM:OMAP: Add initial TWL support for non-MPU MMU framework
+  * Add Nokia CBUS support
+  * Add mbuesch to .mailmap
+  * Add missing USRobotics Wireless Adapter (Model 5423) id into zd1211rw
+  * Allow reading tainted flag as user
+  * Char: icom, mark __init as __devinit
+  * Char: mxser, fix TIOCMIWAIT
+  * Char: mxser_new, fix TIOCMIWAIT
+  * Char: mxser_new, fix recursive locking
+  * Fix possible NULL pointer access in 8250 serial driver
+  * Fix spelling in drivers/video/Kconfig
+  * Fixed booting omap2 again
+  * Formating changes for Basic OMAP2430 High speed I2C
+  * Get TSC2101 and TSC2102 drivers in sync with new ALSA struct naming
+  * I2C: Add high-speed support to omap-i2c
+  * IB/mthca: Fix data corruption after FMR unmap on Sinai
+  * IPv6: fix Routing Header Type 0 handling thinko
+  * KVM: Fix off-by-one when writing to a nonpae guest pde
+  * Linux 2.6.21
+  * Longhaul - Revert ACPI C3 on Longhaul ver. 2
+  * MAINTAINERS: use lists.linux-foundation.org
+  * MTD: Add onenand support for omap24xx
+  * Minor bug fixes to i2c-pasemi
+  * NF: Add iptables IDLETIMER target
+  * NFS: Don't clear PG_writeback until after we've processed unstable writes
+  * NFS: Fix race in nfs_set_page_dirty
+  * NFS: Fix the 'desynchronized value of nfs_i.ncommit' error
+  * NFS: clean up the unstable write code
+  * RPC: Fix the TCP resend semantics for NFSv4
+  * Revert "adjust legacy IDE resource setting (v2)"
+  * Revert "e1000: fix NAPI performance on 4-port adapters"
+  * SPI: Add TSC2102 main SPI driver
+  * SPI: Add an SPI master driver for the OMAP2 McSPI controller
+  * SPI: Add support for TSC2101
+  * SPI: Add support for TSC2301 protocol driver
+  * SPI: TSC2046 touchscreen support
+  * Taskstats fix the structure members alignment issue
+  * USB: Allow transfer_buffer with transfer_dma
+  * WATCHDOG: use base address from platform resources and make 2430 boot again
+  * [ARM] 4313/1: S3C24XX: Update s3c2410 defconfig to 2.6.21-rc6
+  * [ARM] Update mach-types
+  * [BNX2]: Fix occasional NETDEV WATCHDOG on 5709.
+  * [BRIDGE]: Unaligned access when comparing ethernet addresses
+  * [IPSEC] af_key: Fix thinko in pfkey_xfrm_policy2msg()
+  * [IPV6]: Disallow RH0 by default.
+  * [IrDA]: Correctly handling socket error
+  * [KEY]: Fix conversion between IPSEC_MODE_xxx and XFRM_MODE_xxx.
+  * [MIPS] Add missing silicon revisions for BCM112x
+  * [MIPS] Disallow CpU exception in kernel again.
+  * [MIPS] Fix BUG(), BUG_ON() handling
+  * [MIPS] Fix oprofile logic to physical counter remapping
+  * [MIPS] Fix wrong checksum for split TCP packets on 64-bit MIPS
+  * [MIPS] Retry {save,restore}_fp_context if failed in atomic context.
+  * [NETLINK]: Don't attach callback to a going-away netlink socket
+  * [NETLINK]: Infinite recursion in netlink.
+  * [NET]: Fix UDP checksum issue in net poll mode.
+  * [NET]: Get rid of alloc_skb_from_cache
+  * [NET]: Set a separate lockdep class for neighbour table's proxy_queue
+  * [PARPORT] SUNBPP: Fix OOPS when debugging is enabled.
+  * [PPP]: Fix skbuff.c:BUG due incorrect logic in process_input_packet()
+  * [SBUS] vfc_dev.c: kzalloc
+  * [SCTP]: Do not interleave non-fragments when in partial delivery
+  * [SCTP]: Fix assertion (!atomic_read(&sk->sk_rmem_alloc)) failed message
+  * [SCTP]: Unmap v4mapped addresses during SCTP_BINDX_REM_ADDR operation.
+  * [SPARC] openprom: Switch to ref counting PCI API
+  * [SUNHME]: Fix module unload.
+  * [SUNLANCE]: Fix module unload.
+  * [SUNQE]: Fix MAC address assignment.
+  * [TCP]: Congestion control initialization.
+  * [XFRM]: beet: fix pseudo header length value
+  * [netdrvr] depca: handle platform_device_add() failure
+  * acpi-thermal: fix mod_timer() interval
+  * allow vmsplice to work in 32-bit mode on ppc64
+  * alpha: build fixes - force architecture
+  * alpha: fixes for specific machine types
+  * alpha: more fixes for specific machine types
+  * cache_k8_northbridges() overflows beyond allocation
+  * cfq-iosched: fix alias + front merge bug
+  * cfq-iosched: fix sequential write regression
+  * check node crc before doing anything else
+  * check node crc before doing anything else
+  * check node crc before doing anything else
+  * cxgb3 - Fix low memory conditions
+  * cxgb3 - PHY interrupts and GPIO pins.
+  * do not truncate irq number for icom adapter
+  * drivers/macintosh/smu.c: fix locking snafu
+  * drivers/net/hamradio/baycom_ser_fdx build fix
+  * exec.c: fix coredump to pipe problem and obscure "security hole"
+  * fault injection: add entry to MAINTAINERS
+  * fix OOM killing processes wrongly thought MPOL_BIND
+  * fix bogon in /dev/mem mmap'ing on nommu
+  * gianfar needs crc32 lib dependency
+  * hpt366: fix kernel oops with HPT302N
+  * hwmon/w83627ehf: Don't redefine REGION_OFFSET
+  * hwmon/w83627ehf: Fix the fan5 clock divider write
+  * i2c-pasemi: Depend on PPC_PASEMI again
+  * i2c: Merge omap i2c drivers from omap-historic
+  * i386: Fix some warnings added by earlier patch
+  * ide/Kconfig: add missing range check for IDE_MAX_HWIFS
+  * ide/pci/delkin_cb.c: add new PCI ID
+  * ieee1394: update MAINTAINERS database
+  * kernel-doc: fix plist.h comments
+  * knfsd: use a spinlock to protect sk_info_authunix
+  * musb_hdrc: Allow tusb dma to transfer various data sizes
+  * musb_hdrc: Avoid host babble by checking tx fifo
+  * musb_hdrc: Clean-up TUSB fifo access
+  * musb_hdrc: DMA RX workaround for tusb6010
+  * musb_hdrc: Enable host DMA for tusb6010
+  * musb_hdrc: Stop host session on BABBLE
+  * musb_hdrc: Transfer remaining bytes with PIO
+  * omap2: fix clock.h rate_offset whitespace
+  * omap2: merge CONTROL_STATUS defines
+  * omap2: standardize clock.h enable_reg/enable_bit order
+  * omap2: use symbolic constant to mark parent-controlled clocks in clock.[ch]
+  * oom: kill all threads that share mm with killed task
+  * packet: fix error handling
+  * page migration: fix NR_FILE_PAGES accounting
+  * paride drivers: initialize spinlocks
+  * pata_sis: Fix oops on boot
+  * reiserfs: fix xattr root locking/refcount bug
+  * serial: 8250 changes for omap
+  * sis900: Allocate rx replacement buffer before rx operation
+  * sky2: EC-U performance and jumbo support
+  * sky2: disable ASF on all chip types
+  * sky2: disable support for 88E8056
+  * sky2: handle descriptor errors
+  * sky2: no jumbo on Yukon FE
+  * sky2: version 1.14
+  * smc91x: Add code to detect errors caused by bad memory timings
+  * smc91x: Clean up omap machine type handling
+  * spi: fix use of set_cs in spi_s3c24xx driver
+  * spidernet: Fix problem sending IP fragments
+  * ufs proper handling of zero link case
+  * usb-net/pegasus: fix pegasus carrier detection
+  * v9fs: don't use primary fid when removing file
+  * x86-64: Always flush all pages in change_page_attr
+  * x86-64: make GART PTEs uncacheable
+  * x86: Fix gcc 4.2 _proxy_pda workaround
+  * x86: Fix potential overflow in perfctr reservation
+  * x86: Remove noreplacement option
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue,  8 May 2007 16:59:49 +0300
+
+kernel-source-rx-34 (2.6.21-osso12) unstable; urgency=low
+
+  * week200719-2 preprerelease, waiting for changelog 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Sun,  6 May 2007 17:21:28 +0300
+
+kernel-source-rx-34 (2.6.21-osso11) unstable; urgency=low
+
+  * week200718-1 release
+  * ARM: OMAP2: Camera: Properly set video_device's parent device
+  * ARM: OMAP2: Camera: update: mostly DVFS and reset related issues.
+  * ARM: OMAP2: DVFS notification registration checks for end-of-transition
+  * ARM: OMAP2: RX-34/RX-44: Add DVS to DFS
+  * ARM: OMAP2: RX-34/RX-44: Dynamic Voltage Scaling support for OMAP2
+  * ARM: OMAP: Build USB Gadget Support as modules for nokia 2420
+  * ARM: OMAP: DVFS: Add DSS1 clock scaling
+  * ARM: OMAP: Fix to make omap_mbox_send_sync() independently
+  * ARM: OMAP: MMC: Use sys_notify for userland event monitor
+  * ARM: OMAP: RX-44: Add cover as third PWM
+  * ARM: OMAP: RX-44: Add slide and lock GPIOs
+  * ARM: OMAP: Raise bootloader tag size
+  * ARM: OMAP: Remove rx44_defconfig
+  * ARM: OMAP: Rename nokia 2420 defconfig
+  * ARM: OMAP: update nokia 2420 defconfig
+  * ARM: OMAP: update nokia 2420 defconfig
+  * Added missing CONFIG_SCSI_MULTI_LUN to nokia_2420_defconfig
+  * DVFS: Add support DSP with DSP side S/W assistant
+  * DVFS: Add timeout to wait DSP reply for reliability
+  * DVFS: Fix notifier kernel thread problem when suspending
+  * DVFS: Re-enabled DVFS kernel thread for DSP
+  * Disable summary after wbuf recovery
+  * FB: OMAP: Add Blizzard DVFS support
+  * FB: OMAP: Add DVFS handling
+  * FB: OMAP: Be a little more verbose in RFBI error situations
+  * I2C: Add LP5521 LED driver
+  * I2C: LM8323: Fix author annotation
+  * MUSB_HDRC: Allow selecting OTG, peripheral or host mode via sysfs
+  * OMAP: Store switch state for OUTPUT gpio-switches
+  * OTG WHITELIST
+  * Prevent list corruption when handling write errors
+  * TUSB6010 Loopback Test
+  * check node crc before doing anything else
+  * fix deadlock on error path
+ 
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 27 Apr 2007 17:55:40 +0300
+
+kernel-source-rx-34 (2.6.21-osso10) unstable; urgency=low
+
+  * week200717-2 release
+  * mmc: Add high capacity mmc card support
+  * ARM: OMAP2: Camera: driver update.
+  * ARM: OMAP2: Camera: Add initial DVFS support.
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 24 Apr 2007 14:37:20 +0300
+
+kernel-source-rx-34 (2.6.21-osso9) unstable; urgency=low
+
+  * Fixed changelog (added skipped records)
+  * DVFS: Fix incorrect event use of DVFS event variables
+  * DVFS: Fix incorrect use of daemonize
+  * DVFS: Initial DVFS support for DSPGW
+  * ARM: OMAP: Add resume/suspend interface for OMAP mailbox FW
+  * DSP: Add sysfs entry to monitor DSP KFUNC device state
+  * DVFS: Enable DVFS in nokia_internet_tablet_2420_defconfig
+  * DVFS: Add dvfs_notify_pid check for notify callback in ONENAND
+  * DVFS: Add dvfs_notify_pid in DSP to use kernel_thread for Notifier
+  * ARM: OMAP: Add mbox_send_sync interface for omap mailbox
+  * ARM: OMAP: Add mbox_send_sync interface for omap mailbox
+  * ARM: OMAP: N800: Fix build warning in board-n800-pm.c
+  * DVFS: Fix incorrect function pointer set in omap DMA
+  * DVFS: Converted semaphore to mutex
+  * ARM: OMAP: Fix dma.c compilation for non-dvfs configs
+  * ARM: OMAP: Fix dma.c compilation for non-dvfs configs
+  * ARM: Enable TMP105 on OMAP2420 based Nokia Internet Tablets
+  * ARM: OMAP2: Camera: Fix crash in omap24xxcam_sensor_init.
+ 
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Mon, 23 Apr 2007 15:36:06 +0300
+
+kernel-source-rx-34 (2.6.21-osso8) unstable; urgency=low
+
+  * week200717-1 release
+  * DVFS: Workaround for kernel_thread problem
+  * mmc: OMAP: Use R6 with SD_SEND_RELATIVE_ADDR
+  * mmc: OMAP: Add multislot support
+  * MMC: Enable MMC support on Omap
+  * HWMON: Add TMP105 temperature sensor driver
+  * HWMON: Add TMP105 temperature sensor to Kconfig and Makefile
+  * ARM: Enable TMP105 on OMAP2420 based Nokia Internet Tablets
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Mon, 23 Apr 2007 14:46:26 +0300
+
+kernel-source-rx-34 (2.6.21-osso7) unstable; urgency=low
+
+  * week200716-2 release
+  * ARM: OMAP: Enable bluetooth in nokia combo config
+  * Revert "ARM: OMAP2: Add hardware configuration for camera block and  camera sensor."
+  * ARM: OMAP2: Camera: Add generic OMAP camera platform_device.
+  * N800, RX44: Add hardware-dependent configuration for camera sensor.
+  * RX44: Add camera and sensor drivers to default configuration.
+  * N800: Fix default configuration.
+  * ALSA: Add bluetooth port support and audio path controls into OMAP24xx  EAC
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 17 Apr 2007 18:10:34 +0300
+
+kernel-source-rx-34 (2.6.21-osso6) unstable; urgency=low
+
+  * debian/rules: changed defconfig name 
+  * ARM: Add defconfig for OMAP2420 based Nokia Internet Tablets
+  * ARM: OMAP: DVFS cleanup
+  * DVFS: Add DFS support for OneNAND driver
+  * DSPGW: Remove unused mailbox memeber
+  * ARM: OMAP: ONENAND: Whitespace cleanup: drivers/mtd/onenand/omap2.c
+  * DVFS: Fix build error with DVFS disabled in kernel config
+  * ARM: OMAP: ONENAND: Add space in error message
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Mon, 16 Apr 2007 18:25:17 +0300
+
+kernel-source-rx-34 (2.6.21-osso5) unstable; urgency=low
+
+  * Forbidden words cleanup 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 11 Apr 2007 13:01:50 +0300
+
+kernel-source-rx-34 (2.6.21-osso4) unstable; urgency=low
+
+  * week200715-2 release
+  * ARM: OMAP: RX-44: Enable omap uart driver in defconfig
+  * N800: Fix default configuration.
+  * RX44: Add camera and sensor drivers to default configuration.
+  * N800, RX44: Add hardware-dependent configuration for camera sensor.
+  * ARM: OMAP2: Camera: Add generic OMAP camera platform_device.
+  * Revert "ARM: OMAP2: Add hardware configuration for camera block and camera sensor."
+  * ARM: OMAP: DVFS cleanups
+  * ARM: OMAP: DVFS for n800
+  * ARM: OMAP: Transparently queue dma requests during DVFS transitions
+  * ARM: OMAP: Send pre & post notifications for dvfs
+  * ARM: OMAP: Sync clk fw state with current HW settings
+  * ARM: OMAP: Takes a snapshot of a set of memory locations
+  * ARM: OMAP: Peek'nPoke 8, 16 & 32 bit words
+  * ARM: OMAP: Enables Observability Modes
+  * ARM: OMAP: Debug Mode
+  * OMAP: Add serial driver for OMAP UARTs
+  * ARM: OMAP2: Add hardware configuration for camera block and camera sensor.
+  * ARM: OMAP: Camera if: Modify camera/sensor interface.
+  * ARM: OMAP2: Camera, TCM825x: Add entries to Makefile and Kconfig.
+  * ARM: OMAP: TCM825x: Add driver.
+  * ARM: OMAP2: Camera: Add driver.
+  * ALSA: Remove include statement for non-existing header file in AIC33 driver
+  * ALSA: Remove non-global AIC33 header file
+  * ARM: OMAP: FB: Properly initialise struct in full-screen update
+  * I2C: LM8323: Fix debugging
+  * ARM: OMAP: RX-44: Minor keymap updates
+  * ARM: Activate audio support in rx44_defconfig
+  * ARM: OMAP: Add audio support to Nokia RX-44
+  * Add driver for TLV320AIC23 audio codec
+  * ALSA: Fix OMAP24xx EAC codec port I2S master/slave support
+  * Add TSL2563 to rx44_defconfig
+  * Add TSL2563 driver
+  * ARM: OMAP2: RX-44: Add LM8323 to defconfig
+  * ARM: OMAP2: RX-44: Add support for new LM8323 driver
+  * I2C: Add NSC LM8323 driver
+  * ARM: OMAP: RX-44: Remove old LM8323 code
+  * Add TSC2005 touchscreen support
+  * ARM: OMAP: Dummy fix to make board-rx44.o linkable along with board-n800.o
+  * ARM: Add board rx44_defconfig
+  * ARM: OMAP: Add basic support for Nokia RX-44 board
+  * ARM: Hack add machine type for Nokia RX-44
+  * ARM: OMAP: N800 mach type
+  * RX-44:DVFS: Rename dvfs_op to dvfs_init_op
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 10 Apr 2007 21:07:04 +0300
+
+kernel-source-rx-34 (2.6.21-osso3) unstable; urgency=low
+
+  *  Package name back
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue,  3 Apr 2007 18:16:38 +0300
+
+kernel-source-rx-44 (2.6.21-osso3) unstable; urgency=low
+
+  * real rx-44-2007-14-1 release
+  * Oulu's blizzard.c  reverted
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue,  3 Apr 2007 16:49:09 +0300
+
+kernel-source-rx-44 (2.6.21-osso2) unstable; urgency=low
+
+  * Oulu's blizzard.c. 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Mon,  2 Apr 2007 18:56:29 +0300
+
+kernel-source-rx-44 (2.6.21-osso1) unstable; urgency=low
+
+  * week200714-1 release
+  * First RX-44 release
+  * Updated upstream sources
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Mon,  2 Apr 2007 18:53:47 +0300
+
+kernel-source-rx-34 (2.6.18-osso42) unstable; urgency=low
+
+  * week200713-1 release
+  * MMC: Add support for mmc v4 high speed mode
+  * mmc: Support for high speed SD cards
+  * mmc: Add support for SDHC cards
+  * mmc: Graceful fallback for fancy features
+  * mmc: MMC sector based cards
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 27 Mar 2007 15:15:01 +0300
+
+kernel-source-rx-34 (2.6.18-osso41) unstable; urgency=low
+
+  * week200712-1 release
+  * Correct partition failed erase address
+  * Use yield() between GC passes in background thread.
+  * JFFS2: fix deadlock on error path
+  * Support piping into commands in /proc/sys/kernel/core_pattern
+  * Pass process information to userspace coredump helper
+  * Kernel OOM-killer and allocation denial use different rules
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 20 Mar 2007 17:50:42 +0200
+
+kernel-source-rx-34 (2.6.18-osso40) unstable; urgency=low
+
+  * blizzard: fix lame full screen update bug 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed,  7 Mar 2007 14:56:12 +0200
+
+kernel-source-rx-34 (2.6.18-osso39) unstable; urgency=low
+
+  * week200710-1 release
+  * OMAP2: Enable limp state (no sys_clkreq) even when osc_ck is enabled
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed,  7 Mar 2007 12:09:34 +0200
+
+kernel-source-rx-34 (2.6.18-osso38.2) unstable; urgency=low
+
+  * Fixed config for the last change 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri,  2 Mar 2007 15:47:47 +0200
+
+kernel-source-rx-34 (2.6.18-osso38.1) unstable; urgency=low
+
+  * Production release with a fixed UART
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri,  2 Mar 2007 14:39:14 +0200
+
+kernel-source-rx-34 (2.6.18-osso38) unstable; urgency=low
+
+  * week200709-1 release
+  * Tahvo: Only mask MeasReady interrupt when suspending
+  * TSC2301 Mixer: Lazy fix to GPIO restore
+  * Use official machine id for N800
+  * blizzard: more robust suspend / resume
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 27 Feb 2007 16:29:44 +0200
+
+kernel-source-rx-34 (2.6.18-osso37) unstable; urgency=low
+
+  * week200707-1 release
+  * N800: Remove needless codec PLL startup delay from
+    board-n800-audio.c
+  * TSC2301 keypad: workaround the keypad scanner stuck HW bug
+  * [JFFS2] Reschedule in loops
+  * OneNAND: leave watchdog alone
+  * TSC2301 Mixer: Update notes text
+  * TSC2301 Mixer: Update power control rules
+  * TSC2301 Mixer: Slightly updated power control rules
+  * DSP: Fixed Spinlocks in DSP mailbox
+  * N800: Separate EAC and sys_clkout2 pin multiplexing in
+    board-n800-audio.c
+  * ARM: VM: fix user page protection macros
+  * TSC2301 Mixer: Implement delayed power-down
+  * ARM: OMAP2: Camera: More robust reset sequence.
+  * ARM: OMAP2: Camera: Add frame_check to sensor interface
+  * ARM: OMAP2: Camera: Call sensor frame_check
+  * ARM: OMAP2: Camera: Make omap24xxcam_reset_work more public
+  * ARM: OMAP2: Camera: Add sensor jamming detection code.
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 13 Feb 2007 15:35:00 +0200
+
+kernel-source-rx-34 (2.6.18-osso36) unstable; urgency=low
+
+  * week200705-2 release
+  * ARM: OMAP2: Camera: Fix videobuf_buffer memory leak.
+  * TUSB: Save and restore TUSB_PRCM_CONF reg during loopback test
+  * PM: Force UART clocks off during software suspend
+  * n800_defconfig: Link Bauhaus in-kernel again
+  * Tahvo: Mask all IRQs when suspending the chip
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri,  2 Feb 2007 16:20:27 +0200
+
+kernel-source-rx-34 (2.6.18-osso35) unstable; urgency=low
+
+  * week200705-1 release
+  * ARM: OMAP: Remove <linux/config.h> include statement from N800 board file
+  * ARM: OMAP2: Camera: Clear mmapped pages.
+  * ARM: OMAP2: Camera: Don't include linux/config.h.
+  * ARM: OMAP: EAC: Fix bug in eac_enable_clocks function
+  * [PATCH] MUSB HDRC: RMMOD Fail-fixing
+  * PM: Adds EXPORT_SYMBOL for omap2_allow_sleep and omap2_block_sleep
+  * n800_defconfig: compile musb_hdrc as module
+  * DSP: Added locks for request_queue protection
+  * DSP: Added locks for preemption
+  * DSP: Moved lock points along with the previous change
+  * Bluetooth: Shutdown the BT chip after probing.
+  * DSP: Get rid of DSP for production release
+  * Fix typo in drivers/bluetooth/hci_h4p/core.c
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 31 Jan 2007 14:37:30 +0200
+
+kernel-source-rx-34 (2.6.18-osso34) unstable; urgency=low
+
+  * Removed forbidden words from changelog
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue,  9 Jan 2007 16:27:53 +0200
+
+kernel-source-rx-34 (2.6.18-osso33) unstable; urgency=low
+
+  * week200702-1 release
+  * blizzard: Partial updates for YUV422 planes
+  * TSC2301 Mixer: Clarify a comment about PLL shutdown when input clock is off
+  * DSP: Added reset operation for omap mmu framework
+  * DSP: Added IPI initialization for ioctl(MMUINIT)
+  * DSP: Modified to monitor longer response time for dsp message
+  * DSP: Fixed potential sleep under spinlock
+  * DSP: Fixed potential soft lockup in mailbox
+  * ARM: OMAP: N800: Increase third fb plane size
+  * ARM: OMAP2: Camera: Make DMA source burst size 32
+  * OneNAND: report about single-bit errors
+  * OneNAND: bugfix: return error codes
+  * OneNAND: Always print error messages
+  * OneNAND: Correctly catch ECC and other onenand_wait errors
+  * OneNAND: Make read-word function calls consistent
+  * OneNAND: Check gpio errors and timeouts in onenand_wait
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue,  9 Jan 2007 16:17:33 +0200
+
+kernel-source-rx-34 (2.6.18-osso31) unstable; urgency=low
+
+  * week200701-1 release
+  * OneNAND: Disable DMA read for now
+  * ARM: OMAP: I2C: fix tansaction timeout checking
+  * TSC2301: shut down PLL when external clock is off
+  * n800: EAC: fix calling order in clock disable
+  * ARM: OMAP: FB: support for per window HW acceleration
+  * blizzard: add support for various accelearion options
+  * ARM: OMAP2: FB: fix frequency lookup in tearing sync setup
+  * ARM: OMAP: FB: fix locking for mode changes
+  * ARM: OMAP: FB: support for dynamic SRAM allocations
+  * ARM: OMAP: FB: support for dynamic memory reconfiguration
+  * n800: FB: move video plane to SRAM
+  * ARM: OMAP: FB: add new capability infos
+  * n800: blizzard: add new capability infos
+  * ARM: OMAP: FB: Fix cropping for output window
+  * ARM: OMAP: FB: fix OMAPFB_IOCTL return type
+  * TSC2301 Mixer: cleanup include statements
+  * PM: Enable MPU retention
+  * ARM: OMAP: FB: fix update_first_pixel to use the new update_window IOCTL
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed,  3 Jan 2007 16:13:24 +0200
+
+kernel-source-rx-34 (2.6.18-osso30) unstable; urgency=low
+
+  * week200651-3 release
+  * [JFFS2] add cond_resched() when garbage collecting deletion dirent
+  * OneNAND: workaround for boot ROM chip detection bug
+  * Wait until last fw byte is sent in fw uploading
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu, 21 Dec 2006 13:47:43 +0200
+
+kernel-source-rx-34 (2.6.18-osso29) unstable; urgency=low
+
+  * week200651-2 release
+  * BT fixed 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 19 Dec 2006 18:08:54 +0200
+
+kernel-source-rx-34 (2.6.18-osso28) unstable; urgency=low
+
+  * week200651-1 release
+  * Bauhaus: Block sleep when USB cable is connected
+  * Bluetooth: Fix spinlocks and clocks in PM functions. Fixes: NB#49841
+ 
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 19 Dec 2006 11:43:07 +0200
+
+kernel-source-rx-34 (2.6.18-osso27) unstable; urgency=low
+
+  * week200650-1 release
+  * Bluetooth: Block sleep when transfer in progress
+  * MMC: Specify number of blocks in advance for multi-block ops
+  * PM: Take sleep_block into account when deciding about MPU retention
+  * PM: Disable MPU retention for now
+  * DSP: Fixed previous commit for dsp_task_mmap_open/close
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Mon, 11 Dec 2006 18:06:34 +0200
+
+kernel-source-rx-34 (2.6.18-osso26) unstable; urgency=low
+
+  * week200649-1 release
+  * ARM: OMAP: Add prototypes for omap2_{allow,block}_sleep
+  * TCM825x: Update XCLK calculation rules to return 24.57 MHz instead of 24 MHz
+  * ARM: OMAP: Change write burst size in OMAP2 Camera DMA
+  * DSP: Used to unified devstate lock interface
+  * DSP: Added notification to userland when failed to delete dsp task
+  * DSP: Added missed MEM_IOCTL_MMUINIT in dsp_mem ioctl
+  * DSP: Added POLLERR when devstate is not suitable
+  * DSP: Removed BUG() for restarting dsp system again
+  * DSP: Set timeout for waiting devstate transition in open
+  * PM: Prevent MPU retention in special conditions
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue,  5 Dec 2006 14:51:14 +0200
+
+kernel-source-rx-34 (2.6.18-osso25) unstable; urgency=low
+
+  * week200648-1 release
+  * PM: Reprogram dyntick when entering MPU retention
+  * OneNAND: Block sleep when reading from bufferram to maximize speed
+  * TCM825x: Register initialization table cleanup
+  * TCM825X: Update XCLK calculation rules
+  * TCM825x: Change register initialization order
+  * TCM825x: Code readability update
+ 
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 29 Nov 2006 17:27:09 +0200
+
+kernel-source-rx-34 (2.6.18-osso24) unstable; urgency=low
+
+  * week200647-5 release
+  * MMC: OMAP: Guard against NULL dereference
+  * PM: Make MPU always try to enter retention
+  * OMAP: MMC: Enable multi-block write for MMC 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 24 Nov 2006 19:53:51 +0200
+
+kernel-source-rx-34 (2.6.18-osso23) unstable; urgency=low
+
+  * week200647-4 release
+  * Revert "Revert "Revert "PM: Make MPU always try to enter retention"""
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 24 Nov 2006 11:37:49 +0200
+
+kernel-source-rx-34 (2.6.18-osso22) unstable; urgency=low
+
+  * week200647-3 release
+  * PM: Make MPU always try to enter retention
+  * Bluetooth: Send GET_REPORT and SET_REPORT aftern connecting 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 24 Nov 2006 10:17:35 +0200
+
+kernel-source-rx-34 (2.6.18-osso21) unstable; urgency=low
+
+  * Revert "PM: Make MPU always try to enter retention" 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu, 23 Nov 2006 14:44:11 +0200
+
+kernel-source-rx-34 (2.6.18-osso20) unstable; urgency=low
+
+  * week200647-1 release
+  * USB: Rename NXXX to N800
+  * PM: Fix Menelaus VCORE scaling
+  * N800: Update board-n800-audio.c license
+  * ARM: OMAP: EAC: Update license
+  * TSC2301 Mixer: Update license and notes text
+  * PM: Remove clearing of PRCM_IRQSTATUS_MPU
+  * PM: Make MPU always try to enter retention
+  * ARM: OMAP: Pass right access permissions to remap_pfn_range in OMAP2 camera
+  * DSP: Enabled to notify mailbox illegal sequence bit to userland daemon
+  * DSP: Cleaned up dsptask locking
+  * DSP: Rename function name for readibility
+  * DSP: Macro function used to trace dsp taskdev state change
+  * DSP: Changed printk(KERN_INFO..), to pr_info()
+  * N800: Removed DEBUG definition
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu, 23 Nov 2006 12:50:11 +0200
+
+kernel-source-rx-34 (2.6.18-osso19) unstable; urgency=low
+
+  * week200646-1 release
+  * PM: Multiplex EAC pins to protected mode when EAC is not used
+  * Remove leftover debug code from board-n800.c
+  * omap-rng: Clock rng_ick dynamically
+  * PM: Set Blizzard POWERDOWN line when powering down
+  * DSP: Fixed irq state inconsistency
+  * DSP: Fixed the wrong return value when timeout occured
+  * TSC2301 keypad: filter out ghost keys
+  * PM: Merge a couple of forgotten changes
+  * ARM: OMAP: Manage itself buffers to be mmap'ed in OMAP2 camera
+  * PM: Disable VCORE scaling for now
+  * Bluetooth: Send MTU in positive L2CAP config response
+  * Bluetooth: Don't respond to L2CAP config request if disconnecting
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu, 16 Nov 2006 11:21:22 +0200
+
+kernel-source-rx-34 (2.6.18-osso18) unstable; urgency=low
+
+  * Updated defconfig name 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu,  9 Nov 2006 15:54:28 +0200
+
+kernel-source-rx-34 (2.6.18-osso17) unstable; urgency=low
+
+  * Updated orig.tar.gz 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu,  9 Nov 2006 15:38:23 +0200
+
+kernel-source-rx-34 (2.6.18-osso16) unstable; urgency=low
+
+  * week200645-2 release
+  * Rename RX-34 to N800
+  * Allowing user processes to rise their oom_adj value
+  * Reduce dirty ratio granularity to 0.1%
+  * Bluetooth L2CAP: Send right response to unknown option request
+  * Bluetooth: Update H4+ driver license
+  * Menelaus: Support for setting regulator sleep and VCORE
+  * N800: Add a separate file for board-specific PM code
+  * PM: Increase voltage setup delay
+  * PM: Enable DC2 sleep and increase floor voltage for more stability
+  * DSP: Update mailbox driver license
+  * DSP: Update N800 DSP driver license
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu,  9 Nov 2006 14:15:06 +0200
+
+kernel-source-rx-34 (2.6.18-osso15) unstable; urgency=low
+
+  * week200645-1 release
+  * Change x86 keymapping for KEY_PHONE
+  * And now the proper keymapping for KEY_PHONE
+  * PM: Removed unnecessary DSP kill code
+  * Menelaus: Add support for setting platform data
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu,  9 Nov 2006 10:26:38 +0200
+
+kernel-source-rx-34 (2.6.18-osso14) unstable; urgency=low
+
+  * Wrong kernel build because of non-fetched tag 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu,  9 Nov 2006 10:23:51 +0200
+
+kernel-source-rx-34 (2.6.18-osso13) unstable; urgency=low
+
+  * week200644-1 release
+  * Add hid patches from -mh patch set
+  * bluetooth-hid: keycode range workaround for SU-8W
+  * Revert "Bauhaus: Disable TUSB idle if cable is connected"
+  * Revert "musb_hdrc: Workaround for incomplete SETUP packet with USB HSHET
+  * musb_hdrc: Sync relevant code with public linux-omap tree
+  * musb_hdrc: TUSB EVM support
+  * musb_hdrc: Start using common TUSB GPMC init and dynamic GPMC timings
+  * musb_hdrc: Fix TEST_PACKET again
+  * musb_hdrc: Clear txcsr and enable tusb doublebuffering
+  * musb_hdrc: Fix USB SUSPEND on VBUS
+  * musb_hdrc: Fix TUSB sync DMA burst access
+  * musb_hdrc: Backport include/linux/usb/otg.h from mainline
+  * musb_hdrc: Fix warning on pt_regs
+  * Compile ext2 and ext3 as modules
+  * Reserve pool for selected users
+  * MMC: Allow value 3 in CSD struct version
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed,  1 Nov 2006 18:17:14 +0200
+
+kernel-source-rx-34 (2.6.18-osso12) unstable; urgency=low
+
+  * week200643-1 release
+  * DSPGW: Add mutex_unlock for usecount in error return path
+  * DSPGW: Use remap_pfn_range not remap_page_range in message
+  * DSPGW: Removed unused memeber in struct taskdev
+  * DSPGW: Fixed incorrect return value and return checking
+  * DSPGW: Change return code of devstate_read_lock_and_test()
+  * DSPGW: Fix error return path in omap_dsp_init()
+  * MMC: Exclude bad cards from clock calculation
+  * DSPGW: Error checking for proc_list_add()
+  * Moved "ioctl.h" to "include/asm/arch/dsp.h" for  userland
+    application to make use of this file.
+  * ARM: OMAP: omap-pwm-led: Start blinking with on period
+  * DSPGW: Kernel APIs to sync with dsp  during DVFS
+  * DSPGW: Added sysfs file to sync with dsp during DVFS
+  * DSPGW: Added a function to get dsp status
+  * DSPGW: Check return values of __must_check functions
+  * DSPGW: Return value checks for dsp_ctl.c
+  * MBOX: Error return path checks for omap_mbox_init()
+  * ARM: OMAP: omap-pwm-led: Keep power enabled when driver is loaded
+  * LED: Allow tuning of timer trigger brightness
+  * Enable LED triggers in default config
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 25 Oct 2006 16:03:57 +0300
+
+kernel-source-rx-34 (2.6.18-osso11) unstable; urgency=low
+
+  * week200642-1 release
+  * ARM: OMAP1: clock: add SoSSI clock
+  * ARM: OMAP: clock: call propagate_rate for childrens
+  * ARM: OMAP: FB: support for tearing synchronization
+  * ARM: OMAP1: PM: remove manual checking of SoSSI state from idle
+  * HWA742: add support for tearing synchronization
+  * Blizzard: add support for tearing synchronization
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 17 Oct 2006 17:27:23 +0300
+
+kernel-source-rx-34 (2.6.18-osso10) unstable; urgency=low
+
+  * fixed  defconfig name 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 13 Oct 2006 22:00:04 +0300
+
+kernel-source-rx-34 (2.6.18-osso9) unstable; urgency=low
+
+  * use our sources as orig.tar.gz 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 13 Oct 2006 21:48:36 +0300
+
+kernel-source-rx-34 (2.6.18-osso8) unstable; urgency=low
+
+  * use .orig.tar.gz from ftp.kernel.org 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 13 Oct 2006 15:07:47 +0300
+
+kernel-source-rx-34 (2.6.18-osso7) unstable; urgency=low
+
+  * week200641-2 release
+  * Remove ROMFS from defconfig
+  * OneNAND: Enable DMA with both reads and writes
+  * MMC: Do not set unsupported bits in OCR response
+  * MMC: When rescanning cards check existing cards after mmc_setup()
+  * DSPGW: Cleaned up dspgw header files to avoid redefine warnings and whitespace alignements
+  * Remove references to forbidden words
+  * retu-headset: add support for headset button detection
+  * TSC2301 Mixer: Power down mic bias output along with the ADC power down
+  * ARM: OMAP: Keep CAM.XCLK low when powering down sensor in OMAP2 camera
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 13 Oct 2006 14:22:38 +0300
+
+kernel-source-rx-34 (2.6.18-osso6) unstable; urgency=low
+
+  * renamed defconfig in orig.tar.gz 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 11 Oct 2006 19:05:19 +0300
+
+kernel-source-rx-34 (2.6.18-osso5) unstable; urgency=low
+
+  * some fdwords cleanups
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 11 Oct 2006 18:17:52 +0300
+
+kernel-source-rx-34 (2.6.18-osso4) unstable; urgency=low
+
+  * week200641-1 release
+  * ARM: OMAP: Make oprofile work for ARM11
+  * Blizzard: Fix newline bug
+  * Bauhaus: Disable TUSB idle if cable is connected
+  * ARM: OMAP: Make OMAP1 work again
+  * ARM: OMAP: Re:  Fix warning in clock.c
+  * ARM: OMAP: Implement workaround for GPIO wakeup bug in OMAP2420 silicon
+  * Sanitize camera power-up and -down code
+  * MMC: Fix "command gets stuck" problem
+  * TSC2301: audio: move clock handling to correct place
+  * TSC2301: call suspend / resume also for the touchscreen and keypad
+  * TSC2301: keypad: workaround for key scan HW bugs
+  * ARM: OMAP: I2C: Do not use interruptible wait call in omap_i2c_xfer_msg
+  * MMC: Select only one voltage bit in OCR response
+  * Add multi block-write capability
+  * OMAP: MMC: Fix oops when we get a command/data CRC error
+  * mmc: multi sector write transfers
+  * DSPGW: Removed EAC workaround patch for dsp s/w (rx-34-specific)
+  * DSPGW: Cleaned up namespace and indentation for dspgw and mailbox
+  * DSPGW: MBOX: Added kfunc power message print on mailbox log
+  * DSPGW: MBOX: Created mailbox workqueue for performance and robustness
+  * ARM: OMAP: Common MMU management framework
+  * ARM: OMAP: Common MMU management framework (omap1 specific parts)
+  * ARM: OMAP: Common MMU management framework (omap2 specific parts)
+  * DSPGW: mapped EAC and STI for dsp (rx-34-specific)
+  * DSPGW: MBOX: Deferred mailbox initialization
+  * DSPGW: MBOX: introduced request_queue for mailbox message handling
+  * Disable all I/O schedulers except the NOOP scheduler
+  * ARM: OMAP: DISPC: ignore FIFO underflow
+  * DSPGW: fix wrong kconfig dependency
+  * TSC2301: keypad: mask keys when disabled
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 11 Oct 2006 17:12:10 +0300
+
+kernel-source-rx-34 (2.6.18-osso3) unstable; urgency=low
+
+  * week200640-1
+  * CBUS: Tahvo: add atomic set and clear register bits function
+  * BUS: Retu: Combine set / clear register bits into one function
+  * CBUS: retu-headset: update set / clear register function
+  * blizzard: move PM code to board specific file
+  * Camera: Setting DOUT_BUF to 8mA
+  * Camera: Fixing bit offsets for the boolean video controls
+  * musb_hdrc: Workaround for incomplete SETUP packet with USB HSHET
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed,  4 Oct 2006 17:02:13 +0300
+
+kernel-source-rx-34 (2.6.18-osso2) unstable; urgency=low
+
+  * week200639-3 release
+  * OneNAND: Always use CPU to read the buffer RAM
+  * ARM: OMAP: Camera sensor power management added into OMAP2 camera
+  * Add iptables support to default config
+  * omapfb: Enable DISPC and DSS autoidling
+  * ARM: OMAP: Enable 24xx GPIO autoidling
+  * TSC2301: Add suspend, resume and wakeup functionality
+  * CBUS: Enable suspend wakeup for Retu IRQ
+  * ARM: OMAP: Add function to print clock usecounts
+  * ARM: OMAP2: Enable serial idling and wakeup features
+  * ARM: OMAP2: Optimize INTC register accesses and enable autoidling
+  * ARM: OMAP: Replace clock framework debug functions
+  * New PM code
+  * ARM: OMAP: Avoid updating system time for sub-jiffy interrupts
+  * ARM: OMAP: Optimize idle for dyntick
+  * ARM: OMAP: FB: add controller platform data
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 29 Sep 2006 18:07:55 +0300
+
+kernel-source-rx-34 (2.6.18-osso1) unstable; urgency=low
+
+  * week200639-1 release
+  * new upstream release
+  * ARM: OMAP2: Add support for forcing osc_ck on
+  * ARM: OMAP: DSPGW: Remove workaround for dsp s/w pm
+  * Audio: Do not enable the codec by default 
+  * RM: OMAP: Clock use change for OMAP2 camera
+  * Revert "Audio: Do not enable the codec by default 
+  * genirq: fix typo in resend
+  * ARM: OMAP2: fb: clock refcounting for dynamic sleep mode
+  * ARM: OMAP: OMAP2 dmtimer power management support
+  * Updated PM patch from Amit
+  * Typo fix for previous commit
+  * fb: blizzard: enable dynamic sleep
+  * MUSB: More TUSB OTG support
+  * MUSB: TUSB peripheral connection bugfix
+  * Bluetooth: Dynamic clock usage H4+ driver
+  * blizzard: fix rev1 suspend
+  * ARM: OMAP2: PM: remove oscillator clock reference when going idle
+  * camera: don't disable DSS1 interface clock at suspend
+  * ARM: OMAP: Avoid sleeping function being called
+  * MUSB: Enable/disable osc_ck for TUSB
+  * Fix wrong file path mmc
+  * ARM: OMAP: DSPGW: Use device model
+  * ARM: OMAP: DSPGW: Fix deadlock
+  * ARM: OMAP: Disable keypad repeating 
+  * OneNAND: Enable wait pin monitoring
+  * ARM: OMAP2: PM: don't put APLLs into auto idle mode
+  * Blizzard: check line buffer status before starting transfer
+  * TEA5761: Fix mute control query
+  * ARM: OMAP: DSPGW: Peripheral (kfunc) control
+  * ARM: OMAP: DSPGW: Peripheral (kfunc) control, 
+  * ARM: OMAP: DSPGW: make mbox a member of struct omap_dsp
+  * DSPGW: Fix compilation error
+  * Bauhaus: Add check for osc_ck handling
+  * DSPGW: Allow DSP GW to be removed from Kconfig
+  * ARM: OMAP: DSPGW: DSPGW driver 3.3.1 public release (merge)
+  * Menelaus: Fix voltage values for VMEM
+  * Camera: Fix sensor power-on sequence
+  * ARM: OMAP: DSPGW: fix bug in kfunc device list operation
+  * Camera: Turn off sensor power if the sensor was not detected
+  * ARM: OMAP: Add support for forcing osc_ck on
+  * ARM: OMAP2: Make sure peripherals can be accessed after clk_enable
+  * ARM: OMAP2: Keep both APLLs active during bootup
+  * ARM: OMAP: Add sanity check to clk_disable
+  * ARM: OMAP2: Make McSPI clocking more fine-grained
+  * Disable cam_turn GPIO IRQ when camera is not popped out
+  * PM: Don't kill STI clocks
+  * ARM: OMAP: DSPGW: mailbox build fix
+  * ARM: OMAP: DSPGW: fix build warning
+  * ARM: OMAP: DSPGW: Deferred dsp initializtion
+  * ARM: OMAP: MAILBOX: add member "ick" in struct omap_mbox
+  * ARM: OMAP: DSPGW: another workaround for eac access from dsp s/w
+  * ARM: OMAP: DSPGW: remove kfunc to handle mailbox
+  * Revert "ARM: OMAP: MAILBOX: add member "ick" in struct omap_mbox"
+  * DSPGW: Fix compilation error in previous commit
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 27 Sep 2006 15:54:30 +0300
+
+kernel-source-rx-34 (2.6.17-osso9) unstable; urgency=low
+
+  * week200637-1 release
+  * changed package name to kernel-source-rx-34
+  * MUSB: PM cleanup
+  * MUSB: Enable the TUSB irq signal as a wake event source
+  * MUSB: Add back irq_work for cable events
+  * ARM: OMAP: Fix spinlock recursion for dyntick
+  * ARM: OMAP: Fix omap_set_dma_callback spinlock release
+  * MUSB: Additional checks for TUSB DMA
+  * MUSB: Add more TUSB endpoints
+  * lcd_mipid: add SPI Kconfig dependency
+  * ARM: OMAP: DSPGW: bugfix: added missing return
+  * MUSB: PM cleanup
+  * ARM: OMAP: GPIO: IRQSTATUS2 workaround for retention state
+  * ARM: OMAP: DSP: Fix shared memory synchronization
+  * ARM: OMAP: EAC: Clock use change
+  * ARM: OMAP: DSPGW: Remove compilation warnings
+  * ARM: OMAP: Fix typo for 24xx GPIO resume
+  * Set correct mass storage bMaxPower value
+  * ARM: OMAP: DSPGW: fix build error
+  * Implement multi-block MMC writes to improve write performance
+  * MUSB: Miscellaneous updates
+  * Revert "Fix double deleting rfcomm device"
+  * Bluetooth: Check if rfcomm device is already deleted
+  * MUSB: Update TUSB looptest
+  * MMC: Remove support WP switch
+  * OMAP: MMC: Fix typo in mmc_omap_resume()
+  * MUSB: Fix TUSB DMA for short tx packets
+  * Revert "Implement multi-block MMC writes to improve write performance"
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 13 Sep 2006 17:47:42 +0300
+
+kernel-source-rx-34-2.6.17 (2.6.17-osso8) unstable; urgency=low
+
+  * ARM: OMAP: DSPGW: bugfix: added missing return
+  * Merge ../linux-omap 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri,  8 Sep 2006 16:15:21 +0300
+
+kernel-source-rx-34-2.6.17 (2.6.17-osso7) unstable; urgency=low
+
+  * week200636-1
+  * MUSB: Fix TUSB register access
+  * OMAP: Menelaus: Add support for controlling Vaux
+  * Add driver for TMP105 temperature sensor chip
+  * OMAP: Menelaus: Add prototype for menelaus_set_vaux()
+  * usb gadget: g_ether spinlock recursion fix
+  * MUSB: Fix TUSB DMA register access
+  * MUSB: Optimize g_ether with NET_IP_ALIGN to align buffers
+  * MUSB: tusb updates 1/2 -- host side test support
+  * MUSB: tusb patches 2/2 -- whitespace etc
+  * MUSB: tusb multipoint fixes
+  * MUSB: Make TUSB DMA debug less verbose
+  * tell the Mentor HDRC controller driver to avoid ZLPs.
+  * MUSB: Update defconfig for changed Kconfig names
+  * MUSB: Update register access based on new HDRC core spec
+  * Add missing tmp105.c file
+  * Enable TMP105  
+  * ARM: OMAP: cleanup init device
+  * OMAP: Menelaus: Add a stabilization delay of 1 ms after setting voltage
+  * ARM: OMAP: Add write memory barriers to OMAP2 clock code
+  * ARM: OMAP: cleanup init device
+  * ARM: OMAP: omap-pwm-led: Disable GPT when not used
+  * JFFS2: Use all fragments of  nand_ecclayout->oobfree
+  * OneNAND: Update OOB free table
+  * MUSB: Clean up TUSB DMA handling
+  * MUSB: TUSB PM cleanup
+  * MUSB: Clean up cable status sysfs_notify() events
+  * MUSB: MiniAB
+  * IDLETIMER: Update license text
+  * ARM: OMAP: Remove Remove superfluous/recursive locking for GPIO
+  * MUSB: Workarounds for TUSB PLL
+  * MUSB: Minor cleanups
+  * [PATCH] MUSB: Fix TUSB compilation if CONFIG_USB_TUSB6010_TEST is not set
+  * ARM: OMAP: F10 spec changed
+  
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu,  7 Sep 2006 17:44:36 +0300
+
+kernel-source-rx-34-2.6.17 (2.6.17-osso6) unstable; urgency=low
+
+  * week200635-2 release
+  * ARM: OMAP: DSPGW: re-add workaround for dsp s/w pm""
+  * Remove kernel debugging options from defconfig
+  * ARM: OMAP: DMA source and destination addresses are unsigned
+  * MUSB: Update to MUSB snapshot 0825
+  * MUSB: Fix USB high-speed electrical test TEST_PACKET mode
+  * usb gadget: g_ether spinlock recursion fix
+  * MUSB: Clean up TUSB ep0 register configuration
+  * MUSB: Clean up TUSB looptest
+  * MUSB: Disable TUSB looptest debug mode
+  * Fix double deleting rfcomm device
+  * ARM: OMAP: Camera scrolling bug fix
+  * MUSB: Change TUSB DMA log level to be less verbose
+  * retu-headset: Brown paperbag fix
+  * MMC: Add sysfs attributes for the WP switch
+  * ARM: OMAP: Add GPIO irq startup and shutdown functions
+  * ARM: OMAP: Remove IVA IRQ bank
+  * RTC: Add rtc-omap
+  * ARM: OMAP: DISPC scale down in one direction
+  * ARM: OMAP: DSPGW: bugfix for dynamic dsptask deletion
+  * ARM: OMAP: Reset timer for OMAP2 camera
+  *  Revert "ARM: OMAP: Add GPIO irq startup and shutdown functions"
+  * Revert "ARM: OMAP: DSPGW: workaround for dsp s/w pm"
+  * TSC2301 Mixer: Audio output activation delay added
+  * ARM: OMAP: Reset GPIO irq state after free_irq()
+  * Revert "ARM: OMAP: Add GPIO irq startup and shutdown functions"
+  * GPIO: Re-add top-secret PM voodoo that got lost in previous merge
+  * BT: Disable driver if no valid address supplied
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu, 31 Aug 2006 15:02:29 +0300
+
+kernel-source-rx-34-2.6.17 (2.6.17-osso5) unstable; urgency=low
+
+  * week200634-1 release
+  * ARM: OMAP: Fix OMAP2 clock.c typo
+  * ARM: OMAP: Fix GPMC_CS_CONFIG1 writing and typos
+  * Revert "FIXME: Keep 48M clock enabled until drivers are fixed"
+  * ARM: OMAP: Use GPT iclk only when needed
+  * TSC2301 keypad: add disable sysfs entry
+  * OMAP: MMC: Fix timeout calculation
+  * MMC: Fix typo
+  * BT: Fix driver for new skb_pad API
+  * TSC2301 Mixer: Power control for additional GPIO mixer controls
+  * audio: Enable audio amplifier's power-down
+  * ARM: OMAP: Camera compilation fixes for OMAP2
+  * ARM: OMAP: Use 32kHz clock source in omap-pwm-led
+  * TEA5761: update after mainline merge
+  * ARM: OMAP: Sensor query_control should return -EINVAL when ID is wrong
+  * ARM: OMAP: ov9640 fixes
+  * ARM: OMAP: DSPGW: workaround for dsp s/w pm
+  * Update defconfig
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 23 Aug 2006 15:59:33 +0300
+
+kernel-source-rx-34-2.6.17 (2.6.17-osso4) unstable; urgency=low
+
+  * week200633-1 release
+  * CBUS: Add functions for setting/clearing Retu register bits
+  * Add first version of Retu/Vilma headset detection driver
+  * Add support for Vilma headset detection
+  * ARM: OMAP: Camera: DMA setting prevents OMAP sleep
+  * blizzard: put the device to power save mode during suspend
+  * ARM: OMAP: EAC: Use resources to pass the base address
+  * Do not tie headphone indicator to headset detection 
+  * CBUS: Add enable attribute for headset detection
+  * CBUS: Move the retu-headset device registration to board-specific code
+  * Add Retu headset device initialization to audio
+  * TSC2301 Mixer: Fix to PLL configuration
+  * audio: Add author and activate power down code
+  * Enable CONFIG_CBUS_RETU_HEADSET and CONFIG_OMAP_RESET_CLOCKS
+  * ARM: OMAP: DSPGW: fix power management functions
+  * CBUS: remove unused function from retu-headset
+  * MUSB: Fix problem with rmmod g_file_storage after unplug
+  * Introduce OMAP_PM_DEBUG for all debugging code in PM
+  * Allows Clock FW Refcounting to debug drivers in PM code
+  * ARM: OMAP: EAC: Locking change and fixes to clock use and
+    powering sequence
+  * ARM: OMAP: DSP: dsp powerdomain should be handled in dsp code
+  * ARM: OMAP: DSP: Fix typo
+  * Enable suspend-resume on OMAP2, fix GPIO wakeup
+  * ARM: OMAP: Use McSPI clocks only when needed
+  * ARM: OMAP: TSC2301 Mixer: Locking added, improved power-up/-down
+    polling and cleanup
+  * FIXME: Keep 48M clock enabled until drivers are fixed
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu, 17 Aug 2006 15:58:56 +0300
+
+kernel-source-rx-34-2.6.17 (2.6.17-osso3) unstable; urgency=low
+
+  * week200632-1 release
+  * ARM: OMAP: Remove sys_ck and sys_clkout from McBSP for 24xx
+  * ARM: OMAP: Fix missing channel parameter in omapfb_main.c
+  * [PATCH] ARM: OMAP: 2420 boot BUG(): failure to map SRAM
+  * ARM: OMAP: Sleep is prevented when no LCD is attached
+  * CBUS: turn off tahvo-usb OTG idle mode during enabling
+  * Fix typo in MMC driver
+  * ARM: OMAP: Check STI channel value before registering console driver
+  * MMC: Do not poll when cover is open and no cards are inserted
+  * ARM: OMAP: Update gpio-switch framework
+  * Implement support  internal MMC slot cover
+  * TCM825x: power on/off callback fix
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue,  8 Aug 2006 17:35:57 +0300
+
+kernel-source-rx-34-2.6.17 (2.6.17-osso2) unstable; urgency=low
+
+  * week200631-1 release
+  * ARM: OMAP: omapfb: lcd_mipid ESD is blocking keventd
+  * OMAP: MMC: Add support for limiting the maximum bus frequency
+  * ARM: OMAP: Remove non-static declaration of clocks
+  * If MMC is not enabled in Kconfig, do nothing in mmc
+  * OMAP: MMC: Fix suspend and resume
+  * Enable Retu RTC 
+  * Add the lowmem module
+  * Enable lowmem module 
+  * TEA5761: add support for the chip with V4L2 API
+  * Enable FM radio in defconfig
+  * TEA5761: missing init of the video_dev->dev field
+  * Always use a block size of 512 regardless of MMC/SD capacity
+  * ARM: OMAP: Camera: get / use DISPC clocks properly
+  * ARM: OMAP: omapfb: fix error path
+  * Backport patch-sysrq-deadlock until kernel is updated
+  * ARM: OMAP: Avoid sleeping during arch_reset
+  * ARM: OMAP: Fix CONFIG_OMAP_RESET_CLOCKS
+  * ARM: OMAP: make McBSP support a Kconfig option
+  * ARM: OMAP: Make GPIO switch framework sysfs usage more sensible
+  * Remove unneeded #warning from audio
+  * Enable CONFIG_PM in defconfig
+  * Update defconfig, disable CONFIG_OMAP_MCBSP
+  * ARM: OMAP remove McBSP from statically built objects
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu,  3 Aug 2006 18:26:24 +0300
+
+kernel-source-rx-34-2.6.17 (2.6.17-osso1) unstable; urgency=low
+
+  * week200630-1 release
+  * First merged release
+  * Changed maintaner name
+  * changed package name
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Mon, 31 Jul 2006 11:53:32 +0300
+
+kernel-source-rx-34-2.6.16 (2.6.16-rc2-osso23) unstable; urgency=low
+
+  * week200626-1 release
+  * ARM: OMAP: DSPGW: MAILBOX: cleanup: unused files
+  * ARM: OMAP: Generic Mailbox API
+  * ARM: OMAP: DSPGW: autoidle mailbox
+  * ARM: OMAP: DSPGW: set autoidle for dsp and mailbox
+  * ARM: OMAP: DSPGW: power management idle framework
+  * ARM: OMAP: DSPGW pm idle specific parts
+  * ARM: OMAP: DSPGW: DVFS blocking
+  * use the platform resource field for allocating McSPI IO range.
+  * DMA support for McSPI
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 28 Jun 2006 17:03:58 +0300
+
+kernel-source-rx-34-2.6.16 (2.6.16-rc2-osso22) unstable; urgency=low
+
+  * week200625-1 release
+  * ARM: OMAP: Fix DMA channel irq handling for omap24xx
+  * Avoid infinite interrupt loops with zero size packets
+  * TSC2301 Mixer: Fix compile error
+  * omapfb: missing return value in omapfb_update_full_screen
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 20 Jun 2006 18:37:24 +0300
+
+kernel-source-rx-34-2.6.16 (2.6.16-rc2-osso21) unstable; urgency=low
+
+  * week200624-1 release
+  * ARM: OMAP: omap2_mcspi: prevent debug message flood
+  * dspfs: New simplistic virtual file system for dsp resource management.
+  * ARM: OMAP: Simple IVA1 co-processor access through dspfs.
+  * [PATCH] ARM: OMAP: OMAP2 DMA burst support
+  * ARM: OMAP: Additional 24xx DMA fixes and functions
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 14 Jun 2006 16:23:14 +0300
+
+kernel-source-rx-34-2.6.16 (2.6.16-rc2-osso20) unstable; urgency=low
+
+  * week200623-1 release 
+  * TSC2301 Mixer: Some cleanups and fixes to initialization & exit sequence
+  * ARM: OMAP: Fixup EAC initializers for gcc 4.1.
+  * SPI: Kill duplicate TSC2301_MCLK_256xFS definition.
+  * TSC2301 Mixer: Interface changes
+  * ARM: OMAP: EAC: Added ALSA sound card instance
+  * ARM: OMAP: TSC2301 callbacks added into EAC platform_data 
+  * Disable CONFIG_SPI_TSC2301_AUDIO_SELF_REGISTRATION.
+  * Add bauhaus PM support
+  * lcd_lph8923: set LCD data lines correctly
+  * TSC2301 Mixer: Changes to control "Mic Volume"
+  * lph8923: ESD check and recovery for Ural displays
+  * retu-led: Initialize blinking PWM (works now also with B3)
+  * disable CONFIG_SPI_DEBUG
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed,  7 Jun 2006 19:18:58 +0300
+
+kernel-source-rx-34-2.6.16 (2.6.16-rc2-osso19) unstable; urgency=low
+
+  * week200621-2 release
+  * Lame try to boot bt chip many times
+    Some cases bt chip is not started when initialized. In this case
+    try again, max 4 times.
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri, 26 May 2006 16:56:17 +0300
+
+kernel-source-rx-34-2.6.16 (2.6.16-rc2-osso18) unstable; urgency=low
+
+  * week200621-1 release
+  * SPI: add per transfer wordsize and speed parameter
+  * SPI: rename bitbang_transfer_setup
+  * ARM: OMAP: omap2_mcspi: use the per transfer wordsize and speedi overrides
+  * lcd_lph8923: use SPI per transfer parameters
+  * ARM: OMAP: EAC: Configuration structures added into EAC header file.
+  * ARM: OMAP: EAC device added
+  * ARM: OMAP: EAC: Driver made platform independent.
+  * ARM: OMAP: MMC: bugfix for cover switch event
+  * TSC2301 Mixer: Minimum register value defined for volume registers.
+  * ARM: OMAP: DSPGW: memmap for STI
+  * Merged bt driver  
+      - Use probe(). This is allready one selftest.
+      - Use 12byte negotiation message 
+      - disable uart while changin speed
+      - add gpl information and license
+      - enable power saving  
+      - enable clock framework usage 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu, 25 May 2006 12:34:14 +0300
+
+kernel-source-rx-34-2.6.16 (2.6.16-rc2-osso17) unstable; urgency=low
+
+  * week200620-1 release
+  * We also want to use aapcs-linux if the compiler supports it.
+  * USB: Add g_file_storage product ID for new hardware
+  * We don't want 8 bits enum optimisations. This should fix some issues with
+    userspace.
+  * USB: musb: add pollable sysfs events for TUSB6010 cable
+  * Enable 32KHz timer and dyntick
+  * Enable CBUS_RETU_LED
+  * retu-led: support for LEDs driven by retu
+  * ARM: OMAP: Build fixes for bogus .driver initialization.
+  * Merge with upstream
+  * ARM: OMAP: MMC: PM: fix mmc suspend problem
+  * ARM: OMAP: Sync gpio.c  (GPIO IRQ lazy IRQ disable fix)
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 17 May 2006 17:13:31 +0300
+
+kernel-source-rx-34-2.6.16 (2.6.16-rc2-osso16) unstable; urgency=low
+
+  * week200619-1 release
+  * tsc2301-kp: use x86 keycodes in raw mode
+    Post raw keyboard events using standard x86 keycodes, which enables the
+    simultaneous use of the keypad and an external (e.g. Bluetooth) keyboard
+    when using raw mode.
+  * keyboard: enable raw mode on ARM
+  * This patch adds beginnings of suspend support for 24xx.
+    Please note the following:
+    - Some drivers still oops while suspending, such as MMC
+    - To see suspend errors, you must comment out .suspend and .resume
+      in drivers/serial/8250.c as the serial port gets suspended before
+      other drivers.
+    - Wake-up events don't work if the MPU power domain goes into retention
+  * OMAP24xx EAC & TSC2301 Mixer: Default samplerate changed from 44.1 to 48
+    kHz.
+  * This patch enables 32KHz timer wake-up events as needed by
+    dyntick
+  * This patch fixes some dyntick locking issues on ARM
+  * Fix CONFIG_PRINTK_TIME hangs on systems where sched_clock() does
+    not work before timer is initialized.
+  * This patch is a backport to fix sys_nanosleep() with dyntick timer.
+    It broke with recent hrtimer updates.
+  * security: Add updated version of lowmem LSM module.
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 10 May 2006 17:51:53 +0300
+
+kernel-source-rx-34-2.6.16 (2.6.16-rc2-osso15) unstable; urgency=low
+
+  * week200618-2 release
+  * Found another way to solve this problem. thank god
+    Revert "adding __attribute__((packed)) to one structure on asound.h"
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Fri,  5 May 2006 17:28:09 +0300
+
+kernel-source-rx-34-2.6.16 (2.6.16-rc2-osso14) unstable; urgency=low
+
+  * week200618-1 release
+  * adding __attribute__((packed)) to one structure on asound.h
+    This should be solved on another way
+  * key repeat support to the TSC2301 keypad driver. Fixes: NB#24084.
+  * spi: Fix modular master driver remove and device suspend/remove
+  * Fix two problems in the spi subsystem:
+    1) spi subsystem core dumps when modular spi master is unloaded.
+    2) spi subsystem core dumps when spi slave device is suspended/resumed and
+       module slave driver is not loaded.
+  * OMAP24xx EAC: Space-to-tab cleanups to EAC header file. 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu,  4 May 2006 16:38:50 +0300
+
+kernel-source-rx-34-2.6.16 (2.6.16-rc2-osso13) unstable; urgency=low
+
+  * week200617-1
+  * Add missing definition
+  * ARM: OMAP: Add EAC I/O area mapping for DSP
+  * OMAP24xx EAC: one trivial bug corrected in eac_hw_init
+  * enable CONFIG_SND_OMAP24XX_EAC
+  * Revert DSP mailbox changes
+  * Add bt address writing and non working dma skeleton
+  * OMAP24xx EAC: low-level support functions
+    - These will contain basic initialization and clock management code.
+  * Header file for OMAP24xx Enhanced Audio Controller.
+  * DSPGW: mailbox: set clock autoidle
+  * DSPGW: memmap for STI
+  * DSPGW: memmap for EAC
+  * MMC: add slot number in card info which it resides. Fixes: NB#27006.
+  * dspgw: mailbox autoidle temporary disabled. it does not work.
+  * Revert "Ural panel detection based on revision"
+  * dspgw: idle power management
+    - Add dsp clock autoidle(auto-control mode: spec 5.10.8.2)
+            - DSP_FCLK
+            - DSP_ICLK
+            - INT_D_FCLK
+            - INT_D_ICLK
+     The above clocks are controled together by auto-control mode.
+    - Add mailbox clock autoidle
+  * Enable component version display
+  * dspgw: idle power management
+  * ARM: OMAP: Generic Mailbox API.
+  * omapfb: include asm/types.h in omapfb.h
+  * Detect all Ural versions as type B except revision 82
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu, 27 Apr 2006 21:25:32 +0300
+
+kernel-source-rx-34-2.6.16 (2.6.16-rc2-osso12) unstable; urgency=low
+
+  * ls041y3_b display detection change 
+
+ -- Yauheni Kaliuta <ykaliuta@ok.research.nokia.com>  Wed, 19 Apr 2006 19:55:45 +0300
+
+kernel-source-rx-34-2.6.16 (2.6.16-rc2-osso11) unstable; urgency=low
+
+  * week200616-1 release
+  * defconfig
+    - Compile USB_ETHERNET and USB_FILESTORAGE as a module
+      Also added USB_SERIAL as a module
+  * This patch fixes USB loopback test on Darium.
+  * Detect new version 
+  * omapfb: add get_color_key
+  * omapfb: include asm/ioctl.h in omapfb.h
+  * mmc: negotiable voltage
+    - dual voltage cards are supported. If both a higher voltage card
+      and a lower voltage card exists at once, higher voltage is
+      provided.
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 19 Apr 2006 17:00:21 +0300
+
+kernel-source-rx-34-2.6.16 (2.6.16-rc2-osso10) unstable; urgency=low
+
+  * week200615-1 release
+  * sysfs: attribute
+    - For userland applications to migrate new pollable sysfs interface,
+      this is provided. This allows both notifications from pollable sysfs
+      attributes and kobject_uevent. 
+  * kobject_uevent: attribute drivers
+  * kobject_uevent: attribute
+    - This is derived from s+ tree for backward compatibility
+      of sysfs attribute through kobject_uevent.
+  * sysfs: Allow sysfs attribute files to be pollable
+    - This is a backport from mm tree for the userland application
+      to migrate pollable sysfs attribute.
+  * ALSA Mixer control for headset mic select added  and
+    name of headset power amplifier control changed.
+  * Add multiple plane support with scaling / color space conversion.
+  * Allocate 752kB frame buffer memory for each plane.
+  * Register a /dev/fb node for each plane.
+  * Change the FBMEM ATAG to support per plane memory configuarion.
+  * Move the window update kernel API from blizzard to omapfb_main.
+  * Add omapfb Kconfig option to increase the consistent DMA pool size.
+    Update defconfig to set this to 4MB.
+  * Handle multiple board config entries that have the same TAG properly.
+    So far this was done only during the boot tag table parsing.
+  * Set board configuration earlier,
+    since things like SRAM initializing earlier can call get_config.
+  * bugfix: correct cover switch handling
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Tue, 11 Apr 2006 13:39:06 +0300
+
+kernel-source-rx-34-2.6.16 (2.6.16-rc2-osso9) unstable; urgency=low
+
+  * week200614-1 release
+  * USB: test pass in adapter using  trick
+  * Change IOCTL enum parameters to ints, exported u8/16/32 parameters to
+    __u8/16/32. Fixes a bug with a new toolchain where sizeof(enum) is
+    different between user space and kernel space.
+  * Enabling EABI  also modifications to
+    arch/arm/kernel/calls.S
+    arch/arm/kernel/sys_oabi-compat.c
+    to make this possible
+  * Remove extraneous alignment on x / width values of the update window.
+    This fixes a bug where a right stripe of the update window is not updated
+    properly.
+  * MUSB: Select EP0 again after reading EPx CSR register
+  * Enable OMAP watchdog
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed,  5 Apr 2006 15:55:54 +0300
+
+kernel-source-rx-34-2.6.16 (2.6.16-rc2-osso8) unstable; urgency=low
+
+  * week200613-2 release
+  * Add Hailstorm support
+  * Correct exposure time implementation.
+  * Stupid bug: &, not &&... 
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Thu, 30 Mar 2006 16:39:25 +0300
+
+kernel-source-rx-34-2.6.16 (2.6.16-rc2-osso7) unstable; urgency=low
+
+  * week200613-1 release
+  * Tony's USB patches
+  * MMC: negotialble voltage for 2 slots
+  * Merge branch 'master'
+  * Upstream mmc/omap.c merge
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 29 Mar 2006 16:16:34 +0300
+
+kernel-source-rx-34-2.6.16 (2.6.16-rc2-osso6) unstable; urgency=low
+
+  * week200612-1 release
+  * update defconfig
+    CONFIG_SOUND=y
+    CONFIG_SND=y
+    CONFIG_SPI_TSC2301_AUDIO=y
+    CONFIG_SPI_TSC2301_AUDIO_SELF_REGISTRATION=y
+    CONFIG_SND_OSSEMUL=y
+    CONFIG_SND_MIXER_OSS=y
+  * Revert "MMC NEGOTIALBLE VOLTAGE FOR 2 SLOTS"
+  * More sensible sysfs naming for the sensor entry.
+  * Camera sensor code cleanup, and sysfs entries addition
+  * MMC NEGOTIALBLE VOLTAGE FOR 2 SLOTS
+  * MMC HOTSWAP SUPPORT
+  * SD MULTIPLE SLOTS SUPPORT
+  * MMC MULTIPLE SLOTS SUPPORT UPDATES
+    - Basically reformatted.
+    - slots member moved into omap host structure.
+  * MMC BUGFIX TRIVIAL STUFFS
+    - kmalloc() & memset(0) was replaced by kzalloc()
+    - bugfix for incorrect pointer argument
+  * ARM: OMAP: omap2_mcspi: fix for channel configuration and CS
+  * That fixes a kernel oops when VIDIOC_STREAMOFF was called.
+    Now we can do streaming I/O with the camera.
+  * Corrects two bug in arch/arm/mach-omap2/clock.c.
+  * Extra TSC2301 Mixer controls are compiled 
+    if CONFIG_SPI_TSC2301_AUDIO is defined.
+  * Merge branch 'master'
+  * Enable ppp in defconfig
+  * VGA capture seems to work fine now.
+  * Poll should work now.
+  * TSC2301 ALSA Mixer.
+  * TSC2301 touchscreen: mangle reported coordinates above max pressure
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 22 Mar 2006 17:11:28 +0200
+
+kernel-source-rx-34-2.6.16 (2.6.16-rc2-osso5) unstable; urgency=low
+
+  * week200611-1 release
+  * TSC2301 touchscreen: increase x plate resistance for the lph8923 panel
+  * TSC2301 touchscreen: adjust maximum pressure for LS041Y3 panels
+  * Fix the previous fix. Damn, these untried patches never work out. 
+  * ARM: OMAP: omapfb: workaround for alignment bug in window updates
+  * Updated camera driver. This is in sync with David's latest code.
+  * ARM: OMAP: Make McBSP selectable through Kconfig
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed, 15 Mar 2006 16:00:15 +0200
+
+kernel-source-rx-34-2.6.16 (2.6.16-rc2-osso4) unstable; urgency=low
+
+  * week200610-1 release
+  * Changed packages name
+  * config: remove CONFIG_DEBUG_INFO
+
+ -- Yauheni Kaliuta <yauheni.kaliuta@nokia.com>  Wed,  8 Mar 2006 17:26:52 +0200
+
+kernel-source-2.6.16 (2.6.16-rc2-osso3) unstable; urgency=low
+
+  * TSC2301 touchscreen: set different parameters depending on panel type
+
+    Different panel types require different setup for the touchscreen
+    controller. This includes the X plate resistance, the number of samples
+    for HW and SW averaging and samples to be ignored before pen up occurs.
+    Set this configuration in the board-* file depending on the panel name
+    passed from the bootloader.
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Fri,  3 Mar 2006 12:23:58 +0200
+
+kernel-source-2.6.16 (2.6.16-rc2-osso2) unstable; urgency=low
+
+  * ARM: OMAP: omapfb: set panel name correctly in lcd_lph8923
+    Depending on the version set the panel name to either lph8923 or ls041y3.
+ 
+  *  TSC2301 touchscreen: add HW and SW averaging and pen up workaround
+     Some touch panels may generate rather unreliable readings even with
+     maximum HW averaging turned on. Implement SW averaging to improve the
+     readings.
+     Add a parameter to set the voltage settling time.
+     Workaround a problem where the pen up event may generate unreliable
+     reading. Ignore the last n samples from the average if required.
+
+ -- Eduard Bartosh <ed@ok.research.nokia.com>  Thu,  2 Mar 2006 17:17:33 +0200
+
+kernel-source-2.6.16 (2.6.16-rc2-osso1) unstable; urgency=low
+
+  * First build for rx-34 product
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Mon, 27 Feb 2006 18:09:52 +0200
+
+kernel-source-2.6.16 (2.6.16-rc4-osso1) unstable; urgency=low
+
+  * Disable CONFIG_AEABI from N770 defconfig
+    It seems that some places in our drivers still need a bit of
+    work until we can enable EABI.
+  * Fix Bluetooth RFCOMM reference counting
+    This also fixes a problem with pairing getting stuck.
+  * ARM: OMAP: Add external LCD controller support for DSP Gateway
+    If an external LCD controller is in manual update mode, the DSP
+    must let the FB driver know when a frame should be send over the
+    remote framebuffer interface.
+  * ARM: OMAP: MMC driver interoperability updates
+    - Decreased the MMC max sectors count
+    Some MMC cards get stuck hard when the max sectors count is >= 128.
+    - Add a delay after enabling the MMC power regulators
+    Regulator voltages typically have a rising delay. We have to make sure
+    the voltage has stabilized before sending the MMC init sequence.
+    - Add MMC cover switch last state initialization
+    The default last state was left to value 0 (= cover closed). If the cover
+    switch was initially open and then closed, no kevent about it is sent,
+    because the state didn't change from the last seen state.
+    - Add MMC transfer timeout
+    Very rarely the controller itself gets stuck. It needs a really hard reset
+    to recover. Add a timeout to work around against this.
+  * ARM: OMAP: Update n770_defconfig
+    - Enable kernel preemption
+    - Enable EABI user-space support
+    - Disable dyntick for now
+  * ARM: OMAP: Fix uWire SPI driver CS deselect.
+    CS deselection didn't work as expected. Writing 0 to CSR isn't enough,
+    the given CS value with CS_CMD cleared has to be written.
+  * ARM: OMAP: Set serial 8250 ECB for TX fifo
+    Code to fix serial TX fifo by Richard Woodruff.
+    The extended capabilities bit is needed to write fcr, or else some
+    settings don't get set.  That is what the OMAP-UART data sheet says.
+    The write water mark bits 4:5 are not accessible unless ECB is set.
+    The data sheet says it is TI16C750 compatible but it seems to share more
+    with what the code calls a TI16C752.  The 750 has a DLAB to set 64bit
+    fifo and I don't believe that is the case for ours.
+    A minor note is we are still only using 32 bytes of the 64 byte TX fifo
+    for transmits in the current code.  I'm not sure if there is an
+    application that this matters to.
+    Note that the current code id's OMAP serial ports as a 16654 which isn't
+    quite correct.
+    Also note that to use the actual TX watermark interrupt set at 32bytes
+    required too ugly of a hack to use (not use OMAP_SCR=0).
+  * [PATCH] ARM: OMAP: update flash timing on OMAP5912OSK
+    In linux-2.6.15-omap1 patch, in arch/arm/mach-omap1/board-osk.c,
+    EMIFS_CS3_VAL is set to 0x30003361.
+    This was introduced to fix flash timing error.
+    http://linux.omap.com/pipermail/linux-omap-open-source/2005-July/004717.html
+    On the other hand, in SectionE:Errata in EMIFS timing at:
+    http://omap.spectrumdigital.com/osk5912/osk5912_faq.html
+    EMIFS_CS3_VAL was set to 0x88013141, fixing write/read rate.
+    Reading from
+    http://focus.ti.com/lit/ug/spru742/spru742.pdf
+    3.6 EMIFS Registers,
+    0x30003361 will set read mode from "page mode, 4 word/page" to
+    "asynchronous read", and read from flash slowed down.
+    I tested with new value 0x88013141, and works good so far.
+  * ARM: OMAP: Support all four OMAP1610 GPIO trigger modes
+  * ARM: OMAP: Update usage of SA_SAMPLE_RANDOM flag
+  * [PATCH] ARM: OMAP: omap keypad H4 update
+    Move H4 Menelaus specific gpio settings to board-h4.c and fix
+    get_row_gpio_val function.
+  * [PATCH] ARM: OMAP: various whitespace cleanups
+    Please use 'let c_space_errors=1' in vim to see what this patch fixes.
+    While there, remove initilizers from variables which are by default
+    initialized to zero (to respect linux policy). No code changes.
+  * ARM: OMAP: lcd_lph8923: fix register read / write
+    A local variable hiding the one with the same name at an upper scope,
+    resulted in storing the register address instead of the desired value in
+    LCD registers.
+    In register writes there is no extra cycle after the command, so we use
+    only 9-bit word size.
+  * Linux v2.6.16-rc4
+  * Fixes from mainstream
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Wed, 22 Feb 2006 19:35:25 +0200
+
+kernel-source-2.6.16 (2.6.16-rc3-osso1) unstable; urgency=low
+
+  * First 2.6.16 build. A lot of changes from kernel mainstream 
+    amd from Nokia.
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Thu, 16 Feb 2006 14:46:03 +0200
+
+kernel-source-2.6.12.3 (2.6.12.3-osso25) unstable; urgency=low
+
+  * Default PSM should be dynamic. Kiitos to Janne Ylalehto for 
+    reviewing my trash.
+    We use PSM active whenever we lose the link. wlancond and 
+    other supplicant can always overwrite that setting ig they 
+    don't like it.
+
+  * BUGFIX: #22941
+
+  * Bug 22388 seemed to be fixed according to production statistics, but
+    some people are having troubles booting the device with the new boot
+    sequence. We now take the Symbian way, seems to work fine.
+
+  * BUGFIX: #22388
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Wed, 15 Feb 2006 14:28:42 +0200
+
+kernel-source-2.6.12.3 (2.6.12.3-osso24) unstable; urgency=low
+
+  * #22372 fix:  Frame lifetime needs to be increased for some Netgear APs.
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Thu, 26 Jan 2006 15:36:43 +0200
+
+kernel-source-2.6.12.3 (2.6.12.3-osso23) unstable; urgency=low
+
+  * week200603 release
+  * Toggling the START_HALTED bit in the boot sequence makes it more robust.
+    BUGFIX: #22388 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Thu, 19 Jan 2006 15:51:00 +0200
+
+kernel-source-2.6.12.3 (2.6.12.3-osso22) unstable; urgency=low
+
+  * week200550 release
+  * Tasklet latency is much better than workqueues. Also, we return jiffies 
+    in microseconds instead of timeofday for UMAC timekeeping.
+    BUGFIX: #21747, #21145
+  *   arch/arm/mach-omap/dsp/proclist.h
+      DSP Gateway patch for bug 20342 fix.
+      It is changed so that the processes that uses DSP Gateway driver are
+      listed with their pid's, instead of the task_struct pointers which has
+      been caused this bug.
+      Patch from Toshihiro Kobayashi <Toshihiro.Kobayashi@nokia.com>
+      
+      arch/arm/mach-omap/dsp/task.c
+      DSP Gateway patch for bug 20342 fix.
+      It is changed so that the processes that uses DSP Gateway driver are
+      listed with their pid's, instead of the task_struct pointers which has
+      been caused this bug.
+      Patch from Toshihiro Kobayashi <Toshihiro.Kobayashi@nokia.com>
+  *  Merge ok:/osso/linux-2.6 into  
+     six.research.nokia.com:/osso/bitkeeper_osso/linux-2.6
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Tue, 13 Dec 2005 14:56:07 +0200
+
+kernel-source-2.6.12.3 (2.6.12.3-osso21) unstable; urgency=low
+
+  * week200547 release
+  * TX burst mode implementation and newest MTUM integration.
+  * BUGFIX: 19579, 21543.
+  * Patched UMAC: The PMKID cache is not reset when we find a new AP (Stupid
+    Windows requirement)
+  * BUGFIX: 19482
+  * We need to give the possibility to run set_encryption with NET_ADMIN
+    capabilities. 
+
+ -- Ed Bartosh <ed@bifh.research.nokia.com>  Thu, 24 Nov 2005 14:16:08 +0200
+
+kernel-source-2.6.12.3 (2.6.12.3-osso20) unstable; urgency=low
+
+  * week200546 release
+  
+  * Fix bugs #20445 and #20446. Also the similar bugs was fixed
+    for g_ether module.
+    These are just a cosmetic changes. They do not modify module
+    behavior. The changes affect initfs only.
+  
+  * TX dropped and stupid spin_lock bug fixes.
+  
+ -- Ed Bartosh <ed@bifh.research.nokia.com>  Sun, 20 Nov 2005 16:57:27 +0200
+
+kernel-source-2.6.12.3 (2.6.12.3-osso19) unstable; urgency=low
+
+  * get rid of kpkg 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Thu, 17 Nov 2005 16:36:20 +0200
+
+kernel-source-2.6.12.3 (2.6.12.3-osso18) unstable; urgency=low
+
+  * 'XBCS-Scratchbox-Architecture: uarm' added
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Wed, 16 Nov 2005 17:16:57 +0200
+
+kernel-source-2.6.12.3 (2.6.12.3-osso17) unstable; urgency=low
+
+  * gettext support removed (now it's possible to build package in uclibc
+    toolchain) 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Wed, 16 Nov 2005 15:30:20 +0200
+
+kernel-source-2.6.12.3 (2.6.12.3-osso16) unstable; urgency=low
+
+  * Fixed stupid warning...
+  * WPA fixes, stability improved, or so we claim...
+  * BUGFIX: 19241, 21003, 15947, 21033, 11618 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Fri, 11 Nov 2005 16:48:31 +0200
+
+kernel-source-2.6.12.3 (2.6.12.3-osso15) unstable; urgency=low
+
+  * We disable background scanning only when receiving a deauth trap.
+  * Cset exclude: samuel@irie.nokia.com|ChangeSet|20051026134204|36577
+  * Several changes:
+    - Background scanning disabled. It is really bad.
+    - Removed the unused RX queues routines.
+    - Created our own work queue.
+  * Oops, one more OSMO reference to go..
+  * STI: Export omap_sti_init() for early console init.
+  * sti-fifo.c: Don't double check the IRQ status.
+  * STI: Rework to use proper platform devices.
+  * STI: Move to own subdir.
+  * STI: Get rid of old OSMO code, consolidate relevant bits, and cleanup.
+  * omap: Drop the STI tasklet handler, do irqdesc walking in IRQ context.
+    tasklets work well for some of these other status bits that could trigger
+    the interrupt, but unfortunately aren't suitable for the RX FIFO case on
+    account of being too slow. So we do inline irqdesc walking and dispatch
+    in the sti_interrupt() handler instead, this may be a bit heavy, but is
+    the only thing that ends up working in practice when we are under heavy
+    interrupt load.
+  * sti-fifo: Fixup buffer pointer assignment.
+  * omap: STI RX FIFO support.
+  * omap: Move STI enums to sti.h and export sti_readl/writel().
+  * sti-netlink.c: Adjust the skb tail based off of the payload size.
+                   Handle netlink_unicast() retval properly.
+  * sm_drv_spi_io.c: Cleaner complete/wait_for_completion DMA transfers.
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Mon, 31 Oct 2005 10:12:41 +0200
+
+kernel-source-2.6.12.3 (2.6.12.3-osso14) unstable; urgency=low
+
+  * source cleanup
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Thu, 27 Oct 2005 18:25:10 +0300
+
+kernel-source-2.6.12.3 (2.6.12.3-osso13) unstable; urgency=low
+
+  * STI: Export omap_sti_init() for early console init.
+  * Don't double check the IRQ status.
+  * STI: Rework to use proper platform devices.
+  * STI: Move to own subdir.
+  * STI: cleanup.
+  * omap: Drop the STI tasklet handler, do irqdesc walking in IRQ context.
+  * Cleaner complete/wait_for_completion DMA transfers. 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Wed, 26 Oct 2005 09:35:05 +0300
+
+kernel-source-2.6.12.3 (2.6.12.3-osso12) unstable; urgency=low
+
+  * w200543 release
+  * When booting the WLAN chip, we have to wait a bit more for 
+    workqueues to start.
+  * retu-rtc.c: Reinstate comments that were lamely removed by 
+    people who have no place touching code.
+    Purposely obscure the comments to make this thing look 
+    better than it actually is.
+  * Major WLAN driver cleanup and reorganisation for legal reasons.
+  * Prepare the CBUS and EM ASIC drivers for publishing
+    - add GPL license + copyrights + warranties to CBUS drives
+    - remove unnecessary #define's
+    - ack IRQs before enabling them in [retu|tahvo]_request_irq() functions
+      to avoid immediate interrups after requesting them
+  * 1 second SPI timer seems to be agressive and causes connection loses.
+  * We need to check the SPI bus more often since the UMAC BSS timeout can
+    be as low as 3 seconds.
+  * Ugly hack to support Nokia A032.
+  * Also we prevent the driver to send twice an IE event from the same state.
+    dsp_dld kills the wrong processes when rebooting DSP".
+    When a process opens a DSP device, the task_struct is put in the
+    dev->proc_list and when closing, it is removed from the list.
+    The problem was that when a process is killed while it is opening a DSP
+    device, the caller of close() won't be one which called open(), but the
+    parent of it. In this case the opener's task_struct is left in the
+    proc_list, which is not valid anymore and causes this bug.
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Tue, 25 Oct 2005 12:53:39 +0300
+
+kernel-source-2.6.12.3 (2.6.12.3-osso11) unstable; urgency=low
+
+  * w200543 release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Wed, 19 Oct 2005 16:40:51 +0300
+
+kernel-source-2.6.12.3 (2.6.12.3-osso10) unstable; urgency=low
+
+  * w200542 release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Sun, 16 Oct 2005 11:22:26 +0300
+
+kernel-source-2.6.12.3 (2.6.12.3-osso9) unstable; urgency=low
+
+  * w200541 release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Mon, 10 Oct 2005 11:00:36 +0300
+
+kernel-source-2.6.12.3 (2.6.12.3-osso8) unstable; urgency=low
+
+  * w200540 release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Mon,  3 Oct 2005 12:36:55 +0300
+
+kernel-source-2.6.12.3 (2.6.12.3-osso7) unstable; urgency=low
+
+  * w200539 release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Thu, 22 Sep 2005 17:30:56 +0300
+
+kernel-source-2.6.12.3 (2.6.12.3-osso6) unstable; urgency=low
+
+  * w200538 release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Sun, 18 Sep 2005 02:17:05 +0300
+
+kernel-source-2.6.12.3 (2.6.12.3-osso5) unstable; urgency=low
+
+  * w200536 release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Mon,  5 Sep 2005 15:36:31 +0300
+
+kernel-source-2.6.12.3 (2.6.12.3-osso4) unstable; urgency=low
+
+  * bluetooth fix from Ville 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Fri,  2 Sep 2005 01:59:51 +0300
+
+kernel-source-2.6.12.3 (2.6.12.3-osso3) unstable; urgency=low
+
+  * one more mmc patch applied 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Wed, 31 Aug 2005 19:09:45 +0300
+
+kernel-source-2.6.12.3 (2.6.12.3-osso2) unstable; urgency=low
+
+  * mmc fixes applied 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Tue, 30 Aug 2005 19:09:22 +0300
+
+kernel-source-2.6.12.3 (2.6.12.3-osso1) unstable; urgency=low
+
+  * w200535 release
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Sun, 28 Aug 2005 15:05:56 +0300
+
+kernel-source-2.6.12-rc2 (2.6.12-rc2-osso10) unstable; urgency=low
+
+  * w200533 release
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Sun, 14 Aug 2005 15:45:54 +0300
+
+kernel-source-2.6.12-rc2 (2.6.12-rc2-osso9) unstable; urgency=low
+
+  * w200532 release 
+
+ -- Alexey Kotovich <aliaksei.katovich@nokia.com>  Mon,  8 Aug 2005 01:24:40 +0300
+
+kernel-source-2.6.12-rc2 (2.6.12-rc2-osso8) unstable; urgency=low
+
+  * w200531 release
+
+ -- Alexey Kotovich <aliaksei.katovich@nokia.com>  Mon,  1 Aug 2005 15:42:57 +0300
+
+kernel-source-2.6.12-rc2 (2.6.12-rc2-osso7) unstable; urgency=low
+
+  * w200529 release 
+
+ -- Alexey Kotovich <aliaksei.katovich@nokia.com>  Sun, 17 Jul 2005 04:28:06 +0300
+
+kernel-source-2.6.12-rc2 (2.6.12-rc2-osso6) unstable; urgency=low
+
+  * w200528 release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Sun, 10 Jul 2005 20:11:10 +0300
+
+kernel-source-2.6.12-rc2 (2.6.12-rc2-osso5) unstable; urgency=low
+
+  * w200527 release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Wed,  6 Jul 2005 01:46:19 +0300
+
+kernel-source-2.6.12-rc2 (2.6.12-rc2-osso4) unstable; urgency=low
+
+  * w200526 release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Sat, 25 Jun 2005 11:52:00 +0300
+
+kernel-source-2.6.12-rc2 (2.6.12-rc2-osso3) unstable; urgency=low
+
+  * w20025 release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Sat, 25 Jun 2005 11:48:28 +0300
+
+kernel-source-2.6.12-rc2 (2.6.12-rc2-osso2) unstable; urgency=low
+
+  * w200524 release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Sun, 12 Jun 2005 22:35:57 +0300
+
+kernel-source-2.6.12-rc2 (2.6.12-rc2-osso1) unstable; urgency=low
+
+  * w200523 release
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Mon,  6 Jun 2005 22:11:46 +0300
+
+kernel-source-2.6.12-rc2-200521 (2.6.12-rc2-osso1) unstable; urgency=low
+
+  * w200521 release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Sun, 22 May 2005 22:10:57 +0300
+
+kernel-source-2.6.12-rc2-200520 (2.6.12-rc2-osso1) unstable; urgency=low
+
+  * w200520 release
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Sun, 15 May 2005 21:48:39 +0300
+
+kernel-source-2.6.12-rc2-200517 (2.6.12-rc2-osso7) unstable; urgency=low
+
+  * w200517 release
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Fri, 29 Apr 2005 11:09:22 +0300
+
+kernel-source-2.6.12-rc2-200516 (2.6.12-rc2-osso6) unstable; urgency=low
+
+  * w200516 release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Mon, 18 Apr 2005 10:20:12 +0300
+
+kernel-source-2.6.12-rc2-200515 (2.6.12-rc2-osso5) unstable; urgency=low
+
+  * w200515 release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Mon, 11 Apr 2005 09:52:14 +0300
+
+kernel-source-2.6.12-rc1-200514 (2.6.12-rc1-osso4) unstable; urgency=low
+
+  * w200514 release
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Mon,  4 Apr 2005 10:15:13 +0300
+
+kernel-source-2.6.11-200512 (2.6.11-osso3) unstable; urgency=low
+
+  * w200512 release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Sun, 20 Mar 2005 13:22:12 +0200
+
+kernel-source-2.6.11-200511 (2.6.11-osso2) unstable; urgency=low
+
+  * w200511 release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Fri, 11 Mar 2005 14:02:26 +0200
+
+kernel-source-2.6.11-rc5-200510 (2.6.11-osso1) unstable; urgency=low
+
+  * w200510 release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Mon,  7 Mar 2005 11:06:28 +0200
+
+kernel-source-2.6.11-rc4-200509 (2.6.11-osso1) unstable; urgency=low
+
+  * w200509 release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Mon, 28 Feb 2005 09:40:36 +0200
+
+kernel-source-2.6.11-rc3-200508 (2.6.11-osso1) unstable; urgency=low
+
+  * w200508 release
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Sun, 20 Feb 2005 19:27:12 +0200
+
+kernel-source-2.6.10-200507 (2.6.10-osso3) unstable; urgency=low
+
+  * w200507 release
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Sun, 13 Feb 2005 09:49:37 +0200
+
+kernel-source-2.6.10-200506 (2.6.10-osso2) unstable; urgency=low
+
+  * fix for usb 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Tue,  8 Feb 2005 17:56:56 +0200
+
+kernel-source-2.6.10-200506 (2.6.10-osso1) unstable; urgency=low
+
+  * w200506 release
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Fri,  4 Feb 2005 14:46:47 +0200
+
+kernel-source-2.6.10-200505 (2.6.10-osso1) unstable; urgency=low
+
+  * w200505 release
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Thu, 27 Jan 2005 14:59:27 +0200
+
+kernel-source-2.6.10.w200504 (2.6.10-osso.0.200504.1) unstable; urgency=low
+
+  * w200504 release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Mon, 24 Jan 2005 19:30:56 +0200
+
+kernel-source-2.6.10 (2.6.10-osso.0.200503.1) unstable; urgency=low
+
+  *  w200503 release
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Mon, 17 Jan 2005 10:57:47 +0200
+
+kernel-source-2.6.10-rc3 (2.6.10-rc3-osso.0.52.1) unstable; urgency=low
+
+  * w52 fake release 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Wed, 12 Jan 2005 18:53:40 +0200
+
+kernel-source-2.6.10-rc3 (2.6.10-rc3-osso.0.51.1) unstable; urgency=low
+
+  * W51 release
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Sun, 12 Dec 2004 20:40:34 +0200
+
+kernel-source-2.6.10-rc1 (2.6.10-rc1-osso.0.48.3) unstable; urgency=low
+
+  * last minute WLAN fixes 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Thu, 25 Nov 2004 18:54:39 +0200
+
+kernel-source-2.6.10-rc1 (2.6.10-rc1-osso.0.48.2) unstable; urgency=low
+
+  * usb-serial support is turned on 
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Wed, 24 Nov 2004 15:57:46 +0200
+
+kernel-source-2.6.10-rc1 (2.6.10-rc1-osso.0.48.1) unstable; urgency=low
+
+  * W48 core release  
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Mon, 22 Nov 2004 13:32:32 +0200
+
+kernel-source-2.6.10-rc1 (2.6.10-rc1-osso.0.46.1) unstable; urgency=low
+
+  * W46 core release
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Tue,  9 Nov 2004 12:00:42 +0200
+
+kernel-source-2.6.10 (2.6.10-rc1-osso.0.45.1) unstable; urgency=low
+
+  * Initial release
+
+ -- Ed Bartosh <eduard.bartosh@nokia.com>  Sun, 31 Oct 2004 15:47:18 +0200
+
diff -ruN linux-omap-2.6/compat maemo_src/compat
--- linux-omap-2.6/compat	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/compat	2011-02-06 19:38:22.563333272 -0500
@@ -0,0 +1,2 @@
+4
+
diff -ruN linux-omap-2.6/control maemo_src/control
--- linux-omap-2.6/control	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/control	2011-02-06 19:38:22.563333272 -0500
@@ -0,0 +1,28 @@
+Source: kernel-source-diablo
+Section: devel
+Priority: optional
+Maintainer: Grigori Timonen <grigori.timonen@nokia.com>
+Standards-Version: 3.8.0
+XBCS-Scratchbox-Architecture: uarm
+Build-Depends: debhelper (>= 4)
+
+Package: kernel-source-diablo
+Architecture: all
+Section: devel
+Priority: optional
+Provides: kernel-source, kernel-source-2.6
+Recommends: libc6-dev | libc-dev, gcc, make
+Suggests: libncurses-dev | ncurses-dev, kernel-package, libqt3-dev
+Description: Linux kernel sources for rx-34, rx-44 and rx-48 products
+ This package provides the source code for the Linux kernel
+ .
+ You may configure the kernel to your setup by typing "make config"
+ and following instructions, but you could get ncursesX.X-dev and try
+ "make menuconfig" for a jazzier, and easier to use interface. There 
+ are options to use QT or GNOME based configuration interfaces, but they
+ need additional packages to be installed.
+ .
+ If you wish to use this package to create a custom Linux kernel, then
+ it is suggested that you investigate the package kernel-package,
+ which has been designed to ease the task of creating kernel image
+ packages. 
diff -ruN linux-omap-2.6/copyright maemo_src/copyright
--- linux-omap-2.6/copyright	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/copyright	2011-02-06 19:38:22.563333272 -0500
@@ -0,0 +1,36 @@
+This is the Debian GNU/Linux prepackaged version of the Linux kernel.
+Linux was written by Linus Torvalds <Linus.Torvalds@cs.Helsinki.FI>
+and others.
+
+This package was put together by Simon Shapiro <Shimon@i-Connect.Net>, from
+sources retrieved from directories under
+ftp.cs.helsinki.fi:/pub/Software/Linux/Kernel/
+The sources may be found at most Linux ftp sites, including 
+ftp://ftp.kernel.org/pub/linux/kernel/
+
+This package was then maintained by Sven Rudolph.
+
+This package was maintained by Herbert Xu <herbert@debian.org>
+from March 1997 to May 2004.
+
+This package is currently maintained by the
+Ed Bartosh <Eduard.Bartosh@nokia.com>
+
+Linux is copyrighted by Linus Torvalds and others.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; version 2 dated June, 1991.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.
+
+On Debian GNU/Linux systems, the complete text of the GNU General
+Public License can be found in `/usr/share/common-licenses/GPL'.
diff -ruN linux-omap-2.6/crypto/crypto_lzo.c maemo_src/crypto/crypto_lzo.c
--- linux-omap-2.6/crypto/crypto_lzo.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/crypto/crypto_lzo.c	2007-10-02 03:09:31.000000000 -0400
@@ -0,0 +1,123 @@
+/*
+ * Cryptographic API for LZO compression.
+ *
+ * Copyright (C) 2007 Nokia Corporation. All rights reserved.
+ *
+ * Author: Richard Purdie <rpurdie@openedhand.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/crypto.h>
+#include <linux/vmalloc.h>
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+#include <linux/lzo.h>
+
+struct lzo_ctx {
+	void *lzo_mem;
+};
+
+static int lzo_init(struct crypto_tfm *tfm)
+{
+	struct lzo_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	ctx->lzo_mem = vmalloc(LZO1X_MEM_COMPRESS);
+
+	if (!ctx->lzo_mem) {
+		vfree(ctx->lzo_mem);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void lzo_exit(struct crypto_tfm *tfm)
+{
+	struct lzo_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	vfree(ctx->lzo_mem);
+}
+
+static int lzo_compress(struct crypto_tfm *tfm, const u8 *src,
+			    unsigned int slen, u8 *dst, unsigned int *dlen)
+{
+	struct lzo_ctx *ctx = crypto_tfm_ctx(tfm);
+	size_t compress_size;
+	int ret;
+
+	/* Check if enough space in dst buffer for worst case expansion */
+	if (*dlen < lzo1x_worst_compress(slen))
+		return -EINVAL;
+
+	ret = lzo1x_1_compress(src, slen, dst, &compress_size, ctx->lzo_mem);
+
+	if (ret != LZO_E_OK)
+		return -EINVAL;
+
+	*dlen = compress_size;
+
+	return 0;
+}
+
+static int lzo_decompress(struct crypto_tfm *tfm, const u8 *src,
+			      unsigned int slen, u8 *dst, unsigned int *dlen)
+{
+	int ret;
+	size_t dest_len = *dlen;
+
+	ret = lzo1x_decompress_safe(src, slen, dst, &dest_len);
+
+	*dlen = dest_len;
+
+	if (ret != LZO_E_OK)
+		return -EINVAL;
+
+	return 0;
+}
+
+static struct crypto_alg alg = {
+	.cra_name		= "lzo1x",
+	.cra_flags		= CRYPTO_ALG_TYPE_COMPRESS,
+	.cra_ctxsize		= sizeof(struct lzo_ctx),
+	.cra_module		= THIS_MODULE,
+	.cra_list		= LIST_HEAD_INIT(alg.cra_list),
+	.cra_init		= lzo_init,
+	.cra_exit		= lzo_exit,
+	.cra_u			= { .compress = {
+	.coa_compress 		= lzo_compress,
+	.coa_decompress  	= lzo_decompress } }
+};
+
+static int __init init(void)
+{
+	return crypto_register_alg(&alg);
+}
+
+static void __exit fini(void)
+{
+	crypto_unregister_alg(&alg);
+}
+
+module_init(init);
+module_exit(fini);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("LZO Compression Algorithm");
+MODULE_AUTHOR("Richard Purdie <rpurdie@openedhand.com>");
+
diff -ruN linux-omap-2.6/crypto/Kconfig maemo_src/crypto/Kconfig
--- linux-omap-2.6/crypto/Kconfig	2011-02-06 19:44:45.273333273 -0500
+++ maemo_src/crypto/Kconfig	2007-10-02 03:09:31.000000000 -0400
@@ -406,6 +406,15 @@
 	  
 	  You will most probably want this if using IPSec.
 
+config CRYPTO_LZO
+	tristate "LZO compression algorithm"
+	depends on CRYPTO
+	select LZO_COMPRESS
+	select LZO_DECOMPRESS
+	help
+	  Enable use of the LZO compression algorithm through the crypto
+	  subsystem.
+
 config CRYPTO_MICHAEL_MIC
 	tristate "Michael MIC keyed digest algorithm"
 	select CRYPTO_ALGAPI
diff -ruN linux-omap-2.6/crypto/Makefile maemo_src/crypto/Makefile
--- linux-omap-2.6/crypto/Makefile	2011-02-06 19:44:45.273333273 -0500
+++ maemo_src/crypto/Makefile	2007-10-02 03:09:31.000000000 -0400
@@ -44,6 +44,7 @@
 obj-$(CONFIG_CRYPTO_KHAZAD) += khazad.o
 obj-$(CONFIG_CRYPTO_ANUBIS) += anubis.o
 obj-$(CONFIG_CRYPTO_DEFLATE) += deflate.o
+obj-$(CONFIG_CRYPTO_LZO) += crypto_lzo.o
 obj-$(CONFIG_CRYPTO_MICHAEL_MIC) += michael_mic.o
 obj-$(CONFIG_CRYPTO_CRC32C) += crc32c.o
 
diff -ruN linux-omap-2.6/crypto/tcrypt.c maemo_src/crypto/tcrypt.c
--- linux-omap-2.6/crypto/tcrypt.c	2011-02-06 19:44:45.296666606 -0500
+++ maemo_src/crypto/tcrypt.c	2007-10-02 03:09:31.000000000 -0400
@@ -747,7 +747,7 @@
 	crypto_free_hash(tfm);
 }
 
-static void test_deflate(void)
+static void test_compress(char *algo, struct comp_testvec *testvec, int num_tests)
 {
 	unsigned int i;
 	char result[COMP_BUF_SIZE];
@@ -755,25 +755,25 @@
 	struct comp_testvec *tv;
 	unsigned int tsize;
 
-	printk("\ntesting deflate compression\n");
+	printk("\ntesting %s compression\n", algo);
 
-	tsize = sizeof (deflate_comp_tv_template);
+	tsize = sizeof(struct comp_testvec) * num_tests;
 	if (tsize > TVMEMSIZE) {
 		printk("template (%u) too big for tvmem (%u)\n", tsize,
 		       TVMEMSIZE);
 		return;
 	}
 
-	memcpy(tvmem, deflate_comp_tv_template, tsize);
+	memcpy(tvmem, testvec, tsize);
 	tv = (void *)tvmem;
 
-	tfm = crypto_alloc_comp("deflate", 0, CRYPTO_ALG_ASYNC);
+	tfm = crypto_alloc_comp(algo, 0, CRYPTO_ALG_ASYNC);
 	if (IS_ERR(tfm)) {
-		printk("failed to load transform for deflate\n");
+		printk("failed to load transform for %s\n", algo);
 		return;
 	}
 
-	for (i = 0; i < DEFLATE_COMP_TEST_VECTORS; i++) {
+	for (i = 0; i < num_tests; i++) {
 		int ilen, ret, dlen = COMP_BUF_SIZE;
 
 		printk("test %u:\n", i + 1);
@@ -792,26 +792,16 @@
 		       ilen, dlen);
 	}
 
-	printk("\ntesting deflate decompression\n");
+	printk("\ntesting %s decompression\n", algo);
 
-	tsize = sizeof (deflate_decomp_tv_template);
-	if (tsize > TVMEMSIZE) {
-		printk("template (%u) too big for tvmem (%u)\n", tsize,
-		       TVMEMSIZE);
-		goto out;
-	}
-
-	memcpy(tvmem, deflate_decomp_tv_template, tsize);
-	tv = (void *)tvmem;
-
-	for (i = 0; i < DEFLATE_DECOMP_TEST_VECTORS; i++) {
+	for (i = 0; i < num_tests; i++) {
 		int ilen, ret, dlen = COMP_BUF_SIZE;
 
 		printk("test %u:\n", i + 1);
 		memset(result, 0, sizeof (result));
 
-		ilen = tv[i].inlen;
-		ret = crypto_comp_decompress(tfm, tv[i].input,
+		ilen = tv[i].outlen;
+		ret = crypto_comp_decompress(tfm, tv[i].output,
 		                             ilen, result, &dlen);
 		if (ret) {
 			printk("fail: ret=%d\n", ret);
@@ -819,7 +809,7 @@
 		}
 		hexdump(result, dlen);
 		printk("%s (ratio %d:%d)\n",
-		       memcmp(result, tv[i].output, dlen) ? "fail" : "pass",
+		       memcmp(result, tv[i].input, dlen) ? "fail" : "pass",
 		       ilen, dlen);
 	}
 out:
@@ -994,7 +984,8 @@
 		test_hash("tgr192", tgr192_tv_template, TGR192_TEST_VECTORS);
 		test_hash("tgr160", tgr160_tv_template, TGR160_TEST_VECTORS);
 		test_hash("tgr128", tgr128_tv_template, TGR128_TEST_VECTORS);
-		test_deflate();
+		test_compress("deflate", deflate_tv_template, DEFLATE_TEST_VECTORS);
+		test_compress("lzo1x", lzo1x_tv_template, LZO1X_TEST_VECTORS);
 		test_hash("crc32c", crc32c_tv_template, CRC32C_TEST_VECTORS);
 		test_hash("hmac(md5)", hmac_md5_tv_template,
 			  HMAC_MD5_TEST_VECTORS);
@@ -1100,7 +1091,7 @@
 		break;
 
 	case 13:
-		test_deflate();
+		test_compress("deflate", deflate_tv_template, DEFLATE_TEST_VECTORS);
 		break;
 
 	case 14:
@@ -1225,6 +1216,10 @@
 			    CAMELLIA_CBC_DEC_TEST_VECTORS);
 		break;
 
+	case 33:
+		test_compress("lzo1x", lzo1x_tv_template, LZO1X_TEST_VECTORS);
+		break;
+
 	case 100:
 		test_hash("hmac(md5)", hmac_md5_tv_template,
 			  HMAC_MD5_TEST_VECTORS);
diff -ruN linux-omap-2.6/crypto/tcrypt.h maemo_src/crypto/tcrypt.h
--- linux-omap-2.6/crypto/tcrypt.h	2011-02-06 19:44:45.303333272 -0500
+++ maemo_src/crypto/tcrypt.h	2007-10-02 03:09:31.000000000 -0400
@@ -3846,10 +3846,9 @@
  * Deflate test vectors (null-terminated strings).
  * Params: winbits=11, Z_DEFAULT_COMPRESSION, MAX_MEM_LEVEL.
  */
-#define DEFLATE_COMP_TEST_VECTORS 2
-#define DEFLATE_DECOMP_TEST_VECTORS 2
+#define DEFLATE_TEST_VECTORS 2
 
-static struct comp_testvec deflate_comp_tv_template[] = {
+static struct comp_testvec deflate_tv_template[] = {
 	{
 		.inlen	= 70,
 		.outlen	= 38,
@@ -3885,39 +3884,49 @@
 	},
 };
 
-static struct comp_testvec deflate_decomp_tv_template[] = {
+/*
+ * LZO test vectors
+ */
+#define LZO1X_TEST_VECTORS 2
+
+static struct comp_testvec lzo1x_tv_template[] = {
 	{
-		.inlen	= 122,
-		.outlen	= 191,
-		.input	= { 0x5d, 0x8d, 0x31, 0x0e, 0xc2, 0x30, 0x10, 0x04,
-			    0xbf, 0xb2, 0x2f, 0xc8, 0x1f, 0x10, 0x04, 0x09,
-			    0x89, 0xc2, 0x85, 0x3f, 0x70, 0xb1, 0x2f, 0xf8,
-			    0x24, 0xdb, 0x67, 0xd9, 0x47, 0xc1, 0xef, 0x49,
-			    0x68, 0x12, 0x51, 0xae, 0x76, 0x67, 0xd6, 0x27,
-			    0x19, 0x88, 0x1a, 0xde, 0x85, 0xab, 0x21, 0xf2,
-			    0x08, 0x5d, 0x16, 0x1e, 0x20, 0x04, 0x2d, 0xad,
-			    0xf3, 0x18, 0xa2, 0x15, 0x85, 0x2d, 0x69, 0xc4,
-			    0x42, 0x83, 0x23, 0xb6, 0x6c, 0x89, 0x71, 0x9b,
-			    0xef, 0xcf, 0x8b, 0x9f, 0xcf, 0x33, 0xca, 0x2f,
-			    0xed, 0x62, 0xa9, 0x4c, 0x80, 0xff, 0x13, 0xaf,
-			    0x52, 0x37, 0xed, 0x0e, 0x52, 0x6b, 0x59, 0x02,
-			    0xd9, 0x4e, 0xe8, 0x7a, 0x76, 0x1d, 0x02, 0x98,
-			    0xfe, 0x8a, 0x87, 0x83, 0xa3, 0x4f, 0x56, 0x8a,
-			    0xb8, 0x9e, 0x8e, 0x5c, 0x57, 0xd3, 0xa0, 0x79,
-			    0xfa, 0x02 },
-		.output	= "This document describes a compression method based on the DEFLATE"
+		.inlen	= 70,
+		.outlen	= 46,
+		.input	= "Join us now and share the software "
+			  "Join us now and share the software ",
+		.output	= { 0x00, 0x0d, 0x4a, 0x6f, 0x69, 0x6e, 0x20, 0x75,
+			    0x73, 0x20, 0x6e, 0x6f, 0x77, 0x20, 0x61, 0x6e,
+			    0x64, 0x20, 0x73, 0x68, 0x61, 0x72, 0x65, 0x20,
+			    0x74, 0x68, 0x65, 0x20, 0x73, 0x6f, 0x66, 0x74,
+			    0x77, 0x70, 0x01, 0x01, 0x4a, 0x6f, 0x69, 0x6e,
+			    0x3d, 0x88, 0x00, 0x11, 0x00, 0x00 },
+	}, {
+		.inlen	= 191,
+		.outlen	= 153,
+		.input	= "This document describes a compression method based on the DEFLATE"
 			  "compression algorithm.  This document defines the application of "
 			  "the DEFLATE algorithm to the IP Payload Compression Protocol.",
-	}, {
-		.inlen	= 38,
-		.outlen	= 70,
-		.input	= { 0xf3, 0xca, 0xcf, 0xcc, 0x53, 0x28, 0x2d, 0x56,
-			    0xc8, 0xcb, 0x2f, 0x57, 0x48, 0xcc, 0x4b, 0x51,
-			    0x28, 0xce, 0x48, 0x2c, 0x4a, 0x55, 0x28, 0xc9,
-			    0x48, 0x55, 0x28, 0xce, 0x4f, 0x2b, 0x29, 0x07,
-			    0x71, 0xbc, 0x08, 0x2b, 0x01, 0x00 },
-		.output	= "Join us now and share the software "
-			  "Join us now and share the software ",
+		.output	= { 0x00, 0x2f, 0x54, 0x68, 0x69, 0x73, 0x20, 0x64,
+			    0x6f, 0x63, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x20,
+			    0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x62, 0x65,
+			    0x73, 0x20, 0x61, 0x20, 0x63, 0x6f, 0x6d, 0x70,
+			    0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x20,
+			    0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x20, 0x62,
+			    0x61, 0x73, 0x65, 0x64, 0x20, 0x6f, 0x6e, 0x20,
+			    0x74, 0x68, 0x65, 0x20, 0x44, 0x45, 0x46, 0x4c,
+			    0x41, 0x54, 0x45, 0x2a, 0x98, 0x00, 0x0d, 0x61,
+			    0x6c, 0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d,
+			    0x2e, 0x20, 0x20, 0x54, 0x68, 0x69, 0x73, 0x2a,
+			    0x60, 0x01, 0x02, 0x66, 0x69, 0x6e, 0x65, 0x73,
+			    0x80, 0x07, 0x05, 0x61, 0x70, 0x70, 0x6c, 0x69,
+			    0x63, 0x61, 0x74, 0x62, 0x0b, 0x6f, 0x66, 0x88,
+			    0x02, 0xcd, 0x09, 0x20, 0x27, 0x03, 0x01, 0x20,
+			    0x74, 0x6f, 0x80, 0x03, 0x09, 0x49, 0x50, 0x20,
+			    0x50, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x20,
+			    0x43, 0x29, 0x3c, 0x02, 0x06, 0x50, 0x72, 0x6f,
+			    0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x2e, 0x11, 0x00,
+			    0x00 },
 	},
 };
 
diff -ruN linux-omap-2.6/dirs maemo_src/dirs
--- linux-omap-2.6/dirs	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/dirs	2011-02-06 19:38:22.573333274 -0500
@@ -0,0 +1 @@
+usr/src/
diff -ruN linux-omap-2.6/Documentation/filesystems/vfat.txt maemo_src/Documentation/filesystems/vfat.txt
--- linux-omap-2.6/Documentation/filesystems/vfat.txt	2011-02-06 19:44:40.236666606 -0500
+++ maemo_src/Documentation/filesystems/vfat.txt	2011-02-06 20:12:13.959999940 -0500
@@ -57,6 +57,13 @@
                  currently exist in the directory, 'longfile.txt' will
                  be the short alias instead of 'longfi~1.txt'. 
                   
+usefree       -- Use the "free clusters" value stored on FSINFO. It'll
+                 be used to determine number of free clusters without
+                 scanning disk. But it's not used by default, because
+                 recent Windows don't update it correctly in some
+                 case. If you are sure the "free clusters" on FSINFO is
+                 correct, by this option you can avoid scanning disk.
+
 quiet         -- Stops printing certain warning messages.
 
 check=s|r|n   -- Case sensitivity checking setting.
diff -ruN linux-omap-2.6/drivers/bluetooth/hci_h4p/core.c maemo_src/drivers/bluetooth/hci_h4p/core.c
--- linux-omap-2.6/drivers/bluetooth/hci_h4p/core.c	2011-02-06 20:17:25.483333274 -0500
+++ maemo_src/drivers/bluetooth/hci_h4p/core.c	2011-02-06 20:12:11.106666605 -0500
@@ -144,7 +144,7 @@
 	if (info->rx_pm_enabled) {
 		hci_h4p_set_clk(info, &info->rx_clocks_en, 1);
 		hci_h4p_outb(info, UART_IER, hci_h4p_inb(info, UART_IER) | UART_IER_RDI);
-		hci_h4p_set_auto_ctsrts(info, 1, UART_EFR_RTS);
+		__hci_h4p_set_auto_ctsrts(info, 1, UART_EFR_RTS);
 		info->rx_pm_enabled = 0;
 	}
 	spin_unlock_irqrestore(&info->lock, flags);
@@ -157,7 +157,7 @@
 
 	spin_lock_irqsave(&info->lock, flags);
 	if (!(hci_h4p_inb(info, UART_LSR) & UART_LSR_DR)) {
-		hci_h4p_set_auto_ctsrts(info, 0, UART_EFR_RTS);
+		__hci_h4p_set_auto_ctsrts(info, 0, UART_EFR_RTS);
 		hci_h4p_set_rts(info, 0);
 		hci_h4p_outb(info, UART_IER, hci_h4p_inb(info, UART_IER) & ~UART_IER_RDI);
 		hci_h4p_set_clk(info, &info->rx_clocks_en, 0);
@@ -231,7 +231,6 @@
 			goto neg_ret;
 
 		hci_h4p_change_speed(info, MAX_BAUD_RATE);
-		hci_h4p_set_rts(info, 1);
 
 		err = hci_h4p_wait_for_cts(info, 1, 100);
 		if (err < 0)
@@ -252,8 +251,8 @@
 	return;
 
 neg_ret:
-	complete(&info->init_completion);
 	info->init_error = err;
+	complete(&info->init_completion);
 	kfree_skb(skb);
 }
 
@@ -420,6 +419,8 @@
 finish_task:
 	spin_lock_irqsave(&info->lock, flags);
 	hci_h4p_outb(info, UART_IER, hci_h4p_inb(info, UART_IER) | UART_IER_RDI);
+	if (timer_pending(&info->tx_pm_timer))
+		mod_timer(&info->tx_pm_timer, jiffies + msecs_to_jiffies(PM_TIMEOUT));
 	spin_unlock_irqrestore(&info->lock, flags);
 
 	NBT_DBG_TRANSFER_NF("\n");
@@ -511,7 +512,6 @@
 		ret = IRQ_HANDLED;
 	}
 
-
 	return ret;
 }
 
@@ -545,7 +545,6 @@
 	int err;
 
 	hci_h4p_init_uart(info);
-	hci_h4p_set_auto_ctsrts(info, 0, UART_EFR_CTS | UART_EFR_RTS);
 	hci_h4p_set_rts(info, 0);
 
 	omap_set_gpio_dataout(info->reset_gpio, 0);
@@ -626,8 +625,6 @@
 	if (err < 0)
 		goto err_clean;
 
-	hci_h4p_set_auto_ctsrts(info, 1, UART_EFR_CTS | UART_EFR_RTS);
-
 	err = hci_h4p_send_fw(info, &fw_queue);
 	if (err < 0) {
 		dev_err(info->dev, "Sending firmware failed.\n");
@@ -675,6 +672,8 @@
 	del_timer_sync(&info->rx_pm_timer);
 	tasklet_disable(&info->tx_task);
 	tasklet_disable(&info->rx_task);
+	hci_h4p_set_clk(info, &info->tx_clocks_en, 1);
+	hci_h4p_set_clk(info, &info->rx_clocks_en, 1);
 	hci_h4p_reset_uart(info);
 	hci_h4p_set_clk(info, &info->tx_clocks_en, 0);
 	hci_h4p_set_clk(info, &info->rx_clocks_en, 0);
@@ -916,11 +915,10 @@
 	}
 
 	hci_h4p_set_clk(info, &info->tx_clocks_en, 1);
+	hci_h4p_set_auto_ctsrts(info, 0, UART_EFR_CTS | UART_EFR_RTS);
 	err = hci_h4p_init_uart(info);
 	if (err < 0)
 		goto cleanup_irq;
-	hci_h4p_set_auto_ctsrts(info, 0, UART_EFR_CTS | UART_EFR_RTS);
-	hci_h4p_set_rts(info, 0);
 	err = hci_h4p_reset(info);
 	if (err < 0)
 		goto cleanup_irq;
diff -ruN linux-omap-2.6/drivers/bluetooth/hci_h4p/hci_h4p.h maemo_src/drivers/bluetooth/hci_h4p/hci_h4p.h
--- linux-omap-2.6/drivers/bluetooth/hci_h4p/hci_h4p.h	2011-02-06 20:17:25.483333274 -0500
+++ maemo_src/drivers/bluetooth/hci_h4p/hci_h4p.h	2007-10-02 03:09:31.000000000 -0400
@@ -174,6 +174,7 @@
 u8 hci_h4p_inb(struct hci_h4p_info *info, unsigned int offset);
 void hci_h4p_set_rts(struct hci_h4p_info *info, int active);
 int hci_h4p_wait_for_cts(struct hci_h4p_info *info, int active, int timeout_ms);
+void __hci_h4p_set_auto_ctsrts(struct hci_h4p_info *info, int on, u8 which);
 void hci_h4p_set_auto_ctsrts(struct hci_h4p_info *info, int on, u8 which);
 void hci_h4p_change_speed(struct hci_h4p_info *info, unsigned long speed);
 int hci_h4p_reset_uart(struct hci_h4p_info *info);
diff -ruN linux-omap-2.6/drivers/bluetooth/hci_h4p/uart.c maemo_src/drivers/bluetooth/hci_h4p/uart.c
--- linux-omap-2.6/drivers/bluetooth/hci_h4p/uart.c	2011-02-06 20:17:25.483333274 -0500
+++ maemo_src/drivers/bluetooth/hci_h4p/uart.c	2007-10-02 03:09:31.000000000 -0400
@@ -75,7 +75,7 @@
 	}
 }
 
-void hci_h4p_set_auto_ctsrts(struct hci_h4p_info *info, int on, u8 which)
+void __hci_h4p_set_auto_ctsrts(struct hci_h4p_info *info, int on, u8 which)
 {
 	u8 lcr, b;
 
@@ -90,6 +90,15 @@
 	hci_h4p_outb(info, UART_LCR, lcr);
 }
 
+void hci_h4p_set_auto_ctsrts(struct hci_h4p_info *info, int on, u8 which)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&info->lock, flags);
+	__hci_h4p_set_auto_ctsrts(info, on, which);
+	spin_unlock_irqrestore(&info->lock, flags);
+}
+
 void hci_h4p_change_speed(struct hci_h4p_info *info, unsigned long speed)
 {
 	unsigned int divisor;
diff -ruN linux-omap-2.6/drivers/cbus/retu.c maemo_src/drivers/cbus/retu.c
--- linux-omap-2.6/drivers/cbus/retu.c	2011-02-06 20:17:25.499999939 -0500
+++ maemo_src/drivers/cbus/retu.c	2007-10-02 03:09:31.000000000 -0400
@@ -114,9 +114,21 @@
 		return -EINVAL;
 
 	spin_lock_irqsave(&retu_lock, flags);
+
+	if ((channel == 8) && retu_is_vilma) {
+		int scr = retu_read_reg(RETU_REG_ADCSCR);
+		int ch = (retu_read_reg(RETU_REG_ADCR) >> 10) & 0xf;
+		if (((scr & 0xff) != 0) && (ch != 8))
+			retu_write_reg (RETU_REG_ADCSCR, (scr & ~0xff));
+	}
+
 	/* Select the channel and read result */
 	retu_write_reg(RETU_REG_ADCR, channel << 10);
 	res = retu_read_reg(RETU_REG_ADCR) & 0x3ff;
+
+	if (retu_is_vilma)
+		retu_write_reg(RETU_REG_ADCR, (1 << 13));
+
 	/* Unlock retu */
 	spin_unlock_irqrestore(&retu_lock, flags);
 
@@ -306,7 +318,7 @@
  * Probe for the Retu ASIC and allocate memory
  * for its device-struct if found
  */
-static int __devinit retu_probe(struct device *dev)
+static int __init retu_probe(struct platform_device *pdev)
 {
 	const struct omap_em_asic_bb5_config * em_asic_config;
 	int rev, ret;
@@ -371,7 +383,7 @@
 	return 0;
 }
 
-static int retu_remove(struct device *dev)
+static int retu_remove(struct platform_device *pdev)
 {
 #ifdef CONFIG_CBUS_RETU_USER
 	retu_user_cleanup();
@@ -390,11 +402,12 @@
 	complete(&device_release);
 }
 
-static struct device_driver retu_driver = {
-	.name		= "retu",
-	.bus		= &platform_bus_type,
+static struct platform_driver retu_driver = {
 	.probe		= retu_probe,
 	.remove		= retu_remove,
+	.driver		= {
+		.name	= "retu",
+	},
 };
 
 static struct platform_device retu_device = {
@@ -418,11 +431,11 @@
 
 	init_completion(&device_release);
 
-	if ((ret = driver_register(&retu_driver)) < 0)
+	if ((ret = platform_driver_register(&retu_driver)) < 0)
 		return ret;
 
 	if ((ret = platform_device_register(&retu_device)) < 0) {
-		driver_unregister(&retu_driver);
+		platform_driver_unregister(&retu_driver);
 		return ret;
 	}
 	return 0;
@@ -434,7 +447,7 @@
 static void __exit retu_exit(void)
 {
 	platform_device_unregister(&retu_device);
-	driver_unregister(&retu_driver);
+	platform_driver_unregister(&retu_driver);
 	wait_for_completion(&device_release);
 }
 
diff -ruN linux-omap-2.6/drivers/cbus/retu.h maemo_src/drivers/cbus/retu.h
--- linux-omap-2.6/drivers/cbus/retu.h	2011-02-06 20:17:25.499999939 -0500
+++ maemo_src/drivers/cbus/retu.h	2007-10-02 03:09:31.000000000 -0400
@@ -34,6 +34,7 @@
 #define RETU_REG_RTCHMAR	0x05	/* RTC hours and minutes alarm and time set register */
 #define RETU_REG_RTCCALR	0x06	/* RTC calibration register */
 #define RETU_REG_ADCR		0x08	/* ADC result */
+#define RETU_REG_ADCSCR		0x09	/* ADC sample ctrl */
 #define RETU_REG_CC1		0x0d	/* Common control register 1 */
 #define RETU_REG_CC2		0x0e	/* Common control register 2 */
 #define RETU_REG_CTRL_CLR	0x0f	/* Regulator clear register */
diff -ruN linux-omap-2.6/drivers/cbus/retu-headset.c maemo_src/drivers/cbus/retu-headset.c
--- linux-omap-2.6/drivers/cbus/retu-headset.c	2011-02-06 20:17:25.499999939 -0500
+++ maemo_src/drivers/cbus/retu-headset.c	2011-02-06 20:12:13.116666606 -0500
@@ -32,18 +32,16 @@
 
 #define RETU_HEADSET_KEY		KEY_PHONE
 
-#define STATE_DISABLE_DET		1
-#define STATE_ENABLE_DET		2
-
 struct retu_headset {
-	struct platform_device *pdev;
-	struct input_dev *idev;
-	unsigned bias_enabled:1;
-
-	unsigned detection_enabled:1, pressed:1;
-	int detection_state;
-	struct timer_list enable_timer, detect_timer;
-	spinlock_t lock;
+	spinlock_t			lock;
+	struct mutex			mutex;
+	struct platform_device		*pdev;
+	struct input_dev		*idev;
+	unsigned			bias_enabled;
+	unsigned			detection_enabled;
+	unsigned			pressed;
+	struct timer_list		enable_timer;
+	struct timer_list		detect_timer;
 };
 
 static void retu_headset_set_bias(int enable)
@@ -55,46 +53,58 @@
 		retu_set_clear_reg_bits(RETU_REG_AUDTXR, 1 << 3, 0);
 	} else {
 		retu_set_clear_reg_bits(RETU_REG_AUDTXR, 0,
-				    (1 << 0) | (1 << 1) | (1 << 3));
+					(1 << 0) | (1 << 1) | (1 << 3));
 	}
 }
 
 static void retu_headset_enable(struct retu_headset *hs)
 {
-	if (hs->bias_enabled)
-		return;
-	hs->bias_enabled = 1;
-	retu_headset_set_bias(1);
+	mutex_lock(&hs->mutex);
+	if (!hs->bias_enabled) {
+		hs->bias_enabled = 1;
+		retu_headset_set_bias(1);
+	}
+	mutex_unlock(&hs->mutex);
 }
 
 static void retu_headset_disable(struct retu_headset *hs)
 {
-	if (!hs->bias_enabled)
-		return;
-	hs->bias_enabled = 0;
-	retu_headset_set_bias(0);
+	mutex_lock(&hs->mutex);
+	if (hs->bias_enabled) {
+		hs->bias_enabled = 0;
+		retu_headset_set_bias(0);
+	}
+	mutex_unlock(&hs->mutex);
 }
 
 static void retu_headset_det_enable(struct retu_headset *hs)
 {
-	if (hs->detection_enabled)
-		return;
-	hs->detection_enabled = 1;
-	retu_set_clear_reg_bits(RETU_REG_CC1, (1 << 10) | (1 << 8), 0);
-	retu_enable_irq(RETU_INT_HOOK);
+	mutex_lock(&hs->mutex);
+	if (!hs->detection_enabled) {
+		hs->detection_enabled = 1;
+		retu_set_clear_reg_bits(RETU_REG_CC1, (1 << 10) | (1 << 8), 0);
+		retu_enable_irq(RETU_INT_HOOK);
+	}
+	mutex_unlock(&hs->mutex);
 }
 
 static void retu_headset_det_disable(struct retu_headset *hs)
 {
-	if (!hs->detection_enabled)
-		return;
-	hs->detection_enabled = 0;
-	retu_disable_irq(RETU_INT_HOOK);
-	del_timer_sync(&hs->enable_timer);
-	del_timer_sync(&hs->detect_timer);
-	if (hs->pressed)
-		input_report_key(hs->idev, RETU_HEADSET_KEY, 0);
-	retu_set_clear_reg_bits(RETU_REG_CC1, 0, (1 << 10) | (1 << 8));
+	unsigned long flags;
+
+	mutex_lock(&hs->mutex);
+	if (hs->detection_enabled) {
+		hs->detection_enabled = 0;
+		retu_disable_irq(RETU_INT_HOOK);
+		del_timer_sync(&hs->enable_timer);
+		del_timer_sync(&hs->detect_timer);
+		spin_lock_irqsave(&hs->lock, flags);
+		if (hs->pressed)
+			input_report_key(hs->idev, RETU_HEADSET_KEY, 0);
+		spin_unlock_irqrestore(&hs->lock, flags);
+		retu_set_clear_reg_bits(RETU_REG_CC1, 0, (1 << 10) | (1 << 8));
+	}
+	mutex_unlock(&hs->mutex);
 }
 
 static ssize_t retu_headset_hookdet_show(struct device *dev,
@@ -170,7 +180,6 @@
 {
 	struct retu_headset *hs = (struct retu_headset *) arg;
 	unsigned long flags;
-	int was_pressed = 0;
 
 	retu_ack_irq(RETU_INT_HOOK);
 	spin_lock_irqsave(&hs->lock, flags);
@@ -178,11 +187,8 @@
 		/* Headset button was just pressed down. */
 		hs->pressed = 1;
 		input_report_key(hs->idev, RETU_HEADSET_KEY, 1);
-		was_pressed = 1;
 	}
 	spin_unlock_irqrestore(&hs->lock, flags);
-	if (was_pressed)
-		dev_info(&hs->pdev->dev, "button pressed\n");
 	retu_set_clear_reg_bits(RETU_REG_CC1, 0, (1 << 10) | (1 << 8));
 	mod_timer(&hs->enable_timer, jiffies + msecs_to_jiffies(50));
 }
@@ -201,11 +207,11 @@
 	unsigned long flags;
 
 	spin_lock_irqsave(&hs->lock, flags);
-	BUG_ON(!hs->pressed);
-	input_report_key(hs->idev, RETU_HEADSET_KEY, 0);
-	hs->pressed = 0;
+	if (hs->pressed) {
+		hs->pressed = 0;
+		input_report_key(hs->idev, RETU_HEADSET_KEY, 0);
+	}
 	spin_unlock_irqrestore(&hs->lock, flags);
-	dev_info(&hs->pdev->dev, "button released\n");
 }
 
 static int __init retu_headset_probe(struct platform_device *pdev)
@@ -245,6 +251,7 @@
 	platform_set_drvdata(pdev, hs);
 
 	spin_lock_init(&hs->lock);
+	mutex_init(&hs->mutex);
 	setup_timer(&hs->enable_timer, retu_headset_enable_timer,
 		    (unsigned long) hs);
 	setup_timer(&hs->detect_timer, retu_headset_detect_timer,
@@ -288,17 +295,31 @@
 	return 0;
 }
 
-static int retu_headset_suspend(struct platform_device *pdev, pm_message_t mesg)
+static int retu_headset_suspend(struct platform_device *pdev,
+				pm_message_t mesg)
 {
+	struct retu_headset *hs = platform_get_drvdata(pdev);
+
+	mutex_lock(&hs->mutex);
+	if (hs->bias_enabled)
+		retu_headset_set_bias(0);
+	mutex_unlock(&hs->mutex);
+
 	return 0;
 }
 
 static int retu_headset_resume(struct platform_device *pdev)
 {
+	struct retu_headset *hs = platform_get_drvdata(pdev);
+
+	mutex_lock(&hs->mutex);
+	if (hs->bias_enabled)
+		retu_headset_set_bias(1);
+	mutex_unlock(&hs->mutex);
+
 	return 0;
 }
 
-
 static struct platform_driver retu_headset_driver = {
 	.probe		= retu_headset_probe,
 	.remove		= retu_headset_remove,
diff -ruN linux-omap-2.6/drivers/cbus/retu-rtc.c maemo_src/drivers/cbus/retu-rtc.c
--- linux-omap-2.6/drivers/cbus/retu-rtc.c	2011-02-06 20:17:25.499999939 -0500
+++ maemo_src/drivers/cbus/retu-rtc.c	2007-10-02 03:09:31.000000000 -0400
@@ -303,7 +303,7 @@
 static DEVICE_ATTR(cal, S_IRUGO | S_IWUSR, retu_rtc_cal_show,
 		   retu_rtc_cal_store);
 
-static struct device_driver retu_rtc_driver;
+static struct platform_driver retu_rtc_driver;
 
 static void retu_rtca_disable(void)
 {
@@ -316,7 +316,7 @@
 static void retu_rtca_expired(struct work_struct *unused)
 {
 	retu_rtca_disable();
-	sysfs_notify(&retu_rtc_driver.kobj, NULL, "alarm_expired");
+	sysfs_notify(&retu_rtc_driver.driver.kobj, NULL, "alarm_expired");
 }
 
 DECLARE_WORK(retu_rtca_work, retu_rtca_expired);
@@ -328,7 +328,7 @@
 static void retu_rtcs_interrupt(unsigned long unused)
 {
 	retu_ack_irq(RETU_INT_RTCS);
-	complete(&retu_rtc_sync);
+	complete_all(&retu_rtc_sync);
 }
 
 static void retu_rtca_interrupt(unsigned long unused)
@@ -361,15 +361,15 @@
 }
 
 
-static int __devinit retu_rtc_probe(struct device *dev)
+static int __init retu_rtc_probe(struct platform_device *pdev)
 {
-	int r;
+	int ret;
 
 	retu_rtc_alarm_expired = retu_read_reg(RETU_REG_IDR) &
 					       (0x1 << RETU_INT_RTCA);
 
-	if ((r = retu_rtc_init_irq()) != 0)
-		return r;
+	if ((ret = retu_rtc_init_irq()) != 0)
+		return ret;
 
 	mutex_init(&retu_rtc_mutex);
 
@@ -380,48 +380,58 @@
 	else
 		retu_rtc_do_reset();
 
-	if ((r = device_create_file(dev, &dev_attr_time)) != 0)
-		return r;
-	else if ((r = device_create_file(dev, &dev_attr_reset)) != 0)
+	ret = device_create_file(&pdev->dev, &dev_attr_time);
+	if (ret)
+		return ret;
+
+	ret = device_create_file(&pdev->dev, &dev_attr_reset);
+	if (ret)
 		goto err_unregister_time;
-	else if ((r = device_create_file(dev, &dev_attr_alarm)) != 0)
+
+	ret = device_create_file(&pdev->dev, &dev_attr_alarm);
+	if (ret)
 		goto err_unregister_reset;
-	else if ((r = device_create_file(dev, &dev_attr_alarm_expired)) != 0)
+
+	ret = device_create_file(&pdev->dev, &dev_attr_alarm_expired);
+	if (ret)
 		goto err_unregister_alarm;
-	else if ((r = device_create_file(dev, &dev_attr_cal)) != 0)
+
+	ret = device_create_file(&pdev->dev, &dev_attr_cal);
+	if (ret)
 		goto err_unregister_alarm_expired;
-	else
-		return r;
+
+	return ret;
 
 err_unregister_alarm_expired:
-	device_remove_file(dev, &dev_attr_alarm_expired);
+	device_remove_file(&pdev->dev, &dev_attr_alarm_expired);
 err_unregister_alarm:
-	device_remove_file(dev, &dev_attr_alarm);
+	device_remove_file(&pdev->dev, &dev_attr_alarm);
 err_unregister_reset:
-	device_remove_file(dev, &dev_attr_reset);
+	device_remove_file(&pdev->dev, &dev_attr_reset);
 err_unregister_time:
-	device_remove_file(dev, &dev_attr_time);
-	return r;
+	device_remove_file(&pdev->dev, &dev_attr_time);
+	return ret;
 }
 
-static int __devexit retu_rtc_remove(struct device *dev)
+static int __devexit retu_rtc_remove(struct platform_device *pdev)
 {
 	retu_disable_irq(RETU_INT_RTCS);
 	retu_free_irq(RETU_INT_RTCS);
 	retu_free_irq(RETU_INT_RTCA);
-	device_remove_file(dev, &dev_attr_cal);
-	device_remove_file(dev, &dev_attr_alarm_expired);
-	device_remove_file(dev, &dev_attr_alarm);
-	device_remove_file(dev, &dev_attr_reset);
-	device_remove_file(dev, &dev_attr_time);
+	device_remove_file(&pdev->dev, &dev_attr_cal);
+	device_remove_file(&pdev->dev, &dev_attr_alarm_expired);
+	device_remove_file(&pdev->dev, &dev_attr_alarm);
+	device_remove_file(&pdev->dev, &dev_attr_reset);
+	device_remove_file(&pdev->dev, &dev_attr_time);
 	return 0;
 }
 
-static struct device_driver retu_rtc_driver = {
-	.name		= "retu-rtc",
-	.bus		= &platform_bus_type,
+static struct platform_driver retu_rtc_driver = {
 	.probe		= retu_rtc_probe,
-	.remove		= __devexit_p(retu_rtc_remove),
+	.remove		= retu_rtc_remove,
+	.driver = {
+		.name		= "retu-rtc",
+	},
 };
 
 static struct platform_device retu_rtc_device = {
@@ -435,7 +445,7 @@
 /* This function provides syncronization with the RTCS interrupt handler */
 static void retu_rtc_barrier(void)
 {
-	init_completion(&retu_rtc_sync);
+	INIT_COMPLETION(retu_rtc_sync);
 	retu_ack_irq(RETU_INT_RTCS);
 	retu_enable_irq(RETU_INT_RTCS);
 	wait_for_completion(&retu_rtc_sync);
@@ -448,23 +458,24 @@
 
 	init_completion(&retu_rtc_exited);
 
-	if ((ret = driver_register(&retu_rtc_driver)) != 0)
+	ret = platform_driver_register(&retu_rtc_driver);
+	if (ret)
 		return ret;
-
-	if ((ret = platform_device_register(&retu_rtc_device)) != 0)
+	ret = platform_device_register(&retu_rtc_device);
+	if (ret)
 		goto err_unregister_driver;
 
 	return 0;
 
 err_unregister_driver:
-	driver_unregister(&retu_rtc_driver);
+	platform_driver_unregister(&retu_rtc_driver);
 	return ret;
 }
 
 static void __exit retu_rtc_exit(void)
 {
 	platform_device_unregister(&retu_rtc_device);
-	driver_unregister(&retu_rtc_driver);
+	platform_driver_unregister(&retu_rtc_driver);
 
 	wait_for_completion(&retu_rtc_exited);
 }
diff -ruN linux-omap-2.6/drivers/cbus/retu-wdt.c maemo_src/drivers/cbus/retu-wdt.c
--- linux-omap-2.6/drivers/cbus/retu-wdt.c	2011-02-06 20:17:25.499999939 -0500
+++ maemo_src/drivers/cbus/retu-wdt.c	2007-10-02 03:09:31.000000000 -0400
@@ -102,29 +102,29 @@
                    retu_wdt_period_store);
 static DEVICE_ATTR(counter, S_IRUGO, retu_wdt_counter_show, NULL);
 
-static int __devinit retu_wdt_probe(struct device *dev)
+static int __init retu_wdt_probe(struct platform_device *pdev)
 {
 	int ret;
 
-	ret = device_create_file(dev, &dev_attr_period);
+	ret = device_create_file(&pdev->dev, &dev_attr_period);
 	if (ret) {
 		printk(KERN_ERR "retu_wdt_probe: Error creating sys device file: period\n");
 		return ret;
 	}
 
-	ret = device_create_file(dev, &dev_attr_counter);
+	ret = device_create_file(&pdev->dev, &dev_attr_counter);
 	if (ret) {
-		device_remove_file(dev, &dev_attr_period);
+		device_remove_file(&pdev->dev, &dev_attr_period);
 		printk(KERN_ERR "retu_wdt_probe: Error creating sys device file: counter\n");
 	}
 
 	return ret;
 }
 
-static int __devexit retu_wdt_remove(struct device *dev)
+static int retu_wdt_remove(struct platform_device *pdev)
 {
-	device_remove_file(dev, &dev_attr_period);
-	device_remove_file(dev, &dev_attr_counter);
+	device_remove_file(&pdev->dev, &dev_attr_period);
+	device_remove_file(&pdev->dev, &dev_attr_counter);
 	return 0;
 }
 
@@ -141,11 +141,12 @@
 	},
 };
 
-static struct device_driver retu_wdt_driver = {
-	.name = "retu-watchdog",
-	.bus = &platform_bus_type,
-	.probe = retu_wdt_probe,
-	.remove = __devexit_p(retu_wdt_remove),
+static struct platform_driver retu_wdt_driver = {
+	.probe	= retu_wdt_probe,
+	.remove = retu_wdt_remove,
+	.driver	= {
+		.name = "retu-watchdog",
+	},
 };
 
 static int __init retu_wdt_init(void)
@@ -154,7 +155,7 @@
 
 	init_completion(&retu_wdt_completion);
 
-	ret = driver_register(&retu_wdt_driver);
+	ret = platform_driver_register(&retu_wdt_driver);
 	if (ret)
 		return ret;
 
@@ -174,7 +175,7 @@
 	return ret;
 
 exit1:
-	driver_unregister(&retu_wdt_driver);
+	platform_driver_unregister(&retu_wdt_driver);
 	wait_for_completion(&retu_wdt_completion);
 
 	return ret;
@@ -183,7 +184,7 @@
 static void __exit retu_wdt_exit(void)
 {
 	platform_device_unregister(&retu_wdt_device);
-	driver_unregister(&retu_wdt_driver);
+	platform_driver_unregister(&retu_wdt_driver);
 
 	wait_for_completion(&retu_wdt_completion);
 }
diff -ruN linux-omap-2.6/drivers/cbus/tahvo.c maemo_src/drivers/cbus/tahvo.c
--- linux-omap-2.6/drivers/cbus/tahvo.c	2011-02-06 20:17:25.499999939 -0500
+++ maemo_src/drivers/cbus/tahvo.c	2007-10-02 03:09:31.000000000 -0400
@@ -286,7 +286,7 @@
  * Probe for the Tahvo ASIC and allocate memory
  * for its device-struct if found
  */
-static int __devinit tahvo_probe(struct device *dev)
+static int __init tahvo_probe(struct platform_device *pdev)
 {
 	const struct omap_em_asic_bb5_config * em_asic_config;
 	int rev, id, ret;
@@ -355,7 +355,7 @@
 	return 0;
 }
 
-static int tahvo_remove(struct device *dev)
+static int tahvo_remove(struct platform_device *pdev)
 {
 #ifdef CONFIG_CBUS_TAHVO_USER
 	tahvo_user_cleanup();
@@ -374,11 +374,12 @@
 	complete(&device_release);
 }
 
-static struct device_driver tahvo_driver = {
-	.name		= "tahvo",
-	.bus		= &platform_bus_type,
+static struct platform_driver tahvo_driver = {
 	.probe		= tahvo_probe,
 	.remove		= tahvo_remove,
+	.driver = {
+		.name		= "tahvo",
+	}
 };
 
 static struct platform_device tahvo_device = {
@@ -402,11 +403,11 @@
 
 	init_completion(&device_release);
 
-	if ((ret = driver_register(&tahvo_driver)) < 0)
+	if ((ret = platform_driver_register(&tahvo_driver)) < 0)
 		return ret;
 
 	if ((ret = platform_device_register(&tahvo_device)) < 0) {
-		driver_unregister(&tahvo_driver);
+		platform_driver_unregister(&tahvo_driver);
 		return ret;
 	}
 	return 0;
@@ -418,7 +419,7 @@
 static void __exit tahvo_exit(void)
 {
 	platform_device_unregister(&tahvo_device);
-	driver_unregister(&tahvo_driver);
+	platform_driver_unregister(&tahvo_driver);
 	wait_for_completion(&device_release);
 }
 
diff -ruN linux-omap-2.6/drivers/cbus/tahvo-usb.c maemo_src/drivers/cbus/tahvo-usb.c
--- linux-omap-2.6/drivers/cbus/tahvo-usb.c	2011-02-06 20:17:25.499999939 -0500
+++ maemo_src/drivers/cbus/tahvo-usb.c	2007-10-02 03:09:31.000000000 -0400
@@ -176,11 +176,11 @@
 	return 0;
 }
 
-static int omap_otg_probe(struct device *dev)
+static int omap_otg_probe(struct platform_device *pdev)
 {
 	int ret;
 
-	tahvo_otg_dev = to_platform_device(dev);
+	tahvo_otg_dev = pdev;
 	ret = omap_otg_init();
 	if (ret != 0) {
 		printk(KERN_ERR "tahvo-usb: omap_otg_init failed\n");
@@ -609,19 +609,19 @@
 static DEVICE_ATTR(otg_mode, 0644, otg_mode_show, otg_mode_store);
 #endif
 
-static int tahvo_usb_probe(struct device *dev)
+static int tahvo_usb_probe(struct platform_device *pdev)
 {
 	struct tahvo_usb *tu;
 	int ret;
 
-	dev_dbg(dev, "probe\n");
+	dev_dbg(pdev, "probe\n");
 
 	/* Create driver data */
 	tu = kmalloc(sizeof(*tu), GFP_KERNEL);
 	if (!tu)
 		return -ENOMEM;
 	memset(tu, 0, sizeof(*tu));
-	tu->pt_dev = container_of(dev, struct platform_device, dev);
+	tu->pt_dev = pdev;
 #ifdef CONFIG_USB_OTG
 	/* Default mode */
 #ifdef CONFIG_CBUS_TAHVO_USB_HOST_BY_DEFAULT
@@ -648,9 +648,9 @@
 	}
 
 	/* Attributes */
-	ret = device_create_file(dev, &dev_attr_vbus_state);
+	ret = device_create_file(&pdev->dev, &dev_attr_vbus_state);
 #ifdef CONFIG_USB_OTG
-	ret |= device_create_file(dev, &dev_attr_otg_mode);
+	ret |= device_create_file(&pdev->dev, &dev_attr_otg_mode);
 #endif
 	if (ret)
 		printk(KERN_ERR "attribute creation failed: %d\n", ret);
@@ -682,25 +682,26 @@
 	return 0;
 }
 
-static int tahvo_usb_remove(struct device *dev)
+static int tahvo_usb_remove(struct plaform_device *pdev)
 {
-	dev_dbg(dev, "remove\n");
+	dev_dbg(pdev, "remove\n");
 
 	tahvo_free_irq(TAHVO_INT_VBUSON);
 	flush_scheduled_work();
 	otg_set_transceiver(0);
-	device_remove_file(dev, &dev_attr_vbus_state);
+	device_remove_file(&pdev->dev, &dev_attr_vbus_state);
 #ifdef CONFIG_USB_OTG
-	device_remove_file(dev, &dev_attr_otg_mode);
+	device_remove_file(&pdev->dev, &dev_attr_otg_mode);
 #endif
 	return 0;
 }
 
-static struct device_driver tahvo_usb_driver = {
-	.name		= "tahvo-usb",
-	.bus		= &platform_bus_type,
+static struct platform_driver tahvo_usb_driver = {
 	.probe		= tahvo_usb_probe,
 	.remove		= tahvo_usb_remove,
+	.driver = {
+		.name		= "tahvo-usb",
+	},
 };
 
 static struct platform_device tahvo_usb_device = {
@@ -713,18 +714,18 @@
 	int ret = 0;
 
 	printk(KERN_INFO "Tahvo USB transceiver driver initializing\n");
-	ret = driver_register(&tahvo_usb_driver);
+	ret = platform_driver_register(&tahvo_usb_driver);
 	if (ret)
 		return ret;
 	ret = platform_device_register(&tahvo_usb_device);
 	if (ret < 0) {
-		driver_unregister(&tahvo_usb_driver);
+		platform_driver_unregister(&tahvo_usb_driver);
 		return ret;
 	}
 	ret = driver_register(&omap_otg_driver);
 	if (ret) {
 		platform_device_unregister(&tahvo_usb_device);
-		driver_unregister(&tahvo_usb_driver);
+		platform_driver_unregister(&tahvo_usb_driver);
 		return ret;
 	}
 	return 0;
@@ -734,9 +735,9 @@
 
 static void __exit tahvo_usb_exit(void)
 {
-	driver_unregister(&omap_otg_driver);
+	platform_driver_unregister(&omap_otg_driver);
 	platform_device_unregister(&tahvo_usb_device);
-	driver_unregister(&tahvo_usb_driver);
+	platform_driver_unregister(&tahvo_usb_driver);
 }
 module_exit(tahvo_usb_exit);
 
diff -ruN linux-omap-2.6/drivers/char/random.c maemo_src/drivers/char/random.c
--- linux-omap-2.6/drivers/char/random.c	2011-02-06 19:44:46.056666606 -0500
+++ maemo_src/drivers/char/random.c	2011-02-06 20:12:12.489999938 -0500
@@ -1022,37 +1022,44 @@
 	return mask;
 }
 
-static ssize_t
-random_write(struct file * file, const char __user * buffer,
-	     size_t count, loff_t *ppos)
+static int
+write_pool(struct entropy_store *r, const char __user *buffer, size_t count)
 {
-	int ret = 0;
 	size_t bytes;
 	__u32 buf[16];
 	const char __user *p = buffer;
-	size_t c = count;
 
-	while (c > 0) {
-		bytes = min(c, sizeof(buf));
+	while (count > 0) {
+		bytes = min(count, sizeof(buf));
+		if (copy_from_user(&buf, p, bytes))
+			return -EFAULT;
 
-		bytes -= copy_from_user(&buf, p, bytes);
-		if (!bytes) {
-			ret = -EFAULT;
-			break;
-		}
-		c -= bytes;
+		count -= bytes;
 		p += bytes;
 
-		add_entropy_words(&input_pool, buf, (bytes + 3) / 4);
-	}
-	if (p == buffer) {
-		return (ssize_t)ret;
-	} else {
-		struct inode *inode = file->f_path.dentry->d_inode;
-	        inode->i_mtime = current_fs_time(inode->i_sb);
-		mark_inode_dirty(inode);
-		return (ssize_t)(p - buffer);
+		add_entropy_words(r, buf, (bytes + 3) / 4);
 	}
+
+	return 0;
+}
+
+static ssize_t
+random_write(struct file * file, const char __user * buffer,
+	     size_t count, loff_t *ppos)
+{
+	size_t ret;
+	struct inode *inode = file->f_path.dentry->d_inode;
+
+	ret = write_pool(&blocking_pool, buffer, count);
+	if (ret)
+		return ret;
+	ret = write_pool(&nonblocking_pool, buffer, count);
+	if (ret)
+		return ret;
+
+	inode->i_mtime = current_fs_time(inode->i_sb);
+	mark_inode_dirty(inode);
+	return (ssize_t)count;
 }
 
 static int
@@ -1091,8 +1098,8 @@
 			return -EINVAL;
 		if (get_user(size, p++))
 			return -EFAULT;
-		retval = random_write(file, (const char __user *) p,
-				      size, &file->f_pos);
+		retval = write_pool(&input_pool, (const char __user *)p,
+				    size);
 		if (retval < 0)
 			return retval;
 		credit_entropy_store(&input_pool, ent_count);
@@ -1460,6 +1467,7 @@
 
 static __init int seqgen_init(void)
 {
+	INIT_DELAYED_WORK_DEFERRABLE(&rekey_work, rekey_seq_generator);
 	rekey_seq_generator(NULL);
 	return 0;
 }
diff -ruN linux-omap-2.6/drivers/cpufreq/cpufreq.c maemo_src/drivers/cpufreq/cpufreq.c
--- linux-omap-2.6/drivers/cpufreq/cpufreq.c	2011-02-06 19:44:46.179999939 -0500
+++ maemo_src/drivers/cpufreq/cpufreq.c	2007-10-02 03:09:31.000000000 -0400
@@ -390,6 +390,14 @@
 						CPUFREQ_NAME_LEN)) {
 			*policy = CPUFREQ_POLICY_POWERSAVE;
 			err = 0;
+		} else if (!strnicmp(str_governor, "null",
+						CPUFREQ_NAME_LEN)) {
+			*policy = CPUFREQ_POLICY_NULL;
+			err = 0;
+		} else if (!strnicmp(str_governor, "userspace",
+						CPUFREQ_NAME_LEN)) {
+			*policy = CPUFREQ_POLICY_USERSPACE;
+			err = 0;
 		}
 	} else if (cpufreq_driver->target) {
 		struct cpufreq_governor *t;
diff -ruN linux-omap-2.6/drivers/cpufreq/cpufreq_null.c maemo_src/drivers/cpufreq/cpufreq_null.c
--- linux-omap-2.6/drivers/cpufreq/cpufreq_null.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/cpufreq/cpufreq_null.c	2011-02-06 20:12:12.519999938 -0500
@@ -0,0 +1,65 @@
+/*
+ * File: linux/drivers/cpufreq/cpufreq_null.c
+ *
+ * Copyright (C) 2007 Nokia Corporation.
+ *
+ * Contact: Klaus Pedersen <klaus.k.pedersen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */  
+
+/*
+ * The "null" governor is meant to be used as default during boot until
+ * a proper governor is set from userspace.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/cpufreq.h>
+#include <linux/init.h>
+
+#define dprintk(msg...) \
+	cpufreq_debug_printk(CPUFREQ_DEBUG_GOVERNOR, "null", msg)
+
+static int cpufreq_governor_null(struct cpufreq_policy *policy,
+                                 unsigned int event)
+{
+	return 0;
+}
+
+struct cpufreq_governor cpufreq_gov_null = {
+	.name		= "null",
+	.governor	= cpufreq_governor_null,
+	.owner		= THIS_MODULE,
+};
+EXPORT_SYMBOL(cpufreq_gov_null);
+
+static int __init cpufreq_gov_null_init(void)
+{
+	return cpufreq_register_governor(&cpufreq_gov_null);
+}
+
+static void __exit cpufreq_gov_null_exit(void)
+{
+	cpufreq_unregister_governor(&cpufreq_gov_null);
+}
+
+MODULE_AUTHOR("Klaus Pedersen <klaus.k.pedersen@nokia.com");
+MODULE_DESCRIPTION("CPUfreq policy governor 'null'");
+MODULE_LICENSE("GPL");
+
+fs_initcall(cpufreq_gov_null_init);
+module_exit(cpufreq_gov_null_exit);
diff -ruN linux-omap-2.6/drivers/cpufreq/cpufreq_ondemand.c maemo_src/drivers/cpufreq/cpufreq_ondemand.c
--- linux-omap-2.6/drivers/cpufreq/cpufreq_ondemand.c	2011-02-06 19:44:46.183333272 -0500
+++ maemo_src/drivers/cpufreq/cpufreq_ondemand.c	2007-10-02 03:09:31.000000000 -0400
@@ -470,7 +470,7 @@
 	dbs_info->enable = 1;
 	ondemand_powersave_bias_init();
 	dbs_info->sample_type = DBS_NORMAL_SAMPLE;
-	INIT_DELAYED_WORK(&dbs_info->work, do_dbs_timer);
+	INIT_DELAYED_WORK_DEFERRABLE(&dbs_info->work, do_dbs_timer);
 	queue_delayed_work_on(dbs_info->cpu, kondemand_wq, &dbs_info->work,
 	                      delay);
 }
diff -ruN linux-omap-2.6/drivers/cpufreq/cpufreq_powersave.c maemo_src/drivers/cpufreq/cpufreq_powersave.c
--- linux-omap-2.6/drivers/cpufreq/cpufreq_powersave.c	2011-02-06 19:44:46.183333272 -0500
+++ maemo_src/drivers/cpufreq/cpufreq_powersave.c	2007-10-02 03:09:31.000000000 -0400
@@ -35,12 +35,12 @@
 	return 0;
 }
 
-static struct cpufreq_governor cpufreq_gov_powersave = {
+struct cpufreq_governor cpufreq_gov_powersave = {
 	.name		= "powersave",
 	.governor	= cpufreq_governor_powersave,
 	.owner		= THIS_MODULE,
 };
-
+EXPORT_SYMBOL(cpufreq_gov_powersave);
 
 static int __init cpufreq_gov_powersave_init(void)
 {
@@ -58,5 +58,5 @@
 MODULE_DESCRIPTION("CPUfreq policy governor 'powersave'");
 MODULE_LICENSE("GPL");
 
-module_init(cpufreq_gov_powersave_init);
+fs_initcall(cpufreq_gov_powersave_init);
 module_exit(cpufreq_gov_powersave_exit);
diff -ruN linux-omap-2.6/drivers/cpufreq/Kconfig maemo_src/drivers/cpufreq/Kconfig
--- linux-omap-2.6/drivers/cpufreq/Kconfig	2011-02-06 19:44:46.176666606 -0500
+++ maemo_src/drivers/cpufreq/Kconfig	2007-10-02 03:09:31.000000000 -0400
@@ -66,6 +66,21 @@
 	  the frequency statically to the highest frequency supported by
 	  the CPU.
 
+config CPU_FREQ_DEFAULT_GOV_POWERSAVE
+	bool "powersave"
+	select CPU_FREQ_GOV_POWERSAVE
+	help
+	  Use the CPUFreq governor 'powersave' as default. This sets
+	  the frequency statically to the lowest frequency supported by
+	  the CPU.
+
+config CPU_FREQ_DEFAULT_GOV_NULL
+	bool "null"
+	select CPU_FREQ_GOV_NULL
+	help
+	  Use the CPUFreq governor 'null' as default. This tries hard
+	  to not change the frequency.
+
 config CPU_FREQ_DEFAULT_GOV_USERSPACE
 	bool "userspace"
 	select CPU_FREQ_GOV_USERSPACE
@@ -93,6 +108,13 @@
 
 	  If in doubt, say Y.
 
+config CPU_FREQ_GOV_NULL
+       tristate "'null' governor"
+       help
+	  This cpufreq governor tries hard not to change the frequency.
+
+	  If in doubt, say N.
+
 config CPU_FREQ_GOV_USERSPACE
        tristate "'userspace' governor for userspace frequency scaling"
        help
diff -ruN linux-omap-2.6/drivers/cpufreq/Makefile maemo_src/drivers/cpufreq/Makefile
--- linux-omap-2.6/drivers/cpufreq/Makefile	2011-02-06 19:37:51.599999939 -0500
+++ maemo_src/drivers/cpufreq/Makefile	2007-10-02 03:09:31.000000000 -0400
@@ -9,6 +9,7 @@
 obj-$(CONFIG_CPU_FREQ_GOV_USERSPACE)	+= cpufreq_userspace.o
 obj-$(CONFIG_CPU_FREQ_GOV_ONDEMAND)	+= cpufreq_ondemand.o
 obj-$(CONFIG_CPU_FREQ_GOV_CONSERVATIVE)	+= cpufreq_conservative.o
+obj-$(CONFIG_CPU_FREQ_GOV_NULL)		+= cpufreq_null.o
 
 # CPUfreq cross-arch helpers
 obj-$(CONFIG_CPU_FREQ_TABLE)		+= freq_table.o
diff -ruN linux-omap-2.6/drivers/hid/hid-input.c maemo_src/drivers/hid/hid-input.c
--- linux-omap-2.6/drivers/hid/hid-input.c	2011-02-06 19:44:46.653333274 -0500
+++ maemo_src/drivers/hid/hid-input.c	2007-10-02 03:09:31.000000000 -0400
@@ -672,6 +672,9 @@
 			 usage->type == EV_ABS))
 		clear_bit(usage->code, bit);
 
+	if (device->quirks & HID_QUIRK_SU_8W)
+		field->logical_maximum = 119;
+
 	while (usage->code <= max && test_and_set_bit(usage->code, bit))
 		usage->code = find_next_zero_bit(bit, max + 1, usage->code);
 
diff -ruN linux-omap-2.6/drivers/hwmon/Kconfig maemo_src/drivers/hwmon/Kconfig
--- linux-omap-2.6/drivers/hwmon/Kconfig	2011-02-06 19:44:46.656666607 -0500
+++ maemo_src/drivers/hwmon/Kconfig	2007-10-02 03:09:31.000000000 -0400
@@ -458,6 +458,13 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called smsc47b397.
 
+config SENSORS_TMP105
+	bool "Texas Instruments TMP105"
+	depends on HWMON && I2C
+	help
+	  If you say yes here you get support for the TI TMP105
+	  sensor chip.
+
 config SENSORS_VIA686A
 	tristate "VIA686A"
 	depends on HWMON && I2C && PCI
diff -ruN linux-omap-2.6/drivers/hwmon/Makefile maemo_src/drivers/hwmon/Makefile
--- linux-omap-2.6/drivers/hwmon/Makefile	2011-02-06 19:44:46.656666607 -0500
+++ maemo_src/drivers/hwmon/Makefile	2007-10-02 03:09:31.000000000 -0400
@@ -49,6 +49,7 @@
 obj-$(CONFIG_SENSORS_SMSC47B397)+= smsc47b397.o
 obj-$(CONFIG_SENSORS_SMSC47M1)	+= smsc47m1.o
 obj-$(CONFIG_SENSORS_SMSC47M192)+= smsc47m192.o
+obj-$(CONFIG_SENSORS_TMP105)	+= tmp105.o
 obj-$(CONFIG_SENSORS_VIA686A)	+= via686a.o
 obj-$(CONFIG_SENSORS_VT1211)	+= vt1211.o
 obj-$(CONFIG_SENSORS_VT8231)	+= vt8231.o
diff -ruN linux-omap-2.6/drivers/hwmon/tmp105.c maemo_src/drivers/hwmon/tmp105.c
--- linux-omap-2.6/drivers/hwmon/tmp105.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/hwmon/tmp105.c	2007-10-02 03:09:31.000000000 -0400
@@ -0,0 +1,537 @@
+/*
+ * drivers/hwmon/tmp105.c
+ *
+ * TMP105 temperature sensor chip driver
+ *
+ * Copyright (C) 2006 Nokia Corporation
+ * Mikko Ylinen <mikko.k.ylinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/hwmon.h>
+#include <linux/sysfs.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/gpio.h>
+#include <asm/arch/board.h>
+
+#define DRIVER_NAME			"tmp105"
+
+#define TMP105_I2C_ADDRESS		0x48
+
+#define TMP105_TEMPERATURE_MAX		2000
+#define TMP105_TEMPERATURE_CRITICAL	1280
+#define TMP105_TEMPERATURE_CRIT_HYST	1200
+
+#define TMP105_REG_TEMPERATURE		0 /* RO */
+#define TMP105_REG_CONFIGURATION	1 /* RW */
+#define TMP105_REG_TLOW			2 /* RW */
+#define TMP105_REG_THIGH		3 /* RW */
+
+#define TMP105_BIT_SD			(1 << 0) /* shutdown mode */
+#define TMP105_BIT_TM			(1 << 1) /* thermostat mode */
+#define TMP105_BIT_POL			(1 << 2) /* polarity */
+#define TMP105_BIT_F0			(1 << 3) /* fault queue bit 1 */
+#define TMP105_BIT_F1			(1 << 4) /* fault queue bit 2 */
+#define TMP105_BIT_R0			(1 << 5) /* ADC resolution bit 1 */
+#define TMP105_BIT_R1			(1 << 6) /* ADC resolution bit 2 */
+#define TMP105_BIT_OS			(1 << 7) /* one shot */
+
+#define TMP105_INIT_BITS		0x36	 /* R0 | F1 | TM | POL */
+
+#define temp2reg(x) ((u16)((((x) & 0xf) << 8) | (((x) & 0xff0) >> 4)))
+#define reg2temp(x) ((signed short)(((x) >> 8) | (((x) & 0xff) << 8)) >> 4)
+
+static unsigned short normal_i2c[] = { TMP105_I2C_ADDRESS, I2C_CLIENT_END };
+
+I2C_CLIENT_INSMOD;
+
+struct tmp105_data {
+	struct i2c_client	client;
+	struct class_device	*class_dev;
+	struct work_struct	work;
+	unsigned short		irq_pin;
+};
+
+static int tmp105_detach_client(struct i2c_client *client);
+static int tmp105_attach_adapter(struct i2c_adapter *bus);
+
+static inline int tmp105_write_reg8(struct i2c_client *client, int reg,
+				    u8 val)
+{
+	return i2c_smbus_write_byte_data(client, reg, val);
+}
+
+static inline int tmp105_write_reg(struct i2c_client *client, int reg,
+				   u16 val)
+{
+	return i2c_smbus_write_word_data(client, reg, val);
+}
+
+static int tmp105_read_reg(struct i2c_client *client, int reg)
+{
+	int val = i2c_smbus_read_word_data(client, reg);
+	if (val < 0)
+		dev_err(&client->dev, "%s failed\n", __FUNCTION__);
+
+	return val;
+}
+
+static int tmp105_read_temperature(struct i2c_client *client, int *temp)
+{
+	int val;
+
+	val = tmp105_read_reg(client, TMP105_REG_TEMPERATURE);
+	if (val < 0)
+		return val;
+
+	*temp = reg2temp(val);
+
+	return 0;
+}
+
+static int tmp105_is_hot(struct i2c_client *client)
+{
+	int temp, ret;
+
+	ret = tmp105_read_temperature(client, &temp);
+	if (ret < 0)
+		return ret;
+
+	ret = tmp105_read_reg(client, TMP105_REG_THIGH);
+	if (ret < 0)
+		return ret;
+
+	return temp >= reg2temp(ret);
+}
+
+static ssize_t tmp105_temp1_crit_show(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int val;
+
+	val = tmp105_read_reg(client, TMP105_REG_THIGH);
+	if (val < 0)
+		return -EAGAIN;
+
+	return sprintf(buf, "%d\n", (reg2temp(val) * 1000) / 16);
+}
+
+static ssize_t tmp105_temp1_crit_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int high, ret;
+
+	ret = sscanf(buf, "%d", &high);
+	if (ret != 1)
+		return -EINVAL;
+
+	high = (high * 16) / 1000;
+
+	ret = tmp105_read_reg(client, TMP105_REG_TLOW);
+	if (ret < 0)
+		return -EAGAIN;
+
+	if ((high <= reg2temp(ret)) || (high > TMP105_TEMPERATURE_MAX))
+		return -EINVAL;
+
+	ret = tmp105_write_reg(client, TMP105_REG_THIGH, temp2reg(high));
+	if (ret < 0)
+		return -EAGAIN;
+
+	return count;
+}
+
+static DEVICE_ATTR(temp1_crit, S_IRUGO | S_IWUSR, tmp105_temp1_crit_show,
+						  tmp105_temp1_crit_store);
+
+static ssize_t tmp105_temp1_crit_hyst_show(struct device *dev,
+					   struct device_attribute *attr,
+					   char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int val;
+
+	val = tmp105_read_reg(client, TMP105_REG_TLOW);
+	if (val < 0)
+		return -EAGAIN;
+
+	return sprintf(buf, "%d\n", (reg2temp(val)/ 16) * 1000);
+}
+
+static ssize_t tmp105_temp1_crit_hyst_store(struct device *dev,
+					    struct device_attribute *attr,
+					    const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int low, ret;
+
+	ret = sscanf(buf, "%d", &low);
+	if (ret != 1)
+		return -EINVAL;
+
+	low = (low * 16) / 1000;
+
+	ret = tmp105_read_reg(client, TMP105_REG_THIGH);
+	if (ret < 0)
+		return -EAGAIN;
+
+	if (low >= reg2temp(ret))
+		return -EINVAL;
+
+	ret = tmp105_write_reg(client, TMP105_REG_TLOW, temp2reg(low));
+	if (ret < 0)
+		return -EAGAIN;
+
+	return count;
+}
+
+static DEVICE_ATTR(temp1_crit_hyst, S_IRUGO | S_IWUSR,
+		   tmp105_temp1_crit_hyst_show, tmp105_temp1_crit_hyst_store);
+
+static ssize_t tmp105_temp1_input_show(struct device *dev,
+				       struct device_attribute *attr,
+				       char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int temp, ret;
+
+	ret = tmp105_read_temperature(client, &temp);
+	if (ret < 0)
+		return -EAGAIN;
+
+	return sprintf(buf, "%d\n", (temp * 1000) / 16);
+}
+
+DEVICE_ATTR(temp1_input, S_IRUGO, tmp105_temp1_input_show, NULL);
+
+static ssize_t tmp105_temp1_crit_alarm_show(struct device *dev,
+				  struct device_attribute *attr,
+				  char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int ret;
+
+	ret = tmp105_is_hot(client);
+	if (ret < 0)
+		return -EAGAIN;
+
+	return sprintf(buf, "%d\n", ret);
+}
+
+DEVICE_ATTR(temp1_crit_alarm, S_IRUGO, tmp105_temp1_crit_alarm_show, NULL);
+
+static inline int tmp105_create_sysfs_files(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	int err;
+
+	err = device_create_file(dev, &dev_attr_temp1_crit);
+	if (unlikely(err != 0))
+		return err;
+
+	err = device_create_file(dev, &dev_attr_temp1_crit_hyst);
+	if (unlikely(err != 0))
+		goto fail1;
+
+	err = device_create_file(dev, &dev_attr_temp1_input);
+	if (unlikely(err != 0))
+		goto fail2;
+
+	err = device_create_file(dev, &dev_attr_temp1_crit_alarm);
+	if (unlikely(err != 0))
+		goto fail3;
+
+	return 0;
+
+fail3:
+	device_remove_file(dev, &dev_attr_temp1_input);
+fail2:
+	device_remove_file(dev, &dev_attr_temp1_crit_hyst);
+fail1:
+	device_remove_file(dev, &dev_attr_temp1_crit);
+
+	return err;
+}
+
+static void tmp105_work(struct work_struct *ws)
+{
+	struct tmp105_data *t = container_of(ws, struct tmp105_data, work);
+	struct i2c_client *client = &t->client;
+
+	/* unconditionally notify userland about alarm */
+	sysfs_notify(&client->dev.kobj, NULL, "temp1_crit_alarm");
+
+	return;
+}
+
+static irqreturn_t tmp105_irq_handler(int irq, void *chip)
+{
+	struct tmp105_data *data = chip;
+
+	(void)schedule_work(&data->work);
+
+	return IRQ_HANDLED;
+}
+
+#if CONFIG_ARCH_OMAP
+
+static int tmp105_powered;
+
+static int tmp105_dev_power(int power)
+{
+	const struct omap_tmp105_config *info;
+	int err;
+
+	info = omap_get_config(OMAP_TAG_TMP105, struct omap_tmp105_config);
+	if (info == NULL || info->set_power == NULL || tmp105_powered == power)
+		return 0;
+	err = info->set_power(power);
+	if (err < 0)
+		return err;
+	tmp105_powered = power;
+	return 0;
+}
+
+static int tmp105_dev_init(void *data)
+{
+	struct tmp105_data *chip = data;
+	const struct omap_tmp105_config *info;
+	int err;
+
+	info = omap_get_config(OMAP_TAG_TMP105, struct omap_tmp105_config);
+	if (info == NULL)
+		return 0;
+
+	chip->irq_pin = info->tmp105_irq_pin;
+
+	err = omap_request_gpio(chip->irq_pin);
+	if (err < 0) {
+		printk(KERN_ERR "couldn't get IRQ pin\n");
+		return err;
+	}
+
+	/* tmp105 gives an interrupt if temperature oversteps defined
+	 * range. Reserve a GPIO line and register a handler for tmp105
+	 * interrupts. */
+	omap_set_gpio_direction(chip->irq_pin, 1);
+
+	err = request_irq(OMAP_GPIO_IRQ(chip->irq_pin), tmp105_irq_handler,
+			  IRQF_TRIGGER_RISING, DRIVER_NAME, chip);
+	if (err < 0) {
+		printk(KERN_ERR "unable to register IRQ handler\n");
+		return err;
+	}
+
+	return 0;
+}
+
+static void tmp105_dev_exit(void *data)
+{
+	struct tmp105_data *chip = data;
+	if (chip->irq_pin) {
+		free_irq(OMAP_GPIO_IRQ(chip->irq_pin), chip);
+		omap_free_gpio(chip->irq_pin);
+	}
+}
+
+#else
+
+static int tmp105_dev_init(void *data)
+{
+	return 0;
+}
+
+static void tmp105_dev_exit(void *data)
+{
+}
+
+static int tmp105_dev_power(int power)
+{
+	return 0;
+}
+
+#endif
+
+static struct i2c_driver tmp105_i2c_driver = {
+	.id		= I2C_DRIVERID_MISC,
+	.attach_adapter	= tmp105_attach_adapter,
+	.detach_client	= tmp105_detach_client,
+	.driver = {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	}
+};
+
+static int tmp105_probe(struct i2c_adapter *adapter, int address, int kind)
+{
+	struct i2c_client *client;
+	struct tmp105_data *data;
+	int err;
+
+	pr_info(DRIVER_NAME ": found at address 0x%02x\n", address);
+
+	data = kzalloc(sizeof(struct tmp105_data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	client = &data->client;
+
+	strncpy(client->name, DRIVER_NAME, sizeof(client->name));
+	i2c_set_clientdata(client, data);
+
+	client->addr		= address;
+	client->adapter		= adapter;
+	client->driver		= &tmp105_i2c_driver;
+	client->flags		= 0;
+
+	if ((err = tmp105_dev_init(data)) < 0)
+		goto fail1;
+
+	if ((err = i2c_attach_client(client)) < 0) {
+		printk(KERN_ERR DRIVER_NAME ": unable to attach I2C client\n");
+		goto fail2;
+	}
+
+	/* set proper configuration */
+	err = tmp105_write_reg8(client, TMP105_REG_CONFIGURATION,
+				TMP105_INIT_BITS);
+	if (err < 0) {
+		printk(KERN_ERR DRIVER_NAME ": failed to configure chip\n");
+		goto fail3;
+	}
+
+	/* Register sysfs hooks */
+	data->class_dev = hwmon_device_register(&client->dev);
+	if (IS_ERR(data->class_dev))
+		goto fail3;
+
+	/* set up sysfs attributes we provide */
+	err = tmp105_create_sysfs_files(client);
+	if (err < 0)
+		goto fail4;
+
+	INIT_WORK(&data->work, tmp105_work);
+
+	msleep(30); /* the first conversion after power up is slooow... */
+
+	err = tmp105_write_reg(client, TMP105_REG_THIGH,
+			       temp2reg(TMP105_TEMPERATURE_CRITICAL));
+	if (err < 0)
+		goto fail4;
+
+	err = tmp105_write_reg(client, TMP105_REG_TLOW,
+			       temp2reg(TMP105_TEMPERATURE_CRIT_HYST));
+	if (err < 0)
+		goto fail4;
+
+	return 0;
+
+fail4:
+	hwmon_device_unregister(data->class_dev);
+fail3:
+	i2c_detach_client(client);
+fail2:
+	tmp105_dev_exit(data);
+fail1:
+	kfree(data);
+
+	return err;
+}
+
+static int tmp105_detach_client(struct i2c_client *client)
+{
+	struct tmp105_data *data = i2c_get_clientdata(client);
+	struct device *dev = &client->dev;
+	int err;
+
+	hwmon_device_unregister(data->class_dev);
+
+	device_remove_file(dev, &dev_attr_temp1_crit);
+	device_remove_file(dev, &dev_attr_temp1_crit_hyst);
+	device_remove_file(dev, &dev_attr_temp1_input);
+	device_remove_file(dev, &dev_attr_temp1_crit_alarm);
+
+	if ((err = i2c_detach_client(client)) < 0) {
+		dev_err(&client->dev, "client deregistration failed\n");
+		return err;
+	}
+
+	tmp105_dev_power(0);
+	tmp105_dev_exit(data);
+
+	kfree(data);
+
+	return 0;
+}
+
+static int tmp105_attach_adapter(struct i2c_adapter *bus)
+{
+	int err;
+
+	if (!i2c_check_functionality(bus, I2C_FUNC_SMBUS_WRITE_BYTE_DATA |
+				     I2C_FUNC_SMBUS_READ_WORD_DATA |
+					  I2C_FUNC_SMBUS_WRITE_WORD_DATA)) {
+		printk(KERN_ERR DRIVER_NAME ": missing I2C functionalities\n");
+		return -EINVAL;
+	}
+
+	err = tmp105_dev_power(1);
+	if (err < 0)
+		return err;
+
+	return i2c_probe(bus, &addr_data, &tmp105_probe);
+}
+
+static int __init tmp105_init(void)
+{
+	int res;
+
+	pr_info(DRIVER_NAME ": initializing\n");
+
+	if ((res = i2c_add_driver(&tmp105_i2c_driver)) < 0) {
+		printk(KERN_ERR DRIVER_NAME ": I2C registration failed\n");
+		return res;
+	}
+
+	return 0;
+}
+
+static void __exit tmp105_exit(void)
+{
+	if (i2c_del_driver(&tmp105_i2c_driver) < 0)
+		printk(KERN_ERR DRIVER_NAME ": driver remove failed\n");
+}
+
+MODULE_AUTHOR("Mikko K. Ylinen <mikko.k.ylinen@nokia.com");
+MODULE_DESCRIPTION("I2C interface driver for a TMP105 temperature sensor.");
+MODULE_LICENSE("GPL");
+
+module_init(tmp105_init);
+module_exit(tmp105_exit);
diff -ruN linux-omap-2.6/drivers/i2c/busses/i2c-omap.c maemo_src/drivers/i2c/busses/i2c-omap.c
--- linux-omap-2.6/drivers/i2c/busses/i2c-omap.c	2011-02-06 20:17:25.609999939 -0500
+++ maemo_src/drivers/i2c/busses/i2c-omap.c	2011-02-06 20:12:12.813333274 -0500
@@ -134,6 +134,8 @@
 	size_t			buf_len;
 	struct i2c_adapter	adapter;
 	unsigned		rev1:1;
+	unsigned		idle:1;
+	u16			iestate;	/* Saved interrupt register */
 };
 
 static inline void omap_i2c_write_reg(struct omap_i2c_dev *i2c_dev,
@@ -191,18 +193,30 @@
 	}
 }
 
-static void omap_i2c_enable_clocks(struct omap_i2c_dev *dev)
+static void omap_i2c_unidle(struct omap_i2c_dev *dev)
 {
 	if (dev->iclk != NULL)
 		clk_enable(dev->iclk);
 	clk_enable(dev->fclk);
+	if (dev->iestate)
+		omap_i2c_write_reg(dev, OMAP_I2C_IE_REG, dev->iestate);
+	dev->idle = 0;
 }
 
-static void omap_i2c_disable_clocks(struct omap_i2c_dev *dev)
+static void omap_i2c_idle(struct omap_i2c_dev *dev)
 {
+	u16 iv;
+
+	dev->idle = 1;
+	dev->iestate = omap_i2c_read_reg(dev, OMAP_I2C_IE_REG);
+	omap_i2c_write_reg(dev, OMAP_I2C_IE_REG, 0);
+	if (dev->rev1)
+		iv = omap_i2c_read_reg(dev, OMAP_I2C_IV_REG);
+	else
+		omap_i2c_write_reg(dev, OMAP_I2C_STAT_REG, dev->iestate);
+	clk_disable(dev->fclk);
 	if (dev->iclk != NULL)
 		clk_disable(dev->iclk);
-	clk_disable(dev->fclk);
 }
 
 static int omap_i2c_init(struct omap_i2c_dev *dev)
@@ -438,7 +452,7 @@
 	int i;
 	int r;
 
-	omap_i2c_enable_clocks(dev);
+	omap_i2c_unidle(dev);
 
 	/* REVISIT: initialize and use adap->retries. This is an optional
 	 * feature */
@@ -454,7 +468,7 @@
 	if (r == 0)
 		r = num;
 out:
-	omap_i2c_disable_clocks(dev);
+	omap_i2c_idle(dev);
 	return r;
 }
 
@@ -487,6 +501,9 @@
 	struct omap_i2c_dev *dev = dev_id;
 	u16 iv, w;
 
+	if (dev->idle)
+		return IRQ_NONE;
+
 	iv = omap_i2c_read_reg(dev, OMAP_I2C_IV_REG);
 	switch (iv) {
 	case 0x00:	/* None */
@@ -541,6 +558,9 @@
 	u16 stat, w;
 	int count = 0;
 
+	if (dev->idle)
+		return IRQ_NONE;
+
 	bits = omap_i2c_read_reg(dev, OMAP_I2C_IE_REG);
 	while ((stat = (omap_i2c_read_reg(dev, OMAP_I2C_STAT_REG))) & bits) {
 		dev_dbg(dev->dev, "IRQ (ISR = 0x%04x)\n", stat);
@@ -671,7 +691,7 @@
 	if ((r = omap_i2c_get_clocks(dev)) != 0)
 		goto err_free_mem;
 
-	omap_i2c_enable_clocks(dev);
+	omap_i2c_unidle(dev);
 
 	if (cpu_is_omap15xx())
 		dev->rev1 = omap_i2c_read_reg(dev, OMAP_I2C_REV_REG) < 0x20;
@@ -705,14 +725,14 @@
 		goto err_free_irq;
 	}
 
-	omap_i2c_disable_clocks(dev);
+	omap_i2c_idle(dev);
 
 	return 0;
 
 err_free_irq:
 	free_irq(dev->irq, dev);
 err_unuse_clocks:
-	omap_i2c_disable_clocks(dev);
+	omap_i2c_idle(dev);
 	omap_i2c_put_clocks(dev);
 err_free_mem:
 	platform_set_drvdata(pdev, NULL);
diff -ruN linux-omap-2.6/drivers/i2c/chips/Kconfig maemo_src/drivers/i2c/chips/Kconfig
--- linux-omap-2.6/drivers/i2c/chips/Kconfig	2011-02-06 20:17:25.609999939 -0500
+++ maemo_src/drivers/i2c/chips/Kconfig	2007-10-02 03:09:31.000000000 -0400
@@ -108,6 +108,12 @@
 	  If you say yes here you get support for the I2C control
 	  interface for Texas Instruments TLV320AIC23 audio codec.
 
+config SENSORS_TSL2563
+	bool "TSL2563 light sensor chip"
+	depends on I2C
+	help
+	  Say yes here if you have TSL2563 chip on your board
+
 config GPIOEXPANDER_OMAP
 	bool "GPIO Expander PCF8574PWR for OMAP"
 	depends on I2C && (ARCH_OMAP16XX || ARCH_OMAP24XX)
@@ -115,6 +121,20 @@
 	  If you say yes here you get support for I/O expander calls
 	  to configure IrDA, Camera and audio devices.
 
+config LM8323
+	bool "LM8323 keypad chip"
+	depends on I2C
+	help
+	  If you say yes here you get support for the National Semiconductor
+	  LM8323 keypad controller.
+
+config LP5521
+	bool "LP5521 LED driver chip"
+	depends on I2C
+	help
+	  If you say yes here you get support for the National Semiconductor
+	  LP5521 LED driver.
+
 config MENELAUS
 	bool "Menelaus PM chip"
 	depends on I2C=y && ARCH_OMAP24XX
diff -ruN linux-omap-2.6/drivers/i2c/chips/lm8323.c maemo_src/drivers/i2c/chips/lm8323.c
--- linux-omap-2.6/drivers/i2c/chips/lm8323.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/i2c/chips/lm8323.c	2011-02-06 20:12:12.813333274 -0500
@@ -0,0 +1,954 @@
+/*
+ * drivers/i2c/chips/lm8323.c
+ *
+ * Copyright (C) 2007 Nokia Corporation
+ *
+ * Written by Daniel Stone <daniel.stone@nokia.com>
+ *            Timo O. Karjalainen <timo.o.karjalainen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation (version 2 of the License only).
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/leds.h>
+#include <linux/lm8323.h>
+
+#include <asm/mach-types.h>
+#include <asm/mach/irq.h>
+
+#ifdef VERBOSE
+#define debug dev_dbg
+#else
+#define debug(...)
+#endif
+
+/* Commands to send to the chip. */
+#define LM8323_CMD_READ_ID		0x80 /* Read chip ID. */
+#define LM8323_CMD_WRITE_CFG		0x81 /* Set configuration item. */
+#define LM8323_CMD_READ_INT		0x82 /* Get interrupt status. */
+#define LM8323_CMD_RESET		0x83 /* Reset, same as external one */
+#define LM8323_CMD_WRITE_PORT_SEL	0x85 /* Set GPIO in/out. */
+#define LM8323_CMD_WRITE_PORT_STATE	0x86 /* Set GPIO pullup. */
+#define LM8323_CMD_READ_PORT_SEL	0x87 /* Get GPIO in/out. */
+#define LM8323_CMD_READ_PORT_STATE	0x88 /* Get GPIO pullup. */
+#define LM8323_CMD_READ_FIFO		0x89 /* Read byte from FIFO. */
+#define LM8323_CMD_RPT_READ_FIFO	0x8a /* Read FIFO (no increment). */
+#define LM8323_CMD_SET_ACTIVE		0x8b /* Set active time. */
+#define LM8323_CMD_READ_ERR		0x8c /* Get error status. */
+#define LM8323_CMD_READ_ROTATOR		0x8e /* Read rotator status. */
+#define LM8323_CMD_SET_DEBOUNCE		0x8f /* Set debouncing time. */
+#define LM8323_CMD_SET_KEY_SIZE		0x90 /* Set keypad size. */
+#define LM8323_CMD_READ_KEY_SIZE	0x91 /* Get keypad size. */
+#define LM8323_CMD_READ_CFG		0x92 /* Get configuration item. */
+#define LM8323_CMD_WRITE_CLOCK		0x93 /* Set clock config. */
+#define LM8323_CMD_READ_CLOCK		0x94 /* Get clock config. */
+#define LM8323_CMD_PWM_WRITE		0x95 /* Write PWM script. */
+#define LM8323_CMD_START_PWM		0x96 /* Start PWM engine. */
+#define LM8323_CMD_STOP_PWM		0x97 /* Stop PWM engine. */
+
+/* Interrupt status. */
+#define INT_KEYPAD			0x01 /* Key event. */
+#define INT_ROTATOR			0x02 /* Rotator event. */
+#define INT_ERROR			0x08 /* Error: use CMD_READ_ERR. */
+#define INT_NOINIT			0x10 /* Lost configuration. */
+#define INT_PWM1			0x20 /* PWM1 stopped. */
+#define INT_PWM2			0x40 /* PWM2 stopped. */
+#define INT_PWM3			0x80 /* PWM3 stopped. */
+
+/* Errors (signalled by INT_ERROR, read with CMD_READ_ERR). */
+#define ERR_BADPAR			0x01 /* Bad parameter. */
+#define ERR_CMDUNK			0x02 /* Unknown command. */
+#define ERR_KEYOVR			0x04 /* Too many keys pressed. */
+#define ERR_FIFOOVER			0x40 /* FIFO overflow. */
+
+/* Configuration keys (CMD_{WRITE,READ}_CFG). */
+#define CFG_MUX1SEL			0x01 /* Select MUX1_OUT input. */
+#define CFG_MUX1EN			0x02 /* Enable MUX1_OUT. */
+#define CFG_MUX2SEL			0x04 /* Select MUX2_OUT input. */
+#define CFG_MUX2EN			0x08 /* Enable MUX2_OUT. */
+#define CFG_PSIZE			0x20 /* Package size (must be 0). */
+#define CFG_ROTEN			0x40 /* Enable rotator. */
+
+/* Clock settings (CMD_{WRITE,READ}_CLOCK). */
+#define CLK_RCPWM_INTERNAL		0x00
+#define CLK_RCPWM_EXTERNAL		0x03
+#define CLK_SLOWCLKEN			0x08 /* Enable 32.768kHz clock. */
+#define CLK_SLOWCLKOUT			0x40 /* Enable slow pulse output. */
+
+/* The possible addresses corresponding to CONFIG1 and CONFIG2 pin wirings. */
+#define LM8323_I2C_ADDR00		(0x84 >> 1)	/* 1000 010x */
+#define LM8323_I2C_ADDR01		(0x86 >> 1)	/* 1000 011x */
+#define LM8323_I2C_ADDR10		(0x88 >> 1)	/* 1000 100x */
+#define LM8323_I2C_ADDR11		(0x8A >> 1)	/* 1000 101x */
+
+/* Key event fifo length */
+#define LM8323_FIFO_LEN			15
+
+/* Commands for PWM engine; feed in with PWM_WRITE. */
+/* Load ramp counter from duty cycle field (range 0 - 0xff). */
+#define PWM_SET(v)			(0x4000 | ((v) & 0xff))
+/* Go to start of script. */
+#define PWM_GOTOSTART			0x0000
+/*
+ * Stop engine (generates interrupt).  If reset is 1, clear the program
+ * counter, else leave it.
+ */
+#define PWM_END(reset)			(0xc000 | (!!(reset) << 11))
+/*
+ * Ramp.  If s is 1, divide clock by 512, else divide clock by 16.
+ * Take t clock scales (up to 63) per step, for n steps (up to 126).
+ * If u is set, ramp up, else ramp down.
+ */
+#define PWM_RAMP(s, t, n, u)		((!!(s) << 14) | ((t) & 0x3f) << 8 | \
+					 ((n) & 0x7f) | ((u) ? 0 : 0x80))
+/*
+ * Loop (i.e. jump back to pos) for a given number of iterations (up to 63).
+ * If cnt is zero, execute until PWM_END is encountered.
+ */
+#define PWM_LOOP(cnt, pos)		(0xa000 | (((cnt) & 0x3f) << 7) | \
+					 ((pos) & 0x3f))
+/*
+ * Wait for trigger.  Argument is a mask of channels, shifted by the channel
+ * number, e.g. 0xa for channels 3 and 1.  Note that channels are numbered
+ * from 1, not 0.
+ */
+#define PWM_WAIT_TRIG(chans)		(0xe000 | (((chans) & 0x7) << 6))
+/* Send trigger.  Argument is same as PWM_WAIT_TRIG. */
+#define PWM_SEND_TRIG(chans)		(0xe000 | ((chans) & 0x7))
+
+#define DRIVER_NAME  "lm8323"
+
+static unsigned short normal_i2c[] =
+{
+	LM8323_I2C_ADDR00, LM8323_I2C_ADDR01,
+	LM8323_I2C_ADDR10, LM8323_I2C_ADDR11,
+	I2C_CLIENT_END
+};
+
+I2C_CLIENT_INSMOD;
+
+struct lm8323_pwm {
+	int			id;
+	int			enabled;
+	int			fade_time;
+	int			brightness;
+	int			desired_brightness;
+	struct work_struct	work;
+	struct led_classdev	cdev;
+};
+
+struct lm8323_chip {
+	struct mutex		lock;
+	struct i2c_client	client;
+	struct work_struct	work;
+	struct input_dev	*idev;
+	int			irq;
+	unsigned		kp_enabled : 1;
+	unsigned		pm_suspend : 1;
+	unsigned		keys_down;
+	char			phys[32];
+	s16			keymap[LM8323_KEYMAP_SIZE];
+	int			size_x;
+	int			size_y;
+	int			debounce_time;
+	int			active_time;
+	struct lm8323_pwm	pwm1;
+	struct lm8323_pwm	pwm2;
+	struct lm8323_pwm	pwm3;
+};
+
+#define client_to_lm8323(c)	container_of(c, struct lm8323_chip, client)
+#define dev_to_lm8323(d)	container_of(d, struct lm8323_chip, client.dev)
+#define work_to_lm8323(w)	container_of(w, struct lm8323_chip, work)
+#define cdev_to_pwm(c)		container_of(c, struct lm8323_pwm, cdev)
+#define work_to_pwm(w)		container_of(w, struct lm8323_pwm, work)
+
+static struct lm8323_chip *pwm_to_lm8323(struct lm8323_pwm *pwm)
+{
+	switch (pwm->id) {
+	case 1:
+		return container_of(pwm, struct lm8323_chip, pwm1);
+	case 2:
+		return container_of(pwm, struct lm8323_chip, pwm2);
+	case 3:
+		return container_of(pwm, struct lm8323_chip, pwm3);
+	default:
+		return NULL;
+	}
+}
+
+static struct lm8323_platform_data *lm8323_pdata = NULL;
+static struct lm8323_chip lm8323;
+
+
+#define LM8323_MAX_DATA 8
+
+/*
+ * To write, we just access the chip's address in write mode, and dump the
+ * command and data out on the bus.  The command byte and data are taken as
+ * sequential u8s out of varargs, to a maximum of LM8323_MAX_DATA.
+ */
+static int lm8323_write(struct lm8323_chip *lm, int len, ...)
+{
+	int ret, i;
+	va_list ap;
+	u8 data[LM8323_MAX_DATA];
+
+	va_start(ap, len);
+
+	if (unlikely(len > LM8323_MAX_DATA)) {
+		dev_err(&lm->client.dev, "tried to send %d bytes\n", len);
+		va_end(ap);
+		return 0;
+	}
+
+	for (i = 0; i < len; i++)
+		data[i] = va_arg(ap, int);
+
+	va_end(ap);
+
+	/*
+	 * If the host is asleep while we send the data, we can get a NACK
+	 * back while it wakes up, so try again, once.
+	 */
+	ret = i2c_master_send(&lm->client, data, len);
+	if (unlikely(ret == -EREMOTEIO))
+		ret = i2c_master_send(&lm->client, data, len);
+	if (unlikely(ret != len))
+		dev_err(&lm->client.dev, "sent %d bytes of %d total\n",
+			len, ret);
+
+	return ret;
+}
+
+/*
+ * To read, we first send the command byte to the chip and end the transaction,
+ * then access the chip in read mode, at which point it will send the data.
+ */
+static int lm8323_read(struct lm8323_chip *lm, u8 cmd, u8 *buf, int len)
+{
+	int ret;
+
+	/*
+	 * If the host is asleep while we send the byte, we can get a NACK
+	 * back while it wakes up, so try again, once.
+	 */
+	ret = i2c_master_send(&lm->client, &cmd, 1);
+	if (unlikely(ret == -EREMOTEIO))
+		ret = i2c_master_send(&lm->client, &cmd, 1);
+	if (unlikely(ret != 1)) {
+		dev_err(&lm->client.dev, "sending read cmd 0x%02x failed\n",
+			cmd);
+		return 0;
+	}
+
+	ret = i2c_master_recv(&lm->client, buf, len);
+	if (unlikely(ret != len))
+		dev_err(&lm->client.dev, "wanted %d bytes, got %d\n",
+			len, ret);
+
+	return ret;
+}
+
+/*
+ * Set the chip active time (idle time before it enters halt).
+ */
+static void lm8323_set_active_time(struct lm8323_chip *lm, int time)
+{
+	lm8323_write(lm, 2, LM8323_CMD_SET_ACTIVE, time >> 2);
+}
+
+/*
+ * The signals are AT-style: the low 7 bits are the keycode, and the top
+ * bit indicates the state (1 for down, 0 for up).
+ */
+static inline u8 lm8323_whichkey(u8 event)
+{
+	return event & 0x7f;
+}
+
+static inline int lm8323_ispress(u8 event)
+{
+	return (event & 0x80) ? 1 : 0;
+}
+
+static void process_keys(struct lm8323_chip *lm)
+{
+	u8 event;
+	u8 key_fifo[LM8323_FIFO_LEN + 1];
+	int old_keys_down = lm->keys_down;
+	int ret;
+	int i = 0;
+
+	/*
+	 * Read all key events from the FIFO at once. Next READ_FIFO clears the
+	 * FIFO even if we didn't read all events previously.
+	 */
+	ret = lm8323_read(lm, LM8323_CMD_READ_FIFO, key_fifo, LM8323_FIFO_LEN);
+
+	if (ret < 0) {
+		dev_err(&lm->client.dev, "Failed reading fifo \n");
+		return;
+	}
+	key_fifo[ret] = 0;
+
+	while ((event = key_fifo[i])) {
+		u8 key = lm8323_whichkey(event);
+		int isdown = lm8323_ispress(event);
+		s16 keycode = lm->keymap[key];
+
+		if (likely(keycode > 0)) {
+			debug(&lm->client.dev, "key 0x%02x %s\n", key,
+			      isdown ? "down" : "up");
+			if (likely(lm->kp_enabled)) {
+				input_report_key(lm->idev, keycode, isdown);
+				input_sync(lm->idev);
+			}
+			if (isdown)
+				lm->keys_down++;
+			else
+				lm->keys_down--;
+		} else {
+			dev_err(&lm->client.dev, "keycode 0x%02x not mapped "
+				"to any key\n", key);
+		}
+		i++;
+	}
+
+	/*
+	 * Errata: We need to ensure that the chip never enters halt mode
+	 * during a keypress, so set active time to 0.  When it's released,
+	 * we can enter halt again, so set the active time back to normal.
+	 */
+	if (!old_keys_down && lm->keys_down)
+		lm8323_set_active_time(lm, 0);
+	if (old_keys_down && !lm->keys_down)
+		lm8323_set_active_time(lm, lm->active_time);
+}
+
+static void lm8323_process_error(struct lm8323_chip *lm)
+{
+	u8 error;
+
+	if (lm8323_read(lm, LM8323_CMD_READ_ERR, &error, 1) == 1) {
+		if (error & ERR_FIFOOVER)
+			debug(&lm->client.dev, "fifo overflow!\n");
+		if (error & ERR_KEYOVR)
+			debug(&lm->client.dev, "more than two keys pressed\n");
+		if (error & ERR_CMDUNK)
+			debug(&lm->client.dev, "unknown command submitted\n");
+		if (error & ERR_BADPAR)
+			debug(&lm->client.dev, "bad command parameter\n");
+	}
+}
+
+static void lm8323_reset(struct lm8323_chip *lm)
+{
+	/* The docs say we must pass 0xAA as the data byte. */
+	lm8323_write(lm, 2, LM8323_CMD_RESET, 0xAA);
+}
+
+static int lm8323_configure(struct lm8323_chip *lm)
+{
+	int keysize = (lm->size_x << 4) | lm->size_y;
+	int clock = (CLK_SLOWCLKEN | CLK_RCPWM_EXTERNAL);
+	int debounce = lm->debounce_time >> 2;
+	int active = lm->active_time >> 2;
+
+	/*
+	 * Active time must be greater than the debounce time: if it's
+	 * a close-run thing, give ourselves a 12ms buffer.
+	 */
+	if (debounce >= active)
+		active = debounce + 3;
+
+	lm8323_write(lm, 2, LM8323_CMD_WRITE_CFG, 0);
+	lm8323_write(lm, 2, LM8323_CMD_WRITE_CLOCK, clock);
+	lm8323_write(lm, 2, LM8323_CMD_SET_KEY_SIZE, keysize);
+	lm8323_set_active_time(lm, lm->active_time);
+	lm8323_write(lm, 2, LM8323_CMD_SET_DEBOUNCE, debounce);
+	lm8323_write(lm, 3, LM8323_CMD_WRITE_PORT_STATE, 0xff, 0xff);
+	lm8323_write(lm, 3, LM8323_CMD_WRITE_PORT_SEL, 0, 0);
+
+	/*
+	 * Not much we can do about errors at this point, so just hope
+	 * for the best.
+	 */
+
+	return 0;
+}
+
+/*
+ * Bottom half: handle the interrupt by posting key events, or dealing with
+ * errors appropriately.
+ */
+static void lm8323_work(struct work_struct *work)
+{
+	struct lm8323_chip *lm = work_to_lm8323(work);
+	u8 ints;
+
+	mutex_lock(&lm->lock);
+
+	while ((lm8323_read(lm, LM8323_CMD_READ_INT, &ints, 1) == 1) && ints) {
+		if (likely(ints & INT_KEYPAD)) {
+			process_keys(lm);
+		}
+		if (ints & INT_ROTATOR) {
+			/* We don't currently support the rotator. */
+			debug(&lm->client.dev, "rotator fired\n");
+		}
+		if (ints & INT_ERROR) {
+			debug(&lm->client.dev, "error!\n");
+			lm8323_process_error(lm);
+		}
+		if (ints & INT_NOINIT) {
+			dev_err(&lm->client.dev, "chip lost config; "
+						  "reinitialising\n");
+			lm8323_configure(lm);
+		}
+		if (ints & INT_PWM1) {
+			debug(&lm->client.dev, "pwm1 engine completed\n");
+		}
+		if (ints & INT_PWM2) {
+			debug(&lm->client.dev, "pwm2 engine completed\n");
+		}
+		if (ints & INT_PWM3) {
+			debug(&lm->client.dev, "pwm3 engine completed\n");
+		}
+	}
+
+	mutex_unlock(&lm->lock);
+}
+
+/*
+ * We cannot use I2C in interrupt context, so we just schedule work.
+ */
+static irqreturn_t lm8323_irq(int irq, void *data)
+{
+	struct lm8323_chip *lm = data;
+
+	schedule_work(&lm->work);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Read the chip ID.
+ */
+static int lm8323_read_id(struct lm8323_chip *lm, u8 *buf)
+{
+	int bytes;
+
+	bytes = lm8323_read(lm, LM8323_CMD_READ_ID, buf, 2);
+	if (unlikely(bytes != 2))
+		return -EIO;
+
+	return 0;
+}
+
+static void lm8323_write_pwm_one(struct lm8323_pwm *pwm, int pos, u16 cmd)
+{
+	struct lm8323_chip *lm = pwm_to_lm8323(pwm);
+
+	lm8323_write(lm, 4, LM8323_CMD_PWM_WRITE, (pos << 2) | pwm->id,
+		     (cmd & 0xff00) >> 8, cmd & 0x00ff);
+}
+
+/*
+ * Write a script into a given PWM engine, concluding with PWM_END.
+ * If 'keepalive' is specified, the engine will be kept running
+ * indefinitely.
+ */
+static void lm8323_write_pwm(struct lm8323_pwm *pwm, int keepalive,
+			     int len, ...)
+{
+	struct lm8323_chip *lm = pwm_to_lm8323(pwm);
+	int i, cmd;
+	va_list ap;
+
+	/*
+	 * If there are any scripts running at the moment, terminate them
+	 * and make sure the duty cycle is as if it finished.
+	 */
+	lm8323_write(lm, 2, LM8323_CMD_STOP_PWM, pwm->id);
+
+	va_start(ap, len);
+	for (i = 0; i < len; i++) {
+		cmd = va_arg(ap, int);
+		lm8323_write_pwm_one(pwm, i, cmd);
+	}
+	va_end(ap);
+
+	/* Wait for a trigger from any channel. This keeps the engine alive. */
+	if (keepalive)
+		lm8323_write_pwm_one(pwm, i++, PWM_WAIT_TRIG(0xe));
+	else
+		lm8323_write_pwm_one(pwm, i++, PWM_END(1));
+
+	lm8323_write(lm, 2, LM8323_CMD_START_PWM, pwm->id);
+}
+
+static void lm8323_pwm_work(struct work_struct *work)
+{
+	struct lm8323_pwm *pwm = work_to_pwm(work);
+	int div, perstep, steps, hz, direction, keepalive;
+
+	/* Do nothing if we're already at the requested level. */
+	if (pwm->desired_brightness == pwm->brightness)
+		return;
+
+	keepalive = (pwm->desired_brightness > 0);
+	direction = (pwm->desired_brightness > pwm->brightness);
+	steps = abs(pwm->desired_brightness - pwm->brightness);
+
+	/*
+	 * Convert time (in ms) into a divisor (512 or 16 on a refclk of
+	 * 32768Hz), and number of ticks per step.
+	 */
+	if ((pwm->fade_time / steps) > (32768 / 512))
+		div = 512;
+	else
+		div = 16;
+
+	hz = 32768 / div;
+	if (pwm->fade_time < ((steps * 1000) / hz))
+		perstep = 1;
+	else
+		perstep = (hz * pwm->fade_time) / (steps * 1000);
+
+	if (perstep == 0)
+		perstep = 1;
+	else if (perstep > 63)
+		perstep = 63;
+
+	if (steps > 252) {
+		lm8323_write_pwm(pwm, keepalive, 3,
+				 PWM_RAMP((div == 512), perstep, 126,
+					  direction),
+				 PWM_RAMP((div == 512), perstep, 126,
+					  direction),
+				 PWM_RAMP((div == 512), perstep, steps - 252,
+					  direction));
+	} else if (steps > 126) {
+		lm8323_write_pwm(pwm, keepalive, 2,
+				 PWM_RAMP((div == 512), perstep, 126,
+					  direction),
+				 PWM_RAMP((div == 512), perstep, steps - 126,
+					  direction));
+	} else {
+		lm8323_write_pwm(pwm, keepalive, 1,
+				 PWM_RAMP((div == 512), perstep, steps,
+					  direction));
+	}
+
+	pwm->brightness = pwm->desired_brightness;
+}
+
+static void lm8323_pwm_set_brightness(struct led_classdev *led_cdev,
+				      enum led_brightness brightness)
+{
+	struct lm8323_pwm *pwm = cdev_to_pwm(led_cdev);
+	struct lm8323_chip *lm = pwm_to_lm8323(pwm);
+
+	pwm->desired_brightness = brightness;
+
+	if (in_interrupt()) {
+		schedule_work(&pwm->work);
+	} else {
+		/*
+		 * Schedule PWM work as usual unless we are going into suspend
+		 */
+		mutex_lock(&lm->lock);
+		if (likely(!lm->pm_suspend))
+			schedule_work(&pwm->work);
+		else
+			lm8323_pwm_work(&pwm->work);
+		mutex_unlock(&lm->lock);
+	}
+}
+
+static ssize_t lm8323_pwm_show_time(struct class_device *cdev, char *buf)
+{
+	struct led_classdev *led_cdev = class_get_devdata(cdev);
+	struct lm8323_pwm *pwm = cdev_to_pwm(led_cdev);
+
+	return sprintf(buf, "%d\n", pwm->fade_time);
+}
+
+static ssize_t lm8323_pwm_store_time(struct class_device *cdev,
+				     const char *buf, size_t len)
+{
+	struct led_classdev *led_cdev = class_get_devdata(cdev);
+	struct lm8323_pwm *pwm = cdev_to_pwm(led_cdev);
+	char *endptr = NULL;
+	int time;
+
+	time = simple_strtoul(buf, &endptr, 10);
+	/* Numbers only, please. */
+	if (endptr && *endptr != '\n' && *(endptr + 1) != '\0')
+		return -EINVAL;
+
+	pwm->fade_time = time;
+
+	return strlen(buf);
+}
+CLASS_DEVICE_ATTR(time, 0644, lm8323_pwm_show_time, lm8323_pwm_store_time);
+
+static int init_pwm(struct lm8323_chip *lm, int id, struct device *dev,
+		    const char *name)
+{
+	struct lm8323_pwm *pwm = NULL;
+
+	BUG_ON(id > 3);
+
+	switch (id) {
+	case 1:
+		pwm = &lm->pwm1;
+		break;
+	case 2:
+		pwm = &lm->pwm2;
+		break;
+	case 3:
+		pwm = &lm->pwm3;
+		break;
+	}
+
+	pwm->id = id;
+	pwm->fade_time = 0;
+	pwm->brightness = 0;
+	pwm->desired_brightness = 0;
+	if (name) {
+		pwm->cdev.name = name;
+		pwm->cdev.brightness_set = lm8323_pwm_set_brightness;
+		if (led_classdev_register(dev, &pwm->cdev) < 0) {
+			dev_err(dev, "couldn't register PWM %d\n", id);
+			return -1;
+		}
+		if (class_device_create_file(pwm->cdev.class_dev,
+					     &class_device_attr_time) < 0) {
+			dev_err(dev, "couldn't register time attribute\n");
+			led_classdev_unregister(&pwm->cdev);
+			return -1;
+		}
+		INIT_WORK(&pwm->work, lm8323_pwm_work);
+		pwm->enabled = 1;
+	} else {
+		pwm->enabled = 0;
+	}
+
+	return 0;
+}
+
+static struct i2c_driver lm8323_i2c_driver;
+
+static ssize_t lm8323_show_disable(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct lm8323_chip *lm = dev_to_lm8323(dev);
+
+	return sprintf(buf, "%u\n", !lm->kp_enabled);
+}
+
+static ssize_t lm8323_set_disable(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct lm8323_chip *lm = dev_to_lm8323(dev);
+	char *endp;
+	int i;
+
+	i = simple_strtoul(buf, &endp, 10);
+
+	mutex_lock(&lm->lock);
+	lm->kp_enabled = !i;
+	mutex_unlock(&lm->lock);
+
+	return count;
+}
+static DEVICE_ATTR(disable_kp, 0644, lm8323_show_disable, lm8323_set_disable);
+
+static int lm8323_probe(struct i2c_adapter *adapter, int address, int kind)
+{
+	struct input_dev *idev;
+	struct i2c_client *c;
+	struct lm8323_chip *lm = &lm8323;
+	int i, err = 0;
+	unsigned long tmo;
+	u8 data[2];
+
+	if (!lm8323_pdata)
+		return -EINVAL; /* ? */
+
+	c = &lm->client;
+	strncpy(c->name, DRIVER_NAME, sizeof(c->name));
+	c->addr		= address;
+	c->adapter	= adapter;
+	c->driver	= &lm8323_i2c_driver;
+	c->flags	= 0;
+
+	if ((err = i2c_attach_client(c)) < 0) {
+		dev_err(&c->dev, "couldn't attach\n");
+		goto fail1;
+	}
+
+	lm->size_x = lm8323_pdata->size_x;
+	if (lm->size_x == 0) {
+		lm->size_x = 8;
+	} else if (lm->size_x > 8) {
+		dev_err(&c->dev, "invalid x size %d specified\n", lm->size_x);
+		lm->size_x = 8;
+	}
+
+	lm->size_y = lm8323_pdata->size_y;
+	if (lm->size_y == 0) {
+		lm->size_y = 12;
+	} else if (lm->size_y > 12) {
+		dev_err(&c->dev, "invalid y size %d specified\n", lm->size_y);
+		lm->size_x = 12;
+	}
+
+	debug(&c->dev, "Keypad size: %d x %d\n", lm->size_x, lm->size_y);
+
+	lm->debounce_time = lm8323_pdata->debounce_time;
+	if (lm->debounce_time == 0) /* Default. */
+		lm->debounce_time = 12;
+	else if (lm->debounce_time == -1) /* Disable debounce. */
+		lm->debounce_time = 0;
+
+	lm->active_time = lm8323_pdata->active_time;
+	if (lm->active_time == 0) /* Default. */
+		lm->active_time = 500;
+	else if (lm->active_time == -1) /* Disable sleep. */
+		lm->active_time = 0;
+
+	lm8323_reset(lm);
+
+	/* Nothing's set up to service the IRQ yet, so just spin for max.
+	 * 100ms until we can configure. */
+	tmo = jiffies + msecs_to_jiffies(100);
+	while (lm8323_read(lm, LM8323_CMD_READ_INT, data, 1) == 1) {
+		if (data[0] & INT_NOINIT)
+			break;
+
+		if (time_after(jiffies, tmo)) {
+			dev_err(&c->dev, "timeout waiting for initialisation\n");
+			break;
+		}
+
+		msleep(1);
+	}
+	lm8323_configure(lm);
+
+	/* If a true probe check the device */
+	if (kind < 0) {
+		if (lm8323_read_id(lm, data) != 0) {
+			dev_err(&c->dev, "device not found\n");
+			err = -ENODEV;
+			goto fail2;
+		}
+	}
+
+	if (init_pwm(lm, 1, &c->dev, lm8323_pdata->pwm1_name) < 0)
+		goto fail3;
+	if (init_pwm(lm, 2, &c->dev, lm8323_pdata->pwm2_name) < 0)
+		goto fail4;
+	if (init_pwm(lm, 3, &c->dev, lm8323_pdata->pwm3_name) < 0)
+		goto fail5;
+
+	lm->irq = lm8323_pdata->irq_gpio;
+	debug(&c->dev, "IRQ: %d\n", lm->irq);
+
+	mutex_init(&lm->lock);
+	INIT_WORK(&lm->work, lm8323_work);
+
+	err = request_irq(lm->irq, lm8323_irq,
+			  IRQF_TRIGGER_FALLING | IRQF_DISABLED |
+			  IRQF_SAMPLE_RANDOM, DRIVER_NAME, lm);
+	if (err) {
+		dev_err(&c->dev, "could not get IRQ %d\n", lm->irq);
+		goto fail6;
+	}
+
+	set_irq_wake(lm->irq, 1);
+
+	if (kind < 0)
+		debug(&c->dev, "chip revision %d\n", id[1]);
+
+	lm->kp_enabled = 1;
+	err = device_create_file(&c->dev, &dev_attr_disable_kp);
+	if (err < 0)
+		goto fail7;
+
+	idev = input_allocate_device();
+	if (idev == NULL) {
+		err = -ENOMEM;
+		goto fail8;
+	}
+
+	if (lm8323_pdata->name)
+		idev->name = lm8323_pdata->name;
+	else
+		idev->name = "LM8323 keypad";
+	snprintf(lm->phys, sizeof(lm->phys), "%s/input-kp", c->dev.bus_id);
+	idev->phys = lm->phys;
+
+	lm->keys_down = 0;
+	idev->evbit[0] = BIT(EV_KEY);
+	for (i = 0; i < LM8323_KEYMAP_SIZE; i++) {
+		if (lm8323_pdata->keymap[i] > 0)
+			set_bit(lm8323_pdata->keymap[i], idev->keybit);
+
+		lm->keymap[i] = lm8323_pdata->keymap[i];
+	}
+
+	if (lm8323_pdata->repeat)
+		set_bit(EV_REP, idev->evbit);
+
+	lm->idev = idev;
+	input_register_device(idev);
+
+	return 0;
+
+fail8:
+	device_remove_file(&c->dev, &dev_attr_disable_kp);
+fail7:
+	free_irq(lm->irq, lm);
+fail6:
+	if (lm->pwm3.enabled)
+		led_classdev_unregister(&lm->pwm3.cdev);
+fail5:
+	if (lm->pwm2.enabled)
+		led_classdev_unregister(&lm->pwm2.cdev);
+fail4:
+	if (lm->pwm1.enabled)
+		led_classdev_unregister(&lm->pwm1.cdev);
+fail3:
+fail2:
+	i2c_detach_client(c);
+fail1:
+	return err;
+}
+
+static int lm8323_remove(struct i2c_client *client)
+{
+	struct lm8323_chip *lm = client_to_lm8323(client);
+	int err;
+
+	free_irq(lm->irq, lm);
+	device_remove_file(&lm->client.dev, &dev_attr_disable_kp);
+
+	if ((err = i2c_detach_client(client))) {
+		dev_err(&client->dev, "client detach failed: %d\n", err);
+		return err;
+	}
+
+	return 0;
+}
+
+static int lm8323_scan_bus(struct i2c_adapter *bus)
+{
+	return i2c_probe(bus, &addr_data, lm8323_probe);
+}
+
+/*
+ * We don't need to explicitly suspend the chip, as it already switches off
+ * when there's no activity.
+ */
+static int lm8323_suspend(struct i2c_client *client, pm_message_t mesg)
+{
+	struct lm8323_chip *lm = dev_to_lm8323(&client->dev);
+
+	set_irq_wake(lm->irq, 0);
+	disable_irq(lm->irq);
+
+	mutex_lock(&lm->lock);
+	lm->pm_suspend = 1;
+	mutex_unlock(&lm->lock);
+
+	if (lm->pwm1.enabled)
+		led_classdev_suspend(&lm->pwm1.cdev);
+	if (lm->pwm2.enabled)
+		led_classdev_suspend(&lm->pwm2.cdev);
+	if (lm->pwm3.enabled)
+		led_classdev_suspend(&lm->pwm3.cdev);
+
+	return 0;
+}
+
+static int lm8323_resume(struct i2c_client *client)
+{
+	struct lm8323_chip *lm = dev_to_lm8323(&client->dev);
+
+	mutex_lock(&lm->lock);
+	lm->pm_suspend = 0;
+	mutex_unlock(&lm->lock);
+
+	if (lm->pwm1.enabled)
+		led_classdev_resume(&lm->pwm1.cdev);
+	if (lm->pwm2.enabled)
+		led_classdev_resume(&lm->pwm2.cdev);
+	if (lm->pwm3.enabled)
+		led_classdev_resume(&lm->pwm3.cdev);
+
+	enable_irq(lm->irq);
+	set_irq_wake(lm->irq, 1);
+
+	return 0;
+}
+
+static struct i2c_driver lm8323_i2c_driver = {
+	.driver = {
+		.name	 = DRIVER_NAME,
+	},
+	.id		= I2C_DRIVERID_MISC, /*FIXME:accroding to i2c-ids.h */
+	.class		= I2C_CLASS_HWMON,
+	.attach_adapter	= lm8323_scan_bus,
+	.detach_client	= lm8323_remove,
+	.suspend	= lm8323_suspend,
+	.resume		= lm8323_resume,
+};
+
+static int __init lm8323_init(void)
+{
+	int res;
+
+	res = i2c_add_driver(&lm8323_i2c_driver);
+	if (res < 0)
+		return res;
+
+	return 0;
+}
+
+static void __exit lm8323_exit(void)
+{
+	i2c_del_driver(&lm8323_i2c_driver);
+}
+
+void __init lm8323_set_platform_data(struct lm8323_platform_data *pdata)
+{
+	lm8323_pdata = pdata;
+}
+
+MODULE_AUTHOR("Daniel Stone <daniel.stone@nokia.com>");
+MODULE_DESCRIPTION("LM8323 keypad driver");
+MODULE_LICENSE("GPL");
+
+module_init(lm8323_init);
+module_exit(lm8323_exit);
diff -ruN linux-omap-2.6/drivers/i2c/chips/lp5521.c maemo_src/drivers/i2c/chips/lp5521.c
--- linux-omap-2.6/drivers/i2c/chips/lp5521.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/i2c/chips/lp5521.c	2007-10-02 03:09:31.000000000 -0400
@@ -0,0 +1,608 @@
+/*
+ * drivers/i2c/chips/lp5521.c
+ *
+ * Copyright (C) 2007 Nokia Corporation
+ *
+ * Written by Mathias Nyman <mathias.nyman@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <asm/arch/gpio.h>
+
+#define LP5521_DRIVER_NAME		"lp5521"
+
+#ifdef LED_CONNECTED_WRONG
+#define LP5521_REG_R_PWM		0x04
+#define LP5521_REG_B_PWM		0x02
+#else
+#define LP5521_REG_R_PWM		0x02
+#define LP5521_REG_B_PWM		0x04
+#endif
+#define LP5521_REG_ENABLE		0x00
+#define LP5521_REG_OP_MODE		0x01
+#define LP5521_REG_G_PWM		0x03
+#define LP5521_REG_R_CNTRL		0x05
+#define LP5521_REG_G_CNTRL		0x06
+#define LP5521_REG_B_CNTRL		0x07
+#define LP5521_REG_MISC			0x08
+#define LP5521_REG_R_CHANNEL_PC		0x09
+#define LP5521_REG_G_CHANNEL_PC		0x0a
+#define LP5521_REG_B_CHANNEL_PC		0x0b
+#define LP5521_REG_STATUS		0x0c
+#define LP5521_REG_RESET		0x0d
+#define LP5521_REG_GPO			0x0e
+#define LP5521_REG_R_PROG_MEM		0x10
+#define LP5521_REG_G_PROG_MEM		0x30
+#define LP5521_REG_B_PROG_MEM		0x50
+
+#define LP5521_MODE_LOAD		"load"
+#define LP5521_MODE_RUN			"run"
+#define LP5521_MODE_DIRECT_CONTROL	"direct"
+
+#define LP5521_CURRENT_1m5		0x0f
+#define LP5521_CURRENT_3m1		0x1f
+#define LP5521_CURRENT_4m7		0x2f
+#define LP5521_CURRENT_6m3		0x3f
+#define LP5521_CURRENT_7m9		0x4f
+#define LP5521_CURRENT_9m5		0x5f
+#define LP5521_CURRENT_11m1		0x6f
+#define LP5521_CURRENT_12m7		0x7f
+#define LP5521_CURRENT_14m3		0x8f
+#define LP5521_CURRENT_15m9		0x9f
+#define LP5521_CURRENT_17m5		0xaf
+#define LP5521_CURRENT_19m1		0xbf
+#define LP5521_CURRENT_20m7		0xcf
+#define LP5521_CURRENT_22m3		0xdf
+#define LP5521_CURRENT_23m9		0xef
+#define LP5521_CURRENT_25m5		0xff
+
+#define LP5521_PROGRAM_LENGTH		32	/* in bytes */
+
+static unsigned short normal_i2c[] = { 0x32, 0x33, 0x34, 0x35, I2C_CLIENT_END };
+
+I2C_CLIENT_INSMOD;
+
+struct lp5521_chip {
+	struct mutex		lock;
+	struct i2c_client	client;
+	char			*mode;
+	int			red;
+	int			green;
+	int			blue;
+};
+
+#define client_to_lp5521(c)  container_of(c, struct lp5521_chip, client)
+#define dev_to_lp5521(d)     container_of(d, struct lp5521_chip, client.dev)
+
+static int lp5521_set_mode(struct lp5521_chip *chip, char *mode);
+
+static int lp5521_write(struct i2c_client *client, u8 reg, u8 value)
+{
+	return i2c_smbus_write_byte_data(client, reg, value);
+}
+
+static int lp5521_read(struct i2c_client *client, u8 reg, u8 *buf)
+{
+	s32 ret = i2c_smbus_read_byte_data(client, reg);
+
+	if (ret < 0)
+		return -EIO;
+
+	*buf = ret;
+	return 0;
+}
+
+static int lp5521_configure(struct i2c_client *client)
+{
+	int ret = 0;
+
+	/* Enable chip and set light to logarithmic mode*/
+	ret |= lp5521_write(client, LP5521_REG_ENABLE, 0xc0);
+
+	/* setting all color pwms to direct control mode */
+	ret |= lp5521_write(client, LP5521_REG_OP_MODE, 0x3f);
+
+	/* setting current to 4.7 mA for all channels */
+	ret |= lp5521_write(client, LP5521_REG_R_CNTRL, LP5521_CURRENT_4m7);
+	ret |= lp5521_write(client, LP5521_REG_G_CNTRL, LP5521_CURRENT_4m7);
+	ret |= lp5521_write(client, LP5521_REG_B_CNTRL, LP5521_CURRENT_4m7);
+
+	/* Enable auto-powersave, set charge pump to auto, red to battery */
+	ret |= lp5521_write(client, LP5521_REG_MISC, 0x3c);
+
+	/* initialize all channels pwm to zero */
+	ret |= lp5521_write(client, LP5521_REG_R_PWM, 0);
+	ret |= lp5521_write(client, LP5521_REG_G_PWM, 0);
+	ret |= lp5521_write(client, LP5521_REG_B_PWM, 0);
+
+	/* Not much can be done about errors at this point */
+	return ret;
+}
+
+static int lp5521_load_program(struct lp5521_chip *chip, u8 *pattern)
+{
+	struct i2c_client *client = &chip->client;
+	int ret = 0;
+
+	/* Enter load program mode for all led channels */
+	ret |= lp5521_write(client, LP5521_REG_OP_MODE, 0x15); /* 0001 0101 */
+	if (ret)
+		return ret;
+
+	if (chip->red)
+		ret |= i2c_smbus_write_i2c_block_data(client,
+						      LP5521_REG_R_PROG_MEM,
+						      LP5521_PROGRAM_LENGTH,
+						      pattern);
+	if (chip->green)
+		ret |= i2c_smbus_write_i2c_block_data(client,
+						      LP5521_REG_G_PROG_MEM,
+						      LP5521_PROGRAM_LENGTH,
+						      pattern);
+	if (chip->blue)
+		ret |= i2c_smbus_write_i2c_block_data(client,
+						      LP5521_REG_B_PROG_MEM,
+						      LP5521_PROGRAM_LENGTH,
+						      pattern);
+
+	return ret;
+}
+
+static int lp5521_run_program(struct lp5521_chip *chip)
+{
+	struct i2c_client *client = &chip->client;
+	int ret;
+	u8 mask = 0xc0;
+	u8 exec_state = 0;
+	u8 enable_reg;
+
+	ret = lp5521_read(client, LP5521_REG_ENABLE, &enable_reg);
+	if (ret)
+		goto fail;
+
+	enable_reg &= mask;
+
+	/* set all active channels exec state to countinous run*/
+	exec_state |= (chip->red   << 5);
+	exec_state |= (chip->green << 3);
+	exec_state |= (chip->blue  << 1);
+
+	enable_reg |= exec_state;
+
+	ret |= lp5521_write(client, LP5521_REG_ENABLE, enable_reg);
+
+	/* set op-mode to run for active channels, disabled for others */
+	ret |= lp5521_write(client, LP5521_REG_OP_MODE, exec_state);
+
+fail:
+	return ret;
+}
+
+/*--------------------------------------------------------------*/
+/*			Sysfs interface				*/
+/*--------------------------------------------------------------*/
+
+static ssize_t show_active_channels(struct device *dev,
+			    struct device_attribute *attr,
+			    char *buf)
+{
+	struct lp5521_chip *chip = dev_to_lp5521(dev);
+	char channels[4];
+	int pos = 0;
+
+#ifdef LED_CONNECTED_WRONG
+	if (chip->blue)
+		pos += sprintf(channels + pos, "r");
+	if (chip->green)
+		pos += sprintf(channels + pos, "g");
+	if (chip->red)
+		pos += sprintf(channels + pos, "b");
+
+#else
+	if (chip->red)
+		pos += sprintf(channels + pos, "r");
+	if (chip->green)
+		pos += sprintf(channels + pos, "g");
+	if (chip->blue)
+		pos += sprintf(channels + pos, "b");
+#endif
+
+	channels[pos] = '\0';
+
+	return sprintf(buf, "%s\n", channels);
+}
+
+static ssize_t store_active_channels(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t len)
+{
+	struct lp5521_chip *chip = dev_to_lp5521(dev);
+
+	chip->red = 0;
+	chip->green = 0;
+	chip->blue = 0;
+
+#ifdef LED_CONNECTED_WRONG
+	if (strchr(buf, 'r') != NULL)
+		chip->blue = 1;
+	if (strchr(buf, 'b') != NULL)
+		chip->red = 1;
+#else
+	if (strchr(buf, 'r') != NULL)
+		chip->red = 1;
+	if (strchr(buf, 'b') != NULL)
+		chip->blue = 1;
+#endif
+	if (strchr(buf, 'g') != NULL)
+		chip->green = 1;
+
+	return len;
+}
+
+static ssize_t show_color(struct device *dev,
+			    struct device_attribute *attr,
+			    char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int ret = 0;
+	u8 r, g, b;
+
+	ret |= lp5521_read(client, LP5521_REG_R_PWM, &r);
+	ret |= lp5521_read(client, LP5521_REG_G_PWM, &g);
+	ret |= lp5521_read(client, LP5521_REG_B_PWM, &b);
+
+	if (ret)
+		return ret;
+
+	return sprintf(buf, "%.2x:%.2x:%.2x\n", r, g, b);
+}
+
+static ssize_t store_color(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t len)
+{
+	struct lp5521_chip *chip = dev_to_lp5521(dev);
+	struct i2c_client *client = &chip->client;
+	int ret;
+	unsigned r,g,b;
+
+	ret = sscanf(buf, "%2x:%2x:%2x", &r, &g, &b);
+	if (ret != 3) {
+		return  -EINVAL;
+	}
+
+	mutex_lock(&chip->lock);
+
+	ret = lp5521_write(client, LP5521_REG_R_PWM, (u8)r);
+	ret = lp5521_write(client, LP5521_REG_G_PWM, (u8)g);
+	ret = lp5521_write(client, LP5521_REG_B_PWM, (u8)b);
+
+	mutex_unlock(&chip->lock);
+
+	return len;
+}
+
+static ssize_t store_load(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t len)
+{
+	struct lp5521_chip *chip = dev_to_lp5521(dev);
+	int  ret, nrchars, offset = 0, i = 0;
+	char c[3];
+	unsigned cmd;
+	u8 pattern[ LP5521_PROGRAM_LENGTH ] = {0};
+
+	while ((offset < len - 1) && (i < LP5521_PROGRAM_LENGTH)) {
+
+		/* separate sscanfs because length is working only for %s */
+		ret = sscanf(buf + offset, "%2s%n ", c, &nrchars);
+		ret = sscanf(c, "%2x", &cmd);
+		if (ret != 1)
+			goto fail;
+		pattern[i] = (u8)cmd;
+
+		offset += nrchars;
+		i++;
+	}
+
+	/* pattern commands are always two bytes long */
+	if (i % 2)
+		goto fail;
+
+	mutex_lock(&chip->lock);
+
+	ret = lp5521_load_program(chip, pattern);
+	mutex_unlock(&chip->lock);
+
+	if (ret) {
+		dev_err(dev, "lp5521 failed loading pattern\n");
+		return ret;
+	}
+
+	return len;
+fail:
+	dev_err(dev, "lp5521 wrong pattern format\n");
+	return -EINVAL;
+}
+
+static ssize_t show_mode(struct device *dev,
+			 struct device_attribute *attr,
+			 char *buf)
+{
+	struct lp5521_chip *chip = dev_to_lp5521(dev);
+
+	return sprintf(buf, "%s\n", chip->mode);
+}
+
+static ssize_t store_mode(struct device *dev,
+			  struct device_attribute *attr,
+			  const char *buf, size_t len)
+{
+	struct lp5521_chip *chip = dev_to_lp5521(dev);
+
+	mutex_lock(&chip->lock);
+
+	if (!strncmp(buf, "run", 3))
+		lp5521_set_mode(chip, LP5521_MODE_RUN);
+	else if (!strncmp(buf, "load", 4))
+		lp5521_set_mode(chip, LP5521_MODE_LOAD);
+	else if (!strncmp(buf, "direct", 6))
+		lp5521_set_mode(chip, LP5521_MODE_DIRECT_CONTROL);
+
+	mutex_unlock(&chip->lock);
+
+	return len;
+}
+
+static ssize_t show_current(struct device *dev,
+			    struct device_attribute *attr,
+			    char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int ret = 0;
+	u8 r_curr, g_curr, b_curr;
+
+	ret |= lp5521_read(client, LP5521_REG_R_CNTRL, &r_curr);
+	ret |= lp5521_read(client, LP5521_REG_G_CNTRL, &g_curr);
+	ret |= lp5521_read(client, LP5521_REG_B_CNTRL, &b_curr);
+
+	if (ret)
+		return ret;
+
+	r_curr = r_curr >> 4;
+	g_curr = g_curr >> 4;
+	b_curr = b_curr >> 4;
+
+	if (r_curr == g_curr && g_curr == b_curr)
+		return sprintf(buf, "%x\n", r_curr);
+	else
+		return sprintf(buf, "%x %x %x\n", r_curr, g_curr, b_curr);
+}
+
+static ssize_t store_current(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t len)
+{
+	struct lp5521_chip *chip = dev_to_lp5521(dev);
+	struct i2c_client *client = &chip->client;
+	int ret;
+	unsigned curr;
+
+	ret = sscanf(buf, "%1x", &curr);
+	if (ret != 1) {
+		return  -EINVAL;
+	}
+
+	/* current level is determined by the 4 upper bits, rest is ones */
+	curr = (curr << 4) | 0x0f;
+
+	mutex_lock(&chip->lock);
+
+	ret |= lp5521_write(client, LP5521_REG_R_CNTRL, (u8)curr);
+	ret |= lp5521_write(client, LP5521_REG_G_CNTRL, (u8)curr);
+	ret |= lp5521_write(client, LP5521_REG_B_CNTRL, (u8)curr);
+
+	mutex_unlock(&chip->lock);
+
+	return len;
+}
+
+static DEVICE_ATTR(color, S_IRUGO | S_IWUGO, show_color, store_color);
+static DEVICE_ATTR(load, S_IWUGO, NULL, store_load);
+static DEVICE_ATTR(mode, S_IRUGO | S_IWUGO, show_mode, store_mode);
+static DEVICE_ATTR(active_channels, S_IRUGO | S_IWUGO,
+		   show_active_channels, store_active_channels);
+static DEVICE_ATTR(led_current, S_IRUGO | S_IWUGO, show_current, store_current);
+
+static int lp5521_register_sysfs(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	int ret;
+
+	if ((ret = device_create_file(dev, &dev_attr_color)))
+		goto fail1;
+	if ((ret = device_create_file(dev, &dev_attr_active_channels)))
+		goto fail2;
+	if ((ret = device_create_file(dev, &dev_attr_mode)))
+		goto fail3;
+	if ((ret = device_create_file(dev, &dev_attr_led_current)))
+		goto fail4;
+	return 0;
+
+fail4:
+	device_remove_file(dev, &dev_attr_mode);
+fail3:
+	device_remove_file(dev, &dev_attr_active_channels);
+fail2:
+	device_remove_file(dev, &dev_attr_color);
+fail1:
+	return ret;
+}
+
+static void lp5521_unregister_sysfs(struct i2c_client *client)
+{
+	struct lp5521_chip *chip = client_to_lp5521(client);
+	struct device *dev = &client->dev;
+
+	device_remove_file(dev, &dev_attr_led_current);
+	device_remove_file(dev, &dev_attr_mode);
+	device_remove_file(dev, &dev_attr_active_channels);
+	device_remove_file(dev, &dev_attr_color);
+
+	if (chip->mode == LP5521_MODE_LOAD)
+		device_remove_file(dev, &dev_attr_load);
+}
+
+/*--------------------------------------------------------------*/
+/*			Set chip operating mode			*/
+/*--------------------------------------------------------------*/
+
+static int lp5521_set_mode(struct lp5521_chip *chip, char *mode)
+{
+	struct i2c_client *client = &chip->client ;
+	struct device *dev = &client->dev;
+	int ret = 0;
+
+	/* if in that mode already do nothing, except for run */
+	if (mode == chip->mode && mode != LP5521_MODE_RUN)
+		return 0;
+
+	if (mode == LP5521_MODE_RUN)
+		ret = lp5521_run_program(chip);
+
+	else if (mode == LP5521_MODE_LOAD) {
+		ret |= lp5521_write(client, LP5521_REG_OP_MODE, 0x15);
+		if ((ret |= device_create_file(dev, &dev_attr_load)))
+			goto fail;
+	}
+
+	else if (mode == LP5521_MODE_DIRECT_CONTROL)
+		ret |= lp5521_write(client, LP5521_REG_OP_MODE, 0x3F);
+
+	/* remove pattern load attribute from sysfs if not in load mode */
+	if (chip->mode == LP5521_MODE_LOAD && mode != LP5521_MODE_LOAD)
+		device_remove_file(dev, &dev_attr_load);
+
+	chip->mode = mode;
+fail:
+	return ret;
+}
+
+/*--------------------------------------------------------------*/
+/*			Probe, Attach, Remove			*/
+/*--------------------------------------------------------------*/
+static struct i2c_driver lp5521_driver;
+
+static int lp5521_probe(struct i2c_adapter *adap, int addr, int kind)
+{
+	struct i2c_client *client;
+	struct lp5521_chip *chip;
+	int ret = 0;
+
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	client = &chip->client;
+	strncpy(client->name, LP5521_DRIVER_NAME, I2C_NAME_SIZE);
+	client->addr	= addr;
+	client->adapter	= adap;
+	client->driver	= &lp5521_driver;
+	client->flags	= 0;
+
+	if ((ret = i2c_attach_client(client)) != 0) {
+		dev_err(&client->dev, "lp5521 error attaching i2c client \n");
+		goto fail1;
+	}
+
+	mutex_init(&chip->lock);
+
+	if ((ret = lp5521_configure(client)) < 0) {
+		dev_err(&client->dev, "lp5521 error configuring chip \n");
+		goto fail2;
+	}
+
+	/* Set default values */
+	chip->mode	= LP5521_MODE_DIRECT_CONTROL;
+	chip->red	= 1;
+	chip->green	= 1;
+	chip->blue	= 1;
+
+	if ((ret = lp5521_register_sysfs(client)))
+		dev_err(&client->dev, "lp5521 registering sysfs failed \n");
+
+	return ret;
+
+fail2:
+	i2c_detach_client(client);
+fail1:
+	kfree(chip);
+	return ret;
+}
+
+static int lp5521_attach_adapter(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, lp5521_probe);
+}
+
+static int lp5521_detach_client(struct i2c_client *client)
+{
+	struct lp5521_chip *chip = client_to_lp5521(client);
+	int ret;
+
+	lp5521_unregister_sysfs(client);
+
+	if ((ret = i2c_detach_client(client)) == 0)
+		kfree(chip);
+
+	return ret;
+}
+
+static struct i2c_driver lp5521_driver = {
+	.driver = {
+		.name	= LP5521_DRIVER_NAME,
+	},
+	.attach_adapter = lp5521_attach_adapter,
+	.detach_client  = lp5521_detach_client,
+};
+
+static int __init lp5521_init(void)
+{
+	int ret;
+
+	ret = i2c_add_driver(&lp5521_driver);
+
+	if (ret < 0)
+		printk(KERN_ALERT "Adding lp5521 driver failed \n");
+
+	return ret;
+}
+
+static void __exit lp5521_exit(void)
+{
+	i2c_del_driver(&lp5521_driver);
+}
+
+MODULE_AUTHOR("Mathias Nyman <mathias.nyman@nokia.com>");
+MODULE_DESCRIPTION("lp5521 LED driver");
+MODULE_LICENSE("GPL");
+
+module_init(lp5521_init);
+module_exit(lp5521_exit);
diff -ruN linux-omap-2.6/drivers/i2c/chips/Makefile maemo_src/drivers/i2c/chips/Makefile
--- linux-omap-2.6/drivers/i2c/chips/Makefile	2011-02-06 20:17:25.609999939 -0500
+++ maemo_src/drivers/i2c/chips/Makefile	2007-10-02 03:09:31.000000000 -0400
@@ -13,10 +13,13 @@
 obj-$(CONFIG_ISP1301_OMAP)	+= isp1301_omap.o
 obj-$(CONFIG_TPS65010)		+= tps65010.o
 obj-$(CONFIG_SENSORS_TLV320AIC23) += tlv320aic23.o
+obj-$(CONFIG_SENSORS_TSL2563)	+= tsl2563.o
 obj-$(CONFIG_GPIOEXPANDER_OMAP)	+= gpio_expander_omap.o
+obj-$(CONFIG_LM8323)		+= lm8323.o
 obj-$(CONFIG_MENELAUS)		+= menelaus.o
 obj-$(CONFIG_TWL4030_CORE)      += twl4030_core.o
 obj-$(CONFIG_RTC_X1205_I2C)	+= x1205.o
+obj-$(CONFIG_LP5521)		+= lp5521.o
 
 ifeq ($(CONFIG_I2C_DEBUG_CHIP),y)
 EXTRA_CFLAGS += -DDEBUG
diff -ruN linux-omap-2.6/drivers/i2c/chips/menelaus.c maemo_src/drivers/i2c/chips/menelaus.c
--- linux-omap-2.6/drivers/i2c/chips/menelaus.c	2011-02-06 20:17:25.629999941 -0500
+++ maemo_src/drivers/i2c/chips/menelaus.c	2011-02-06 20:12:12.809999940 -0500
@@ -47,11 +47,11 @@
 #include <asm/arch/gpio.h>
 #include <asm/arch/menelaus.h>
 
-#define DEBUG
+/* #define DEBUG */
 
 #define DRIVER_NAME			"menelaus"
 
-#define pr_err(fmt, arg...)	printk(KERN_ERR DRIVER_NAME ": ", ## arg);
+#define pr_err(format, arg...) dev_err(&menelaus.client.dev, format, ## arg)
 
 #define MENELAUS_I2C_ADDRESS		0x72
 
@@ -359,9 +359,9 @@
 		int b;
 
 		if (enable)
-			ret |= 1 << 1;
+			val |= 1 << 1;
 		else
-			ret &= ~(1 << 1);
+			val &= ~(1 << 1);
 		b = menelaus_read_reg(MENELAUS_MCT_CTRL2);
 		b &= ~0x03;
 		b |= power;
@@ -424,6 +424,8 @@
 	u8 vtg_shift;
 	u8 vtg_bits;
 	u8 mode_reg;
+	u8 mode_v_norm;
+	u8 mode_v_sleep;
 };
 
 struct menelaus_vtg_value {
@@ -431,47 +433,71 @@
 	u16 val;
 };
 
-static int menelaus_set_voltage(const struct menelaus_vtg *vtg, int mV,
-				int vtg_val, int mode)
+static int menelaus_get_vtg_value(int vtg, const struct menelaus_vtg_value *tbl,
+				  int n)
 {
-	int val, ret;
+	int i;
 
-	mutex_lock(&menelaus.lock);
-	if (vtg == 0)
-		goto set_voltage;
+	for (i = 0; i < n; i++, tbl++)
+		if (tbl->vtg == vtg)
+			return tbl->val;
+	return -EINVAL;
+}
+
+static int _menelaus_set_voltage(const struct menelaus_vtg *vtg,
+				 int mV, int low_power,
+				 const struct menelaus_vtg_value *tbl, int n)
+{
+	int val, ret, vtg_val;
+	int mode;
+
+	if (mV == 0) {
+		/* shut off regulator but don't touch the voltage(!) */
+		dev_info(&menelaus.client.dev, "Shutting off '%s'\n", vtg->name);
+		return menelaus_write_reg(vtg->mode_reg, 0);
+	}
 
 	ret = menelaus_read_reg(vtg->vtg_reg);
 	if (ret < 0)
-		goto out;
+		return ret;
+
+	vtg_val = menelaus_get_vtg_value(mV, tbl, n);
+	if (vtg_val < 0)
+		return -EINVAL;
+
 	val = ret & ~(((1 << vtg->vtg_bits) - 1) << vtg->vtg_shift);
 	val |= vtg_val << vtg->vtg_shift;
-#ifdef DEBUG
-	printk("menelaus: Setting voltage '%s' to %d mV (reg 0x%02x, val 0x%02x)\n",
-	       vtg->name, mV, vtg->vtg_reg, val);
-#endif
+
 	ret = menelaus_write_reg(vtg->vtg_reg, val);
 	if (ret < 0)
-		goto out;
-set_voltage:
+		return ret;
+
+	mode = (low_power)? vtg->mode_v_sleep: vtg->mode_v_norm;
 	ret = menelaus_write_reg(vtg->mode_reg, mode);
-out:
-	mutex_unlock(&menelaus.lock);
-	if (ret == 0) {
-		/* Wait for voltage to stabilize */
-		msleep(1);
-	}
+	if (ret < 0)
+		return ret;
+
+	dev_info(&menelaus.client.dev,
+		"Setting voltage '%s' to %d mV (reg 0x%02x, val 0x%02x)\n",
+		vtg->name, mV, vtg->vtg_reg, val);
+
+	/* Wait for voltage to stabilize */
+	msleep(1);
+
 	return ret;
 }
 
-static int menelaus_get_vtg_value(int vtg, const struct menelaus_vtg_value *tbl,
-				  int n)
+static int menelaus_set_voltage(const struct menelaus_vtg *vtg,
+				int mV, int low_power,
+				const struct menelaus_vtg_value *tbl, int n)
 {
-	int i;
+	int ret;
 
-	for (i = 0; i < n; i++, tbl++)
-		if (tbl->vtg == vtg)
-			return tbl->val;
-	return -EINVAL;
+	mutex_lock(&menelaus.lock);
+	ret = _menelaus_set_voltage(vtg, mV, low_power, tbl, n);
+	mutex_unlock(&menelaus.lock);
+
+	return ret;
 }
 
 /* Vcore can be programmed in two ways:
@@ -511,9 +537,8 @@
 	val = menelaus_get_vtg_value(mV, vcore_values, ARRAY_SIZE(vcore_values));
 	if (val < 0)
 		return -EINVAL;
-#ifdef DEBUG
-	printk("menelaus: Setting VCORE to %d mV (val 0x%02x)\n", mV, val);
-#endif
+
+	dev_info(&menelaus.client.dev, "Setting VCORE to %d mV (val 0x%02x)\n", mV, val);
 
 	/* Set SW mode and the voltage in one go. */
 	mutex_lock(&menelaus.lock);
@@ -537,10 +562,9 @@
 	if (fval < 0)
 		return -EINVAL;
 
-#ifdef DEBUG
-	printk("menelaus: Setting VCORE FLOOR to %d mV and ROOF to %d mV\n",
-	       floor_mV, roof_mV);
-#endif
+	dev_dbg(&menelaus.client.dev,
+		"Setting VCORE FLOOR to %d mV and ROOF to %d mV\n",
+		floor_mV, roof_mV);
 
 	mutex_lock(&menelaus.lock);
 	ret = menelaus_write_reg(MENELAUS_VCORE_CTRL3, fval);
@@ -550,12 +574,20 @@
 	if (ret < 0)
 		goto out;
 	if (!menelaus.vcore_hw_mode) {
+#define POWEROK_LOW_COUNT 3
 		val = menelaus_read_reg(MENELAUS_VCORE_CTRL1);
-		val |= ((1 << 7) | (1 << 5)); /* HW mode, turn OFF byte comparator */
+		val |= ((1 << 7) | (1 << 5)); /* HW mode, turn ON byte comparator */
+		val &= ~(1 << 6); /* turn OFF Stepping */
 		ret = menelaus_write_reg(MENELAUS_VCORE_CTRL1, val);
+		if (ret < 0)
+			goto out;
+		ret = menelaus_write_reg(MENELAUS_VCORE_CTRL2, POWEROK_LOW_COUNT);
+		if (ret < 0)
+			goto out;
 		menelaus.vcore_hw_mode = 1;
+		dev_dbg(&menelaus.client.dev, "HW mode set: %08x\n",
+				menelaus_read_reg(MENELAUS_VCORE_CTRL1));
 	}
-	msleep(1);
 out:
 	mutex_unlock(&menelaus.lock);
 	return ret;
@@ -567,6 +599,8 @@
 	.vtg_shift = 0,
 	.vtg_bits = 2,
 	.mode_reg = MENELAUS_LDO_CTRL3,
+	.mode_v_norm  = 2,
+	.mode_v_sleep = 1,
 };
 
 static const struct menelaus_vtg_value vmem_values[] = {
@@ -578,15 +612,8 @@
 
 int menelaus_set_vmem(unsigned int mV)
 {
-	int val;
-
-	if (mV == 0)
-		return menelaus_set_voltage(&vmem_vtg, 0, 0, 0);
-
-	val = menelaus_get_vtg_value(mV, vmem_values, ARRAY_SIZE(vmem_values));
-	if (val < 0)
-		return -EINVAL;
-	return menelaus_set_voltage(&vmem_vtg, mV, val, 0x02);
+	return menelaus_set_voltage(&vmem_vtg, mV, 0,
+				    vmem_values, ARRAY_SIZE(vmem_values));
 }
 EXPORT_SYMBOL(menelaus_set_vmem);
 
@@ -596,6 +623,8 @@
 	.vtg_shift = 2,
 	.vtg_bits = 2,
 	.mode_reg = MENELAUS_LDO_CTRL4,
+	.mode_v_norm  = 2,
+	.mode_v_sleep = 1,
 };
 
 static const struct menelaus_vtg_value vio_values[] = {
@@ -607,15 +636,8 @@
 
 int menelaus_set_vio(unsigned int mV)
 {
-	int val;
-
-	if (mV == 0)
-		return menelaus_set_voltage(&vio_vtg, 0, 0, 0);
-
-	val = menelaus_get_vtg_value(mV, vio_values, ARRAY_SIZE(vio_values));
-	if (val < 0)
-		return -EINVAL;
-	return menelaus_set_voltage(&vio_vtg, mV, val, 0x02);
+	return menelaus_set_voltage(&vio_vtg, mV, 0,
+				    vio_values, ARRAY_SIZE(vio_values));
 }
 EXPORT_SYMBOL(menelaus_set_vio);
 
@@ -636,6 +658,8 @@
 	.vtg_shift = 0,
 	.vtg_bits = 3,
 	.mode_reg = MENELAUS_DCDC_CTRL2,
+	.mode_v_norm  = 3,
+	.mode_v_sleep = 1,
 };
 
 static const struct menelaus_vtg vdcdc3_vtg = {
@@ -644,27 +668,23 @@
 	.vtg_shift = 3,
 	.vtg_bits = 3,
 	.mode_reg = MENELAUS_DCDC_CTRL3,
+	.mode_v_norm  = 3,
+	.mode_v_sleep = 1,
 };
 
-int menelaus_set_vdcdc(int dcdc, unsigned int mV)
+int menelaus_set_vdcdc(int dcdc, unsigned int mV, int low_power)
 {
 	const struct menelaus_vtg *vtg;
-	int val;
 
-	if (dcdc != 2 && dcdc != 3)
-		return -EINVAL;
 	if (dcdc == 2)
 		vtg = &vdcdc2_vtg;
-	else
+	else if (dcdc == 3)
 		vtg = &vdcdc3_vtg;
-
-	if (mV == 0)
-		return menelaus_set_voltage(vtg, 0, 0, 0);
-
-	val = menelaus_get_vtg_value(mV, vdcdc_values, ARRAY_SIZE(vdcdc_values));
-	if (val < 0)
+	else
 		return -EINVAL;
-	return menelaus_set_voltage(vtg, mV, val, 0x03);
+
+	return menelaus_set_voltage(vtg, mV, low_power,
+				    vdcdc_values, ARRAY_SIZE(vdcdc_values));
 }
 
 static const struct menelaus_vtg_value vmmc_values[] = {
@@ -680,23 +700,17 @@
 	.vtg_shift = 6,
 	.vtg_bits = 2,
 	.mode_reg = MENELAUS_LDO_CTRL7,
+	.mode_v_norm  = 2,
+	.mode_v_sleep = 1,
 };
 
-int menelaus_set_vmmc(unsigned int mV)
+int menelaus_set_vmmc(unsigned int mV, int low_power)
 {
-	int val;
-
-	if (mV == 0)
-		return menelaus_set_voltage(&vmmc_vtg, 0, 0, 0);
-
-	val = menelaus_get_vtg_value(mV, vmmc_values, ARRAY_SIZE(vmmc_values));
-	if (val < 0)
-		return -EINVAL;
-	return menelaus_set_voltage(&vmmc_vtg, mV, val, 0x02);
+	return menelaus_set_voltage(&vmmc_vtg, mV, low_power,
+			vmmc_values, ARRAY_SIZE(vmmc_values));
 }
 EXPORT_SYMBOL(menelaus_set_vmmc);
 
-
 static const struct menelaus_vtg_value vaux_values[] = {
 	{ 1500, 0 },
 	{ 1800, 1 },
@@ -710,19 +724,14 @@
 	.vtg_shift = 4,
 	.vtg_bits = 2,
 	.mode_reg = MENELAUS_LDO_CTRL6,
+	.mode_v_norm  = 2,
+	.mode_v_sleep = 1,
 };
 
 int menelaus_set_vaux(unsigned int mV)
 {
-	int val;
-
-	if (mV == 0)
-		return menelaus_set_voltage(&vaux_vtg, 0, 0, 0);
-
-	val = menelaus_get_vtg_value(mV, vaux_values, ARRAY_SIZE(vaux_values));
-	if (val < 0)
-		return -EINVAL;
-	return menelaus_set_voltage(&vaux_vtg, mV, val, 0x02);
+	return menelaus_set_voltage(&vaux_vtg, mV, 0,
+			vaux_values, ARRAY_SIZE(vaux_values));
 }
 EXPORT_SYMBOL(menelaus_set_vaux);
 
@@ -740,9 +749,10 @@
 	ret = menelaus_write_reg(MENELAUS_SLEEP_CTRL2, val);
 	if (ret < 0)
 		goto out;
-#ifdef DEBUG
-	printk("menelaus: regulator sleep configuration: %02x\n", val);
-#endif
+
+	dev_info(&menelaus.client.dev,
+		"regulator sleep configuration: %02x\n", val);
+
 	ret = menelaus_read_reg(MENELAUS_GPIO_CTRL);
 	if (ret < 0)
 		goto out;
@@ -852,7 +862,7 @@
 	err = request_irq(menelaus.irq, menelaus_irq, IRQF_DISABLED,
 			  DRIVER_NAME, &menelaus);
 	if (err) {
-		printk(KERN_ERR "Could not get Menelaus IRQ\n");
+		pr_err("Could not get Menelaus IRQ\n");
 		goto fail2;
 	}
 
@@ -865,10 +875,13 @@
 	val = menelaus_read_reg(MENELAUS_VCORE_CTRL1);
 	if (val < 0)
 		goto fail3;
-	if (val & (1 << 7))
+	if (val & (1 << 7)) {
+		dev_dbg(&menelaus.client.dev, "HW mode set\n");
 		menelaus.vcore_hw_mode = 1;
-	else
+	} else {
+		dev_dbg(&menelaus.client.dev, "SW mode set\n");
 		menelaus.vcore_hw_mode = 0;
+	}
 
 	if (menelaus_pdata != NULL && menelaus_pdata->late_init != NULL) {
 		err = menelaus_pdata->late_init(&c->dev);
@@ -920,7 +933,7 @@
 	.driver = {
 		.name		= DRIVER_NAME,
 	},
-	.id		= I2C_DRIVERID_MISC, /*FIXME:accroding to i2c-ids.h */
+	.id		= I2C_DRIVERID_MISC, /* FIXME: accroding to i2c-ids.h */
 	.class		= I2C_CLASS_HWMON,
 	.attach_adapter	= menelaus_scan_bus,
 	.detach_client	= menelaus_remove,
@@ -928,22 +941,14 @@
 
 static int __init menelaus_init(void)
 {
-	int res;
-
-	if ((res = i2c_add_driver(&menelaus_i2c_driver)) < 0) {
-		pr_err("driver registration failed\n");
-		return res;
-	}
-
-	return 0;
+	return i2c_add_driver(&menelaus_i2c_driver);
 }
 
 static void __exit menelaus_exit(void)
 {
-	if (i2c_del_driver(&menelaus_i2c_driver) < 0)
-		pr_err("driver remove failed\n");
-
 	/* FIXME: Shutdown menelaus parts that can be shut down */
+	i2c_del_driver(&menelaus_i2c_driver);
+
 }
 
 void __init menelaus_set_platform_data(struct menelaus_platform_data *pdata)
@@ -957,3 +962,4 @@
 
 module_init(menelaus_init);
 module_exit(menelaus_exit);
+
diff -ruN linux-omap-2.6/drivers/i2c/chips/tsl2563.c maemo_src/drivers/i2c/chips/tsl2563.c
--- linux-omap-2.6/drivers/i2c/chips/tsl2563.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/i2c/chips/tsl2563.c	2007-10-02 03:09:31.000000000 -0400
@@ -0,0 +1,1052 @@
+/*
+ * drivers/i2c/chips/tsl2563.c
+ *
+ * Copyright (C) 2007 Nokia Corporation
+ *
+ * Written by Timo O. Karjalainen <timo.o.karjalainen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/mutex.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/hwmon.h>
+#include <linux/err.h>
+#include <linux/tsl2563.h>
+#include <asm/arch/board.h>
+
+#define DRIVER_NAME  "tsl2563"
+
+#define DEBUG
+
+#undef pr_info
+#undef pr_debug
+#define pr_info(fmt, arg...)	printk(KERN_INFO  DRIVER_NAME ": " fmt, ## arg)
+#define pr_warn(fmt, arg...)	printk(KERN_WARNING DRIVER_NAME ": " fmt, ## arg)
+#define pr_err(fmt, arg...)	printk(KERN_ERR   DRIVER_NAME ": " fmt, ## arg)
+#define pr_debug(fmt, arg...)	printk(KERN_DEBUG DRIVER_NAME ": " fmt, ## arg)
+
+/* Use this many bits for fraction part. */
+#define ADC_FRAC_BITS		(14)
+
+/* Given number of 1/10000's in ADC_FRAC_BITS precision. */
+#define FRAC10K(f)		(((f) * (1L << (ADC_FRAC_BITS))) / (10000))
+
+/* Bits used for fraction in calibration coefficients.*/
+#define CALIB_FRAC_BITS		(10)
+/* 0.5 in CALIB_FRAC_BITS precision */
+#define CALIB_FRAC_HALF		(1 << (CALIB_FRAC_BITS - 1))
+/* Make a fraction from a number n that was multiplied with b. */
+#define CALIB_FRAC(n,b)		(((n) << CALIB_FRAC_BITS) / (b))
+/* Decimal 10^(digits in sysfs presentation) */
+#define CALIB_BASE_SYSFS	(1000)
+
+/*
+ * Type used to store calibration coefficients. This is a fixed point number
+ * having CALIB_FRAC_BITS bits of fraction.
+ */
+typedef unsigned long calib_t;
+
+
+#define TSL2563_CMD		(0x80)
+#define TSL2563_CLEARINT	(0x40)
+
+#define TSL2563_REG_CTRL	(0x00)
+#define TSL2563_REG_TIMING	(0x01)
+#define TSL2563_REG_LOWLOW	(0x02) /* data0 low threshold, 2 bytes */
+#define TSL2563_REG_LOWHIGH	(0x03)
+#define TSL2563_REG_HIGHLOW	(0x04) /* data0 high threshold, 2 bytes */
+#define TSL2563_REG_HIGHHIGH	(0x05)
+#define TSL2563_REG_INT		(0x06)
+#define TSL2563_REG_ID		(0x0a)
+#define TSL2563_REG_DATA0LOW	(0x0c) /* broadband sensor value, 2 bytes */
+#define TSL2563_REG_DATA0HIGH	(0x0d)
+#define TSL2563_REG_DATA1LOW	(0x0e) /* infrared sensor value, 2 bytes */
+#define TSL2563_REG_DATA1HIGH	(0x0f)
+
+#define TSL2563_CTRL_POWER_ON	(0x03)
+#define TSL2563_CTRL_POWER_OFF	(0x00)
+#define TSL2563_CTRL_POWER_MASK (0x03)
+
+#define TSL2563_TIMING_13MS	(0x00)
+#define TSL2563_TIMING_100MS	(0x01)
+#define TSL2563_TIMING_400MS	(0x02)
+#define TSL2563_TIMING_MASK	(0x03)
+#define TSL2563_TIMING_GAIN16	(0x10)
+#define TSL2563_TIMING_GAIN1	(0x00)
+
+#define TSL2563_INT_LEVEL	(0x10)
+#define TSL2563_INT_PERSIST(n)	((n) & 0x0F)
+
+static struct tsl2563_platform_data *tsl2563_pdata;
+
+struct tsl2563_gainlevel_coeff {
+	u8 gaintime;
+	u16 min;
+	u16 max;
+};
+
+static struct tsl2563_gainlevel_coeff tsl2563_gainlevel_table[] = {
+	{TSL2563_TIMING_400MS | TSL2563_TIMING_GAIN16,	0,	 65534},
+	{TSL2563_TIMING_400MS | TSL2563_TIMING_GAIN1,	2048,	 65534},
+	{TSL2563_TIMING_100MS | TSL2563_TIMING_GAIN1,	4095,	 37177},
+	{TSL2563_TIMING_13MS | TSL2563_TIMING_GAIN1,	3000,	 65535},
+};
+
+static unsigned short normal_i2c[] = {
+	0x29,	/* 0101 001x, address select low */
+	0x39,	/* 0111 001x, address select floats */
+	0x49,	/* 1001 001x, address select high */
+	I2C_CLIENT_END
+};
+
+I2C_CLIENT_INSMOD;
+
+struct tsl2563_chip {
+	struct mutex		lock;
+	struct i2c_client	client;
+	struct class_device	*class_dev;
+
+	int			irq;
+	pm_message_t		state;
+
+	void			(*set_power)(struct device *dev, int on);
+	int			power_count;
+
+	/*
+	 * Remember configuration so we can reconfigure the chip after
+	 * a suspend.
+	 */
+	struct tsl2563_gainlevel_coeff *gainlevel;
+
+	unsigned		low_thres; /* Thresholds are in lux */
+	unsigned		high_thres;
+	u8			intr;
+
+	/* Calibration coefficients */
+	calib_t			calib0;
+	calib_t			calib1;
+
+	/* Cache current values, to be returned while suspended */
+	u32			data0;
+	u32			data1;
+};
+
+#define client_to_tsl2563(c)	container_of(c, struct tsl2563_chip, client)
+#define dev_to_tsl2563(d)	container_of(d, struct tsl2563_chip, \
+					     client.dev)
+
+static int tsl2563_write(struct i2c_client *client, u8 reg, u8 value)
+{
+	int ret;
+	u8 buf[2];
+
+	buf[0] = TSL2563_CMD | reg;
+	buf[1] = value;
+
+	ret = i2c_master_send(client, buf, sizeof(buf));
+	return (ret == sizeof(buf)) ? 0 : ret;
+}
+
+static int tsl2563_read(struct i2c_client *client, u8 reg, void *buf, int len)
+{
+	int ret;
+	u8 cmd = TSL2563_CMD | reg;
+
+	ret = i2c_master_send(client, &cmd, sizeof(cmd));
+	if (ret != sizeof(cmd)) {
+		return ret;
+	}
+
+	return i2c_master_recv(client, buf, len);
+}
+
+static int tsl2563_set_power(struct tsl2563_chip *chip, int on)
+{
+	struct i2c_client *client = &chip->client;
+	u8 cmd;
+
+	cmd = on ? TSL2563_CTRL_POWER_ON : TSL2563_CTRL_POWER_OFF;
+	return tsl2563_write(client, TSL2563_REG_CTRL, cmd);
+}
+
+/*
+ * Return value is 0 for off, 1 for on, or a negative error
+ * code if reading failed.
+ */
+static int tsl2563_get_power(struct tsl2563_chip *chip)
+{
+	struct i2c_client *client = &chip->client;
+	int ret;
+	u8 val;
+
+	ret = tsl2563_read(client, TSL2563_REG_CTRL, &val, sizeof(val));
+	if (ret != sizeof(val))
+		return ret;
+
+	return (val & TSL2563_CTRL_POWER_MASK) == TSL2563_CTRL_POWER_ON;
+}
+
+static int tsl2563_configure(struct tsl2563_chip *chip)
+{
+	struct i2c_client *client = &chip->client;
+	int r;
+
+	if ((r = tsl2563_write(client, TSL2563_REG_LOWHIGH,
+			       chip->low_thres >> 8)))
+		goto out;
+	if ((r = tsl2563_write(client, TSL2563_REG_LOWLOW,
+			       chip->low_thres & 0xff)))
+		goto out;
+	if ((r = tsl2563_write(client, TSL2563_REG_HIGHHIGH,
+			       chip->high_thres >> 8)))
+		goto out;
+	if ((r = tsl2563_write(client, TSL2563_REG_HIGHLOW,
+			       chip->high_thres & 0xff)))
+		goto out;
+
+	if ((r = tsl2563_write(client, TSL2563_REG_TIMING,
+			       chip->gainlevel->gaintime)))
+		goto out;
+
+	r = tsl2563_write(client, TSL2563_REG_INT, chip->intr);
+
+out:
+	return r;
+}
+
+static int tsl2563_power_inc(struct tsl2563_chip *chip)
+{
+	int restarted = 0;
+	if (!chip->power_count++) {
+		if (chip->set_power) {
+			chip->set_power(&chip->client.dev, 1);
+			/*
+			 * This is optimization that we will re-configure the
+			 * chip only if it was really unpowered. This is
+			 * due that in some platform, platform specific
+			 * set_power could only force power on but not off.
+			 * Re-configuration is necessary only when the chip
+			 * power really went down
+			 */
+			if (!tsl2563_get_power(chip)) {
+				tsl2563_set_power(chip, 1);
+				tsl2563_configure(chip);
+				restarted = 1;
+			}
+		} else {
+			tsl2563_set_power(chip, 1);
+			tsl2563_configure(chip);
+			restarted = 1;
+		}
+	}
+	return restarted;
+}
+
+static void tsl2563_power_dec(struct tsl2563_chip *chip)
+{
+	if (!--chip->power_count) {
+		if (chip->set_power)
+			chip->set_power(&chip->client.dev, 0);
+		else
+			tsl2563_set_power(chip, 0);
+	}
+}
+
+static int tsl2563_detect(struct tsl2563_chip *chip)
+{
+	int ret;
+
+	if ((ret = tsl2563_set_power(chip, 1)))
+		return ret;
+
+	ret = tsl2563_get_power(chip);
+	if (ret < 0)
+		return ret;
+
+	return ret ? 0 : -ENODEV;
+}
+
+static int tsl2563_read_id(struct tsl2563_chip *chip, u8 *id)
+{
+	struct i2c_client *client = &chip->client;
+	int ret;
+
+	ret = tsl2563_read(client, TSL2563_REG_ID, id, sizeof(*id));
+	if (ret != sizeof(*id))
+		return ret;
+
+	return 0;
+}
+
+/*
+ * "Normalized" ADC value is one obtained with 400ms of integration time and
+ * 16x gain. This function returns the number of bits of shift needed to
+ * convert between normalized values and HW values obtained using given
+ * timing and gain settings.
+ */
+static int adc_shiftbits(u8 timing)
+{
+	int shift = 0;
+
+	switch (timing & TSL2563_TIMING_MASK) {
+	case TSL2563_TIMING_13MS:
+		shift += 5;
+		break;
+	case TSL2563_TIMING_100MS:
+		shift += 2;
+		break;
+	case TSL2563_TIMING_400MS:
+		/* no-op */
+		break;
+	}
+
+	if (!(timing & TSL2563_TIMING_GAIN16))
+		shift += 4;
+
+	return shift;
+}
+
+/* Convert a HW ADC value to normalized scale. */
+static u32 normalize_adc(u16 adc, u8 timing)
+{
+	return adc << adc_shiftbits(timing);
+}
+
+/* Convert normalized ADC value to HW value. */
+static u16 denormalize_adc(u32 normal, u8 timing)
+{
+	return normal >> adc_shiftbits(timing);
+}
+
+static void tsl2563_wait_adc(struct tsl2563_chip *chip)
+{
+	unsigned int delay;
+
+	switch (chip->gainlevel->gaintime & TSL2563_TIMING_MASK) {
+	case TSL2563_TIMING_13MS:
+		delay = 14;
+		break;
+	case TSL2563_TIMING_100MS:
+		delay = 101;
+		break;
+	default:
+		delay = 402;
+	}
+	/*
+	 * TODO: Make sure that we wait at least required delay but why we
+	 * have to extend it one tick more?
+	 */
+	schedule_timeout_interruptible(msecs_to_jiffies(delay) + 2);
+}
+
+static int tsl2563_adjust_gainlevel(struct tsl2563_chip *chip, u16 adc)
+{
+	struct i2c_client *client = &chip->client;
+
+	if (adc > chip->gainlevel->max || adc < chip->gainlevel->min) {
+
+		(adc > chip->gainlevel->max) ?
+			chip->gainlevel++ : chip->gainlevel--;
+
+		tsl2563_write(client, TSL2563_REG_TIMING,
+			      chip->gainlevel->gaintime);
+
+		tsl2563_wait_adc(chip);
+		tsl2563_wait_adc(chip);
+
+		return 1;
+	} else
+		return 0;
+}
+
+static int tsl2563_get_adc(struct tsl2563_chip *chip)
+{
+	struct i2c_client *client = &chip->client;
+	u8 buf0[2], buf1[2];
+	u16 adc0, adc1;
+	int retry = 1;
+	int ret = 0;
+
+	/* Wait over first integration cycle if we just powered up */
+	if (tsl2563_power_inc(chip))
+		tsl2563_wait_adc(chip);
+
+	if (chip->state.event != PM_EVENT_ON)
+		goto out;
+
+	while (retry) {
+		ret = tsl2563_read(client,
+				   TSL2563_REG_DATA0LOW | TSL2563_CLEARINT,
+				   buf0, sizeof(buf0));
+		if (ret != sizeof(buf0))
+			goto out;
+
+		ret = tsl2563_read(client, TSL2563_REG_DATA1LOW,
+				   buf1, sizeof(buf1));
+		if (ret != sizeof(buf1))
+			goto out;
+
+		adc0 = (buf0[1] << 8) + buf0[0];
+		adc1 = (buf1[1] << 8) + buf1[0];
+
+		retry = tsl2563_adjust_gainlevel(chip, adc0);
+	}
+
+	chip->data0 = normalize_adc(adc0, chip->gainlevel->gaintime);
+	chip->data1 = normalize_adc(adc1, chip->gainlevel->gaintime);
+
+	ret = 0;
+out:
+	tsl2563_power_dec(chip);
+
+	return ret;
+}
+
+static inline int calib_to_sysfs(calib_t calib)
+{
+	return (int) (((calib * CALIB_BASE_SYSFS) +
+		       CALIB_FRAC_HALF) >> CALIB_FRAC_BITS);
+}
+
+static inline calib_t calib_from_sysfs(int value)
+{
+	return (((calib_t) value) << CALIB_FRAC_BITS) / CALIB_BASE_SYSFS;
+}
+
+/*
+ * Conversions between lux and ADC values.
+ *
+ * The basic formula is lux = c0 * adc0 - c1 * adc1, where c0 and c1 are
+ * appropriate constants. Different constants are needed for different
+ * kinds of light, determined by the ratio adc1/adc0 (basically the ratio
+ * of the intensities in infrared and visible wavelengths). lux_table below
+ * lists the upper threshold of the adc1/adc0 ratio and the corresponding
+ * constants.
+ */
+
+struct tsl2563_lux_coeff {
+	unsigned long ch_ratio;
+	unsigned long ch0_coeff;
+	unsigned long ch1_coeff;
+};
+
+static const struct tsl2563_lux_coeff lux_table[] = {
+	{ FRAC10K(1300),	FRAC10K(315),	FRAC10K(262)	},
+	{ FRAC10K(2600),	FRAC10K(337),	FRAC10K(430)	},
+	{ FRAC10K(3900),	FRAC10K(363),	FRAC10K(529)	},
+	{ FRAC10K(5200),	FRAC10K(392),	FRAC10K(605)	},
+	{ FRAC10K(6500),	FRAC10K(229),	FRAC10K(291)	},
+	{ FRAC10K(8000),	FRAC10K(157),	FRAC10K(180)	},
+	{ FRAC10K(13000),	FRAC10K(34),	FRAC10K(26)	},
+	{ ULONG_MAX,		0,		0		}
+};
+
+/*
+ * Convert normalized, scaled ADC values to lux.
+ */
+static unsigned int adc_to_lux(u32 adc0, u32 adc1)
+{
+	const struct tsl2563_lux_coeff *lp = lux_table;
+	unsigned long ratio, lux, ch0 = adc0, ch1 = adc1;
+
+	ratio = ch0 ? ((ch1 << ADC_FRAC_BITS) / ch0) : ULONG_MAX;
+
+	while (lp->ch_ratio < ratio)
+		lp++;
+
+	lux = ch0 * lp->ch0_coeff - ch1 * lp->ch1_coeff;
+
+	return (unsigned int) (lux >> ADC_FRAC_BITS);
+}
+
+/*
+ * Approximate a channel0 ADC value from a lux value.
+ * This is needed for setting HW interrupt thresholds as ADC values,
+ * whereas userspace requests the thresholds in lux.
+ * This reverse conversion cannot be done exactly, since for any given
+ * adc0 the lux value depends on adc1. However, in "short range" the
+ * kind of light probably stays the same (only the intensity changes).
+ * Therefore we do a simple linear estimate from the current lux, as computed
+ * from the given ADC values now, to the target lux. This should be reasonably
+ * close assuming that the target lux is relatively close to current lux.
+ */
+static u32 lux_to_adc(unsigned int lux, u32 now0, u32 now1)
+{
+	unsigned long luxnow, luxtarget = lux;
+
+	luxnow = adc_to_lux(now0, now1);
+	return (u32) ((now0 * luxtarget) / luxnow);
+
+}
+
+static ssize_t tsl2563_adc_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct tsl2563_chip *chip = dev_to_tsl2563(dev);
+	int ret;
+
+	mutex_lock(&chip->lock);
+
+	ret = tsl2563_get_adc(chip);
+	if (ret)
+		return ret;
+
+	ret = snprintf(buf, PAGE_SIZE, "%d %d\n", chip->data0, chip->data1);
+	mutex_unlock(&chip->lock);
+
+	return ret;
+}
+
+/* Apply calibration coefficient to ADC count. */
+static u32 calib_adc(u32 adc, calib_t calib)
+{
+	unsigned long scaled = adc;
+
+	scaled *= calib;
+	scaled >>= CALIB_FRAC_BITS;
+
+	return (u32) scaled;
+}
+
+static ssize_t tsl2563_lux_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct tsl2563_chip *chip = dev_to_tsl2563(dev);
+	u32 calib0, calib1;
+	int ret;
+
+	mutex_lock(&chip->lock);
+
+	ret = tsl2563_get_adc(chip);
+	if (ret)
+		goto out;
+
+	calib0 = calib_adc(chip->data0, chip->calib0);
+	calib1 = calib_adc(chip->data1, chip->calib1);
+
+	ret = snprintf(buf, PAGE_SIZE, "%d\n", adc_to_lux(calib0, calib1));
+
+out:
+	mutex_unlock(&chip->lock);
+	return ret;
+}
+
+static ssize_t format_calib(char *buf, int len, calib_t calib)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", calib_to_sysfs(calib));
+}
+
+static ssize_t tsl2563_calib0_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct tsl2563_chip *chip = dev_to_tsl2563(dev);
+	int ret;
+
+	mutex_lock(&chip->lock);
+	ret = format_calib(buf, PAGE_SIZE, chip->calib0);
+	mutex_unlock(&chip->lock);
+	return ret;
+}
+
+static ssize_t tsl2563_calib1_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct tsl2563_chip *chip = dev_to_tsl2563(dev);
+	int ret;
+
+	mutex_lock(&chip->lock);
+	ret = format_calib(buf, PAGE_SIZE, chip->calib1);
+	mutex_unlock(&chip->lock);
+	return ret;
+}
+
+#if 0 /* FIXME: disabled until fixed to take into account powering changes */
+static ssize_t tsl2563_lowthres_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct tsl2563_chip *chip = dev_to_tsl2563(dev);
+	int ret;
+
+	mutex_lock(&chip->lock);
+	ret = snprintf(buf, PAGE_SIZE, "%d\n", chip->low_thres);
+	mutex_unlock(&chip->lock);
+	return ret;
+}
+
+static ssize_t tsl2563_highthres_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct tsl2563_chip *chip = dev_to_tsl2563(dev);
+	int ret;
+
+	mutex_lock(&chip->lock);
+	ret = snprintf(buf, PAGE_SIZE, "%d\n", chip->high_thres);
+	mutex_unlock(&chip->lock);
+	return ret;
+}
+
+static ssize_t tsl2563_lowthres_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t len)
+{
+	struct tsl2563_chip *chip = dev_to_tsl2563(dev);
+	struct i2c_client *client = &chip->client;
+	int value, ret = 0;
+
+	if (1 != sscanf(buf, "%u", &value)) {
+		ret = -EINVAL;
+		goto out1;
+	}
+
+	mutex_lock(&chip->lock);
+	chip->low_thres = value;
+
+	if (chip->state.event == PM_EVENT_ON) {
+		u16 adc;
+
+		/*
+		 * TODO: should we reread ADC counts from the chip or are
+		 * the cached values recent enough?
+		 */
+		adc = lux_to_adc(value, chip->data0, chip->data1);
+		adc = denormalize_adc(adc, chip->gainlevel->gaintime);
+
+		if ((ret = tsl2563_write(client,
+					 TSL2563_REG_LOWHIGH, adc >> 8)))
+			goto out2;
+
+		if ((ret = tsl2563_write(client,
+					 TSL2563_REG_LOWLOW, adc & 0xff)))
+			goto out2;
+
+		ret = len;
+	}
+
+out2:
+	mutex_unlock(&chip->lock);
+out1:
+	return ret;
+}
+
+static ssize_t tsl2563_highthres_store(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t len)
+{
+	struct tsl2563_chip *chip = dev_to_tsl2563(dev);
+	struct i2c_client *client = &chip->client;
+	int value, ret = 0;
+
+	if (1 != sscanf(buf, "%u", &value)) {
+		ret = -EINVAL;
+		goto out1;
+	}
+
+	mutex_lock(&chip->lock);
+	chip->high_thres = value;
+
+	if (chip->state.event == PM_EVENT_ON) {
+		u16 adc;
+
+		/*
+		 * TODO: should we reread ADC counts from the chip or are
+		 * the cached values recent enough?
+		 */
+		adc = lux_to_adc(value, chip->data0, chip->data1);
+		adc = denormalize_adc(adc, chip->gainlevel->gaintime);
+
+		if ((ret = tsl2563_write(client,
+					 TSL2563_REG_HIGHHIGH, adc >> 8)))
+			goto out2;
+
+		if ((ret = tsl2563_write(client,
+					 TSL2563_REG_HIGHLOW, adc & 0xff)))
+			goto out2;
+
+		ret = len;
+	}
+
+out2:
+	mutex_unlock(&chip->lock);
+
+out1:
+	return ret;
+}
+#endif
+
+static int do_calib_store(struct device *dev, const char *buf, size_t len,
+			  int ch)
+{
+	struct tsl2563_chip *chip = dev_to_tsl2563(dev);
+	int value;
+	calib_t calib;
+
+	if (1 != sscanf(buf, "%d", &value))
+		return -EINVAL;
+
+	calib = calib_from_sysfs(value);
+
+	if (ch)
+		chip->calib1 = calib;
+	else
+		chip->calib0 = calib;
+
+	return len;
+}
+
+static ssize_t tsl2563_calib0_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t len)
+{
+	return do_calib_store(dev, buf, len, 0);
+}
+
+static ssize_t tsl2563_calib1_store(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t len)
+{
+	return do_calib_store(dev, buf, len, 1);
+}
+
+static struct device_attribute tsl2563_attr_adc =
+	__ATTR(adc, S_IRUGO, tsl2563_adc_show, NULL);
+
+static struct device_attribute tsl2563_attr_lux =
+	__ATTR(lux, S_IRUGO, tsl2563_lux_show, NULL);
+
+static struct device_attribute tsl2563_attr_calib0 =
+	__ATTR(calib0, S_IRUGO | S_IWUSR,
+	       tsl2563_calib0_show, tsl2563_calib0_store);
+
+static struct device_attribute tsl2563_attr_calib1 =
+	__ATTR(calib1, S_IRUGO | S_IWUSR,
+	       tsl2563_calib1_show, tsl2563_calib1_store);
+
+#if 0 /* FIXME: disabled until fixed to take into account powering changes */
+static struct device_attribute tsl2563_attr_lowthres =
+	__ATTR(lowthres, S_IRUGO | S_IWUSR,
+	       tsl2563_lowthres_show, tsl2563_lowthres_store);
+
+static struct device_attribute tsl2563_attr_highthres =
+	__ATTR(highthres, S_IRUGO | S_IWUSR,
+	       tsl2563_highthres_show, tsl2563_highthres_store);
+#endif
+
+static int tsl2563_register_sysfs(struct i2c_client *client)
+{
+	struct device *d = &client->dev;
+	int r;
+
+	if ((r = device_create_file(d, &tsl2563_attr_adc)))
+		goto fail1;
+
+	if ((r = device_create_file(d, &tsl2563_attr_lux)))
+		goto fail2;
+
+#if 0 /* FIXME: disabled until fixed to take into account powering changes */
+	if ((r = device_create_file(d, &tsl2563_attr_lowthres)))
+		goto fail3;
+
+	if ((r = device_create_file(d, &tsl2563_attr_highthres)))
+		goto fail4;
+#endif
+
+	if ((r = device_create_file(d, &tsl2563_attr_calib0)))
+		goto fail5;
+
+	if ((r = device_create_file(d, &tsl2563_attr_calib1)))
+		goto fail6;
+
+	return 0;
+
+fail6:
+	device_remove_file(d, &tsl2563_attr_calib0);
+fail5:
+#if 0 /* FIXME: disabled until fixed to take into account powering changes */
+	device_remove_file(d, &tsl2563_attr_highthres);
+fail4:
+	device_remove_file(d, &tsl2563_attr_lowthres);
+fail3:
+#endif
+	device_remove_file(d, &tsl2563_attr_lux);
+fail2:
+	device_remove_file(d, &tsl2563_attr_adc);
+fail1:
+	return r;
+}
+
+static void tsl2563_unregister_sysfs(struct i2c_client *client)
+{
+	struct device *d = &client->dev;
+
+	device_remove_file(d, &tsl2563_attr_calib1);
+	device_remove_file(d, &tsl2563_attr_calib0);
+#if 0 /* FIXME: disabled until fixed to take into account powering changes */
+	device_remove_file(d, &tsl2563_attr_highthres);
+	device_remove_file(d, &tsl2563_attr_lowthres);
+#endif
+	device_remove_file(d, &tsl2563_attr_lux);
+	device_remove_file(d, &tsl2563_attr_adc);
+}
+
+static irqreturn_t tsl2563_irq(int irq, void *_tsl2563)
+{
+	struct tsl2563_chip *chip = _tsl2563;
+	struct i2c_client *client = &chip->client;
+
+	/*
+	 * TODO: convert ADC to lux, notify userspace only if out of
+	 * thresholds
+	 */
+	sysfs_notify(&client->dev.kobj, NULL, "adc");
+	sysfs_notify(&client->dev.kobj, NULL, "lux");
+
+	/* Failure of these calls is not significant */
+	if (sysfs_update_file(&client->dev.kobj, &tsl2563_attr_adc.attr));
+	if (sysfs_update_file(&client->dev.kobj, &tsl2563_attr_lux.attr));
+
+	return IRQ_HANDLED;
+}
+
+static struct i2c_driver tsl2563_i2c_driver;
+
+static int tsl2563_detect_client(struct i2c_adapter *adapter, int address,
+				 int kind)
+{
+	struct i2c_client *client;
+	struct tsl2563_chip *chip;
+	struct tsl2563_platform_data *pdata = tsl2563_pdata;
+	int err = 0;
+	u8 id;
+
+	if (!(chip = kzalloc(sizeof(*chip), GFP_KERNEL)))
+		return -ENOMEM;
+
+	client = &chip->client;
+	strncpy(client->name, DRIVER_NAME, sizeof(client->name));
+	client->addr	= address;
+	client->adapter	= adapter;
+	client->driver	= &tsl2563_i2c_driver;
+	client->flags	= 0;
+
+	if ((err = i2c_attach_client(client)) < 0) {
+		pr_err("couldn't attach\n");
+		goto fail1;
+	}
+
+	mutex_init(&chip->lock);
+
+	chip->set_power = pdata->set_power;
+	chip->irq = pdata->irq;
+#if 0 /* FIXME: disabled until fixed to take into account powering changes */
+	err = request_irq(chip->irq, tsl2563_irq,
+			  IRQF_TRIGGER_FALLING | IRQF_DISABLED |
+			  IRQF_SAMPLE_RANDOM, DRIVER_NAME, chip);
+	if (err) {
+		pr_err("could not get IRQ %d\n", chip->irq);
+		goto fail2;
+	}
+#endif
+
+	/* Default values used until userspace says otherwise */
+	chip->low_thres = 0x0;
+	chip->high_thres = 0xffff;
+	chip->gainlevel = tsl2563_gainlevel_table;
+	chip->intr = TSL2563_INT_PERSIST(4);
+	chip->calib0 = calib_from_sysfs(CALIB_BASE_SYSFS);
+	chip->calib1 = calib_from_sysfs(CALIB_BASE_SYSFS);
+
+	/* Probe for the device */
+	if (kind < 0) {
+		if ((err = tsl2563_detect(chip))) {
+			pr_err("device not found, error %d\n", -err);
+			goto fail3;
+		}
+	}
+
+	if ((err = tsl2563_read_id(chip, &id)))
+		goto fail3;
+
+	pr_info("model %d, rev. %d\n", id >> 4, id & 0x0f);
+
+	if ((err = tsl2563_configure(chip)))
+		goto fail3;
+
+	/*
+	 * Keep in power-down and let the tsl2563_power_inc and _dec functions
+	 * to manage power according to chip usage
+	 */
+	if (chip->set_power)
+		chip->set_power(&chip->client.dev, 0);
+	else
+		tsl2563_set_power(chip, 0);
+
+	chip->class_dev = hwmon_device_register(&client->dev);
+	if (IS_ERR(chip->class_dev))
+		goto fail3;
+
+	if ((err = tsl2563_register_sysfs(client))) {
+		pr_err("sysfs registration failed, error %d\n", err);
+		goto fail4;
+	}
+
+	return 0;
+fail4:
+	hwmon_device_unregister(chip->class_dev);
+fail3:
+	free_irq(chip->irq, chip);
+fail2:
+	i2c_detach_client(client);
+fail1:
+	kfree(chip);
+	return err;
+}
+
+static int tsl2563_scan_bus(struct i2c_adapter *bus)
+{
+	return i2c_probe(bus, &addr_data, tsl2563_detect_client);
+}
+
+static int tsl2563_detach_client(struct i2c_client *client)
+{
+	struct tsl2563_chip *chip = client_to_tsl2563(client);
+	int err;
+
+	tsl2563_unregister_sysfs(client);
+	hwmon_device_unregister(chip->class_dev);
+	free_irq(chip->irq, chip);
+
+	if ((err = i2c_detach_client(client))) {
+		pr_err("I2C deregistration failed\n");
+		return err;
+	}
+
+	kfree(chip);
+	return 0;
+}
+
+static int tsl2563_suspend(struct device *dev, pm_message_t state)
+{
+	struct tsl2563_chip *chip = dev_to_tsl2563(dev);
+	int ret;
+
+	mutex_lock(&chip->lock);
+
+	if ((ret = tsl2563_set_power(chip, 0)))
+		goto out;
+
+	chip->state = state;
+
+out:
+	mutex_unlock(&chip->lock);
+	return ret;
+}
+
+static int tsl2563_resume(struct device *dev)
+{
+	struct tsl2563_chip *chip = dev_to_tsl2563(dev);
+	int ret;
+
+	mutex_lock(&chip->lock);
+
+	if ((ret = tsl2563_set_power(chip, 1)))
+		goto out;
+
+	if ((ret = tsl2563_configure(chip)))
+		goto out;
+
+	chip->state.event = PM_EVENT_ON;
+
+out:
+	mutex_unlock(&chip->lock);
+	return ret;
+}
+
+static struct i2c_driver tsl2563_i2c_driver = {
+	.driver = {
+		.name	 = DRIVER_NAME,
+		.suspend = tsl2563_suspend,
+		.resume	 = tsl2563_resume
+	},
+	/* FIXME: id according to i2c-ids.h */
+	.id		= I2C_DRIVERID_MISC,
+	.class		= I2C_CLASS_HWMON,
+	.attach_adapter	= tsl2563_scan_bus,
+	.detach_client	= tsl2563_detach_client,
+};
+
+static int tsl2563_probe(struct platform_device *pdev)
+{
+	struct tsl2563_platform_data *pdata = pdev->dev.platform_data;
+
+	if (tsl2563_pdata) {
+		dev_err(&pdev->dev,
+			"only single %s platform device supported\n",
+			DRIVER_NAME);
+		return -EBUSY;
+	}
+	tsl2563_pdata = pdata;
+	if (tsl2563_pdata->set_power)
+		tsl2563_pdata->set_power(&pdev->dev, 1);
+
+	return i2c_add_driver(&tsl2563_i2c_driver);
+}
+
+static int tsl2563_remove(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = i2c_del_driver(&tsl2563_i2c_driver);
+	tsl2563_pdata = NULL;
+
+	return ret;
+}
+
+static struct platform_driver tsl2563_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "tsl2563",
+	},
+	.probe		= tsl2563_probe,
+	.remove		= tsl2563_remove,
+};
+
+static int __init tsl2563_init(void)
+{
+	if (platform_driver_register(&tsl2563_driver)) {
+		printk(KERN_ERR "Failed to register %s driver\n",
+		       DRIVER_NAME);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static void __exit tsl2563_exit(void)
+{
+	platform_driver_unregister(&tsl2563_driver);
+}
+
+MODULE_AUTHOR("Nokia Corporation");
+MODULE_DESCRIPTION("tsl2563 light sensor driver");
+MODULE_LICENSE("GPL");
+
+module_init(tsl2563_init);
+module_exit(tsl2563_exit);
diff -ruN linux-omap-2.6/drivers/input/evdev.c maemo_src/drivers/input/evdev.c
--- linux-omap-2.6/drivers/input/evdev.c	2011-02-06 19:44:51.343333272 -0500
+++ maemo_src/drivers/input/evdev.c	2007-10-02 03:09:31.000000000 -0400
@@ -37,6 +37,7 @@
 	struct input_event buffer[EVDEV_BUFFER_SIZE];
 	int head;
 	int tail;
+	int exclusive;
 	struct fasync_struct *fasync;
 	struct evdev *evdev;
 	struct list_head node;
@@ -49,7 +50,7 @@
 	struct evdev *evdev = handle->private;
 	struct evdev_list *list;
 
-	if (evdev->grab) {
+	if (evdev->grab && evdev->grab->exclusive) {
 		list = evdev->grab;
 
 		do_gettimeofday(&list->buffer[list->head].time);
@@ -483,11 +484,12 @@
 
 		case EVIOCGRAB:
 			if (p) {
-				if (evdev->grab)
+				if (evdev->grab && evdev->grab->exclusive)
 					return -EBUSY;
 				if (input_grab_device(&evdev->handle))
 					return -EBUSY;
 				evdev->grab = list;
+				evdev->grab->exclusive = ((long) p == 1);
 				return 0;
 			} else {
 				if (evdev->grab != list)
diff -ruN linux-omap-2.6/drivers/input/keyboard/tsc2301_kp.c maemo_src/drivers/input/keyboard/tsc2301_kp.c
--- linux-omap-2.6/drivers/input/keyboard/tsc2301_kp.c	2011-02-06 20:17:25.669999940 -0500
+++ maemo_src/drivers/input/keyboard/tsc2301_kp.c	2011-02-06 20:12:10.946666607 -0500
@@ -49,7 +49,7 @@
 
 #define TSC2301_DEBOUNCE_TIME		TSC2301_DEBOUNCE_TIME_20MS
 
-#define TSC2301_POLL_TIME		30
+#define TSC2301_RELEASE_TIMEOUT		50
 
 struct tsc2301_kp {
 	struct input_dev	*idev;
@@ -58,20 +58,18 @@
 	struct mutex		mutex;
 	struct timer_list	timer;
 	u16			keys_pressed;
-	unsigned		pending:1;
-	unsigned		user_disabled:1;
+	u8			pending;
+	u8			user_disabled;
 	unsigned		disable_depth;
 
 	struct spi_transfer	read_xfer[4];
 	struct spi_message	read_msg;
-	u16			state;
+
 	u16			data;
 	u16			mask;
 
 	int			irq;
 	s16			keymap[16];
-
-	int			(*get_keyb_irq_state)(struct device *dev);
 };
 
 static inline int tsc2301_kp_disabled(struct tsc2301 *tsc)
@@ -79,24 +77,6 @@
 	return tsc->kp->disable_depth != 0;
 }
 
-static inline void tsc2301_kp_set_keypressed_state(struct tsc2301 *tsc)
-{
-	struct tsc2301_kp *kp = tsc->kp;
-
-	/* kp->state is updated only if we don't have the callback */
-	if (kp->get_keyb_irq_state != NULL) {
-		if (kp->get_keyb_irq_state(&tsc->spi->dev))
-			kp->state = 1 << 15;
-		else
-			kp->state = 0;
-	}
-}
-
-static inline int tsc2301_kp_key_is_pressed(struct tsc2301 *tsc)
-{
-	return tsc->kp->state & (1 << 15);
-}
-
 static void tsc2301_kp_send_key_events(struct tsc2301 *tsc,
 				       u16 prev_state,
 				       u16 new_state)
@@ -125,20 +105,6 @@
 	input_sync(kp->idev);
 }
 
-static inline void tsc2301_kp_release_all_keys(struct tsc2301 *tsc)
-{
-	struct tsc2301_kp *kp = tsc->kp;
-	unsigned long flags;
-	int keys_pressed;
-
-	spin_lock_irqsave(&kp->lock, flags);
-	keys_pressed = kp->keys_pressed;
-	kp->keys_pressed = 0;
-	spin_unlock_irqrestore(&kp->lock, flags);
-	if (keys_pressed)
-		tsc2301_kp_send_key_events(tsc, keys_pressed, 0);
-}
-
 static inline void _filter_out(struct tsc2301 *tsc, u16 prev_state,
 			       u16 *new_state, int row1, int row2, u8 rect_pat)
 {
@@ -183,16 +149,13 @@
 static void tsc2301_kp_timer(unsigned long arg)
 {
 	struct tsc2301 *tsc = (void *) arg;
-	int r;
+	struct tsc2301_kp *kp = tsc->kp;
+	unsigned long flags;
 
-	/* This needs to be done early enough, since reading the key data
-	 * register clears the IRQ line, which may be used to determine
-	 * the key pressed state.
-	 */
-	tsc2301_kp_set_keypressed_state(tsc);
-	r = spi_async(tsc->spi, &tsc->kp->read_msg);
-	if (unlikely(r < 0 && printk_ratelimit()))
-		dev_err(&tsc->spi->dev, "kp: spi_async() failed");
+	tsc2301_kp_send_key_events(tsc, kp->keys_pressed, 0);
+	spin_lock_irqsave(&kp->lock, flags);
+	kp->keys_pressed = 0;
+	spin_unlock_irqrestore(&kp->lock, flags);
 }
 
 static void tsc2301_kp_rx(void *arg)
@@ -200,30 +163,16 @@
 	struct tsc2301 *tsc = arg;
 	struct tsc2301_kp *kp = tsc->kp;
 	unsigned long flags;
-	int key_pressed;
 	u16 kp_data;
 
 	kp_data = kp->data;
-	key_pressed = tsc2301_kp_key_is_pressed(tsc);
-	dev_dbg(&tsc->spi->dev, "KP data %04x (%s)\n",
-		kp_data, key_pressed ? "pressed" : "not pressed");
-	if (!key_pressed)
-		kp_data = 0;
-	else
-		tsc2301_filter_ghost_keys(tsc, kp->keys_pressed, &kp_data);
+	dev_dbg(&tsc->spi->dev, "KP data %04x\n", kp_data);
+
+	tsc2301_filter_ghost_keys(tsc, kp->keys_pressed, &kp_data);
 	tsc2301_kp_send_key_events(tsc, kp->keys_pressed, kp_data);
-	kp->keys_pressed = kp_data;
 	spin_lock_irqsave(&kp->lock, flags);
-	if (likely(!tsc2301_kp_disabled(tsc))) {
-		if (likely(key_pressed))
-			mod_timer(&kp->timer,
-				 jiffies + msecs_to_jiffies(TSC2301_POLL_TIME));
-		else {
-			kp->pending = 0;
-			enable_irq(kp->irq);
-		}
-	} else
-		kp->pending = 0;
+	kp->keys_pressed = kp_data;
+	kp->pending = 0;
 	spin_unlock_irqrestore(&kp->lock, flags);
 }
 
@@ -232,17 +181,20 @@
 	struct tsc2301 *tsc = dev_id;
 	struct tsc2301_kp *kp = tsc->kp;
 	unsigned long flags;
+	int r;
 
 	spin_lock_irqsave(&kp->lock, flags);
-	BUG_ON(kp->pending);
 	if (tsc2301_kp_disabled(tsc)) {
 		spin_unlock_irqrestore(&kp->lock, flags);
 		return IRQ_HANDLED;
 	}
 	kp->pending = 1;
-	disable_irq_nosync(irq);
 	spin_unlock_irqrestore(&kp->lock, flags);
-	tsc2301_kp_timer((unsigned long) tsc);
+	mod_timer(&kp->timer,
+		 jiffies + msecs_to_jiffies(TSC2301_RELEASE_TIMEOUT));
+	r = spi_async(tsc->spi, &tsc->kp->read_msg);
+	if (r)
+		dev_err(&tsc->spi->dev, "kp: spi_async() failed");
 	return IRQ_HANDLED;
 }
 
@@ -255,7 +207,27 @@
 static void tsc2301_kp_stop_scan(struct tsc2301 *tsc)
 {
 	tsc2301_write_reg(tsc, TSC2301_REG_KEY, 1 << 14);
-	tsc2301_write_reg(tsc, TSC2301_REG_KPMASK, 0xffff);
+}
+
+/* The following workaround is needed for a HW bug triggered by the
+ * following:
+ * 1. keep any key pressed
+ * 2. disable keypad
+ * 3. release all keys
+ * 4. reenable keypad
+ * 5. disable touch screen controller
+ *
+ * After this the keypad scanner will get stuck in busy state and won't
+ * report any interrupts for further keypresses.
+ * The problematic action is disabling the touchscreen scanning, so
+ * if the keypad is enabled we restart just in case, whenever the
+ * touchscreen scanning is disabled.
+ */
+void tsc2301_kp_restart(struct tsc2301 *tsc)
+{
+	if (!tsc2301_kp_disabled(tsc)) {
+		tsc2301_kp_start_scan(tsc);
+	}
 }
 
 /* Must be called with the mutex held */
@@ -270,18 +242,11 @@
 		spin_unlock_irqrestore(&kp->lock, flags);
 		return;
 	}
-	if (kp->keys_pressed)
-		kp->pending = 1;
 	spin_unlock_irqrestore(&kp->lock, flags);
 
 	set_irq_type(kp->irq, IRQT_FALLING);
 	tsc2301_kp_start_scan(tsc);
-	if (kp->pending)
-		/* continue an interrupted polling */
-		mod_timer(&kp->timer,
-			  jiffies + msecs_to_jiffies(TSC2301_POLL_TIME));
-	else
-		enable_irq(kp->irq);
+	enable_irq(kp->irq);
 }
 
 /* Must be called with the mutex held */
@@ -295,50 +260,23 @@
 		spin_unlock_irqrestore(&kp->lock, flags);
 		goto out;
 	}
-	if (!kp->pending)
-		disable_irq_nosync(kp->irq);
+
+	disable_irq_nosync(kp->irq);
+	set_irq_type(kp->irq, IRQT_NOEDGE);
+	spin_unlock_irqrestore(&kp->lock, flags);
 
 	while (kp->pending) {
-		spin_unlock_irqrestore(&kp->lock, flags);
-		msleep(1);
-		spin_lock_irqsave(&kp->lock, flags);
+		msleep(4);
 	}
-	spin_unlock_irqrestore(&kp->lock, flags);
 
 	tsc2301_kp_stop_scan(tsc);
-	set_irq_type(kp->irq, IRQT_NOEDGE);
 out:
-	if (release_keys)
-		tsc2301_kp_release_all_keys(tsc);
+	if (!release_keys)
+		del_timer(&kp->timer); /* let timeout release keys */
 
 	return 0;
 }
 
-/* The following workaround is needed for a HW bug triggered by the
- * following:
- * 1. keep any key pressed
- * 2. disable keypad
- * 3. release all keys
- * 4. reenable keypad
- * 5. disable touch screen controller
- *
- * After this the keypad scanner will get stuck in busy state and won't
- * report any interrupts for further keypresses. One way to recover is to
- * restart the keypad scanner whenever we enable / disable the
- * touchscreen controller.
- */
-void tsc2301_kp_restart(struct tsc2301 *tsc)
-{
-	struct tsc2301_kp *kp = tsc->kp;
-
-	mutex_lock(&kp->mutex);
-	if (!kp->user_disabled) {
-		tsc2301_kp_disable(tsc, 0);
-		tsc2301_kp_enable(tsc);
-	}
-	mutex_unlock(&kp->mutex);
-}
-
 static ssize_t tsc2301_kp_disable_show(struct device *dev,
 				       struct device_attribute *attr, char *buf)
 {
@@ -379,7 +317,6 @@
 		   tsc2301_kp_disable_store);
 
 static const u16 tsc2301_kp_read_data = 0x8000 | TSC2301_REG_KPDATA;
-static const u16 tsc2301_kp_read_state = 0x8000 | TSC2301_REG_KEY;
 
 static void tsc2301_kp_setup_spi_xfer(struct tsc2301 *tsc)
 {
@@ -389,22 +326,6 @@
 
 	spi_message_init(&kp->read_msg);
 
-	if (kp->get_keyb_irq_state == NULL) {
-		/* No platform specific way for determining the keypress
-		 * state, so we'll need an extra status register read.
-		 */
-		x->tx_buf = &tsc2301_kp_read_state;
-		x->len = 2;
-		spi_message_add_tail(x, m);
-		x++;
-
-		x->rx_buf = &kp->state;
-		x->len = 2;
-		x->cs_change = 1;
-		spi_message_add_tail(x, m);
-		x++;
-	}
-
 	x->tx_buf = &tsc2301_kp_read_data;
 	x->len = 2;
 	spi_message_add_tail(x, m);
@@ -465,14 +386,15 @@
 	kp->timer.data = (unsigned long) tsc;
 	kp->timer.function = tsc2301_kp_timer;
 
-	kp->get_keyb_irq_state = pdata->get_keyb_irq_state;
-
 	idev = input_allocate_device();
 	if (idev == NULL) {
 		r = -ENOMEM;
 		goto err1;
 	}
-	idev->name = "TSC2301 keypad";
+	if (pdata->keyb_name)
+		idev->name = pdata->keyb_name;
+	else
+		idev->name = "TSC2301 keypad";
 	snprintf(kp->phys, sizeof(kp->phys), "%s/input-kp", tsc->spi->dev.bus_id);
 	idev->phys = kp->phys;
 
diff -ruN linux-omap-2.6/drivers/input/touchscreen/Kconfig maemo_src/drivers/input/touchscreen/Kconfig
--- linux-omap-2.6/drivers/input/touchscreen/Kconfig	2011-02-06 20:17:25.686666606 -0500
+++ maemo_src/drivers/input/touchscreen/Kconfig	2011-02-06 20:12:10.916666605 -0500
@@ -159,6 +159,11 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called ucb1400_ts.
 
+config TOUCHSCREEN_TSC2005
+	tristate "TSC2005 touchscreen support"
+	help
+	  Say Y here for if you are using the touchscreen features of TSC2301.
+
 config TOUCHSCREEN_TSC2301
 	tristate "TSC2301 touchscreen support"
 	depends on SPI_TSC2301
diff -ruN linux-omap-2.6/drivers/input/touchscreen/Makefile maemo_src/drivers/input/touchscreen/Makefile
--- linux-omap-2.6/drivers/input/touchscreen/Makefile	2011-02-06 20:17:25.686666606 -0500
+++ maemo_src/drivers/input/touchscreen/Makefile	2011-02-06 20:12:10.913333272 -0500
@@ -16,6 +16,7 @@
 obj-$(CONFIG_TOUCHSCREEN_TOUCHRIGHT)	+= touchright.o
 obj-$(CONFIG_TOUCHSCREEN_TOUCHWIN)	+= touchwin.o
 obj-$(CONFIG_TOUCHSCREEN_UCB1400)	+= ucb1400_ts.o
+obj-$(CONFIG_TOUCHSCREEN_TSC2005)	+= tsc2005.o
 obj-$(CONFIG_TOUCHSCREEN_TSC2102)	+= tsc2102_ts.o
 obj-$(CONFIG_TOUCHSCREEN_OMAP)	+= omap/
 obj-$(CONFIG_TOUCHSCREEN_TSC2301)	+= tsc2301_ts.o
diff -ruN linux-omap-2.6/drivers/input/touchscreen/tsc2005.c maemo_src/drivers/input/touchscreen/tsc2005.c
--- linux-omap-2.6/drivers/input/touchscreen/tsc2005.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/input/touchscreen/tsc2005.c	2011-02-06 20:12:10.916666605 -0500
@@ -0,0 +1,762 @@
+/*
+ * TSC2005 touchscreen driver
+ *
+ * Copyright (C) 2006-2007 Nokia Corporation
+ *
+ * Author: Lauri Leukkunen <lauri.leukkunen@nokia.com>
+ * based on TSC2301 driver by Klaus K. Pedersen <klaus.k.pedersen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+
+#ifdef CONFIG_ARCH_OMAP
+#include <asm/arch/gpio.h>
+#endif
+
+#include <linux/spi/tsc2005.h>
+
+/**
+ * The touchscreen interface operates as follows:
+ *
+ * Initialize:
+ *    Request access to GPIO103 (DAV)
+ *    tsc2005_dav_irq_handler will trigger when DAV line goes down
+ *
+ *  1) Pen is pressed against touchscreeen
+ *  2) TSC2005 performs AD conversion
+ *  3) After the conversion is done TSC2005 drives DAV line down
+ *  4) GPIO IRQ is received and tsc2005_dav_irq_handler is called
+ *  5) tsc2005_ts_irq_handler queues up an spi transfer to fetch
+ *     the x, y, z1, z2 values
+ *  6) tsc2005_ts_rx() reports coordinates to input layer and
+ *     sets up tsc2005_ts_timer() to be called after TSC2005_TS_SCAN_TIME
+ *  7)  When the penup_timer expires, there have not been DAV interrupts
+ *     during the last 20ms which means the pen has been lifted.
+ */
+
+#define TSC2005_HZ	(14000000)
+
+#define TSC2005_CMD	(0x80)
+#define TSC2005_REG	(0x00)
+
+#define TSC2005_CMD_STOP	(1)
+#define TSC2005_CMD_10BIT	(0 << 2)
+#define TSC2005_CMD_12BIT	(1 << 2)
+
+#define TSC2005_CMD_SCAN_XYZZ	(0 << 3)
+#define TSC2005_CMD_SCAN_XY	(1 << 3)
+#define TSC2005_CMD_SCAN_X	(2 << 3)
+#define TSC2005_CMD_SCAN_Y	(3 << 3)
+#define TSC2005_CMD_SCAN_ZZ	(4 << 3)
+#define TSC2005_CMD_AUX_SINGLE	(5 << 3)
+#define TSC2005_CMD_TEMP1	(6 << 3)
+#define TSC2005_CMD_TEMP2	(7 << 3)
+#define TSC2005_CMD_AUX_CONT	(8 << 3)
+#define TSC2005_CMD_TEST_X_CONN	(9 << 3)
+#define TSC2005_CMD_TEST_Y_CONN	(10 << 3)
+/* command 11 reserved */
+#define TSC2005_CMD_TEST_SHORT	(12 << 3)
+#define TSC2005_CMD_DRIVE_XX	(13 << 3)
+#define TSC2005_CMD_DRIVE_YY	(14 << 3)
+#define TSC2005_CMD_DRIVE_YX	(15 << 3)
+
+#define TSC2005_REG_X		(0 << 3)
+#define TSC2005_REG_Y		(1 << 3)
+#define TSC2005_REG_Z1		(2 << 3)
+#define TSC2005_REG_Z2		(3 << 3)
+#define TSC2005_REG_AUX		(4 << 3)
+#define TSC2005_REG_TEMP1	(5 << 3)
+#define TSC2005_REG_TEMP2	(6 << 3)
+#define TSC2005_REG_STATUS	(7 << 3)
+#define TSC2005_REG_AUX_HIGH	(8 << 3)
+#define TSC2005_REG_AUX_LOW	(9 << 3)
+#define TSC2005_REG_TEMP_HIGH	(10 << 3)
+#define TSC2005_REG_TEMP_LOW	(11 << 3)
+#define TSC2005_REG_CFR0	(12 << 3)
+#define TSC2005_REG_CFR1	(13 << 3)
+#define TSC2005_REG_CFR2	(14 << 3)
+#define TSC2005_REG_FUNCTION	(15 << 3)
+
+#define TSC2005_REG_PND0	(1 << 1)
+#define TSC2005_REG_READ	(0x01)
+#define TSC2005_REG_WRITE	(0x00)
+
+
+#define TSC2005_CFR0_LONGSAMPLING	(1)
+#define TSC2005_CFR0_DETECTINWAIT	(1 << 1)
+#define TSC2005_CFR0_SENSETIME_32US	(0)
+#define TSC2005_CFR0_SENSETIME_96US	(1 << 2)
+#define TSC2005_CFR0_SENSETIME_544US	(1 << 3)
+#define TSC2005_CFR0_SENSETIME_2080US	(1 << 4)
+#define TSC2005_CFR0_SENSETIME_2656US	(0x001C)
+#define TSC2005_CFR0_PRECHARGE_20US	(0x0000)
+#define TSC2005_CFR0_PRECHARGE_84US	(0x0020)
+#define TSC2005_CFR0_PRECHARGE_276US	(0x0040)
+#define TSC2005_CFR0_PRECHARGE_1044US	(0x0080)
+#define TSC2005_CFR0_PRECHARGE_1364US	(0x00E0)
+#define TSC2005_CFR0_STABTIME_0US	(0x0000)
+#define TSC2005_CFR0_STABTIME_100US	(0x0100)
+#define TSC2005_CFR0_STABTIME_500US	(0x0200)
+#define TSC2005_CFR0_STABTIME_1MS	(0x0300)
+#define TSC2005_CFR0_STABTIME_5MS	(0x0400)
+#define TSC2005_CFR0_STABTIME_100MS	(0x0700)
+#define TSC2005_CFR0_CLOCK_4MHZ		(0x0000)
+#define TSC2005_CFR0_CLOCK_2MHZ		(0x0800)
+#define TSC2005_CFR0_CLOCK_1MHZ		(0x1000)
+#define TSC2005_CFR0_RESOLUTION12	(0x2000)
+#define TSC2005_CFR0_STATUS		(0x4000)
+#define TSC2005_CFR0_PENMODE		(0x8000)
+
+#define TSC2005_CFR0_INITVALUE	(TSC2005_CFR0_STABTIME_1MS  |	\
+				 TSC2005_CFR0_CLOCK_1MHZ    |	\
+				 TSC2005_CFR0_RESOLUTION12  |	\
+				 TSC2005_CFR0_PRECHARGE_276US | \
+				 TSC2005_CFR0_PENMODE)
+
+#define TSC2005_CFR1_BATCHDELAY_0MS	(0x0000)
+#define TSC2005_CFR1_BATCHDELAY_1MS	(0x0001)
+#define TSC2005_CFR1_BATCHDELAY_2MS	(0x0002)
+#define TSC2005_CFR1_BATCHDELAY_4MS	(0x0003)
+#define TSC2005_CFR1_BATCHDELAY_10MS	(0x0004)
+#define TSC2005_CFR1_BATCHDELAY_20MS	(0x0005)
+#define TSC2005_CFR1_BATCHDELAY_40MS	(0x0006)
+#define TSC2005_CFR1_BATCHDELAY_100MS	(0x0007)
+
+#define TSC2005_CFR1_INITVALUE	(TSC2005_CFR1_BATCHDELAY_2MS)
+
+#define TSC2005_CFR2_MAVE_TEMP	(0x0001)
+#define TSC2005_CFR2_MAVE_AUX	(0x0002)
+#define TSC2005_CFR2_MAVE_Z	(0x0004)
+#define TSC2005_CFR2_MAVE_Y	(0x0008)
+#define TSC2005_CFR2_MAVE_X	(0x0010)
+#define TSC2005_CFR2_AVG_1	(0x0000)
+#define TSC2005_CFR2_AVG_3	(0x0400)
+#define TSC2005_CFR2_AVG_7	(0x0800)
+#define TSC2005_CFR2_MEDIUM_1	(0x0000)
+#define TSC2005_CFR2_MEDIUM_3	(0x1000)
+#define TSC2005_CFR2_MEDIUM_7	(0x2000)
+#define TSC2005_CFR2_MEDIUM_15	(0x3000)
+
+#define TSC2005_CFR2_IRQ_DAV	(0x4000)
+#define TSC2005_CFR2_IRQ_PEN	(0x8000)
+#define TSC2005_CFR2_IRQ_PENDAV	(0x0000)
+
+#define TSC2005_CFR2_INITVALUE	(TSC2005_CFR2_IRQ_DAV   |	\
+				 TSC2005_CFR2_MAVE_X    |	\
+				 TSC2005_CFR2_MAVE_Y    |	\
+				 TSC2005_CFR2_MAVE_Z    |	\
+				 TSC2005_CFR2_MEDIUM_15 |	\
+				 TSC2005_CFR2_AVG_7)
+
+#define MAX_12BIT					((1 << 12) - 1)
+#define TS_SAMPLES					4
+#define P_SAMPLES					16
+#define TS_RECT_SIZE					8
+#define TSC2005_TS_PENUP_TIME		     		20
+
+static const u32 tsc2005_read_reg[] = {
+	(TSC2005_REG | TSC2005_REG_X | TSC2005_REG_READ) << 16,
+	(TSC2005_REG | TSC2005_REG_Y | TSC2005_REG_READ) << 16,
+	(TSC2005_REG | TSC2005_REG_Z1 | TSC2005_REG_READ) << 16,
+	(TSC2005_REG | TSC2005_REG_Z2 | TSC2005_REG_READ) << 16,
+};
+#define NUM_READ_REGS	(sizeof(tsc2005_read_reg)/sizeof(tsc2005_read_reg[0]))
+
+struct tsc2005 {
+	struct spi_device	*spi;
+
+	struct input_dev	*idev;
+	char			phys[32];
+	struct timer_list	penup_timer;
+	spinlock_t		lock;
+	struct mutex		mutex;
+
+	struct spi_message	read_msg;
+	struct spi_transfer	read_xfer[NUM_READ_REGS];
+	u32                     data[NUM_READ_REGS];
+
+	/* previous x,y,z */
+	int			x;
+	int			y;
+	int			p;
+	/* average accumulators for each component */
+	int			sample_cnt;
+	int 			avg_x;
+	int 			avg_y;
+	int 			p_n;
+	int 			p_buf[P_SAMPLES];
+	/* configuration */
+	int			x_plate_ohm;
+	int			hw_avg_max;
+	int			stab_time;
+	int			p_max;
+	int			touch_pressure;
+	int			irq;
+	s16			dav_gpio;
+	/* status */
+	u8			sample_sent;
+	u8			pen_down;
+	u8			pen_active;
+	u8			disabled;
+	u8			disable_depth;
+	u8			spi_active;
+};
+
+static void tsc2005_cmd(struct tsc2005 *ts, u8 cmd)
+{
+	u16 data = TSC2005_CMD | TSC2005_CMD_12BIT | cmd;
+	struct spi_message msg;
+	struct spi_transfer xfer = { 0 };
+
+	spi_message_init(&msg);
+	msg.spi = ts->spi;
+	xfer.tx_buf = &data;
+	xfer.rx_buf = NULL;
+	xfer.len = 2;
+	xfer.bits_per_word = 8;
+
+	spi_message_add_tail(&xfer, &msg);
+	spi_sync(ts->spi, &msg);
+}
+
+static void tsc2005_write(struct tsc2005 *ts, u8 reg, u16 value)
+{
+	u32 tx;
+	struct spi_message msg;
+	struct spi_transfer xfer = { 0 };
+
+	tx = (TSC2005_REG | reg | TSC2005_REG_PND0 |
+	       TSC2005_REG_WRITE) << (2 * 8);
+	tx |= value;
+
+	spi_message_init(&msg);
+	msg.spi = ts->spi;
+	xfer.tx_buf = &tx;
+	xfer.rx_buf = NULL;
+	xfer.len = 4;
+	xfer.bits_per_word = 3 * 8;
+
+	spi_message_add_tail(&xfer, &msg);
+	spi_sync(ts->spi, &msg);
+}
+
+static void tsc2005_ts_update_pen_state(struct tsc2005 *ts,
+					int x, int y, int pressure)
+{
+	if (pressure) {
+		input_report_abs(ts->idev, ABS_X, x);
+		input_report_abs(ts->idev, ABS_Y, y);
+		input_report_abs(ts->idev, ABS_PRESSURE, pressure);
+		if (!ts->pen_down) {
+			input_report_key(ts->idev, BTN_TOUCH, 1);
+			ts->pen_down = 1;
+		}
+	} else {
+		input_report_abs(ts->idev, ABS_PRESSURE, 0);
+		if (ts->pen_down) {
+			input_report_key(ts->idev, BTN_TOUCH, 0);
+		}
+		ts->pen_down = 0;
+	}
+
+	input_sync(ts->idev);
+}
+
+/*
+ * This function is called by the SPI framework after the coordinates
+ * have been read from TSC2005
+ */
+static void tsc2005_ts_rx(void *arg)
+{
+	struct tsc2005 *ts = arg;
+	unsigned long flags;
+	int inside_rect, pressure_limit;
+	int x, y, z1, z2, pressure;
+	int i;
+
+	spin_lock_irqsave(&ts->lock, flags);
+
+	x = ts->data[0];
+	y = ts->data[1];
+	z1 = ts->data[2];
+	z2 = ts->data[3];
+
+	/* validate position */
+	if (x > MAX_12BIT || y > MAX_12BIT)
+		goto out;
+
+	/* validate pressure */
+	if (z1 < 100 || z1 > 4000 || z2 < z1 || z2 > 4000)
+		goto out;
+	
+	pressure = x * (z2 - z1) / z1;
+	pressure = pressure * ts->x_plate_ohm / 4096;
+	pressure_limit = ts->sample_sent ? ts->p_max : ts->touch_pressure;
+
+	if (pressure > pressure_limit)
+		goto out;
+
+	/* start accumulating average */
+	if (!ts->pen_active) {
+		ts->pen_active = 1;
+		ts->sample_cnt = 0;
+		ts->avg_x = 0;
+		ts->avg_y = 0;
+		ts->p_n = 0;
+		for (i = 0; i < P_SAMPLES; i++)
+			ts->p_buf[i] = 0;
+	}
+
+	ts->avg_x += x;
+	ts->avg_y += y;
+	ts->p_buf[ts->p_n++] = pressure;
+
+	if (ts->p_n >= P_SAMPLES)
+		ts->p_n = 0;
+
+	/* only report the average coords every TS_SAMPLES */
+	if (++ts->sample_cnt < TS_SAMPLES)
+		goto out;
+
+	x = ts->avg_x / TS_SAMPLES;
+	y = ts->avg_y / TS_SAMPLES;
+
+	/* report the max pressure out of a sliding window */
+	for (i = 0; i < P_SAMPLES; i++)
+		if (ts->p_buf[i] && ts->p_buf[i] < pressure)
+			pressure = ts->p_buf[i];
+
+	ts->sample_cnt = 0;
+	ts->avg_x = 0;
+	ts->avg_y = 0;
+
+
+	/* discard the event if it still is within the previous rect - unless
+	 * if the pressure is harder, but then use previous x,y position */
+	inside_rect = (ts->sample_sent &&
+		x > (int)ts->x - TS_RECT_SIZE &&
+		x < (int)ts->x + TS_RECT_SIZE &&
+		y > (int)ts->y - TS_RECT_SIZE &&
+		y < (int)ts->y + TS_RECT_SIZE);
+
+	if (inside_rect)
+		x = ts->x, y = ts->y;
+
+	if (!inside_rect || pressure < ts->p) {
+		tsc2005_ts_update_pen_state(ts, x, y, pressure);
+		ts->sample_sent = 1;
+		ts->x = x;
+		ts->y = y;
+		ts->p = pressure;
+	}
+
+out:
+	ts->spi_active = 0;
+
+	spin_unlock_irqrestore(&ts->lock, flags);
+
+	mod_timer(&ts->penup_timer,
+		  jiffies + msecs_to_jiffies(TSC2005_TS_PENUP_TIME));
+}
+
+static void tsc2005_ts_penup_timer_handler(unsigned long data)
+{
+	struct tsc2005 *ts = (struct tsc2005 *)data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ts->lock, flags);
+
+	/* check if we'll be kicked again => do nothing */
+	if (ts->spi_active) {
+		spin_unlock_irqrestore(&ts->lock, flags);
+		return;
+	}
+
+	if (ts->sample_sent) {
+		tsc2005_ts_update_pen_state(ts, 0, 0, 0);
+		ts->sample_sent = 0;
+	}
+
+	ts->pen_active = 0;
+
+	spin_unlock_irqrestore(&ts->lock, flags);
+}
+
+/*
+ * This interrupt is called when pen is down and coordinates are
+ * available. That is indicated by a falling edge on DAV line.
+ */
+static irqreturn_t tsc2005_ts_irq_handler(int irq, void *dev_id)
+{
+	struct tsc2005 *ts = dev_id;
+
+	spin_lock(&ts->lock);
+
+	/* schedule a new read request only if none pending */
+	if (!ts->spi_active) {
+		if (spi_async(ts->spi, &ts->read_msg))
+			dev_err(&ts->spi->dev, "ts: spi_async() failed");
+		else
+			ts->spi_active = 1;
+	}
+
+	spin_unlock(&ts->lock);
+	return IRQ_HANDLED;
+}
+
+static void tsc2005_ts_setup_spi_xfer(struct tsc2005 *ts)
+{
+	struct spi_message *m = &ts->read_msg;
+	struct spi_transfer *x = &ts->read_xfer[0];
+	int i;
+
+	spi_message_init(m);
+	m->spi = ts->spi;
+
+	for (i = 0; i < NUM_READ_REGS; i++, x++ ) {
+		x->tx_buf = &tsc2005_read_reg[i];
+		x->rx_buf = &ts->data[i];
+		x->len = 4;
+		x->bits_per_word = 24;
+		x->cs_change = i < (NUM_READ_REGS - 1);
+		spi_message_add_tail(x, m);
+	}
+
+	m->complete = tsc2005_ts_rx;
+	m->context = ts;
+}
+
+static ssize_t tsc2005_ts_pen_down_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct tsc2005 *tsc = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", tsc->pen_down);
+}
+
+static DEVICE_ATTR(pen_down, S_IRUGO, tsc2005_ts_pen_down_show, NULL);
+
+static int tsc2005_configure(struct tsc2005 *tsc, int flags)
+{
+	tsc2005_write(tsc, TSC2005_REG_CFR0, TSC2005_CFR0_INITVALUE);
+	tsc2005_write(tsc, TSC2005_REG_CFR1, TSC2005_CFR1_INITVALUE);
+	tsc2005_write(tsc, TSC2005_REG_CFR2, TSC2005_CFR2_INITVALUE);
+	tsc2005_cmd(tsc, flags);
+
+	return 0;
+}
+
+static void tsc2005_start_scan(struct tsc2005 *tsc)
+{
+	tsc2005_configure(tsc, TSC2005_CMD_SCAN_XYZZ);
+}
+
+static void tsc2005_stop_scan(struct tsc2005 *tsc)
+{
+	tsc2005_cmd(tsc, TSC2005_CMD_STOP);
+}
+
+/* Must be called with mutex held */
+static void tsc2005_disable(struct tsc2005 *ts)
+{
+	if (ts->disable_depth++ != 0) {
+		return;
+	}
+	disable_irq(ts->irq);
+
+	/* wait until penup timer expire normally */
+	do {
+		msleep(4);
+	} while (ts->sample_sent);
+
+	tsc2005_stop_scan(ts);
+}
+
+static void tsc2005_enable(struct tsc2005 *ts)
+{
+	if (--ts->disable_depth != 0) {
+		return;
+	}
+	enable_irq(ts->irq);
+
+	tsc2005_start_scan(ts);
+}
+
+static ssize_t tsc2005_disable_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct tsc2005 *ts = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", ts->disabled);
+}
+
+static ssize_t tsc2005_disable_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct tsc2005		*tsc = dev_get_drvdata(dev);
+	char *endp;
+	int i;
+
+	i = simple_strtoul(buf, &endp, 10);
+	i = i ? 1 : 0;
+
+	mutex_lock(&tsc->mutex);
+	if (i == tsc->disabled) goto out;
+	tsc->disabled = i;
+
+	if (i)
+		tsc2005_disable(tsc);
+	else
+		tsc2005_enable(tsc);
+out:
+	mutex_unlock(&tsc->mutex);
+	return count;
+}
+
+static DEVICE_ATTR(disable_ts, 0664, tsc2005_disable_show,
+		   tsc2005_disable_store);
+
+
+static int __devinit tsc2005_ts_init(struct tsc2005 *ts,
+				     struct tsc2005_platform_data *pdata)
+{
+	struct input_dev *idev;
+	int dav_gpio, r;
+	int x_max, y_max;
+	int x_fudge, y_fudge, p_fudge;
+
+	if (pdata->dav_gpio < 0) {
+		dev_err(&ts->spi->dev, "need DAV GPIO");
+		return -EINVAL;
+	}
+	dav_gpio = pdata->dav_gpio;
+	ts->dav_gpio = dav_gpio;
+	dev_dbg(&ts->spi->dev, "TSC2005: DAV GPIO = %d\n", dav_gpio);
+
+#ifdef CONFIG_ARCH_OMAP
+	r = omap_request_gpio(dav_gpio);
+	if (r < 0) {
+		dev_err(&ts->spi->dev, "unable to get DAV GPIO");
+		goto err1;
+	}
+	omap_set_gpio_direction(dav_gpio, 1);
+	ts->irq = OMAP_GPIO_IRQ(dav_gpio);
+	dev_dbg(&ts->spi->dev, "TSC2005: DAV IRQ = %d\n", ts->irq);
+#endif
+	init_timer(&ts->penup_timer);
+	setup_timer(&ts->penup_timer, tsc2005_ts_penup_timer_handler,
+			(unsigned long)ts);
+
+	spin_lock_init(&ts->lock);
+	mutex_init(&ts->mutex);
+
+	ts->x_plate_ohm		= pdata->ts_x_plate_ohm ? : 280;
+	ts->hw_avg_max		= pdata->ts_hw_avg;
+	ts->stab_time		= pdata->ts_stab_time;
+	x_max			= pdata->ts_x_max ? : 4096;
+	x_fudge			= pdata->ts_x_fudge ? : 4;
+	y_max			= pdata->ts_y_max ? : 4096;
+	y_fudge			= pdata->ts_y_fudge ? : 8;
+	ts->p_max		= pdata->ts_pressure_max ? : MAX_12BIT;
+	ts->touch_pressure 	= pdata->ts_touch_pressure ? : ts->p_max;
+	p_fudge			= pdata->ts_pressure_fudge ? : 2;
+
+	idev = input_allocate_device();
+	if (idev == NULL) {
+		r = -ENOMEM;
+		goto err2;
+	}
+
+	/*
+	 * TODO: should be "TSC2005 touchscreen", but X has hardcoded these
+	 * strings and doesn't accept TSC2005 yet...
+	 */
+	idev->name = "TSC2301 touchscreen";
+	snprintf(ts->phys, sizeof(ts->phys), "%s/input-ts",
+		 ts->spi->dev.bus_id);
+	idev->phys = ts->phys;
+
+	idev->evbit[0] = BIT(EV_ABS) | BIT(EV_KEY);
+	idev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y) | BIT(ABS_PRESSURE);
+	ts->idev = idev;
+
+	tsc2005_ts_setup_spi_xfer(ts);
+
+	input_set_abs_params(idev, ABS_X, 0, x_max, x_fudge, 0);
+	input_set_abs_params(idev, ABS_Y, 0, y_max, y_fudge, 0);
+	input_set_abs_params(idev, ABS_PRESSURE, 0, ts->p_max, p_fudge, 0);
+
+	tsc2005_start_scan(ts);
+
+	r = request_irq(ts->irq, tsc2005_ts_irq_handler,
+			IRQF_TRIGGER_FALLING | IRQF_DISABLED |
+			IRQF_SAMPLE_RANDOM, "tsc2005", ts);
+	if (r < 0) {
+		dev_err(&ts->spi->dev, "unable to get DAV IRQ");
+		goto err3;
+	}
+
+	set_irq_wake(ts->irq, 1);
+
+	r = input_register_device(idev);
+	if (r < 0) {
+		dev_err(&ts->spi->dev, "can't register touchscreen device\n");
+		goto err4;
+	}
+
+	/* We can tolerate these failing */
+	if (device_create_file(&ts->spi->dev, &dev_attr_pen_down));
+	if (device_create_file(&ts->spi->dev, &dev_attr_disable_ts));
+
+	return 0;
+err4:
+	free_irq(ts->irq, ts);
+err3:
+	tsc2005_stop_scan(ts);
+	input_free_device(idev);
+err2:
+#ifdef CONFIG_ARCH_OMAP
+	omap_free_gpio(dav_gpio);
+#endif
+err1:
+	return r;
+}
+
+static int __devinit tsc2005_probe(struct spi_device *spi)
+{
+	struct tsc2005			*tsc;
+	struct tsc2005_platform_data	*pdata = spi->dev.platform_data;
+	int r;
+
+	if (!pdata) {
+		dev_dbg(&spi->dev, "no platform data?\n");
+		return -ENODEV;
+	}
+
+	tsc = kzalloc(sizeof(*tsc), GFP_KERNEL);
+	if (tsc == NULL)
+		return -ENOMEM;
+
+	dev_set_drvdata(&spi->dev, tsc);
+	tsc->spi = spi;
+	spi->dev.power.power_state = PMSG_ON;
+
+	spi->mode = SPI_MODE_0;
+	spi->bits_per_word = 8;
+	/* The max speed might've been defined by the board-specific
+	 * struct */
+	if (!spi->max_speed_hz)
+		spi->max_speed_hz = TSC2005_HZ;
+
+	spi_setup(spi);
+
+	r = tsc2005_ts_init(tsc, pdata);
+	if (r)
+		goto err1;
+
+	return 0;
+
+err1:
+	kfree(tsc);
+	return r;
+}
+
+static int __devexit tsc2005_remove(struct spi_device *spi)
+{
+	struct tsc2005 *ts = dev_get_drvdata(&spi->dev);
+	unsigned long flags;
+
+	spin_lock_irqsave(&ts->lock, flags);
+	tsc2005_disable(ts);
+	spin_unlock_irqrestore(&ts->lock, flags);
+
+	device_remove_file(&ts->spi->dev, &dev_attr_disable_ts);
+	device_remove_file(&ts->spi->dev, &dev_attr_pen_down);
+
+	free_irq(ts->irq, ts);
+	input_unregister_device(ts->idev);
+
+#ifdef CONFIG_ARCH_OMAP
+	omap_free_gpio(ts->dav_gpio);
+#endif
+	kfree(ts);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int tsc2005_suspend(struct spi_device *spi, pm_message_t mesg)
+{
+	struct tsc2005 *ts = dev_get_drvdata(&spi->dev);
+
+	mutex_lock(&ts->mutex);
+	tsc2005_disable(ts);
+	mutex_unlock(&ts->mutex);
+
+	return 0;
+}
+
+static int tsc2005_resume(struct spi_device *spi)
+{
+	struct tsc2005 *ts = dev_get_drvdata(&spi->dev);
+
+	mutex_lock(&ts->mutex);
+	tsc2005_enable(ts);
+	mutex_unlock(&ts->mutex);
+
+	return 0;
+}
+#endif
+
+static struct spi_driver tsc2005_driver = {
+	.driver = {
+		.name = "tsc2005",
+		.bus = &spi_bus_type,
+		.owner = THIS_MODULE,
+	},
+#ifdef CONFIG_PM
+	.suspend = tsc2005_suspend,
+	.resume = tsc2005_resume,
+#endif
+	.probe = tsc2005_probe,
+	.remove = __devexit_p(tsc2005_remove),
+};
+
+static int __init tsc2005_init(void)
+{
+	printk("TSC2005 driver initializing\n");
+
+	return spi_register_driver(&tsc2005_driver);
+}
+module_init(tsc2005_init);
+
+static void __exit tsc2005_exit(void)
+{
+	spi_unregister_driver(&tsc2005_driver);
+}
+module_exit(tsc2005_exit);
+
+MODULE_AUTHOR("Lauri Leukkunen <lauri.leukkunen@nokia.com>");
+MODULE_LICENSE("GPL");
diff -ruN linux-omap-2.6/drivers/input/touchscreen/tsc2301_ts.c maemo_src/drivers/input/touchscreen/tsc2301_ts.c
--- linux-omap-2.6/drivers/input/touchscreen/tsc2301_ts.c	2011-02-06 20:17:25.709999939 -0500
+++ maemo_src/drivers/input/touchscreen/tsc2301_ts.c	2011-02-06 20:12:10.893333273 -0500
@@ -1,7 +1,7 @@
 /*
  * TSC2301 touchscreen driver
  *
- * Copyright (C) 2005-2006 Nokia Corporation
+ * Copyright (C) 2005-2007 Nokia Corporation
  *
  * Written by Jarkko Oikarinen, Imre Deak and Juha Yrjola
  *
@@ -34,32 +34,29 @@
 
 #include <linux/spi/tsc2301.h>
 
-/**
+/*
  * The touchscreen interface operates as follows:
  *
  * Initialize:
  *    Request access to GPIO103 (DAV)
- *    tsc2301_dav_irq_handler will trigger when DAV line goes down
+ *    tsc2301_ts_irq_handler will trigger when DAV line goes down
  *
  *  1) Pen is pressed against touchscreeen
  *  2) TSC2301 performs AD conversion
  *  3) After the conversion is done TSC2301 drives DAV line down
- *  4) GPIO IRQ is received and tsc2301_dav_irq_handler is called
- *  5) tsc2301_dav_irq_handler sets up tsc2301_ts_timer in TSC2301_TS_SCAN_TIME
- *  6) tsc2301_ts_timer disables the irq and requests spi driver
- *     to read X, Y, Z1 and Z2
- *  7) SPI framework calls tsc2301_ts_rx after the coordinates are read
- *  8) tsc2301_ts_rx reports coordinates to input layer and
- *     sets up tsc2301_ts_timer to be called after TSC2301_TS_SCAN_TIME
- *  9) if tsc2301_tx_timer notices that the pen has been lifted, the lift event
- *     is sent, and irq is again enabled.
+ *  4) GPIO IRQ is received and tsc2301_ts_irq_handler is called
+ *  5) tsc2301_ts_irq_handler queues up an spi transfer to fetch
+ *     the x, y, z1, z2 values
+ *  6) SPI framework calls tsc2301_ts_rx after the coordinates are read
+ *  7) When the penup_timer expires, there have not been DAV interrupts
+ *     during the last 20ms which means the pen has been lifted.
  */
 
 
 #define TSC2301_TOUCHSCREEN_PRODUCT_ID      		0x0052
 #define TSC2301_TOUCHSCREEN_PRODUCT_VERSION 		0x0001
 
-#define TSC2301_TS_SCAN_TIME		     		1
+#define TSC2301_TS_PENUP_TIME		     		20
 
 #define TSC2301_ADCREG_CONVERSION_CTRL_BY_TSC2301	0x8000
 #define TSC2301_ADCREG_CONVERSION_CTRL_BY_HOST		0x0000
@@ -102,39 +99,47 @@
 #define TSC2301_ADCREG_STOP_CONVERSION			0x4000
 
 #define MAX_12BIT					((1 << 12) - 1)
+#define TS_SAMPLES					4
+#define P_SAMPLES					16
+#define TS_RECT_SIZE					8
 
 struct tsc2301_ts {
 	struct input_dev	*idev;
 	char			phys[32];
-	struct timer_list	timer;
+	struct timer_list	penup_timer;
 	spinlock_t		lock;
+	struct mutex		mutex;
 
 	struct spi_transfer	read_xfer[2];
 	struct spi_message	read_msg;
 	u16                     data[4];
 
-	int			hw_avg_max;
+	int			sample_cnt;
+	int 			avg_x;
+	int 			avg_y;
+	int 			p_n;
+	int 			p_buf[P_SAMPLES];
+
 	u16			x;
 	u16			y;
 	u16			p;
-	int			sample_cnt;
 
-	int			ignore_last : 1;
 	u16			x_plate_ohm;
+	int			hw_avg_max;
 	int			stab_time;
-	int			max_pressure;
+	int			p_max;
 	int			touch_pressure;
-	int			pressure_limit;
-
-	u16			irq_enabled:1;
-	u16			pen_down:1;
-	u16			disabled:1;
-	u16			pending:1;
 
-	int			hw_flags;
+	u8			sample_sent;
+	u8			pen_down;
+	u8			pen_active;
+	u8			disabled;
+	u8			disable_depth;
 
 	s16			dav_gpio;
 	int			irq;
+	int			hw_flags;
+	u8			irqs_pending;
 };
 
 
@@ -201,12 +206,12 @@
  */
 static int tsc2301_ts_configure(struct tsc2301 *tsc, int flags)
 {
-	struct spi_transfer xfer[3];
+	struct spi_transfer xfer[5];
 	struct spi_transfer *x;
 	struct spi_message m;
-	int reg = TSC2301_REG_ADC;
+	int i;
 	u16 val1, val2, val3;
-	u16 data[6];
+	u16 data[10];
 
 	val1 = TSC2301_ADCREG_CONVERSION_CTRL_BY_HOST |
 		TSC2301_ADCREG_STOP_CONVERSION |
@@ -227,16 +232,20 @@
 	val3 = TSC2301_ADCREG_CONVERSION_CTRL_BY_TSC2301 |
 		TSC2301_ADCREG_FUNCTION_XYZ |
 		TSC2301_ADCREG_RESOLUTION_12BIT |
-		TSC2301_ADCREG_CLOCK_1MHZ |
+		TSC2301_ADCREG_CLOCK_2MHZ |
 		flags;
 
 	/* Now we prepare the command for transferring */
-	data[0] = reg;
+	data[0] = TSC2301_REG_ADC;
 	data[1] = val1;
-	data[2] = reg;
+	data[2] = TSC2301_REG_ADC;
 	data[3] = val2;
-	data[4] = reg;
+	data[4] = TSC2301_REG_ADC;
 	data[5] = val3;
+	data[6] = TSC2301_REG_REF;
+	data[7] = 1 << 4 | 1 << 2 | 1; /* intref, 100uS settl, 2.5V ref */
+	data[8] = TSC2301_REG_CONFIG;
+	data[9] = 3 << 3 | 2 << 0; /* 340uS pre-chrg, 544us delay */
 
 	spi_message_init(&m);
 	m.spi = tsc->spi;
@@ -244,22 +253,14 @@
 	memset(xfer, 0, sizeof(xfer));
 	x = &xfer[0];
 
-	x->tx_buf = &data[0];
-	x->len = 4;
-	x->cs_change = 1;
-	spi_message_add_tail(x, &m);
-
-	x++;
-	x->tx_buf = &data[2];
-	x->len = 4;
-	x->cs_change = 1;
-	spi_message_add_tail(x, &m);
-
-	x++;
-	x->tx_buf = &data[4];
-	x->len = 4;
-	spi_message_add_tail(x, &m);
-
+	for (i = 0; i < 10; i += 2) {
+		x->tx_buf = &data[i];
+		x->len = 4;
+		if (i != 8)
+			x->cs_change = 1;
+		spi_message_add_tail(x, &m);
+		x++;
+	}
 	spi_sync(m.spi, &m);
 
 	return 0;
@@ -268,40 +269,33 @@
 static void tsc2301_ts_start_scan(struct tsc2301 *tsc)
 {
 	tsc2301_ts_configure(tsc, tsc->ts->hw_flags);
+	tsc2301_kp_restart(tsc);
 }
 
 static void tsc2301_ts_stop_scan(struct tsc2301 *tsc)
 {
-	tsc2301_ts_configure(tsc, TSC2301_ADCREG_STOP_CONVERSION);
-}
-
-static int device_suspended(struct device *dev)
-{
-	struct tsc2301 *tsc = dev_get_drvdata(dev);
-	return dev->power.power_state.event != PM_EVENT_ON || tsc->ts->disabled;
+	tsc2301_write_reg(tsc, TSC2301_REG_ADC, TSC2301_ADCREG_STOP_CONVERSION);
+	tsc2301_kp_restart(tsc);
 }
 
-static void update_pen_state(struct tsc2301_ts *ts, int x, int y, int pressure)
+static void tsc2301_update_pen_state(struct tsc2301_ts *ts, int x, int y, int pressure)
 {
-	int sync = 0;
-
 	if (pressure) {
 		input_report_abs(ts->idev, ABS_X, x);
 		input_report_abs(ts->idev, ABS_Y, y);
 		input_report_abs(ts->idev, ABS_PRESSURE, pressure);
 		if (!ts->pen_down)
 			input_report_key(ts->idev, BTN_TOUCH, 1);
-		sync = 1;
-	} else if (ts->pen_down) {
+		ts->pen_down = 1;
+	} else {
 		input_report_abs(ts->idev, ABS_PRESSURE, 0);
-		input_report_key(ts->idev, BTN_TOUCH, 0);
-		sync = 1;
+		if (ts->pen_down)
+			input_report_key(ts->idev, BTN_TOUCH, 0);
+		ts->pen_down = 0;
 	}
 
-	if (sync)
-		input_sync(ts->idev);
+	input_sync(ts->idev);
 
-	ts->pen_down = pressure ? 1 : 0;
 #ifdef VERBOSE
 	dev_dbg(&tsc->spi->dev, "x %4d y %4d p %4d\n", x, y, pressure);
 #endif
@@ -315,151 +309,177 @@
 {
 	struct tsc2301 *tsc = arg;
 	struct tsc2301_ts *ts = tsc->ts;
-	unsigned int x, y, z1, z2, pressure;
+	unsigned long flags;
+	int inside_rect, pressure_limit;
+	int x, y, z1, z2, pressure;
+	int i;
+
+	spin_lock_irqsave(&ts->lock, flags);
 
 	x  = ts->data[0];
 	y  = ts->data[1];
 	z1 = ts->data[2];
 	z2 = ts->data[3];
 
-	if (z1) {
-		pressure = ts->x_plate_ohm * x;
-		pressure /= 4096;
-		pressure *= z2 - z1;
-		pressure /= z1;
-	} else
-		pressure = 0;
-
-	/* If pressure value is above a preset limit (pen is barely
-	 * touching the screen) we can't trust the coordinate values.
-	 */
-	if (pressure < ts->pressure_limit && x < MAX_12BIT && y < MAX_12BIT) {
-		ts->pressure_limit = ts->max_pressure;
-		if (ts->ignore_last) {
-			if (ts->sample_cnt)
-				update_pen_state(ts, ts->x, ts->y, ts->p);
-			ts->x = x;
-			ts->y = y;
-			ts->p = pressure;
-		} else
-			update_pen_state(ts, x, y, pressure);
-		ts->sample_cnt++;
-	}
+	/* validate position */
+	if (x > MAX_12BIT || y > MAX_12BIT)
+		goto out;
+
+	/* validate pressure */
+	if (z1 < 100 || z1 > 4000 || z2 < z1 || z2 > 4000)
+		goto out;
+	
+	pressure = x * (z2 - z1) / z1;
+	pressure = pressure * ts->x_plate_ohm / 4096;
+	pressure_limit = ts->sample_sent ? ts->p_max : ts->touch_pressure;
+
+	if (pressure > pressure_limit)
+		goto out;
+
+	/* start accumulating average */
+	if (!ts->pen_active) {
+		ts->pen_active = 1;
+		ts->sample_cnt = 0;
+		ts->avg_x = 0;
+		ts->avg_y = 0;
+		ts->p_n = 0;
+		for (i = 0; i < P_SAMPLES; i++)
+			ts->p_buf[i] = 0;
+	}
+		
+
+	ts->avg_x += x;
+	ts->avg_y += y;
+
+	ts->p_buf[ts->p_n++] = pressure;
+	if (ts->p_n >= P_SAMPLES)
+		ts->p_n = 0;
+
+	/* only report the average coords every TS_SAMPLES */
+	if (++ts->sample_cnt < TS_SAMPLES)
+		goto out;
+
+	x = ts->avg_x / TS_SAMPLES;
+	y = ts->avg_y / TS_SAMPLES;
+
+	ts->sample_cnt = 0;
+	ts->avg_x = 0;
+	ts->avg_y = 0;
+
+	/* report the max pressure out of a sliding window */
+	for (i = 0; i < P_SAMPLES; i++)
+		if (ts->p_buf[i] && ts->p_buf[i] < pressure)
+			pressure = ts->p_buf[i];
+
+	/* discard the event if it still is within the previous rect - unless
+	 * if the pressure is harder, but then use previous x,y position */
+	inside_rect = (ts->sample_sent &&
+		x > (int)ts->x - TS_RECT_SIZE &&
+		x < (int)ts->x + TS_RECT_SIZE &&
+		y > (int)ts->y - TS_RECT_SIZE &&
+		y < (int)ts->y + TS_RECT_SIZE);
+	if (inside_rect)
+		x = ts->x, y = ts->y;
+
+	if (!inside_rect || pressure < ts->p) {
+		tsc2301_update_pen_state(ts, x, y, pressure);
+		ts->sample_sent = 1;
+		ts->x = x;
+		ts->y = y;
+		ts->p = pressure;
+	}
+
+out:
+	/* issue a new request if necesary */
+	if (ts->irqs_pending > 1)
+		if (spi_async(tsc->spi, &ts->read_msg))
+			dev_err(&tsc->spi->dev, "ts_rx: spi_async() failed");
 
-	mod_timer(&ts->timer,
-		  jiffies + msecs_to_jiffies(TSC2301_TS_SCAN_TIME));
-}
+	ts->irqs_pending = 0;
 
-static int is_pen_down(struct tsc2301_ts *ts)
-{
-	return ts->pen_down;
+	spin_unlock_irqrestore(&ts->lock, flags);
+
+	mod_timer(&ts->penup_timer,
+		  jiffies + msecs_to_jiffies(TSC2301_TS_PENUP_TIME));
 }
 
-/*
- * Timer is called every TSC2301_TS_SCAN_TIME when the pen is down
- */
-static void tsc2301_ts_timer(unsigned long arg)
+static void tsc2301_ts_timer_handler(unsigned long data)
 {
-	struct tsc2301 *tsc = (void *) arg;
+	struct tsc2301 *tsc = (struct tsc2301 *)data;
 	struct tsc2301_ts *ts = tsc->ts;
 	unsigned long flags;
-	int ndav;
-	int r;
 
 	spin_lock_irqsave(&ts->lock, flags);
-	ndav = omap_get_gpio_datain(ts->dav_gpio);
-	if (ndav || device_suspended(&tsc->spi->dev)) {
-		/* Pen has been lifted */
-		if (!device_suspended(&tsc->spi->dev)) {
-			ts->irq_enabled = 1;
-			enable_irq(ts->irq);
-		}
-		update_pen_state(ts, 0, 0, 0);
-		ts->pending = 0;
-		spin_unlock_irqrestore(&ts->lock, flags);
 
-	} else {
-		ts->pen_down = 1;
+	/* check if we'll be kicked again => do nothing */
+	if (ts->irqs_pending) {
 		spin_unlock_irqrestore(&ts->lock, flags);
+		return;
+	}
 
-		r = spi_async(tsc->spi, &ts->read_msg);
-		if (r)
-			dev_err(&tsc->spi->dev, "ts: spi_async() failed");
+	if (ts->sample_sent) {
+		tsc2301_update_pen_state(ts, 0, 0, 0);
+		ts->sample_sent = 0;
 	}
+
+	ts->pen_active = 0;
+
+	spin_unlock_irqrestore(&ts->lock, flags);
 }
 
 /*
- * This interrupt is called when pen is down and first coordinates are
- * available. That is indicated by a falling edge on DEV line.  IRQ is
- * disabled here because while the pen is down the coordinates are
- * read by a timer.
+ * This interrupt is called when pen is down and coordinates are
+ * available. That is indicated by a falling edge on DEV line.
  */
 static irqreturn_t tsc2301_ts_irq_handler(int irq, void *dev_id)
 {
 	struct tsc2301 *tsc = dev_id;
 	struct tsc2301_ts *ts = tsc->ts;
-	unsigned long flags;
 
-	spin_lock_irqsave(&ts->lock, flags);
-	if (ts->irq_enabled) {
-		ts->irq_enabled = 0;
-		disable_irq(ts->irq);
-		ts->pending = 1;
-		ts->pressure_limit = ts->touch_pressure;
-		ts->sample_cnt = 0;
-		mod_timer(&ts->timer,
-			  jiffies + msecs_to_jiffies(TSC2301_TS_SCAN_TIME));
-	}
-	spin_unlock_irqrestore(&ts->lock, flags);
+	spin_lock(&ts->lock);
+
+	/* schedule a new read request only if none pending */
+	if (!ts->irqs_pending)
+		if (spi_async(tsc->spi, &ts->read_msg)) {
+			dev_err(&tsc->spi->dev, "ts_irq: spi_async() failed");
+			goto out;
+		}
+
+	ts->irqs_pending++;
 
+out:
+	spin_unlock(&ts->lock);
 	return IRQ_HANDLED;
 }
 
-/* Must be called with ts->lock held */
+/* Must be called with mutex held */
 static void tsc2301_ts_disable(struct tsc2301 *tsc)
 {
 	struct tsc2301_ts *ts = tsc->ts;
 
-	if (ts->disabled)
+	if (ts->disable_depth++ != 0) {
 		return;
-
-	ts->disabled = 1;
-	if (!ts->pending) {
-		ts->irq_enabled = 0;
-		disable_irq(ts->irq);
-	} else {
-		while (ts->pending) {
-			spin_unlock_irq(&ts->lock);
-			msleep(1);
-			spin_lock_irq(&ts->lock);
-		}
 	}
+	disable_irq(ts->irq);
+
+	/* wait until penup timer expire normally */
+	do {
+		msleep(4);
+	} while (ts->sample_sent);
 
-	spin_unlock_irq(&ts->lock);
 	tsc2301_ts_stop_scan(tsc);
-	/* Workaround a bug where turning on / off touchscreen scanner
-	 * can get the keypad scanner stuck.
-	 */
-	tsc2301_kp_restart(tsc);
-	spin_lock_irq(&ts->lock);
 }
 
 static void tsc2301_ts_enable(struct tsc2301 *tsc)
 {
 	struct tsc2301_ts *ts = tsc->ts;
 
-	if (!ts->disabled)
+	if (--ts->disable_depth != 0) {
 		return;
-
-	ts->disabled = 0;
-	ts->irq_enabled = 1;
+	}
 	enable_irq(ts->irq);
 
-	spin_unlock_irq(&ts->lock);
 	tsc2301_ts_start_scan(tsc);
-	/* Same workaround as above. */
-	tsc2301_kp_restart(tsc);
-	spin_lock_irq(&ts->lock);
 }
 
 #ifdef CONFIG_PM
@@ -467,9 +487,9 @@
 {
 	struct tsc2301_ts *ts = tsc->ts;
 
-	spin_lock_irq(&ts->lock);
+	mutex_lock(&ts->mutex);
 	tsc2301_ts_disable(tsc);
-	spin_unlock_irq(&ts->lock);
+	mutex_unlock(&ts->mutex);
 
 	return 0;
 }
@@ -478,9 +498,9 @@
 {
 	struct tsc2301_ts *ts = tsc->ts;
 
-	spin_lock_irq(&ts->lock);
+	mutex_lock(&ts->mutex);
 	tsc2301_ts_enable(tsc);
-	spin_unlock_irq(&ts->lock);
+	mutex_unlock(&ts->mutex);
 }
 #endif
 
@@ -511,7 +531,7 @@
 {
 	struct tsc2301 *tsc = dev_get_drvdata(dev);
 
-	return sprintf(buf, "%u\n", is_pen_down(tsc->ts));
+	return sprintf(buf, "%u\n", tsc->ts->pen_down);
 }
 
 static DEVICE_ATTR(pen_down, S_IRUGO, tsc2301_ts_pen_down_show, NULL);
@@ -535,15 +555,17 @@
 	int i;
 
 	i = simple_strtoul(buf, &endp, 10);
-	spin_lock_irq(&ts->lock);
+	i = i ? 1 : 0;
+	mutex_lock(&ts->mutex);
+	if (i == ts->disabled) goto out;
+	ts->disabled = i;
 
 	if (i)
 		tsc2301_ts_disable(tsc);
 	else
 		tsc2301_ts_enable(tsc);
-
-	spin_unlock_irq(&ts->lock);
-
+out:
+	mutex_unlock(&ts->mutex);
 	return count;
 }
 
@@ -556,6 +578,8 @@
 	struct tsc2301_ts *ts;
 	struct input_dev *idev;
 	int dav_gpio, r;
+	int x_max, y_max;
+	int x_fudge, y_fudge, p_fudge;
 
 	if (pdata->dav_gpio < 0) {
 		dev_err(&tsc->spi->dev, "need DAV GPIO");
@@ -578,18 +602,24 @@
 	omap_set_gpio_direction(dav_gpio, 1);
 	ts->irq = OMAP_GPIO_IRQ(dav_gpio);
 #endif
-	init_timer(&ts->timer);
-	ts->timer.data = (unsigned long) tsc;
-	ts->timer.function = tsc2301_ts_timer;
+	init_timer(&ts->penup_timer);
+	setup_timer(&ts->penup_timer, tsc2301_ts_timer_handler,
+			(unsigned long)tsc);
 
 	spin_lock_init(&ts->lock);
+	mutex_init(&ts->mutex);
 
-	ts->x_plate_ohm	= pdata->ts_x_plate_ohm ? : 280;
-	ts->hw_avg_max	= pdata->ts_hw_avg;
-	ts->max_pressure= pdata->ts_max_pressure ? : MAX_12BIT;
-	ts->touch_pressure = pdata->ts_touch_pressure ? : ts->max_pressure;
-	ts->ignore_last	= pdata->ts_ignore_last;
-	ts->stab_time	= pdata->ts_stab_time;
+	ts->x_plate_ohm		= pdata->ts_x_plate_ohm ? : 280;
+	ts->hw_avg_max		= pdata->ts_hw_avg;
+	ts->stab_time		= pdata->ts_stab_time;
+	ts->p_max		= pdata->ts_pressure_max ? : MAX_12BIT;
+	ts->touch_pressure	= pdata->ts_touch_pressure ? : ts->p_max;
+
+	x_max		= pdata->ts_x_max ? : 4096;
+	y_max		= pdata->ts_y_max ? : 4096;
+	x_fudge		= pdata->ts_x_fudge ? : 4;
+	y_fudge		= pdata->ts_y_fudge ? : 8;
+	p_fudge		= pdata->ts_pressure_fudge ? : 2;
 
 	if ((r = tsc2301_ts_check_config(ts, &ts->hw_flags))) {
 		dev_err(&tsc->spi->dev, "invalid configuration\n");
@@ -613,13 +643,12 @@
 	tsc2301_ts_setup_spi_xfer(tsc);
 
 	/* These parameters should perhaps be configurable? */
-	input_set_abs_params(idev, ABS_X, 0, 4096, 0, 0);
-	input_set_abs_params(idev, ABS_Y, 0, 4096, 0, 0);
-	input_set_abs_params(idev, ABS_PRESSURE, 0, 1024, 0, 0);
+	input_set_abs_params(idev, ABS_X, 0, x_max, x_fudge, 0);
+	input_set_abs_params(idev, ABS_Y, 0, y_max, y_fudge, 0);
+	input_set_abs_params(idev, ABS_PRESSURE, 0, ts->p_max, p_fudge, 0);
 
 	tsc2301_ts_start_scan(tsc);
 
-	ts->irq_enabled = 1;
 	r = request_irq(ts->irq, tsc2301_ts_irq_handler,
 			SA_SAMPLE_RANDOM | SA_TRIGGER_FALLING,
 			"tsc2301-ts", tsc);
diff -ruN linux-omap-2.6/drivers/leds/leds-omap-pwm.c maemo_src/drivers/leds/leds-omap-pwm.c
--- linux-omap-2.6/drivers/leds/leds-omap-pwm.c	2011-02-06 20:17:25.713333273 -0500
+++ maemo_src/drivers/leds/leds-omap-pwm.c	2011-02-06 20:12:10.986666606 -0500
@@ -16,17 +16,20 @@
 #include <linux/platform_device.h>
 #include <linux/leds.h>
 #include <linux/ctype.h>
+#include <linux/sched.h>
 #include <asm/delay.h>
 #include <asm/arch/board.h>
 #include <asm/arch/dmtimer.h>
 
 struct omap_pwm_led {
 	struct led_classdev cdev;
+	struct work_struct work;
 	struct omap_pwm_led_platform_data *pdata;
 	struct omap_dm_timer *intensity_timer;
 	struct omap_dm_timer *blink_timer;
 	int powered;
 	unsigned int on_period, off_period;
+	enum led_brightness brightness;
 };
 
 static inline struct omap_pwm_led *pdev_to_omap_pwm_led(struct platform_device *pdev)
@@ -39,6 +42,11 @@
 	return container_of(led_cdev, struct omap_pwm_led, cdev);
 }
 
+static inline struct omap_pwm_led *work_to_omap_pwm_led(struct work_struct *work)
+{
+	return container_of(work, struct omap_pwm_led, work);
+}
+
 static void omap_pwm_led_set_blink(struct omap_pwm_led *led)
 {
 	if (!led->powered)
@@ -134,9 +142,17 @@
 {
 	struct omap_pwm_led *led = cdev_to_omap_pwm_led(led_cdev);
 
-	if (value != LED_OFF) {
+	led->brightness = value;
+	schedule_work(&led->work);
+}
+
+static void omap_pwm_led_work(struct work_struct *work)
+{
+	struct omap_pwm_led *led = work_to_omap_pwm_led(work);
+
+	if (led->brightness != LED_OFF) {
 		omap_pwm_led_power_on(led);
-		omap_pwm_led_set_pwm_cycle(led, value);
+		omap_pwm_led_set_pwm_cycle(led, led->brightness);
 	} else {
 		omap_pwm_led_power_off(led);
 	}
@@ -228,6 +244,8 @@
 	led->cdev.default_trigger = NULL;
 	led->cdev.name = pdata->name;
 	led->pdata = pdata;
+	led->brightness = 0;
+	INIT_WORK(&led->work, omap_pwm_led_work);
 
 	dev_info(&pdev->dev, "OMAP PWM LED (%s) at GP timer %d/%d\n",
 		 pdata->name, pdata->intensity_timer, pdata->blink_timer);
@@ -269,6 +287,9 @@
 
 	}
 
+	if (led->pdata->set_power != NULL)
+		led->pdata->set_power(led->pdata, 0);
+
 	return 0;
 
 error_blink3:
diff -ruN linux-omap-2.6/drivers/media/video/omap/Kconfig maemo_src/drivers/media/video/omap/Kconfig
--- linux-omap-2.6/drivers/media/video/omap/Kconfig	2011-02-06 20:17:25.716666607 -0500
+++ maemo_src/drivers/media/video/omap/Kconfig	2007-10-02 03:09:31.000000000 -0400
@@ -10,3 +10,7 @@
 	depends on VIDEO_OMAP_CAMERA
 	help
 	  OmniVision 9640 camera sensor support
+
+config VIDEO_CAMERA_SENSOR_TCM825X
+	tristate "TCM825x sensor support"
+	depends on VIDEO_OMAP_CAMERA
diff -ruN linux-omap-2.6/drivers/media/video/omap/Makefile maemo_src/drivers/media/video/omap/Makefile
--- linux-omap-2.6/drivers/media/video/omap/Makefile	2011-02-06 20:17:25.716666607 -0500
+++ maemo_src/drivers/media/video/omap/Makefile	2007-10-02 03:09:31.000000000 -0400
@@ -2,11 +2,15 @@
 
 obj-$(CONFIG_VIDEO_OMAP_CAMERA) += omapcamera.o
 obj-$(CONFIG_VIDEO_CAMERA_SENSOR_OV9640) += sensor_ov9640.o
+obj-$(CONFIG_VIDEO_CAMERA_SENSOR_TCM825X) += sensor_tcm825x.o
 
 objs-y$(CONFIG_ARCH_OMAP16XX) += omap16xxcam.o camera_core.o
+objs-y$(CONFIG_ARCH_OMAP24XX) += omap24xxcam.o omap24xxcam-dma.o
 objs-y$(CONFIG_MACH_OMAP_H3) += h3_sensor_power.o
 objs-y$(CONFIG_MACH_OMAP_H4) += h4_sensor_power.o
 
+obj-$(CONFIG_VIDEO_DEV) += sensor_if.o
+
 omapcamera-objs := $(objs-yy)
 
 EXTRA_CFLAGS = -I$(src)/..
diff -ruN linux-omap-2.6/drivers/media/video/omap/omap24xxcam.c maemo_src/drivers/media/video/omap/omap24xxcam.c
--- linux-omap-2.6/drivers/media/video/omap/omap24xxcam.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/media/video/omap/omap24xxcam.c	2011-02-06 20:12:12.913333272 -0500
@@ -0,0 +1,1797 @@
+/*
+ * omap24xxcam.c
+ *
+ * OMAP 2 camera block driver.
+ *
+ * Copyright (C) 2004 MontaVista Software, Inc.
+ * Copyright (C) 2004 Texas Instruments.
+ * Copyright (C) 2007 Nokia Corporation.
+ *
+ * Contact: Sakari Ailus <sakari.ailus@nokia.com>
+ *
+ * Based on code from Andy Lowe <source@mvista.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/videodev2.h>
+#include <linux/pci.h>		/* needed for videobufs */
+#include <linux/version.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <media/v4l2-common.h>
+
+#include <asm/io.h>
+#include <asm/arch/dvfs.h>
+
+#include "omap24xxcam.h"
+
+#include "sensor_if.h"
+
+#define RESET_TIMEOUT_NS 10000
+
+static void omap24xxcam_reset(struct omap24xxcam_device *cam);
+static int omap24xxcam_device_register(struct omap24xxcam_device *cam);
+static void omap24xxcam_device_unregister(struct omap24xxcam_device *cam);
+static int omap24xxcam_remove(struct platform_device *pdev);
+
+/* module parameters */
+static int video_nr = -1;	/* video device minor (-1 ==> auto assign) */
+/* Maximum amount of memory to use for capture buffers.
+ * Default is 4800KB, enough to double-buffer SXGA.
+ */
+static int capture_mem = 1280 * 960 * 2 * 2;
+
+/*
+ *
+ * Clocks.
+ *
+ */
+
+static void omap24xxcam_clock_put(struct omap24xxcam_device *cam)
+{
+	if (cam->ick != NULL && !IS_ERR(cam->ick))
+		clk_put(cam->ick);
+	if (cam->fck != NULL && !IS_ERR(cam->fck))
+		clk_put(cam->fck);
+
+	cam->ick = cam->fck = NULL;
+}
+
+static int omap24xxcam_clock_get(struct omap24xxcam_device *cam)
+{
+	int rval = 0;
+
+	cam->fck = clk_get(cam->dev, "cam_fck");
+	if (IS_ERR(cam->fck)) {
+		dev_err(cam->dev, "can't get cam_fck");
+		rval = PTR_ERR(cam->fck);
+		omap24xxcam_clock_put(cam);
+		return rval;
+	}
+
+	cam->ick = clk_get(cam->dev, "cam_ick");
+	if (IS_ERR(cam->ick)) {
+		dev_err(cam->dev, "can't get cam_ick");
+		rval = PTR_ERR(cam->ick);
+		omap24xxcam_clock_put(cam);
+	}
+
+	return rval;
+}
+
+static void omap24xxcam_clock_on(struct omap24xxcam_device *cam)
+{
+	clk_enable(cam->fck);
+	clk_enable(cam->ick);
+}
+
+static void omap24xxcam_clock_off(struct omap24xxcam_device *cam)
+{
+	clk_disable(cam->fck);
+	clk_disable(cam->ick);
+}
+
+/*
+ *
+ * Camera core
+ *
+ */
+
+/*
+ * Set xclk.
+ *
+ * If the given value is not usable, the next possible lower value
+ * will be selected.
+ *
+ * To disable xclk, use value zero.
+ *
+ * The selected xclk value is returned.
+ */
+static u32 omap24xxcam_core_xclk_set(const struct omap24xxcam_device *cam,
+				     u32 xclk)
+{
+	u32 divisor;
+
+	if (xclk) {
+		if (xclk > CAM_MCLK)
+			xclk = CAM_MCLK;
+
+		divisor = CAM_MCLK / xclk;
+		if (xclk * divisor < CAM_MCLK)
+			divisor += 1;
+		if (divisor > 30)
+			divisor = 30;
+		xclk = CAM_MCLK / divisor;
+
+		if (divisor == 1)
+			omap24xxcam_reg_out(cam->mmio_base + CC_REG_OFFSET,
+					    CC_CTRL_XCLK,
+					    CC_CTRL_XCLK_DIV_BYPASS);
+		else
+			omap24xxcam_reg_out(cam->mmio_base + CC_REG_OFFSET,
+					    CC_CTRL_XCLK, divisor);
+	} else
+		omap24xxcam_reg_out(cam->mmio_base + CC_REG_OFFSET,
+				    CC_CTRL_XCLK, CC_CTRL_XCLK_DIV_STABLE_LOW);
+
+	return xclk;
+}
+
+static void omap24xxcam_core_hwinit(const struct omap24xxcam_device *cam)
+{
+	/* Setting the camera core AUTOIDLE bit causes problems with frame
+	 * synchronization, so we will clear the AUTOIDLE bit instead.
+	 */
+	//omap24xxcam_reg_out(cam, CC_SYSCONFIG, 0);
+	omap24xxcam_reg_out(cam->mmio_base + CC_REG_OFFSET, CC_SYSCONFIG,
+			    CC_SYSCONFIG_AUTOIDLE);
+
+	/* program the camera interface DMA packet size */
+	omap24xxcam_reg_out(cam->mmio_base + CC_REG_OFFSET, CC_CTRL_DMA,
+			    CC_CTRL_DMA_EN | (DMA_THRESHOLD / 4 - 1));
+
+	/* enable camera core error interrupts */
+	omap24xxcam_reg_out(cam->mmio_base + CC_REG_OFFSET, CC_IRQENABLE,
+			    CC_IRQENABLE_FW_ERR_IRQ
+			    | CC_IRQENABLE_FSC_ERR_IRQ
+			    | CC_IRQENABLE_SSC_ERR_IRQ
+			    | CC_IRQENABLE_FIFO_OF_IRQ);
+}
+
+/*
+ * Enable the camera core.
+ *
+ * Data transfer to the camera DMA starts from next starting frame.
+ */
+static void omap24xxcam_core_enable(const struct omap24xxcam_device *cam)
+{
+	omap24xxcam_reg_out(cam->mmio_base + CC_REG_OFFSET, CC_CTRL,
+			    CC_CTRL_NOBT_SYNCHRO
+			    | CC_CTRL_PAR_CLK_POL
+			    | CC_CTRL_PAR_MODE_NOBT8
+			    | CC_CTRL_CC_EN);
+}
+
+/*
+ * Disable camera core.
+ *
+ * The data transfer will be stopped immediately (CC_CTRL_CC_RST). The
+ * core internal state machines will be reset. Use
+ * CC_CTRL_CC_FRAME_TRIG instead if you want to transfer the current
+ * frame completely.
+ */
+static void omap24xxcam_core_disable(const struct omap24xxcam_device *cam)
+{
+	omap24xxcam_reg_out(cam->mmio_base + CC_REG_OFFSET, CC_CTRL,
+			    CC_CTRL_CC_RST);
+}
+
+/* Interrupt service routine for camera core interrupts. */
+static void omap24xxcam_core_isr(struct omap24xxcam_device *cam)
+{
+	u32 cc_irqstatus;
+	const u32 cc_irqstatus_err =
+		CC_IRQSTATUS_FW_ERR_IRQ
+		| CC_IRQSTATUS_FSC_ERR_IRQ
+		| CC_IRQSTATUS_SSC_ERR_IRQ
+		| CC_IRQSTATUS_FIFO_UF_IRQ
+		| CC_IRQSTATUS_FIFO_OF_IRQ;
+
+	cc_irqstatus = omap24xxcam_reg_in(cam->mmio_base + CC_REG_OFFSET,
+					  CC_IRQSTATUS);
+	omap24xxcam_reg_out(cam->mmio_base + CC_REG_OFFSET, CC_IRQSTATUS,
+			    cc_irqstatus);
+
+	if (cc_irqstatus & cc_irqstatus_err
+	    && !atomic_read(&cam->in_reset)) {
+		dev_dbg(cam->dev, "resetting camera, cc_irqstatus 0x%x\n",
+			cc_irqstatus);
+		omap24xxcam_reset(cam);
+	}
+}
+
+/*
+ *
+ * videobuf_buffer handling.
+ *
+ * Memory for mmapped videobuf_buffers is not allocated
+ * conventionally, but by several kmalloc allocations and then
+ * creating the scatterlist on our own. User-space buffers are handled
+ * normally.
+ *
+ */
+
+/*
+ * Free the memory-mapped buffer memory allocated for a
+ * videobuf_buffer and the associated scatterlist.
+ */
+static void omap24xxcam_vbq_free_mmap_buffer(struct videobuf_buffer *vb)
+{
+	int i;
+	size_t alloc_size;
+	struct page *page;
+
+	if (vb->dma.sglist == NULL)
+		return;
+
+	i = vb->dma.sglen;
+	while (i) {
+		i--;
+		alloc_size = vb->dma.sglist[i].length;
+		page = vb->dma.sglist[i].page;
+		do {
+			ClearPageReserved(page++);
+		} while (alloc_size -= PAGE_SIZE);
+		__free_pages(vb->dma.sglist[i].page,
+			     get_order(vb->dma.sglist[i].length));
+	}
+
+	kfree(vb->dma.sglist);
+	vb->dma.sglist = NULL;
+}
+
+/* Release all memory related to the videobuf_queue. */
+static void omap24xxcam_vbq_free_mmap_buffers(struct videobuf_queue *vbq)
+{
+	int i;
+
+	mutex_lock(&vbq->lock);
+
+	for (i = 0; i < VIDEO_MAX_FRAME; i++) {
+		if (NULL == vbq->bufs[i])
+			continue;
+		if (V4L2_MEMORY_MMAP != vbq->bufs[i]->memory)
+			continue;
+		vbq->ops->buf_release(vbq, vbq->bufs[i]);
+		omap24xxcam_vbq_free_mmap_buffer(vbq->bufs[i]);
+		kfree(vbq->bufs[i]);
+		vbq->bufs[i] = NULL;
+	}
+
+	mutex_unlock(&vbq->lock);
+
+	videobuf_mmap_free(vbq);
+}
+
+/*
+ * Allocate physically as contiguous as possible buffer for video
+ * frame and allocate and build DMA scatter-gather list for it.
+ */
+static int omap24xxcam_vbq_alloc_mmap_buffer(struct videobuf_buffer *vb)
+{
+	unsigned int order;
+	size_t alloc_size, size = vb->bsize; /* vb->bsize is page aligned */
+	struct page *page;
+	int max_pages, err = 0, i = 0;
+
+	/* allocate maximum size scatter-gather list. Note this is overhead. We
+	 * may not use as many entries as we allocate */
+	max_pages = vb->bsize >> PAGE_SHIFT;
+	vb->dma.sglist =
+		kcalloc(max_pages, sizeof(*vb->dma.sglist), GFP_KERNEL);
+	if (vb->dma.sglist == NULL) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	while (size) {
+		order = get_order(size);
+		/* do not over-allocate even if we would get larger contiguous
+		 * chunk that way */
+		if ((PAGE_SIZE << order) > size)
+			order--;
+
+		/* try to allocate as many contiguous pages as possible */
+		page = alloc_pages(GFP_KERNEL | GFP_DMA, order);
+		/* if allocation fails, try to allocate smaller amount */
+		while (page == NULL) {
+			order--;
+			page = alloc_pages(GFP_KERNEL | GFP_DMA, order);
+			if (page == NULL && !order) {
+				err = -ENOMEM;
+				goto out;
+			}
+		}
+		size -= (PAGE_SIZE << order);
+
+		/* append allocated chunk of pages into scatter-gather list */
+		vb->dma.sglist[i].page = page;
+		vb->dma.sglist[i].length = (PAGE_SIZE << order);
+		vb->dma.sglen++;
+		i++;
+
+		alloc_size = (PAGE_SIZE << order);
+
+		/* clear pages before giving them to user space */
+		memset(page_address(page), 0, alloc_size);
+
+		/* mark allocated pages reserved */
+		do {
+			SetPageReserved(page++);
+		} while (alloc_size -= PAGE_SIZE);
+	}
+	/* REVISIT: not fully correct to assign nr_pages == sglen but video-buf
+	 * is passing nr_pages for e.g. unmap_sg calls */
+	vb->dma.nr_pages = vb->dma.sglen;
+	vb->dma.direction = PCI_DMA_FROMDEVICE;
+
+	return 0;
+
+out:
+	omap24xxcam_vbq_free_mmap_buffer(vb);
+	return err;
+}
+
+static int omap24xxcam_vbq_alloc_mmap_buffers(struct videobuf_queue *vbq,
+					      unsigned int count)
+{
+	int i, err = 0;
+	struct omap24xxcam_fh *fh =
+		container_of(vbq, struct omap24xxcam_fh, vbq);
+
+	mutex_lock(&vbq->lock);
+
+	for (i = 0; i < count; i++) {
+		err = omap24xxcam_vbq_alloc_mmap_buffer(vbq->bufs[i]);
+		if (err)
+			goto out;
+		dev_dbg(fh->cam->dev, "sglen is %d for buffer %d\n",
+			vbq->bufs[i]->dma.sglen, i);
+	}
+
+	mutex_unlock(&vbq->lock);
+
+	return 0;
+out:
+	while (i) {
+		i--;
+		omap24xxcam_vbq_free_mmap_buffer(vbq->bufs[i]);
+	}
+
+	mutex_unlock(&vbq->lock);
+
+	return err;
+}
+
+/* This routine is called from interrupt context when a scatter-gather DMA
+ * transfer of a videobuf_buffer completes.
+ */
+static void omap24xxcam_vbq_complete(struct omap24xxcam_sgdma *sgdma,
+				     u32 csr, void *arg)
+{
+	struct omap24xxcam_device *cam =
+		container_of(sgdma, struct omap24xxcam_device, sgdma);
+	struct omap24xxcam_fh *fh = cam->streaming->private_data;
+	struct videobuf_buffer *vb = (struct videobuf_buffer *)arg;
+	const u32 csr_error = CAMDMA_CSR_MISALIGNED_ERR
+		| CAMDMA_CSR_SUPERVISOR_ERR | CAMDMA_CSR_SECURE_ERR
+		| CAMDMA_CSR_TRANS_ERR | CAMDMA_CSR_DROP;
+	unsigned long flags;
+
+	spin_lock_irqsave(&cam->core_enable_disable_lock, flags);
+	if (--cam->sgdma_in_queue == 0)
+		omap24xxcam_core_disable(cam);
+	if (time_before(cam->next_reset_at, jiffies)
+	    && !atomic_read(&cam->in_reset)) {
+		spin_unlock_irqrestore(&cam->core_enable_disable_lock, flags);
+		omap24xxcam_reset(cam);
+	} else {
+		spin_unlock_irqrestore(&cam->core_enable_disable_lock, flags);
+	}
+
+	do_gettimeofday(&vb->ts);
+	vb->field_count = atomic_add_return(2, &fh->field_count);
+	if (csr & csr_error) {
+		vb->state = STATE_ERROR;
+		if (!atomic_read(&cam->in_reset)) {
+			dev_dbg(cam->dev, "resetting camera, csr 0x%x\n", csr);
+			omap24xxcam_reset(cam);
+		}
+	} else
+		vb->state = STATE_DONE;
+	wake_up(&vb->done);
+}
+
+static void omap24xxcam_vbq_release(struct videobuf_queue *vbq,
+				    struct videobuf_buffer *vb)
+{
+	struct videobuf_dmabuf *dma = &vb->dma;
+
+	/* wait for buffer, especially to get out of the sgdma queue */
+	videobuf_waiton(vb, 0, 0);
+	if (vb->memory == V4L2_MEMORY_MMAP) {
+		dma_unmap_sg(vbq->dev, dma->sglist, dma->sglen,
+			     dma->direction);
+		dma->direction = DMA_NONE;
+	} else {
+		videobuf_dma_unmap(vbq, &vb->dma);
+		videobuf_dma_free(&vb->dma);
+	}
+
+	vb->state = STATE_NEEDS_INIT;
+}
+
+/* Limit the number of available kernel image capture buffers based on the
+ * number requested, the currently selected image size, and the maximum
+ * amount of memory permitted for kernel capture buffers.
+ */
+static int omap24xxcam_vbq_setup(struct videobuf_queue *vbq, unsigned int *cnt,
+				 unsigned int *size)
+{
+	struct omap24xxcam_fh *fh = vbq->priv_data;
+
+	if (*cnt <= 0)
+		*cnt = VIDEO_MAX_FRAME;	/* supply a default number of buffers */
+
+	if (*cnt > VIDEO_MAX_FRAME)
+		*cnt = VIDEO_MAX_FRAME;
+
+	*size = fh->pix.sizeimage;
+
+	/* accessing fh->cam->capture_mem is ok, it's constant */
+	while (*size * *cnt > fh->cam->capture_mem)
+		(*cnt)--;
+
+	return 0;
+}
+
+static int omap24xxcam_dma_iolock(struct videobuf_queue *vbq,
+				  struct videobuf_dmabuf *dma)
+{
+	int err = 0;
+
+	dma->direction = PCI_DMA_FROMDEVICE;
+	if (!dma_map_sg(vbq->dev, dma->sglist, dma->sglen, dma->direction)) {
+		kfree(dma->sglist);
+		dma->sglist = NULL;
+		dma->sglen = 0;
+		err = -EIO;
+	}
+
+	return err;
+}
+
+static int omap24xxcam_vbq_prepare(struct videobuf_queue *vbq,
+				   struct videobuf_buffer *vb,
+				   enum v4l2_field field)
+{
+	struct omap24xxcam_fh *fh = vbq->priv_data;
+	int err = 0;
+
+	/* accessing pix here is okay since it's constant while
+	 * streaming is on (and we only get called then). */
+
+	if (vb->baddr) {
+		/* This is a userspace buffer. */
+		if (fh->pix.sizeimage > vb->bsize) {
+			/* The buffer isn't big enough. */
+			err = -EINVAL;
+		} else
+			vb->size = fh->pix.sizeimage;
+	} else {
+		if (vb->state != STATE_NEEDS_INIT) {
+			/* We have a kernel bounce buffer that has already been
+			 * allocated.
+			 */
+			if (fh->pix.sizeimage > vb->size) {
+				/* The image size has been changed to a larger
+				 * size since this buffer was allocated, so we
+				 * need to free and reallocate it.
+				 */
+				omap24xxcam_vbq_release(vbq, vb);
+				vb->size = fh->pix.sizeimage;
+			}
+		} else {
+			/* We need to allocate a new kernel bounce buffer. */
+			vb->size = fh->pix.sizeimage;
+		}
+	}
+
+	if (err)
+		return err;
+
+	vb->width = fh->pix.width;
+	vb->height = fh->pix.height;
+	vb->field = field;
+
+	if (vb->state == STATE_NEEDS_INIT) {
+		if (vb->memory == V4L2_MEMORY_MMAP)
+			/* we have built the scatter-gather list by ourself so
+			 * do the scatter-gather mapping as well */
+			err = omap24xxcam_dma_iolock(vbq, &vb->dma);
+		else
+			err = videobuf_iolock(vbq, vb, NULL);
+	}
+
+	if (!err)
+		vb->state = STATE_PREPARED;
+	else
+		omap24xxcam_vbq_release(vbq, vb);
+
+	return err;
+}
+
+static void omap24xxcam_vbq_queue(struct videobuf_queue *vbq,
+				  struct videobuf_buffer *vb)
+{
+	struct omap24xxcam_fh *fh = vbq->priv_data;
+	struct omap24xxcam_device *cam = fh->cam;
+	enum videobuf_state state = vb->state;
+	unsigned long flags;
+	int err;
+
+	/*
+	 * FIXME: We're marking the buffer active since we have no
+	 * pretty way of marking it active exactly when the
+	 * scatter-gather transfer starts.
+	 */
+	vb->state = STATE_ACTIVE;
+
+	err = omap24xxcam_sgdma_queue(&fh->cam->sgdma, vb->dma.sglist,
+				      vb->dma.sglen, vb->size,
+				      omap24xxcam_vbq_complete, vb);
+
+	if (!err) {
+		spin_lock_irqsave(&cam->core_enable_disable_lock, flags);
+		if (++cam->sgdma_in_queue == 1
+		    && !atomic_read(&cam->in_reset))
+			omap24xxcam_core_enable(cam);
+		spin_unlock_irqrestore(&cam->core_enable_disable_lock, flags);
+	} else {
+		/* Oops.  We're not supposed to get any errors here.  The only
+		 * way we could get an error is if we ran out of scatter-gather
+		 * DMA slots, but we are supposed to have at least as many
+		 * scatter-gather DMA slots as video buffers so that can't
+		 * happen.
+		 */
+		dev_err(cam->dev, "failed to queue a video buffer for dma!\n");
+		dev_err(cam->dev, "likely a bug in the driver!\n");
+		vb->state = state;
+	}
+}
+
+static struct videobuf_queue_ops omap24xxcam_vbq_ops = {
+	.buf_setup = omap24xxcam_vbq_setup,
+	.buf_prepare = omap24xxcam_vbq_prepare,
+	.buf_queue = omap24xxcam_vbq_queue,
+	.buf_release = omap24xxcam_vbq_release,
+};
+
+/*
+ *
+ * OMAP main camera system
+ *
+ */
+
+/*
+ * Reset camera block to power-on state.
+ */
+static void omap24xxcam_poweron_reset(const struct omap24xxcam_device *cam)
+{
+	int max_loop = RESET_TIMEOUT_NS;
+
+	/* Reset whole camera subsystem */
+	omap24xxcam_reg_out(cam->mmio_base,
+			    CAM_SYSCONFIG,
+			    CAM_SYSCONFIG_SOFTRESET);
+
+	/* Wait till it's finished */
+	while (!(omap24xxcam_reg_in(cam->mmio_base, CAM_SYSSTATUS)
+		 & CAM_SYSSTATUS_RESETDONE)
+	       && --max_loop) {
+		ndelay(1);
+	}
+
+	if (!(omap24xxcam_reg_in(cam->mmio_base, CAM_SYSSTATUS)
+	      & CAM_SYSSTATUS_RESETDONE))
+		dev_err(cam->dev, "camera soft reset timeout\n");
+}
+
+/*
+ * (Re)initialise the camera block.
+ */
+static void omap24xxcam_hwinit(const struct omap24xxcam_device *cam)
+{
+	omap24xxcam_poweron_reset(cam);
+
+	/* set the camera subsystem autoidle bit */
+	omap24xxcam_reg_out(cam->mmio_base, CAM_SYSCONFIG,
+			    CAM_SYSCONFIG_AUTOIDLE);
+
+	/* set the camera MMU autoidle bit */
+	omap24xxcam_reg_out(cam->mmio_base,
+			    CAMMMU_REG_OFFSET + CAMMMU_SYSCONFIG,
+			    CAMMMU_SYSCONFIG_AUTOIDLE);
+
+	omap24xxcam_core_hwinit(cam);
+
+	omap24xxcam_dma_hwinit(&cam->sgdma.dma);
+}
+
+/*
+ * Callback for dma transfer stalling.
+ */
+static void omap24xxcam_stalled_dma_reset(unsigned long data)
+{
+	struct omap24xxcam_device *cam = (struct omap24xxcam_device *)data;
+
+	if (!atomic_read(&cam->in_reset)) {
+		dev_dbg(cam->dev, "dma stalled, resetting camera\n");
+		omap24xxcam_reset(cam);
+	}
+}
+
+/*
+ * Stop capture. Mark we're doing a reset, stop DMA transfers and
+ * core. (No new scatter-gather transfers will be queued whilst
+ * in_reset is non-zero.)
+ *
+ * If omap24xxcam_capture_stop is called from several places at
+ * once, only the first call will have an effect. Similarly, the last
+ * call omap24xxcam_streaming_cont will have effect.
+ *
+ * Serialisation is ensured by using cam->core_enable_disable_lock.
+ */
+static void omap24xxcam_capture_stop(struct omap24xxcam_device *cam)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&cam->core_enable_disable_lock, flags);
+
+	if (atomic_inc_return(&cam->in_reset) != 1) {
+		spin_unlock_irqrestore(&cam->core_enable_disable_lock, flags);
+		return;
+	}
+
+	omap24xxcam_core_disable(cam);
+
+	spin_unlock_irqrestore(&cam->core_enable_disable_lock, flags);
+
+	omap24xxcam_sgdma_sync(&cam->sgdma);
+}
+
+/*
+ * Reset and continue streaming.
+ *
+ * Note: Resetting the camera FIFO via the CC_RST bit in the CC_CTRL
+ * register is supposed to be sufficient to recover from a camera
+ * interface error, but it doesn't seem to be enough. If we only do
+ * that then subsequent image captures are out of sync by either one
+ * or two times DMA_THRESHOLD bytes. Resetting and re-initializing the
+ * entire camera subsystem prevents the problem with frame
+ * synchronization.
+ */
+static void omap24xxcam_capture_cont(struct omap24xxcam_device *cam)
+{
+	unsigned long flags;
+	struct omap24xxcam_fh *fh = cam->streaming->private_data;
+
+	spin_lock_irqsave(&cam->core_enable_disable_lock, flags);
+
+	if (atomic_read(&cam->in_reset) != 1)
+		goto out;
+
+	omap24xxcam_hwinit(cam);
+
+	omap24xxcam_core_xclk_set(
+		cam, cam->sdev->u.slave->vidioc_int_g_ext_clk(cam->sdev));
+
+	omap24xxcam_sgdma_process(&cam->sgdma);
+
+	if (cam->sgdma_in_queue)
+		omap24xxcam_core_enable(cam);
+
+	cam->next_reset_at = jiffies + RESET_INTERVAL;
+	atomic_set(&cam->field_count_at_last_reset,
+		   atomic_read(&fh->field_count) + 2);
+
+out:
+	atomic_dec(&cam->in_reset);
+	spin_unlock_irqrestore(&cam->core_enable_disable_lock, flags);
+}
+
+static ssize_t
+omap24xxcam_streaming_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct omap24xxcam_device *cam = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%s\n", cam->streaming ?  "active" : "inactive");
+}
+static DEVICE_ATTR(streaming, S_IRUGO, omap24xxcam_streaming_show, NULL);
+
+/*
+ * Stop capture and restart it. I.e. reset the camera during use.
+ */
+static void omap24xxcam_reset(struct omap24xxcam_device *cam)
+{
+	omap24xxcam_capture_stop(cam);
+	omap24xxcam_capture_cont(cam);
+}
+
+/*
+ * The main interrupt handler.
+ */
+static irqreturn_t omap24xxcam_isr(int irq, void *arg)
+{
+	struct omap24xxcam_device *cam = (struct omap24xxcam_device *)arg;
+	u32 irqstatus;
+	unsigned int irqhandled = 0;
+
+	irqstatus = omap24xxcam_reg_in(cam->mmio_base, CAM_IRQSTATUS);
+
+	if (irqstatus &
+	    (CAM_IRQSTATUS_DMA_IRQ2 | CAM_IRQSTATUS_DMA_IRQ1
+	     | CAM_IRQSTATUS_DMA_IRQ0)) {
+		omap24xxcam_dma_isr(&cam->sgdma.dma);
+		irqhandled = 1;
+	}
+	if (irqstatus & CAM_IRQSTATUS_CC_IRQ) {
+		omap24xxcam_core_isr(cam);
+		irqhandled = 1;
+	}
+	if (irqstatus & CAM_IRQSTATUS_MMU_IRQ)
+		dev_err(cam->dev, "unhandled camera MMU interrupt!\n");
+
+	return IRQ_RETVAL(irqhandled);
+}
+
+/*
+ *
+ * Sensor handling.
+ *
+ */
+
+#define SENSOR_INIT_TRY 3
+
+/*
+ * Initialise the sensor hardware.
+ */
+static int omap24xxcam_sensor_init(struct omap24xxcam_device *cam)
+{
+	int err = 0;
+	struct v4l2_int_device *sdev = cam->sdev;
+	int again = SENSOR_INIT_TRY;
+
+tryit_again:
+	omap24xxcam_clock_on(cam);
+	omap24xxcam_core_xclk_set(cam,
+				  sdev->u.slave->vidioc_int_g_ext_clk(sdev));
+
+	/* power up sensor during sensor initialization */
+	sdev->u.slave->power_set(sdev, 1);
+
+	err = sdev->u.slave->dev_init(sdev);
+	if (err) {
+		dev_err(cam->dev, "cannot initialize sensor, error %d\n", err);
+		goto out;
+	}
+
+	dev_info(cam->dev, "sensor is %s\n", sdev->name);
+
+out:
+	omap24xxcam_core_xclk_set(cam, 0);
+	omap24xxcam_clock_off(cam);
+
+	sdev->u.slave->power_set(sdev, 0);
+
+	if (err) {
+		if (--again > 0)
+			goto tryit_again;
+		/* Sensor init failed --- it's nonexistent to us! */
+		cam->sdev = NULL;
+	}
+
+	return err;
+}
+
+static void omap24xxcam_sensor_exit(struct omap24xxcam_device *cam)
+{
+	if (cam->sdev)
+		cam->sdev->u.slave->dev_exit(cam->sdev);
+}
+
+static void omap24xxcam_sensor_disable(struct omap24xxcam_device *cam)
+{
+	omap24xxcam_core_xclk_set(cam, 0);
+	omap24xxcam_clock_off(cam);
+	cam->sdev->u.slave->power_set(cam->sdev, 0);
+}
+
+/*
+ * Power-up and configure camera sensor. It's ready for capturing now.
+ */
+static int omap24xxcam_sensor_enable(struct omap24xxcam_device *cam)
+{
+	int rval;
+
+	omap24xxcam_clock_on(cam);
+
+	omap24xxcam_core_xclk_set(
+		cam, cam->sdev->u.slave->vidioc_int_g_ext_clk(cam->sdev));
+
+	if ((rval = cam->sdev->u.slave->power_set(cam->sdev, 1)))
+		goto out;
+
+	if ((rval = cam->sdev->u.slave->vidioc_int_init(cam->sdev)))
+		goto out;
+
+	return 0;
+
+out:
+	omap24xxcam_sensor_disable(cam);
+	return rval;
+}
+
+static void omap24xxcam_sensor_reset_work(struct work_struct *work)
+{
+	struct omap24xxcam_device *cam =
+		container_of(work, struct omap24xxcam_device,
+			     sensor_reset_work);
+
+	if (atomic_read(&cam->reset_disable))
+		return;
+
+	omap24xxcam_capture_stop(cam);
+
+	/* Can't reset it by vidioc_int_reset. */
+	if (cam->sdev->u.slave->vidioc_int_reset(cam->sdev)) {
+		omap24xxcam_sensor_disable(cam);
+		omap24xxcam_sensor_enable(cam);
+	}
+
+	omap24xxcam_capture_cont(cam);
+}
+
+/*
+ * Register sensor to the camera. Only works after the camera module
+ * is initialised.
+ */
+static int omap24xxcam_sensor_attach(struct v4l2_int_device *ctl,
+				     struct v4l2_int_device *s)
+{
+	struct omap24xxcam_device *cam = ctl->priv;
+	int rval;
+
+	if (cam->sdev != NULL)
+		return -EBUSY;
+
+	cam->sdev = s;
+
+	rval = omap24xxcam_device_register(cam);
+	if (rval)
+		cam->sdev = NULL;
+
+	return rval;
+}
+
+static void omap24xxcam_sensor_detach(struct v4l2_int_device *ctl)
+{
+	struct omap24xxcam_device *cam = ctl->priv;
+
+	omap24xxcam_device_unregister(cam);
+
+	cam->sdev = NULL;
+}
+
+static struct v4l2_int_master omap24xxcam_master = {
+	.attach = &omap24xxcam_sensor_attach,
+	.detach = &omap24xxcam_sensor_detach,
+};
+
+static struct v4l2_int_device omap24xxcam = {
+	.module = THIS_MODULE,
+	.name = CAM_NAME,
+	.type = v4l2_int_type_master,
+	.u = { .master = &omap24xxcam_master },
+};
+
+/*
+ *
+ * IOCTL interface.
+ *
+ */
+
+static int vidioc_querycap(struct file *file, void *fh,
+			   struct v4l2_capability *cap)
+{
+	struct omap24xxcam_fh *ofh = fh;
+	struct omap24xxcam_device *cam = ofh->cam;
+
+	strlcpy(cap->driver, CAM_NAME, sizeof(cap->driver));
+	strlcpy(cap->card, cam->vfd->name, sizeof(cap->card));
+	cap->version = KERNEL_VERSION(0, 0, 0);
+	cap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;
+
+	return 0;
+}
+
+static int vidioc_enum_fmt_cap(struct file *file, void *fh,
+			       struct v4l2_fmtdesc *f)
+{
+	struct omap24xxcam_fh *ofh = fh;
+	struct omap24xxcam_device *cam = ofh->cam;
+
+	return cam->sdev->u.slave->vidioc_int_enum_fmt_cap(cam->sdev, f);
+}
+
+static int vidioc_g_fmt_cap(struct file *file, void *fh,
+			    struct v4l2_format *f)
+{
+	struct omap24xxcam_fh *ofh = fh;
+	struct omap24xxcam_device *cam = ofh->cam;
+	int rval;
+
+	mutex_lock(&cam->mutex);
+	rval = cam->sdev->u.slave->vidioc_int_g_fmt_cap(cam->sdev, f);
+	mutex_unlock(&cam->mutex);
+
+	return rval;
+}
+
+static int vidioc_s_fmt_cap(struct file *file, void *fh,
+			    struct v4l2_format *f)
+{
+	struct omap24xxcam_fh *ofh = fh;
+	struct omap24xxcam_device *cam = ofh->cam;
+	int rval;
+
+	mutex_lock(&cam->mutex);
+	if (cam->streaming) {
+		rval = -EBUSY;
+		goto out;
+	}
+
+	rval = cam->sdev->u.slave->vidioc_int_s_fmt_cap(cam->sdev, f);
+
+out:
+	mutex_unlock(&cam->mutex);
+
+	if (!rval) {
+		mutex_lock(&ofh->vbq.lock);
+		ofh->pix = f->fmt.pix;
+		mutex_unlock(&ofh->vbq.lock);
+	}
+
+	memset(f, 0, sizeof(*f));
+	vidioc_g_fmt_cap(file, fh, f);
+
+	return rval;
+}
+
+static int vidioc_try_fmt_cap(struct file *file, void *fh,
+			      struct v4l2_format *f)
+{
+	struct omap24xxcam_fh *ofh = fh;
+	struct omap24xxcam_device *cam = ofh->cam;
+	int rval;
+
+	mutex_lock(&cam->mutex);
+	rval = cam->sdev->u.slave->vidioc_int_try_fmt_cap(cam->sdev, f);
+	mutex_unlock(&cam->mutex);
+
+	return rval;
+}
+
+static int vidioc_reqbufs(struct file *file, void *fh,
+			  struct v4l2_requestbuffers *b)
+{
+	struct omap24xxcam_fh *ofh = fh;
+	struct omap24xxcam_device *cam = ofh->cam;
+	int rval;
+
+	mutex_lock(&cam->mutex);
+	if (cam->streaming) {
+		mutex_unlock(&cam->mutex);
+		return -EBUSY;
+	}
+
+	omap24xxcam_vbq_free_mmap_buffers(&ofh->vbq);
+	mutex_unlock(&cam->mutex);
+
+	rval = videobuf_reqbufs(&ofh->vbq, b);
+
+	/* Either videobuf_reqbufs failed or the buffers are not
+	 * memory-mapped (which would need special attention). */
+	if (rval || b->memory != V4L2_MEMORY_MMAP)
+		goto out;
+
+	rval = omap24xxcam_vbq_alloc_mmap_buffers(&ofh->vbq, b->count);
+	if (rval)
+		omap24xxcam_vbq_free_mmap_buffers(&ofh->vbq);
+
+out:
+	return rval;
+}
+
+static int vidioc_querybuf(struct file *file, void *fh,
+			   struct v4l2_buffer *b)
+{
+	struct omap24xxcam_fh *ofh = fh;
+
+	return videobuf_querybuf(&ofh->vbq, b);
+}
+
+static int vidioc_qbuf(struct file *file, void *fh, struct v4l2_buffer *b)
+{
+	struct omap24xxcam_fh *ofh = fh;
+
+	return videobuf_qbuf(&ofh->vbq, b);
+}
+
+static int vidioc_dqbuf(struct file *file, void *fh, struct v4l2_buffer *b)
+{
+	struct omap24xxcam_fh *ofh = fh;
+	struct omap24xxcam_device *cam = ofh->cam;
+	struct videobuf_buffer *vb;
+	int rval;
+
+	rval = videobuf_dqbuf(&ofh->vbq, b, file->f_flags & O_NONBLOCK);
+	if (rval)
+		goto out;
+
+	vb = ofh->vbq.bufs[b->index];
+
+	/* Don't test frames immediately after reset. */
+	if ((atomic_read(&cam->field_count_at_last_reset) + 2 > vb->field_count
+	     || atomic_read(&cam->field_count_at_last_reset) < vb->field_count)
+	    && cam->sdev->u.slave->vidioc_int_g_needs_reset) {
+		mutex_lock(&cam->mutex);
+		rval = cam->sdev->u.slave->vidioc_int_g_needs_reset(
+			cam->sdev, (void *)vb->baddr);
+		mutex_unlock(&cam->mutex);
+		if (rval)
+			schedule_work(&cam->sensor_reset_work);
+	}
+out:
+	/* This is a hack. User space won't get the index of this
+	 * buffer and does not want to requeue it so we requeue it
+	 * here. */
+	if (rval == -EIO)
+		videobuf_qbuf(&ofh->vbq, b);
+
+	return rval;
+}
+
+static int vidioc_streamon(struct file *file, void *fh, enum v4l2_buf_type i)
+{
+	struct omap24xxcam_fh *ofh = fh;
+	struct omap24xxcam_device *cam = ofh->cam;
+	int rval;
+
+	mutex_lock(&cam->mutex);
+	if (cam->streaming) {
+		mutex_unlock(&cam->mutex);
+		return -EBUSY;
+	}
+
+	if (!(rval = videobuf_streamon(&ofh->vbq))) {
+		cam->streaming = file;
+		sysfs_notify(&cam->dev->kobj, NULL, "streaming");
+	}
+
+	mutex_unlock(&cam->mutex);
+
+
+	return rval;
+}
+
+static int vidioc_streamoff(struct file *file, void *fh, enum v4l2_buf_type i)
+{
+	struct omap24xxcam_fh *ofh = fh;
+	struct omap24xxcam_device *cam = ofh->cam;
+	struct videobuf_queue *q = &ofh->vbq;
+	int rval;
+
+	atomic_inc(&cam->reset_disable);
+
+	flush_scheduled_work();
+
+	if (!(rval = videobuf_streamoff(q))) {
+		mutex_lock(&cam->mutex);
+		cam->streaming = NULL;
+		mutex_unlock(&cam->mutex);
+		sysfs_notify(&cam->dev->kobj, NULL, "streaming");
+	}
+
+	atomic_dec(&cam->reset_disable);
+
+	return rval;
+}
+
+static int vidioc_enum_input(struct file *file, void *fh,
+			     struct v4l2_input *inp)
+{
+	if (inp->index > 0)
+		return -EINVAL;
+
+	strlcpy(inp->name, "camera", sizeof(inp->name));
+	inp->type = V4L2_INPUT_TYPE_CAMERA;
+
+	return 0;
+}
+
+static int vidioc_g_input(struct file *file, void *fh, unsigned int *i)
+{
+	*i = 0;
+
+	return 0;
+}
+
+static int vidioc_s_input(struct file *file, void *fh, unsigned int i)
+{
+	if (i > 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int vidioc_queryctrl(struct file *file, void *fh,
+			    struct v4l2_queryctrl *a)
+{
+	struct omap24xxcam_fh *ofh = fh;
+	struct omap24xxcam_device *cam = ofh->cam;
+
+	return cam->sdev->u.slave->vidioc_int_queryctrl(cam->sdev, a);
+}
+
+static int vidioc_g_ctrl(struct file *file, void *fh,
+			 struct v4l2_control *a)
+{
+	struct omap24xxcam_fh *ofh = fh;
+	struct omap24xxcam_device *cam = ofh->cam;
+	int rval;
+
+	mutex_lock(&cam->mutex);
+	rval = cam->sdev->u.slave->vidioc_int_g_ctrl(cam->sdev, a);
+	mutex_unlock(&cam->mutex);
+
+	return rval;
+}
+
+static int vidioc_s_ctrl(struct file *file, void *fh,
+			 struct v4l2_control *a)
+{
+	struct omap24xxcam_fh *ofh = fh;
+	struct omap24xxcam_device *cam = ofh->cam;
+	int rval;
+
+	mutex_lock(&cam->mutex);
+	rval = cam->sdev->u.slave->vidioc_int_s_ctrl(cam->sdev, a);
+	mutex_unlock(&cam->mutex);
+
+	return rval;
+}
+
+static int vidioc_g_parm(struct file *file, void *fh,
+			 struct v4l2_streamparm *a) {
+	struct omap24xxcam_fh *ofh = fh;
+	struct omap24xxcam_device *cam = ofh->cam;
+	int rval;
+
+	if (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	mutex_lock(&cam->mutex);
+	rval = cam->sdev->u.slave->vidioc_int_g_parm(cam->sdev, a);
+	mutex_unlock(&cam->mutex);
+
+	return rval;
+}
+
+static int vidioc_s_parm(struct file *file, void *fh,
+			 struct v4l2_streamparm *a)
+{
+	struct omap24xxcam_fh *ofh = fh;
+	struct omap24xxcam_device *cam = ofh->cam;
+	int rval;
+	u32 xclk, xclk_old;
+
+	if (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	mutex_lock(&cam->mutex);
+	if (cam->streaming) {
+		rval = -EBUSY;
+		goto out;
+	}
+
+	xclk_old = cam->sdev->u.slave->vidioc_int_g_ext_clk(cam->sdev);
+
+	rval = cam->sdev->u.slave->vidioc_int_s_parm(cam->sdev, a);
+
+	xclk = omap24xxcam_core_xclk_set(
+		cam, cam->sdev->u.slave->vidioc_int_g_ext_clk(cam->sdev));
+
+	/*
+	 * FIXME: if setting xclk fails, streaming parameters are not
+	 * reverted. Also bad xclk is used for a short while.
+	 */
+	if (cam->sdev->u.slave->vidioc_int_s_ext_clk(cam->sdev, xclk)) {
+		rval = -EINVAL;
+		omap24xxcam_core_xclk_set(cam, xclk_old);
+	}
+
+out:
+	mutex_unlock(&cam->mutex);
+
+	return rval;
+}
+
+/*
+ *
+ * File operations.
+ *
+ */
+
+static unsigned int omap24xxcam_poll(struct file *file,
+				     struct poll_table_struct *wait)
+{
+	struct omap24xxcam_fh *fh = file->private_data;
+	struct omap24xxcam_device *cam = fh->cam;
+	struct videobuf_buffer *vb;
+
+	mutex_lock(&cam->mutex);
+	if (cam->streaming != file) {
+		mutex_unlock(&cam->mutex);
+		return POLLERR;
+	}
+	mutex_unlock(&cam->mutex);
+
+	mutex_lock(&fh->vbq.lock);
+	if (list_empty(&fh->vbq.stream)) {
+		mutex_unlock(&fh->vbq.lock);
+		return POLLERR;
+	}
+	vb = list_entry(fh->vbq.stream.next, struct videobuf_buffer, stream);
+	mutex_unlock(&fh->vbq.lock);
+
+	poll_wait(file, &vb->done, wait);
+
+	if (vb->state == STATE_DONE || vb->state == STATE_ERROR)
+		return POLLIN | POLLRDNORM;
+
+	return 0;
+}
+
+static int omap24xxcam_mmap_buffers(struct file *file,
+				    struct vm_area_struct *vma)
+{
+	struct omap24xxcam_fh *fh = file->private_data;
+	struct omap24xxcam_device *cam = fh->cam;
+	struct videobuf_queue *vbq = &fh->vbq;
+	struct videobuf_buffer *vb;
+	unsigned int first, last, size, i, j;
+	int err = 0;
+
+	mutex_lock(&cam->mutex);
+	if (cam->streaming) {
+		mutex_unlock(&cam->mutex);
+		return -EBUSY;
+	}
+	mutex_unlock(&cam->mutex);
+	mutex_lock(&vbq->lock);
+
+	/* look for first buffer to map */
+	for (first = 0; first < VIDEO_MAX_FRAME; first++) {
+		if (NULL == vbq->bufs[first])
+			continue;
+		if (V4L2_MEMORY_MMAP != vbq->bufs[first]->memory)
+			continue;
+		if (vbq->bufs[first]->boff == (vma->vm_pgoff << PAGE_SHIFT))
+			break;
+	}
+
+	/* look for last buffer to map */
+	for (size = 0, last = first; last < VIDEO_MAX_FRAME; last++) {
+		if (NULL == vbq->bufs[last])
+			continue;
+		if (V4L2_MEMORY_MMAP != vbq->bufs[last]->memory)
+			continue;
+		size += vbq->bufs[last]->bsize;
+		if (size == (vma->vm_end - vma->vm_start))
+			break;
+	}
+
+	size = 0;
+	for (i = first; i <= last; i++) {
+		vb = vbq->bufs[i];
+		for (j = 0; j < vb->dma.sglen; j++) {
+			err = remap_pfn_range(
+				vma, vma->vm_start + size,
+				page_to_pfn(vb->dma.sglist[j].page),
+				vb->dma.sglist[j].length, vma->vm_page_prot);
+			if (err)
+				goto out;
+			size += vb->dma.sglist[j].length;
+		}
+	}
+
+out:
+	mutex_unlock(&vbq->lock);
+
+	return err;
+}
+
+static int omap24xxcam_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct omap24xxcam_fh *fh = file->private_data;
+	int rval;
+
+	/* let the video-buf mapper check arguments and set-up structures */
+	rval = videobuf_mmap_mapper(&fh->vbq, vma);
+	if (rval)
+		return rval;
+
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	/* do mapping to our allocated buffers */
+	rval = omap24xxcam_mmap_buffers(file, vma);
+	/* In case of error, free vma->vm_private_data allocated by
+	 * videobuf_mmap_mapper. */
+	if (rval)
+		kfree(vma->vm_private_data);
+
+	return rval;
+}
+
+static int omap24xxcam_open(struct inode *inode, struct file *file)
+{
+	int minor = iminor(inode);
+	struct omap24xxcam_device *cam = omap24xxcam.priv;
+	struct omap24xxcam_fh *fh;
+	struct v4l2_format format;
+
+	if (!cam || !cam->vfd || (cam->vfd->minor != minor))
+		return -ENODEV;
+
+	if ((fh = kzalloc(sizeof(*fh), GFP_KERNEL)) == NULL)
+		return -ENOMEM;
+
+	mutex_lock(&cam->mutex);
+	if (cam->sdev == NULL || !try_module_get(cam->sdev->module))
+		goto out_try_module_get;
+	mutex_unlock(&cam->mutex);
+
+	mutex_lock(&cam->mutex);
+	if (atomic_inc_return(&cam->users) == 1) {
+		omap24xxcam_hwinit(cam);
+		if (omap24xxcam_sensor_enable(cam))
+			goto out_omap24xxcam_sensor_enable;
+
+		dvfs_op_policy_update(CAM_STREAMING_CHANGED, 1);
+	}
+	mutex_unlock(&cam->mutex);
+
+	fh->cam = cam;
+	mutex_lock(&cam->mutex);
+	cam->sdev->u.slave->vidioc_int_g_fmt_cap(cam->sdev, &format);
+	mutex_unlock(&cam->mutex);
+	/* FIXME: how about fh->pix when there are more users? */
+	fh->pix = format.fmt.pix;
+
+	file->private_data = fh;
+
+	spin_lock_init(&fh->vbq_lock);
+
+	videobuf_queue_init(&fh->vbq, &omap24xxcam_vbq_ops, NULL,
+			    &fh->vbq_lock, V4L2_BUF_TYPE_VIDEO_CAPTURE,
+			    V4L2_FIELD_NONE,
+			    sizeof(struct videobuf_buffer), fh);
+
+	return 0;
+
+out_omap24xxcam_sensor_enable:
+	omap24xxcam_poweron_reset(cam);
+	module_put(cam->sdev->module);
+
+out_try_module_get:
+	mutex_unlock(&cam->mutex);
+	kfree(fh);
+
+	return -ENODEV;
+}
+
+static int omap24xxcam_release(struct inode *inode, struct file *file)
+{
+	struct omap24xxcam_fh *fh = file->private_data;
+	struct omap24xxcam_device *cam = fh->cam;
+
+	atomic_inc(&cam->reset_disable);
+
+	flush_scheduled_work();
+
+	mutex_lock(&cam->mutex);
+	/* stop streaming capture */
+	if (cam->streaming == file) {
+		cam->streaming = NULL;
+		mutex_unlock(&cam->mutex);
+		videobuf_streamoff(&fh->vbq);
+		sysfs_notify(&cam->dev->kobj, NULL, "streaming");
+	} else {
+		mutex_unlock(&cam->mutex);
+	}
+
+	atomic_dec(&cam->reset_disable);
+
+	omap24xxcam_vbq_free_mmap_buffers(&fh->vbq);
+
+	/* Make sure the reset work we might have scheduled is not
+	 * pending! It may be run *only* if we have users. (And it may
+	 * not be scheduled anymore since streaming is already
+	 * disabled.)
+	 */
+	flush_scheduled_work();
+
+	mutex_lock(&cam->mutex);
+	if (atomic_dec_return(&cam->users) == 0) {
+		dvfs_op_policy_update(CAM_STREAMING_CHANGED, 0);
+		omap24xxcam_sensor_disable(cam);
+		omap24xxcam_poweron_reset(cam);
+	}
+	mutex_unlock(&cam->mutex);
+
+	file->private_data = NULL;
+
+	module_put(cam->sdev->module);
+	kfree(fh);
+
+	return 0;
+}
+
+static struct file_operations omap24xxcam_fops = {
+	.owner = THIS_MODULE,
+	.llseek = no_llseek,
+	.ioctl = video_ioctl2,
+	.poll = omap24xxcam_poll,
+	.mmap = omap24xxcam_mmap,
+	.open = omap24xxcam_open,
+	.release = omap24xxcam_release,
+};
+
+/*
+ *
+ * Power management.
+ *
+ */
+
+#ifdef CONFIG_PM
+static int omap24xxcam_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct omap24xxcam_device *cam = platform_get_drvdata(pdev);
+
+	if (atomic_read(&cam->users) == 0)
+		return 0;
+
+	if (!atomic_read(&cam->reset_disable))
+		omap24xxcam_capture_stop(cam);
+
+	omap24xxcam_sensor_disable(cam);
+	omap24xxcam_poweron_reset(cam);
+
+	return 0;
+}
+
+static int omap24xxcam_resume(struct platform_device *pdev)
+{
+	struct omap24xxcam_device *cam = platform_get_drvdata(pdev);
+
+	if (atomic_read(&cam->users) == 0)
+		return 0;
+
+	omap24xxcam_hwinit(cam);
+	omap24xxcam_sensor_enable(cam);
+
+	if (!atomic_read(&cam->reset_disable))
+		omap24xxcam_capture_cont(cam);
+
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+/*
+ *
+ * Camera device (i.e. /dev/video).
+ *
+ */
+
+static int omap24xxcam_device_register(struct omap24xxcam_device *cam)
+{
+	struct video_device *vfd;
+	int rval;
+
+	if (device_create_file(cam->dev, &dev_attr_streaming) != 0) {
+		dev_err(cam->dev, "could not register sysfs entry\n");
+		rval = -EBUSY;
+		goto err;
+	}
+
+	/* initialize the video_device struct */
+	vfd = cam->vfd = video_device_alloc();
+	if (!vfd) {
+		dev_err(cam->dev, "could not allocate video device struct\n");
+		rval = -ENOMEM;
+		goto err;
+	}
+	vfd->release = video_device_release;
+
+	vfd->dev = cam->dev;
+
+	strlcpy(vfd->name, CAM_NAME, sizeof(vfd->name));
+	vfd->type = VID_TYPE_CAPTURE | VID_TYPE_CHROMAKEY;
+	/* need to register for a VID_HARDWARE_* ID in videodev.h */
+	vfd->hardware = 0;
+	vfd->fops = &omap24xxcam_fops;
+	/* FIXME: need to use the full v4l2 API */
+	vfd->priv = cam;
+	vfd->minor = -1;
+
+	vfd->vidioc_querycap = &vidioc_querycap;
+	vfd->vidioc_enum_fmt_cap = &vidioc_enum_fmt_cap;
+	vfd->vidioc_g_fmt_cap = &vidioc_g_fmt_cap;
+	vfd->vidioc_s_fmt_cap = &vidioc_s_fmt_cap;
+	vfd->vidioc_try_fmt_cap = &vidioc_try_fmt_cap;
+	vfd->vidioc_reqbufs = &vidioc_reqbufs;
+	vfd->vidioc_querybuf = &vidioc_querybuf;
+	vfd->vidioc_qbuf = &vidioc_qbuf;
+	vfd->vidioc_dqbuf = &vidioc_dqbuf;
+	vfd->vidioc_streamon = &vidioc_streamon;
+	vfd->vidioc_streamoff = &vidioc_streamoff;
+	vfd->vidioc_enum_input = &vidioc_enum_input;
+	vfd->vidioc_g_input = &vidioc_g_input;
+	vfd->vidioc_s_input = &vidioc_s_input;
+	vfd->vidioc_queryctrl = &vidioc_queryctrl;
+	vfd->vidioc_g_ctrl = &vidioc_g_ctrl;
+	vfd->vidioc_s_ctrl = &vidioc_s_ctrl;
+	vfd->vidioc_g_parm = &vidioc_g_parm;
+	vfd->vidioc_s_parm = &vidioc_s_parm;
+
+	omap24xxcam_hwinit(cam);
+
+	if ((rval = omap24xxcam_sensor_init(cam)))
+		goto err;
+
+	if (video_register_device(vfd, VFL_TYPE_GRABBER, video_nr) < 0) {
+		dev_err(cam->dev, "could not register V4L device\n");
+		vfd->minor = -1;
+		rval = -EBUSY;
+		goto err;
+	}
+
+	omap24xxcam_poweron_reset(cam);
+
+	dev_info(cam->dev, "registered device video%d [v4l2]\n", vfd->minor);
+
+	return 0;
+
+err:
+	omap24xxcam_device_unregister(cam);
+
+	return rval;
+}
+
+static void omap24xxcam_device_unregister(struct omap24xxcam_device *cam)
+{
+	omap24xxcam_sensor_exit(cam);
+
+	if (cam->vfd) {
+		if (cam->vfd->minor == -1) {
+			/* The device was never registered, so release the
+			 * video_device struct directly.
+			 */
+			video_device_release(cam->vfd);
+		} else {
+			/* The unregister function will release the video_device
+			 * struct as well as unregistering it.
+			 */
+			video_unregister_device(cam->vfd);
+		}
+		cam->vfd = NULL;
+	}
+
+	device_remove_file(cam->dev, &dev_attr_streaming);
+}
+
+/*
+ *
+ * Driver initialisation and deinitialisation.
+ *
+ */
+
+static int omap24xxcam_probe(struct platform_device *pdev)
+{
+	struct omap24xxcam_device *cam;
+	struct resource *mem;
+	int irq;
+
+	cam = kzalloc(sizeof(*cam), GFP_KERNEL);
+	if (!cam) {
+		dev_err(&pdev->dev, "could not allocate memory\n");
+		goto err;
+	}
+
+	platform_set_drvdata(pdev, cam);
+
+	cam->dev = &pdev->dev;
+
+	/* Impose a lower limit on the amount of memory allocated for capture.
+	 * We require at least enough memory to double-buffer QVGA (300KB).
+	 */
+	if (capture_mem < 320 * 240 * 2 * 2)
+		capture_mem = 320 * 240 * 2 * 2;
+	cam->capture_mem = capture_mem;
+
+	/* request the mem region for the camera registers */
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem) {
+		dev_err(cam->dev, "no mem resource?\n");
+		goto err;
+	}
+	if (!request_mem_region(mem->start, (mem->end - mem->start) + 1,
+				pdev->name)) {
+		dev_err(cam->dev,
+			"cannot reserve camera register I/O region\n");
+		goto err;
+	}
+	cam->mmio_base_phys = mem->start;
+	cam->mmio_size = (mem->end - mem->start) + 1;
+
+	/* map the region */
+	cam->mmio_base = (unsigned long)
+		ioremap_nocache(cam->mmio_base_phys, cam->mmio_size);
+	if (!cam->mmio_base) {
+		dev_err(cam->dev, "cannot map camera register I/O region\n");
+		goto err;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq <= 0) {
+		dev_err(cam->dev, "no irq for camera?\n");
+		goto err;
+	}
+
+	/* install the interrupt service routine */
+	if (request_irq(irq, omap24xxcam_isr, 0, CAM_NAME, cam)) {
+		dev_err(cam->dev,
+			"could not install interrupt service routine\n");
+		goto err;
+	}
+	cam->irq = irq;
+
+	if (omap24xxcam_clock_get(cam))
+		goto err;
+
+	INIT_WORK(&cam->sensor_reset_work, omap24xxcam_sensor_reset_work);
+
+	mutex_init(&cam->mutex);
+	spin_lock_init(&cam->core_enable_disable_lock);
+
+	omap24xxcam_sgdma_init(&cam->sgdma,
+			       cam->mmio_base + CAMDMA_REG_OFFSET,
+			       &omap24xxcam_stalled_dma_reset,
+			       (unsigned long)cam);
+
+	omap24xxcam.priv = cam;
+
+	if (v4l2_int_device_register(&omap24xxcam))
+		goto err;
+
+	return 0;
+
+err:
+	omap24xxcam_remove(pdev);
+	return -ENODEV;
+}
+
+static int omap24xxcam_remove(struct platform_device *pdev)
+{
+	struct omap24xxcam_device *cam = platform_get_drvdata(pdev);
+
+	if (!cam)
+		return 0;
+
+	if (omap24xxcam.priv != NULL)
+		v4l2_int_device_unregister(&omap24xxcam);
+	omap24xxcam.priv = NULL;
+
+	omap24xxcam_device_unregister(cam);
+	omap24xxcam_clock_put(cam);
+
+	if (cam->irq) {
+		free_irq(cam->irq, cam);
+		cam->irq = 0;
+	}
+
+	if (cam->mmio_base) {
+		iounmap((void *)cam->mmio_base);
+		cam->mmio_base = 0;
+	}
+
+	if (cam->mmio_base_phys) {
+		release_mem_region(cam->mmio_base_phys, cam->mmio_size);
+		cam->mmio_base_phys = 0;
+	}
+
+	kfree(cam);
+
+	return 0;
+}
+
+static struct platform_driver omap24xxcam_driver = {
+	.probe = omap24xxcam_probe,
+	.remove = omap24xxcam_remove,
+#ifdef CONFIG_PM
+	.suspend = omap24xxcam_suspend,
+	.resume = omap24xxcam_resume,
+#endif
+	.driver = {
+		.name = CAM_NAME,
+	},
+};
+
+/*
+ *
+ * Module initialisation and deinitialisation
+ *
+ */
+
+static int __init omap24xxcam_init(void)
+{
+	return platform_driver_register(&omap24xxcam_driver);
+}
+
+static void __exit omap24xxcam_cleanup(void)
+{
+	platform_driver_unregister(&omap24xxcam_driver);
+}
+
+MODULE_AUTHOR("Sakari Ailus <sakari.ailus@nokia.com>");
+MODULE_DESCRIPTION("OMAP24xx Video for Linux camera driver");
+MODULE_LICENSE("GPL");
+module_param(video_nr, int, 0);
+MODULE_PARM_DESC(video_nr,
+		 "Minor number for video device (-1 ==> auto assign)");
+module_param(capture_mem, int, 0);
+MODULE_PARM_DESC(capture_mem,
+		 "Maximum amount of memory for capture buffers (default 4800kiB)");
+
+module_init(omap24xxcam_init);
+module_exit(omap24xxcam_cleanup);
diff -ruN linux-omap-2.6/drivers/media/video/omap/omap24xxcam-dma.c maemo_src/drivers/media/video/omap/omap24xxcam-dma.c
--- linux-omap-2.6/drivers/media/video/omap/omap24xxcam-dma.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/media/video/omap/omap24xxcam-dma.c	2007-10-02 03:09:31.000000000 -0400
@@ -0,0 +1,606 @@
+/*
+ * omap24xxcam-dma.c
+ *
+ * Copyright (C) 2004 MontaVista Software, Inc.
+ * Copyright (C) 2004 Texas Instruments.
+ * Copyright (C) 2007 Nokia Corporation.
+ *
+ * Contact: Sakari Ailus <sakari.ailus@nokia.com>
+ *
+ * Based on code from Andy Lowe <source@mvista.com> and
+ *                    David Cohen <david.cohen@indt.org.br>.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <linux/kernel.h>
+
+#include <asm/io.h>
+#include <asm/scatterlist.h>
+
+#include "omap24xxcam.h"
+
+/*
+ *
+ * DMA hardware.
+ *
+ */
+
+/* Ack all interrupt on CSR and IRQSTATUS_L0 */
+static void omap24xxcam_dmahw_ack_all(unsigned long base)
+{
+	u32 csr;
+	int i;
+
+	for (i = 0; i < NUM_CAMDMA_CHANNELS; ++i) {
+		csr = omap24xxcam_reg_in(base, CAMDMA_CSR(i));
+		/* ack interrupt in CSR */
+		omap24xxcam_reg_out(base, CAMDMA_CSR(i), csr);
+	}
+	omap24xxcam_reg_out(base, CAMDMA_IRQSTATUS_L0, 0xf);
+}
+
+/* Ack dmach on CSR and IRQSTATUS_L0 */
+static u32 omap24xxcam_dmahw_ack_ch(unsigned long base, int dmach)
+{
+	u32 csr;
+
+	csr = omap24xxcam_reg_in(base, CAMDMA_CSR(dmach));
+	/* ack interrupt in CSR */
+	omap24xxcam_reg_out(base, CAMDMA_CSR(dmach), csr);
+	/* ack interrupt in IRQSTATUS */
+	omap24xxcam_reg_out(base, CAMDMA_IRQSTATUS_L0, (1 << dmach));
+
+	return csr;
+}
+
+static int omap24xxcam_dmahw_running(unsigned long base, int dmach)
+{
+	return omap24xxcam_reg_in(base, CAMDMA_CCR(dmach)) & CAMDMA_CCR_ENABLE;
+}
+
+static void omap24xxcam_dmahw_transfer_setup(unsigned long base, int dmach,
+					     dma_addr_t start, u32 len)
+{
+	omap24xxcam_reg_out(base, CAMDMA_CCR(dmach),
+			    CAMDMA_CCR_SEL_SRC_DST_SYNC
+			    | CAMDMA_CCR_BS
+			    | CAMDMA_CCR_DST_AMODE_POST_INC
+			    | CAMDMA_CCR_SRC_AMODE_POST_INC
+			    | CAMDMA_CCR_FS
+			    | CAMDMA_CCR_WR_ACTIVE
+			    | CAMDMA_CCR_RD_ACTIVE
+			    | CAMDMA_CCR_SYNCHRO_CAMERA);
+	omap24xxcam_reg_out(base, CAMDMA_CLNK_CTRL(dmach), 0);
+	omap24xxcam_reg_out(base, CAMDMA_CEN(dmach), len);
+	omap24xxcam_reg_out(base, CAMDMA_CFN(dmach), 1);
+	omap24xxcam_reg_out(base, CAMDMA_CSDP(dmach),
+			    CAMDMA_CSDP_WRITE_MODE_POSTED
+			    | CAMDMA_CSDP_DST_BURST_EN_32
+			    | CAMDMA_CSDP_DST_PACKED
+			    | CAMDMA_CSDP_SRC_BURST_EN_32
+			    | CAMDMA_CSDP_SRC_PACKED
+			    | CAMDMA_CSDP_DATA_TYPE_8BITS);
+	omap24xxcam_reg_out(base, CAMDMA_CSSA(dmach), 0);
+	omap24xxcam_reg_out(base, CAMDMA_CDSA(dmach), start);
+	omap24xxcam_reg_out(base, CAMDMA_CSEI(dmach), 0);
+	omap24xxcam_reg_out(base, CAMDMA_CSFI(dmach), DMA_THRESHOLD);
+	omap24xxcam_reg_out(base, CAMDMA_CDEI(dmach), 0);
+	omap24xxcam_reg_out(base, CAMDMA_CDFI(dmach), 0);
+	omap24xxcam_reg_out(base, CAMDMA_CSR(dmach),
+			    CAMDMA_CSR_MISALIGNED_ERR
+			    | CAMDMA_CSR_SECURE_ERR
+			    | CAMDMA_CSR_TRANS_ERR
+			    | CAMDMA_CSR_BLOCK
+			    | CAMDMA_CSR_DROP);
+	omap24xxcam_reg_out(base, CAMDMA_CICR(dmach),
+			    CAMDMA_CICR_MISALIGNED_ERR_IE
+			    | CAMDMA_CICR_SECURE_ERR_IE
+			    | CAMDMA_CICR_TRANS_ERR_IE
+			    | CAMDMA_CICR_BLOCK_IE
+			    | CAMDMA_CICR_DROP_IE);
+}
+
+static void omap24xxcam_dmahw_transfer_start(unsigned long base, int dmach)
+{
+	omap24xxcam_reg_out(base, CAMDMA_CCR(dmach),
+			    CAMDMA_CCR_SEL_SRC_DST_SYNC
+			    | CAMDMA_CCR_BS
+			    | CAMDMA_CCR_DST_AMODE_POST_INC
+			    | CAMDMA_CCR_SRC_AMODE_POST_INC
+			    | CAMDMA_CCR_ENABLE
+			    | CAMDMA_CCR_FS
+			    | CAMDMA_CCR_SYNCHRO_CAMERA);
+}
+
+static void omap24xxcam_dmahw_transfer_chain(unsigned long base, int dmach,
+					     int free_dmach)
+{
+	int prev_dmach, ch;
+
+	if (dmach == 0)
+		prev_dmach = NUM_CAMDMA_CHANNELS - 1;
+	else
+		prev_dmach = dmach - 1;
+	omap24xxcam_reg_out(base, CAMDMA_CLNK_CTRL(prev_dmach),
+			    CAMDMA_CLNK_CTRL_ENABLE_LNK | dmach);
+	/* Did we chain the DMA transfer before the previous one
+	 * finished?
+	 */
+	ch = (dmach + free_dmach) % NUM_CAMDMA_CHANNELS;
+	while (!(omap24xxcam_reg_in(base, CAMDMA_CCR(ch))
+		 & CAMDMA_CCR_ENABLE))
+	{
+		if (ch == dmach) {
+			/* The previous transfer has ended and this one
+			 * hasn't started, so we must not have chained
+			 * to the previous one in time.  We'll have to
+			 * start it now.
+			 */
+			omap24xxcam_dmahw_transfer_start(base, dmach);
+			break;
+		} else
+			ch = (ch + 1) % NUM_CAMDMA_CHANNELS;
+	}
+}
+
+/* Abort all chained DMA transfers. After all transfers have been
+ * aborted and the DMA controller is idle, the completion routines for
+ * any aborted transfers will be called in sequence. The DMA
+ * controller may not be idle after this routine completes, because
+ * the completion routines might start new transfers.
+ */
+static void omap24xxcam_dmahw_abort_ch(unsigned long base, int dmach)
+{
+	/* mask all interrupts from this channel */
+	omap24xxcam_reg_out(base, CAMDMA_CICR(dmach), 0);
+	/* unlink this channel */
+	omap24xxcam_reg_merge(base, CAMDMA_CLNK_CTRL(dmach), 0,
+			      CAMDMA_CLNK_CTRL_ENABLE_LNK);
+	/* disable this channel */
+	omap24xxcam_reg_merge(base, CAMDMA_CCR(dmach), 0, CAMDMA_CCR_ENABLE);
+}
+
+static void omap24xxcam_dmahw_init(unsigned long base)
+{
+	omap24xxcam_reg_out(base, CAMDMA_OCP_SYSCONFIG,
+			    CAMDMA_OCP_SYSCONFIG_MIDLEMODE_FSTANDBY
+			    | CAMDMA_OCP_SYSCONFIG_SIDLEMODE_FIDLE
+			    | CAMDMA_OCP_SYSCONFIG_AUTOIDLE);
+
+	omap24xxcam_reg_merge(base, CAMDMA_GCR, 0x10,
+			      CAMDMA_GCR_MAX_CHANNEL_FIFO_DEPTH);
+
+	omap24xxcam_reg_out(base, CAMDMA_IRQENABLE_L0, 0xf);
+}
+
+/*
+ *
+ * Individual DMA channel handling.
+ *
+ */
+
+/* Start a DMA transfer from the camera to memory.
+ * Returns zero if the transfer was successfully started, or non-zero if all
+ * DMA channels are already in use or starting is currently inhibited.
+ */
+static int omap24xxcam_dma_start(struct omap24xxcam_dma *dma, dma_addr_t start,
+				 u32 len, dma_callback_t callback, void *arg)
+{
+	unsigned long flags;
+	int dmach;
+
+	spin_lock_irqsave(&dma->lock, flags);
+
+	if (!dma->free_dmach || atomic_read(&dma->dma_stop)) {
+		spin_unlock_irqrestore(&dma->lock, flags);
+		return -EBUSY;
+	}
+
+	dmach = dma->next_dmach;
+
+	dma->ch_state[dmach].callback = callback;
+	dma->ch_state[dmach].arg = arg;
+
+	omap24xxcam_dmahw_transfer_setup(dma->base, dmach, start, len);
+
+	/* We're ready to start the DMA transfer. */
+
+	if (dma->free_dmach < NUM_CAMDMA_CHANNELS) {
+		/* A transfer is already in progress, so try to chain to it. */
+		omap24xxcam_dmahw_transfer_chain(dma->base, dmach,
+						 dma->free_dmach);
+	}
+	else {
+		/* No transfer is in progress, so we'll just start this one
+		 * now.
+		 */
+		omap24xxcam_dmahw_transfer_start(dma->base, dmach);
+	}
+
+	dma->next_dmach = (dma->next_dmach + 1) % NUM_CAMDMA_CHANNELS;
+	dma->free_dmach--;
+
+	spin_unlock_irqrestore(&dma->lock, flags);
+
+	return 0;
+}
+
+/* Abort all chained DMA transfers. After all transfers have been
+ * aborted and the DMA controller is idle, the completion routines for
+ * any aborted transfers will be called in sequence. The DMA
+ * controller may not be idle after this routine completes, because
+ * the completion routines might start new transfers.
+ */
+static void omap24xxcam_dma_abort(struct omap24xxcam_dma *dma, u32 csr)
+{
+	unsigned long flags;
+	int dmach, i, free_dmach;
+	dma_callback_t callback;
+	void *arg;
+
+	spin_lock_irqsave(&dma->lock, flags);
+
+	/* stop any DMA transfers in progress */
+	dmach = (dma->next_dmach + dma->free_dmach) % NUM_CAMDMA_CHANNELS;
+	for (i = 0; i < NUM_CAMDMA_CHANNELS; i++) {
+		omap24xxcam_dmahw_abort_ch(dma->base, dmach);
+		dmach = (dmach + 1) % NUM_CAMDMA_CHANNELS;
+	}
+
+	/* We have to be careful here because the callback routine
+	 * might start a new DMA transfer, and we only want to abort
+	 * transfers that were started before this routine was called.
+	 */
+	free_dmach = dma->free_dmach;
+	while ((dma->free_dmach < NUM_CAMDMA_CHANNELS) &&
+	       (free_dmach < NUM_CAMDMA_CHANNELS)) {
+		dmach = (dma->next_dmach + dma->free_dmach)
+			% NUM_CAMDMA_CHANNELS;
+		callback = dma->ch_state[dmach].callback;
+		arg = dma->ch_state[dmach].arg;
+		dma->free_dmach++;
+		free_dmach++;
+		if (callback) {
+			/* leave interrupts disabled during callback */
+			spin_unlock(&dma->lock);
+			(*callback) (dma, csr, arg);
+			spin_lock(&dma->lock);
+		}
+	}
+
+	spin_unlock_irqrestore(&dma->lock, flags);
+}
+
+/* Abort all chained DMA transfers. After all transfers have been
+ * aborted and the DMA controller is idle, the completion routines for
+ * any aborted transfers will be called in sequence. If the completion
+ * routines attempt to start a new DMA transfer it will fail, so the
+ * DMA controller will be idle after this routine completes.
+ */
+static void omap24xxcam_dma_stop(struct omap24xxcam_dma *dma, u32 csr)
+{
+	atomic_inc(&dma->dma_stop);
+	omap24xxcam_dma_abort(dma, csr);
+	atomic_dec(&dma->dma_stop);
+}
+
+/* Camera DMA interrupt service routine. */
+void omap24xxcam_dma_isr(struct omap24xxcam_dma *dma)
+{
+	int dmach;
+	dma_callback_t callback;
+	void *arg;
+	u32 csr;
+	const u32 csr_error = CAMDMA_CSR_MISALIGNED_ERR
+		| CAMDMA_CSR_SUPERVISOR_ERR | CAMDMA_CSR_SECURE_ERR
+		| CAMDMA_CSR_TRANS_ERR | CAMDMA_CSR_DROP;
+
+	spin_lock(&dma->lock);
+
+	if (dma->free_dmach == NUM_CAMDMA_CHANNELS) {
+		/* A camera DMA interrupt occurred while all channels
+		 * are idle, so we'll acknowledge the interrupt in the
+		 * IRQSTATUS register and exit.
+		 */
+		omap24xxcam_dmahw_ack_all(dma->base);
+		spin_unlock(&dma->lock);
+		return;
+	}
+
+	while (dma->free_dmach < NUM_CAMDMA_CHANNELS) {
+		dmach = (dma->next_dmach + dma->free_dmach)
+			% NUM_CAMDMA_CHANNELS;
+		if (omap24xxcam_dmahw_running(dma->base, dmach)) {
+			/* This buffer hasn't finished yet, so we're done. */
+			break;
+		}
+		csr = omap24xxcam_dmahw_ack_ch(dma->base, dmach);
+		if (csr & csr_error) {
+			/* A DMA error occurred, so stop all DMA
+			 * transfers in progress.
+			 */
+			spin_unlock(&dma->lock);
+			omap24xxcam_dma_stop(dma, csr);
+			return;
+		} else {
+			callback = dma->ch_state[dmach].callback;
+			arg = dma->ch_state[dmach].arg;
+			dma->free_dmach++;
+			if (callback) {
+				spin_unlock(&dma->lock);
+				(*callback) (dma, csr, arg);
+				spin_lock(&dma->lock);
+			}
+		}
+	}
+
+	spin_unlock(&dma->lock);
+
+	omap24xxcam_sgdma_process(
+		container_of(dma, struct omap24xxcam_sgdma, dma));
+}
+
+void omap24xxcam_dma_hwinit(const struct omap24xxcam_dma *dma)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dma->lock, flags);
+
+	omap24xxcam_dmahw_init(dma->base);
+
+	spin_unlock_irqrestore(&dma->lock, flags);
+}
+
+static void omap24xxcam_dma_init(struct omap24xxcam_dma *dma,
+				 unsigned long base)
+{
+	int ch;
+
+	/* group all channels on DMA IRQ0 and unmask irq */
+	spin_lock_init(&dma->lock);
+	dma->base = base;
+	dma->free_dmach = NUM_CAMDMA_CHANNELS;
+	dma->next_dmach = 0;
+	for (ch = 0; ch < NUM_CAMDMA_CHANNELS; ch++) {
+		dma->ch_state[ch].callback = NULL;
+		dma->ch_state[ch].arg = NULL;
+	}
+}
+
+/*
+ *
+ * Scatter-gather DMA.
+ *
+ * High-level DMA construct for transferring whole picture frames to
+ * memory that is discontinuous.
+ *
+ */
+
+/* DMA completion routine for the scatter-gather DMA fragments. */
+static void omap24xxcam_sgdma_callback(struct omap24xxcam_dma *dma, u32 csr,
+				       void *arg)
+{
+	struct omap24xxcam_sgdma *sgdma =
+		container_of(dma, struct omap24xxcam_sgdma, dma);
+	int sgslot = (int)arg;
+	struct sgdma_state *sg_state;
+	const u32 csr_error = CAMDMA_CSR_MISALIGNED_ERR
+		| CAMDMA_CSR_SUPERVISOR_ERR | CAMDMA_CSR_SECURE_ERR
+		| CAMDMA_CSR_TRANS_ERR | CAMDMA_CSR_DROP;
+
+	spin_lock(&sgdma->lock);
+
+	/* We got an interrupt, we can remove the timer */
+	del_timer(&sgdma->reset_timer);
+
+	sg_state = sgdma->sg_state + sgslot;
+	if (!sg_state->queued_sglist) {
+		spin_unlock(&sgdma->lock);
+		printk(KERN_ERR "%s: sgdma completed when none queued!\n",
+		       __FUNCTION__);
+		return;
+	}
+
+	sg_state->csr |= csr;
+	if (!--sg_state->queued_sglist) {
+		/* Queue for this sglist is empty, so check to see if we're
+		 * done.
+		 */
+		if ((sg_state->next_sglist == sg_state->sglen)
+		    || (sg_state->csr & csr_error)) {
+			sgdma_callback_t callback = sg_state->callback;
+			void *arg = sg_state->arg;
+			u32 sg_csr = sg_state->csr;
+			/* All done with this sglist */
+			sgdma->free_sgdma++;
+			if (callback) {
+				spin_unlock(&sgdma->lock);
+				(*callback) (sgdma, sg_csr, arg);
+				return;
+			}
+		}
+	}
+
+	spin_unlock(&sgdma->lock);
+}
+
+/* Start queued scatter-gather DMA transfers. */
+void omap24xxcam_sgdma_process(struct omap24xxcam_sgdma *sgdma)
+{
+	unsigned long flags;
+	int queued_sgdma, sgslot;
+	struct sgdma_state *sg_state;
+	const u32 csr_error = CAMDMA_CSR_MISALIGNED_ERR
+		| CAMDMA_CSR_SUPERVISOR_ERR | CAMDMA_CSR_SECURE_ERR
+		| CAMDMA_CSR_TRANS_ERR | CAMDMA_CSR_DROP;
+
+	spin_lock_irqsave(&sgdma->lock, flags);
+
+	queued_sgdma = NUM_SG_DMA - sgdma->free_sgdma;
+	sgslot = (sgdma->next_sgdma + sgdma->free_sgdma) % NUM_SG_DMA;
+	while (queued_sgdma > 0) {
+		sg_state = sgdma->sg_state + sgslot;
+		while ((sg_state->next_sglist < sg_state->sglen) &&
+		       !(sg_state->csr & csr_error)) {
+			const struct scatterlist *sglist;
+			unsigned int len;
+
+			sglist = sg_state->sglist + sg_state->next_sglist;
+			/* try to start the next DMA transfer */
+			if (sg_state->next_sglist + 1 == sg_state->sglen) {
+				/*
+				 *  On the last sg, we handle the case where
+				 *  cam->img.pix.sizeimage % PAGE_ALIGN != 0
+				 */
+				len = sg_state->len - sg_state->bytes_read;
+			} else {
+				len = sg_dma_len(sglist);
+			}
+
+			if (omap24xxcam_dma_start(&sgdma->dma,
+						  sg_dma_address(sglist),
+						  len,
+						  omap24xxcam_sgdma_callback,
+						  (void *)sgslot)) {
+				/* DMA start failed */
+				spin_unlock_irqrestore(&sgdma->lock, flags);
+				return;
+			} else {
+				unsigned long expires;
+				/* DMA start was successful */
+				sg_state->next_sglist++;
+				sg_state->bytes_read += len;
+				sg_state->queued_sglist++;
+
+				/* We start the reset timer */
+				expires = jiffies + HZ;
+				mod_timer(&sgdma->reset_timer, expires);
+			}
+		}
+		queued_sgdma--;
+		sgslot = (sgslot + 1) % NUM_SG_DMA;
+	}
+
+	spin_unlock_irqrestore(&sgdma->lock, flags);
+}
+
+/*
+ * Queue a scatter-gather DMA transfer from the camera to memory.
+ * Returns zero if the transfer was successfully queued, or non-zero
+ * if all of the scatter-gather slots are already in use.
+ */
+int omap24xxcam_sgdma_queue(struct omap24xxcam_sgdma *sgdma,
+			    const struct scatterlist *sglist, int sglen,
+			    int len, sgdma_callback_t callback, void *arg)
+{
+	unsigned long flags;
+	struct sgdma_state *sg_state;
+
+	if ((sglen < 0) || ((sglen > 0) & !sglist))
+		return -EINVAL;
+
+	spin_lock_irqsave(&sgdma->lock, flags);
+
+	if (!sgdma->free_sgdma) {
+		spin_unlock_irqrestore(&sgdma->lock, flags);
+		return -EBUSY;
+	}
+
+	sg_state = sgdma->sg_state + sgdma->next_sgdma;
+
+	sg_state->sglist = sglist;
+	sg_state->sglen = sglen;
+	sg_state->next_sglist = 0;
+	sg_state->bytes_read = 0;
+	sg_state->len = len;
+	sg_state->queued_sglist = 0;
+	sg_state->csr = 0;
+	sg_state->callback = callback;
+	sg_state->arg = arg;
+
+	sgdma->next_sgdma = (sgdma->next_sgdma + 1) % NUM_SG_DMA;
+	sgdma->free_sgdma--;
+
+	spin_unlock_irqrestore(&sgdma->lock, flags);
+
+	omap24xxcam_sgdma_process(sgdma);
+
+	return 0;
+}
+
+/* Sync scatter-gather DMA by aborting any DMA transfers currently in progress.
+ * Any queued scatter-gather DMA transactions that have not yet been started
+ * will remain queued.  The DMA controller will be idle after this routine
+ * completes.  When the scatter-gather queue is restarted, the next
+ * scatter-gather DMA transfer will begin at the start of a new transaction.
+ */
+void omap24xxcam_sgdma_sync(struct omap24xxcam_sgdma *sgdma)
+{
+	unsigned long flags;
+	int sgslot;
+	struct sgdma_state *sg_state;
+	u32 csr = CAMDMA_CSR_TRANS_ERR;
+
+	/* stop any DMA transfers in progress */
+	omap24xxcam_dma_stop(&sgdma->dma, csr);
+
+	spin_lock_irqsave(&sgdma->lock, flags);
+
+	if (sgdma->free_sgdma < NUM_SG_DMA) {
+		sgslot = (sgdma->next_sgdma + sgdma->free_sgdma) % NUM_SG_DMA;
+		sg_state = sgdma->sg_state + sgslot;
+		if (sg_state->next_sglist != 0) {
+			/* This DMA transfer was in progress, so abort it. */
+			sgdma_callback_t callback = sg_state->callback;
+			void *arg = sg_state->arg;
+			sgdma->free_sgdma++;
+			if (callback) {
+				/* leave interrupts masked */
+				spin_unlock(&sgdma->lock);
+				(*callback) (sgdma, csr, arg);
+				spin_lock(&sgdma->lock);
+			}
+		}
+	}
+
+	spin_unlock_irqrestore(&sgdma->lock, flags);
+}
+
+void omap24xxcam_sgdma_init(struct omap24xxcam_sgdma *sgdma,
+			    unsigned long base,
+			    void (*reset_callback)(unsigned long data),
+			    unsigned long reset_callback_data)
+{
+	int sg;
+
+	spin_lock_init(&sgdma->lock);
+	sgdma->free_sgdma = NUM_SG_DMA;
+	sgdma->next_sgdma = 0;
+	for (sg = 0; sg < NUM_SG_DMA; sg++) {
+		sgdma->sg_state[sg].sglen = 0;
+		sgdma->sg_state[sg].next_sglist = 0;
+		sgdma->sg_state[sg].bytes_read = 0;
+		sgdma->sg_state[sg].queued_sglist = 0;
+		sgdma->sg_state[sg].csr = 0;
+		sgdma->sg_state[sg].callback = NULL;
+		sgdma->sg_state[sg].arg = NULL;
+	}
+
+	omap24xxcam_dma_init(&sgdma->dma, base);
+	init_timer(&sgdma->reset_timer);
+	sgdma->reset_timer.function = reset_callback;
+	sgdma->reset_timer.data = reset_callback_data;
+}
diff -ruN linux-omap-2.6/drivers/media/video/omap/omap24xxcam.h maemo_src/drivers/media/video/omap/omap24xxcam.h
--- linux-omap-2.6/drivers/media/video/omap/omap24xxcam.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/media/video/omap/omap24xxcam.h	2011-02-06 20:12:12.903333273 -0500
@@ -0,0 +1,581 @@
+/*
+ * omap24xxcam.h
+ *
+ * Copyright (C) 2004 MontaVista Software, Inc.
+ * Copyright (C) 2004 Texas Instruments.
+ * Copyright (C) 2007 Nokia Corporation.
+ *
+ * Contact: Sakari Ailus <sakari.ailus@nokia.com>
+ *
+ * Based on code from Andy Lowe <source@mvista.com>.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#ifndef OMAP24XXCAM_H
+#define OMAP24XXCAM_H
+
+#include <media/video-buf.h>
+
+#include "sensor_if.h"
+
+/*
+ *
+ * General driver related definitions.
+ *
+ */
+
+#define CAM_NAME				"omap24xxcam"
+
+#define CAM_MCLK				96000000
+
+/* number of bytes transferred per DMA request */
+#define DMA_THRESHOLD				32
+
+/* NUM_CAMDMA_CHANNELS is the number of logical channels provided by
+ * the camera DMA controller.
+ */
+#define NUM_CAMDMA_CHANNELS			4
+
+/* NUM_SG_DMA is the number of scatter-gather DMA transfers that can
+ * be queued. (We don't have any overlay sglists now.)
+ */
+#define NUM_SG_DMA				(VIDEO_MAX_FRAME)
+
+/*
+ *
+ * Register definitions.
+ *
+ */
+
+/* subsystem register block offsets */
+#define CC_REG_OFFSET				0x00000400
+#define CAMDMA_REG_OFFSET			0x00000800
+#define CAMMMU_REG_OFFSET			0x00000C00
+
+/* define camera subsystem register offsets */
+#define CAM_REVISION				0x000
+#define CAM_SYSCONFIG				0x010
+#define CAM_SYSSTATUS				0x014
+#define CAM_IRQSTATUS				0x018
+#define CAM_GPO					0x040
+#define CAM_GPI					0x050
+
+/* define camera core register offsets */
+#define CC_REVISION				0x000
+#define CC_SYSCONFIG				0x010
+#define CC_SYSSTATUS				0x014
+#define CC_IRQSTATUS				0x018
+#define CC_IRQENABLE				0x01C
+#define CC_CTRL					0x040
+#define CC_CTRL_DMA				0x044
+#define CC_CTRL_XCLK				0x048
+#define CC_FIFODATA				0x04C
+#define CC_TEST					0x050
+#define CC_GENPAR				0x054
+#define CC_CCPFSCR				0x058
+#define CC_CCPFECR				0x05C
+#define CC_CCPLSCR				0x060
+#define CC_CCPLECR				0x064
+#define CC_CCPDFR				0x068
+
+/* define camera dma register offsets */
+#define CAMDMA_REVISION				0x000
+#define CAMDMA_IRQSTATUS_L0			0x008
+#define CAMDMA_IRQSTATUS_L1			0x00C
+#define CAMDMA_IRQSTATUS_L2			0x010
+#define CAMDMA_IRQSTATUS_L3			0x014
+#define CAMDMA_IRQENABLE_L0			0x018
+#define CAMDMA_IRQENABLE_L1			0x01C
+#define CAMDMA_IRQENABLE_L2			0x020
+#define CAMDMA_IRQENABLE_L3			0x024
+#define CAMDMA_SYSSTATUS			0x028
+#define CAMDMA_OCP_SYSCONFIG			0x02C
+#define CAMDMA_CAPS_0				0x064
+#define CAMDMA_CAPS_2				0x06C
+#define CAMDMA_CAPS_3				0x070
+#define CAMDMA_CAPS_4				0x074
+#define CAMDMA_GCR				0x078
+#define CAMDMA_CCR(n)				(0x080 + (n)*0x60)
+#define CAMDMA_CLNK_CTRL(n)			(0x084 + (n)*0x60)
+#define CAMDMA_CICR(n)				(0x088 + (n)*0x60)
+#define CAMDMA_CSR(n)				(0x08C + (n)*0x60)
+#define CAMDMA_CSDP(n)				(0x090 + (n)*0x60)
+#define CAMDMA_CEN(n)				(0x094 + (n)*0x60)
+#define CAMDMA_CFN(n)				(0x098 + (n)*0x60)
+#define CAMDMA_CSSA(n)				(0x09C + (n)*0x60)
+#define CAMDMA_CDSA(n)				(0x0A0 + (n)*0x60)
+#define CAMDMA_CSEI(n)				(0x0A4 + (n)*0x60)
+#define CAMDMA_CSFI(n)				(0x0A8 + (n)*0x60)
+#define CAMDMA_CDEI(n)				(0x0AC + (n)*0x60)
+#define CAMDMA_CDFI(n)				(0x0B0 + (n)*0x60)
+#define CAMDMA_CSAC(n)				(0x0B4 + (n)*0x60)
+#define CAMDMA_CDAC(n)				(0x0B8 + (n)*0x60)
+#define CAMDMA_CCEN(n)				(0x0BC + (n)*0x60)
+#define CAMDMA_CCFN(n)				(0x0C0 + (n)*0x60)
+#define CAMDMA_COLOR(n)				(0x0C4 + (n)*0x60)
+
+/* define camera mmu register offsets */
+#define CAMMMU_REVISION				0x000
+#define CAMMMU_SYSCONFIG			0x010
+#define CAMMMU_SYSSTATUS			0x014
+#define CAMMMU_IRQSTATUS			0x018
+#define CAMMMU_IRQENABLE			0x01C
+#define CAMMMU_WALKING_ST			0x040
+#define CAMMMU_CNTL				0x044
+#define CAMMMU_FAULT_AD				0x048
+#define CAMMMU_TTB				0x04C
+#define CAMMMU_LOCK				0x050
+#define CAMMMU_LD_TLB				0x054
+#define CAMMMU_CAM				0x058
+#define CAMMMU_RAM				0x05C
+#define CAMMMU_GFLUSH				0x060
+#define CAMMMU_FLUSH_ENTRY			0x064
+#define CAMMMU_READ_CAM				0x068
+#define CAMMMU_READ_RAM				0x06C
+#define CAMMMU_EMU_FAULT_AD			0x070
+
+/* Define bit fields within selected registers */
+#define CAM_REVISION_MAJOR			(15 << 4)
+#define CAM_REVISION_MAJOR_SHIFT		4
+#define CAM_REVISION_MINOR			(15 << 0)
+#define CAM_REVISION_MINOR_SHIFT		0
+
+#define CAM_SYSCONFIG_SOFTRESET			(1 <<  1)
+#define CAM_SYSCONFIG_AUTOIDLE			(1 <<  0)
+
+#define CAM_SYSSTATUS_RESETDONE			(1 <<  0)
+
+#define CAM_IRQSTATUS_CC_IRQ			(1 <<  4)
+#define CAM_IRQSTATUS_MMU_IRQ			(1 <<  3)
+#define CAM_IRQSTATUS_DMA_IRQ2			(1 <<  2)
+#define CAM_IRQSTATUS_DMA_IRQ1			(1 <<  1)
+#define CAM_IRQSTATUS_DMA_IRQ0			(1 <<  0)
+
+#define CAM_GPO_CAM_S_P_EN			(1 <<  1)
+#define CAM_GPO_CAM_CCP_MODE			(1 <<  0)
+
+#define CAM_GPI_CC_DMA_REQ1			(1 << 24)
+#define CAP_GPI_CC_DMA_REQ0			(1 << 23)
+#define CAP_GPI_CAM_MSTANDBY			(1 << 21)
+#define CAP_GPI_CAM_WAIT			(1 << 20)
+#define CAP_GPI_CAM_S_DATA			(1 << 17)
+#define CAP_GPI_CAM_S_CLK			(1 << 16)
+#define CAP_GPI_CAM_P_DATA			(0xFFF << 3)
+#define CAP_GPI_CAM_P_DATA_SHIFT		3
+#define CAP_GPI_CAM_P_VS			(1 <<  2)
+#define CAP_GPI_CAM_P_HS			(1 <<  1)
+#define CAP_GPI_CAM_P_CLK			(1 <<  0)
+
+#define CC_REVISION_MAJOR			(15 << 4)
+#define CC_REVISION_MAJOR_SHIFT			4
+#define CC_REVISION_MINOR			(15 << 0)
+#define CC_REVISION_MINOR_SHIFT			0
+
+#define CC_SYSCONFIG_SIDLEMODE			(3 <<  3)
+#define CC_SYSCONFIG_SIDLEMODE_FIDLE		(0 <<  3)
+#define CC_SYSCONFIG_SIDLEMODE_NIDLE		(1 <<  3)
+#define CC_SYSCONFIG_SOFTRESET			(1 <<  1)
+#define CC_SYSCONFIG_AUTOIDLE			(1 <<  0)
+
+#define CC_SYSSTATUS_RESETDONE			(1 <<  0)
+
+#define CC_IRQSTATUS_FS_IRQ			(1 << 19)
+#define CC_IRQSTATUS_LE_IRQ			(1 << 18)
+#define CC_IRQSTATUS_LS_IRQ			(1 << 17)
+#define CC_IRQSTATUS_FE_IRQ			(1 << 16)
+#define CC_IRQSTATUS_FW_ERR_IRQ			(1 << 10)
+#define CC_IRQSTATUS_FSC_ERR_IRQ		(1 <<  9)
+#define CC_IRQSTATUS_SSC_ERR_IRQ		(1 <<  8)
+#define CC_IRQSTATUS_FIFO_NOEMPTY_IRQ		(1 <<  4)
+#define CC_IRQSTATUS_FIFO_FULL_IRQ		(1 <<  3)
+#define CC_IRQSTATUS_FIFO_THR_IRQ		(1 <<  2)
+#define CC_IRQSTATUS_FIFO_OF_IRQ		(1 <<  1)
+#define CC_IRQSTATUS_FIFO_UF_IRQ		(1 <<  0)
+
+#define CC_IRQENABLE_FS_IRQ			(1 << 19)
+#define CC_IRQENABLE_LE_IRQ			(1 << 18)
+#define CC_IRQENABLE_LS_IRQ			(1 << 17)
+#define CC_IRQENABLE_FE_IRQ			(1 << 16)
+#define CC_IRQENABLE_FW_ERR_IRQ			(1 << 10)
+#define CC_IRQENABLE_FSC_ERR_IRQ		(1 <<  9)
+#define CC_IRQENABLE_SSC_ERR_IRQ		(1 <<  8)
+#define CC_IRQENABLE_FIFO_NOEMPTY_IRQ		(1 <<  4)
+#define CC_IRQENABLE_FIFO_FULL_IRQ		(1 <<  3)
+#define CC_IRQENABLE_FIFO_THR_IRQ		(1 <<  2)
+#define CC_IRQENABLE_FIFO_OF_IRQ		(1 <<  1)
+#define CC_IRQENABLE_FIFO_UF_IRQ		(1 <<  0)
+
+#define CC_CTRL_CC_ONE_SHOT			(1 << 20)
+#define CC_CTRL_CC_IF_SYNCHRO			(1 << 19)
+#define CC_CTRL_CC_RST				(1 << 18)
+#define CC_CTRL_CC_FRAME_TRIG			(1 << 17)
+#define CC_CTRL_CC_EN				(1 << 16)
+#define CC_CTRL_NOBT_SYNCHRO			(1 << 13)
+#define CC_CTRL_BT_CORRECT			(1 << 12)
+#define CC_CTRL_PAR_ORDERCAM			(1 << 11)
+#define CC_CTRL_PAR_CLK_POL			(1 << 10)
+#define CC_CTRL_NOBT_HS_POL			(1 <<  9)
+#define CC_CTRL_NOBT_VS_POL			(1 <<  8)
+#define CC_CTRL_PAR_MODE			(7 <<  1)
+#define CC_CTRL_PAR_MODE_SHIFT			1
+#define CC_CTRL_PAR_MODE_NOBT8			(0 <<  1)
+#define CC_CTRL_PAR_MODE_NOBT10			(1 <<  1)
+#define CC_CTRL_PAR_MODE_NOBT12			(2 <<  1)
+#define CC_CTRL_PAR_MODE_BT8			(4 <<  1)
+#define CC_CTRL_PAR_MODE_BT10			(5 <<  1)
+#define CC_CTRL_PAR_MODE_FIFOTEST		(7 <<  1)
+#define CC_CTRL_CCP_MODE			(1 <<  0)
+
+#define CC_CTRL_DMA_EN				(1 <<  8)
+#define CC_CTRL_DMA_FIFO_THRESHOLD		(0x7F << 0)
+#define CC_CTRL_DMA_FIFO_THRESHOLD_SHIFT	0
+
+#define CC_CTRL_XCLK_DIV			(0x1F << 0)
+#define CC_CTRL_XCLK_DIV_SHIFT			0
+#define CC_CTRL_XCLK_DIV_STABLE_LOW		(0 <<  0)
+#define CC_CTRL_XCLK_DIV_STABLE_HIGH		(1 <<  0)
+#define CC_CTRL_XCLK_DIV_BYPASS			(31 << 0)
+
+#define CC_TEST_FIFO_RD_POINTER			(0xFF << 24)
+#define CC_TEST_FIFO_RD_POINTER_SHIFT		24
+#define CC_TEST_FIFO_WR_POINTER			(0xFF << 16)
+#define CC_TEST_FIFO_WR_POINTER_SHIFT		16
+#define CC_TEST_FIFO_LEVEL			(0xFF <<  8)
+#define CC_TEST_FIFO_LEVEL_SHIFT		8
+#define CC_TEST_FIFO_LEVEL_PEAK			(0xFF <<  0)
+#define CC_TEST_FIFO_LEVEL_PEAK_SHIFT		0
+
+#define CC_GENPAR_FIFO_DEPTH			(7 <<  0)
+#define CC_GENPAR_FIFO_DEPTH_SHIFT		0
+
+#define CC_CCPDFR_ALPHA				(0xFF <<  8)
+#define CC_CCPDFR_ALPHA_SHIFT			8
+#define CC_CCPDFR_DATAFORMAT			(15 <<  0)
+#define CC_CCPDFR_DATAFORMAT_SHIFT		0
+#define CC_CCPDFR_DATAFORMAT_YUV422BE		( 0 <<  0)
+#define CC_CCPDFR_DATAFORMAT_YUV422		( 1 <<  0)
+#define CC_CCPDFR_DATAFORMAT_YUV420		( 2 <<  0)
+#define CC_CCPDFR_DATAFORMAT_RGB444		( 4 <<  0)
+#define CC_CCPDFR_DATAFORMAT_RGB565		( 5 <<  0)
+#define CC_CCPDFR_DATAFORMAT_RGB888NDE		( 6 <<  0)
+#define CC_CCPDFR_DATAFORMAT_RGB888		( 7 <<  0)
+#define CC_CCPDFR_DATAFORMAT_RAW8NDE		( 8 <<  0)
+#define CC_CCPDFR_DATAFORMAT_RAW8		( 9 <<  0)
+#define CC_CCPDFR_DATAFORMAT_RAW10NDE		(10 <<  0)
+#define CC_CCPDFR_DATAFORMAT_RAW10		(11 <<  0)
+#define CC_CCPDFR_DATAFORMAT_RAW12NDE		(12 <<  0)
+#define CC_CCPDFR_DATAFORMAT_RAW12		(13 <<  0)
+#define CC_CCPDFR_DATAFORMAT_JPEG8		(15 <<  0)
+
+#define CAMDMA_REVISION_MAJOR			(15 << 4)
+#define CAMDMA_REVISION_MAJOR_SHIFT		4
+#define CAMDMA_REVISION_MINOR			(15 << 0)
+#define CAMDMA_REVISION_MINOR_SHIFT		0
+
+#define CAMDMA_OCP_SYSCONFIG_MIDLEMODE		(3 << 12)
+#define CAMDMA_OCP_SYSCONFIG_MIDLEMODE_FSTANDBY	(0 << 12)
+#define CAMDMA_OCP_SYSCONFIG_MIDLEMODE_NSTANDBY	(1 << 12)
+#define CAMDMA_OCP_SYSCONFIG_MIDLEMODE_SSTANDBY	(2 << 12)
+#define CAMDMA_OCP_SYSCONFIG_FUNC_CLOCK		(1 <<  9)
+#define CAMDMA_OCP_SYSCONFIG_OCP_CLOCK		(1 <<  8)
+#define CAMDMA_OCP_SYSCONFIG_EMUFREE		(1 <<  5)
+#define CAMDMA_OCP_SYSCONFIG_SIDLEMODE		(3 <<  3)
+#define CAMDMA_OCP_SYSCONFIG_SIDLEMODE_FIDLE	(0 <<  3)
+#define CAMDMA_OCP_SYSCONFIG_SIDLEMODE_NIDLE	(1 <<  3)
+#define CAMDMA_OCP_SYSCONFIG_SIDLEMODE_SIDLE	(2 <<  3)
+#define CAMDMA_OCP_SYSCONFIG_SOFTRESET		(1 <<  1)
+#define CAMDMA_OCP_SYSCONFIG_AUTOIDLE		(1 <<  0)
+
+#define CAMDMA_SYSSTATUS_RESETDONE		(1 <<  0)
+
+#define CAMDMA_GCR_ARBITRATION_RATE		(0xFF << 16)
+#define CAMDMA_GCR_ARBITRATION_RATE_SHIFT	16
+#define CAMDMA_GCR_MAX_CHANNEL_FIFO_DEPTH	(0xFF << 0)
+#define CAMDMA_GCR_MAX_CHANNEL_FIFO_DEPTH_SHIFT	0
+
+#define CAMDMA_CCR_SEL_SRC_DST_SYNC		(1 << 24)
+#define CAMDMA_CCR_PREFETCH			(1 << 23)
+#define CAMDMA_CCR_SUPERVISOR			(1 << 22)
+#define CAMDMA_CCR_SECURE			(1 << 21)
+#define CAMDMA_CCR_BS				(1 << 18)
+#define CAMDMA_CCR_TRANSPARENT_COPY_ENABLE	(1 << 17)
+#define CAMDMA_CCR_CONSTANT_FILL_ENABLE		(1 << 16)
+#define CAMDMA_CCR_DST_AMODE			(3 << 14)
+#define CAMDMA_CCR_DST_AMODE_CONST_ADDR		(0 << 14)
+#define CAMDMA_CCR_DST_AMODE_POST_INC		(1 << 14)
+#define CAMDMA_CCR_DST_AMODE_SGL_IDX		(2 << 14)
+#define CAMDMA_CCR_DST_AMODE_DBL_IDX		(3 << 14)
+#define CAMDMA_CCR_SRC_AMODE			(3 << 12)
+#define CAMDMA_CCR_SRC_AMODE_CONST_ADDR		(0 << 12)
+#define CAMDMA_CCR_SRC_AMODE_POST_INC		(1 << 12)
+#define CAMDMA_CCR_SRC_AMODE_SGL_IDX		(2 << 12)
+#define CAMDMA_CCR_SRC_AMODE_DBL_IDX		(3 << 12)
+#define CAMDMA_CCR_WR_ACTIVE			(1 << 10)
+#define CAMDMA_CCR_RD_ACTIVE			(1 <<  9)
+#define CAMDMA_CCR_SUSPEND_SENSITIVE		(1 <<  8)
+#define CAMDMA_CCR_ENABLE			(1 <<  7)
+#define CAMDMA_CCR_PRIO				(1 <<  6)
+#define CAMDMA_CCR_FS				(1 <<  5)
+#define CAMDMA_CCR_SYNCHRO			((3 << 19) | (31 << 0))
+#define CAMDMA_CCR_SYNCHRO_CAMERA		0x01
+
+#define CAMDMA_CLNK_CTRL_ENABLE_LNK		(1 << 15)
+#define CAMDMA_CLNK_CTRL_NEXTLCH_ID		(0x1F << 0)
+#define CAMDMA_CLNK_CTRL_NEXTLCH_ID_SHIFT	0
+
+#define CAMDMA_CICR_MISALIGNED_ERR_IE		(1 << 11)
+#define CAMDMA_CICR_SUPERVISOR_ERR_IE		(1 << 10)
+#define CAMDMA_CICR_SECURE_ERR_IE		(1 <<  9)
+#define CAMDMA_CICR_TRANS_ERR_IE		(1 <<  8)
+#define CAMDMA_CICR_PACKET_IE			(1 <<  7)
+#define CAMDMA_CICR_BLOCK_IE			(1 <<  5)
+#define CAMDMA_CICR_LAST_IE			(1 <<  4)
+#define CAMDMA_CICR_FRAME_IE			(1 <<  3)
+#define CAMDMA_CICR_HALF_IE			(1 <<  2)
+#define CAMDMA_CICR_DROP_IE			(1 <<  1)
+
+#define CAMDMA_CSR_MISALIGNED_ERR		(1 << 11)
+#define CAMDMA_CSR_SUPERVISOR_ERR		(1 << 10)
+#define CAMDMA_CSR_SECURE_ERR			(1 <<  9)
+#define CAMDMA_CSR_TRANS_ERR			(1 <<  8)
+#define CAMDMA_CSR_PACKET			(1 <<  7)
+#define CAMDMA_CSR_SYNC				(1 <<  6)
+#define CAMDMA_CSR_BLOCK			(1 <<  5)
+#define CAMDMA_CSR_LAST				(1 <<  4)
+#define CAMDMA_CSR_FRAME			(1 <<  3)
+#define CAMDMA_CSR_HALF				(1 <<  2)
+#define CAMDMA_CSR_DROP				(1 <<  1)
+
+#define CAMDMA_CSDP_SRC_ENDIANNESS		(1 << 21)
+#define CAMDMA_CSDP_SRC_ENDIANNESS_LOCK		(1 << 20)
+#define CAMDMA_CSDP_DST_ENDIANNESS		(1 << 19)
+#define CAMDMA_CSDP_DST_ENDIANNESS_LOCK		(1 << 18)
+#define CAMDMA_CSDP_WRITE_MODE			(3 << 16)
+#define CAMDMA_CSDP_WRITE_MODE_WRNP		(0 << 16)
+#define CAMDMA_CSDP_WRITE_MODE_POSTED		(1 << 16)
+#define CAMDMA_CSDP_WRITE_MODE_POSTED_LAST_WRNP	(2 << 16)
+#define CAMDMA_CSDP_DST_BURST_EN		(3 << 14)
+#define CAMDMA_CSDP_DST_BURST_EN_1		(0 << 14)
+#define CAMDMA_CSDP_DST_BURST_EN_16		(1 << 14)
+#define CAMDMA_CSDP_DST_BURST_EN_32		(2 << 14)
+#define CAMDMA_CSDP_DST_BURST_EN_64		(3 << 14)
+#define CAMDMA_CSDP_DST_PACKED			(1 << 13)
+#define CAMDMA_CSDP_WR_ADD_TRSLT		(15 << 9)
+#define CAMDMA_CSDP_WR_ADD_TRSLT_ENABLE_MREQADD	(3 <<  9)
+#define CAMDMA_CSDP_SRC_BURST_EN		(3 <<  7)
+#define CAMDMA_CSDP_SRC_BURST_EN_1		(0 <<  7)
+#define CAMDMA_CSDP_SRC_BURST_EN_16		(1 <<  7)
+#define CAMDMA_CSDP_SRC_BURST_EN_32		(2 <<  7)
+#define CAMDMA_CSDP_SRC_BURST_EN_64		(3 <<  7)
+#define CAMDMA_CSDP_SRC_PACKED			(1 <<  6)
+#define CAMDMA_CSDP_RD_ADD_TRSLT		(15 << 2)
+#define CAMDMA_CSDP_RD_ADD_TRSLT_ENABLE_MREQADD	(3 <<  2)
+#define CAMDMA_CSDP_DATA_TYPE			(3 <<  0)
+#define CAMDMA_CSDP_DATA_TYPE_8BITS		(0 <<  0)
+#define CAMDMA_CSDP_DATA_TYPE_16BITS		(1 <<  0)
+#define CAMDMA_CSDP_DATA_TYPE_32BITS		(2 <<  0)
+
+#define CAMMMU_SYSCONFIG_AUTOIDLE		(1 <<  0)
+
+/*
+ *
+ * Declarations.
+ *
+ */
+
+/* forward declarations */
+struct omap24xxcam_sgdma;
+struct omap24xxcam_dma;
+
+typedef void (*sgdma_callback_t)(struct omap24xxcam_sgdma * cam,
+				 u32 status, void *arg);
+typedef void (*dma_callback_t)(struct omap24xxcam_dma * cam,
+			       u32 status, void *arg);
+
+struct channel_state {
+	dma_callback_t callback;
+	void *arg;
+};
+
+/* sgdma state for each of the possible videobuf_buffers + 2 overlays */
+struct sgdma_state {
+	const struct scatterlist *sglist;
+	int sglen;		 /* number of sglist entries */
+	int next_sglist;	 /* index of next sglist entry to process */
+	unsigned int bytes_read; /* number of bytes read */
+	unsigned int len;        /* total length of sglist (excluding
+				  * bytes due to page alignment) */
+	int queued_sglist;	 /* number of sglist entries queued for DMA */
+	u32 csr;		 /* DMA return code */
+	sgdma_callback_t callback;
+	void *arg;
+};
+
+/* physical DMA channel management */
+struct omap24xxcam_dma {
+	spinlock_t lock;
+
+	unsigned long base;	/* base address for dma controller */
+
+	/* While dma_stop!=0, an attempt to start a new DMA transfer will
+	 * fail.
+	 */
+	atomic_t dma_stop;
+	int free_dmach;		/* number of dma channels free */
+	int next_dmach;		/* index of next dma channel to use */
+	struct channel_state ch_state[NUM_CAMDMA_CHANNELS];
+};
+
+/* scatter-gather DMA (scatterlist stuff) management */
+struct omap24xxcam_sgdma {
+	struct omap24xxcam_dma dma;
+
+	spinlock_t lock;
+	int free_sgdma;		/* number of free sg dma slots */
+	int next_sgdma;		/* index of next sg dma slot to use */
+	struct sgdma_state sg_state[NUM_SG_DMA];
+
+	/* Reset timer data */
+	struct timer_list reset_timer;
+};
+
+#define RESET_INTERVAL msecs_to_jiffies(5000)
+
+/* per-device data structure */
+struct omap24xxcam_device {
+	/*** mutex  ***/
+	/*
+	 * mutex serialises access to this structure. Also camera
+	 * opening and releasing is synchronised by this.
+	 */
+	struct mutex mutex;
+
+	/*** general driver state information ***/
+	atomic_t users;
+	/*
+	 * Lock to serialise core enabling and disabling and access to
+	 * next_reset_at and sgdma_in_queue.
+	 */
+	spinlock_t core_enable_disable_lock;
+	unsigned long next_reset_at;
+	atomic_t field_count_at_last_reset;
+	int sgdma_in_queue; /* number or sgdma requests in
+			     * scatter-gather queue, protected by the
+			     * lock above */
+
+	/*** subsystem structures ***/
+	struct omap24xxcam_sgdma sgdma;
+
+	/*** hardware resources ***/
+	unsigned int irq;
+	unsigned long mmio_base;
+	unsigned long mmio_base_phys;
+	unsigned long mmio_size;
+
+	/*** interfaces and device ***/
+	struct v4l2_int_device *sdev;
+	struct device *dev;
+	struct video_device *vfd;
+
+	/*** camera and sensor reset related stuff ***/
+	struct work_struct sensor_reset_work;
+	/*
+	 * We're in the middle of a reset. Don't enable core if this
+	 * is non-zero! This exists to help decisionmaking in a case
+	 * where videobuf_qbuf is called while we are in the middle of
+	 * a reset.
+	 */
+	atomic_t in_reset;
+	/* Non-zero if we don't want any resets for now. Used to
+	 * prevent reset work to run when we're about to stop
+	 * streaming. */
+	atomic_t reset_disable;
+
+	/*** video device parameters ***/
+	int capture_mem;
+
+	/*** camera module clocks ***/
+	struct clk *fck;
+	struct clk *ick;
+
+	/*** capture data ***/
+	/* file handle, if streaming is on */
+	struct file *streaming;
+};
+
+/* Per-file handle data. */
+struct omap24xxcam_fh {
+	spinlock_t vbq_lock; /* spinlock for the videobuf queue */
+	struct videobuf_queue vbq;
+	struct v4l2_pix_format pix; /* serialise pix by vbq->lock */
+	atomic_t field_count; /* field counter for videobuf_buffer */
+	/* accessing cam here doesn't need serialisation: it's constant */
+	struct omap24xxcam_device *cam;
+};
+
+/*
+ *
+ * Register I/O functions.
+ *
+ */
+
+static __inline__ u32 omap24xxcam_reg_in(unsigned long base, u32 offset)
+{
+	return readl(base + offset);
+}
+
+static __inline__ u32 omap24xxcam_reg_out(unsigned long base, u32 offset,
+					  u32 val)
+{
+	writel(val, base + offset);
+	return val;
+}
+
+static __inline__ u32 omap24xxcam_reg_merge(unsigned long base, u32 offset,
+					    u32 val, u32 mask)
+{
+	u32 addr = base + offset;
+	u32 new_val = (readl(addr) & ~mask) | (val & mask);
+
+	writel(new_val, addr);
+	return new_val;
+}
+
+/*
+ *
+ * Function prototypes.
+ *
+ */
+
+/* dma prototypes */
+
+void omap24xxcam_dma_hwinit(const struct omap24xxcam_dma *dma);
+void omap24xxcam_dma_isr(struct omap24xxcam_dma *dma);
+
+/* sgdma prototypes */
+
+void omap24xxcam_sgdma_process(struct omap24xxcam_sgdma *sgdma);
+int omap24xxcam_sgdma_queue(struct omap24xxcam_sgdma *sgdma,
+			    const struct scatterlist *sglist, int sglen,
+			    int len, sgdma_callback_t callback, void *arg);
+void omap24xxcam_sgdma_sync(struct omap24xxcam_sgdma *sgdma);
+void omap24xxcam_sgdma_init(struct omap24xxcam_sgdma *sgdma,
+			    unsigned long base,
+			    void (*reset_callback)(unsigned long data),
+			    unsigned long reset_callback_data);
+void omap24xxcam_sgdma_exit(struct omap24xxcam_sgdma *sgdma);
+
+#endif
diff -ruN linux-omap-2.6/drivers/media/video/omap/sensor_if.c maemo_src/drivers/media/video/omap/sensor_if.c
--- linux-omap-2.6/drivers/media/video/omap/sensor_if.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/media/video/omap/sensor_if.c	2007-10-02 03:09:31.000000000 -0400
@@ -0,0 +1,99 @@
+/*
+ * sensor_if.c
+ *
+ * An interface for V4L2 sensors.
+ *
+ * Copyright (C) 2007 Nokia Corporation.
+ *
+ * Contact: Sakari Ailus <sakari.ailus@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/string.h>
+#include <media/v4l2-common.h>
+
+#include "sensor_if.h"
+
+static DEFINE_MUTEX(mutex);
+static LIST_HEAD(int_list);
+
+static void v4l2_sensor_try_attach_all(void)
+{
+	struct list_head *head_master;
+
+	list_for_each(head_master, &int_list) {
+		struct list_head *head_slave;
+		struct v4l2_int_device *m =
+			list_entry(head_master, struct v4l2_int_device, head);
+
+		if (m->type != v4l2_int_type_master)
+			continue;
+
+		list_for_each(head_slave, &int_list) {
+			struct v4l2_int_device *s =
+				list_entry(head_slave,
+					   struct v4l2_int_device, head);
+
+			if (s->type != v4l2_int_type_slave)
+				continue;
+
+			/* Slave is connected? */
+			if (s->u.slave->master)
+				continue;
+
+			/* Slave wants to attach to master? */
+			if (s->u.slave->attach_to[0] != 0
+			    && strncmp(m->name, s->u.slave->attach_to,
+				       V4L2NAMESIZE))
+				continue;
+
+			if (!try_module_get(m->module))
+				continue;
+
+			if (m->u.master->attach(m, s)) {
+				module_put(m->module);
+				continue;
+			}
+
+			s->u.slave->master = m;
+		}
+	}
+}
+
+int v4l2_int_device_register(struct v4l2_int_device *d)
+{
+	mutex_lock(&mutex);
+	list_add(&d->head, &int_list);
+	v4l2_sensor_try_attach_all();
+	mutex_unlock(&mutex);
+
+	return 0;
+}
+
+void v4l2_int_device_unregister(struct v4l2_int_device *d)
+{
+	mutex_lock(&mutex);
+	list_del(&d->head);
+	if (d->type == v4l2_int_type_slave
+	    && d->u.slave->master != NULL) {
+		d->u.slave->master->u.master->detach(d);
+		module_put(d->u.slave->master->module);
+		d->u.slave->master = NULL;
+	}
+	mutex_unlock(&mutex);
+}
diff -ruN linux-omap-2.6/drivers/media/video/omap/sensor_if.h maemo_src/drivers/media/video/omap/sensor_if.h
--- linux-omap-2.6/drivers/media/video/omap/sensor_if.h	2011-02-06 20:17:25.719999940 -0500
+++ maemo_src/drivers/media/video/omap/sensor_if.h	2007-10-02 03:09:31.000000000 -0400
@@ -1,50 +1,121 @@
 /*
- * drivers/media/video/omap/sensor_if.h
+ * sensor_if.h
  *
- * Copyright (C) 2004 Texas Instruments, Inc. 
- * 
- * Sensor interface to OMAP camera capture drivers
- * Sensor driver should implement this interface
- *
- * This package is free software; you can redistribute it and/or modify 
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation. 
- * 
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR 
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED 
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. 
+ * An interface for V4L2 sensors.
+ *
+ * Copyright (C) 2007 Nokia Corporation.
+ *
+ * Contact: Sakari Ailus <sakari.ailus@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
  */
- 
-#ifndef OMAP_SENSOR_IF_H
-#define OMAP_SENSOR_IF_H
 
-#define OMAP_SENSOR_NAME_LEN		31
+#ifndef SENSOR_IF_H
+#define SENSOR_IF_H
 
-struct omap_camera_sensor {
-	unsigned int version;
-	char name[OMAP_SENSOR_NAME_LEN + 1];
+#include <linux/module.h>
+#include <media/v4l2-common.h>
 
-	void *(*init)(struct v4l2_pix_format *);
-	int (*cleanup)(void *);
+#define V4L2NAMESIZE 32
 
-	int (*power_on)(void *);
-	int (*power_off)(void *);
+enum v4l2_int_type {
+	v4l2_int_type_master = 1,
+	v4l2_int_type_slave
+};
+
+struct v4l2_int_device;
+
+struct v4l2_int_master {
+	int (*attach)(struct v4l2_int_device *master,
+		      struct v4l2_int_device *slave);
+	void (*detach)(struct v4l2_int_device *master);
+};
+
+struct v4l2_int_slave {
+	/* Don't touch master. */
+	struct v4l2_int_device *master;
+
+	char attach_to[V4L2NAMESIZE];
+
+	/*
+	 * Initialise and deinitialise the sensor device. The
+	 * initialisation is run power and clocks on.
+	 */
+	int (*dev_init)(struct v4l2_int_device *s);
+	int (*dev_exit)(struct v4l2_int_device *s);
+
+	int (*power_set)(struct v4l2_int_device *s, int on);
+
+	/*
+	 * Get the desired external clock rate for current format /
+	 * parameters.
+	 */
+	u32 (*vidioc_int_g_ext_clk)(struct v4l2_int_device *s);
+	/* Tell what we're actually getting. */
+	int (*vidioc_int_s_ext_clk)(struct v4l2_int_device *s, u32 ext_clk);
+
+	/* Ask whether the sensor driver feels it needs to be reset. */
+	int (*vidioc_int_g_needs_reset)(struct v4l2_int_device *s, void *buf);
+
+	/* Mimic V4L2 ioctls. Please keep the order same. */
+	int (*vidioc_int_g_chip_ident)(struct v4l2_int_device *s,
+				       enum v4l2_chip_ident *i);
+
+	int (*vidioc_int_reset)(struct v4l2_int_device *s);
+	int (*vidioc_int_init)(struct v4l2_int_device *s);
+
+	int (*vidioc_int_enum_fmt_cap)(struct v4l2_int_device *s,
+				       struct v4l2_fmtdesc *fmtdesc);
+	int (*vidioc_int_s_fmt_cap)(struct v4l2_int_device *s,
+				    struct v4l2_format *f);
+	int (*vidioc_int_g_fmt_cap)(struct v4l2_int_device *s,
+				    struct v4l2_format *f);
+	int (*vidioc_int_try_fmt_cap)(struct v4l2_int_device *s,
+				      struct v4l2_format *f);
+
+	int (*vidioc_int_queryctrl)(struct v4l2_int_device *s,
+				    struct v4l2_queryctrl *ctrl);
+	int (*vidioc_int_g_ctrl)(struct v4l2_int_device *s,
+				 struct v4l2_control *ctrl);
+	int (*vidioc_int_s_ctrl)(struct v4l2_int_device *s,
+				 struct v4l2_control *ctrl);
+
+	int (*vidioc_int_g_parm)(struct v4l2_int_device *s,
+				 struct v4l2_streamparm *a);
+	int (*vidioc_int_s_parm)(struct v4l2_int_device *s,
+				 struct v4l2_streamparm *a);
+};
 
-	int (*enum_pixformat)(struct v4l2_fmtdesc *, void *);
-	int (*try_format)(struct v4l2_pix_format *, void *);
+struct v4l2_int_device {
+	/* Don't touch head. */
+	struct list_head head;
 
-	unsigned long (*calc_xclk)(struct v4l2_pix_format *,
-				   struct v4l2_fract *, void *);
+	struct module *module;
 
-	int (*configure)(struct v4l2_pix_format *, unsigned long,
-			 struct v4l2_fract *, void *);
+	char name[V4L2NAMESIZE];
 
-	int (*query_control) (struct v4l2_queryctrl *, void *);
-	int (*get_control)(struct v4l2_control *, void *);
-	int (*set_control)(struct v4l2_control *, void *);
+	enum v4l2_int_type type;
+	union {
+		struct v4l2_int_master *master;
+		struct v4l2_int_slave *slave;
+	} u;
 
+	void *priv;
 };
 
-extern struct omap_camera_sensor camera_sensor_if;
+int v4l2_int_device_register(struct v4l2_int_device *d);
+void v4l2_int_device_unregister(struct v4l2_int_device *d);
 
 #endif
diff -ruN linux-omap-2.6/drivers/media/video/omap/sensor_tcm825x.c maemo_src/drivers/media/video/omap/sensor_tcm825x.c
--- linux-omap-2.6/drivers/media/video/omap/sensor_tcm825x.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/media/video/omap/sensor_tcm825x.c	2011-02-06 20:12:12.889999938 -0500
@@ -0,0 +1,1151 @@
+/*
+ * drivers/media/video/omap/sensor_tcm825x.c
+ *
+ * TCM825X Sensor driver for OMAP camera sensor interface
+ *
+ * Author: David Cohen (david.cohen@indt.org.br)
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ * This driver was based on ov9640 sensor driver from MontaVista
+ */
+
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/videodev.h>
+#include <linux/delay.h>
+#include <media/video-buf.h>
+
+#include <asm/mach-types.h>
+
+#include <asm/arch/board.h>
+#include <asm/arch/gpio.h>
+
+#include "sensor_if.h"
+#include "tcm825x.h"
+
+#define OMAP24XX_CAMERA_JAM_HACK
+
+#ifdef OMAP24XX_CAMERA_JAM_HACK
+/*
+ * We don't need to check every pixel to assume that the frame is
+ * corrupt and the sensor is jammed. CHECK_X and CHECK_Y are the
+ * number of u32s to check per line / row, plus there are two lines in
+ * the bottom of the frame.
+ */
+#define CHECK_X 8
+#define CHECK_Y 6
+/*
+ * Start checking after this many frames since resetting the sensor.
+ * Sometimes the first frame(s) is(/are) black which could trigger
+ * unwanted reset(s).
+ */
+#define JAM_CHECK_AFTER 3
+/*
+ * If the sensor is quickly brought into bright conditions from dark,
+ * it may temporarily be saturated, leaving out the normal background
+ * noise. This many saturated frames may go through before the sensor
+ * is considered jammed.
+ */
+#define SATURATED_MAX 30
+#endif
+
+#define BYTES_PER_PIXEL 2
+
+/* Try I2C accesses this many times before giving up. */
+#define I2C_TRY_COUNT 4
+
+/*
+ * The sensor has two fps modes: the lower one just gives half the fps
+ * at the same xclk than the high one.
+ */
+#define MAX_FPS 30
+#define MIN_FPS 8
+#define MAX_HALF_FPS (MAX_FPS / 2)
+#define HIGH_FPS_LOWER_LIMIT 14
+#define DEFAULT_FPS MAX_HALF_FPS
+
+static struct tcm825x_sensor {
+	const struct omap_camera_sensor_config * sensor_config;
+	struct i2c_client i2c_client;
+	struct i2c_driver *i2c_driver;
+	struct v4l2_pix_format pix;
+	struct v4l2_fract timeperframe;
+#ifdef OMAP24XX_CAMERA_JAM_HACK
+	int frames_after_reset;
+	int saturated_count;
+#endif
+} tcm825x;
+
+static struct i2c_driver tcm825x_i2c_driver = {
+	.driver = {
+		.name	= "TCM825x I2C driver",
+	},
+	.id		= I2C_DRIVERID_MISC,	/* Experimental ID */
+};
+
+/* list of image formats supported by TCM825X sensor */
+const static struct v4l2_fmtdesc tcm825x_formats[] = {
+	{
+		.description = "YUYV (YUV 4:2:2), packed",
+		.pixelformat = V4L2_PIX_FMT_UYVY,
+	}, {
+		/* Note:  V4L2 defines RGB565 as:
+		 *
+		 *      Byte 0                    Byte 1
+		 *      g2 g1 g0 r4 r3 r2 r1 r0   b4 b3 b2 b1 b0 g5 g4 g3
+		 *
+		 * We interpret RGB565 as:
+		 *
+		 *      Byte 0                    Byte 1
+		 *      g2 g1 g0 b4 b3 b2 b1 b0   r4 r3 r2 r1 r0 g5 g4 g3
+		 */
+		.description = "RGB565, le",
+		.pixelformat = V4L2_PIX_FMT_RGB565,
+	},
+};
+
+#define TCM825X_NUM_CAPTURE_FORMATS	ARRAY_SIZE(tcm825x_formats)
+#define NUM_OVERLAY_FORMATS		2
+
+/* register initialization tables for TCM825X */
+
+/* TCM825X register configuration for all combinations of pixel format and
+ * image size
+ */
+const static struct tcm825x_reg subqcif	=	{ 0x20, TCM825X_PICSIZ };
+const static struct tcm825x_reg qcif	=	{ 0x18, TCM825X_PICSIZ };
+const static struct tcm825x_reg cif	=	{ 0x14, TCM825X_PICSIZ };
+const static struct tcm825x_reg qqvga	=	{ 0x0c, TCM825X_PICSIZ };
+const static struct tcm825x_reg qvga	=	{ 0x04, TCM825X_PICSIZ };
+const static struct tcm825x_reg vga	=	{ 0x00, TCM825X_PICSIZ };
+
+const static struct tcm825x_reg yuv422	=	{ 0x00, TCM825X_PICFMT };
+const static struct tcm825x_reg rgb565	=	{ 0x02, TCM825X_PICFMT };
+
+/* Our own specific controls */
+#define V4L2_CID_ALC				V4L2_CID_PRIVATE_BASE
+#define V4L2_CID_H_EDGE_EN			V4L2_CID_PRIVATE_BASE + 1
+#define V4L2_CID_V_EDGE_EN			V4L2_CID_PRIVATE_BASE + 2
+#define V4L2_CID_LENS				V4L2_CID_PRIVATE_BASE + 3
+#define V4L2_CID_MAX_EXPOSURE_TIME		V4L2_CID_PRIVATE_BASE + 4
+#define V4L2_CID_LAST_PRIV			V4L2_CID_MAX_EXPOSURE_TIME
+
+/*  Video controls  */
+static struct vcontrol {
+	struct v4l2_queryctrl qc;
+	u16 reg;
+	u16 start_bit;
+} video_control[] = {
+	{
+		{
+			.id = V4L2_CID_GAIN,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Gain",
+			.minimum = 0,
+			.maximum = 63,
+			.step = 1,
+		},
+		.reg = TCM825X_AG,
+		.start_bit = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_RED_BALANCE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Red Balance",
+			.minimum = 0,
+			.maximum = 255,
+			.step = 1,
+		},
+		.reg = TCM825X_MRG,
+		.start_bit = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_BLUE_BALANCE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Blue Balance",
+			.minimum = 0,
+			.maximum = 255,
+			.step = 1,
+		},
+		.reg = TCM825X_MBG,
+		.start_bit = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_AUTO_WHITE_BALANCE,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "Auto White Balance",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 0,
+		},
+		.reg = TCM825X_AWBSW,
+		.start_bit = 7,
+	},
+	{
+		{
+			.id = V4L2_CID_EXPOSURE,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Exposure Time",
+			.minimum = 0,
+			.maximum = 0x1fff,
+			.step = 1,
+		},
+		.reg = TCM825X_ESRSPD_U,
+		.start_bit = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_HFLIP,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "Mirror Image",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 0,
+		},
+		.reg = TCM825X_H_INV,
+		.start_bit = 6,
+	},
+	{
+		{
+			.id = V4L2_CID_VFLIP,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "Vertical Flip",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 0,
+		},
+		.reg = TCM825X_V_INV,
+		.start_bit = 7,
+	},
+	/* Private controls */
+	{
+		{
+			.id = V4L2_CID_ALC,
+			.type = V4L2_CTRL_TYPE_BOOLEAN,
+			.name = "Auto Luminance Control",
+			.minimum = 0,
+			.maximum = 1,
+			.step = 0,
+		},
+		.reg = TCM825X_ALCSW,
+		.start_bit = 7,
+	},
+	{
+		{
+			.id = V4L2_CID_H_EDGE_EN,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Horizontal Edge Enhancement",
+			.minimum = 0,
+			.maximum = 0xff,
+			.step = 1,
+		},
+		.reg = TCM825X_HDTG,
+		.start_bit = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_V_EDGE_EN,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Vertical Edge Enhancement",
+			.minimum = 0,
+			.maximum = 0xff,
+			.step = 1,
+		},
+		.reg = TCM825X_VDTG,
+		.start_bit = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_LENS,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Lens Shading Compensation",
+			.minimum = 0,
+			.maximum = 0x3f,
+			.step = 1,
+		},
+		.reg = TCM825X_LENS,
+		.start_bit = 0,
+	},
+	{
+		{
+			.id = V4L2_CID_MAX_EXPOSURE_TIME,
+			.type = V4L2_CTRL_TYPE_INTEGER,
+			.name = "Maximum Exposure Time",
+			.minimum = 0,
+			.maximum = 0x3,
+			.step = 1,
+		},
+		.reg = TCM825X_ESRLIM,
+		.start_bit = 5,
+	},
+};
+
+
+const static struct tcm825x_reg *tcm825x_siz_reg[NUM_IMAGE_SIZES] =
+{ &subqcif, &qqvga, &qcif, &qvga, &cif, &vga };
+
+const static struct tcm825x_reg *tcm825x_fmt_reg[NUM_PIXEL_FORMATS] =
+{ &yuv422, &rgb565 };
+
+/*
+ * Read a value from a register in an TCM825X sensor device.  The value is
+ * returned in 'val'.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int tcm825x_read_reg(struct i2c_client *client, int reg)
+{
+	int err;
+	struct i2c_msg msg[2];
+	u8 reg_buf, data_buf = 0;
+	int again = I2C_TRY_COUNT;
+
+	if (!client->adapter)
+		return -ENODEV;
+
+	do {
+		msg[0].addr = client->addr;
+		msg[0].flags = 0;
+		msg[0].len = 1;
+		msg[0].buf = &reg_buf;
+		msg[1].addr = client->addr;
+		msg[1].flags = I2C_M_RD;
+		msg[1].len = 1;
+		msg[1].buf = &data_buf;
+
+		reg_buf = reg;
+
+		err = i2c_transfer(client->adapter, msg, 2);
+		if (err >= 0)
+			return data_buf;
+
+		printk(KERN_ERR "%s: trying again (%d)\n", __func__, err);
+		msleep(1);
+	} while (--again > 0);
+
+	return err;
+}
+
+/* Write a value to a register in an TCM825X sensor device.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int tcm825x_write_reg(struct i2c_client *client, u8 reg, u8 val)
+{
+	int err;
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+	int again = I2C_TRY_COUNT;
+
+	if (!client->adapter)
+		return -ENODEV;
+
+	do {
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = 2;
+		msg->buf = data;
+		data[0] = reg;
+		data[1] = val;
+		err = i2c_transfer(client->adapter, msg, 1);
+		if (err >= 0)
+			return 0;
+
+		printk(KERN_ERR "%s: trying again (%d)\n", __func__, err);
+		msleep(1);
+	} while (--again > 0);
+
+	return err;
+}
+
+static int __tcm825x_write_reg_mask(struct i2c_client *client,
+				    u8 reg, u8 val, u8 mask)
+{
+	int rc;
+
+	/* need to do read - modify - write */
+	rc = tcm825x_read_reg(client, reg);
+	if (rc < 0)
+		return rc;
+
+	rc &= (~mask);	/* Clear the masked bits */
+	val &= mask;	/* Enforce mask on value */
+	val |= rc;
+
+	/* write the new value to the register */
+	if ((rc = tcm825x_write_reg(client, reg, val)))
+		return rc;
+
+	return 0;
+}
+
+#define tcm825x_write_reg_mask(client, regmask, val)			\
+	__tcm825x_write_reg_mask(client, TCM825X_ADDR((regmask)), val,	\
+				 TCM825X_MASK((regmask)))
+
+
+/* Initialize a list of TCM825X registers.
+ * The list of registers is terminated by the pair of values
+ * { TCM825X_REG_TERM, TCM825X_VAL_TERM }.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int tcm825x_write_default_regs(struct i2c_client *client,
+				      const struct tcm825x_reg reglist[])
+{
+	int err;
+	const struct tcm825x_reg *next = reglist;
+
+	while (!((next->reg == TCM825X_REG_TERM)
+		 && (next->val == TCM825X_VAL_TERM))) {
+		err = tcm825x_write_reg(client, next->reg, next->val);
+		udelay(100);
+		if (err) {
+			printk(KERN_ERR "%s(): Register writing failed\n",
+			       __FUNCTION__);
+			return err;
+		}
+		next++;
+	}
+
+	return 0;
+}
+
+/* Matches the control ID and returns the vcontrol pointer */
+static struct vcontrol * find_vctrl(int id)
+{
+	int i;
+
+	if (id < V4L2_CID_BASE)
+		return NULL;
+
+	for (i = 0; i < ARRAY_SIZE(video_control); i++)
+		if (video_control[i].qc.id == id)
+			return &video_control[i];
+
+	return NULL;
+}
+
+/* Configure the TCM825X for a specified image size, pixel format, and frame
+ * period.  xclk is the frequency (in Hz) of the xclk input to the TCM825X.
+ * fper is the frame period (in seconds) expressed as a fraction.
+ * Returns zero if successful, or non-zero otherwise.
+ * The actual frame period is returned in fper.
+ */
+static int tcm825x_configure(struct v4l2_int_device *s,
+			     enum image_size isize, u32 pixelformat,
+			     u32 xclk, struct v4l2_fract *fper)
+{
+	int err;
+	u32 tgt_fps;
+	u8 val;
+	enum pixel_format pfmt;
+	struct tcm825x_sensor *sensor = s->priv;
+
+	/* common register initialization */
+	err = tcm825x_write_default_regs(
+		&sensor->i2c_client, sensor->sensor_config->default_regs());
+	if (err)
+		return err;
+
+	/* configure image size */
+	val = tcm825x_siz_reg[isize]->val;
+	printk(KERN_DEBUG "%s(): configuring Image Size %d\n",
+	       __FUNCTION__, isize);
+	err = tcm825x_write_reg_mask(&sensor->i2c_client,
+				     tcm825x_siz_reg[isize]->reg, val);
+	if (err)
+		return err;
+
+	/* configure pixel format */
+	switch (pixelformat) {
+	default:
+	case V4L2_PIX_FMT_RGB565:
+		pfmt = RGB565;
+		break;
+	case V4L2_PIX_FMT_UYVY:
+		pfmt = YUV422;
+		break;
+	}
+
+	val = tcm825x_fmt_reg[pfmt]->val;
+	printk(KERN_DEBUG "%s(): configuring Pixel Format %d\n",
+	       __FUNCTION__, pfmt);
+	err = tcm825x_write_reg_mask(&sensor->i2c_client,
+				     tcm825x_fmt_reg[pfmt]->reg, val);
+	if (err)
+		return err;
+
+	/* for frame rate < 15, the FPS reg (addr 0x02, bit 7) should be set */
+	tgt_fps = fper->denominator / fper->numerator;
+	if (tgt_fps <= HIGH_FPS_LOWER_LIMIT) {
+		val = tcm825x_read_reg(&sensor->i2c_client, 0x02);
+		val |= 0x80;
+		tcm825x_write_reg(&sensor->i2c_client, 0x02, val);
+	}
+
+	return 0;
+}
+
+static int tcm825x_detect(struct tcm825x_sensor *sensor)
+{
+	int r;
+
+	r = tcm825x_read_reg(&sensor->i2c_client, 0x01);
+	if (r < 0)
+		return r;
+	if (r == 0) {
+		dev_err(&sensor->i2c_client.dev, "device not detected\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+
+/* This function registers an I2C client via i2c_attach_client() for an TCM825X
+ * sensor device.  If 'probe' is non-zero, then the I2C client is only
+ * registered if the device can be detected.  If 'probe' is zero, then no
+ * device detection is attempted and the I2C client is always registered.
+ * Returns zero if an I2C client is successfully registered, or non-zero
+ * otherwise.
+ */
+static int tcm825x_i2c_attach_client(struct i2c_adapter *adap,
+				     int addr, int probe)
+{
+	struct tcm825x_sensor *sensor = &tcm825x;
+	struct i2c_client *client = &sensor->i2c_client;
+	int err;
+
+	if (client->adapter)
+		return -EBUSY;	/* our client is already attached */
+
+	client->addr = addr;
+	client->flags = 0;
+	client->driver = sensor->i2c_driver;
+	client->adapter = adap;
+	strlcpy(client->name, "TCM825x I2C driver", sizeof(client->name));
+
+	err = i2c_attach_client(client);
+	if (err) {
+		client->adapter = NULL;
+		return err;
+	}
+
+	if (probe) {
+		err = tcm825x_detect(sensor);
+		if (err < 0) {
+			i2c_detach_client(client);
+			client->adapter = NULL;
+			return err;
+		}
+	}
+	return 0;
+}
+
+/* This function is called by i2c_del_adapter() and i2c_del_driver()
+ * if the adapter or driver with which this I2C client is associated is
+ * removed.  This function unregisters the client via i2c_detach_client().
+ * Returns zero if the client is successfully detached, or non-zero
+ * otherwise.
+ */
+static int tcm825x_i2c_detach_client(struct i2c_client *client)
+{
+	int err;
+
+	if (!client->adapter)
+		return -ENODEV;	/* our client isn't attached */
+
+	err = i2c_detach_client(client);
+	client->adapter = NULL;
+
+	return err;
+}
+
+/* This function will be called for each registered I2C bus adapter when our
+ * I2C driver is registered via i2c_add_driver().  It will also be called
+ * whenever a new I2C adapter is registered after our I2C driver is registered.
+ * This function probes the specified I2C bus adapter to determine if an
+ * TCM825X sensor device is present.  If a device is detected, an I2C client
+ * is registered for it via tcm825x_i2c_attach_client().  Note that we can't
+ * use the standard i2c_probe() function to look for the sensor because the
+ * OMAP I2C controller doesn't support probing.
+ * Returns zero if an TCM825X device is detected and an I2C client successfully
+ * registered for it, or non-zero otherwise.
+ */
+static int tcm825x_i2c_probe_adapter(struct i2c_adapter *adap)
+{
+	return tcm825x_i2c_attach_client(adap, TCM825X_I2C_ADDR, 1);
+}
+
+/* Find the best match for a requested image capture size.  The best match
+ * is chosen as the nearest match that has the same number or fewer pixels
+ * as the requested size, or the smallest image size if the requested size
+ * has fewer pixels than the smallest image.
+ */
+static enum image_size tcm825x_find_size(unsigned int width,
+					 unsigned int height)
+{
+	enum image_size isize;
+	unsigned long pixels = width * height;
+
+	for (isize = subQCIF; isize < VGA; isize++) {
+		if (tcm825x_sizes[isize + 1].height
+		    * tcm825x_sizes[isize + 1].width > pixels) {
+			printk(KERN_DEBUG "%s(): size %d\n",
+			       __FUNCTION__, isize);
+			return isize;
+		}
+	}
+
+	printk(KERN_DEBUG "%s(): format default VGA\n", __FUNCTION__);
+	return VGA;
+}
+
+/* Given the image capture format in pix, the nominal frame period in
+ * timeperframe, calculate the required xclk frequency.
+ *
+ * TCM825X input frequency characteristics are:
+ *     Minimum 11.9 MHz, Typical 24.57 MHz and maximum 25/27 MHz
+ */
+#define XCLK_MIN 11900000
+#define XCLK_MAX 25000000
+
+static u32 vidioc_int_g_ext_clk(struct v4l2_int_device *s)
+{
+	struct tcm825x_sensor *sensor = s->priv;
+	struct v4l2_fract *timeperframe = &sensor->timeperframe;
+	u32 tgt_xclk;	/* target xclk */
+	u32 tgt_fps;	/* target frames per secound */
+
+	tgt_fps = timeperframe->denominator / timeperframe->numerator;
+
+	tgt_xclk = (tgt_fps <= HIGH_FPS_LOWER_LIMIT) ?
+		(2457 * tgt_fps) / MAX_HALF_FPS :
+		(2457 * tgt_fps) / MAX_FPS;
+	tgt_xclk *= 10000;
+
+	tgt_xclk = min(tgt_xclk, (u32)XCLK_MAX);
+	tgt_xclk = max(tgt_xclk, (u32)XCLK_MIN);
+
+	return tgt_xclk;
+}
+
+static int vidioc_int_s_ext_clk(struct v4l2_int_device *s, u32 xclk)
+{
+	if (xclk > XCLK_MAX || xclk < XCLK_MIN)
+		return -EINVAL;
+	return 0;
+}
+
+/* following are sensor interface functions implemented by
+ * TCM825X sensor driver.
+ */
+static int vidioc_int_queryctrl(struct v4l2_int_device *s,
+				struct v4l2_queryctrl *qc)
+{
+	struct vcontrol * control;
+
+	control = find_vctrl(qc->id);
+
+	if (control == NULL)
+		return -EINVAL;
+
+	*qc = control->qc;
+
+	return 0;
+}
+
+static int vidioc_int_g_ctrl(struct v4l2_int_device *s,
+			     struct v4l2_control *vc)
+{
+	struct tcm825x_sensor *sensor = s->priv;
+	struct i2c_client *client = &sensor->i2c_client;
+	int val, r;
+	struct vcontrol *lvc;
+
+	/* exposure time is special, spread accross 2 registers */
+	if (vc->id == V4L2_CID_EXPOSURE) {
+		int val_lower, val_upper;
+
+		val_upper = tcm825x_read_reg(client,
+					     TCM825X_ADDR(TCM825X_ESRSPD_U));
+		if (val_upper < 0)
+			return val_upper;
+		val_lower = tcm825x_read_reg(client,
+					     TCM825X_ADDR(TCM825X_ESRSPD_L));
+		if (val_lower < 0)
+			return val_lower;
+
+		vc->value = ((val_upper & 0x1f) << 8) | (val_lower);
+		return 0;
+	}
+
+	lvc = find_vctrl(vc->id);
+	if (lvc == NULL)
+		return -EINVAL;
+
+	r = tcm825x_read_reg(client, TCM825X_ADDR(lvc->reg));
+	if (r < 0)
+		return r;
+	val = r & TCM825X_MASK(lvc->reg);
+	val >>= lvc->start_bit;
+
+	if (val < 0)
+		return val;
+
+	if (vc->id == V4L2_CID_HFLIP || vc->id == V4L2_CID_VFLIP)
+		val ^= sensor->sensor_config->is_upside_down();
+
+	vc->value = val;
+	return 0;
+}
+
+static int vidioc_int_s_ctrl(struct v4l2_int_device *s,
+			     struct v4l2_control *vc)
+{
+	struct tcm825x_sensor *sensor = s->priv;
+	struct i2c_client *client = &sensor->i2c_client;
+	struct vcontrol *lvc;
+	int val = vc->value;
+
+	/* exposure time is special, spread accross 2 registers */
+	if (vc->id == V4L2_CID_EXPOSURE) {
+		int val_lower, val_upper;
+		val_lower = val & TCM825X_MASK(TCM825X_ESRSPD_L);
+		val_upper = (val >> 8) & TCM825X_MASK(TCM825X_ESRSPD_U);
+
+		if (tcm825x_write_reg_mask(client,
+					   TCM825X_ESRSPD_U, val_upper))
+			return -EIO;
+
+		if (tcm825x_write_reg_mask(client,
+					   TCM825X_ESRSPD_L, val_lower))
+			return -EIO;
+
+		return 0;
+	}
+
+	lvc = find_vctrl(vc->id);
+	if (lvc == NULL)
+		return -EINVAL;
+
+	if (vc->id == V4L2_CID_HFLIP || vc->id == V4L2_CID_VFLIP)
+		val ^= sensor->sensor_config->is_upside_down();
+
+	val = val << lvc->start_bit;
+	if (tcm825x_write_reg_mask(client, lvc->reg, val))
+		return -EIO;
+
+	return 0;
+}
+
+/* Implement the VIDIOC_ENUM_FMT ioctl for the CAPTURE buffer type.
+ */
+static int vidioc_int_enum_fmt_cap(struct v4l2_int_device *s,
+				   struct v4l2_fmtdesc *fmt)
+{
+	int index = fmt->index;
+
+	switch (fmt->type) {
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+		if (index >= TCM825X_NUM_CAPTURE_FORMATS)
+			return -EINVAL;
+		break;
+
+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
+		if (index >= NUM_OVERLAY_FORMATS)
+			return -EINVAL;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	fmt->flags = tcm825x_formats[index].flags;
+	strlcpy(fmt->description, tcm825x_formats[index].description,
+		sizeof(fmt->description));
+	fmt->pixelformat = tcm825x_formats[index].pixelformat;
+
+	return 0;
+}
+
+/* Implement the VIDIOC_TRY_FMT ioctl for the CAPTURE buffer type.  This
+ * ioctl is used to negotiate the image capture size and pixel format
+ * without actually making it take effect.
+ */
+static int vidioc_int_try_fmt_cap(struct v4l2_int_device *s,
+				  struct v4l2_format *f)
+{
+	enum image_size isize;
+	int ifmt;
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+
+	isize = tcm825x_find_size(pix->width, pix->height);
+	printk(KERN_DEBUG "%s(): isize = %d num_capture = %d\n",
+	       __FUNCTION__, isize, TCM825X_NUM_CAPTURE_FORMATS);
+
+	pix->width = tcm825x_sizes[isize].width;
+	pix->height = tcm825x_sizes[isize].height;
+
+	for (ifmt = 0; ifmt < TCM825X_NUM_CAPTURE_FORMATS; ifmt++)
+		if (pix->pixelformat == tcm825x_formats[ifmt].pixelformat)
+			break;
+
+	if (ifmt == TCM825X_NUM_CAPTURE_FORMATS)
+		ifmt = 0;	/* Default = YUV 4:2:2 */
+
+	pix->pixelformat = tcm825x_formats[ifmt].pixelformat;
+	pix->field = V4L2_FIELD_NONE;
+	pix->bytesperline = pix->width * BYTES_PER_PIXEL;
+	pix->sizeimage = pix->bytesperline * pix->height;
+	pix->priv = 0;
+	printk(KERN_DEBUG "%s(): format = 0x%08x\n",
+	       __FUNCTION__, pix->pixelformat);
+
+	switch (pix->pixelformat) {
+	case V4L2_PIX_FMT_UYVY:
+	default:
+		pix->colorspace = V4L2_COLORSPACE_JPEG;
+		break;
+	case V4L2_PIX_FMT_RGB565:
+		pix->colorspace = V4L2_COLORSPACE_SRGB;
+		break;
+	}
+
+	return 0;
+}
+
+static int vidioc_int_s_fmt_cap(struct v4l2_int_device *s,
+				struct v4l2_format *f)
+{
+	struct tcm825x_sensor *sensor = s->priv;
+	struct v4l2_pix_format *pix = &f->fmt.pix;
+	int rval;
+
+	if ((rval = vidioc_int_try_fmt_cap(s, f)))
+		return rval;
+
+	rval = tcm825x_configure(s,
+				 tcm825x_find_size(pix->width, pix->height),
+				 pix->pixelformat, vidioc_int_g_ext_clk(s),
+				 &sensor->timeperframe);
+
+	sensor->pix = *pix;
+
+	return rval;
+}
+
+static int vidioc_int_g_fmt_cap(struct v4l2_int_device *s,
+				struct v4l2_format *f)
+{
+	struct tcm825x_sensor *sensor = s->priv;
+
+	f->fmt.pix = sensor->pix;
+
+	return 0;
+}
+
+static int vidioc_int_g_parm(struct v4l2_int_device *s,
+			     struct v4l2_streamparm *a)
+{
+	struct tcm825x_sensor *sensor = s->priv;
+	struct v4l2_captureparm *cparm = &a->parm.capture;
+
+	if (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	memset(a, 0, sizeof(*a));
+	a->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+
+	cparm->capability = V4L2_CAP_TIMEPERFRAME;
+	cparm->timeperframe = sensor->timeperframe;
+
+	return 0;
+}
+
+/* Given a capture format in pix, the frame period in timeperframe, and
+ * the xclk frequency, set the capture format of the TCM825X sensor.
+ * The actual frame period will be returned in timeperframe.
+ */
+static int vidioc_int_s_parm(struct v4l2_int_device *s,
+			     struct v4l2_streamparm *a)
+{
+	struct tcm825x_sensor *sensor = s->priv;
+	struct v4l2_pix_format *pix = &sensor->pix;
+	struct v4l2_fract *timeperframe = &a->parm.capture.timeperframe;
+	u32 tgt_fps;	/* target frames per secound */
+	int rval;
+
+	if (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	if ((timeperframe->numerator == 0)
+	    || (timeperframe->denominator == 0)) {
+		timeperframe->denominator = DEFAULT_FPS;
+		timeperframe->numerator = 1;
+	}
+
+	tgt_fps = timeperframe->denominator / timeperframe->numerator;
+
+	if (tgt_fps > MAX_FPS) {
+		timeperframe->denominator = MAX_FPS;
+		timeperframe->numerator = 1;
+	} else if (tgt_fps < MIN_FPS) {
+		timeperframe->denominator = MIN_FPS;
+		timeperframe->numerator = 1;
+	}
+
+	rval = tcm825x_configure(s,
+				 tcm825x_find_size(pix->width, pix->height),
+				 pix->pixelformat, vidioc_int_g_ext_clk(s),
+				 timeperframe);
+
+	sensor->timeperframe = *timeperframe;
+
+	return rval;
+}
+
+static int power_set(struct v4l2_int_device *s, int on)
+{
+	struct tcm825x_sensor *sensor = &tcm825x;
+
+#ifdef OMAP24XX_CAMERA_JAM_HACK
+	if (on) {
+		sensor->saturated_count = 0;
+		sensor->frames_after_reset = 0;
+	}
+#endif
+	return sensor->sensor_config->power_set(on);
+}
+
+#ifdef OMAP24XX_CAMERA_JAM_HACK
+/*
+ * Check for jammed sensor, in which case all horizontal lines are
+ * equal. Handle also case where sensor could be saturated awhile in
+ * case of rapid increase of brightness.
+ */
+static int vidioc_int_g_needs_reset(struct v4l2_int_device *s, void *buf)
+{
+	int i, j;
+	uint32_t xor, xor2;
+	uint32_t offset;
+	struct tcm825x_sensor *sensor = s->priv;
+	struct v4l2_pix_format *pix = &sensor->pix;
+	uint32_t dx_offset;
+	uint32_t saturated_pattern;
+	int is_saturated = 1;
+
+	switch (pix->pixelformat) {
+	default:
+	case V4L2_PIX_FMT_RGB565:
+		saturated_pattern = 0xffffffff; /* guess */
+		break;
+	case V4L2_PIX_FMT_UYVY:
+		saturated_pattern = 0xe080e080;
+		break;
+	}
+
+	/*
+	 * This won't work for height under 2 at all.
+	 */
+	if (pix->height < 2)
+		return 0;
+	/*
+	 * Check that there is enough image data.
+	 */
+	if (pix->width * BYTES_PER_PIXEL < sizeof(uint32_t))
+		return 0;
+	/*
+	 * Don't check for jamming immediately. Sometimes frames
+	 * immediately after reset are black.
+	 */
+	if (sensor->frames_after_reset < JAM_CHECK_AFTER) {
+		sensor->frames_after_reset++;
+		return 0;
+	}
+	
+	dx_offset = ((pix->width - sizeof(uint32_t) / BYTES_PER_PIXEL)
+		     * BYTES_PER_PIXEL) / (CHECK_X - 1);
+	dx_offset = dx_offset - dx_offset % BYTES_PER_PIXEL;
+	/*
+	 * Check two lines in the bottom first. They're unlikely to be
+	 * saturated and quick to check.
+	 */
+	offset = (pix->height - 2) * pix->bytesperline;
+	xor = xor2 = 0;
+	for (j = 0; j < CHECK_X; j++) {
+		uint32_t *val = buf + offset;
+		uint32_t *val2 = buf + offset + pix->bytesperline;
+		xor ^= *val;
+		if (*val != saturated_pattern)
+			is_saturated = 0;
+		xor2 ^= *val2;
+		if (xor2 != xor) {
+			sensor->saturated_count = 0;
+			return 0;
+		}
+		offset += dx_offset;
+	}
+	/*
+	 * Check the rest of the picture.
+	 */
+	offset = 0;
+	for (i = 0; i < CHECK_Y; i++) {
+		uint32_t offset2 = offset;
+		xor2 = 0;
+		for (j = 0; j < CHECK_X; j++) {
+			uint32_t *val = buf + offset2;
+			xor2 ^= *val;
+			offset2 += dx_offset;
+		}
+		if (xor2 != xor) {
+			sensor->saturated_count = 0;
+			return 0;
+		}
+		offset += pix->bytesperline * ((pix->height - 2) / CHECK_Y);
+	}
+
+	if (is_saturated && sensor->saturated_count++ < SATURATED_MAX)
+		return 0;
+	
+	return -EIO;
+}
+#endif
+
+static int vidioc_int_reset(struct v4l2_int_device *s)
+{
+	return -EBUSY;
+}
+
+static int vidioc_int_init(struct v4l2_int_device *s)
+{
+	struct tcm825x_sensor *sensor = s->priv;
+	struct v4l2_pix_format *pix = &sensor->pix;
+
+	return tcm825x_configure(s,
+				 tcm825x_find_size(pix->width, pix->height),
+				 pix->pixelformat, vidioc_int_g_ext_clk(s),
+				 &sensor->timeperframe);
+}
+
+/* Prepare for the driver to exit.
+ * Balances tcm825xsensor_init().
+ * This function must de-initialize the sensor and its associated data
+ * structures.
+ */
+static int dev_exit(struct v4l2_int_device *s)
+{
+	struct tcm825x_sensor *sensor = s->priv;
+
+	i2c_del_driver(sensor->i2c_driver);
+
+	return 0;
+}
+
+
+/* Initialize the TCM825X sensor.
+ * This routine allocates and initializes the data structure for the sensor,
+ * powers up the sensor, registers the I2C driver, and sets a default image
+ * capture format in pix.  The capture format is not actually programmed
+ * into the TCM825X sensor by this routine.
+ * This function must return a non-NULL value to indicate that
+ * initialization is successful.
+ */
+static int dev_init(struct v4l2_int_device *s)
+{
+	struct tcm825x_sensor *sensor = s->priv;
+
+	sensor->i2c_driver->attach_adapter = tcm825x_i2c_probe_adapter;
+	sensor->i2c_driver->detach_client = tcm825x_i2c_detach_client;
+
+	if (i2c_add_driver(sensor->i2c_driver)) {
+		printk(KERN_WARNING
+		       "%s(): Failed to register TCM825x I2C client\n",
+		       __FUNCTION__);
+		goto err_add;
+	}
+
+	if (!sensor->i2c_client.adapter) {
+		printk(KERN_WARNING
+		       "%s(): Failed to detect TCM825x sensor chip\n",
+		       __FUNCTION__);
+		goto err_detect;
+	}
+
+	return 0;
+
+err_detect:
+	i2c_del_driver(sensor->i2c_driver);
+err_add:
+	return -EBUSY;
+}
+
+static struct v4l2_int_slave tcm825x_slave = {
+	.dev_init = dev_init,
+	.dev_exit = dev_exit,
+	.power_set = power_set,
+	.vidioc_int_g_ext_clk = vidioc_int_g_ext_clk,
+	.vidioc_int_s_ext_clk = vidioc_int_s_ext_clk,
+#ifdef OMAP24XX_CAMERA_JAM_HACK
+	.vidioc_int_g_needs_reset = vidioc_int_g_needs_reset,
+#endif
+	.vidioc_int_reset = vidioc_int_reset,
+	.vidioc_int_init = vidioc_int_init,
+	.vidioc_int_enum_fmt_cap = vidioc_int_enum_fmt_cap,
+	.vidioc_int_try_fmt_cap = vidioc_int_try_fmt_cap,
+	.vidioc_int_g_fmt_cap = vidioc_int_g_fmt_cap,
+	.vidioc_int_s_fmt_cap = vidioc_int_s_fmt_cap,
+	.vidioc_int_g_parm = vidioc_int_g_parm,
+	.vidioc_int_s_parm = vidioc_int_s_parm,
+	.vidioc_int_queryctrl = vidioc_int_queryctrl,
+	.vidioc_int_g_ctrl = vidioc_int_g_ctrl,
+	.vidioc_int_s_ctrl = vidioc_int_s_ctrl,
+};
+
+static struct v4l2_int_device tcm825x_if = {
+	.module = THIS_MODULE,
+	.name = "TCM825x",
+	.type = v4l2_int_type_slave,
+	.u = { .slave = &tcm825x_slave },
+};
+
+int __init sensor_tcm825x_init(void)
+{
+	struct tcm825x_sensor *sensor = &tcm825x;
+
+	sensor->sensor_config =
+		omap_get_config(OMAP_TAG_CAMERA_SENSOR,
+				struct omap_camera_sensor_config);
+
+	if (sensor->sensor_config == NULL
+	    && !sensor->sensor_config->is_okay())
+		return -ENODEV;
+
+	sensor->i2c_driver = &tcm825x_i2c_driver;
+	tcm825x_if.priv = sensor;
+
+	/* Make the default capture format QVGA RGB565 */
+	sensor->pix.width = tcm825x_sizes[QVGA].width;
+	sensor->pix.height = tcm825x_sizes[QVGA].height;
+	sensor->pix.pixelformat = V4L2_PIX_FMT_RGB565;
+
+	sensor->timeperframe.denominator = DEFAULT_FPS;
+	sensor->timeperframe.numerator = 1;
+
+	return v4l2_int_device_register(&tcm825x_if);
+}
+
+void __exit sensor_tcm825x_cleanup(void)
+{
+	v4l2_int_device_unregister(&tcm825x_if);
+}
+
+/*
+ * FIXME: Menelaus isn't ready at module_init stage, so use
+ * late_initcall for now.
+ */
+late_initcall(sensor_tcm825x_init);
+module_exit(sensor_tcm825x_cleanup);
diff -ruN linux-omap-2.6/drivers/media/video/omap/tcm825x.h maemo_src/drivers/media/video/omap/tcm825x.h
--- linux-omap-2.6/drivers/media/video/omap/tcm825x.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/media/video/omap/tcm825x.h	2007-10-02 03:09:31.000000000 -0400
@@ -0,0 +1,182 @@
+/*
+ * drivers/media/video/omap/tcm825x.h
+ *
+ * Register definitions for the TCM825X CameraChip.
+ *
+ * Author: David Cohen (david.cohen@indt.org.br)
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ *
+ * This file was based on ov9640.h from MontaVista
+ */
+
+#ifndef TCM825X_H
+#define TCM825X_H
+
+#define TCM825X_MASK(x)  x & 0x00ff
+#define TCM825X_ADDR(x) (x & 0xff00) >> 8
+
+/* The TCM825X I2C sensor chip has a fixed slave address of 0x3d. */
+#define TCM825X_I2C_ADDR	0x3d
+
+/* define register offsets for the TCM825X sensor chip
+ * OFFSET(8 bits) + MASK(8 bits)
+ * MASK bit 4 and 3 are used when the register uses more than one address
+ */
+#define TCM825X_FPS		0x0280
+#define TCM825X_ACF		0x0240
+#define TCM825X_DOUTBUF		0x020C
+#define TCM825X_DCLKP		0x0202
+#define TCM825X_ACFDET		0x0201
+#define TCM825X_DOUTSW		0x0380
+#define TCM825X_DATAHZ		0x0340
+#define TCM825X_PICSIZ		0x033c
+#define TCM825X_PICFMT		0x0302
+#define TCM825X_V_INV		0x0480
+#define TCM825X_H_INV		0x0440
+#define TCM825X_ESRLSW		0x0430
+#define TCM825X_V_LENGTH	0x040F
+#define TCM825X_ALCSW		0x0580
+#define TCM825X_ESRLIM		0x0560
+#define TCM825X_ESRSPD_U        0x051F
+#define TCM825X_ESRSPD_L        0x06FF
+#define TCM825X_AG		0x07FF
+#define TCM825X_ESRSPD2         0x06FF
+#define TCM825X_ALCMODE         0x0830
+#define TCM825X_ALCH            0x080F
+#define TCM825X_ALCL            0x09FF
+#define TCM825X_AWBSW           0x0A80
+#define TCM825X_MRG             0x0BFF
+#define TCM825X_MBG             0x0CFF
+#define TCM825X_GAMSW           0x0D80
+#define TCM825X_HDTG            0x0EFF
+#define TCM825X_VDTG            0x0FFF
+#define TCM825X_HDTCORE         0x10F0
+#define TCM825X_VDTCORE         0x100F
+#define TCM825X_CONT            0x11FF
+#define TCM825X_BRIGHT          0x12FF
+#define TCM825X_VHUE            0x137F
+#define TCM825X_UHUE            0x147F
+#define TCM825X_VGAIN           0x153F
+#define TCM825X_UGAIN           0x163F
+#define TCM825X_UVCORE          0x170F
+#define TCM825X_SATU            0x187F
+#define TCM825X_MHMODE          0x1980
+#define TCM825X_MHLPFSEL        0x1940
+#define TCM825X_YMODE           0x1930
+#define TCM825X_MIXHG           0x1907
+#define TCM825X_LENS            0x1A3F
+#define TCM825X_AGLIM           0x1BE0
+#define TCM825X_LENSRPOL        0x1B10
+#define TCM825X_LENSRGAIN       0x1B0F
+#define TCM825X_ES100S          0x1CFF
+#define TCM825X_ES120S          0x1DFF
+#define TCM825X_DMASK           0x1EC0
+#define TCM825X_CODESW          0x1E20
+#define TCM825X_CODESEL         0x1E10
+#define TCM825X_TESPIC          0x1E04
+#define TCM825X_PICSEL          0x1E03
+#define TCM825X_HNUM            0x20FF
+#define TCM825X_VOUTPH          0x287F
+#define TCM825X_ESROUT          0x327F
+#define TCM825X_ESROUT2         0x33FF
+#define TCM825X_AGOUT           0x34FF
+#define TCM825X_DGOUT           0x353F
+#define TCM825X_AGSLOW1         0x39C0
+#define TCM825X_FLLSMODE        0x3930
+#define TCM825X_FLLSLIM         0x390F
+#define TCM825X_DETSEL          0x3AF0
+#define TCM825X_ACDETNC         0x3A0F
+#define TCM825X_AGSLOW2         0x3BC0
+#define TCM825X_DG              0x3B3F
+#define TCM825X_REJHLEV         0x3CFF
+#define TCM825X_ALCLOCK         0x3D80
+#define TCM825X_FPSLNKSW        0x3D40
+#define TCM825X_ALCSPD          0x3D30
+#define TCM825X_REJH            0x3D03
+#define TCM825X_SHESRSW         0x3E80
+#define TCM825X_ESLIMSEL        0x3E40
+#define TCM825X_SHESRSPD        0x3E30
+#define TCM825X_ELSTEP          0x3E0C
+#define TCM825X_ELSTART         0x3E03
+#define TCM825X_AGMIN           0x3FFF
+#define TCM825X_PREGRG          0x423F
+#define TCM825X_PREGBG          0x433F
+#define TCM825X_PRERG           0x443F
+#define TCM825X_PREBG           0x453F
+#define TCM825X_MSKBR           0x477F
+#define TCM825X_MSKGR           0x487F
+#define TCM825X_MSKRB           0x497F
+#define TCM825X_MSKGB           0x4A7F
+#define TCM825X_MSKRG           0x4B7F
+#define TCM825X_MSKBG           0x4C7F
+#define TCM825X_HDTCSW          0x4D80
+#define TCM825X_VDTCSW          0x4D40
+#define TCM825X_DTCYL           0x4D3F
+#define TCM825X_HDTPSW          0x4E80
+#define TCM825X_VDTPSW          0x4E40
+#define TCM825X_DTCGAIN         0x4E3F
+#define TCM825X_DTLLIMSW        0x4F10
+#define TCM825X_DTLYLIM         0x4F0F
+#define TCM825X_YLCUTLMSK       0x5080
+#define TCM825X_YLCUTL          0x503F
+#define TCM825X_YLCUTHMSK       0x5180
+#define TCM825X_YLCUTH          0x513F
+#define TCM825X_UVSKNC          0x527F
+#define TCM825X_UVLJ            0x537F
+#define TCM825X_WBGMIN          0x54FF
+#define TCM825X_WBGMAX          0x55FF
+#define TCM825X_WBSPDUP         0x5603
+#define TCM825X_ALLAREA         0x5820
+#define TCM825X_WBLOCK          0x5810
+#define TCM825X_WB2SP           0x580F
+#define TCM825X_KIZUSW          0x5920
+#define TCM825X_PBRSW           0x5910
+#define TCM825X_ABCSW           0x5903
+#define TCM825X_PBDLV           0x5AFF
+#define TCM825X_PBC1LV          0x5BFF
+
+#define TCM825X_NUM_REGS	(TCM825X_ADDR(TCM825X_PBC1LV) + 1)
+
+//#define TCM825X_PID_MAGIC	0x96	/* high byte of product ID number */
+//#define TCM825X_VER_REV2	0x48	/* low byte of product ID number */
+//#define TCM825X_VER_REV3	0x49	/* low byte of product ID number */
+//#define TCM825X_MIDH_MAGIC	0x7F	/* high byte of mfg ID */
+//#define TCM825X_MIDL_MAGIC	0xA2	/* low byte of mfg ID */
+
+#define TCM825X_REG_TERM 0xff		/* terminating list entry for reg */
+#define TCM825X_VAL_TERM 0xff		/* terminating list entry for val */
+
+/* define a structure for tcm825x register initialization values */
+struct tcm825x_reg {
+	u8 val;
+	u16 reg;
+};
+
+enum image_size { subQCIF = 0, QQVGA, QCIF, QVGA, CIF, VGA };
+enum pixel_format { YUV422 = 0, RGB565 };
+#define NUM_IMAGE_SIZES 6
+#define NUM_PIXEL_FORMATS 2
+
+struct capture_size {
+	unsigned long width;
+	unsigned long height;
+};
+
+/* Array of image sizes supported by TCM825X.  These must be ordered from
+ * smallest image size to largest.
+ */
+const static struct capture_size tcm825x_sizes[] = {
+	{ 128,  96 }, /* subQCIF */
+	{ 160, 120 }, /* QQVGA */
+	{ 176, 144 }, /* QCIF */
+	{ 320, 240 }, /* QVGA */
+	{ 352, 288 }, /* CIF */
+	{ 640, 480 }, /* VGA */
+};
+
+#endif /* ifndef TCM825X_H */
+
+
diff -ruN linux-omap-2.6/drivers/media/video/video-buf.c maemo_src/drivers/media/video/video-buf.c
--- linux-omap-2.6/drivers/media/video/video-buf.c	2011-02-06 19:44:58.263333272 -0500
+++ maemo_src/drivers/media/video/video-buf.c	2007-10-02 03:09:31.000000000 -0400
@@ -702,9 +702,7 @@
 		dprintk(1,"qbuf: memory type is wrong.\n");
 		goto done;
 	}
-	if (buf->state == STATE_QUEUED ||
-	    buf->state == STATE_PREPARED ||
-	    buf->state == STATE_ACTIVE) {
+	if (buf->state != STATE_NEEDS_INIT && buf->state != STATE_IDLE) {
 		dprintk(1,"qbuf: buffer is already queued or active.\n");
 		goto done;
 	}
diff -ruN linux-omap-2.6/drivers/mmc/Kconfig maemo_src/drivers/mmc/Kconfig
--- linux-omap-2.6/drivers/mmc/Kconfig	2011-02-06 19:44:58.649999941 -0500
+++ maemo_src/drivers/mmc/Kconfig	2011-02-06 20:12:12.609999940 -0500
@@ -71,6 +71,12 @@
 
 	  If unsure, say N.
 
+config MMC_PAUSING
+	bool "Can pause DMA while accessing the MMC"
+	depends on MMC_OMAP
+	help
+	  This enables sw controlled pausing of DMA transfers to/from the MMC.
+
 config MMC_WBSD
 	tristate "Winbond W83L51xD SD/MMC Card Interface support"
 	depends on MMC && ISA_DMA_API
diff -ruN linux-omap-2.6/drivers/mmc/mmc_block.c maemo_src/drivers/mmc/mmc_block.c
--- linux-omap-2.6/drivers/mmc/mmc_block.c	2011-02-06 19:44:58.656666607 -0500
+++ maemo_src/drivers/mmc/mmc_block.c	2011-02-06 20:12:12.573333271 -0500
@@ -218,19 +218,72 @@
 	return blocks;
 }
 
+static int mmc_blk_configure_xfer(struct mmc_card *card,
+				  struct mmc_blk_request *brq,
+				  struct request *req)
+{
+	u32 readcmd, writecmd;
+
+	if (rq_data_dir(req) != READ &&
+	    !(card->host->caps & MMC_CAP_MULTIWRITE) &&
+	    !mmc_card_sd(card))
+		brq->data.blocks = 1;
+
+	if (brq->data.blocks > 1) {
+		/* MMC cards behave better (at least with write operations)
+		 * if we specify the block count in advance. */
+		if (!mmc_card_sd(card) && rq_data_dir(req) == READ &&
+		    (card->host->caps & MMC_CAP_BAN_OPENENDED_READ)) {
+			struct mmc_command cmd;
+			int err;
+
+			cmd.opcode = MMC_SET_BLOCK_COUNT;
+			cmd.arg = brq->data.blocks;
+			cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+			err = mmc_wait_for_cmd(card->host, &cmd, 5);
+			if (err) {
+				if (printk_ratelimit())
+					printk(KERN_WARNING "%s: error %d setting block count\n",
+					       req->rq_disk->disk_name, cmd.error);
+				/* Fall back to single-block transfer */
+				brq->data.blocks = 1;
+			}
+		} else
+			brq->mrq.stop = &brq->stop;
+	}
+
+	if (brq->data.blocks > 1) {
+		brq->data.flags |= MMC_DATA_MULTI;
+		readcmd = MMC_READ_MULTIPLE_BLOCK;
+		writecmd = MMC_WRITE_MULTIPLE_BLOCK;
+	} else {
+		readcmd = MMC_READ_SINGLE_BLOCK;
+		writecmd = MMC_WRITE_BLOCK;
+	}
+
+	if (rq_data_dir(req) == READ) {
+		brq->cmd.opcode = readcmd;
+		brq->data.flags |= MMC_DATA_READ;
+	} else {
+		brq->cmd.opcode = writecmd;
+		brq->data.flags |= MMC_DATA_WRITE;
+	}
+
+	return 0;
+}
+
 static int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)
 {
 	struct mmc_blk_data *md = mq->data;
 	struct mmc_card *card = md->queue.card;
 	struct mmc_blk_request brq;
-	int ret = 1;
+	int ret = 1, sg_pos, data_size;
 
 	if (mmc_card_claim_host(card))
 		goto flush_queue;
 
 	do {
 		struct mmc_command cmd;
-		u32 readcmd, writecmd;
 
 		memset(&brq, 0, sizeof(struct mmc_blk_request));
 		brq.mrq.cmd = &brq.cmd;
@@ -256,33 +309,26 @@
 		 * this rule as they support querying the number of
 		 * successfully written sectors.
 		 */
-		if (rq_data_dir(req) != READ &&
-		    !(card->host->caps & MMC_CAP_MULTIWRITE) &&
-		    !mmc_card_sd(card))
-			brq.data.blocks = 1;
-
-		if (brq.data.blocks > 1) {
-			brq.data.flags |= MMC_DATA_MULTI;
-			brq.mrq.stop = &brq.stop;
-			readcmd = MMC_READ_MULTIPLE_BLOCK;
-			writecmd = MMC_WRITE_MULTIPLE_BLOCK;
-		} else {
-			brq.mrq.stop = NULL;
-			readcmd = MMC_READ_SINGLE_BLOCK;
-			writecmd = MMC_WRITE_BLOCK;
-		}
-
-		if (rq_data_dir(req) == READ) {
-			brq.cmd.opcode = readcmd;
-			brq.data.flags |= MMC_DATA_READ;
-		} else {
-			brq.cmd.opcode = writecmd;
-			brq.data.flags |= MMC_DATA_WRITE;
-		}
+		if (mmc_blk_configure_xfer(card, &brq, req) < 0)
+			goto cmd_err;
 
 		brq.data.sg = mq->sg;
 		brq.data.sg_len = blk_rq_map_sg(req->q, req, brq.data.sg);
 
+		if (brq.data.blocks !=
+		    (req->nr_sectors >> (md->block_bits - 9))) {
+			data_size = brq.data.blocks * brq.data.blksz;
+			for (sg_pos = 0; sg_pos < brq.data.sg_len; sg_pos++) {
+				data_size -= mq->sg[sg_pos].length;
+				if (data_size <= 0) {
+					mq->sg[sg_pos].length += data_size;
+					sg_pos++;
+					break;
+				}
+			}
+			brq.data.sg_len = sg_pos;
+		}
+
 		mmc_wait_for_req(card->host, &brq.mrq);
 		if (brq.cmd.error) {
 			printk(KERN_ERR "%s: error %d sending read/write command\n",
@@ -315,7 +361,13 @@
 					       req->rq_disk->disk_name, err);
 					goto cmd_err;
 				}
-			} while (!(cmd.resp[0] & R1_READY_FOR_DATA));
+				/*
+				 * Some cards mishandle the status bits,
+				 * so make sure to check both the busy
+				 * indication and the card state.
+				 */
+			} while (!(cmd.resp[0] & R1_READY_FOR_DATA) ||
+				 (R1_CURRENT_STATE(cmd.resp[0]) == 7));
 
 #if 0
 			if (cmd.resp[0] & ~0x00000900)
@@ -477,11 +529,20 @@
 
 	blk_queue_hardsect_size(md->queue.queue, 1 << md->block_bits);
 
-	/*
-	 * The CSD capacity field is in units of read_blkbits.
-	 * set_capacity takes units of 512 bytes.
-	 */
-	set_capacity(md->disk, card->csd.capacity << (card->csd.read_blkbits - 9));
+	if (!mmc_card_sd(card) && mmc_card_blockaddr(card)) {
+		/*
+		 * The EXT_CSD sector count is in number or 512 byte
+		 * sectors.
+		 */
+		set_capacity(md->disk, card->ext_csd.sectors);
+	} else {
+		/*
+		 * The CSD capacity field is in units of read_blkbits.
+		 * set_capacity takes units of 512 bytes.
+		 */
+		set_capacity(md->disk,
+			card->csd.capacity << (card->csd.read_blkbits - 9));
+	}
 	return md;
 
  err_putdisk:
@@ -518,6 +579,8 @@
 	return 0;
 }
 
+static void mmc_blk_remove(struct mmc_card *card);
+
 static int mmc_blk_probe(struct mmc_card *card)
 {
 	struct mmc_blk_data *md;
@@ -547,7 +610,7 @@
 	return 0;
 
  out:
-	mmc_blk_put(md);
+	mmc_blk_remove(card);
 
 	return err;
 }
diff -ruN linux-omap-2.6/drivers/mmc/mmc.c maemo_src/drivers/mmc/mmc.c
--- linux-omap-2.6/drivers/mmc/mmc.c	2011-02-06 19:44:58.656666607 -0500
+++ maemo_src/drivers/mmc/mmc.c	2011-02-06 20:12:12.596666606 -0500
@@ -27,6 +27,21 @@
 
 #include "mmc.h"
 
+#ifdef CONFIG_MMC_PAUSING
+static DEFINE_MUTEX(mmc_running);
+void mmc_running_lock(void)
+{
+	mutex_lock(&mmc_running);
+}
+void mmc_running_unlock(void)
+{
+	mutex_unlock(&mmc_running);
+}
+#else
+static inline void mmc_running_lock(void) {}
+static inline void mmc_running_unlock(void) {}
+#endif
+
 #define CMD_RETRIES	3
 
 /*
@@ -57,6 +72,23 @@
 	35,	40,	45,	50,	55,	60,	70,	80,
 };
 
+static void mmc_idle_work(struct work_struct *work);
+static inline void mmc_set_ios(struct mmc_host *host);
+
+static void mmc_card_watch_state(struct mmc_host *host, struct mmc_command *cmd)
+{
+	struct mmc_card *card = host->card_selected;
+
+	if (!host->claimed || card == NULL || card == (void *)-1)
+		return;
+
+	if (mmc_resp_type(cmd) == MMC_RSP_R1) {
+		card->rq_state = R1_CURRENT_STATE(cmd->resp[0]);
+		if (host->caps & MMC_CAP_STANDBY)
+			mod_timer(&host->idle_timer,
+				  jiffies + host->idle_delay);
+	}
+}
 
 /**
  *	mmc_request_done - finish processing an MMC request
@@ -82,6 +114,7 @@
 		cmd->error = 0;
 		host->ops->request(host, mrq);
 	} else if (mrq->done) {
+		mmc_card_watch_state(host, cmd);
 		mrq->done(mrq);
 	}
 }
@@ -122,6 +155,12 @@
 			mrq->stop->mrq = mrq;
 		}
 	}
+
+	if (host->ios.power_mode != MMC_POWER_ON) {
+		host->ios.power_mode = MMC_POWER_ON;
+		mmc_set_ios(host);
+	}
+
 	host->ops->request(host, mrq);
 }
 
@@ -139,9 +178,11 @@
 	mrq->done_data = &complete;
 	mrq->done = mmc_wait_done;
 
+	mmc_running_lock();
 	mmc_start_request(host, mrq);
 
 	wait_for_completion(&complete);
+	mmc_running_unlock();
 
 	return 0;
 }
@@ -479,6 +520,24 @@
 {
 	int bit;
 
+	/*
+	 * Sanity check the voltages that the card claims to
+	 * support.
+	 */
+	if (ocr & 0x7F) {
+		printk("%s: card claims to support voltages below "
+		       "the defined range. These will be ignored.\n",
+		       mmc_hostname(host));
+		ocr &= ~0x7F;
+	}
+
+	if (host->mode == MMC_MODE_SD && (ocr & MMC_VDD_165_195)) {
+		printk("%s: SD card claims to support the incompletely "
+		       "defined 'low voltage range'. This will be ignored.\n",
+		       mmc_hostname(host));
+		ocr &= ~MMC_VDD_165_195;
+	}
+
 	ocr &= host->ocr_avail;
 
 	bit = ffs(ocr);
@@ -1095,11 +1154,29 @@
 		mmc_wait_for_req(host, &mrq);
 
 		if (cmd.error != MMC_ERR_NONE || data.error != MMC_ERR_NONE) {
-			printk("%s: unable to read EXT_CSD, performance "
-				"might suffer.\n", mmc_hostname(card->host));
+			if (card->csd.capacity == (4096 * 512)) {
+				printk(KERN_ERR "%s: unable to read EXT_CSD "
+					"on a possible high capacity card. "
+					"Card will be ignored.\n",
+					mmc_hostname(card->host));
+				mmc_card_set_dead(card);
+			} else {
+				printk(KERN_WARNING "%s: unable to read "
+					"EXT_CSD, performance might "
+					"suffer.\n",
+					mmc_hostname(card->host));
+			}
 			continue;
 		}
 
+		card->ext_csd.sectors =
+			ext_csd[EXT_CSD_SEC_CNT + 0] << 0 |
+			ext_csd[EXT_CSD_SEC_CNT + 1] << 8 |
+			ext_csd[EXT_CSD_SEC_CNT + 2] << 16 |
+			ext_csd[EXT_CSD_SEC_CNT + 3] << 24;
+		if (card->ext_csd.sectors > EXT_CSD_SEC_CNT_2GB)
+			mmc_card_set_blockaddr(card);
+
 		switch (ext_csd[EXT_CSD_CARD_TYPE]) {
 		case EXT_CSD_CARD_TYPE_52 | EXT_CSD_CARD_TYPE_26:
 			card->ext_csd.hs_max_dtr = 52000000;
@@ -1410,7 +1487,8 @@
 
 static void mmc_setup(struct mmc_host *host)
 {
-	if (host->ios.power_mode != MMC_POWER_ON) {
+	if (host->ios.power_mode != MMC_POWER_ON &&
+	    host->ios.power_mode != MMC_POWER_STANDBY) {
 		int err;
 		u32 ocr;
 
@@ -1488,7 +1566,8 @@
 			mmc_send_app_op_cond(host, host->ocr | (sd2 << 30), NULL);
 		}
 	} else {
-		mmc_send_op_cond(host, host->ocr, NULL);
+		/* The extra bit indicates that we support high capacity */
+		mmc_send_op_cond(host, host->ocr | (1 << 30), NULL);
 	}
 
 	mmc_discover_cards(host);
@@ -1508,6 +1587,122 @@
 		mmc_process_ext_csds(host);
 }
 
+/**
+ *	mmc_idle_timer -
+ *	@host: MMC host which completed request
+ *	@mrq: MMC request which request
+ *
+ *      MMC idle timer is set to run after any read or write request
+ *      to put host standby mode once the cards are idle
+ */
+static void
+mmc_idle_timer(unsigned long data)
+{
+	struct mmc_host *host = (struct mmc_host *)data;
+	schedule_work(&host->idle_work);
+}
+
+/**
+ *      mmc_card_check_busy - check if the card is busy writing
+ *	@host: MMC host in claimed state
+ *      @card: mmc card to check
+ *
+ *      Host must be in claimed state and card unselected.
+ *
+ *      Returns 0 if card is not busy
+ *      Returns 1 if card is still busy
+ *      Returns 2 if card is removed
+ */
+
+static int mmc_card_check_busy(struct mmc_host *host, struct mmc_card *card)
+{
+	struct mmc_command cmd;
+	int err;
+
+	if (mmc_card_dead(card) ||
+	    card->rq_state == R1_STATE_TRAN ||
+	    card->rq_state == R1_STATE_STBY)
+		return 0;
+
+	cmd.opcode = MMC_SEND_STATUS;
+	cmd.arg = card->rca << 16;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+
+	err = mmc_wait_for_cmd(host, &cmd, CMD_RETRIES);
+	if (err != MMC_ERR_NONE)
+		return 2;
+
+	card->rq_state = R1_CURRENT_STATE(cmd.resp[0]);
+	if (card->rq_state != R1_STATE_STBY)
+		return 1;
+
+	return 0;
+}
+
+/**
+ *      mmc_check_buys - check if the cards are busy (writing)
+ *	@host: MMC host in claimed state
+ *
+ *      Host must be in claimed state.
+ *
+ *      Returns 0 if no card is busy.
+ *      Returns 1 if any cards is still in the programming state
+ *      Returns 2 if any card was missing
+ */
+
+static int mmc_check_busy(struct mmc_host *host)
+{
+	struct list_head *l, *n;
+
+	mmc_deselect_cards(host);
+	list_for_each_safe(l, n, &host->cards) {
+		struct mmc_card *card = mmc_list_to_card(l);
+		int busy = mmc_card_check_busy(host, card);
+
+		if (busy)
+			return busy;
+	}
+
+	return 0;
+}
+
+/**
+ *      mmc_idle_work - put host into standby mode
+ *	@host: MMC host which completed request a while ago
+ *
+ */
+static void mmc_idle_work(struct work_struct *work)
+{
+	struct mmc_host *host = container_of(work, struct mmc_host, idle_work);
+
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	if (host->claimed) {
+		spin_unlock_irqrestore(&host->lock, flags);
+		mod_timer(&host->idle_timer, jiffies + host->idle_delay);
+		return;
+	}
+	host->claimed = 1;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	if (host->ios.power_mode == MMC_POWER_ON ||
+	    host->ios.power_mode == MMC_POWER_STANDBY)
+		switch (mmc_check_busy(host)) {
+		case 0:
+			host->ios.power_mode = MMC_POWER_STANDBY;
+			mmc_set_ios(host);
+			break;
+		case 1:
+			mod_timer(&host->idle_timer,
+				  jiffies + host->idle_delay);
+			break;
+		case 2:
+			mmc_detect_change(host, 0);
+		}
+
+	mmc_release_host(host);
+}
 
 /**
  *	mmc_detect_change - process change of state on a MMC socket
@@ -1539,7 +1734,8 @@
 	 * removed cards first so we can intelligently re-select the VDD.
 	 */
 	power_mode = host->ios.power_mode;
-	if (power_mode == MMC_POWER_ON)
+	if (power_mode == MMC_POWER_ON ||
+	    power_mode == MMC_POWER_STANDBY)
 		mmc_check_cards(host);
 
 	mmc_setup(host);
@@ -1613,6 +1809,10 @@
 		INIT_LIST_HEAD(&host->cards);
 		INIT_DELAYED_WORK(&host->detect, mmc_rescan);
 
+		setup_timer(&host->idle_timer, mmc_idle_timer,
+			    (unsigned long) host);
+		INIT_WORK(&host->idle_work, mmc_idle_work);
+
 		/*
 		 * By default, hosts do not support SGIO or large requests.
 		 * They have to set these according to their abilities.
@@ -1661,6 +1861,7 @@
 {
 	struct list_head *l, *n;
 
+	del_timer_sync(&host->idle_timer);
 	list_for_each_safe(l, n, &host->cards) {
 		struct mmc_card *card = mmc_list_to_card(l);
 
@@ -1673,6 +1874,55 @@
 
 EXPORT_SYMBOL(mmc_remove_host);
 
+#define MAX_STATUS_INQUIRIES 5000
+static void mmc_card_wait_for_standby(struct mmc_card *card)
+{
+	struct mmc_host *host = card->host;
+	long started = jiffies;
+	int cnt;
+	int elapsed;
+
+	mmc_claim_host(host);
+
+	mmc_deselect_cards(host);
+	cnt = 0;
+	while (cnt < MAX_STATUS_INQUIRIES) {
+		int state = mmc_card_check_busy(host, card);
+		if (state == 1) {
+			mdelay(1);
+			cnt++;
+		} else
+			break;
+	}
+	elapsed = jiffies_to_msecs(jiffies  - started);
+
+	mmc_release_host(host);
+
+	if (cnt >= MAX_STATUS_INQUIRIES)
+		printk(KERN_ERR "%s: Card still busy after %d ms polling.\n",
+		       mmc_hostname(host), elapsed);
+	else if (cnt > 0)
+		printk(KERN_NOTICE "%s: Card idle after %d of polling.\n",
+		       mmc_hostname(host), elapsed);
+}
+
+void mmc_shutdown_host(struct mmc_host *host)
+{
+	struct list_head *l, *n;
+
+	del_timer_sync(&host->idle_timer);
+	list_for_each_safe(l, n, &host->cards) {
+		struct mmc_card *card = mmc_list_to_card(l);
+
+		mmc_remove_card(card);
+		mmc_card_wait_for_standby(card);
+	}
+
+	mmc_power_off(host);
+	mmc_remove_host_sysfs(host);
+}
+EXPORT_SYMBOL(mmc_shutdown_host);
+
 /**
  *	mmc_free_host - free the host structure
  *	@host: mmc host
@@ -1697,6 +1947,7 @@
 int mmc_suspend_host(struct mmc_host *host, pm_message_t state)
 {
 	mmc_claim_host(host);
+	del_timer_sync(&host->idle_timer);
 	mmc_deselect_cards(host);
 	mmc_power_off(host);
 	mmc_release_host(host);
diff -ruN linux-omap-2.6/drivers/mmc/mmc.h maemo_src/drivers/mmc/mmc.h
--- linux-omap-2.6/drivers/mmc/mmc.h	2011-02-06 19:44:58.656666607 -0500
+++ maemo_src/drivers/mmc/mmc.h	2011-02-06 20:12:12.596666606 -0500
@@ -18,6 +18,7 @@
 int mmc_add_host_sysfs(struct mmc_host *host);
 void mmc_remove_host_sysfs(struct mmc_host *host);
 void mmc_free_host_sysfs(struct mmc_host *host);
+void mmc_shutdown_host(struct mmc_host *host);
 
 int mmc_schedule_work(struct work_struct *work);
 int mmc_schedule_delayed_work(struct delayed_work *work, unsigned long delay);
diff -ruN linux-omap-2.6/drivers/mmc/mmc_queue.c maemo_src/drivers/mmc/mmc_queue.c
--- linux-omap-2.6/drivers/mmc/mmc_queue.c	2011-02-06 19:44:58.656666607 -0500
+++ maemo_src/drivers/mmc/mmc_queue.c	2007-10-02 03:09:31.000000000 -0400
@@ -41,6 +41,8 @@
 		 * Block I/O requests need translating according
 		 * to the protocol.
 		 */
+		if (!mq)
+			return ret;
 		ret = mq->prep_fn(mq, req);
 	} else {
 		/*
diff -ruN linux-omap-2.6/drivers/mmc/omap.c maemo_src/drivers/mmc/omap.c
--- linux-omap-2.6/drivers/mmc/omap.c	2011-02-06 20:17:25.739999940 -0500
+++ maemo_src/drivers/mmc/omap.c	2011-02-06 20:12:12.589999940 -0500
@@ -32,6 +32,7 @@
 #include <asm/mach-types.h>
 
 #include <asm/arch/board.h>
+#include <asm/arch/mmc.h>
 #include <asm/arch/gpio.h>
 #include <asm/arch/dma.h>
 #include <asm/arch/mux.h>
@@ -51,7 +52,7 @@
 #define	OMAP_MMC_REG_BLEN	0x24
 #define	OMAP_MMC_REG_NBLK	0x28
 #define	OMAP_MMC_REG_BUF	0x2c
-#define OMAP_MMC_REG_SDIO	0x34
+#define	OMAP_MMC_REG_SDIO	0x34
 #define	OMAP_MMC_REG_REV	0x3c
 #define	OMAP_MMC_REG_RSP0	0x40
 #define	OMAP_MMC_REG_RSP1	0x44
@@ -95,9 +96,30 @@
 
 /* Specifies how often in millisecs to poll for card status changes
  * when the cover switch is open */
-#define OMAP_MMC_SWITCH_POLL_DELAY	500
+#define OMAP_MMC_COVER_POLL_DELAY	500
 
-static int mmc_omap_enable_poll = 1;
+struct mmc_omap_host;
+
+struct mmc_omap_slot {
+	int                     id;
+	unsigned int            vdd;
+	u16                     saved_con;
+	u16                     bus_mode;
+	unsigned int		fclk_freq;
+	unsigned		power_mode;
+
+	struct tasklet_struct	cover_tasklet;
+	struct timer_list       cover_timer;
+	unsigned		cover_open;
+
+	int                     cover_last_state;
+	int                     enable_poll;
+
+	struct mmc_request *    mrq;
+	struct mmc_omap_host *  host;
+	struct mmc_host *       mmc;
+	struct omap_mmc_slot_data *pdata;
+};
 
 struct mmc_omap_host {
 	int			initialized;
@@ -114,8 +136,9 @@
 	void __iomem		*virt_base;
 	unsigned int		phys_base;
 	int			irq;
-	unsigned char		bus_mode;
-	unsigned char		hw_bus_mode;
+
+	struct work_struct      cmd_abort;
+	struct timer_list       cmd_timer;
 
 	unsigned int		sg_len;
 	int			sg_idx;
@@ -132,40 +155,161 @@
 	struct timer_list	dma_timer;
 	unsigned		dma_len;
 
-	short			power_pin;
-	short			wp_pin;
+	struct mmc_omap_slot *  slots[OMAP_MMC_MAX_SLOTS];
+	struct mmc_omap_slot *  current_slot;
+	spinlock_t              slot_lock;
+	wait_queue_head_t       slot_wq;
+	int                     nr_slots;
+
+	struct timer_list       clk_timer;
+	spinlock_t		clk_lock;     /* for changing enabled state */
+	unsigned int            fclk_enabled:1;
 
-	int			switch_pin;
-	struct work_struct	switch_work;
-	struct timer_list	switch_timer;
-	int			switch_last_state;
+	struct omap_mmc_platform_data *pdata;
 };
 
-static inline int
-mmc_omap_cover_is_open(struct mmc_omap_host *host)
+void mmc_omap_fclk_offdelay(struct mmc_omap_slot *slot)
 {
-	if (host->switch_pin < 0)
-		return 0;
-	return omap_get_gpio_datain(host->switch_pin);
+	unsigned long tick_ns;
+
+	if (slot != NULL && slot->host->fclk_enabled && slot->fclk_freq > 0) {
+		tick_ns = (1000000000 + slot->fclk_freq - 1) / slot->fclk_freq;
+		ndelay(8 * tick_ns);
+	}
+}
+
+void mmc_omap_fclk_enable(struct mmc_omap_host *host, unsigned int enable)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->clk_lock, flags);
+	if (host->fclk_enabled != enable) {
+		host->fclk_enabled = enable;
+		if (enable)
+			clk_enable(host->fclk);
+		else
+			clk_disable(host->fclk);
+	}
+	spin_unlock_irqrestore(&host->clk_lock, flags);
+}
+
+static void mmc_omap_select_slot(struct mmc_omap_slot *slot, int claimed)
+{
+	struct mmc_omap_host *host = slot->host;
+	unsigned long flags;
+
+	if (claimed)
+		goto no_claim;
+	spin_lock_irqsave(&host->slot_lock, flags);
+	while (host->mmc != NULL) {
+		spin_unlock_irqrestore(&host->slot_lock, flags);
+		wait_event(host->slot_wq, host->mmc == NULL);
+		spin_lock_irqsave(&host->slot_lock, flags);
+	}
+	host->mmc = slot->mmc;
+	spin_unlock_irqrestore(&host->slot_lock, flags);
+no_claim:
+	del_timer(&host->clk_timer);
+	if (host->current_slot != slot || !claimed)
+		mmc_omap_fclk_offdelay(host->current_slot);
+
+	if (host->current_slot != slot) {
+		OMAP_MMC_WRITE(host, CON, slot->saved_con & 0xFC00);
+
+		if (host->pdata->switch_slot != NULL)
+			host->pdata->switch_slot(mmc_dev(slot->mmc), slot->id);
+		host->current_slot = slot;
+	}
+
+	if (claimed) {
+		mmc_omap_fclk_enable(host, 1);
+
+		/* Doing the dummy read here seems to work around some bug
+		 * at least in OMAP24xx silicon where the command would not
+		 * start after writing the CMD register. Sigh. */
+		OMAP_MMC_READ(host, CON);
+
+		OMAP_MMC_WRITE(host, CON, slot->saved_con);
+	} else
+		mmc_omap_fclk_enable(host, 0);
+}
+
+static void mmc_omap_start_request(struct mmc_omap_host *host,
+				   struct mmc_request *req);
+
+static void mmc_omap_release_slot(struct mmc_omap_slot *slot, int clk_enabled)
+{
+	struct mmc_omap_host *host = slot->host;
+	unsigned long flags;
+	int i;
+
+	BUG_ON(slot == NULL || host->mmc == NULL);
+
+	if (clk_enabled)
+		/* Keeps clock running for at least 8 cycles on valid freq */
+		mod_timer(&host->clk_timer, jiffies  + HZ/10);
+	else {
+		del_timer(&host->clk_timer);
+		mmc_omap_fclk_offdelay(slot);
+		mmc_omap_fclk_enable(host, 0);
+	}
+
+	spin_lock_irqsave(&host->slot_lock, flags);
+	/* Check for any pending requests */
+	for (i = 0; i < host->nr_slots; i++) {
+		struct mmc_omap_slot *new_slot;
+		struct mmc_request *rq;
+
+		if (host->slots[i] == NULL || host->slots[i]->mrq == NULL)
+			continue;
+
+		new_slot = host->slots[i];
+		/* The current slot should not have a request in queue */
+		BUG_ON(new_slot == host->current_slot);
+
+		host->mmc = new_slot->mmc;
+		spin_unlock_irqrestore(&host->slot_lock, flags);
+		mmc_omap_select_slot(new_slot, 1);
+		rq = new_slot->mrq;
+		new_slot->mrq = NULL;
+		mmc_omap_start_request(host, rq);
+
+		return;
+	}
+
+	host->mmc = NULL;
+	wake_up(&host->slot_wq);
+	spin_unlock_irqrestore(&host->slot_lock, flags);
+}
+
+static inline
+int mmc_omap_cover_is_open(struct mmc_omap_slot *slot)
+{
+	return slot->pdata->get_cover_state(mmc_dev(slot->mmc), slot->id);
 }
 
 static ssize_t
 mmc_omap_show_cover_switch(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
-	struct mmc_omap_host *host = dev_get_drvdata(dev);
+	struct mmc_host *mmc = container_of(dev, struct mmc_host, class_dev);
+	struct mmc_omap_slot *slot = mmc_priv(mmc);
 
-	return sprintf(buf, "%s\n", mmc_omap_cover_is_open(host) ? "open" :
-			"closed");
+	return sprintf(buf, "%s\n", mmc_omap_cover_is_open(slot) ? "open" : "closed");
 }
 
 static DEVICE_ATTR(cover_switch, S_IRUGO, mmc_omap_show_cover_switch, NULL);
 
+#if 0
 static ssize_t
 mmc_omap_show_enable_poll(struct device *dev,
 	struct device_attribute *attr, char *buf)
 {
-	return snprintf(buf, PAGE_SIZE, "%d\n", mmc_omap_enable_poll);
+	struct mmc_host *mmc = container_of(dev, struct mmc_host, class_dev);
+	struct mmc_omap_slot *slot = mmc_priv(mmc);
+
+	return sprintf(buf, "%s\n", mmc_omap_cover_is_open(slot) ? "closed" :
+		       "open");
 }
 
 static ssize_t
@@ -191,6 +335,33 @@
 static DEVICE_ATTR(enable_poll, 0664,
 		   mmc_omap_show_enable_poll, mmc_omap_store_enable_poll);
 
+#endif
+
+/* Access to the R/O switch is required for production testing
+ * purposes. */
+static ssize_t
+mmc_omap_show_ro(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mmc_host *mmc = container_of(dev, struct mmc_host, class_dev);
+	struct mmc_omap_slot *slot = mmc_priv(mmc);
+
+	return sprintf(buf, "%d\n", slot->pdata->get_ro(mmc_dev(mmc),
+							slot->id));
+}
+
+static DEVICE_ATTR(ro, S_IRUGO, mmc_omap_show_ro, NULL);
+
+static ssize_t
+mmc_omap_show_slot_name(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct mmc_host *mmc = container_of(dev, struct mmc_host, class_dev);
+	struct mmc_omap_slot *slot = mmc_priv(mmc);
+
+	return sprintf(buf, "%s\n", slot->pdata->name);
+}
+
+static DEVICE_ATTR(slot_name, S_IRUGO, mmc_omap_show_slot_name, NULL);
+
 static void
 mmc_omap_start_command(struct mmc_omap_host *host, struct mmc_command *cmd)
 {
@@ -223,6 +394,10 @@
 		break;
 	}
 
+	if (cmd->opcode == SD_SEND_RELATIVE_ADDR &&
+	    mmc_cmd_type(cmd) == MMC_CMD_BCR)
+		resptype = 6;
+
 	if (mmc_cmd_type(cmd) == MMC_CMD_ADTC) {
 		cmdtype = OMAP_MMC_CMDTYPE_ADTC;
 	} else if (mmc_cmd_type(cmd) == MMC_CMD_BC) {
@@ -235,7 +410,7 @@
 
 	cmdreg = cmd->opcode | (resptype << 8) | (cmdtype << 12);
 
-	if (host->bus_mode == MMC_BUSMODE_OPENDRAIN)
+	if (host->current_slot->bus_mode == MMC_BUSMODE_OPENDRAIN)
 		cmdreg |= 1 << 6;
 
 	if (cmd->flags & MMC_RSP_BUSY)
@@ -244,7 +419,7 @@
 	if (host->data && !(host->data->flags & MMC_DATA_WRITE))
 		cmdreg |= 1 << 15;
 
-	clk_enable(host->fclk);
+	mod_timer(&host->cmd_timer, jiffies + HZ/2);
 
 	OMAP_MMC_WRITE(host, CTO, 200);
 	OMAP_MMC_WRITE(host, ARGL, cmd->arg & 0xffff);
@@ -259,26 +434,32 @@
 }
 
 static void
+mmc_omap_release_dma(struct mmc_omap_host *host, struct mmc_data *data,
+		     int abort)
+{
+	enum dma_data_direction dma_data_dir;
+
+	BUG_ON(host->dma_ch < 0);
+	if (abort)
+		omap_stop_dma(host->dma_ch);
+	/* Release DMA channel lazily */
+	mod_timer(&host->dma_timer, jiffies + HZ);
+	if (data->flags & MMC_DATA_WRITE)
+		dma_data_dir = DMA_TO_DEVICE;
+	else
+		dma_data_dir = DMA_FROM_DEVICE;
+	dma_unmap_sg(mmc_dev(host->mmc), data->sg, host->sg_len,
+		     dma_data_dir);
+}
+
+static void
 mmc_omap_xfer_done(struct mmc_omap_host *host, struct mmc_data *data)
 {
-	if (host->dma_in_use) {
-		enum dma_data_direction dma_data_dir;
+	if (host->dma_in_use)
+		mmc_omap_release_dma(host, data, data->error != MMC_ERR_NONE);
 
-		BUG_ON(host->dma_ch < 0);
-		if (data->error != MMC_ERR_NONE)
-			omap_stop_dma(host->dma_ch);
-		/* Release DMA channel lazily */
-		mod_timer(&host->dma_timer, jiffies + HZ);
-		if (data->flags & MMC_DATA_WRITE)
-			dma_data_dir = DMA_TO_DEVICE;
-		else
-			dma_data_dir = DMA_FROM_DEVICE;
-		dma_unmap_sg(mmc_dev(host->mmc), data->sg, host->sg_len,
-			     dma_data_dir);
-	}
 	host->data = NULL;
 	host->sg_len = 0;
-	clk_disable(host->fclk);
 
 	/* NOTE:  MMC layer will sometimes poll-wait CMD13 next, issuing
 	 * dozens of requests until the card finishes writing data.
@@ -286,15 +467,66 @@
 	 */
 
 	if (!data->stop) {
+		struct mmc_host *mmc;
+
 		host->mrq = NULL;
-		mmc_request_done(host->mmc, data->mrq);
+		mmc = host->mmc;
+		mmc_omap_release_slot(host->current_slot, 1);
+		mmc_request_done(mmc, data->mrq);
 		return;
 	}
 
+	mmc_omap_fclk_offdelay(host->current_slot);
 	mmc_omap_start_command(host, data->stop);
 }
 
 static void
+mmc_omap_send_abort(struct mmc_omap_host *host)
+{
+	struct mmc_omap_slot *slot = host->current_slot;
+	unsigned int restarts, passes, timeout;
+	u16 stat = 0;
+
+	/* Sending abort takes 80 clocks. Have some extra and round up */
+	timeout = (120*1000000 + slot->fclk_freq - 1)/slot->fclk_freq;
+	restarts = 0;
+	while (restarts < 10000) {
+		OMAP_MMC_WRITE(host, STAT, 0xFFFF);
+		OMAP_MMC_WRITE(host, CMD, (3 << 12) | (1 << 7));
+
+		passes = 0;
+		while (passes < timeout) {
+			stat = OMAP_MMC_READ(host, STAT);
+			if (stat & OMAP_MMC_STAT_END_OF_CMD)
+				goto out;
+			udelay(1);
+			passes ++;
+		}
+
+		restarts++;
+	}
+out:
+	OMAP_MMC_WRITE(host, STAT, stat);
+}
+
+static void
+mmc_omap_abort_xfer(struct mmc_omap_host *host, struct mmc_data *data)
+{
+	u16 ie;
+
+	if (host->dma_in_use)
+		mmc_omap_release_dma(host, data, 1);
+
+	host->data = NULL;
+	host->sg_len = 0;
+
+	ie = OMAP_MMC_READ(host, IE);
+	OMAP_MMC_WRITE(host, IE, 0);
+	mmc_omap_send_abort(host);
+	OMAP_MMC_WRITE(host, IE, ie);
+}
+
+static void
 mmc_omap_end_of_data(struct mmc_omap_host *host, struct mmc_data *data)
 {
 	unsigned long flags;
@@ -347,6 +579,8 @@
 {
 	host->cmd = NULL;
 
+	del_timer(&host->cmd_timer);
+
 	if (cmd->flags & MMC_RSP_PRESENT) {
 		if (cmd->flags & MMC_RSP_136) {
 			/* response type 2 */
@@ -371,10 +605,64 @@
 	}
 
 	if (host->data == NULL || cmd->error != MMC_ERR_NONE) {
+		struct mmc_host *mmc;
+
+		if (host->data != NULL)
+			mmc_omap_abort_xfer(host, host->data);
 		host->mrq = NULL;
-		clk_disable(host->fclk);
-		mmc_request_done(host->mmc, cmd->mrq);
+		mmc = host->mmc;
+		mmc_omap_release_slot(host->current_slot, 1);
+		mmc_request_done(mmc, cmd->mrq);
+	}
+}
+
+/*
+ * Abort stuck command. Can occur when card is removed while it is being
+ * read.
+ */
+static void mmc_omap_abort_command(struct work_struct *work)
+{
+	struct mmc_omap_host *host = container_of(work, struct mmc_omap_host,
+						  cmd_abort);
+	u16 ie;
+
+	ie = OMAP_MMC_READ(host, IE);
+	OMAP_MMC_WRITE(host, IE, 0);
+
+	if (!host->cmd) {
+		OMAP_MMC_WRITE(host, IE, ie);
+		return;
 	}
+
+	dev_dbg(mmc_dev(host->mmc), "Aborting stuck command CMD%d\n",
+		host->cmd->opcode);
+
+	if (host->data && host->dma_in_use)
+		mmc_omap_release_dma(host, host->data, 1);
+
+	host->data = NULL;
+	host->sg_len = 0;
+
+	mmc_omap_send_abort(host);
+	host->cmd->error = MMC_ERR_TIMEOUT;
+	mmc_omap_cmd_done(host, host->cmd);
+	OMAP_MMC_WRITE(host, IE, ie);
+}
+
+static void
+mmc_omap_cmd_timer(unsigned long data)
+{
+	struct mmc_omap_host *host = (struct mmc_omap_host *) data;
+
+	schedule_work(&host->cmd_abort);
+}
+
+static void
+mmc_omap_clk_timer(unsigned long data)
+{
+	struct mmc_omap_host *host = (struct mmc_omap_host *) data;
+
+	mmc_omap_fclk_enable(host, 0);
 }
 
 /* PIO only */
@@ -438,11 +726,12 @@
 	u16 status;
 	int end_command;
 	int end_transfer;
-	int transfer_error;
+	int transfer_error, cmd_error;
 
 	if (host->cmd == NULL && host->data == NULL) {
 		status = OMAP_MMC_READ(host, STAT);
-		dev_info(mmc_dev(host->mmc),"spurious irq 0x%04x\n", status);
+		dev_info(mmc_dev(host->slots[0]->mmc),
+			 "Spurious IRQ 0x%04x\n", status);
 		if (status != 0) {
 			OMAP_MMC_WRITE(host, STAT, status);
 			OMAP_MMC_WRITE(host, IE, 0);
@@ -453,12 +742,19 @@
 	end_command = 0;
 	end_transfer = 0;
 	transfer_error = 0;
+	cmd_error = 0;
 
 	while ((status = OMAP_MMC_READ(host, STAT)) != 0) {
+		int cmd;
+
 		OMAP_MMC_WRITE(host, STAT, status);
+		if (host->cmd != NULL)
+			cmd = host->cmd->opcode;
+		else
+			cmd = -1;
 #ifdef CONFIG_MMC_DEBUG
-		dev_dbg(mmc_dev(host->mmc), "MMC IRQ %04x (CMD %d): ",
-			status, host->cmd != NULL ? host->cmd->opcode : -1);
+		dev_dbg(mmc_dev(host->mmc), "MMC IRQ %04x (CMD%d): ",
+			status, cmd);
 		mmc_omap_report_irq(status);
 		printk("\n");
 #endif
@@ -497,17 +793,19 @@
 		if (status & OMAP_MMC_STAT_CMD_TOUT) {
 			/* Timeouts are routine with some commands */
 			if (host->cmd) {
+				struct mmc_omap_slot *slot =
+					host->current_slot;
 				if (host->cmd->opcode != MMC_ALL_SEND_CID &&
-						host->cmd->opcode !=
-						MMC_SEND_OP_COND &&
-						host->cmd->opcode !=
-						MMC_APP_CMD &&
-						!mmc_omap_cover_is_open(host))
+				    host->cmd->opcode != MMC_SEND_OP_COND &&
+				    host->cmd->opcode != MMC_APP_CMD &&
+				    (slot == NULL ||
+				     !mmc_omap_cover_is_open(slot)))
 					dev_err(mmc_dev(host->mmc),
-						"command timeout, CMD %d\n",
-						host->cmd->opcode);
+						"command timeout (CMD%d)\n",
+						cmd);
 				host->cmd->error = MMC_ERR_TIMEOUT;
 				end_command = 1;
+				cmd_error = 1;
 			}
 		}
 
@@ -515,9 +813,10 @@
 			if (host->cmd) {
 				dev_err(mmc_dev(host->mmc),
 					"command CRC error (CMD%d, arg 0x%08x)\n",
-					host->cmd->opcode, host->cmd->arg);
+					cmd, host->cmd->arg);
 				host->cmd->error = MMC_ERR_BADCRC;
 				end_command = 1;
+				cmd_error = 1;
 			} else
 				dev_err(mmc_dev(host->mmc),
 					"command CRC error without cmd?\n");
@@ -550,7 +849,7 @@
 
 		/*
 		 * NOTE: On 1610 the END_OF_CMD may come too early when
-		 * starting a write 
+		 * starting a write
 		 */
 		if ((status & OMAP_MMC_STAT_END_OF_CMD) &&
 		    (!(status & OMAP_MMC_STAT_A_EMPTY))) {
@@ -561,60 +860,60 @@
 	if (end_command) {
 		mmc_omap_cmd_done(host, host->cmd);
 	}
-	if (transfer_error)
-		mmc_omap_xfer_done(host, host->data);
-	else if (end_transfer)
-		mmc_omap_end_of_data(host, host->data);
+	if (host->data != NULL) {
+		if (transfer_error)
+			mmc_omap_xfer_done(host, host->data);
+		else if (end_transfer)
+			mmc_omap_end_of_data(host, host->data);
+	}
 
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t mmc_omap_switch_irq(int irq, void *dev_id)
+void omap_mmc_notify_cover_event(struct device *dev, int num, int is_closed)
 {
-	struct mmc_omap_host *host = (struct mmc_omap_host *) dev_id;
+	int cover_open;
+	struct mmc_omap_host *host = dev_get_drvdata(dev);
+	struct mmc_omap_slot *slot = host->slots[num];
 
-	schedule_work(&host->switch_work);
+	BUG_ON(num >= host->nr_slots);
 
-	return IRQ_HANDLED;
+	/* Other subsystems can call in here before we're initialised. */
+	if (host->nr_slots == 0 || !host->slots[num])
+		return;
+
+	cover_open = mmc_omap_cover_is_open(slot);
+	if (cover_open != slot->cover_open) {
+		slot->cover_open = cover_open;
+		sysfs_notify(&slot->mmc->class_dev.kobj, NULL, "cover_switch");
+	}
+	tasklet_hi_schedule(&slot->cover_tasklet);
 }
 
-static void mmc_omap_switch_timer(unsigned long arg)
+static void mmc_omap_cover_timer(unsigned long arg)
 {
-	struct mmc_omap_host *host = (struct mmc_omap_host *) arg;
-
-	schedule_work(&host->switch_work);
+	struct mmc_omap_slot *slot = (struct mmc_omap_slot *) arg;
+	tasklet_schedule(&slot->cover_tasklet);
 }
 
-static void mmc_omap_switch_handler(struct work_struct *work)
+static void mmc_omap_cover_handler(unsigned long param)
 {
-	struct mmc_omap_host *host = container_of(work, struct mmc_omap_host, switch_work);
-	struct mmc_card *card;
-	static int complained = 0;
-	int cards = 0, cover_open;
+	struct mmc_omap_slot *slot = (struct mmc_omap_slot *)param;
+	int cover_open = mmc_omap_cover_is_open(slot);
 
-	if (host->switch_pin == -1)
+	mmc_detect_change(slot->mmc, 0);
+
+	if (!cover_open)
 		return;
-	cover_open = mmc_omap_cover_is_open(host);
-	if (cover_open != host->switch_last_state) {
-		kobject_uevent(&host->dev->kobj, KOBJ_CHANGE);
-		host->switch_last_state = cover_open;
-	}
-	mmc_detect_change(host->mmc, 0);
-	list_for_each_entry(card, &host->mmc->cards, node) {
-		if (mmc_card_present(card))
-			cards++;
-	}
-	if (mmc_omap_cover_is_open(host)) {
-		if (!complained) {
-			dev_info(mmc_dev(host->mmc), "cover is open\n");
-			complained = 1;
-		}
-		if (mmc_omap_enable_poll)
-			mod_timer(&host->switch_timer, jiffies +
-				msecs_to_jiffies(OMAP_MMC_SWITCH_POLL_DELAY));
-	} else {
-		complained = 0;
-	}
+	/*
+	 * If no cards are inserted, we postpone polling until
+	 * the cover has been closed.
+	 */
+	if (list_empty(&slot->mmc->cards))
+		return;
+
+	mod_timer(&slot->cover_timer,
+		  jiffies + msecs_to_jiffies(OMAP_MMC_COVER_POLL_DELAY));
 }
 
 /* Prepare to transfer the next segment of a scatterlist */
@@ -785,13 +1084,12 @@
 
 static inline void set_data_timeout(struct mmc_omap_host *host, struct mmc_request *req)
 {
-	int timeout;
+	int timeout, cycle_ns;
 	u16 reg;
 
-	/* Convert ns to clock cycles by assuming 20MHz frequency
-	 * 1 cycle at 20MHz = 500 ns
-	 */
-	timeout = req->data->timeout_clks + req->data->timeout_ns / 500;
+	cycle_ns = 1000000000 / host->current_slot->fclk_freq;
+	timeout = req->data->timeout_ns / cycle_ns;
+	timeout += req->data->timeout_clks;
 
 	/* Check if we need to use timeout multiplier register */
 	reg = OMAP_MMC_READ(host, SDIO);
@@ -874,21 +1172,40 @@
 	}
 }
 
-static void mmc_omap_request(struct mmc_host *mmc, struct mmc_request *req)
+static void mmc_omap_start_request(struct mmc_omap_host *host,
+				   struct mmc_request *req)
 {
-	struct mmc_omap_host *host = mmc_priv(mmc);
-
-	WARN_ON(host->mrq != NULL);
+	BUG_ON(host->mrq != NULL);
 
 	host->mrq = req;
-
 	/* only touch fifo AFTER the controller readies it */
 	mmc_omap_prepare_data(host, req);
 	mmc_omap_start_command(host, req->cmd);
 	if (host->dma_in_use)
 		omap_start_dma(host->dma_ch);
+	BUG_ON(irqs_disabled());
 }
 
+static void mmc_omap_request(struct mmc_host *mmc, struct mmc_request *req)
+{
+	struct mmc_omap_slot *slot = mmc_priv(mmc);
+	struct mmc_omap_host *host = slot->host;
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->slot_lock, flags);
+	if (host->mmc != NULL) {
+		BUG_ON(slot->mrq != NULL);
+		slot->mrq = req;
+		spin_unlock_irqrestore(&host->slot_lock, flags);
+		return;
+	} else
+		host->mmc = mmc;
+	spin_unlock_irqrestore(&host->slot_lock, flags);
+	mmc_omap_select_slot(slot, 1);
+	mmc_omap_start_request(host, req);
+}
+
+#if 0
 static void innovator_fpga_socket_power(int on)
 {
 #if defined(CONFIG_MACH_OMAP_INNOVATOR) && defined(CONFIG_ARCH_OMAP15XX)
@@ -901,48 +1218,37 @@
 	}
 #endif
 }
+#endif
 
 /*
  * Turn the socket power on/off. Innovator uses FPGA, most boards
  * probably use GPIO.
  */
-static void mmc_omap_power(struct mmc_omap_host *host, int on)
+static void mmc_omap_set_power(struct mmc_omap_slot *slot, int power_mode,
+			       int vdd)
 {
-	if (machine_is_sx1())
-		sx1_setmmcpower(on);
-	else if (on) {
-		if (machine_is_omap_innovator())
-			innovator_fpga_socket_power(1);
-		else if (machine_is_omap_h2())
-			tps65010_set_gpio_out_value(GPIO3, HIGH);
-		else if (machine_is_omap_h3())
-			/* GPIO 4 of TPS65010 sends SD_EN signal */
-			tps65010_set_gpio_out_value(GPIO4, HIGH);
-		else if (cpu_is_omap24xx()) {
-			u16 reg = OMAP_MMC_READ(host, CON);
-			OMAP_MMC_WRITE(host, CON, reg | (1 << 11));
-		} else
-			if (host->power_pin >= 0)
-				omap_set_gpio_dataout(host->power_pin, 1);
-	} else {
-		if (machine_is_omap_innovator())
-			innovator_fpga_socket_power(0);
-		else if (machine_is_omap_h2())
-			tps65010_set_gpio_out_value(GPIO3, LOW);
-		else if (machine_is_omap_h3())
-			tps65010_set_gpio_out_value(GPIO4, LOW);
-		else if (cpu_is_omap24xx()) {
-			u16 reg = OMAP_MMC_READ(host, CON);
-			OMAP_MMC_WRITE(host, CON, reg & ~(1 << 11));
-		} else
-			if (host->power_pin >= 0)
-				omap_set_gpio_dataout(host->power_pin, 0);
+	struct mmc_omap_host *host = slot->host;
+
+	if (slot->pdata->set_power != NULL)
+		slot->pdata->set_power(mmc_dev(slot->mmc), slot->id,
+				       power_mode, vdd);
+	if (cpu_is_omap24xx()) {
+		u16 w;
+
+		if (power_mode != MMC_POWER_OFF) {
+			w = OMAP_MMC_READ(host, CON);
+			OMAP_MMC_WRITE(host, CON, w | (1 << 11));
+		} else {
+			w = OMAP_MMC_READ(host, CON);
+			OMAP_MMC_WRITE(host, CON, w & ~(1 << 11));
+		}
 	}
 }
 
 static int mmc_omap_calc_divisor(struct mmc_host *mmc, struct mmc_ios *ios)
 {
-	struct mmc_omap_host *host = mmc_priv(mmc);
+	struct mmc_omap_slot *slot = mmc_priv(mmc);
+	struct mmc_omap_host *host = slot->host;
 	int func_clk_rate = clk_get_rate(host->fclk);
 	int dsor;
 
@@ -958,7 +1264,8 @@
 
 	if (dsor > 250)
 		dsor = 250;
-	dsor++;
+
+	slot->fclk_freq = func_clk_rate / dsor;
 
 	if (ios->bus_width == MMC_BUS_WIDTH_4)
 		dsor |= 1 << 15;
@@ -968,28 +1275,49 @@
 
 static void mmc_omap_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 {
-	struct mmc_omap_host *host = mmc_priv(mmc);
-	int dsor;
+	struct mmc_omap_slot *slot = mmc_priv(mmc);
+	struct mmc_omap_host *host = slot->host;
+	int dsor, mode_change, clk_enabled;
 	int i;
 
+	mmc_omap_select_slot(slot, 0);
+
 	dsor = mmc_omap_calc_divisor(mmc, ios);
-	host->bus_mode = ios->bus_mode;
-	host->hw_bus_mode = host->bus_mode;
 
+	if (ios->power_mode == slot->power_mode ||
+	    (ios->power_mode == MMC_POWER_ON &&
+	     slot->power_mode == MMC_POWER_UP))
+		mode_change = 0;
+	else
+		mode_change = 1;
+
+	if (mode_change || slot->vdd != ios->vdd)
+		mmc_omap_set_power(slot, ios->power_mode, ios->vdd);
+
+	slot->vdd = ios->vdd;
+	slot->power_mode = ios->power_mode;
+
+	clk_enabled = 0;
 	switch (ios->power_mode) {
 	case MMC_POWER_OFF:
-		mmc_omap_power(host, 0);
 		break;
+
 	case MMC_POWER_UP:
-		/* Cannot touch dsor yet, just power up MMC */
-		mmc_omap_power(host, 1);
-		return;
+	case MMC_POWER_STANDBY:
+		goto exit;
+
 	case MMC_POWER_ON:
+		mmc_omap_fclk_enable(host, 1);
+		clk_enabled = 1;
 		dsor |= 1 << 11;
 		break;
 	}
 
-	clk_enable(host->fclk);
+	if (slot->bus_mode != ios->bus_mode) {
+		if (slot->pdata->set_bus_mode != NULL)
+			slot->pdata->set_bus_mode(mmc_dev(mmc), slot->id, ios->bus_mode);
+		slot->bus_mode = ios->bus_mode;
+	}
 
 	/* On insanely high arm_per frequencies something sometimes
 	 * goes somehow out of sync, and the POW bit is not being set,
@@ -997,22 +1325,32 @@
 	 * Writing to the CON register twice seems to do the trick. */
 	for (i = 0; i < 2; i++)
 		OMAP_MMC_WRITE(host, CON, dsor);
+	slot->saved_con = dsor;
 	if (ios->power_mode == MMC_POWER_ON) {
+		int usecs = 250;  /* 80 cycles at 400 kHz is 200 microsecs */
+
 		/* Send clock cycles, poll completion */
 		OMAP_MMC_WRITE(host, IE, 0);
 		OMAP_MMC_WRITE(host, STAT, 0xffff);
 		OMAP_MMC_WRITE(host, CMD, 1 << 7);
-		while ((OMAP_MMC_READ(host, STAT) & 1) == 0);
+		while (usecs > 0 && (OMAP_MMC_READ(host, STAT) & 1) == 0) {
+			udelay(1);
+			usecs--;
+		}
 		OMAP_MMC_WRITE(host, STAT, 1);
 	}
-	clk_disable(host->fclk);
+exit:
+	mmc_omap_release_slot(slot, clk_enabled);
 }
 
 static int mmc_omap_get_ro(struct mmc_host *mmc)
 {
-	struct mmc_omap_host *host = mmc_priv(mmc);
+	struct mmc_omap_slot *slot = mmc_priv(mmc);
 
-	return host->wp_pin && omap_get_gpio_datain(host->wp_pin);
+	if (slot->pdata->get_ro != NULL)
+		return slot->pdata->get_ro(mmc_dev(mmc), slot->id);
+
+	return 0;
 }
 
 static const struct mmc_host_ops mmc_omap_ops = {
@@ -1021,19 +1359,138 @@
 	.get_ro		= mmc_omap_get_ro,
 };
 
-static int __init mmc_omap_probe(struct platform_device *pdev)
+static int __init mmc_omap_new_slot(struct mmc_omap_host *host, int id)
 {
-	struct omap_mmc_conf *minfo = pdev->dev.platform_data;
+	struct mmc_omap_slot *slot;
 	struct mmc_host *mmc;
+	int r;
+
+	mmc = mmc_alloc_host(sizeof(struct mmc_omap_slot), host->dev);
+	if (mmc == NULL)
+		return -ENOMEM;
+
+	slot = mmc_priv(mmc);
+	slot->host = host;
+	slot->mmc = mmc;
+	slot->id = id;
+	slot->pdata = &host->pdata->slots[id];
+
+	mmc->caps = MMC_CAP_BYTEBLOCK | MMC_CAP_MULTIWRITE;
+	/* High speed modes are not officially supported. */
+	/* mmc->caps |= MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED; */
+	mmc->caps |= MMC_CAP_STANDBY;
+
+	if (host->pdata->conf.wire4)
+		mmc->caps |= MMC_CAP_4_BIT_DATA;
+
+	if (slot->pdata->ban_openended_read)
+		mmc->caps |= MMC_CAP_BAN_OPENENDED_READ;
+
+	mmc->idle_delay = 5*HZ;
+
+	mmc->ops = &mmc_omap_ops;
+	mmc->f_min = 400000;
+
+	if (cpu_class_is_omap2())
+		mmc->f_max = 48000000;
+	else
+		mmc->f_max = 24000000;
+	if (host->pdata->max_freq)
+		mmc->f_max = min(host->pdata->max_freq, mmc->f_max);
+	mmc->ocr_avail = slot->pdata->ocr_mask;
+
+	/*
+	 * Use scatterlist DMA to reduce per-transfer costs.
+	 * NOTE max_seg_size assumption that small blocks aren't
+	 * normally used (except e.g. for reading SD registers).
+	 */
+	mmc->max_phys_segs = 32;
+	mmc->max_hw_segs = 32;
+	mmc->max_blk_size = 2048;	/* BLEN is 11 bits (+1) */
+	mmc->max_blk_count = 2048;	/* NBLK is 11 bits (+1) */
+	mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
+	mmc->max_seg_size = mmc->max_req_size;
+
+	r = mmc_add_host(mmc);
+	if (r < 0)
+		return r;
+
+	if (slot->pdata->name != NULL) {
+		r = device_create_file(&mmc->class_dev, &dev_attr_slot_name);
+		if (r < 0)
+			goto err_remove_host;
+	}
+
+	if (slot->pdata->get_cover_state != NULL) {
+		r = device_create_file(&mmc->class_dev, &dev_attr_cover_switch);
+		if (r < 0)
+			goto err_remove_slot_name;
+
+		init_timer(&slot->cover_timer);
+		slot->cover_timer.function = mmc_omap_cover_timer;
+		slot->cover_timer.data = (unsigned long)slot;
+
+		tasklet_init(&slot->cover_tasklet, mmc_omap_cover_handler,
+			     (unsigned long)slot);
+		tasklet_schedule(&slot->cover_tasklet);
+	}
+
+	if (slot->pdata->get_ro != NULL) {
+		r = device_create_file(&mmc->class_dev, &dev_attr_ro);
+		if (r < 0)
+			goto err_remove_cover_attr;
+	}
+
+	host->slots[id] = slot;
+
+	return 0;
+
+err_remove_cover_attr:
+	if (slot->pdata->get_cover_state != NULL)
+		device_remove_file(&mmc->class_dev, &dev_attr_cover_switch);
+err_remove_slot_name:
+	if (slot->pdata->name != NULL)
+		device_remove_file(&mmc->class_dev, &dev_attr_ro);
+err_remove_host:
+	mmc_remove_host(mmc);
+	return r;
+}
+
+static void mmc_omap_remove_slot(struct mmc_omap_slot *slot)
+{
+	struct mmc_host *mmc = slot->mmc;
+
+	if (slot->pdata->name != NULL)
+		device_remove_file(&mmc->class_dev, &dev_attr_slot_name);
+	if (slot->pdata->get_cover_state != NULL)
+		device_remove_file(&mmc->class_dev, &dev_attr_cover_switch);
+	if (slot->pdata->get_ro != NULL)
+		device_remove_file(&mmc->class_dev, &dev_attr_ro);
+
+	tasklet_kill(&slot->cover_tasklet);
+	del_timer_sync(&slot->cover_timer);
+	flush_scheduled_work();
+
+	mmc_remove_host(mmc);
+	mmc_free_host(mmc);
+}
+
+static int __init mmc_omap_probe(struct platform_device *pdev)
+{
+	struct omap_mmc_platform_data  *pdata = pdev->dev.platform_data;
 	struct mmc_omap_host *host = NULL;
 	struct resource *res;
-	int ret = 0;
+	int i, ret = 0;
 	int irq;
 
-	if (minfo == NULL) {
+	if (pdata == NULL) {
 		dev_err(&pdev->dev, "platform data missing\n");
 		return -ENXIO;
 	}
+	if (pdata->nr_slots == 0) {
+		dev_err(&pdev->dev, "no slots\n");
+		return -ENXIO;
+	}
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	irq = platform_get_irq(pdev, 0);
@@ -1041,28 +1498,46 @@
 		return -ENXIO;
 
 	res = request_mem_region(res->start, res->end - res->start + 1,
-			         pdev->name);
+				 pdev->name);
 	if (res == NULL)
 		return -EBUSY;
 
-	mmc = mmc_alloc_host(sizeof(struct mmc_omap_host), &pdev->dev);
-	if (mmc == NULL) {
+	host = kzalloc(sizeof(struct mmc_omap_host), GFP_KERNEL);
+	if (host == NULL) {
 		ret = -ENOMEM;
 		goto err_free_mem_region;
 	}
 
-	host = mmc_priv(mmc);
-	host->mmc = mmc;
+	INIT_WORK(&host->cmd_abort, mmc_omap_abort_command);
+	setup_timer(&host->cmd_timer, mmc_omap_cmd_timer,
+		    (unsigned long) host);
+
+	spin_lock_init(&host->clk_lock);
+	setup_timer(&host->clk_timer, mmc_omap_clk_timer, (unsigned long) host);
 
 	spin_lock_init(&host->dma_lock);
 	init_timer(&host->dma_timer);
+	spin_lock_init(&host->slot_lock);
+	init_waitqueue_head(&host->slot_wq);
+
 	host->dma_timer.function = mmc_omap_dma_timer;
 	host->dma_timer.data = (unsigned long) host;
 
+	host->pdata = pdata;
+	host->dev = &pdev->dev;
+	platform_set_drvdata(pdev, host);
+
 	host->id = pdev->id;
 	host->mem_res = res;
 	host->irq = irq;
 
+	host->use_dma = 1;
+	host->dma_ch = -1;
+
+	host->irq = irq;
+	host->phys_base = host->mem_res->start;
+	host->virt_base = (void __iomem *) IO_ADDRESS(host->phys_base);
+
 	if (cpu_is_omap24xx()) {
 		host->iclk = clk_get(&pdev->dev, "mmc_ick");
 		if (IS_ERR(host->iclk))
@@ -1080,109 +1555,34 @@
 		goto err_free_iclk;
 	}
 
-	/* REVISIT:
-	 * Also, use minfo->cover to decide how to manage
-	 * the card detect sensing.
-	 */
-	host->power_pin = minfo->power_pin;
-	host->switch_pin = minfo->switch_pin;
-	host->wp_pin = minfo->wp_pin;
-	host->use_dma = 1;
-	host->dma_ch = -1;
-
-	host->irq = irq;
-	host->phys_base = host->mem_res->start;
-	host->virt_base = (void __iomem *) IO_ADDRESS(host->phys_base);
-
-	mmc->ops = &mmc_omap_ops;
-	mmc->f_min = 400000;
-	mmc->f_max = 24000000;
-	mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
-	mmc->caps = MMC_CAP_MULTIWRITE | MMC_CAP_BYTEBLOCK;
-
-	if (minfo->wire4)
-		 mmc->caps |= MMC_CAP_4_BIT_DATA;
-
-	/* Use scatterlist DMA to reduce per-transfer costs.
-	 * NOTE max_seg_size assumption that small blocks aren't
-	 * normally used (except e.g. for reading SD registers).
-	 */
-	mmc->max_phys_segs = 32;
-	mmc->max_hw_segs = 32;
-	mmc->max_blk_size = 2048;	/* BLEN is 11 bits (+1) */
-	mmc->max_blk_count = 2048;	/* NBLK is 11 bits (+1) */
-	mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
-	mmc->max_seg_size = mmc->max_req_size;
-
-	if (host->power_pin >= 0) {
-		if ((ret = omap_request_gpio(host->power_pin)) != 0) {
-			dev_err(mmc_dev(host->mmc),
-				"Unable to get GPIO pin for MMC power\n");
-			goto err_free_fclk;
-		}
-		omap_set_gpio_direction(host->power_pin, 0);
-	}
-
 	ret = request_irq(host->irq, mmc_omap_irq, 0, DRIVER_NAME, host);
 	if (ret)
-		goto err_free_power_gpio;
+		goto err_free_fclk;
 
-	host->dev = &pdev->dev;
-	platform_set_drvdata(pdev, host);
+	if (pdata->init != NULL) {
+		ret = pdata->init(&pdev->dev);
+		if (ret < 0)
+			goto err_free_irq;
+	}
+
+	host->nr_slots = pdata->nr_slots;
+	for (i = 0; i < pdata->nr_slots; i++) {
+		ret = mmc_omap_new_slot(host, i);
+		if (ret < 0) {
+			while (--i >= 0)
+				mmc_omap_remove_slot(host->slots[i]);
 
-	if (host->switch_pin >= 0) {
-		INIT_WORK(&host->switch_work, mmc_omap_switch_handler);
-		init_timer(&host->switch_timer);
-		host->switch_timer.function = mmc_omap_switch_timer;
-		host->switch_timer.data = (unsigned long) host;
-		if (omap_request_gpio(host->switch_pin) != 0) {
-			dev_warn(mmc_dev(host->mmc), "Unable to get GPIO pin for MMC cover switch\n");
-			host->switch_pin = -1;
-			goto no_switch;
-		}
-
-		omap_set_gpio_direction(host->switch_pin, 1);
-		ret = request_irq(OMAP_GPIO_IRQ(host->switch_pin),
-				  mmc_omap_switch_irq, IRQF_TRIGGER_RISING, DRIVER_NAME, host);
-		if (ret) {
-			dev_warn(mmc_dev(host->mmc), "Unable to get IRQ for MMC cover switch\n");
-			omap_free_gpio(host->switch_pin);
-			host->switch_pin = -1;
-			goto no_switch;
-		}
-		ret = device_create_file(&pdev->dev, &dev_attr_cover_switch);
-		if (ret == 0) {
-			ret = device_create_file(&pdev->dev, &dev_attr_enable_poll);
-			if (ret != 0)
-				device_remove_file(&pdev->dev, &dev_attr_cover_switch);
-		}
-		if (ret) {
-			dev_warn(mmc_dev(host->mmc), "Unable to create sysfs attributes\n");
-			free_irq(OMAP_GPIO_IRQ(host->switch_pin), host);
-			omap_free_gpio(host->switch_pin);
-			host->switch_pin = -1;
-			goto no_switch;
+			goto err_plat_cleanup;
 		}
-		if (mmc_omap_enable_poll && mmc_omap_cover_is_open(host))
-			schedule_work(&host->switch_work);
 	}
 
-	mmc_add_host(mmc);
-
 	return 0;
 
-no_switch:
-	/* FIXME: Free other resources too. */
-	if (host) {
-		if (host->iclk && !IS_ERR(host->iclk))
-			clk_put(host->iclk);
-		if (host->fclk && !IS_ERR(host->fclk))
-			clk_put(host->fclk);
-		mmc_free_host(host->mmc);
-	}
-err_free_power_gpio:
-	if (host->power_pin >= 0)
-		omap_free_gpio(host->power_pin);
+err_plat_cleanup:
+	if (pdata->cleanup)
+		pdata->cleanup(&pdev->dev);
+err_free_irq:
+	free_irq(host->irq, host);
 err_free_fclk:
 	clk_put(host->fclk);
 err_free_iclk:
@@ -1191,34 +1591,42 @@
 		clk_put(host->iclk);
 	}
 err_free_mmc_host:
-	mmc_free_host(host->mmc);
+	kfree(host);
 err_free_mem_region:
 	release_mem_region(res->start, res->end - res->start + 1);
 	return ret;
 }
 
+static void mmc_omap_shutdown(struct platform_device *pdev)
+{
+	struct mmc_omap_host *host = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < host->nr_slots; i++) {
+		struct mmc_omap_slot *slot = host->slots[i];
+		struct mmc_host *mmc = slot->mmc;
+
+		mmc_shutdown_host(mmc);
+	}
+}
+
 static int mmc_omap_remove(struct platform_device *pdev)
 {
 	struct mmc_omap_host *host = platform_get_drvdata(pdev);
+	int i;
 
 	platform_set_drvdata(pdev, NULL);
 
 	BUG_ON(host == NULL);
 
-	mmc_remove_host(host->mmc);
+	for (i = 0; i < host->nr_slots; i++)
+		mmc_omap_remove_slot(host->slots[i]);
+
+	if (host->pdata->cleanup)
+		host->pdata->cleanup(&pdev->dev);
+
 	free_irq(host->irq, host);
 
-	if (host->power_pin >= 0)
-		omap_free_gpio(host->power_pin);
-	if (host->switch_pin >= 0) {
-		device_remove_file(&pdev->dev, &dev_attr_enable_poll);
-		device_remove_file(&pdev->dev, &dev_attr_cover_switch);
-		free_irq(OMAP_GPIO_IRQ(host->switch_pin), host);
-		omap_free_gpio(host->switch_pin);
-		host->switch_pin = -1;
-		del_timer_sync(&host->switch_timer);
-		flush_scheduled_work();
-	}
 	if (host->iclk && !IS_ERR(host->iclk))
 		clk_put(host->iclk);
 	if (host->fclk && !IS_ERR(host->fclk))
@@ -1226,8 +1634,7 @@
 
 	release_mem_region(pdev->resource[0].start,
 			   pdev->resource[0].end - pdev->resource[0].start + 1);
-
-	mmc_free_host(host->mmc);
+	kfree(host);
 
 	return 0;
 }
@@ -1235,35 +1642,49 @@
 #ifdef CONFIG_PM
 static int mmc_omap_suspend(struct platform_device *pdev, pm_message_t mesg)
 {
-	int ret = 0;
+	int i, ret = 0;
 	struct mmc_omap_host *host = platform_get_drvdata(pdev);
 
-	if (host && host->suspended)
+	if (host == NULL || host->suspended)
 		return 0;
 
-	if (host) {
-		ret = mmc_suspend_host(host->mmc, mesg);
-		if (ret == 0)
-			host->suspended = 1;
+	for (i = 0; i < host->nr_slots; i++) {
+		struct mmc_omap_slot *slot;
+
+		slot = host->slots[i];
+		ret = mmc_suspend_host(slot->mmc, mesg);
+		if (ret < 0) {
+			while (--i >= 0) {
+				slot = host->slots[i];
+				mmc_resume_host(slot->mmc);
+			}
+			return ret;
+		}
 	}
-	return ret;
+
+	host->suspended = 1;
+	return 0;
 }
 
 static int mmc_omap_resume(struct platform_device *pdev)
 {
-	int ret = 0;
+	int i, ret = 0;
 	struct mmc_omap_host *host = platform_get_drvdata(pdev);
 
-	if (host && !host->suspended)
+	if (host == NULL || !host->suspended)
 		return 0;
 
-	if (host) {
-		ret = mmc_resume_host(host->mmc);
-		if (ret == 0)
-			host->suspended = 0;
-	}
+	for (i = 0; i < host->nr_slots; i++) {
+		struct mmc_omap_slot *slot;
 
-	return ret;
+		slot = host->slots[i];
+		ret = mmc_resume_host(slot->mmc);
+		if (ret < 0)
+			return ret;
+
+		host->suspended = 0;
+	}
+	return 0;
 }
 #else
 #define mmc_omap_suspend	NULL
@@ -1275,6 +1696,7 @@
 	.remove		= mmc_omap_remove,
 	.suspend	= mmc_omap_suspend,
 	.resume		= mmc_omap_resume,
+	.shutdown       = mmc_omap_shutdown,
 	.driver		= {
 		.name	= DRIVER_NAME,
 	},
diff -ruN linux-omap-2.6/drivers/mmc/sdhci.c maemo_src/drivers/mmc/sdhci.c
--- linux-omap-2.6/drivers/mmc/sdhci.c	2011-02-06 19:44:58.663333273 -0500
+++ maemo_src/drivers/mmc/sdhci.c	2011-02-06 20:12:12.603333272 -0500
@@ -1,7 +1,7 @@
 /*
  *  linux/drivers/mmc/sdhci.c - Secure Digital Host Controller Interface driver
  *
- *  Copyright (C) 2005-2006 Pierre Ossman, All Rights Reserved.
+ *  Copyright (C) 2005-2007 Pierre Ossman, All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -247,14 +247,13 @@
 			chunk_remain = min(blksize, 4);
 		}
 
-		size = min(host->size, host->remain);
-		size = min(size, chunk_remain);
+		size = min(host->remain, chunk_remain);
 
 		chunk_remain -= size;
 		blksize -= size;
 		host->offset += size;
 		host->remain -= size;
-		host->size -= size;
+
 		while (size) {
 			*buffer = data & 0xFF;
 			buffer++;
@@ -289,14 +288,13 @@
 	buffer = sdhci_sg_to_buffer(host) + host->offset;
 
 	while (blksize) {
-		size = min(host->size, host->remain);
-		size = min(size, chunk_remain);
+		size = min(host->remain, chunk_remain);
 
 		chunk_remain -= size;
 		blksize -= size;
 		host->offset += size;
 		host->remain -= size;
-		host->size -= size;
+
 		while (size) {
 			data >>= 8;
 			data |= (u32)*buffer << 24;
@@ -325,7 +323,7 @@
 
 	BUG_ON(!host->data);
 
-	if (host->size == 0)
+	if (host->num_sg == 0)
 		return;
 
 	if (host->data->flags & MMC_DATA_READ)
@@ -339,10 +337,8 @@
 		else
 			sdhci_write_block_pio(host);
 
-		if (host->size == 0)
+		if (host->num_sg == 0)
 			break;
-
-		BUG_ON(host->num_sg == 0);
 	}
 
 	DBG("PIO transfer complete.\n");
@@ -408,8 +404,6 @@
 
 		writel(sg_dma_address(data->sg), host->ioaddr + SDHCI_DMA_ADDRESS);
 	} else {
-		host->size = data->blksz * data->blocks;
-
 		host->cur_sg = data->sg;
 		host->num_sg = data->sg_len;
 
@@ -473,10 +467,6 @@
 			"though there were blocks left.\n",
 			mmc_hostname(host->mmc));
 		data->error = MMC_ERR_FAILED;
-	} else if (host->size != 0) {
-		printk(KERN_ERR "%s: %d bytes were left untransferred.\n",
-			mmc_hostname(host->mmc), host->size);
-		data->error = MMC_ERR_FAILED;
 	}
 
 	DBG("Ending data transfer (%d bytes)\n", data->bytes_xfered);
diff -ruN linux-omap-2.6/drivers/mmc/sdhci.h maemo_src/drivers/mmc/sdhci.h
--- linux-omap-2.6/drivers/mmc/sdhci.h	2011-02-06 19:44:58.663333273 -0500
+++ maemo_src/drivers/mmc/sdhci.h	2011-02-06 20:12:12.573333271 -0500
@@ -1,7 +1,7 @@
 /*
  *  linux/drivers/mmc/sdhci.h - Secure Digital Host Controller Interface driver
  *
- *  Copyright (C) 2005 Pierre Ossman, All Rights Reserved.
+ *  Copyright (C) 2005-2007 Pierre Ossman, All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -187,8 +187,6 @@
 	int			offset;		/* Offset into current sg */
 	int			remain;		/* Bytes left in current */
 
-	int			size;		/* Remaining bytes in transfer */
-
 	char			slot_descr[20];	/* Name for reservations */
 
 	int			irq;		/* Device IRQ */
diff -ruN linux-omap-2.6/drivers/mmc/wbsd.c maemo_src/drivers/mmc/wbsd.c
--- linux-omap-2.6/drivers/mmc/wbsd.c	2011-02-06 19:44:58.666666606 -0500
+++ maemo_src/drivers/mmc/wbsd.c	2011-02-06 20:12:12.593333273 -0500
@@ -1,7 +1,7 @@
 /*
  *  linux/drivers/mmc/wbsd.c - Winbond W83L51xD SD/MMC driver
  *
- *  Copyright (C) 2004-2006 Pierre Ossman, All Rights Reserved.
+ *  Copyright (C) 2004-2007 Pierre Ossman, All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -278,90 +278,36 @@
 
 static inline void wbsd_sg_to_dma(struct wbsd_host *host, struct mmc_data *data)
 {
-	unsigned int len, i, size;
+	unsigned int len, i;
 	struct scatterlist *sg;
 	char *dmabuf = host->dma_buffer;
 	char *sgbuf;
 
-	size = host->size;
-
 	sg = data->sg;
 	len = data->sg_len;
 
-	/*
-	 * Just loop through all entries. Size might not
-	 * be the entire list though so make sure that
-	 * we do not transfer too much.
-	 */
 	for (i = 0; i < len; i++) {
 		sgbuf = page_address(sg[i].page) + sg[i].offset;
-		if (size < sg[i].length)
-			memcpy(dmabuf, sgbuf, size);
-		else
-			memcpy(dmabuf, sgbuf, sg[i].length);
+		memcpy(dmabuf, sgbuf, sg[i].length);
 		dmabuf += sg[i].length;
-
-		if (size < sg[i].length)
-			size = 0;
-		else
-			size -= sg[i].length;
-
-		if (size == 0)
-			break;
 	}
-
-	/*
-	 * Check that we didn't get a request to transfer
-	 * more data than can fit into the SG list.
-	 */
-
-	BUG_ON(size != 0);
-
-	host->size -= size;
 }
 
 static inline void wbsd_dma_to_sg(struct wbsd_host *host, struct mmc_data *data)
 {
-	unsigned int len, i, size;
+	unsigned int len, i;
 	struct scatterlist *sg;
 	char *dmabuf = host->dma_buffer;
 	char *sgbuf;
 
-	size = host->size;
-
 	sg = data->sg;
 	len = data->sg_len;
 
-	/*
-	 * Just loop through all entries. Size might not
-	 * be the entire list though so make sure that
-	 * we do not transfer too much.
-	 */
 	for (i = 0; i < len; i++) {
 		sgbuf = page_address(sg[i].page) + sg[i].offset;
-		if (size < sg[i].length)
-			memcpy(sgbuf, dmabuf, size);
-		else
-			memcpy(sgbuf, dmabuf, sg[i].length);
+		memcpy(sgbuf, dmabuf, sg[i].length);
 		dmabuf += sg[i].length;
-
-		if (size < sg[i].length)
-			size = 0;
-		else
-			size -= sg[i].length;
-
-		if (size == 0)
-			break;
 	}
-
-	/*
-	 * Check that we didn't get a request to transfer
-	 * more data than can fit into the SG list.
-	 */
-
-	BUG_ON(size != 0);
-
-	host->size -= size;
 }
 
 /*
@@ -484,7 +430,7 @@
 	/*
 	 * Handle excessive data.
 	 */
-	if (data->bytes_xfered == host->size)
+	if (host->num_sg == 0)
 		return;
 
 	buffer = wbsd_sg_to_buffer(host) + host->offset;
@@ -514,31 +460,14 @@
 			data->bytes_xfered++;
 
 			/*
-			 * Transfer done?
-			 */
-			if (data->bytes_xfered == host->size)
-				return;
-
-			/*
 			 * End of scatter list entry?
 			 */
 			if (host->remain == 0) {
 				/*
 				 * Get next entry. Check if last.
 				 */
-				if (!wbsd_next_sg(host)) {
-					/*
-					 * We should never reach this point.
-					 * It means that we're trying to
-					 * transfer more blocks than can fit
-					 * into the scatter list.
-					 */
-					BUG_ON(1);
-
-					host->size = data->bytes_xfered;
-
+				if (!wbsd_next_sg(host))
 					return;
-				}
 
 				buffer = wbsd_sg_to_buffer(host);
 			}
@@ -550,7 +479,7 @@
 	 * hardware problem. The chip doesn't trigger
 	 * FIFO threshold interrupts properly.
 	 */
-	if ((host->size - data->bytes_xfered) < 16)
+	if ((data->blocks * data->blksz - data->bytes_xfered) < 16)
 		tasklet_schedule(&host->fifo_tasklet);
 }
 
@@ -564,7 +493,7 @@
 	 * Check that we aren't being called after the
 	 * entire buffer has been transfered.
 	 */
-	if (data->bytes_xfered == host->size)
+	if (host->num_sg == 0)
 		return;
 
 	buffer = wbsd_sg_to_buffer(host) + host->offset;
@@ -594,31 +523,14 @@
 			data->bytes_xfered++;
 
 			/*
-			 * Transfer done?
-			 */
-			if (data->bytes_xfered == host->size)
-				return;
-
-			/*
 			 * End of scatter list entry?
 			 */
 			if (host->remain == 0) {
 				/*
 				 * Get next entry. Check if last.
 				 */
-				if (!wbsd_next_sg(host)) {
-					/*
-					 * We should never reach this point.
-					 * It means that we're trying to
-					 * transfer more blocks than can fit
-					 * into the scatter list.
-					 */
-					BUG_ON(1);
-
-					host->size = data->bytes_xfered;
-
+				if (!wbsd_next_sg(host))
 					return;
-				}
 
 				buffer = wbsd_sg_to_buffer(host);
 			}
@@ -638,6 +550,7 @@
 	u16 blksize;
 	u8 setup;
 	unsigned long dmaflags;
+	unsigned int size;
 
 	DBGF("blksz %04x blks %04x flags %08x\n",
 		data->blksz, data->blocks, data->flags);
@@ -647,7 +560,7 @@
 	/*
 	 * Calculate size.
 	 */
-	host->size = data->blocks * data->blksz;
+	size = data->blocks * data->blksz;
 
 	/*
 	 * Check timeout values for overflow.
@@ -705,8 +618,8 @@
 		/*
 		 * The buffer for DMA is only 64 kB.
 		 */
-		BUG_ON(host->size > 0x10000);
-		if (host->size > 0x10000) {
+		BUG_ON(size > 0x10000);
+		if (size > 0x10000) {
 			data->error = MMC_ERR_INVALID;
 			return;
 		}
@@ -729,7 +642,7 @@
 		else
 			set_dma_mode(host->dma, DMA_MODE_WRITE & ~0x40);
 		set_dma_addr(host->dma, host->dma_addr);
-		set_dma_count(host->dma, host->size);
+		set_dma_count(host->dma, size);
 
 		enable_dma(host->dma);
 		release_dma_lock(dmaflags);
@@ -812,6 +725,10 @@
 		count = get_dma_residue(host->dma);
 		release_dma_lock(dmaflags);
 
+		data->bytes_xfered = host->mrq->data->blocks *
+			host->mrq->data->blksz - count;
+		data->bytes_xfered -= data->bytes_xfered % data->blksz;
+
 		/*
 		 * Any leftover data?
 		 */
@@ -820,7 +737,8 @@
 				"%d bytes left.\n",
 				mmc_hostname(host->mmc), count);
 
-			data->error = MMC_ERR_FAILED;
+			if (data->error == MMC_ERR_NONE)
+				data->error = MMC_ERR_FAILED;
 		} else {
 			/*
 			 * Transfer data from DMA buffer to
@@ -828,8 +746,11 @@
 			 */
 			if (data->flags & MMC_DATA_READ)
 				wbsd_dma_to_sg(host, data);
+		}
 
-			data->bytes_xfered = host->size;
+		if (data->error != MMC_ERR_NONE) {
+			if (data->bytes_xfered)
+				data->bytes_xfered -= data->blksz;
 		}
 	}
 
@@ -1167,7 +1088,7 @@
 	/*
 	 * Done?
 	 */
-	if (host->size == data->bytes_xfered) {
+	if (host->num_sg == 0) {
 		wbsd_write_index(host, WBSD_IDX_FIFOEN, 0);
 		tasklet_schedule(&host->finish_tasklet);
 	}
diff -ruN linux-omap-2.6/drivers/mmc/wbsd.h maemo_src/drivers/mmc/wbsd.h
--- linux-omap-2.6/drivers/mmc/wbsd.h	2011-02-06 19:44:58.666666606 -0500
+++ maemo_src/drivers/mmc/wbsd.h	2011-02-06 20:12:12.646666607 -0500
@@ -1,7 +1,7 @@
 /*
  *  linux/drivers/mmc/wbsd.h - Winbond W83L51xD SD/MMC driver
  *
- *  Copyright (C) 2004-2005 Pierre Ossman, All Rights Reserved.
+ *  Copyright (C) 2004-2007 Pierre Ossman, All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -158,8 +158,6 @@
 	unsigned int		offset;		/* Offset into current entry */
 	unsigned int		remain;		/* Data left in curren entry */
 
-	int			size;		/* Total size of transfer */
-
 	char*			dma_buffer;	/* ISA DMA buffer */
 	dma_addr_t		dma_addr;	/* Physical address for same */
 
diff -ruN linux-omap-2.6/drivers/mtd/Kconfig maemo_src/drivers/mtd/Kconfig
--- linux-omap-2.6/drivers/mtd/Kconfig	2011-02-06 19:44:58.666666606 -0500
+++ maemo_src/drivers/mtd/Kconfig	2011-02-06 20:12:13.216666607 -0500
@@ -282,6 +282,17 @@
 	  This enables read only access to SmartMedia formatted NAND
 	  flash. You can mount it with FAT file system.
 
+config MTD_OOPS
+	tristate "Log panic/oops to an MTD buffer"
+	depends on MTD
+	help
+	  This enables panic and oops messages to be logged to a circular
+	  buffer in a flash partition where it can be read back at some
+	  later point.
+
+	  To use, add console=ttyMTDx to the kernel command line,
+	  where x is the MTD device number to use.
+
 source "drivers/mtd/chips/Kconfig"
 
 source "drivers/mtd/maps/Kconfig"
diff -ruN linux-omap-2.6/drivers/mtd/Makefile maemo_src/drivers/mtd/Makefile
--- linux-omap-2.6/drivers/mtd/Makefile	2011-02-06 19:44:58.666666606 -0500
+++ maemo_src/drivers/mtd/Makefile	2007-10-02 03:09:31.000000000 -0400
@@ -23,6 +23,7 @@
 obj-$(CONFIG_INFTL)		+= inftl.o
 obj-$(CONFIG_RFD_FTL)		+= rfd_ftl.o
 obj-$(CONFIG_SSFDC)		+= ssfdc.o
+obj-$(CONFIG_MTD_OOPS)		+= mtdoops.o
 
 nftl-objs		:= nftlcore.o nftlmount.o
 inftl-objs		:= inftlcore.o inftlmount.o
diff -ruN linux-omap-2.6/drivers/mtd/mtdoops.c maemo_src/drivers/mtd/mtdoops.c
--- linux-omap-2.6/drivers/mtd/mtdoops.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/mtd/mtdoops.c	2011-02-06 20:12:13.166666607 -0500
@@ -0,0 +1,442 @@
+/*
+ * MTD Oops/Panic logger
+ *
+ * Copyright (C) 2007 Nokia Corporation. All rights reserved.
+ *
+ * Author: Richard Purdie <rpurdie@openedhand.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/console.h>
+#include <linux/vmalloc.h>
+#include <linux/workqueue.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/mtd/mtd.h>
+
+#define MTDOOPS_KERNMSG_MAGIC 0x5d005d00
+#define OOPS_PAGE_SIZE 4096
+
+struct mtdoops_context {
+	int mtd_index;
+	struct work_struct work_erase;
+	struct work_struct work_write;
+	struct mtd_info *mtd;
+	int oops_pages;
+	int nextpage;
+	int nextcount;
+
+	void *oops_buf;
+
+	/* writecount and disabling ready are spin lock protected */
+	spinlock_t writecount_lock;
+	int ready;
+	int writecount;
+} oops_cxt;
+
+static void mtdoops_erase_callback(struct erase_info *done)
+{
+	wait_queue_head_t *wait_q = (wait_queue_head_t *)done->priv;
+	wake_up(wait_q);
+}
+
+static int mtdoops_erase_block(struct mtd_info *mtd, int offset)
+{
+	struct erase_info erase;
+	DECLARE_WAITQUEUE(wait, current);
+	wait_queue_head_t wait_q;
+	int ret;
+
+	init_waitqueue_head(&wait_q);
+	erase.mtd = mtd;
+	erase.callback = mtdoops_erase_callback;
+	erase.addr = offset;
+	erase.len = mtd->erasesize;
+	erase.priv = (u_long)&wait_q;
+
+	set_current_state(TASK_INTERRUPTIBLE);
+	add_wait_queue(&wait_q, &wait);
+
+	ret = mtd->erase(mtd, &erase);
+	if (ret) {
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&wait_q, &wait);
+		printk (KERN_WARNING "mtdoops: erase of region [0x%x, 0x%x] "
+				     "on \"%s\" failed\n",
+			erase.addr, erase.len, mtd->name);
+		return ret;
+	}
+
+	schedule();  /* Wait for erase to finish. */
+	remove_wait_queue(&wait_q, &wait);
+
+	return 0;
+}
+
+static void mtdoops_inc_counter(struct mtdoops_context *cxt)
+{
+	struct mtd_info *mtd = cxt->mtd;
+	size_t retlen;
+	u32 count;
+	int ret;
+
+	cxt->nextpage++;
+	if (cxt->nextpage >= cxt->oops_pages)
+		cxt->nextpage = 0;
+	cxt->nextcount++;
+	if (cxt->nextcount == 0xffffffff)
+		cxt->nextcount = 0;
+
+	ret = mtd->read(mtd, cxt->nextpage * OOPS_PAGE_SIZE, 4,
+			&retlen, (u_char *) &count);
+	if ((retlen != 4) || ((ret < 0) && (ret != -EUCLEAN))) {
+		printk(KERN_ERR "mtdoops: Read failure at %d (%td of 4 read)"
+				", err %d.\n", cxt->nextpage * OOPS_PAGE_SIZE,
+				retlen, ret);
+		schedule_work(&cxt->work_erase);
+		return;
+	}
+
+	/* See if we need to erase the next block */
+	if (count != 0xffffffff) {
+		schedule_work(&cxt->work_erase);
+		return;
+	}
+
+	printk(KERN_DEBUG "mtdoops: Ready %d, %d (no erase)\n",
+			cxt->nextpage, cxt->nextcount);
+	cxt->ready = 1;
+}
+
+/* Scheduled work - when we can't proceed without erasing a block */
+static void mtdoops_workfunc_erase(struct work_struct *work)
+{
+	struct mtdoops_context *cxt =
+			container_of(work, struct mtdoops_context, work_erase);
+	struct mtd_info *mtd = cxt->mtd;
+	int i = 0, j, ret, mod;
+
+	/* We were unregistered */
+	if (!mtd)
+		return;
+
+	mod = (cxt->nextpage * OOPS_PAGE_SIZE) % mtd->erasesize;
+	if (mod != 0) {
+		cxt->nextpage = cxt->nextpage + ((mtd->erasesize - mod) / OOPS_PAGE_SIZE);
+		if (cxt->nextpage >= cxt->oops_pages)
+			cxt->nextpage = 0;
+	}
+
+	while (mtd->block_isbad) {
+		ret = mtd->block_isbad(mtd, cxt->nextpage * OOPS_PAGE_SIZE);
+		if (!ret)
+			break;
+		if (ret < 0) {
+			printk(KERN_ERR "mtdoops: block_isbad failed, aborting.\n");
+			return;
+		}
+badblock:
+		printk(KERN_WARNING "mtdoops: Bad block at %08x\n",
+				cxt->nextpage * OOPS_PAGE_SIZE);
+		i++;
+		cxt->nextpage = cxt->nextpage + (mtd->erasesize / OOPS_PAGE_SIZE);
+		if (cxt->nextpage >= cxt->oops_pages)
+			cxt->nextpage = 0;
+		if (i == (cxt->oops_pages / (mtd->erasesize / OOPS_PAGE_SIZE))) {
+			printk(KERN_ERR "mtdoops: All blocks bad!\n");
+			return;
+		}
+	}
+
+	for (j = 0, ret = -1; (j < 3) && (ret < 0); j++)
+		ret = mtdoops_erase_block(mtd, cxt->nextpage * OOPS_PAGE_SIZE);
+
+	if (ret >= 0) {
+		printk(KERN_DEBUG "mtdoops: Ready %d, %d \n", cxt->nextpage, cxt->nextcount);
+		cxt->ready = 1;
+		return;
+	}
+
+	if (mtd->block_markbad && (ret == -EIO)) {
+		ret = mtd->block_markbad(mtd, cxt->nextpage * OOPS_PAGE_SIZE);
+		if (ret < 0) {
+			printk(KERN_ERR "mtdoops: block_markbad failed, aborting.\n");
+			return;
+		}
+	}
+	goto badblock;
+}
+
+static void mtdoops_write(struct mtdoops_context *cxt, int panic)
+{
+	struct mtd_info *mtd = cxt->mtd;
+	size_t retlen;
+	int ret;
+
+	if (cxt->writecount < OOPS_PAGE_SIZE)
+		memset(cxt->oops_buf + cxt->writecount, 0xff,
+					OOPS_PAGE_SIZE - cxt->writecount);
+
+	if (panic)
+		ret = mtd->panic_write(mtd, cxt->nextpage * OOPS_PAGE_SIZE,
+					OOPS_PAGE_SIZE, &retlen, cxt->oops_buf);
+	else
+		ret = mtd->write(mtd, cxt->nextpage * OOPS_PAGE_SIZE,
+					OOPS_PAGE_SIZE, &retlen, cxt->oops_buf);
+
+	cxt->writecount = 0;
+
+	if ((retlen != OOPS_PAGE_SIZE) || (ret < 0))
+		printk(KERN_ERR "mtdoops: Write failure at %d (%td of %d written), err %d.\n",
+			cxt->nextpage * OOPS_PAGE_SIZE, retlen,	OOPS_PAGE_SIZE, ret);
+
+	mtdoops_inc_counter(cxt);
+}
+
+
+static void mtdoops_workfunc_write(struct work_struct *work)
+{
+	struct mtdoops_context *cxt =
+			container_of(work, struct mtdoops_context, work_write);
+
+	mtdoops_write(cxt, 0);
+}					
+
+static void find_next_position(struct mtdoops_context *cxt)
+{
+	struct mtd_info *mtd = cxt->mtd;
+	int ret, page, maxpos = 0;
+	u32 count[2], maxcount = 0xffffffff;
+	size_t retlen;
+
+	for (page = 0; page < cxt->oops_pages; page++) {
+		ret = mtd->read(mtd, page * OOPS_PAGE_SIZE, 8, &retlen, (u_char *) &count[0]);
+		if ((retlen != 8) || ((ret < 0) && (ret != -EUCLEAN))) {
+			printk(KERN_ERR "mtdoops: Read failure at %d (%td of 8 read)"
+				", err %d.\n", page * OOPS_PAGE_SIZE, retlen, ret);
+			continue;
+		}
+
+		if (count[1] != MTDOOPS_KERNMSG_MAGIC)
+			continue;
+		if (count[0] == 0xffffffff)
+			continue;
+
+		if (maxcount == 0xffffffff) {
+			maxcount = count[0];
+			maxpos = page;
+		} else if ((count[0] < 0x40000000) && (maxcount > 0xc0000000)) {
+			maxcount = count[0];
+			maxpos = page;
+		} else if ((count[0] > maxcount) && (count[0] < 0xc0000000)) {
+			maxcount = count[0];
+			maxpos = page;
+		} else if ((count[0] > maxcount) && (count[0] > 0xc0000000)
+					&& (maxcount > 0x80000000)) {
+			maxcount = count[0];
+			maxpos = page;
+		}
+	}
+	if (maxcount == 0xffffffff) {
+		cxt->nextpage = 0;
+		cxt->nextcount = 1;
+		schedule_work(&cxt->work_erase);
+		return;
+	}
+
+	cxt->nextpage = maxpos;
+	cxt->nextcount = maxcount;
+
+	mtdoops_inc_counter(cxt);
+}
+
+
+static void mtdoops_notify_add(struct mtd_info *mtd)
+{
+	struct mtdoops_context *cxt = &oops_cxt;
+
+	if ((mtd->index != cxt->mtd_index) || cxt->mtd_index < 0)
+		return;
+
+	if (mtd->size < (mtd->erasesize * 2)) {
+		printk(KERN_ERR "MTD partition %d not big enough for mtdoops\n",
+				mtd->index);
+		return;
+	}
+
+	if (mtd->erasesize < OOPS_PAGE_SIZE) {
+		printk(KERN_ERR "Eraseblock size of MTD partition %d too small\n",
+				mtd->index);
+		return;
+	}
+
+	cxt->mtd = mtd;
+	cxt->oops_pages = mtd->size / OOPS_PAGE_SIZE;
+
+	find_next_position(cxt);
+
+	printk(KERN_INFO "mtdoops: Attached to MTD device %d\n", mtd->index);
+}
+
+static void mtdoops_notify_remove(struct mtd_info *mtd)
+{
+	struct mtdoops_context *cxt = &oops_cxt;
+
+	if ((mtd->index != cxt->mtd_index) || cxt->mtd_index < 0)
+		return;
+
+	cxt->mtd = NULL;
+	flush_scheduled_work();
+}
+
+static void mtdoops_console_sync(void)
+{
+	struct mtdoops_context *cxt = &oops_cxt;
+	struct mtd_info *mtd = cxt->mtd;
+	unsigned long flags;
+
+	if (!cxt->ready || !mtd || cxt->writecount == 0)
+		return;
+
+	/* 
+	 *  Once ready is 0 and we've held the lock no further writes to the 
+	 *  buffer will happen
+	 */
+	spin_lock_irqsave(&cxt->writecount_lock, flags);
+	if (!cxt->ready) {
+		spin_unlock_irqrestore(&cxt->writecount_lock, flags);
+		return;
+	}
+	cxt->ready = 0;
+	spin_unlock_irqrestore(&cxt->writecount_lock, flags);
+
+	if (mtd->panic_write && in_interrupt())
+		/* Interrupt context, we're going to panic so try and log */
+		mtdoops_write(cxt, 1);
+	else
+		schedule_work(&cxt->work_write);
+}
+
+static void
+mtdoops_console_write(struct console *co, const char *s, unsigned int count)
+{
+	struct mtdoops_context *cxt = co->data;
+	struct mtd_info *mtd = cxt->mtd;
+	unsigned long flags;
+
+	if (!oops_in_progress) {
+		mtdoops_console_sync();
+		return;
+	}
+
+	if (!cxt->ready || !mtd)
+		return;
+
+	/* Locking on writecount ensures sequential writes to the buffer */
+	spin_lock_irqsave(&cxt->writecount_lock, flags);
+
+	/* Check ready status didn't change whilst waiting for the lock */
+	if (!cxt->ready)
+		return;
+
+	if (cxt->writecount == 0) {
+		u32 *stamp = cxt->oops_buf;
+		*stamp++ = cxt->nextcount;
+		*stamp = MTDOOPS_KERNMSG_MAGIC;
+		cxt->writecount = 8;
+	}
+
+	if ((count + cxt->writecount) > OOPS_PAGE_SIZE)
+		count = OOPS_PAGE_SIZE - cxt->writecount;
+
+	memcpy(cxt->oops_buf + cxt->writecount, s, count);
+	cxt->writecount += count;
+
+	spin_unlock_irqrestore(&cxt->writecount_lock, flags);
+
+	if (cxt->writecount == OOPS_PAGE_SIZE)
+		mtdoops_console_sync();
+}
+
+static int __init mtdoops_console_setup(struct console *co, char *options)
+{
+	struct mtdoops_context *cxt = co->data;
+
+	if (cxt->mtd_index != -1)
+		return -EBUSY;
+	if (co->index == -1)
+		return -EINVAL;
+
+	cxt->mtd_index = co->index;
+	return 0;
+}
+
+static struct mtd_notifier mtdoops_notifier = {
+	.add	= mtdoops_notify_add,
+	.remove	= mtdoops_notify_remove,
+};
+
+static struct console mtdoops_console = {
+	.name		= "ttyMTD",
+	.write		= mtdoops_console_write,
+	.setup		= mtdoops_console_setup,
+	.unblank	= mtdoops_console_sync,
+	.index		= -1,
+	.data		= &oops_cxt,
+};
+
+static int __init mtdoops_console_init(void)
+{
+	struct mtdoops_context *cxt = &oops_cxt;
+
+	cxt->mtd_index = -1;
+	cxt->oops_buf = vmalloc(OOPS_PAGE_SIZE);
+
+	if (!cxt->oops_buf) {
+		printk(KERN_ERR "Failed to allocate mtdoops buffer workspace\n");
+		return -ENOMEM;
+	}
+
+	INIT_WORK(&cxt->work_erase, mtdoops_workfunc_erase);
+	INIT_WORK(&cxt->work_write, mtdoops_workfunc_write);
+
+	register_console(&mtdoops_console);
+	register_mtd_user(&mtdoops_notifier);
+	return 0;
+}
+
+static void __exit mtdoops_console_exit(void)
+{
+	struct mtdoops_context *cxt = &oops_cxt;
+
+	unregister_mtd_user(&mtdoops_notifier);
+	unregister_console(&mtdoops_console);
+	vfree(cxt->oops_buf);
+}
+
+
+subsys_initcall(mtdoops_console_init);
+module_exit(mtdoops_console_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Richard Purdie <rpurdie@openedhand.com>");
+MODULE_DESCRIPTION("MTD Oops/Panic console logger/driver");
diff -ruN linux-omap-2.6/drivers/mtd/mtdpart.c maemo_src/drivers/mtd/mtdpart.c
--- linux-omap-2.6/drivers/mtd/mtdpart.c	2011-02-06 19:44:58.756666606 -0500
+++ maemo_src/drivers/mtd/mtdpart.c	2011-02-06 20:12:13.166666608 -0500
@@ -151,6 +151,20 @@
 				    len, retlen, buf);
 }
 
+static int part_panic_write (struct mtd_info *mtd, loff_t to, size_t len,
+			size_t *retlen, const u_char *buf)
+{
+	struct mtd_part *part = PART(mtd);
+	if (!(mtd->flags & MTD_WRITEABLE))
+		return -EROFS;
+	if (to >= mtd->size)
+		len = 0;
+	else if (to + len > mtd->size)
+		len = mtd->size - to;
+	return part->master->panic_write (part->master, to + part->offset,
+				    len, retlen, buf);
+}
+
 static int part_write_oob(struct mtd_info *mtd, loff_t to,
 			 struct mtd_oob_ops *ops)
 {
@@ -353,6 +367,9 @@
 		slave->mtd.read = part_read;
 		slave->mtd.write = part_write;
 
+		if (master->panic_write)
+			slave->mtd.panic_write = part_panic_write;
+
 		if(master->point && master->unpoint){
 			slave->mtd.point = part_point;
 			slave->mtd.unpoint = part_unpoint;
diff -ruN linux-omap-2.6/drivers/mtd/onenand/omap2.c maemo_src/drivers/mtd/onenand/omap2.c
--- linux-omap-2.6/drivers/mtd/onenand/omap2.c	2011-02-06 20:17:25.766666607 -0500
+++ maemo_src/drivers/mtd/onenand/omap2.c	2011-02-06 20:12:13.216666607 -0500
@@ -4,7 +4,7 @@
  *  OneNAND driver for OMAP2
  *
  *  Copyright (C) 2005-2006 Nokia Corporation
- * 
+ *
  *  Author: Jarkko Lavinen <jarkko.lavinen@nokia.com> and Juha Yrjola
  *  IRQ and DMA support written by Timo Teras
  *
@@ -61,6 +61,8 @@
 	struct completion irq_done;
 	struct completion dma_done;
 	int dma_channel;
+	int freq;
+	int (*setup)(void __iomem *base, int freq);
 };
 
 static unsigned short omap2_onenand_readw(void __iomem *addr)
@@ -98,7 +100,23 @@
 	u32 syscfg;
 
 	if (state == FL_RESETING) {
-		udelay(1);
+		int i;
+
+		for (i = 0; i < 20; i++) {
+			udelay(1);
+			interrupt = omap2_onenand_readw(info->onenand.base + ONENAND_REG_INTERRUPT);
+			if (interrupt & ONENAND_INT_MASTER)
+				break;
+		}
+		ctrl = omap2_onenand_readw(info->onenand.base + ONENAND_REG_CTRL_STATUS);
+		if (ctrl & ONENAND_CTRL_ERROR) {
+			printk(KERN_ERR "onenand_wait: reset error! ctrl 0x%04x intr 0x%04x\n", ctrl, interrupt);
+			return -EIO;
+		}
+		if (!(interrupt & ONENAND_INT_RESET)) {
+			printk(KERN_ERR "onenand_wait: reset timeout! ctrl 0x%04x intr 0x%04x\n", ctrl, interrupt);
+			return -EIO;
+		}
 		return 0;
 	}
 
@@ -160,7 +178,7 @@
 		printk(KERN_ERR "onenand_wait: controller error = 0x%04x\n", ctrl);
 		if (ctrl & ONENAND_CTRL_LOCK)
 			printk(KERN_ERR "onenand_erase: Device is write protected!!!\n");
-		return ctrl;
+		return -EIO;
 	}
 
 	if (ctrl & 0xFE9F)
@@ -169,11 +187,12 @@
 	if (interrupt & ONENAND_INT_READ) {
 		int ecc = omap2_onenand_readw(info->onenand.base + ONENAND_REG_ECC_STATUS);
 		if (ecc) {
-			printk(KERN_ERR "onenand_wait: ECC error = 0x%04x\n", ecc);
 			if (ecc & ONENAND_ECC_2BIT_ALL) {
+				printk(KERN_ERR "onenand_wait: ECC error = 0x%04x\n", ecc);
 				mtd->ecc_stats.failed++;
-				return ecc;
+				return -EBADMSG;
 			} else if (ecc & ONENAND_ECC_1BIT_ALL)
+				printk(KERN_NOTICE "onenand_wait: correctable ECC error = 0x%04x\n", ecc);
 				mtd->ecc_stats.corrected++;
 		}
 	} else if (state == FL_READING) {
@@ -285,6 +304,29 @@
 	return 0;
 }
 
+static struct platform_driver omap2_onenand_driver;
+
+static int __adjust_timing(struct device *dev, void *data)
+{
+	int ret = 0;
+	struct omap2_onenand *info;
+
+	info = dev_get_drvdata(dev);
+
+	BUG_ON(info->setup == NULL);
+
+	/* DMA is not in use so this is all that is needed */
+	ret = info->setup(info->onenand.base, info->freq);
+
+	return ret;
+}
+
+int omap2_onenand_rephase(void)
+{
+	return driver_for_each_device(&omap2_onenand_driver.driver, NULL,
+				      NULL, __adjust_timing);
+}
+
 static void __devexit omap2_onenand_shutdown(struct platform_device *pdev)
 {
 	struct omap2_onenand *info = dev_get_drvdata(&pdev->dev);
@@ -337,16 +379,17 @@
 	}
 
 	if (pdata->onenand_setup != NULL) {
-		r = pdata->onenand_setup(info->onenand.base);
+		r = pdata->onenand_setup(info->onenand.base, info->freq);
 		if (r < 0) {
 			dev_err(&pdev->dev, "Onenand platform setup failed: %d\n", r);
-			goto err_iounmap;                       
+			goto err_iounmap;
 		}
-        }
+		info->setup = pdata->onenand_setup;
+	}
 
 	if ((r = omap_request_gpio(info->gpio_irq)) < 0) {
 		dev_err(&pdev->dev,  "Failed to request GPIO%d for OneNAND\n",
-		        info->gpio_irq);
+			info->gpio_irq);
 		goto err_iounmap;
 	}
 	omap_set_gpio_direction(info->gpio_irq, 1);
@@ -379,12 +422,28 @@
 	info->mtd.priv = &info->onenand;
 	info->mtd.owner = THIS_MODULE;
 	info->onenand.wait = omap2_onenand_wait;
+
 	info->onenand.read_bufferram = omap2_onenand_read_bufferram;
 	info->onenand.write_bufferram = omap2_onenand_write_bufferram;
 
 	if ((r = onenand_scan(&info->mtd, 1)) < 0)
 		goto err_release_dma;
 
+	switch ((info->onenand.version_id >> 4) & 0xf) {
+	case 0:
+		info->freq = 40;
+		break;
+	case 1:
+		info->freq = 54;
+		break;
+	case 2:
+		info->freq = 66;
+		break;
+	case 3:
+		info->freq = 83;
+		break;
+	}
+
 #ifdef CONFIG_MTD_PARTITIONS
 	if (pdata->parts != NULL)
 		r = add_mtd_partitions(&info->mtd, pdata->parts, pdata->nr_parts);
diff -ruN linux-omap-2.6/drivers/mtd/onenand/onenand_base.c maemo_src/drivers/mtd/onenand/onenand_base.c
--- linux-omap-2.6/drivers/mtd/onenand/onenand_base.c	2011-02-06 19:44:58.789999940 -0500
+++ maemo_src/drivers/mtd/onenand/onenand_base.c	2011-02-06 20:12:13.236666605 -0500
@@ -18,6 +18,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/sched.h>
+#include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/jiffies.h>
 #include <linux/mtd/mtd.h>
@@ -312,18 +313,20 @@
 		printk(KERN_ERR "onenand_wait: controller error = 0x%04x\n", ctrl);
 		if (ctrl & ONENAND_CTRL_LOCK)
 			printk(KERN_ERR "onenand_wait: it's locked error.\n");
-		return ctrl;
+		return -EIO;
 	}
 
 	if (interrupt & ONENAND_INT_READ) {
 		int ecc = this->read_word(this->base + ONENAND_REG_ECC_STATUS);
 		if (ecc) {
-			printk(KERN_ERR "onenand_wait: ECC error = 0x%04x\n", ecc);
 			if (ecc & ONENAND_ECC_2BIT_ALL) {
+				printk(KERN_ERR "onenand_wait: ECC error = 0x%04x\n", ecc);
 				mtd->ecc_stats.failed++;
-				return ecc;
-			} else if (ecc & ONENAND_ECC_1BIT_ALL)
+				return -EBADMSG;
+			} else if (ecc & ONENAND_ECC_1BIT_ALL) {
+				printk(KERN_NOTICE "onenand_wait: correctable ECC error = 0x%04x)\n", ecc);
 				mtd->ecc_stats.corrected++;
+			}
 		}
 	} else if (state == FL_READING) {
 		printk(KERN_ERR "onenand_wait: read timeout! ctrl=0x%04x intr=0x%04x\n", ctrl, interrupt);
@@ -716,18 +719,8 @@
 	spin_unlock(&this->chip_lock);
 }
 
-/**
- * onenand_read - [MTD Interface] Read data from flash
- * @param mtd		MTD device structure
- * @param from		offset to read from
- * @param len		number of bytes to read
- * @param retlen	pointer to variable to store the number of read bytes
- * @param buf		the databuffer to put data
- *
- * Read with ecc
-*/
-static int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
-	size_t *retlen, u_char *buf)
+static int onenand_read_nolock(struct mtd_info *mtd, loff_t from, size_t len,
+			       size_t *retlen, u_char *buf)
 {
 	struct onenand_chip *this = mtd->priv;
 	struct mtd_ecc_stats stats;
@@ -735,75 +728,70 @@
 	int thislen;
 	int ret = 0, boundary = 0;
 
-	DEBUG(MTD_DEBUG_LEVEL3, "onenand_read: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);
+	DEBUG(MTD_DEBUG_LEVEL3, "onenand_read_nolock: from = 0x%08x, ""len = %i\n",
+	      (unsigned int) from, (int) len);
 
 	/* Do not allow reads past end of device */
 	if ((from + len) > mtd->size) {
-		printk(KERN_ERR "onenand_read: Attempt read beyond end of device\n");
+		printk(KERN_ERR "onenand_read_nolock: Attempt read beyond end of device\n");
 		*retlen = 0;
 		return -EINVAL;
 	}
 
-	/* Grab the lock and see if the device is available */
-	onenand_get_device(mtd, FL_READING);
-
 	stats = mtd->ecc_stats;
 
- 	/* Read-while-load method */
+	/* Read-while-load method */
 
- 	/* Do first load to bufferRAM */
- 	if (read < len) {
- 		if (!onenand_check_bufferram(mtd, from)) {
- 			this->command(mtd, ONENAND_CMD_READ, from, mtd->writesize);
- 			ret = this->wait(mtd, FL_READING);
- 			onenand_update_bufferram(mtd, from, !ret);
- 		}
- 	}
-
- 	thislen = min_t(int, mtd->writesize, len - read);
- 	column = from & (mtd->writesize - 1);
- 	if (column + thislen > mtd->writesize)
- 		thislen = mtd->writesize - column;
-
- 	while (!ret) {
- 		/* If there is more to load then start next load */
- 		from += thislen;
- 		if (read + thislen < len) {
- 			this->command(mtd, ONENAND_CMD_READ, from, mtd->writesize);
- 			/*
- 			 * Chip boundary handling in DDP
- 			 * Now we issued chip 1 read and pointed chip 1
- 			 * bufferam so we have to point chip 0 bufferam.
- 			 */
- 			if (ONENAND_IS_DDP(this) &&
- 			    unlikely(from == (this->chipsize >> 1))) {
- 				this->write_word(ONENAND_DDP_CHIP0, this->base + ONENAND_REG_START_ADDRESS2);
- 				boundary = 1;
- 			} else
- 				boundary = 0;
- 			ONENAND_SET_PREV_BUFFERRAM(this);
- 		}
- 		/* While load is going, read from last bufferRAM */
- 		this->read_bufferram(mtd, ONENAND_DATARAM, buf, column, thislen);
- 		/* See if we are done */
- 		read += thislen;
- 		if (read == len)
- 			break;
- 		/* Set up for next read from bufferRAM */
- 		if (unlikely(boundary))
- 			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
- 		ONENAND_SET_NEXT_BUFFERRAM(this);
- 		buf += thislen;
- 		thislen = min_t(int, mtd->writesize, len - read);
- 		column = 0;
- 		cond_resched();
- 		/* Now wait for load */
- 		ret = this->wait(mtd, FL_READING);
- 		onenand_update_bufferram(mtd, from, !ret);
- 	}
+	/* Do first load to bufferRAM */
+	if (read < len) {
+		if (!onenand_check_bufferram(mtd, from)) {
+			this->command(mtd, ONENAND_CMD_READ, from, mtd->writesize);
+			ret = this->wait(mtd, FL_READING);
+			onenand_update_bufferram(mtd, from, !ret);
+		}
+	}
 
-	/* Deselect and wake up anyone waiting on the device */
-	onenand_release_device(mtd);
+	thislen = min_t(int, mtd->writesize, len - read);
+	column = from & (mtd->writesize - 1);
+	if (column + thislen > mtd->writesize)
+		thislen = mtd->writesize - column;
+
+	while (!ret) {
+		/* If there is more to load then start next load */
+		from += thislen;
+		if (read + thislen < len) {
+			this->command(mtd, ONENAND_CMD_READ, from, mtd->writesize);
+			/*
+			 * Chip boundary handling in DDP
+			 * Now we issued chip 1 read and pointed chip 1
+			 * bufferam so we have to point chip 0 bufferam.
+			 */
+			if (ONENAND_IS_DDP(this) &&
+			    unlikely(from == (this->chipsize >> 1))) {
+				this->write_word(ONENAND_DDP_CHIP0, this->base + ONENAND_REG_START_ADDRESS2);
+				boundary = 1;
+			} else
+				boundary = 0;
+			ONENAND_SET_PREV_BUFFERRAM(this);
+		}
+		/* While load is going, read from last bufferRAM */
+		this->read_bufferram(mtd, ONENAND_DATARAM, buf, column, thislen);
+		/* See if we are done */
+		read += thislen;
+		if (read == len)
+			break;
+		/* Set up for next read from bufferRAM */
+		if (unlikely(boundary))
+			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
+		ONENAND_SET_NEXT_BUFFERRAM(this);
+		buf += thislen;
+		thislen = min_t(int, mtd->writesize, len - read);
+		column = 0;
+		cond_resched();
+		/* Now wait for load */
+		ret = this->wait(mtd, FL_READING);
+		onenand_update_bufferram(mtd, from, !ret);
+	}
 
 	/*
 	 * Return success, if no ECC failures, else -EBADMSG
@@ -822,6 +810,28 @@
 }
 
 /**
+ * onenand_read - [MTD Interface] Read data from flash
+ * @param mtd		MTD device structure
+ * @param from		offset to read from
+ * @param len		number of bytes to read
+ * @param retlen	pointer to variable to store the number of read bytes
+ * @param buf		the databuffer to put data
+ *
+ * Read with ecc
+*/
+static int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
+			size_t *retlen, u_char *buf)
+{
+	int ret;
+
+	onenand_get_device(mtd, FL_READING);
+	ret = onenand_read_nolock(mtd, from, len, retlen, buf);
+	onenand_release_device(mtd);
+
+	return ret;
+}
+
+/**
  * onenand_transfer_auto_oob - [Internal] oob auto-placement transfer
  * @param mtd		MTD device structure
  * @param buf		destination address
@@ -861,7 +871,7 @@
 }
 
 /**
- * onenand_do_read_oob - [MTD Interface] OneNAND read out-of-band
+ * onenand_read_oob_nolock - [MTD Interface] OneNAND read out-of-band
  * @param mtd		MTD device structure
  * @param from		offset to read from
  * @param len		number of bytes to read
@@ -871,14 +881,15 @@
  *
  * OneNAND read out-of-band data from the spare area
  */
-static int onenand_do_read_oob(struct mtd_info *mtd, loff_t from, size_t len,
+static int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from, size_t len,
 			size_t *retlen, u_char *buf, mtd_oob_mode_t mode)
 {
 	struct onenand_chip *this = mtd->priv;
 	int read = 0, thislen, column, oobsize;
 	int ret = 0;
 
-	DEBUG(MTD_DEBUG_LEVEL3, "onenand_read_oob: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);
+	DEBUG(MTD_DEBUG_LEVEL3, "onenand_read_oob_nolock: from = 0x%08x, len = %i\n",
+	      (unsigned int) from, (int) len);
 
 	/* Initialize return length value */
 	*retlen = 0;
@@ -891,7 +902,7 @@
 	column = from & (mtd->oobsize - 1);
 
 	if (unlikely(column >= oobsize)) {
-		printk(KERN_ERR "onenand_read_oob: Attempted to start read outside oob\n");
+		printk(KERN_ERR "onenand_read_oob_nolock: Attempted to start read outside oob\n");
 		return -EINVAL;
 	}
 
@@ -899,13 +910,10 @@
 	if (unlikely(from >= mtd->size ||
 		     column + len > ((mtd->size >> this->page_shift) -
 				     (from >> this->page_shift)) * oobsize)) {
-		printk(KERN_ERR "onenand_read_oob: Attempted to read beyond end of device\n");
+		printk(KERN_ERR "onenand_read_oob_nolock: Attempted to read beyond end of device\n");
 		return -EINVAL;
 	}
 
-	/* Grab the lock and see if the device is available */
-	onenand_get_device(mtd, FL_READING);
-
 	while (read < len) {
 		cond_resched();
 
@@ -925,7 +933,7 @@
 			this->read_bufferram(mtd, ONENAND_SPARERAM, buf, column, thislen);
 
 		if (ret) {
-			printk(KERN_ERR "onenand_read_oob: read failed = 0x%x\n", ret);
+			printk(KERN_ERR "onenand_read_oob_nolock: read failed = 0x%x\n", ret);
 			break;
 		}
 
@@ -944,9 +952,6 @@
 		}
 	}
 
-	/* Deselect and wake up anyone waiting on the device */
-	onenand_release_device(mtd);
-
 	*retlen = read;
 	return ret;
 }
@@ -960,6 +965,8 @@
 static int onenand_read_oob(struct mtd_info *mtd, loff_t from,
 			    struct mtd_oob_ops *ops)
 {
+	int ret;
+
 	switch (ops->mode) {
 	case MTD_OOB_PLACE:
 	case MTD_OOB_AUTO:
@@ -969,8 +976,12 @@
 	default:
 		return -EINVAL;
 	}
-	return onenand_do_read_oob(mtd, from + ops->ooboffs, ops->ooblen,
-				   &ops->oobretlen, ops->oobbuf, ops->mode);
+
+	onenand_get_device(mtd, FL_READING);
+	ret = onenand_read_oob_nolock(mtd, from + ops->ooboffs, ops->ooblen,
+				      &ops->oobretlen, ops->oobbuf, ops->mode);
+	onenand_release_device(mtd);
+	return ret;
 }
 
 /**
@@ -1167,8 +1178,22 @@
 
 #define NOTALIGNED(x)	((x & (this->subpagesize - 1)) != 0)
 
+static void onenand_panic_wait(struct mtd_info *mtd)
+{
+	struct onenand_chip *this = mtd->priv;
+	unsigned int interrupt;
+	int i;
+	
+	for (i = 0; i < 2000; i++) {
+		interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
+		if (interrupt & ONENAND_INT_MASTER)
+			break;
+		udelay(10);
+	}
+}
+
 /**
- * onenand_write - [MTD Interface] write buffer to FLASH
+ * onenand_panic_write - [MTD Interface] write buffer to FLASH in a panic context
  * @param mtd		MTD device structure
  * @param to		offset to write to
  * @param len		number of bytes to write
@@ -1177,35 +1202,110 @@
  *
  * Write with ECC
  */
-static int onenand_write(struct mtd_info *mtd, loff_t to, size_t len,
-	size_t *retlen, const u_char *buf)
+static int onenand_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
+			 size_t *retlen, const u_char *buf)
 {
 	struct onenand_chip *this = mtd->priv;
+	int column, subpage;
 	int written = 0;
 	int ret = 0;
-	int column, subpage;
 
-	DEBUG(MTD_DEBUG_LEVEL3, "onenand_write: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);
+	if (this->state == FL_PM_SUSPENDED)
+		return -EBUSY;
+
+	/* Wait for any existing operation to clear */
+	onenand_panic_wait(mtd);
+
+	DEBUG(MTD_DEBUG_LEVEL3, "onenand_panic_write: to = 0x%08x, len = %i\n",
+	      (unsigned int) to, (int) len);
 
 	/* Initialize retlen, in case of early exit */
 	*retlen = 0;
 
 	/* Do not allow writes past end of device */
 	if (unlikely((to + len) > mtd->size)) {
-		printk(KERN_ERR "onenand_write: Attempt write to past end of device\n");
+		printk(KERN_ERR "onenand_panic_write: Attempt write to past end of device\n");
 		return -EINVAL;
 	}
 
 	/* Reject writes, which are not page aligned */
         if (unlikely(NOTALIGNED(to)) || unlikely(NOTALIGNED(len))) {
-                printk(KERN_ERR "onenand_write: Attempt to write not page aligned data\n");
+                printk(KERN_ERR "onenand_panic_write: Attempt to write not page aligned data\n");
                 return -EINVAL;
         }
 
 	column = to & (mtd->writesize - 1);
 
-	/* Grab the lock and see if the device is available */
-	onenand_get_device(mtd, FL_WRITING);
+	/* Loop until all data write */
+	while (written < len) {
+		int thislen = min_t(int, mtd->writesize - column, len - written);
+		u_char *wbuf = (u_char *) buf;
+
+		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, thislen);
+
+		/* Partial page write */
+		subpage = thislen < mtd->writesize;
+		if (subpage) {
+			memset(this->page_buf, 0xff, mtd->writesize);
+			memcpy(this->page_buf + column, buf, thislen);
+			wbuf = this->page_buf;
+		}
+
+		this->write_bufferram(mtd, ONENAND_DATARAM, wbuf, 0, mtd->writesize);
+		this->write_bufferram(mtd, ONENAND_SPARERAM, ffchars, 0, mtd->oobsize);
+
+		this->command(mtd, ONENAND_CMD_PROG, to, mtd->writesize);
+
+		onenand_panic_wait(mtd);
+
+		/* In partial page write we don't update bufferram */
+		onenand_update_bufferram(mtd, to, !ret && !subpage);
+		if (ret) {
+			printk(KERN_ERR "onenand_panic_write: write failed %d\n", ret);
+			break;
+		}
+
+		written += thislen;
+
+		if (written == len)
+			break;
+
+		column = 0;
+		to += thislen;
+		buf += thislen;
+	}
+
+	*retlen = written;
+	return ret;
+}
+
+static int onenand_write_nolock(struct mtd_info *mtd, loff_t to, size_t len,
+				size_t *retlen, const u_char *buf)
+{
+	struct onenand_chip *this = mtd->priv;
+	int written = 0;
+	int ret = 0;
+	int column, subpage;
+
+	DEBUG(MTD_DEBUG_LEVEL3, "onenand_write_nolock: to = 0x%08x, len = %i\n",
+	      (unsigned int) to, (int) len);
+
+	/* Initialize retlen, in case of early exit */
+	*retlen = 0;
+
+	/* Do not allow writes past end of device */
+	if (unlikely((to + len) > mtd->size)) {
+		printk(KERN_ERR "onenand_write_nolock: Attempt write to past end of device\n");
+		return -EINVAL;
+	}
+
+	/* Reject writes, which are not page aligned */
+        if (unlikely(NOTALIGNED(to)) || unlikely(NOTALIGNED(len))) {
+                printk(KERN_ERR "onenand_write_nolock: Attempt to write not page aligned data\n");
+                return -EINVAL;
+        }
+
+	column = to & (mtd->writesize - 1);
 
 	/* Loop until all data write */
 	while (written < len) {
@@ -1235,14 +1335,14 @@
 		onenand_update_bufferram(mtd, to, !ret && !subpage);
 
 		if (ret) {
-			printk(KERN_ERR "onenand_write: write filaed %d\n", ret);
+			printk(KERN_ERR "onenand_write_nolock: write filaed %d\n", ret);
 			break;
 		}
 
 		/* Only check verify write turn on */
 		ret = onenand_verify(mtd, (u_char *) wbuf, to, thislen);
 		if (ret) {
-			printk(KERN_ERR "onenand_write: verify failed %d\n", ret);
+			printk(KERN_ERR "onenand_write_nolock: verify failed %d\n", ret);
 			break;
 		}
 
@@ -1256,10 +1356,28 @@
 		buf += thislen;
 	}
 
-	/* Deselect and wake up anyone waiting on the device */
-	onenand_release_device(mtd);
-
 	*retlen = written;
+	return ret;
+}
+
+/**
+ * onenand_write - [MTD Interface] write buffer to FLASH
+ * @param mtd		MTD device structure
+ * @param to		offset to write to
+ * @param len		number of bytes to write
+ * @param retlen	pointer to variable to store the number of written bytes
+ * @param buf		the data to write
+ *
+ * Write with ECC
+ */
+static int onenand_write(struct mtd_info *mtd, loff_t to, size_t len,
+			 size_t *retlen, const u_char *buf)
+{
+	int ret;
+
+	onenand_get_device(mtd, FL_WRITING);
+	ret = onenand_write_nolock(mtd, to, len, retlen, buf);
+	onenand_release_device(mtd);
 
 	return ret;
 }
@@ -1303,7 +1421,7 @@
 }
 
 /**
- * onenand_do_write_oob - [Internal] OneNAND write out-of-band
+ * onenand_write_oob_nolock - [Internal] OneNAND write out-of-band
  * @param mtd		MTD device structure
  * @param to		offset to write to
  * @param len		number of bytes to write
@@ -1313,7 +1431,7 @@
  *
  * OneNAND write out-of-band
  */
-static int onenand_do_write_oob(struct mtd_info *mtd, loff_t to, size_t len,
+static int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to, size_t len,
 				size_t *retlen, const u_char *buf, mtd_oob_mode_t mode)
 {
 	struct onenand_chip *this = mtd->priv;
@@ -1321,7 +1439,8 @@
 	int written = 0;
 	u_char *oobbuf;
 
-	DEBUG(MTD_DEBUG_LEVEL3, "onenand_write_oob: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);
+	DEBUG(MTD_DEBUG_LEVEL3, "onenand_write_oob_nolock: to = 0x%08x, len = %i\n",
+	      (unsigned int) to, (int) len);
 
 	/* Initialize retlen, in case of early exit */
 	*retlen = 0;
@@ -1334,13 +1453,13 @@
 	column = to & (mtd->oobsize - 1);
 
 	if (unlikely(column >= oobsize)) {
-		printk(KERN_ERR "onenand_write_oob: Attempted to start write outside oob\n");
+		printk(KERN_ERR "onenand_write_oob_nolock: Attempted to start write outside oob\n");
 		return -EINVAL;
 	}
 
 	/* For compatibility with NAND: Do not allow write past end of page */
 	if (unlikely(column + len > oobsize)) {
-		printk(KERN_ERR "onenand_write_oob: "
+		printk(KERN_ERR "onenand_write_oob_nolock: "
 		      "Attempt to write past end of page\n");
 		return -EINVAL;
 	}
@@ -1349,13 +1468,10 @@
 	if (unlikely(to >= mtd->size ||
 		     column + len > ((mtd->size >> this->page_shift) -
 				     (to >> this->page_shift)) * oobsize)) {
-		printk(KERN_ERR "onenand_write_oob: Attempted to write past end of device\n");
+		printk(KERN_ERR "onenand_write_oob_nolock: Attempted to write past end of device\n");
 		return -EINVAL;
 	}
 
-	/* Grab the lock and see if the device is available */
-	onenand_get_device(mtd, FL_WRITING);
-
 	oobbuf = this->oob_buf;
 
 	/* Loop until all data write */
@@ -1381,13 +1497,13 @@
 
 		ret = this->wait(mtd, FL_WRITING);
 		if (ret) {
-			printk(KERN_ERR "onenand_write_oob: write failed %d\n", ret);
+			printk(KERN_ERR "onenand_write_oob_nolock: write failed %d\n", ret);
 			break;
 		}
 
 		ret = onenand_verify_oob(mtd, oobbuf, to);
 		if (ret) {
-			printk(KERN_ERR "onenand_write_oob: verify failed %d\n", ret);
+			printk(KERN_ERR "onenand_write_oob_nolock: verify failed %d\n", ret);
 			break;
 		}
 
@@ -1400,11 +1516,7 @@
 		column = 0;
 	}
 
-	/* Deselect and wake up anyone waiting on the device */
-	onenand_release_device(mtd);
-
 	*retlen = written;
-
 	return ret;
 }
 
@@ -1417,6 +1529,8 @@
 static int onenand_write_oob(struct mtd_info *mtd, loff_t to,
 			     struct mtd_oob_ops *ops)
 {
+	int ret;
+
 	switch (ops->mode) {
 	case MTD_OOB_PLACE:
 	case MTD_OOB_AUTO:
@@ -1426,21 +1540,15 @@
 	default:
 		return -EINVAL;
 	}
-	return onenand_do_write_oob(mtd, to + ops->ooboffs, ops->ooblen,
+	onenand_get_device(mtd, FL_WRITING);
+	ret =  onenand_write_oob_nolock(mtd, to + ops->ooboffs, ops->ooblen,
 				    &ops->oobretlen, ops->oobbuf, ops->mode);
+	onenand_release_device(mtd);
+	return ret;
 }
 
-/**
- * onenand_block_checkbad - [GENERIC] Check if a block is marked bad
- * @param mtd		MTD device structure
- * @param ofs		offset from device start
- * @param getchip	0, if the chip is already selected
- * @param allowbbt	1, if its allowed to access the bbt area
- *
- * Check, if the block is bad. Either by reading the bad block table or
- * calling of the scan function.
- */
-static int onenand_block_checkbad(struct mtd_info *mtd, loff_t ofs, int getchip, int allowbbt)
+static int onenand_block_isbad_nolock(struct mtd_info *mtd, loff_t ofs,
+				      int allowbbt)
 {
 	struct onenand_chip *this = mtd->priv;
 	struct bbm_info *bbm = this->bbm;
@@ -1501,7 +1609,7 @@
 		cond_resched();
 
 		/* Check if we have a bad block, we do not erase bad blocks */
-		if (onenand_block_checkbad(mtd, addr, 0, 0)) {
+		if (onenand_block_isbad_nolock(mtd, addr, 0)) {
 			printk (KERN_WARNING "onenand_erase: attempt to erase a bad block at addr 0x%08x\n", (unsigned int) addr);
 			instr->state = MTD_ERASE_FAILED;
 			goto erase_exit;
@@ -1565,11 +1673,16 @@
  */
 static int onenand_block_isbad(struct mtd_info *mtd, loff_t ofs)
 {
+	int ret;
+
 	/* Check for invalid offset */
 	if (ofs > mtd->size)
 		return -EINVAL;
 
-	return onenand_block_checkbad(mtd, ofs, 1, 0);
+	onenand_get_device(mtd, FL_READING);
+	ret = onenand_block_isbad_nolock(mtd, ofs, 0);
+	onenand_release_device(mtd);
+	return ret;
 }
 
 /**
@@ -1586,7 +1699,7 @@
 	struct bbm_info *bbm = this->bbm;
 	u_char buf[2] = {0, 0};
 	size_t retlen;
-	int block;
+	int block, ret;
 
 	/* Get block number */
 	block = ((int) ofs) >> bbm->bbt_erase_shift;
@@ -1595,7 +1708,8 @@
 
         /* We write two bytes, so we dont have to mess with 16 bit access */
         ofs += mtd->oobsize + (bbm->badblockpos & ~0x01);
-        return onenand_do_write_oob(mtd, ofs , 2, &retlen, buf, MTD_OOB_PLACE);
+        ret = onenand_write_oob_nolock(mtd, ofs , 2, &retlen, buf, MTD_OOB_PLACE);
+	return ret;
 }
 
 /**
@@ -1618,7 +1732,10 @@
 		return ret;
 	}
 
-	return this->block_markbad(mtd, ofs);
+	onenand_get_device(mtd, FL_WRITING);
+	ret = this->block_markbad(mtd, ofs);
+	onenand_release_device(mtd);
+	return ret;
 }
 
 /**
@@ -1709,7 +1826,12 @@
  */
 static int onenand_lock(struct mtd_info *mtd, loff_t ofs, size_t len)
 {
-	return onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_LOCK);
+	int ret;
+
+	onenand_get_device(mtd, FL_LOCKING);
+	ret = onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_LOCK);
+	onenand_release_device(mtd);
+	return ret;
 }
 
 /**
@@ -1722,7 +1844,12 @@
  */
 static int onenand_unlock(struct mtd_info *mtd, loff_t ofs, size_t len)
 {
-	return onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);
+	int ret;
+
+	onenand_get_device(mtd, FL_LOCKING);
+	ret = onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);
+	onenand_release_device(mtd);
+	return ret;
 }
 
 /**
@@ -1784,7 +1911,7 @@
 			loff_t ofs = this->chipsize >> 1;
 			size_t len = mtd->erasesize;
 
-			onenand_unlock(mtd, ofs, len);
+			onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);
 		}
 
 		onenand_check_lock_status(this);
@@ -1792,7 +1919,7 @@
 		return 0;
 	}
 
-	onenand_unlock(mtd, 0x0, this->chipsize);
+	onenand_do_lock_cmd(mtd, 0x0, this->chipsize, ONENAND_CMD_UNLOCK);
 
 	return 0;
 }
@@ -1823,7 +1950,7 @@
 	this->command(mtd, ONENAND_CMD_OTP_ACCESS, 0, 0);
 	this->wait(mtd, FL_OTPING);
 
-	ret = mtd->read(mtd, from, len, retlen, buf);
+	ret = onenand_read_nolock(mtd, from, len, retlen, buf);
 
 	/* Exit OTP access mode */
 	this->command(mtd, ONENAND_CMD_RESET, 0, 0);
@@ -1835,14 +1962,14 @@
 /**
  * do_otp_write - [DEFAULT] Write OTP block area
  * @param mtd		MTD device structure
- * @param from		The offset to write
+ * @param to		The offset to write
  * @param len		number of bytes to write
  * @param retlen	pointer to variable to store the number of write bytes
  * @param buf		the databuffer to put/get data
  *
  * Write OTP block area.
  */
-static int do_otp_write(struct mtd_info *mtd, loff_t from, size_t len,
+static int do_otp_write(struct mtd_info *mtd, loff_t to, size_t len,
 		size_t *retlen, u_char *buf)
 {
 	struct onenand_chip *this = mtd->priv;
@@ -1861,7 +1988,7 @@
 	this->command(mtd, ONENAND_CMD_OTP_ACCESS, 0, 0);
 	this->wait(mtd, FL_OTPING);
 
-	ret = mtd->write(mtd, from, len, retlen, pbuf);
+	ret = onenand_write_nolock(mtd, to, len, retlen, pbuf);
 
 	/* Exit OTP access mode */
 	this->command(mtd, ONENAND_CMD_RESET, 0, 0);
@@ -1890,7 +2017,8 @@
 	this->command(mtd, ONENAND_CMD_OTP_ACCESS, 0, 0);
 	this->wait(mtd, FL_OTPING);
 
-	ret = onenand_do_write_oob(mtd, from, len, retlen, buf, MTD_OOB_PLACE);
+	ret = onenand_write_oob_nolock(mtd, from, len, retlen, buf,
+				       MTD_OOB_PLACE);
 
 	/* Exit OTP access mode */
 	this->command(mtd, ONENAND_CMD_RESET, 0, 0);
@@ -1937,13 +2065,16 @@
 	if (((mtd->writesize * otp_pages) - (from + len)) < 0)
 		return 0;
 
+	onenand_get_device(mtd, FL_OTPING);
 	while (len > 0 && otp_pages > 0) {
 		if (!action) {	/* OTP Info functions */
 			struct otp_info *otpinfo;
 
 			len -= sizeof(struct otp_info);
-			if (len <= 0)
-				return -ENOSPC;
+			if (len <= 0) {
+				ret = -ENOSPC;
+				break;
+			}
 
 			otpinfo = (struct otp_info *) buf;
 			otpinfo->start = from;
@@ -1963,13 +2094,14 @@
 			len -= size;
 			*retlen += size;
 
-			if (ret < 0)
-				return ret;
+			if (ret)
+				break;
 		}
 		otp_pages--;
 	}
+	onenand_release_device(mtd);
 
-	return 0;
+	return ret;
 }
 
 /**
@@ -2148,7 +2280,7 @@
                 (16 << density),
                 vcc ? "2.65/3.3" : "1.8",
                 device);
-	printk(KERN_DEBUG "OneNAND version = 0x%04x\n", version);
+	printk(KERN_INFO "OneNAND version 0x%04x\n", version);
 }
 
 static const struct onenand_manufacturers onenand_manuf_ids[] = {
@@ -2282,7 +2414,7 @@
 	if (this->state == FL_PM_SUSPENDED)
 		onenand_release_device(mtd);
 	else
-		printk(KERN_ERR "resume() called for the chip which is not"
+		printk(KERN_ERR "resume() called for the chip which is not "
 				"in suspended state\n");
 }
 
@@ -2403,6 +2535,7 @@
 	mtd->write = onenand_write;
 	mtd->read_oob = onenand_read_oob;
 	mtd->write_oob = onenand_write_oob;
+	mtd->panic_write = onenand_panic_write;
 #ifdef CONFIG_MTD_ONENAND_OTP
 	mtd->get_fact_prot_info = onenand_get_fact_prot_info;
 	mtd->read_fact_prot_reg = onenand_read_fact_prot_reg;
diff -ruN linux-omap-2.6/drivers/net/wireless/Kconfig maemo_src/drivers/net/wireless/Kconfig
--- linux-omap-2.6/drivers/net/wireless/Kconfig	2011-02-06 19:44:59.909999940 -0500
+++ maemo_src/drivers/net/wireless/Kconfig	2007-10-02 03:09:32.000000000 -0400
@@ -538,6 +538,7 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called zd1201.
 
+
 source "drivers/net/wireless/hostap/Kconfig"
 source "drivers/net/wireless/bcm43xx/Kconfig"
 source "drivers/net/wireless/zd1211rw/Kconfig"
@@ -550,3 +551,5 @@
 
 endmenu
 
+source "drivers/net/wireless/pc2400m/Kconfig"
+
diff -ruN linux-omap-2.6/drivers/net/wireless/Makefile maemo_src/drivers/net/wireless/Makefile
--- linux-omap-2.6/drivers/net/wireless/Makefile	2011-02-06 19:44:59.909999940 -0500
+++ maemo_src/drivers/net/wireless/Makefile	2007-10-02 03:09:32.000000000 -0400
@@ -43,3 +43,8 @@
 obj-$(CONFIG_PCMCIA_WL3501)	+= wl3501_cs.o
 
 obj-$(CONFIG_USB_ZD1201)	+= zd1201.o
+
+obj-$(CONFIG_NET_PC2400M)	+= pc2400m/
+
+#obj-m				+= cx3110x/
+#obj-m				+= umac/
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/Kconfig maemo_src/drivers/net/wireless/pc2400m/Kconfig
--- linux-omap-2.6/drivers/net/wireless/pc2400m/Kconfig	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/Kconfig	2011-02-06 20:12:12.086666606 -0500
@@ -0,0 +1,40 @@
+menu "WiMAX (IEEE 802.16)"
+        depends on NETDEVICES
+
+config NET_PC2400M
+        tristate "Intel PC2400M WiMAX chipset driver"
+        depends on SPI
+        ---help---
+          Support for the Intel PC2400M WiMAX chipset over SPI
+
+config NET_PC2400M_GCOV
+        boolean "Intel PC2400M driver GCOV support"
+        depends on GCOV_PROFILE
+        ---help---
+          Enabling this option will instrument the pc2400m driver to
+          support GCOV coverage testing
+
+config NET_PC2400M_SPI_48MHZ
+        boolean "Intel PC2400M SPI @ 48MHz"
+        depends on !NET_PC2400M_SIM
+        ---help---
+          Support for running the PC2400M SPI interface at 48 MHz
+
+config NET_PC2400M_ALLOW_SPI_AGGREGATION
+        boolean "Intel PC2400M SPI aggregation"
+        depends on NET_PC2400M
+        ---help---
+         Support for aggregating multiple packets on the SPI bus into single
+         transactions. This will have a beneficial effect on performance
+         (throughput and load) but may induce serious instability on some
+         hardware / firmware versions.
+
+config NET_PC2400M_ENABLE_CHIPSET_INTERNAL_RESET
+        boolean "Enable Intel PC2400M internal resets"
+        depends on NET_PC2400M
+        ---help---
+         Enable the internal reset feature of the PC2400M chipset. If unsure,
+         answer "no."
+
+endmenu
+
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/Makefile maemo_src/drivers/net/wireless/pc2400m/Makefile
--- linux-omap-2.6/drivers/net/wireless/pc2400m/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/Makefile	2011-02-06 20:12:12.073333272 -0500
@@ -0,0 +1,38 @@
+#
+# Makefile for the PC2400M OSSO driver
+#
+# Change history:
+#
+# Date        Version Status   Reason                         Guilty 
+# ----------------------------------------------------------------------------
+# 17-Mar-2008      15 APPROVED Added pc2400m_i2c.o            Juuso Oikarinen
+# 13-Mar-2008      15 APPROVED Removed pc2400m_sim.o          Juuso Oikarinen
+# 23-Jan-2008      14 APPROVED Removed pc2400m_drv_sllist.o   Juuso Oikarinen
+# 21-Jan-2008      13 DRAFT    Corrected GCOV support         Juuso Oikarinen
+# 21-Jan-2008      12 DRAFT    Added GCOV support             Juuso Oikarinen
+
+ifeq ($(CONFIG_NET_PC2400M_GCOV), y)
+CFLAGS += -fprofile-arcs -ftest-coverage
+LINUXINCLUDE2 := -I$(objtree)/include -I$(srctree) -I$(objtree) \
+         $(if $(KBUILD_SRC),-I$(objtree)/include2 -I$(srctree)/include) \
+         -include include/linux/autoconf.h
+CPPFLAGS := -D__KERNEL__ $(LINUXINCLUDE2)
+CFLAGS += -O0
+endif
+
+pc2400m-objs := pc2400m_if.o \
+	pc2400m_if_netlink.o \
+	pc2400m_if_we.o \
+	pc2400m_if_sysfs.o \
+	pc2400m_spi.o \
+	pc2400m_i2c.o \
+	pc2400m_drv.o \
+	pc2400m_osal.o \
+	pc2400m_drv_sdio.o \
+	pc2400m_drv_spi.o \
+	pc2400m_drv_spi_fw.o \
+	pc2400m_drv_cd.o \
+	pc2400m_drv_dm.o \
+	pc2400m_drv_dm_bg.o
+obj-$(CONFIG_NET_PC2400M) += pc2400m.o
+
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_al.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_al.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_al.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_al.h	2011-02-06 20:12:12.013333273 -0500
@@ -0,0 +1,100 @@
+/*
+ * pc2400m_al.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         16      APPROVED 21-Feb-2008 Jouni Lappi
+*/
+
+/** @file pc2400m_al.h
+ *
+ * This is header file for abstraction layers
+ *
+ */
+
+
+#ifndef PC2400M_AL_H
+#define PC2400M_AL_H
+
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include "pc2400m_spi.h"
+#include "pc2400m_drv_iffunc.h"
+
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/** SPI configuration flags */
+#define SPI_CONFIG_SAMPLE_FALLING     0x00000001
+
+
+/*****************************************************************************
+ * Data types
+ */
+
+/** SPI function types */
+typedef void (*spi_commit_cb)(wimax_osal_context*, s32, void*);
+typedef void (*spi_irq_cb)(wimax_osal_context*);
+typedef s32 (*spi_h2d_fnc)(wimax_osal_context*, u8* , s32);
+typedef s32 (*spi_d2h_fnc)(wimax_osal_context*, u8*, s32);
+typedef s32 (*spi_commit_fnc)(wimax_osal_context*, spi_commit_cb, void*);
+typedef void (*spi_enable_irq_fnc)(wimax_osal_context*, spi_irq_cb);
+typedef void (*spi_configure_fnc)(wimax_osal_context*, u32, u32);
+typedef void (*spi_set_power_fnc)(wimax_osal_context*, u8);
+typedef boolean (*spi_irq_pending_fnc)(wimax_osal_context*);
+
+/** SPI and network interface abstraction */
+struct t_wihal_adaptation_if {
+
+        /* SPI adaptation */
+        spi_h2d_fnc               h2d;
+        spi_d2h_fnc               d2h;
+        spi_commit_fnc            commit;
+        spi_enable_irq_fnc        enable_irq;
+        spi_configure_fnc         configure;
+        spi_set_power_fnc         set_power;
+        spi_irq_pending_fnc       irq_pending;
+
+};
+
+struct t_wihal_event_if {
+
+        /* Network interface */
+        t_wihal_cmd_response_fnc  cmd_resp;
+        t_wihal_indication_fnc    ind;
+
+};
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+#endif /* PC2400M_AL_H */
+
+/* End of File */
+
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_com.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_com.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_com.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_com.h	2011-02-06 20:12:12.329999940 -0500
@@ -0,0 +1,120 @@
+/*
+ * pc2400m_com.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         15      APPROVED 21-Feb-2008 Jouni Lappi
+*/
+
+/** @file pc2400m_com.h
+ *
+ * This is header containing common definitions and functions used throughout
+ * the driver code
+ *
+ */
+
+#ifndef PC2400M_COM_H
+#define PC2400M_COM_H
+
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <asm/semaphore.h>
+
+#include "pc2400m_spi.h"
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/** For removing compiler warnings 
+ *
+ *  @param x (any) This param is placed into it self
+ *  @return void
+ */
+#define PC2400M_UNWARN(x)  x = x
+
+/** Driver suffix */
+#define DRV_SUFFIX "PC2400M: "
+
+/** Debugging definitions */
+#define DEBUG(...) printk(KERN_DEBUG DRV_SUFFIX __VA_ARGS__)
+#define ERROR(...) printk(KERN_ERR DRV_SUFFIX __VA_ARGS__)
+#define INFO(...)  printk(KERN_INFO DRV_SUFFIX __VA_ARGS__)
+
+
+/*****************************************************************************
+ * Data types
+ */
+
+/** public global variable (recommended initialization)
+ * Global variable holding the currently executing context. This is only
+ * valid within the common driver. */
+extern struct net_device *pc2400m_com_running_context;
+
+/** public global variable (recommended initialization)
+ * Global lock for the adaptation library. This is global, because the driver
+ * lib needs to be concurrency protected from multiple accesses regardless
+ * of the number of instances with one single lock. */
+extern struct semaphore pc2400m_com_mutex;
+
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/** pc2400m_com_lock - get a global lock
+ *  Get a global lock to protect the driver library
+ *  from concurrent access
+ *
+ *  @param ndev net device struct
+ *  @return void
+ */
+static inline void pc2400m_com_lock(struct net_device *ndev) {
+
+        down(&pc2400m_com_mutex);
+        pc2400m_com_running_context = ndev;
+}
+
+/** pc2400m_com_unlock - release the global lock
+ *  Release the global lock used to protect the driver
+ *  library from concurrent access
+ *
+ *  @param void
+ *  @return void
+ */
+static inline void pc2400m_com_unlock(void) {
+
+        pc2400m_com_running_context = NULL;
+        up(&pc2400m_com_mutex);
+
+}
+
+#endif /* PC2400M_COM_H */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_conf.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_conf.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_conf.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_conf.h	2011-02-06 20:12:11.539999941 -0500
@@ -0,0 +1,110 @@
+/*
+ * pc2400m_conf.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Jouni Lappi <jouni.lappi@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         11      APPROVED 15-Aug-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_conf.h
+ *
+ * General configurations for WiMAX driver
+ *
+ */
+
+#ifndef PC2400M_CONF_H
+#define PC2400M_CONF_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/** Initial scan result event buffer */
+#define PC2400M_CONF_EV_BUFF                 2048
+
+/* These are definitions for device info field lengths */
+#define PC2400M_CONF_HW_FW_VERSION_STR_LEN   40
+#define PC2400M_CONF_MODEL_STR_LEN           40
+#define PC2400M_CONF_MANUFACTURER_STR_LEN    40
+#define PC2400M_CONF_WE_API_VRS_STR_LEN      3
+#define PC2400M_CONF_RELEASE_STR_LEN         12
+#define PC2400M_CONF_SERIAL_NBR_STR_LEN      50
+
+/** version info for supported WE API */
+#define PC2400M_CONF_WE_API_VRS "3.6"
+
+/** Firmware mapping */
+#define PC2400M_CONF_FIRMWARE_FNAME_1           "pc2400m_a0.bin"
+#define PC2400M_CONF_FW_CHIP_TYPE_1             1
+
+/** this is default for firmware mapping */
+#define PC2400M_CONF_FIRMWARE_FNAME_2           "pc2400m.bin"
+
+/** EAP protocol type */
+#define PC2400M_CONF_ETH_P_EAP                  0x888E
+
+/** default and max MTU size */
+#define PC2400M_CONF_WIMAX_DEFAULT_MTU          1400
+#define PC2400M_CONF_WIMAX_MAX_MTU              1400
+#define PC2400M_CONF_WIMAX_MIN_MTU              80
+
+/** Chipset configuration defaults */
+/* 10 seconds */
+#define PC2400M_CONF_WIMAX_DEFAULT_IDLE_TIMER                10000
+/* 4 seconds */
+#define PC2400M_CONF_WIMAX_DEFAULT_SLEEP_TIMER               4000
+/* 20 seconds */
+#define PC2400M_CONF_WIMAX_DEFAULT_SIGNAL_RECOVERY_LIMIT     20000
+/* 5.12 seconds */
+#define PC2400M_CONF_WIMAX_DEFAULT_IDLE_PAGING_INTERVAL      5120
+
+/** mac address for fake ethernet headers. This is only used for EAP data */
+#define PC2400M_CONF_MAC_SOURCE         "\000\001\002\003\004\005"
+
+/** max temporary TX buffer for driver */
+#define PC2400M_CONF_TX_BUF_TOO_HIGH    20
+
+/** This defines how many IRQs are processed before we proceed to tx side*/
+#define PC2400M_CONF_MAX_IRQ_LOOPS      10
+
+/** This is only for setting nap with certain default value
+ *  this not invalid value or unused
+ *  some bs could use this 0 for real */
+#define PC2400M_IF_NO_NAP               0
+
+/*****************************************************************************
+ * Data types
+ */
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+#endif /* PC2400M_CONF_H */
+
+/* End of File */
+
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv.c maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv.c
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv.c	2011-02-06 20:12:12.246666606 -0500
@@ -0,0 +1,2430 @@
+/*
+ * pc2400m_drv.c
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         56      APPROVED 28-Aug-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_drv.c
+ *
+ * This file is the entry point and interface handler of the common driver.
+ * It implements the WiHAL interface.
+ *
+ */
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include "pc2400m_drv_com.h"
+#include "pc2400m_drv_spi.h"
+#include "pc2400m_drv_if.h"
+#include "pc2400m_drv_hdi.h"
+#include "pc2400m_drv_cd.h"
+#include "pc2400m_drv_dm.h"
+#include "pc2400m_drv.h"
+
+/*****************************************************************************
+ * Global constants and macros
+ */
+
+/*****************************************************************************
+ * Global data types
+ */
+
+/** main WiHAL entry point */
+static void pc2400m_drv_wihal_command(
+        wimax_osal_context*,
+        struct t_wihal_cmd*,
+        void*);
+
+/** definition for the interface provided by the common driver to the client */
+static struct t_wihal_driver_if pc2400m_wihal_if = {
+        pc2400m_drv_wihal_command
+};
+
+/** structure to pass driver cleanup data */
+struct pc2400m_drv_close_resp_data {
+        void *user_data;
+        t_wihal_cmd_response_fnc resp_func;
+};
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/** local function declarations */
+static void pc2400m_drv_prod_test_resp(
+        struct pc2400m_drv_cd_if*,
+        wimax_osal_packet*,
+        void*);
+static void pc2400m_drv_pkt_handler(
+        struct pc2400m_drv_cd_if*,
+        wimax_osal_packet_list*,
+        void*);
+static void pc2400m_drv_dbg_handler(
+        struct pc2400m_drv_cd_if*,
+        wimax_osal_packet*,
+        void*);
+
+
+/*****************************************************************************
+ * Local functions
+ */
+
+/** Convert a BSID mask to a WiHAL NAP mask. This function analyses a BSID
+ *  mask and returns an WiHAL enumeration based on its findings.
+ *
+ *  @param ctx handle identifying the driver instance
+ *  @param bsid_mask pointer to the 6 byte BSID mask
+ *  @return returns the WiHAL nap mask type identifier
+ */
+static enum t_wihal_nap_id_mask pc2400m_drv_get_nap_id_mask(
+        wimax_osal_context *ctx,
+        u8 *bsid_mask)
+{
+
+        enum t_wihal_nap_id_mask ret = E_WIHAL_NAP_ID_MASK_NA;
+
+        PC2400M_DRV_UNWARN(ctx);
+
+        wimax_osal_assert(bsid_mask);
+
+        /* the following checks whether all bits are set in the first three
+           bytes of the full (6 byte) BSID. The first three bytes signify the
+           24-bit NAP identifier. */
+        if (bsid_mask[0] == 0xff &&
+            bsid_mask[1] == 0xff &&
+            bsid_mask[2] == 0xff)
+                ret = E_WIHAL_NAP_ID_MASK_FULL;
+        else {
+                /* a compressed NAP identifier has all bits of its least
+                   significant byte (third byte) set. this is the minumum
+                   required - otherwise something unexpected has occurred. */
+                wimax_osal_assert(bsid_mask[2] == 0xff);
+                ret = E_WIHAL_NAP_ID_MASK_COMPRESSED;
+        }
+        return ret;
+
+}
+
+/** Determine NSP flag based on BSID. Determine the NSP flag value based on
+ *  the provided BSID - may return N/A value if the flag cannot be determined
+ *  from the BSID info.
+ *
+ *  @param ctx handle identifying the driver instance
+ *  @param bsid_mask pointer to the 6 byte BSID mask
+ *  @param bsid pointer to the 6 byte BSID
+ *  @return returns the WiHAL NAP and NSP enumeration value
+ */
+static enum t_wihal_nap_and_nsp pc2400m_drv_get_nap_and_nsp_flag(
+        wimax_osal_context *ctx,
+        u8 *bsid_mask,
+        u8 *bsid)
+{
+
+        enum t_wihal_nap_and_nsp ret = E_WIHAL_NAP_AND_NSP_NA;
+
+        PC2400M_DRV_UNWARN(ctx);
+
+        wimax_osal_assert(bsid_mask && bsid);
+
+        /* the most significant bit of the fourth byte of the BSID indicates,
+           whether the NSP id is the same as the NAP id. If the bit is set,
+           they are not the same, otherwise they are. */
+        /* if the specific bit is not set according to the mask, the value
+           of this bit is unspecified. */
+        if (bsid_mask[3] & 0x80) {
+                if (bsid[3] & 0x80)
+                        ret = E_WIHAL_NAP_AND_NSP_FALSE;
+                else
+                        ret = E_WIHAL_NAP_AND_NSP_TRUE;
+        }
+
+        return ret;
+}
+
+/** Convert channel params to channel plan. Convert channel parameters from
+ *  chipset into a WiHAL channel plan structure.
+ *
+ *  @param ctx handle identifying the driver instance
+ *  @cp pointer to channel plan to fill out
+ *  @freq channel frequency value chipset
+ *  @bw channel bandwidth value from chipset
+ *  @fft channel fft length value from chipset
+ *  @preamble channel preable bits from chipset
+ *  @return none
+ */
+static void pc2400m_drv_get_channel_plan(
+        wimax_osal_context *ctx,
+        struct t_wihal_search_plan *cp,
+        u32 freq,
+        u8 bw,
+        u8 fft,
+        u8 *preamble)
+{
+
+        PC2400M_DRV_UNWARN(ctx);
+
+        /* this function relies on the assumption, that the value range of
+           the chipset and WiHAL variables are identical. below, this
+           assumption is enforced. */
+        wimax_osal_assert(
+                E_WIHAL_FFT_SIZE_512 == L3L4_FFT_512 &&
+                E_WIHAL_FFT_SIZE_1024 == L3L4_FFT_1024 &&
+                E_WIHAL_CHANNEL_BANDWIDTH_3_5MHZ ==
+                        L3L4_BANDWIDTH_3_5 &&
+                E_WIHAL_CHANNEL_BANDWIDTH_5MHZ ==
+                L3L4_BANDWIDTH_5 &&
+                E_WIHAL_CHANNEL_BANDWIDTH_7MHZ ==
+                L3L4_BANDWIDTH_7 &&
+                E_WIHAL_CHANNEL_BANDWIDTH_8_75MHZ ==
+                L3L4_BANDWIDTH_8_75 &&
+                E_WIHAL_CHANNEL_BANDWIDTH_10MHZ ==
+                L3L4_BANDWIDTH_10);
+        wimax_osal_assert((bw != L3L4_BANDWIDTH_NA) && (fft != L3L4_FFT_NA));
+
+        cp->carrier_freq = WIMAX_OSAL_LE_TO_U32(freq);
+        cp->channel_bandwidth = (enum t_wihal_channel_bandwidth)bw;
+        cp->fft_size = (enum t_wihal_fft_size)fft;
+        wimax_osal_mem_cpy(
+                cp->preamble,
+                preamble,
+                WIHAL_PREAMBLE_SIZE);
+
+        return;
+
+}
+
+
+/** Send WiHAL ESearchNAPIndication. Construct and send a ESearchNAPIndication
+ *  message to the client to inform it of a found BS.
+ *
+ *  @param ctx handle identifying the driver instance
+ *  @param res_nap_id the NAP associated to the found BS
+ *  @param res_nap_id_mask the NAP mask of the NAP
+ *  @param res_nap_and_nsp NSP flag indicating NAP and NSP are the same
+ *  @param res_rssi RSSI value of this particular BS
+ *  @param res_cinr CINR value of this particular BS
+ *  @param res_channel Channel parameters of this particular BS
+ *  @return none
+ */
+static void pc2400m_drv_send_search_ind(
+        wimax_osal_context *ctx,
+        u32 res_nap_id,
+        enum t_wihal_nap_id_mask res_nap_id_mask,
+        enum t_wihal_nap_and_nsp res_nap_and_nsp,
+        u8 res_rssi,
+        u8 res_cinr,
+        struct t_wihal_search_plan *res_channel)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+        struct t_wihal_search_result search_result;
+        struct t_wihal_ind ind;
+
+        wimax_osal_assert(res_channel);
+
+        /* initialize the indication message generic part */
+        ind.ind_id = E_WIHAL_SEARCH_NAP_IND;
+        ind.ind.search_nap.result_count = 1;
+        ind.ind.search_nap.p_search_result = &search_result;
+
+        /* fill in search result info */
+        ind.ind.search_nap.p_search_result->nap_id = res_nap_id;
+        ind.ind.search_nap.p_search_result->nap_id_mask = res_nap_id_mask;
+        ind.ind.search_nap.p_search_result->signal_strength = res_rssi;
+        ind.ind.search_nap.p_search_result->cinr = res_cinr;
+        ind.ind.search_nap.p_search_result->nap_and_nsp = res_nap_and_nsp;
+        wimax_osal_mem_cpy(
+                &ind.ind.search_nap.p_search_result->channel,
+                res_channel,
+                sizeof(struct t_wihal_search_plan));
+
+        /* provide this information to the client */
+        priv->eif->ind(ctx, &ind);
+
+        return;
+}
+
+/** Send WiHAL ESearchNAPResponse. Construct and send a ESearchNAPResponse to
+ *  the client to indicate to it that scanning is complete.
+ *
+ *  @param ctx handle identifying the driver instance
+ *  @param status Resulting status of the operation
+ *  @param client_data Client data pointer passed to the SCAN transition
+ *         during start
+ *  @return none
+ */
+static void pc2400m_drv_send_search_nap_resp(
+        wimax_osal_context *ctx,
+        enum t_wihal_status status,
+        void *client_data)
+{
+
+        struct t_wihal_resp resp;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+
+        resp.cmd_resp_id = E_WIHAL_SEARCH_NAP_RESP;
+        resp.cmd_status = status;
+
+        /* provide this information to the client */
+        priv->eif->cmd_resp(ctx, &resp, client_data);
+
+        return;
+}
+
+
+/** Send WiHAL ESearchNSPResponse. Construct and send a ESearchNSPResponse to
+ *  the client to indicate to it that NSP discovery is complete, and pass on
+ *  the results. NOTE that the caller will clean up memory associated with the
+ *  message.
+ *
+ *  @param ctx handle identifying the driver instance
+ *  @param status Resulting status of the operation
+ *  @param nap_id The NAP id that was searched
+ *  @param nsp_cc NSP change count value
+ *  @param nap_and_nsp Bit indicating whether the NAP and NSP are the same
+ *  @param nsp_count Number of NSPs listed in the following list
+ *  @param nsp Pointer to first element of a list containing the found NSPs
+ *  @param client_data Client data pointer passed to the SCAN transition
+ *                     during start
+ *  @return none
+ */
+static void pc2400m_drv_send_search_nsp_resp(
+        wimax_osal_context *ctx,
+        enum t_wihal_status status,
+        t_wihal_nap_id nap_id,
+        t_wihal_nsp_change_count nsp_cc,
+        enum t_wihal_nap_and_nsp nap_and_nsp,
+        u32 nsp_count,
+        struct t_wihal_nsp_info *nsp,
+        void *client_data)
+{
+
+        struct t_wihal_resp resp;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+
+        resp.cmd_resp_id = E_WIHAL_SEARCH_NSP_RESP;
+        resp.cmd_status = status;
+
+        /* fill in with the NSP specific information */
+        resp.resp.search_nsp.nap_id = nap_id;
+        resp.resp.search_nsp.nsp_change_count = nsp_cc;
+        resp.resp.search_nsp.nap_and_nsp = nap_and_nsp;
+        resp.resp.search_nsp.nsp_count = nsp_count;
+        resp.resp.search_nsp.p_nsp = nsp;
+
+        /* provide this information to the client */
+        priv->eif->cmd_resp(ctx, &resp, client_data);
+
+        return;
+}
+
+
+/** Send WiHAL ESystemStateIndication. Construct and send a
+ *  ESystemStateIndication to the client to indicate to it that a change in the
+ *  system state has occurred.
+ *
+ *  @param ctx handle identifying the driver instance
+ *  @param system_state The cause code for the indication
+ *  @return none
+ */
+static void pc2400m_drv_send_system_state_ind(
+        wimax_osal_context *ctx,
+        enum t_wihal_system_state system_state)
+{
+
+        struct t_wihal_ind ind;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+
+        ind.ind_id = E_WIHAL_SYSTEM_STATE_IND;
+        ind.ind.system_state.system_state = system_state;
+
+        /* send indication */
+        priv->eif->ind(ctx, &ind);
+
+}
+
+
+/** Send WiHAL ENetworkStatusIndication. Construct and send a
+ *  ENetworkStatusIndication to the client to indicate to it the current
+ *  network status.
+ *
+ *  @param ctx handle identifying the driver instance
+ *  @param network_status The current network status
+ *  @param status The cause code for the current network status
+ *  @param bs_id Identifier of the connected to BS (valid only if connected)
+ *  @param cp Channel parameters of the connected to BS (valid only if
+ *            connected)
+ *  @param nsp_realm_len Length of the following realm name field
+ *  @param nsp_realm Field containing a string indicating the REALM
+ *  @return none
+ */
+static void pc2400m_drv_send_network_status_ind(
+        wimax_osal_context *ctx,
+        enum t_wihal_network_status network_status,
+        enum t_wihal_network_status_err status,
+        t_wihal_bsid bs_id,
+        struct t_wihal_search_plan *cp,
+        u32 nsp_realm_len,
+        u8 *nsp_realm)
+{
+
+        struct t_wihal_ind ind;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+
+        if (network_status == E_WIHAL_NETWORK_STATUS_DISCONNECTED) {
+
+                /* close the EAP data pipe by disconnecting its handlers */
+                priv->dm->cd->register_indication(
+                        priv->dm->cd, L3_L4_OPCODE_REPORT_EAP_REQUEST,
+                        NULL, NULL);
+
+                priv->dm->cd->register_indication(
+                        priv->dm->cd, L3_L4_OPCODE_REPORT_ALT_ACCEPT,
+                        NULL, NULL);
+
+                priv->dm->cd->register_indication(
+                        priv->dm->cd, L3_L4_OPCODE_REPORT_KEY_REQUEST,
+                        NULL, NULL);
+        }
+
+        /* prepare a network status indication message to the client */
+        ind.ind_id = E_WIHAL_NETWORK_STATUS_IND;
+        ind.ind.network_status.network_status = network_status;
+        ind.ind.network_status.network_status_err = status;
+        ind.ind.network_status.nsp_realm_len = nsp_realm_len;
+        /* note that this pointer will only be borrowed to the called
+           handler */
+        ind.ind.network_status.p_nsp_realm = nsp_realm;
+
+        if (bs_id) {
+                wimax_osal_mem_cpy(
+                        ind.ind.network_status.bsid,
+                        bs_id,
+                        WIHAL_BSID_LENGTH);
+                ind.ind.network_status.nap_and_nsp =
+                        PC2400M_DRV_GET_WIHAL_NAP_AND_NSP(
+                                priv, PC2400M_DRV_FULL_BSID_MASK, bs_id);
+        } else {
+                wimax_osal_mem_cpy(
+                        ind.ind.network_status.bsid,
+                        PC2400M_DRV_FULL_BSID_MASK,
+                        WIHAL_BSID_LENGTH);
+                ind.ind.network_status.nap_and_nsp =
+                        E_WIHAL_NAP_AND_NSP_NA;
+        }
+
+        if (cp) {
+                wimax_osal_mem_cpy(
+                        &ind.ind.network_status.channel,
+                        cp,
+                        sizeof(struct t_wihal_search_plan));
+        } else {
+
+                wimax_osal_mem_set(
+                        &ind.ind.network_status.channel,
+                        0x00,
+                        sizeof(struct t_wihal_search_plan));
+        }
+
+        /* send indication */
+        priv->eif->ind(ctx, &ind);
+
+}
+
+/** Send WiHAL ENetworkStatusResponse. Construct and send a
+ *  ENetworkStatusResponse to the client to indicate to it the current network
+ *  status as requested.
+ *
+ *  @param ctx handle identifying the driver instance
+ *  @param status The result status of the operation
+ *  @param network_status The current network status
+ *  @param bs_id Identifier of the connected to BS (valid only if connected)
+ *  @param cp Channel parameters of the connected to BS (valid only if
+ *            connected)
+ *  @param rssi the RSSI value of the connection (valid only if connected)
+ *  @param cinr the CINR value of the connection (valid only if connected)
+ *  @param client_data Client data pointer passed to the operation during its
+ *                     start
+ *  @return none
+ */
+static void pc2400m_drv_send_network_status_resp(
+        wimax_osal_context *ctx,
+        enum t_wihal_status status,
+        enum t_wihal_network_status network_status,
+        t_wihal_bsid bsid,
+        struct t_wihal_search_plan *cp,
+        u8 rssi,
+        u8 cinr,
+        void *client_data)
+{
+
+        struct t_wihal_resp resp;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+
+        resp.cmd_resp_id = E_WIHAL_NETWORK_STATUS_RESP;
+        resp.cmd_status = status;
+
+        /* fill in with the NSP specific information */
+        resp.resp.network_status.network_status = network_status;
+        resp.resp.network_status.signal_strength = rssi;
+        resp.resp.network_status.cinr = cinr;
+        wimax_osal_mem_cpy(
+                resp.resp.network_status.bsid,
+                bsid,
+                WIHAL_BSID_LENGTH);
+        wimax_osal_mem_cpy(
+                &resp.resp.network_status.channel,
+                cp,
+                sizeof(struct t_wihal_search_plan));
+
+        /* provide this information to the client */
+        priv->eif->cmd_resp(ctx, &resp, client_data);
+
+        return;
+
+}
+
+
+/** Send WiHAL ECloseResponse. Construct and send a ECloseResponse to the
+ *  client to indicate to it the driver instance has been deleted, and this
+ *  thread of execution is the last thread to run in the code. The undelying
+ *  ctx may be deleted while this response is processed.
+ *
+ *  @param ctx handle identifying the driver instance
+ *  @param data The given to unref_data
+ *  @return none
+ */
+static void pc2400m_drv_send_close_resp(wimax_osal_context *ctx, void *data)
+{
+
+        /* The CTX->priv is no longer valid here, this function is called post
+           mortem to the driver instance to indicate to the client, that
+           finalization is complete. The "data" pointer is used to hold the
+           important references until the cleanup is complete. */
+
+        struct pc2400m_drv_close_resp_data *respdata =
+                (struct pc2400m_drv_close_resp_data*)data;
+        t_wihal_cmd_response_fnc resp_func = respdata->resp_func;
+        void *user_data = respdata->user_data;
+        struct t_wihal_resp resp;
+
+        /* free the memory for the response data */
+        wimax_osal_mem_free((void**)&respdata);
+
+        /* send notification */
+        resp.cmd_resp_id = E_WIHAL_CLOSE_RESP;
+        resp.cmd_status = E_WIHAL_SUCCESS;
+        resp_func(ctx, &resp, user_data);
+
+}
+
+/** Process EConfigure completion. Handle the completion of EConfigure by
+ *  sending the appropriate response event with the capability fields filled.
+ *
+ *  @param dm handle identifying the device manager instance
+ *  @param status The result status of the operation
+ *  @param data Parameter data passed to the transition
+ *  @param cbdata Call back specific cookie data passed to the transition
+ *  @param cbdatacl Client specific cookie data passed to the transition
+ *  @return none
+ */
+static void pc2400m_drv_configure_resp(
+        struct pc2400m_drv_dm_if *dm,
+        s32 status,
+        void *data,
+        void *cbdata,
+        void *cbdatacl)
+{
+
+        wimax_osal_context *ctx = (wimax_osal_context*)cbdata;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+        struct pc2400m_drv_dm_configure_params *params = data;
+        struct t_wihal_resp resp;
+
+        PC2400M_DRV_UNWARN(data);
+        PC2400M_DRV_UNWARN(dm);
+
+        resp.cmd_resp_id = E_WIHAL_CONFIGURE_RESP;
+        resp.cmd_status = PC2400M_DRV_GET_WIHAL_ERROR(status);
+
+        wimax_osal_mem_cpy(
+                &(resp.resp.configure.capabilities),
+                &params->capa,
+                sizeof(struct t_wihal_capabilities));
+
+        wimax_osal_mem_free((void**)&params);
+
+        /* send response */
+        priv->eif->cmd_resp(ctx, &resp, cbdatacl);
+
+}
+
+/** Process ERadioState completion. Handle the completion of ERadioState by
+ *  sending the appropriate response the client with the appropriate status
+ *  code set.
+ *
+ *  @param dm handle identifying the device manager instance
+ *  @param status The result status of the operation
+ *  @param data Parameter data passed to the transition
+ *  @param cbdata Call back specific cookie data passed to the transition
+ *  @param cbdatacl Client specific cookie data passed to the transition
+ *  @return none
+ */
+static void pc2400m_drv_radio_state_resp(
+        struct pc2400m_drv_dm_if *dm,
+        s32 status,
+        void *data,
+        void *cbdata,
+        void *cbdatacl)
+{
+
+        wimax_osal_context *ctx = (wimax_osal_context*)cbdata;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+        struct t_wihal_resp resp;
+
+        PC2400M_DRV_UNWARN(dm);
+        PC2400M_DRV_UNWARN(data);
+
+        resp.cmd_resp_id = E_WIHAL_RADIO_STATE_RESP;
+        resp.cmd_status = PC2400M_DRV_GET_WIHAL_ERROR(status);
+
+        /* send response */
+        priv->eif->cmd_resp(ctx, &resp, cbdatacl);
+
+}
+
+
+/** Process ESearchNAP completion. Handle the completion of ESearchNAP by
+ *  clearing up the parameter data provided to the transition upon its startup.
+ *  The response will be implicitly sent by the scanning background transition,
+ *  when it completes.
+ *
+ *  @param dm handle identifying the device manager instance
+ *  @param status The result status of the operation
+ *  @param data Parameter data passed to the transition
+ *  @param cbdata Call back specific cookie data passed to the transition
+ *  @param cbdatacl Client specific cookie data passed to the transition
+ *  @return none
+ */
+static void pc2400m_drv_search_nap_resp(
+        struct pc2400m_drv_dm_if *dm,
+        s32 status,
+        void *data,
+        void *cbdata,
+        void *cbdatacl)
+{
+
+        struct pc2400m_drv_dm_bg_scan_nap_params *params = data;
+
+        PC2400M_DRV_UNWARN(dm);
+        PC2400M_DRV_UNWARN(cbdatacl);
+        PC2400M_DRV_UNWARN(cbdata);
+        PC2400M_DRV_UNWARN(status);
+
+        /* free parameter data */
+        wimax_osal_assert(params);
+
+        /* NOTE that the DM will take ownership of the list, and set
+           the pointer in the request to NULL if it does so */
+        wimax_osal_mem_free((void**)&(params->req.p_search_plan));
+        wimax_osal_mem_free((void**)&params);
+
+        return;
+
+}
+
+/** Process ESearchNAPStop completion. Handle the completion of ESearchNAP by
+ *  sending the appropriate response to the client with the return status value
+ *  set appropriately.
+ *
+ *  @param dm handle identifying the device manager instance
+ *  @param status The result status of the operation
+ *  @param data Parameter data passed to the transition
+ *  @param cbdata Call back specific cookie data passed to the transition
+ *  @param cbdatacl Client specific cookie data passed to the transition
+ *  @return none
+ */
+static void pc2400m_drv_search_nap_stop_resp(
+        struct pc2400m_drv_dm_if *dm,
+        s32 status,
+        void *data,
+        void *cbdata,
+        void *cbdatacl)
+{
+
+        wimax_osal_context *ctx = (wimax_osal_context*)cbdata;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+        struct t_wihal_resp resp;
+
+        PC2400M_DRV_UNWARN(dm);
+        PC2400M_DRV_UNWARN(data);
+
+        resp.cmd_resp_id = E_WIHAL_SEARCH_NAP_STOP_RESP;
+        resp.cmd_status = PC2400M_DRV_GET_WIHAL_ERROR(status);
+
+        /* send response */
+        priv->eif->cmd_resp(ctx, &resp, cbdatacl);
+
+}
+
+/** Process ESearchNSP completion. Handle the completion of ESearchNSP by
+ *  freeing the parameter data sent to the transition upon its start. The
+ *  response will be sent from the background transition upon its completion.
+ *
+ *  @param dm handle identifying the device manager instance
+ *  @param status The result status of the operation
+ *  @param data Parameter data passed to the transition
+ *  @param cbdata Call back specific cookie data passed to the transition
+ *  @param cbdatacl Client specific cookie data passed to the transition
+ *  @return none
+ */
+static void pc2400m_drv_search_nsp_resp(
+        struct pc2400m_drv_dm_if *dm,
+        s32 status,
+        void *data,
+        void *cbdata,
+        void *cbdatacl)
+{
+
+        struct pc2400m_drv_dm_bg_scan_nsp_params *params = data;
+
+        PC2400M_DRV_UNWARN(dm);
+        PC2400M_DRV_UNWARN(cbdatacl);
+        PC2400M_DRV_UNWARN(cbdata);
+        PC2400M_DRV_UNWARN(status);
+
+        /* free parameter data */
+        wimax_osal_assert(params);
+        wimax_osal_mem_free((void**)&params);
+
+        return;
+
+}
+
+
+/** Process ESearchNSPStop completion. Handle the completion of ESearchNSPStop
+ *  by sending the appropriate response to the client with the return status
+ *  value set appropriately.
+ *
+ *  @param dm handle identifying the device manager instance
+ *  @param status The result status of the operation
+ *  @param data Parameter data passed to the transition
+ *  @param cbdata Call back specific cookie data passed to the transition
+ *  @param cbdatacl Client specific cookie data passed to the transition
+ *  @return none
+ */
+static void pc2400m_drv_search_nsp_stop_resp(
+        struct pc2400m_drv_dm_if *dm,
+        s32 status,
+        void *data,
+        void *cbdata,
+        void *cbdatacl)
+{
+
+        wimax_osal_context *ctx = (wimax_osal_context*)cbdata;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+        struct t_wihal_resp resp;
+
+        PC2400M_DRV_UNWARN(dm);
+        PC2400M_DRV_UNWARN(data);
+
+        resp.cmd_resp_id = E_WIHAL_SEARCH_NSP_STOP_RESP;
+        resp.cmd_status = PC2400M_DRV_GET_WIHAL_ERROR(status);
+
+        /* send response */
+        priv->eif->cmd_resp(ctx, &resp, cbdatacl);
+
+}
+
+
+/** Process EEntry completion. Handle the completion of Entry by freeing the
+ *  parameter data sent to the transition upon its start and sending the
+ *  appropriate response with the status code appropriately set to the client.
+ *
+ *  @param dm handle identifying the device manager instance
+ *  @param status The result status of the operation
+ *  @param data Parameter data passed to the transition
+ *  @param cbdata Call back specific cookie data passed to the transition
+ *  @param cbdatacl Client specific cookie data passed to the transition
+ *  @return none
+ */
+static void pc2400m_drv_connect_resp(
+        struct pc2400m_drv_dm_if *dm,
+        s32 status,
+        void *data,
+        void *cbdata,
+        void *cbdatacl)
+{
+
+        wimax_osal_context *ctx = (wimax_osal_context*)cbdata;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+        struct t_wihal_resp resp;
+
+        PC2400M_DRV_UNWARN(dm);
+
+        wimax_osal_mem_free((void**)&data);
+
+        resp.cmd_resp_id = E_WIHAL_ENTRY_RESP;
+        resp.cmd_status = PC2400M_DRV_GET_WIHAL_ERROR(status);
+
+        /* send response */
+        priv->eif->cmd_resp(ctx, &resp, cbdatacl);
+
+}
+
+/** Process EExit completion. Handle the completion of EExit by sending the
+ *  appropriate response with the status code appropriately set to the client.
+ *
+ *  @param dm handle identifying the device manager instance
+ *  @param status The result status of the operation
+ *  @param data Parameter data passed to the transition
+ *  @param cbdata Call back specific cookie data passed to the transition
+ *  @param cbdatacl Client specific cookie data passed to the transition
+ *  @return none
+ */
+static void pc2400m_drv_disconnect_resp(
+        struct pc2400m_drv_dm_if *dm,
+        s32 status,
+        void *data,
+        void *cbdata,
+        void *cbdatacl)
+{
+
+        wimax_osal_context *ctx = (wimax_osal_context*)cbdata;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+        struct t_wihal_resp resp;
+
+        PC2400M_DRV_UNWARN(dm);
+        PC2400M_DRV_UNWARN(data);
+
+        resp.cmd_resp_id = E_WIHAL_EXIT_RESP;
+        resp.cmd_status = PC2400M_DRV_GET_WIHAL_ERROR(status);
+
+        /* send response */
+        priv->eif->cmd_resp(ctx, &resp, cbdatacl);
+
+}
+
+/** Process production mode entry completion. Handle the completion of the
+ *  production mode entry by sending via the control dispatcher the production
+ *  line message that triggered the change to production mode in the first
+ *  place.
+ *
+ *  @param dm handle identifying the device manager instance
+ *  @param status The result status of the operation
+ *  @param data Parameter data passed to the transition
+ *  @param cbdata Call back specific cookie data passed to the transition
+ *  @param cbdatacl Client specific cookie data passed to the transition
+ *  @return none
+ */
+static void pc2400m_drv_production_resp(
+        struct pc2400m_drv_dm_if *dm,
+        s32 status,
+        void *data,
+        void *cbdata,
+        void *cbdatacl)
+{
+
+        wimax_osal_context *ctx = (wimax_osal_context*)cbdata;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+        wimax_osal_packet *msg = (wimax_osal_packet*)data;
+
+        PC2400M_DRV_UNWARN(dm);
+
+        if (!status)
+                /* set the driver into production testing mode */
+                priv->mode_flags |= PC2400M_DRV_COM_PROD_TEST_MODE;
+        else {
+                /* send to the client a 'NULL' message, indicating that
+                   the production message has failed. */
+                pc2400m_drv_prod_test_resp(
+                        priv->dm->cd,
+                        NULL,
+                        (void*)ctx);
+        }
+
+        /* forward message directly to the control dispatcher */
+        if (priv->dm && priv->dm->cd &&
+                (priv->mode_flags & PC2400M_DRV_COM_PROD_TEST_MODE)) {
+
+                /* this operation will not maintain client data pointers */
+                wimax_osal_assert(!cbdatacl);
+                priv->dm->cd->msg_enqueue(
+                        priv->dm->cd,
+                        msg,
+                        pc2400m_drv_prod_test_resp,
+                        (void*)ctx,
+                        PC2400M_CD_FLAG_NONE);
+        } else
+                wimax_osal_packet_free(&msg);
+
+}
+
+/** Process ESuspend completion. Handle the completion of the ESuspend by
+ *  sending the appropriate response with the status appropriately set to the
+ *  client.
+ *
+ *  @param dm handle identifying the device manager instance
+ *  @param status The result status of the operation
+ *  @param data Parameter data passed to the transition
+ *  @param cbdata Call back specific cookie data passed to the transition
+ *  @param cbdatacl Client specific cookie data passed to the transition
+ *  @return none
+ */
+static void pc2400m_drv_suspend_resp(
+        struct pc2400m_drv_dm_if *dm,
+        s32 status,
+        void *data,
+        void *cbdata,
+        void *cbdatacl)
+{
+
+        wimax_osal_context *ctx = (wimax_osal_context*)cbdata;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+        struct t_wihal_resp resp;
+
+        PC2400M_DRV_UNWARN(dm);
+        PC2400M_DRV_UNWARN(status);
+        PC2400M_DRV_UNWARN(data);
+
+        /* suspend cannot fail, hence status is ignored */
+        resp.cmd_resp_id = E_WIHAL_SUSPEND_RESP;
+        resp.cmd_status = E_WIHAL_SUCCESS;
+
+        /* send response */
+        priv->eif->cmd_resp(ctx, &resp, cbdatacl);
+
+}
+
+/** Process EResume completion. Handle the completion of the EResume by sending
+ *  the appropriate response with the status appropriately set to the client.
+ *
+ *  @param dm handle identifying the device manager instance
+ *  @param status The result status of the operation
+ *  @param data Parameter data passed to the transition
+ *  @param cbdata Call back specific cookie data passed to the transition
+ *  @param cbdatacl Client specific cookie data passed to the transition
+ *  @return none
+ */
+static void pc2400m_drv_resume_resp(
+        struct pc2400m_drv_dm_if *dm,
+        s32 status,
+        void *data,
+        void *cbdata,
+        void *cbdatacl)
+{
+
+        wimax_osal_context *ctx = (wimax_osal_context*)cbdata;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+        struct t_wihal_resp resp;
+
+        PC2400M_DRV_UNWARN(dm);
+        PC2400M_DRV_UNWARN(status);
+        PC2400M_DRV_UNWARN(data);
+
+        /* resume cannot fail, so status is ignored */
+        resp.cmd_resp_id = E_WIHAL_RESUME_RESP;
+        resp.cmd_status = E_WIHAL_SUCCESS;
+
+        /* send response */
+        priv->eif->cmd_resp(ctx, &resp, cbdatacl);
+
+}
+
+/** Process EClose completion. Handle the completion of the EClose by disabling
+ *  the chipset interrupt, powering down the chipset, and then unreferencing
+ *  the main reference to the driver, causing the driver to be deleted and the
+ *  ECloseResponse to be sent when all threads of execution have left the code.
+ *
+ *  @param dm handle identifying the device manager instance
+ *  @param status The result status of the operation
+ *  @param data  Parameter data passed to the transition
+ *  @param cbdata Call back specific cookie data passed to the transition
+ *  @param cbdatacl Client specific cookie data passed to the transition
+ *  @return none
+ */
+static void pc2400m_drv_close_resp(
+        struct pc2400m_drv_dm_if *dm,
+        s32 status,
+        void *data,
+        void *cbdata,
+        void *cb_cldata)
+{
+
+        wimax_osal_context *ctx = (wimax_osal_context*)cbdata;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+        struct pc2400m_drv_close_resp_data *respdata;
+
+        PC2400M_DRV_UNWARN(dm);
+        PC2400M_DRV_UNWARN(status);
+        PC2400M_DRV_UNWARN(data);
+
+        /* power off the chipset */
+        dm->hdi->irq_off(dm->hdi);
+        priv->aif->set_power(ctx, FALSE);
+
+        /* the unref operator will take care of cleaning the instance
+           once the stack has been cleared of references to it =>
+           it will then call our function and allow the thing to
+           finalize */
+        respdata = (struct pc2400m_drv_close_resp_data*)
+                wimax_osal_mem_alloc(
+                        sizeof(struct pc2400m_drv_close_resp_data));
+        respdata->user_data = cb_cldata;
+        respdata->resp_func = priv->eif->cmd_resp;
+
+        priv->unref_data(priv, pc2400m_drv_send_close_resp, respdata);
+
+        return;
+
+}
+
+/** EInitialize response handler. Send the EInitializeResponse to the client
+ *  setting the appropriate status code. If the initialization fails, reset
+ *  the instances to startup state.
+ *
+ *  @param dm handle to the device manager instance
+ *  @param ret return status code
+ *  @param data pointer used to carry the priv pointer
+ *  @return none
+ */
+static void pc2400m_drv_initialize_resp(
+        struct pc2400m_drv_dm_if *hnd,
+        s32 ret,
+        void *data)
+{
+
+        struct t_wihal_resp resp;
+        wimax_osal_context *ctx = hnd->ctx;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+
+        if (ret != ESUCCESS) {
+                priv->dm->reset(priv->dm);
+        }
+
+        if (ret == ESUCCESS) {
+                /* register data handler */
+                priv->dm->cd->register_pkt_handler(
+                        priv->dm->cd, pc2400m_drv_pkt_handler, (void*)ctx);
+
+                /* register trace handler */
+                priv->dm->cd->register_dbg_handler(
+                        priv->dm->cd, pc2400m_drv_dbg_handler, (void*)ctx);
+        }
+
+        /* generate response */
+        resp.cmd_resp_id = E_WIHAL_INITIALIZE_RESP;
+        if (ret != ESUCCESS)
+                resp.cmd_status = E_WIHAL_ERR_FAILURE;
+        else
+                resp.cmd_status = E_WIHAL_SUCCESS;
+
+        priv->eif->cmd_resp(ctx, &resp, data);
+
+        return;
+
+}
+
+
+/** Transmit production test message response. Forward the response to a direct
+ *  production testing pipe message from the chipset to the client.
+ *
+ *  @param cd handle identifying the control dispatcher instance
+ *  @param msg response message from the chipset
+ *  @param data data handle used to pass the priv pointer
+ *  @return none
+ */
+static void pc2400m_drv_prod_test_resp(
+        struct pc2400m_drv_cd_if *cd,
+        wimax_osal_packet *msg,
+        void *data)
+{
+
+        wimax_osal_context *ctx = (wimax_osal_context*)data;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+        struct t_wihal_resp resp;
+
+        PC2400M_DRV_UNWARN(cd);
+
+        resp.cmd_resp_id = E_WIHAL_PROD_TEST_RESP;
+        if (msg)
+                resp.cmd_status = E_WIHAL_SUCCESS;
+        else
+                resp.cmd_status = E_WIHAL_ERR_FAILURE;
+
+        resp.resp.prod_test.p_data = msg;
+
+        /* send response */
+        priv->eif->cmd_resp(ctx, &resp, NULL);
+
+}
+
+
+/** Transmit diagnostics message response. Forward the response to a direct
+ *  diagnostics pipe message from the chipset to the client.
+ *
+ *  @param cd handle identifying the control dispatcher instance
+ *  @param msg response message from the chipset
+ *  @param data data handle used to pass the priv pointer
+ *  @return none
+ */
+static void pc2400m_drv_diagnostics_resp(
+        struct pc2400m_drv_cd_if *cd,
+        wimax_osal_packet *msg,
+        void *data)
+{
+
+        wimax_osal_context *ctx = (wimax_osal_context*)data;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+        struct t_wihal_resp resp;
+
+        PC2400M_DRV_UNWARN(cd);
+
+        /* the diagnostics message return value will always be success, as
+           a response in itself indicates that response data from the chipset
+           has been successfully received. */
+        resp.cmd_resp_id = E_WIHAL_DIAGNOSTICS_RESP;
+        resp.cmd_status = E_WIHAL_SUCCESS;
+
+        resp.resp.diagnostics.p_data = msg;
+
+        /* send response */
+        priv->eif->cmd_resp(ctx, &resp, NULL);
+
+}
+
+/** Forward production indications to client. Forward the production related
+ *  chipset report message to the client via the production testing pipe
+ *  indication (EProdTestIndication.)
+ *
+ *  @param cd handle identifying the control dispatcher instance
+ *  @param msg response message from the chipset
+ *  @param data data handle used to pass the priv pointer
+ *  @return none
+ */
+static void pc2400m_drv_prod_handler(
+        struct pc2400m_drv_cd_if *cd,
+        wimax_osal_packet *msg,
+        void *data)
+{
+
+        wimax_osal_context *ctx = (wimax_osal_context*)data;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+        struct t_wihal_ind ind;
+
+        PC2400M_DRV_UNWARN(cd);
+
+        ind.ind_id = E_WIHAL_PROD_TEST_IND;
+        ind.ind.prod_test.p_data = msg;
+
+        /* send response */
+        priv->eif->ind(ctx, &ind);
+
+}
+
+/** Handle a debug message from the chipset. Forward debugging messages out of
+ *  the driver via the OSAL trace mechanism with the special DIAGNOSTIC
+ *  priority.
+ *
+ *  @param cd handle to the control dispatcher instance
+ *  @param msg message contents
+ *  @param data pointer used to carry the priv pointer
+ *  @return none
+ */
+static void pc2400m_drv_dbg_handler(
+        struct pc2400m_drv_cd_if *cd,
+        wimax_osal_packet *msg,
+        void *data)
+{
+
+        PC2400M_DRV_UNWARN(cd);
+        PC2400M_DRV_UNWARN(data);
+
+        /* trace the message out */
+        wimax_osal_trace_data(PC2400M_GROUP_CHIPSET,
+                              PC2400M_TRACE_UNSOLICITED,
+                              WIMAX_OSAL_TRACE_PRIORITY_DIAGNOSTIC,
+                              wimax_osal_packet_ptr(msg),
+                              wimax_osal_packet_size(msg));
+
+        wimax_osal_packet_free(&msg);
+
+}
+
+
+/** Buffer DL data packet. Append the received packet into the receive buffer,
+ *  and indicate to the client the availability of data
+ *  (EDataReceiveIndication.) If the buffer size exceeds a water mark, request
+ *  the chipset to stop sending further data.
+ *
+ *  @param cd handle identifying the control dispatcher instance
+ *  @param pkt_list list of IP packets from the chipset
+ *  @param data data handle used to pass the priv pointer
+ *  @return none
+ */
+static void pc2400m_drv_pkt_handler(
+        struct pc2400m_drv_cd_if *cd,
+        wimax_osal_packet_list *pkt_list,
+        void *data)
+{
+
+        struct pc2400m_private *priv =
+               wimax_osal_ctx_priv_get((wimax_osal_context*)data);
+        wimax_osal_packet *msg;
+        struct t_wihal_ind ind;
+
+        PC2400M_DRV_UNWARN(cd);
+
+        /* append the packets into the receive buffer */
+        while (wimax_osal_packet_list_len(pkt_list)) {
+                msg = wimax_osal_packet_list_pop(pkt_list);
+                wimax_osal_packet_list_append(&(priv->pkt_list), msg);
+        }
+
+        /* if the number of packets in the list exceeds a watermark,
+           request the chip to stop sending more */
+        if (wimax_osal_packet_list_len(&(priv->pkt_list)) >
+            PC2400M_DRV_RECEIVE_BUFFER_HIGH_WATERMARK) {
+                priv->dm->set_data_filter(priv->dm, FALSE);
+                priv->mode_flags |=
+                        PC2400M_DRV_COM_DATA_HOLD_MODE;
+        }
+
+        /* poll for a transmission unless not already polled */
+        if (!priv->recv_polled) {
+                ind.ind_id = E_WIHAL_DATA_RECV_IND;
+                ind.ind.data_receive.data_count =
+                        wimax_osal_packet_list_len(&(priv->pkt_list));
+                priv->recv_polled = 1;
+                priv->eif->ind(priv->ctx, &ind);
+        }
+}
+
+/** Send more TX data credits to the client. Send to the client the
+ *  EDataSendResponse message indicating to it that it again has credits to
+ *  send more data.
+ *
+ *  @param cd handle identifying the control dispatcher instance
+ *  @param data data pointer used to carry the priv reference
+ *  @return none
+ */
+static void pc2400m_drv_send_credit(struct pc2400m_drv_cd_if *cd, void *data)
+{
+
+        struct pc2400m_private *priv = (struct pc2400m_private*)data;
+        struct t_wihal_resp resp;
+
+        PC2400M_DRV_UNWARN(cd);
+
+        /* reset internal credit variable */
+        priv->send_credit = WIHAL_DATA_SEND_CREDIT_LEN;
+
+        /* send a response to give credit to the client too */
+        resp.cmd_status = E_WIHAL_SUCCESS;
+        resp.cmd_resp_id = E_WIHAL_DATA_SEND_RESP;
+        priv->eif->cmd_resp(priv->ctx, &resp, NULL);
+
+}
+
+
+/** Send UL packets to the chipset. Send all the packets provided to the
+ *  control dispatcher for sending to the chipset. Send more credit to the
+ *  client when the credit is depleted.
+ *
+ *  @param ctx handle to the osal context
+ *  @param cmd command holding the data packets
+ *  @return none
+ */
+static void pc2400m_drv_send_packets(
+        wimax_osal_context *ctx,
+        struct t_wihal_cmd *cmd)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+
+        /* not exceeding our credit are we? */
+        wimax_osal_assert(
+                priv->send_credit >=
+                (u32)wimax_osal_packet_list_len(&(cmd->cmd.data_send.p_data)));
+
+        /* reporting the same number of packets as are in the list? */
+        wimax_osal_assert(
+                cmd->cmd.data_send.data_count ==
+                (u32)wimax_osal_packet_list_len(&(cmd->cmd.data_send.p_data)));
+
+        priv->send_credit -=
+                wimax_osal_packet_list_len(&(cmd->cmd.data_send.p_data));
+
+        /* queue the data packet(s) */
+        priv->dm->cd->pkt_enqueue(
+                priv->dm->cd,
+                &(cmd->cmd.data_send.p_data));
+
+        /* if the credit is exhausted and the chipset can
+           take more data, send response */
+        if (!priv->send_credit) {
+
+                /* check from the control dispatcher whether
+                   more credit can be sent now or later */
+                if (priv->dm->cd->pkt_queue_has_space(
+                            priv->dm->cd,
+                            pc2400m_drv_send_credit,
+                            (void*)priv))
+                        pc2400m_drv_send_credit(
+                                NULL, (void*)priv);
+
+        }
+
+}
+
+/** Send DL packets to the client. Send up to max packets from the DL buffer
+ *  to the client, indicating to the client more data is available if the
+ *  buffer is not completely depleted.
+ *
+ *  @param ctx handle to the osal context
+ *  @param max maximum number of packets to send
+ *  @param cldata client data pointer passed by the receive request
+ *  @return none
+ */
+static void pc2400m_drv_receive_packets(
+        wimax_osal_context *ctx,
+        u32 max,
+        void *cldata)
+{
+
+        struct t_wihal_ind ind;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+        struct t_wihal_resp resp;
+        u32 i;
+
+        /* copy up to the specified number of packets from the buffer
+           into the data receive response message */
+        if (max < (u32)wimax_osal_packet_list_len(&(priv->pkt_list)))
+                max = (u32)wimax_osal_packet_list_len(&(priv->pkt_list));
+
+        resp.cmd_resp_id = E_WIHAL_DATA_RECEIVE_RESP;
+        resp.cmd_status = E_WIHAL_SUCCESS;
+        resp.resp.data_receive.data_count = max;
+        resp.resp.data_receive.last_packet = E_WIHAL_TRUE;
+
+        /* copy the actual packets */
+        wimax_osal_packet_list_initialize(&(resp.resp.data_receive.p_data));
+        for (i=0; i<max; i++) {
+                wimax_osal_packet_list_append(
+                        &(resp.resp.data_receive.p_data),
+                        wimax_osal_packet_list_pop(&(priv->pkt_list)));
+        }
+
+        priv->recv_polled = FALSE;
+        priv->eif->cmd_resp(ctx, &resp, cldata);
+
+        wimax_osal_packet_list_release(
+                &(resp.resp.data_receive.p_data), FALSE);
+
+        /* schedule another poll if there is still more data */
+        if (wimax_osal_packet_list_len(&(priv->pkt_list))) {
+                ind.ind_id = E_WIHAL_DATA_RECV_IND;
+                ind.ind.data_receive.data_count =
+                        wimax_osal_packet_list_len(&(priv->pkt_list));
+
+                priv->recv_polled = TRUE;
+                priv->eif->ind(ctx, &ind);
+        }
+
+        /* request data from the chipset, if the buffer size is below
+           the low water mark */
+        if (priv->mode_flags & PC2400M_DRV_COM_DATA_HOLD_MODE &&
+            (wimax_osal_packet_list_len(&(priv->pkt_list)) <
+             PC2400M_DRV_RECEIVE_BUFFER_HIGH_WATERMARK)) {
+                priv->dm->set_data_filter(priv->dm, TRUE);
+                priv->mode_flags &=
+                        (~PC2400M_DRV_COM_DATA_HOLD_MODE);
+        }
+
+
+}
+
+
+
+
+/** Forward EAP response message. Forward the EAP response message from the
+ *  chipset to the client
+ *
+ *  @param priv handle identifying the driver instance
+ *  @param msg EAP data packet from chipset
+ *  @return none
+ */
+static void pc2400m_drv_eap_response(
+        struct pc2400m_private *priv,
+        wimax_osal_packet *msg)
+{
+
+        struct L3L4_TLV_STR_REPORT_EAP_RESPONSE *resp;
+        wimax_osal_packet *newmsg;
+        u32 len = wimax_osal_packet_size(msg);
+
+        /* create a duplicate message with enough space to hold excess padding
+           at the end */
+        newmsg = wimax_osal_packet_alloc(
+                PC2400M_DRV_CHIPIF_CTRL_MSG_LEN +
+                WIMAX_OSAL_PAD4(L3L4_TLV_SIZE_REPORT_EAP_RESPONSE + len));
+
+        /* insert the message header in front of the TLV */
+        priv->dm->setup_header(
+                priv->dm,
+                wimax_osal_packet_put(newmsg, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN),
+                L4_L3_OPCODE_CMD_SEND_EAP_RESPONSE,
+                WIMAX_OSAL_PAD4(L3L4_TLV_SIZE_REPORT_EAP_RESPONSE + len));
+
+        /* insert the TLV header in front of the data */
+        resp = (struct L3L4_TLV_STR_REPORT_EAP_RESPONSE*)
+                wimax_osal_packet_put(
+                        newmsg, L3L4_TLV_SIZE_REPORT_EAP_RESPONSE);
+        resp->tlv.type =
+                WIMAX_OSAL_U16_TO_LE(L3L4_TLV_TYPE_REPORT_EAP_RESPONSE);
+        resp->tlv.length =
+                WIMAX_OSAL_U16_TO_LE(
+                        WIMAX_OSAL_PAD4(L3L4_TLV_SIZE_REPORT_EAP_RESPONSE +
+                                        len) - L3L4_TLV_HDR_LEN);
+        resp->length = WIMAX_OSAL_U16_TO_LE(len);
+
+        /* copy the payload data into the message */
+        wimax_osal_mem_cpy(wimax_osal_packet_put(newmsg, len),
+                           wimax_osal_packet_ptr(msg),
+                           len);
+
+        /* trace now to make the "len" available for other use ;) */
+        wimax_osal_trace_u32(PC2400M_GROUP_EAP_DEBUG,
+                             PC2400M_TRACE_EAP_RESP,
+                             WIMAX_OSAL_TRACE_PRIORITY_DEBUG, len);
+
+        /* set the padding bytes to 0xff */
+        len = WIMAX_OSAL_PAD4(L3L4_TLV_SIZE_REPORT_EAP_RESPONSE + len) -
+                (len + L3L4_TLV_SIZE_REPORT_EAP_RESPONSE);
+        wimax_osal_mem_set(wimax_osal_packet_put(newmsg, len), 0xff, len);
+
+        /* remove the original payload */
+        wimax_osal_packet_free(&msg);
+
+        priv->dm->cd->msg_enqueue(priv->dm->cd, newmsg, NULL, NULL,
+                                  PC2400M_CD_FLAG_NONE);
+
+}
+
+/** Indicate EAP failure to the chipset. Send message to the chipset indicating
+ *  EAP failure.
+ *
+ *  @param priv handle identifying the driver instance
+ *  @return none
+ */
+static void pc2400m_drv_eap_set_failure(struct pc2400m_private *priv)
+{
+
+        wimax_osal_packet *msg;
+
+        /* send EAP failure message directly to chipset */
+        msg = wimax_osal_packet_alloc(PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+        priv->dm->setup_header(
+                priv->dm,
+                wimax_osal_packet_put(
+                        msg, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN),
+                L4_L3_OPCODE_SET_EAP_FAIL,
+                0);
+
+        priv->dm->cd->msg_enqueue(priv->dm->cd, msg, NULL, NULL,
+                                  PC2400M_CD_FLAG_NONE);
+
+}
+
+/** Send key response message to chipset. Copy the EAP payload into a message
+ *  and send it to the client.
+ *
+ *  @param priv pointer to the driver instance
+ *  @return ESUCCESS upon success, -EGENERAL if no key is set
+ */
+static s32 pc2400m_drv_eap_send_key_resp(struct pc2400m_private *priv)
+{
+
+        struct L3L4_TLV_STR_SET_EAP_KEY_VALID *valid;
+        struct L3L4_TLV_STR_SET_EAP_KEY_MSK *msk;
+        wimax_osal_packet *msg;
+        s32 ret = ESUCCESS;
+
+        /* if there is a valid key, set it to the device */
+        if (priv->msk_flags & PC2400M_DRV_MSK_FLAG_VALID) {
+                msg = wimax_osal_packet_alloc(PC2400M_DRV_CHIPIF_CTRL_MSG_LEN +
+                                              L3L4_TLV_SIZE_SET_EAP_KEY_VALID +
+                                              L3L4_TLV_SIZE_SET_EAP_KEY_MSK);
+                priv->dm->setup_header(
+                        priv->dm,
+                        wimax_osal_packet_put(
+                                msg, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN),
+                        L4_L3_OPCODE_SET_EAP_KEY,
+                        L3L4_TLV_SIZE_SET_EAP_KEY_VALID +
+                        L3L4_TLV_SIZE_SET_EAP_KEY_MSK);
+
+                /* the key is valid ... */
+                valid = (struct L3L4_TLV_STR_SET_EAP_KEY_VALID*)
+                        wimax_osal_packet_put(
+                                msg, L3L4_TLV_SIZE_SET_EAP_KEY_VALID);
+                valid->tlv.type =
+                        WIMAX_OSAL_U16_TO_LE(L3L4_TLV_TYPE_SET_EAP_KEY_VALID);
+                valid->tlv.length =
+                        WIMAX_OSAL_U16_TO_LE(L3L4_TLV_SIZE_SET_EAP_KEY_VALID -
+                                             L3L4_TLV_HDR_LEN);
+                valid->key_valid =
+                        WIMAX_OSAL_U32_TO_LE(L3L4_EAP_KEY_VALID_VALID);
+
+                /* ... and follows in the next tlv */
+                msk = (struct L3L4_TLV_STR_SET_EAP_KEY_MSK*)
+                        wimax_osal_packet_put(
+                                msg, L3L4_TLV_SIZE_SET_EAP_KEY_MSK);
+                msk->tlv.type =
+                        WIMAX_OSAL_U16_TO_LE(L3L4_TLV_TYPE_SET_EAP_KEY_MSK);
+                msk->tlv.length =
+                        WIMAX_OSAL_U16_TO_LE(L3L4_TLV_SIZE_SET_EAP_KEY_MSK -
+                                             L3L4_TLV_HDR_LEN);
+
+                wimax_osal_mem_cpy(msk->msk, priv->msk, L3L4_MSK_LENGTH);
+
+                priv->dm->cd->msg_enqueue(priv->dm->cd, msg, NULL, NULL,
+                                          PC2400M_CD_FLAG_NONE);
+
+                wimax_osal_mem_set(priv->msk, 0x00, L3L4_MSK_LENGTH);
+                priv->msk_flags &= (~PC2400M_DRV_MSK_FLAG_VALID);
+                priv->msk_flags &= (~PC2400M_DRV_MSK_FLAG_REQD);
+
+                wimax_osal_trace(PC2400M_GROUP_EAP_INFO,
+                                 PC2400M_TRACE_MSK_SET,
+                                 WIMAX_OSAL_TRACE_PRIORITY_INFO);
+
+        } else {
+                ret = -EGENERAL;
+        }
+
+        return ret;
+
+}
+
+
+/** Set the MSK into the driver buffer. Set the MSK into the driver buffer,
+ *  forwarding it to the chipset immediately if the chipset has an open request
+ *  for the key.
+ *
+ *  @param priv handle identifying the driver instance
+ *  @param msk the key to set to the chipset
+ *  @return none
+ */
+static void pc2400m_drv_eap_set_key(struct pc2400m_private *priv, u8 *msk)
+{
+
+        /* copy the key into our own buffer */
+        wimax_osal_mem_cpy(priv->msk, msk, L3L4_MSK_LENGTH);
+        priv->msk_flags |= PC2400M_DRV_MSK_FLAG_VALID;
+
+        wimax_osal_trace(PC2400M_GROUP_EAP_DEBUG,
+                         PC2400M_TRACE_MSK_RECVD,
+                         WIMAX_OSAL_TRACE_PRIORITY_DEBUG);
+
+        /* if a request is pending for the key from the device, dispatch
+           immediately */
+        if (priv->msk_flags & PC2400M_DRV_MSK_FLAG_REQD) {
+                wimax_osal_timer_cancel(priv->msk_req_timer);
+                priv->msk_req_timer = 0;
+
+                /* return value not checked, because this will certainly
+                   succeed */
+                pc2400m_drv_eap_send_key_resp(priv);
+        }
+
+}
+
+/** Forward EAP request from chipset to the client. Copy the EAP payload into
+ *  a message and send it to the client.
+ *
+ *  @param cdhnd handle to the control dispatcher instance
+ *  @param indid identifier of the processed report
+ *  @param msg message payload of the processed report
+ *  @param data client data used to carry the priv pointer
+ *  @return none
+ */
+static void pc2400m_drv_eap_request(
+        struct pc2400m_drv_cd_if *cdhnd,
+        u32 indid,
+        wimax_osal_packet *msg,
+        void *data)
+{
+
+        struct pc2400m_private *priv = (struct pc2400m_private*)data;
+        struct t_wihal_ind ind;
+        struct L3L4_TLV_STR_REPORT_EAP_REQUEST *tlv;
+        u16 len;
+
+        PC2400M_DRV_UNWARN(cdhnd);
+        PC2400M_DRV_UNWARN(indid);
+
+        /* extract the payload */
+        tlv = (struct L3L4_TLV_STR_REPORT_EAP_REQUEST*)
+                priv->dm->get_tlv(priv->dm, wimax_osal_packet_ptr(msg),
+                                  L3L4_TLV_TYPE_REPORT_EAP_REQUEST, NULL);
+
+        wimax_osal_assert(tlv);
+
+        /* get the actual payload length */
+        len = WIMAX_OSAL_LE_TO_U16(tlv->length);
+
+        /* forward the EAP payload as-is to the client, remove the message
+           headers in front */
+        wimax_osal_packet_head_cut(msg, L3L4_TLV_SIZE_REPORT_EAP_REQUEST +
+                                   PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+
+        /* remove excess padding and the end of the payload */
+        wimax_osal_packet_trim(msg, len);
+
+        ind.ind_id = E_WIHAL_EAP_DATA_IND;
+        ind.ind.eap_data.p_payload = msg;
+
+        wimax_osal_trace_u32(PC2400M_GROUP_EAP_DEBUG,
+                             PC2400M_TRACE_EAP_REQ,
+                             WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                             WIMAX_OSAL_LE_TO_U16(tlv->tlv.length));
+
+        priv->eif->ind(priv->ctx, &ind);
+
+}
+
+/** Handle key request timeout. Handle the chipset key request timeout. If
+ *  the key is not provided by the client within the timeout period, an error
+ *  will be returned to the chipset indicating key is not available.
+ *
+ *  @param id identifier of the expired timer
+ *  @param data pointer used to carry the priv pointer
+ *  @return none
+ */
+static void pc2400m_drv_eap_key_request_timeout(
+        wimax_osal_timer_handle id,
+        void* data)
+{
+
+        struct pc2400m_private *priv = (struct pc2400m_private*)data;
+        struct L3L4_TLV_STR_SET_EAP_KEY_VALID *valid;
+        wimax_osal_packet *msg;
+
+        PC2400M_DRV_UNWARN(id);
+
+        /* trace */
+        wimax_osal_trace(PC2400M_GROUP_EAP_ERROR,
+                         PC2400M_TRACE_MSK_NOT_RECVD,
+                         WIMAX_OSAL_TRACE_PRIORITY_ERROR);
+
+        /* no eap key received, respond with no valid key */
+        msg = wimax_osal_packet_alloc(PC2400M_DRV_CHIPIF_CTRL_MSG_LEN +
+                                      L3L4_TLV_SIZE_SET_EAP_KEY_VALID);
+        priv->dm->setup_header(
+                priv->dm,
+                wimax_osal_packet_put(msg, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN),
+                L4_L3_OPCODE_SET_EAP_KEY,
+                L3L4_TLV_SIZE_SET_EAP_KEY_VALID);
+
+        valid = (struct L3L4_TLV_STR_SET_EAP_KEY_VALID*)
+                wimax_osal_packet_put(msg, L3L4_TLV_SIZE_SET_EAP_KEY_VALID);
+        valid->tlv.type =
+                WIMAX_OSAL_U16_TO_LE(L3L4_TLV_TYPE_SET_EAP_KEY_VALID);
+        valid->tlv.length =
+                WIMAX_OSAL_U16_TO_LE(L3L4_TLV_SIZE_SET_EAP_KEY_VALID -
+                                     L3L4_TLV_HDR_LEN);
+        valid->key_valid =
+                WIMAX_OSAL_U32_TO_LE(L3L4_EAP_KEY_VALID_INVALID);
+
+        priv->dm->cd->msg_enqueue(priv->dm->cd, msg, NULL, NULL,
+                                  PC2400M_CD_FLAG_NONE);
+
+        priv->msk_flags &= (~PC2400M_DRV_MSK_FLAG_REQD);
+
+}
+
+
+/** Process key request from chipset. Handle the EAP key request from the
+ *  chipset by immediately returning the MSK if it has been provided by the
+ *  client already, otherwise start a timer to wait for the client to provide
+ *  the key.
+ *
+ *  @param cdhnd handle to the control dispatcher instance
+ *  @param indid identifier of the report being processed
+ *  @param msg payload of the report being processed
+ *  @param data pointer used to carry the priv pointer
+ *  @return none
+ */
+static void pc2400m_drv_eap_key_request(
+        struct pc2400m_drv_cd_if *cdhnd,
+        u32 indid,
+        wimax_osal_packet *msg,
+        void *data)
+{
+
+        struct pc2400m_private *priv = (struct pc2400m_private*)data;
+
+        PC2400M_DRV_UNWARN(cdhnd);
+        PC2400M_DRV_UNWARN(indid);
+
+        /* respond with the key if valid, otherwise wait for
+           it to become valid */
+        if (pc2400m_drv_eap_send_key_resp(priv) != ESUCCESS) {
+                priv->msk_req_timer =
+                        wimax_osal_timer_create(
+                                PC2400M_DRV_MSK_REQ_TIMEOUT,
+                                WIMAX_OSAL_TR_10MS,
+                                0,
+                                (void*)priv,
+                                pc2400m_drv_eap_key_request_timeout);
+
+                priv->msk_flags |= PC2400M_DRV_MSK_FLAG_REQD;
+
+        }
+
+        wimax_osal_packet_free(&msg);
+}
+
+/** Process alternate accept from chipset. Handle the EAP alternate accept
+ *  report from the chipset by blatantly ignoring the message. Emit a trace
+ *  anyway.
+ *
+ *  @param cdhnd handle to the control dispatcher instance
+ *  @param indid identifier of the report being processed
+ *  @param msg payload of the report being processed
+ *  @param data pointer used to carry the priv pointer
+ *  @return none
+ */
+static void pc2400m_drv_eap_alt_accept(
+        struct pc2400m_drv_cd_if *cdhnd,
+        u32 indid,
+        wimax_osal_packet *msg,
+        void *data)
+{
+
+        PC2400M_DRV_UNWARN(cdhnd);
+        PC2400M_DRV_UNWARN(indid);
+        PC2400M_DRV_UNWARN(data);
+
+        wimax_osal_trace(PC2400M_GROUP_EAP_ERROR,
+                         PC2400M_TRACE_ALT_ACCEPT_IGN,
+                         WIMAX_OSAL_TRACE_PRIORITY_ERROR);
+
+        wimax_osal_packet_free(&msg);
+
+}
+
+
+
+/** Increment reference counter of this driver instance.
+ *
+ *  @param priv pointer to the driver instance
+ *  @return none
+ */
+static void pc2400m_drv_ref(struct pc2400m_private *priv)
+{
+
+        priv->ref_cnt++;
+
+}
+
+/** Decrement reference counter of this driver instance. Decrement the
+ *  reference counter of this driver instance, and associate a callback with
+ *  the deletion event. This callback will be called when the last reference to
+ *  the instance is removed, and the instance is physically removed.
+ *
+ *  @param priv pointer to the driver instance
+ *  @param cb callback to call when instance is deleted
+ *  @param data pointer to pass to the callback
+ *  @return none
+ */
+static void pc2400m_drv_unref_data(
+        struct pc2400m_private *priv,
+        drv_unref_cb cb,
+        void *data)
+{
+
+        wimax_osal_assert(cb);
+
+        priv->unref_cb = cb;
+        priv->unref_cb_data = data;
+
+        priv->unref(priv);
+
+        return;
+
+}
+
+/** Decrement reference counter of this driver instance. Decrement the
+ *  reference counter of this driver instance, freeing the instance memory when
+ *  the last reference is removed.
+ *
+ *  @param priv pointer to the driver instance
+ *  @param cb callback to call when instance is deleted
+ *  @param data pointer to pass to the callback
+ *  @return none
+ */
+static void pc2400m_drv_unref(struct pc2400m_private *priv)
+{
+
+        priv->ref_cnt--;
+
+        if (!priv->ref_cnt) {
+                /* local copy of the unref cb pointers */
+                drv_unref_cb cb = priv->unref_cb;
+                void *data = priv->unref_cb_data;
+                wimax_osal_context *ctx = priv->ctx;
+
+                /* unregister EAP indications */
+                priv->dm->cd->register_indication(
+                        priv->dm->cd, L3_L4_OPCODE_REPORT_ALT_ACCEPT,
+                        NULL, NULL);
+
+                priv->dm->cd->register_indication(
+                        priv->dm->cd, L3_L4_OPCODE_REPORT_KEY_REQUEST,
+                        NULL, NULL);
+
+                priv->dm->cd->register_indication(
+                        priv->dm->cd, L3_L4_OPCODE_REPORT_EAP_REQUEST,
+                        NULL, NULL);
+
+                /* free the subsystem instances */
+                priv->dm->cleanup(priv->dm);
+
+                /* free the packet buffer */
+                wimax_osal_packet_list_release(&(priv->pkt_list), TRUE);
+                priv->mode_flags &= (~PC2400M_DRV_COM_DATA_HOLD_MODE);
+
+                /* indicate success */
+                wimax_osal_trace_u32(PC2400M_GROUP_WIHAL_DEBUG,
+                                     PC2400M_TRACE_DRIVER_UNLOADED,
+                                     WIMAX_OSAL_TRACE_PRIORITY_DIAGNOSTIC,
+                                     (u32)priv->ctx);
+
+                /* free the instance itself */
+                wimax_osal_ctx_priv_set(priv->ctx, NULL);
+                wimax_osal_mem_free((void**)&priv);
+
+                /* call the unref cb to indicate that we're gone */
+                wimax_osal_assert(cb);
+                cb(ctx, data);
+
+        }
+        return;
+
+}
+
+/** WiHAL command handler for lifecycle messages.
+ *
+ *  @param ctx handle identifying the driver instance
+ *  @param cmd structure containing command parameters
+ *  @param data client data to be passed to the response
+ *  @return none
+ */
+static void pc2400m_drv_wihal_command_lifecycle(
+        wimax_osal_context *ctx,
+        struct t_wihal_cmd *cmd,
+        void *data)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+        struct pc2400m_drv_dm_configure_params *config_params;
+
+        switch (cmd->cmd_id) {
+        case E_WIHAL_INITIALIZE:
+
+                /* Currently, only single block firmwares supported */
+                if (cmd->cmd.initialize.block_count != 1) {
+                        pc2400m_drv_initialize_resp(
+                                priv->dm, -EGENERAL, (void*)data);
+                }
+
+                /* NOTE: power will go on during firmware download */
+
+                /* the device manager will initialize the rest of the
+                   system */
+                priv->dm->initialize(
+                        priv->dm, cmd->cmd.initialize.p_blocks[0].ptr,
+                        cmd->cmd.initialize.p_blocks[0].length,
+                        pc2400m_drv_initialize_resp, (void*)data);
+                break;
+
+        case E_WIHAL_CONFIGURE:
+
+                config_params = (struct pc2400m_drv_dm_configure_params*)
+                        wimax_osal_mem_alloc(
+                                sizeof
+                                (struct pc2400m_drv_dm_configure_params));
+                wimax_osal_mem_set(config_params, 0x00,
+                        sizeof(struct pc2400m_drv_dm_configure_params));
+
+                wimax_osal_mem_cpy(
+                        &(config_params->req),
+                        &(cmd->cmd.configure),
+                        sizeof(struct t_wihal_cmd_configure));
+
+                /* configure the chipset */
+                priv->dm->transition(
+                        priv->dm,
+                        PC2400M_DRV_DM_CONFIGURE,
+                        config_params,
+                        pc2400m_drv_configure_resp,
+                        (void*)ctx,
+                        data);
+                break;
+
+        case E_WIHAL_CLOSE:
+
+                /* Enforce, that EClose is called only once - as
+                   deinstantiator, nothing more can be reliably done to
+                   protect the integrity of the driver */
+                wimax_osal_assert(
+                        !(priv->mode_flags & PC2400M_DRV_COM_CLOSE_MODE));
+                priv->mode_flags |= PC2400M_DRV_COM_CLOSE_MODE;
+
+                /* perform a soft reset on the chip before powering down
+                   unless the driver is in unitialized state, in which case
+                   simply send the response and clean up */
+                priv->dm->transition(
+                        priv->dm,
+                        PC2400M_DRV_DM_TERMINATE,
+                        NULL,
+                        pc2400m_drv_close_resp,
+                        (void*)ctx,
+                        data);
+                break;
+
+        case E_WIHAL_SUSPEND:
+                /* suspend device manager */
+                priv->dm->transition(
+                        priv->dm,
+                        PC2400M_DRV_DM_SUSPEND,
+                        NULL,
+                        pc2400m_drv_suspend_resp,
+                        (void*)ctx,
+                        data);
+                break;
+
+        default:
+
+                wimax_osal_assert(cmd->cmd_id == E_WIHAL_RESUME);
+
+                /* resume the device manager */
+                priv->dm->transition(
+                        priv->dm,
+                        PC2400M_DRV_DM_RESUME,
+                        NULL,
+                        pc2400m_drv_resume_resp,
+                        (void*)ctx,
+                        data);
+                break;
+
+        }
+
+        return;
+}
+
+/** WiHAL command handler for data path messages.
+ *
+ *  @param ctx handle identifying the driver instance
+ *  @param cmd structure containing command parameters
+ *  @param data client data to be passed to the response
+ *  @return TRUE if the message was parsed, FALSE if it was not
+ */
+static boolean pc2400m_drv_wihal_command_data_path(
+        wimax_osal_context *ctx,
+        struct t_wihal_cmd *cmd,
+        void *data)
+{
+
+        boolean ret = TRUE;
+
+        switch (cmd->cmd_id) {
+        case E_WIHAL_DATA_RECEIVE:
+
+                /* forward the queued packets to the client */
+                pc2400m_drv_receive_packets(
+                        ctx,
+                        cmd->cmd.data_receive.data_count,
+                        data);
+                break;
+
+        case E_WIHAL_DATA_SEND:
+
+                /* forward the packets to the chipset */
+                wimax_osal_assert(data == NULL);
+                pc2400m_drv_send_packets(ctx, cmd);
+                break;
+
+        default:
+                ret = FALSE;
+                break;
+        }
+
+        return ret;
+}
+
+/** WiHAL command handler for network discovery and selection messages.
+ *
+ *  @param ctx handle identifying the driver instance
+ *  @param cmd structure containing command parameters
+ *  @param data client data to be passed to the response
+ *  @return TRUE if the message was parsed, FALSE if it was not
+ */
+static boolean pc2400m_drv_wihal_command_nds(
+        wimax_osal_context *ctx,
+        struct t_wihal_cmd *cmd,
+        void *data)
+{
+
+        struct pc2400m_drv_dm_bg_connect_params *connect_params;
+        struct pc2400m_drv_dm_bg_scan_nap_params *start_scan_params;
+        struct pc2400m_drv_dm_bg_scan_nsp_params *start_nsp_discovery_params;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+        boolean ret = TRUE;
+
+        switch (cmd->cmd_id) {
+        case E_WIHAL_NETWORK_STATUS:
+
+                /* asynchrously request the network status from the
+                   driver */
+                priv->dm->get_network_status(priv->dm, data);
+                break;
+
+        case E_WIHAL_RADIO_STATE:
+
+                switch(cmd->cmd.radio_state.radio_state) {
+                case E_WIHAL_RADIO_STATE_ON:
+                        priv->dm->transition(
+                                priv->dm,
+                                PC2400M_DRV_DM_ENABLE_RADIO,
+                                NULL,
+                                pc2400m_drv_radio_state_resp,
+                                (void*)ctx,
+                                data);
+                        break;
+
+                case E_WIHAL_RADIO_STATE_OFF:
+                        priv->dm->transition(
+                                priv->dm,
+                                PC2400M_DRV_DM_DISABLE_RADIO,
+                                NULL,
+                                pc2400m_drv_radio_state_resp,
+                                (void*)ctx,
+                                data);
+                        break;
+                }
+                break;
+
+        case E_WIHAL_SEARCH_NAP:
+
+                /* copy the search command */
+                start_scan_params =
+                          (struct pc2400m_drv_dm_bg_scan_nap_params*)
+                          wimax_osal_mem_alloc
+                          (sizeof(struct pc2400m_drv_dm_bg_scan_nap_params));
+                wimax_osal_mem_cpy(&(start_scan_params->req),
+                                   &(cmd->cmd.search_nap),
+                                   sizeof(struct t_wihal_cmd_search_nap));
+
+                /* store the client data */
+                start_scan_params->client_data = data;
+
+                /* copy the search plan -> NOTE that the dm will take
+                   ownership of the search plan list */
+                start_scan_params->req.p_search_plan =
+                          (struct t_wihal_search_plan*)wimax_osal_mem_alloc
+                           (sizeof(struct t_wihal_search_plan) *
+                            cmd->cmd.search_nap.search_plan_count);
+                wimax_osal_mem_cpy(start_scan_params->req.p_search_plan,
+                                   cmd->cmd.search_nap.p_search_plan,
+                                   (sizeof(struct t_wihal_search_plan) *
+                                    cmd->cmd.search_nap.search_plan_count));
+
+                priv->dm->transition(
+                        priv->dm,
+                        PC2400M_DRV_DM_START_SCAN,
+                        (void*)start_scan_params,
+                        pc2400m_drv_search_nap_resp,
+                        (void*)ctx,
+                        data);
+                break;
+
+        case E_WIHAL_SEARCH_NAP_STOP:
+
+                priv->dm->transition(priv->dm,
+                                     PC2400M_DRV_DM_STOP_SCAN,
+                                     NULL,
+                                     pc2400m_drv_search_nap_stop_resp,
+                                     (void*)ctx,
+                                     data);
+                break;
+
+        case E_WIHAL_SEARCH_NSP:
+
+                start_nsp_discovery_params =
+                          (struct pc2400m_drv_dm_bg_scan_nsp_params*)
+                          wimax_osal_mem_alloc
+                          (sizeof(struct pc2400m_drv_dm_bg_scan_nsp_params));
+
+                /* store the client data */
+                start_nsp_discovery_params->client_data = data;
+
+                /* copy the search command */
+                wimax_osal_mem_cpy(&(start_nsp_discovery_params->req),
+                                   &(cmd->cmd.search_nsp),
+                                   sizeof(struct t_wihal_cmd_search_nsp));
+
+                priv->dm->transition(
+                        priv->dm,
+                        PC2400M_DRV_DM_START_SCAN_NSP,
+                        (void*)start_nsp_discovery_params,
+                        pc2400m_drv_search_nsp_resp,
+                        (void*)ctx,
+                        data);
+                break;
+
+        case E_WIHAL_SEARCH_NSP_STOP:
+
+                priv->dm->transition(
+                        priv->dm,
+                        PC2400M_DRV_DM_STOP_SCAN_NSP,
+                        NULL,
+                        pc2400m_drv_search_nsp_stop_resp,
+                        (void*)ctx,
+                        data);
+                break;
+
+        case E_WIHAL_ENTRY:
+
+                /* invalidate EAP MSK */
+                priv->msk_flags &= (~PC2400M_DRV_MSK_FLAG_VALID);
+
+                /* take hold of the entry paramters */
+                connect_params =
+                        (struct pc2400m_drv_dm_bg_connect_params*)
+                        wimax_osal_mem_alloc(
+                                sizeof(struct
+                                       pc2400m_drv_dm_bg_connect_params));
+
+                wimax_osal_mem_cpy(
+                        &(connect_params->req), &(cmd->cmd.entry),
+                        sizeof(struct pc2400m_drv_dm_bg_connect_params));
+
+                /* register EAP handlers to open EAP data path */
+                priv->dm->cd->register_indication(
+                        priv->dm->cd, L3_L4_OPCODE_REPORT_EAP_REQUEST,
+                        pc2400m_drv_eap_request, (void*)priv);
+
+                priv->dm->cd->register_indication(
+                        priv->dm->cd, L3_L4_OPCODE_REPORT_ALT_ACCEPT,
+                        pc2400m_drv_eap_alt_accept, (void*)priv);
+
+                priv->dm->cd->register_indication(
+                        priv->dm->cd, L3_L4_OPCODE_REPORT_KEY_REQUEST,
+                        pc2400m_drv_eap_key_request, (void*)priv);
+
+                /* start the entry procedure */
+                priv->dm->transition(
+                        priv->dm,
+                        PC2400M_DRV_DM_CONNECT,
+                        (void*)connect_params,
+                        pc2400m_drv_connect_resp,
+                        (void*)ctx,
+                        data);
+                break;
+
+        case E_WIHAL_EXIT:
+
+                priv->dm->transition(
+                        priv->dm,
+                        PC2400M_DRV_DM_DISCONNECT,
+                        NULL,
+                        pc2400m_drv_disconnect_resp,
+                        (void*)ctx,
+                        data);
+                break;
+
+        default:
+
+                ret = FALSE;
+                break;
+        }
+
+        return ret;
+
+}
+
+/** WiHAL command handler for raw data pipes.
+ *
+ *  @param ctx handle identifying the driver instance
+ *  @param cmd structure containing command parameters
+ *  @param data client data to be passed to the response
+ *  @return TRUE if the message was parsed, FALSE if it was not
+ */
+static boolean pc2400m_drv_wihal_command_pipes (
+        wimax_osal_context *ctx,
+        struct t_wihal_cmd *cmd,
+        void *data)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+        boolean ret = TRUE;
+
+        switch (cmd->cmd_id) {
+        case E_WIHAL_PROD_TEST:
+
+                if (!(priv->mode_flags & PC2400M_DRV_COM_PROD_TEST_MODE)) {
+
+                        /* upon the first production test message, change to
+                           the production testing mode */
+                        priv->dm->transition(
+                                priv->dm,
+                                PC2400M_DRV_DM_PRODUCTION,
+                                cmd->cmd.prod_test.p_data,
+                                pc2400m_drv_production_resp,
+                                (void*)ctx,
+                                data);
+
+                        /* register a handler for production testing
+                           reports */
+                        priv->dm->cd->register_prod_handler(
+                                priv->dm->cd, pc2400m_drv_prod_handler, ctx);
+
+                } else {
+
+                        /* on subsequent messages, simply forward the data
+                           to the control dispatcher */
+                        pc2400m_drv_production_resp(
+                                priv->dm, ESUCCESS, cmd->cmd.prod_test.p_data,
+                                ctx, data);
+                }
+                break;
+
+        case E_WIHAL_DIAGNOSTICS:
+
+                /* forward message directly to the control dispatcher */
+                wimax_osal_assert(!data);
+
+                priv->dm->cd->msg_enqueue(
+                        priv->dm->cd,
+                        cmd->cmd.diagnostics.p_data,
+                        pc2400m_drv_diagnostics_resp,
+                        (void*)ctx,
+                        PC2400M_CD_FLAG_NONE);
+                break;
+
+        default:
+
+                ret = FALSE;
+                break;
+        }
+
+        return ret;
+
+}
+
+/** WiHAL command handler for EAP messages.
+ *
+ *  @param ctx handle identifying the driver instance
+ *  @param cmd structure containing command parameters
+ *  @param data client data to be passed to the response
+ *  @return TRUE if the message was parsed, FALSE if it was not
+ */
+static boolean pc2400m_drv_wihal_command_eap (
+        wimax_osal_context *ctx,
+        struct t_wihal_cmd *cmd,
+        void *data)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+        struct t_wihal_resp resp;
+        boolean ret = TRUE;
+
+        switch (cmd->cmd_id) {
+        case E_WIHAL_EAP_DATA:
+
+                /* forward the data to the eap subsystem */
+                pc2400m_drv_eap_response(priv, cmd->cmd.eap_data.p_payload);
+
+                resp.cmd_resp_id = E_WIHAL_EAP_DATA_RESP;
+                resp.cmd_status = E_WIHAL_SUCCESS;
+                priv->eif->cmd_resp(ctx, &resp, data);
+                break;
+
+        case E_WIHAL_EAP_RESULT:
+
+                /* either indicate failure or forward the key to the
+                   eap subsystem */
+                if (cmd->cmd.eap_result.success) {
+                        pc2400m_drv_eap_set_key(priv, cmd->cmd.eap_result.msk);
+
+                        /* there is an L3L4 for eap success as well, but
+                           the spec specifies that it is optional, and can
+                           just as well be deduced by the chipset itself.
+
+                           we do not send it. */
+                } else {
+                        pc2400m_drv_eap_set_failure(priv);
+                }
+
+                resp.cmd_resp_id = E_WIHAL_EAP_RESULT_RESP;
+                resp.cmd_status = E_WIHAL_SUCCESS;
+                priv->eif->cmd_resp(ctx, &resp, data);
+                break;
+
+        default:
+                ret = FALSE;
+                break;
+
+        }
+
+        return ret;
+
+}
+
+/** WiHAL main command handler. This function parses the WiHAL command
+ *  structure an performs an action based on it.
+ *
+ *  @param ctx handle identifying the driver instance
+ *  @param cmd structure containing command parameters
+ *  @param data client data to be passed to the response
+ *  @return none
+ */
+static void pc2400m_drv_wihal_command(
+        wimax_osal_context *ctx,
+        struct t_wihal_cmd *cmd,
+        void *data)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(ctx);
+        boolean ret;
+
+        /* trace the message */
+        if (cmd->cmd_id != E_WIHAL_DATA_RECEIVE &&
+            cmd->cmd_id != E_WIHAL_DATA_SEND) {
+                wimax_osal_trace_u32(PC2400M_GROUP_WIHAL_DEBUG,
+                                     PC2400M_TRACE_WIHAL_CTRL,
+                                     WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                                     cmd->cmd_id);
+        }
+
+        /* accessing an uninstantiated instance of the driver? */
+        wimax_osal_assert(priv);
+
+        /* increment a temporary reference for the instance so that it won't
+           disappear while processing this function */
+        priv->ref(priv);
+
+        /* pick yer poison, choose the WiHAL command requested and process
+           it without delay! */
+        ret = pc2400m_drv_wihal_command_data_path(ctx, cmd, data);
+        if (!ret)
+                ret = pc2400m_drv_wihal_command_pipes(ctx, cmd, data);
+        if (!ret)
+                ret = pc2400m_drv_wihal_command_eap(ctx, cmd, data);
+        if (!ret)
+                ret = pc2400m_drv_wihal_command_nds(ctx, cmd, data);
+        if (!ret)
+                pc2400m_drv_wihal_command_lifecycle(ctx, cmd, data);
+
+        /* remove temporary reference to the instance */
+        priv->unref(priv);
+
+        return;
+
+}
+
+
+/*****************************************************************************
+ * Exported functions
+ */
+
+/** Open a new instance of the Pc2400m driver. Open a new instance of the
+ *  pc2400m driver for a physical device.
+ *
+ *  @param ctx handle to identify the physical device for the driver
+ *  @param eif event interface pointer for driver usage
+ *  @param aif adaptation interface pointer for driver usage
+ */
+struct t_wihal_driver_if *pc2400m_drv_wihal_open(
+        wimax_osal_context *ctx,
+        struct t_wihal_event_if *eif,
+        struct t_wihal_adaptation_if *aif)
+{
+
+        struct pc2400m_private *priv;
+        struct t_wihal_driver_if *iface = NULL;
+
+        /* create the private data */
+        priv = wimax_osal_mem_alloc(sizeof(struct pc2400m_private));
+        wimax_osal_mem_set(priv, 0x00, sizeof(struct pc2400m_private));
+        priv->ctx = ctx;
+
+        wimax_osal_packet_list_initialize(&(priv->pkt_list));
+
+        /* take hold of the client interface pointers */
+        priv->aif = aif;
+        priv->eif = eif;
+
+        /* WiHAL event message construction */
+        priv->send_network_status_ind = pc2400m_drv_send_network_status_ind;
+        priv->send_network_status_resp = pc2400m_drv_send_network_status_resp;
+        priv->send_system_state_ind = pc2400m_drv_send_system_state_ind;
+        priv->send_search_ind = pc2400m_drv_send_search_ind;
+        priv->send_search_nap_resp = pc2400m_drv_send_search_nap_resp;
+        priv->send_search_nsp_resp = pc2400m_drv_send_search_nsp_resp;
+
+        /* WiHAL interface data type handling */
+        priv->get_nap_id_mask = pc2400m_drv_get_nap_id_mask;
+        priv->get_nap_and_nsp_flag = pc2400m_drv_get_nap_and_nsp_flag;
+        priv->get_channel_plan = pc2400m_drv_get_channel_plan;
+
+        /* reference and life time management */
+        priv->ref = pc2400m_drv_ref;
+        priv->unref = pc2400m_drv_unref;
+        priv->unref_data = pc2400m_drv_unref_data;
+
+        /* start up with full data send quota */
+        priv->send_credit = WIHAL_DATA_SEND_CREDIT_LEN;
+
+        /* add the permanent reference to the instance */
+        priv->ref(priv);
+
+        /* instantiate subsystems */
+        priv->dm = pc2400m_drv_dm_if_new(ctx);
+
+        /* instance of the interface */
+        iface = &pc2400m_wihal_if;
+        wimax_osal_ctx_priv_set(ctx, priv);
+
+        /* NOTE: powering the chipset here causes problems as the
+           ctx variable is not fully initialized. */
+
+        return iface;
+
+}
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_cd.c maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_cd.c
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_cd.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_cd.c	2011-02-06 20:12:11.776666608 -0500
@@ -0,0 +1,1296 @@
+/*
+ * pc2400m_drv_cd.c
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         42      APPROVED 15-Sep-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_drv_cd.c
+ *
+ * This file implements the control dispatcher functionality of the driver.
+ * The control dispatcher handles logical message level transport to the
+ * chipset. The control dispatcher utilizes the SPI for physical transport.
+ *
+ */
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include "pc2400m_drv_com.h"
+#include "pc2400m_drv_chipif.h"
+#include "pc2400m_drv_hdi.h"
+#include "pc2400m_drv_dm.h"
+#include "pc2400m_drv_cd.h"
+
+/*****************************************************************************
+ * Global constants and macros
+ */
+
+/** Check whether the control and data queues are empty.
+ *
+ *  @param _hnd (struct pc2400m_drv_cd_if*) handle to the control dispatcher
+ *              instance
+ *  @return TRUE if the queues are empty, FALSE if they are not empty
+ */
+#define PC2400M_DRV_CD_QUEUES_EMPTY(_hnd) \
+            ((!wimax_osal_packet_list_len(&((_hnd)->pkt_list))) && \
+             (!wimax_osal_list_first(&((_hnd)->ctrl_list))))
+
+/*****************************************************************************
+ * Global data types
+ */
+
+/** this type abstracts a chipset control message either being processed
+    or stored in the message queue. */
+struct pc2400m_drv_cd_ctrl_msg_elem {
+        wimax_osal_packet *msg;
+        cd_msg_enqueue_cb cb;
+        /* data is a carried cookie value for the client, ownership
+           remains at the client side */
+        void *data;
+        u16 type;
+        wimax_osal_timer_handle timeout_handle;
+        boolean processing;
+        struct wimax_osal_list_elem_hdr list;
+};
+
+/** this type stores a registration to a indication type report from the
+    chipset */
+struct pc2400m_drv_cd_ind_elem {
+        cd_indication_cb cb;
+        u32 id;
+        void *data;
+        struct wimax_osal_list_elem_hdr list;
+};
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+static void pc2400m_drv_cd_power_save_exit(struct pc2400m_drv_cd_if*);
+static void pc2400m_drv_cd_send(struct pc2400m_drv_cd_if *hnd);
+
+/*****************************************************************************
+ * Local functions
+ */
+
+/** Free messsage element structure. This function frees the memory taken
+ *  by the provided message element structure.
+ *
+ *  @param elem pointer to the structure (may not be NULL)
+ *  @return none
+ */
+static void pc2400m_drv_cd_free_msg_elem(void **elem)
+{
+
+        wimax_osal_assert(*elem);
+
+        wimax_osal_packet_free(
+                &(((struct pc2400m_drv_cd_ctrl_msg_elem*)*elem)->msg));
+        wimax_osal_mem_free(elem);
+
+}
+
+
+/** Handler for transaction timeout. This function is called if a
+ *  transaction with the chipset times out (the response for a request
+ *  never arrives.) This function frees the memory associated to the
+ *  transaction and the transaction queue, and then indicates irrecoverable
+ *  failure to the device manager.
+ *
+ *  @param handle handle to the expired timer
+ *  @param hnddata client data carrying the control dispatcher handle
+ *  @return none
+ *
+ */
+static void pc2400m_drv_cd_send_timeout(
+        wimax_osal_timer_handle handle,
+        void* hnddata)
+{
+
+        struct pc2400m_drv_cd_if *hnd = (struct pc2400m_drv_cd_if*)hnddata;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->ctx);
+
+        /* add reference to the main instance */
+        priv->ref(priv);
+
+        /* check that there is an event being processed */
+        wimax_osal_assert(hnd->ctrl_processed);
+        wimax_osal_assert(hnd->ctrl_processed->timeout_handle == handle);
+
+        /* the event of this timer was already processed */
+        wimax_osal_trace_u16(PC2400M_GROUP_CD_ERROR,
+                             PC2400M_TRACE_MSG_TIMEOUT,
+                             WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                             hnd->ctrl_processed->type);
+        pc2400m_drv_cd_free_msg_elem((void**)&(hnd->ctrl_processed));
+
+        /* stop everyting! */
+        priv->dm->abort_mission(priv->dm);
+
+        /* if the system was deleted during the handling of this,
+           handle it now */
+        priv->unref(priv);
+
+}
+
+/** Main message procesing loop. This function is respobsible for sending
+ *  command and data messages to the chipset from the control dispatcher
+ *  queues. This function is invoked whenever new data is queued into the
+ *  control message dispatcher or a transaction has completed.
+ *
+ *  @param hnd handle to the control dispatcher instance
+ *  @return none
+ */
+static void pc2400m_drv_cd_send(struct pc2400m_drv_cd_if *hnd)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->ctx);
+        wimax_osal_packet *pkt;
+        s32 send = FALSE;
+        static boolean running = FALSE;
+
+
+        /* do not execute further if suspended or if recursive access to
+           this function */
+        if (running || (hnd->flags & PC2400M_DRV_CD_FLAGS_SUSPENDED))
+                goto out;
+
+        running = TRUE;
+
+        /* if in power save, and there is something to send, exit power save
+           first */
+        if ((hnd->flags & PC2400M_DRV_CD_FLAGS_POWER_SAVE) &&
+            (!PC2400M_DRV_CD_QUEUES_EMPTY(hnd)))
+                pc2400m_drv_cd_power_save_exit(hnd);
+
+        do {
+
+                /* check whether there are messages to process,
+                   and process them */
+                if (!hnd->ctrl_processed)
+                        hnd->ctrl_processed =
+                                wimax_osal_list_pop(&(hnd->ctrl_list));
+
+                if (hnd->ctrl_processed &&
+                    (!hnd->ctrl_processed->processing)) {
+
+                        /* trace the control message contents */
+                        wimax_osal_trace_data(
+                                PC2400M_GROUP_CD_DEBUG,
+                                PC2400M_TRACE_H2D,
+                                WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                                wimax_osal_packet_ptr(
+                                        hnd->ctrl_processed->msg),
+                                wimax_osal_packet_size(
+                                        hnd->ctrl_processed->msg));
+
+                        /* the control message will always be sent
+                           first, and shall therefore never fail */
+                        wimax_osal_assert(
+                                !hnd->hdi->put(
+                                        hnd->hdi,
+                                        hnd->ctrl_processed->msg,
+                                        PC2400M_DRV_SPI_FRAME_TYPE_CONTROL));
+                        hnd->ctrl_processed->processing = TRUE;
+                        send = TRUE;
+
+                        hnd->ctrl_processed->msg = NULL;
+                        hnd->ctrl_processed->timeout_handle =
+                                wimax_osal_timer_create(
+                                        PC2400M_DRV_CD_RESPONSE_TIMEOUT,
+                                        WIMAX_OSAL_TR_10MS,
+                                        FALSE,
+                                        (void*)hnd,
+                                        pc2400m_drv_cd_send_timeout);
+                }
+
+                /* pack as many packets into the transaction as will fit */
+                while ((!(hnd->flags & PC2400M_DRV_CD_FLAGS_HOLD_DATA)) &&
+                       wimax_osal_packet_list_len(&(hnd->pkt_list))) {
+
+                        pkt = wimax_osal_packet_list_pop(&(hnd->pkt_list));
+                        if (hnd->hdi->put(
+                                    hnd->hdi,
+                                    pkt,
+                                    PC2400M_DRV_SPI_FRAME_TYPE_DATA)) {
+                                /* put back to the front of the list, and stop
+                                   pushing more data */
+                                wimax_osal_packet_list_push(
+                                        &(hnd->pkt_list), pkt);
+                                break;
+                        } else {
+                                send = TRUE;
+                        }
+
+                }
+
+                /* if the queue is empty, inform the client of it */
+                if ((wimax_osal_packet_list_len(&(hnd->pkt_list)) <=
+                     PC2400M_DRV_CD_SEND_BUFFER_LOW_WATERMARK) &&
+                    hnd->pkt_queue_empty_cb) {
+                        cd_pkt_queue_empty_cb local_cb =
+                                hnd->pkt_queue_empty_cb;
+                        void *local_data = hnd->pkt_queue_empty_data;
+
+                        /* need to put the callback and data into stack as
+                           this call may again change the values here */
+                        hnd->pkt_queue_empty_cb = NULL;
+                        hnd->pkt_queue_empty_data = NULL;
+
+                        local_cb(hnd, local_data);
+                }
+
+                /* transmit the data to the chipset if any was queued */
+                if (send) {
+                        hnd->hdi->write(hnd->hdi);
+                }
+
+                /* if data remains in the packet list, send them too (unless
+                   the data path is on hold or an interrupt is pending) */
+
+        } while ((!(hnd->flags & PC2400M_DRV_CD_FLAGS_HOLD_DATA)) &&
+                 wimax_osal_packet_list_len(&(hnd->pkt_list)) &&
+                 !priv->aif->irq_pending(hnd->ctx));
+
+        /* allow access to the function */
+        running = FALSE;
+
+ out:
+        return;
+}
+
+/** Response to power save entry. This function changes control dispatcher
+ *  into power save mode (which implies putting control and data queues to
+ *  hold.)
+ *
+ *  @param hnd handle to the control dispatcher instance
+ *  @param msg response message content
+ *  @param data client data to the command
+ *  @return none
+ */
+static void pc2400m_drv_cd_power_save_entry_resp(
+        struct pc2400m_drv_cd_if *hnd,
+        wimax_osal_packet *msg,
+        void *data)
+{
+
+        struct pc2400m_drv_chipif_ctrl_msg *hdr =
+                (struct pc2400m_drv_chipif_ctrl_msg*)
+                wimax_osal_packet_ptr(msg);
+
+        PC2400M_DRV_UNWARN(data);
+
+
+
+        /* if the driver responds with success, the interface is
+           officially in power save */
+        if (L3L4_SUCCESS(WIMAX_OSAL_LE_TO_U16(hdr->status))) {
+                hnd->flags |= PC2400M_DRV_CD_FLAGS_POWER_SAVE;
+
+                /* the following flag is set here again because the interrupt
+                   handling routine will have cleared it as response to a
+                   data message arriving from the chipset. */
+                hnd->flags |= PC2400M_DRV_CD_FLAGS_POWER_SAVE_HOLD_DATA;
+
+                wimax_osal_trace(PC2400M_GROUP_CD_DEBUG,
+                                 PC2400M_TRACE_ENTERED_POWER_SAVE,
+                                 WIMAX_OSAL_TRACE_PRIORITY_DEBUG);
+        }
+
+        /* the interrupt service itself will have cleared the data hold
+           flag */
+
+        wimax_osal_packet_free(&msg);
+
+}
+
+/** Response to power save exit. This function handles the response to a
+ *  power save exit request by resetting the control dispatcher power save
+ *  mode status.
+ *
+ *  @param hnd handle to the control dispatcher instance
+ *  @param msg response message content
+ *  @param data client data to the command
+ *  @return none
+ */
+static void pc2400m_drv_cd_power_save_exit_resp(
+        struct pc2400m_drv_cd_if *hnd,
+        wimax_osal_packet *msg,
+        void *data)
+{
+
+        PC2400M_DRV_UNWARN(data);
+        PC2400M_DRV_UNWARN(hnd);
+
+        /* the response itself is enough to indicate exit from power
+           save - and the interrupt service routine will have cleared
+           the data hold */
+        wimax_osal_packet_free(&msg);
+
+}
+
+/** Send power save exit request. This function constructs a request message
+ *  to move the chipset out of power save mode. This message must be placed
+ *  first in the message queue in order to be processed before other requests.
+ *
+ *  @param hnd handle to the control dispatcher instance
+ *  @return none
+ */
+static void pc2400m_drv_cd_power_save_exit(struct pc2400m_drv_cd_if *hnd)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->ctx);
+        wimax_osal_packet *msg;
+
+        /* send a power save exit request */
+        msg = wimax_osal_packet_alloc(PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+
+        priv->dm->setup_header(
+                priv->dm,
+                wimax_osal_packet_put(
+                        msg, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN),
+                L4_L3_OPCODE_GET_STATE,
+                0);
+
+        /* clear the powersave before queueing the request (to avoid an
+           endless loop) */
+        hnd->flags &= (~PC2400M_DRV_CD_FLAGS_POWER_SAVE);
+
+        wimax_osal_trace(
+                PC2400M_GROUP_CD_DEBUG,
+                PC2400M_TRACE_POWER_SAVE_EXIT,
+                WIMAX_OSAL_TRACE_PRIORITY_DEBUG);
+
+        /* place this request in front in the processing queue, as this
+           needs to be done prior to any other possible traffic */
+        hnd->msg_enqueue(
+                hnd,
+                msg,
+                pc2400m_drv_cd_power_save_exit_resp,
+                NULL,
+                PC2400M_CD_FLAG_URGENT);
+
+        /* power save is cleared once the response for this message arrives */
+
+}
+
+/** Send power save entry request. This function constructs a request message
+ *  to move the chipset into power save mode. The message is only sent if both
+ *  the control and data queues are empty.
+ *
+ *  @param hnd handle to the control dispatcher instance
+ *  @return none
+ */
+static void pc2400m_drv_cd_power_save_entry(
+        struct pc2400m_drv_cd_if *hnd,
+        u32 ind_id,
+        wimax_osal_packet *msg,
+        void *data)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->ctx);
+        struct L3L4_TLV_STR_WAKEUP_MODE *wakeup;
+        wimax_osal_packet *req;
+
+
+        PC2400M_DRV_UNWARN(ind_id);
+        PC2400M_DRV_UNWARN(data);
+
+        /* if nothing is queued, request entry to power save */
+        if ((!hnd->ctrl_processed) &&
+            PC2400M_DRV_CD_QUEUES_EMPTY(hnd)) {
+
+                wimax_osal_trace(PC2400M_GROUP_CD_DEBUG,
+                                 PC2400M_TRACE_REQUEST_POWER_SAVE,
+                                 WIMAX_OSAL_TRACE_PRIORITY_DEBUG);
+
+                /* send a power save request */
+                req = wimax_osal_packet_alloc(
+                        PC2400M_DRV_CHIPIF_CTRL_MSG_LEN +
+                        L3L4_TLV_SIZE_WAKEUP_MODE);
+
+                priv->dm->setup_header(
+                        priv->dm,
+                        wimax_osal_packet_put(
+                                req, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN),
+                        L4_L3_OPCODE_CMD_ENTER_POWER_SAVE,
+                        L3L4_TLV_SIZE_WAKEUP_MODE);
+
+                /* request that the driver may wakeup the chipset at any
+                   time */
+                wakeup = priv->dm->insert_tlv(priv->dm, req,
+                                            L3L4_TLV_TYPE_WAKEUP_MODE,
+                                            L3L4_TLV_SIZE_WAKEUP_MODE);
+                wakeup->wake_up_mode =
+                        (u8)L3L4_WAKEUP_MODE_ENABLED;
+                wakeup->reserved1 = 0;
+                wakeup->reserved2 = 0;
+                wakeup->reserved3 = 0;
+
+                hnd->flags |= PC2400M_DRV_CD_FLAGS_POWER_SAVE_HOLD_DATA;
+
+                /* put the data path on hold now to avoid race conditions */
+                hnd->msg_enqueue(
+                        hnd,
+                        req,
+                        pc2400m_drv_cd_power_save_entry_resp,
+                        NULL,
+                        PC2400M_CD_FLAG_URGENT);
+
+                /* then wait for the verdict */
+
+        }
+
+        /* otherwise the request ignored, the powersave is not entered in
+           anticipation of more traffic. the chipset will request powersave
+           again once there is a new silent period */
+
+        wimax_osal_packet_free(&msg);
+
+}
+
+
+/** Response to idle exit. This function handles the exit idle response
+ *  message by emitting a trace if failure occurred. The actual exit from
+ *  idle will have been completed and will be processed one the device
+ *  manager indicates exit from idle.
+ *
+ *  @param hnd handle to the control dispatcher instance
+ *  @param msg response message content
+ *  @param data client data to the command
+ *  @return none
+ */
+static void pc2400m_drv_cd_exit_idle_resp(
+        struct pc2400m_drv_cd_if *hnd,
+        wimax_osal_packet *msg,
+        void *data)
+{
+
+        struct pc2400m_drv_chipif_ctrl_msg *hdr =
+                (struct pc2400m_drv_chipif_ctrl_msg*)
+                wimax_osal_packet_ptr(msg);
+
+        PC2400M_DRV_UNWARN(data);
+
+        /* emit a trace, if exit from idle failed */
+        if (!L3L4_SUCCESS(WIMAX_OSAL_LE_TO_U16(hdr->status))) {
+                wimax_osal_trace_u16(
+                        PC2400M_GROUP_CD_ERROR,
+                        PC2400M_TRACE_EXIT_IDLE_FAILED,
+                        WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                        WIMAX_OSAL_LE_TO_U16(hdr->status));
+
+                /* do not expect the idle to be exited soon, as an error
+                   occurred in the exit idle mechanism. */
+                hnd->flags &= (~PC2400M_DRV_CD_FLAGS_IDLE_EXITING);
+
+        }
+
+        wimax_osal_packet_free(&msg);
+
+}
+
+
+/** Send request to exit idle. This function constructs and send a message
+ *  to request exiting IDLE mode.
+ *
+ *  @param hnd handle to the control dispatcher instance
+ *  @return none
+ */
+static void pc2400m_drv_cd_exit_idle(struct pc2400m_drv_cd_if *hnd)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->ctx);
+        wimax_osal_packet *msg;
+
+        /* don't do multiple exits */
+        if (hnd->flags & PC2400M_DRV_CD_FLAGS_IDLE_EXITING)
+                goto out;
+
+        /* send a power save exit request */
+        msg = wimax_osal_packet_alloc(PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+
+        priv->dm->setup_header(
+                priv->dm,
+                wimax_osal_packet_put(msg, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN),
+                L4_L3_OPCODE_CMD_EXIT_IDLE,
+                0);
+
+        wimax_osal_trace(
+                PC2400M_GROUP_CD_DEBUG,
+                PC2400M_TRACE_IDLE_MODE_EXIT,
+                WIMAX_OSAL_TRACE_PRIORITY_DEBUG);
+
+        /* place this request in front in the processing queue, as this
+           needs to be done prior to any other possible traffic */
+        hnd->msg_enqueue(
+                hnd,
+                msg,
+                pc2400m_drv_cd_exit_idle_resp,
+                NULL,
+                PC2400M_CD_FLAG_URGENT);
+
+        hnd->flags |= PC2400M_DRV_CD_FLAGS_IDLE_EXITING;
+
+ out:
+        return;
+
+}
+
+
+/** Bring cd to idle mode or out of idle mode. This function is called by the
+ *  device manager to indicate the chipset has entered or exited IDLE mode. For
+ *  control dispatcher, IDLE implies putting the data transfer queue to hold
+ *  until IDLE is exited.
+ *
+ *  @param hnd handle to the cd instance
+ *  @param enable TRUE to enable idle mode, FALSE to disable it
+ *  @return none.
+ */
+static void pc2400m_drv_cd_idle(
+        struct pc2400m_drv_cd_if *hnd,
+        boolean enable)
+{
+
+        if (enable) {
+                /* set the IDLE flag */
+                hnd->flags |= PC2400M_DRV_CD_FLAGS_IDLE_HOLD_DATA;
+
+                /* if there is data in the buffer, exit idle immediately */
+                if (wimax_osal_packet_list_len(&(hnd->pkt_list)))
+                        pc2400m_drv_cd_exit_idle(hnd);
+
+                wimax_osal_trace(PC2400M_GROUP_CD_DEBUG,
+                                 PC2400M_TRACE_ENTERED_IDLE,
+                                 WIMAX_OSAL_TRACE_PRIORITY_DEBUG);
+
+        } else {
+                /* clear the IDLE_EXITING flag which prevents multiple
+                   idle exit requests */
+                hnd->flags &= (~PC2400M_DRV_CD_FLAGS_IDLE_EXITING);
+
+                /* remove the IDLE flag and start processing data */
+                hnd->flags &= (~PC2400M_DRV_CD_FLAGS_IDLE_HOLD_DATA);
+                pc2400m_drv_cd_send(hnd);
+
+                wimax_osal_trace(PC2400M_GROUP_CD_DEBUG,
+                                 PC2400M_TRACE_EXITED_IDLE,
+                                 WIMAX_OSAL_TRACE_PRIORITY_DEBUG);
+        }
+
+}
+
+/** Inform link state up or down. This function is called by device manager
+ *  to indicate the current state of the link. By default, link state is down.
+ *  While the link state is down, the data queue is on hold.
+ *
+ *  @param hnd handle to the cd instance
+ *  @param enable TRUE for link state up, FALSE for link state down
+ *  @return none
+ */
+static void pc2400m_drv_cd_link_state(
+        struct pc2400m_drv_cd_if *hnd,
+        boolean enable)
+{
+
+        if (enable) {
+
+                /* clear the link state down flag */
+                hnd->flags &= (~PC2400M_DRV_CD_FLAGS_LINK_DOWN);
+
+                /* process the data queue */
+                pc2400m_drv_cd_send(hnd);
+
+        } else {
+
+                /* set the link state down flag */
+                hnd->flags |= PC2400M_DRV_CD_FLAGS_LINK_DOWN;
+
+                /* emit a trace */
+                if (wimax_osal_packet_list_len(&(hnd->pkt_list)))
+                        wimax_osal_trace_u32(
+                                PC2400M_GROUP_CD_ERROR,
+                                PC2400M_TRACE_LINK_DOWN,
+                                WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                                wimax_osal_packet_list_len(&(hnd->pkt_list)));
+
+                /* flush the current packet buffer */
+                wimax_osal_packet_list_release(&(hnd->pkt_list), TRUE);
+                wimax_osal_packet_list_initialize(&(hnd->pkt_list));
+
+                /* if waiting for credits, send them now */
+                if (hnd->pkt_queue_empty_cb) {
+                        cd_pkt_queue_empty_cb local_cb =
+                                hnd->pkt_queue_empty_cb;
+                        void *local_data = hnd->pkt_queue_empty_data;
+
+                        /* need to put the callback and data into stack as
+                           this call may again change the values here */
+                        hnd->pkt_queue_empty_cb = NULL;
+                        hnd->pkt_queue_empty_data = NULL;
+
+                        local_cb(hnd, local_data);
+                }
+
+        }
+
+}
+
+/** Request suspension of all queues. This function starts suspension of the
+ *  control dispatcher control and data queues. When complete, the cb will be
+ *  called. The suspension is complete immediately if no control message is
+ *  currently being processed, otherwise it is complete when the current
+ *  control message becomes ready.
+ *
+ *  @param hnd handle to the control dispatcher instance
+ *  @param cb call back to call when suspension is complete
+ *  @param data data to pass to the callback
+ *  @return none
+ */
+static void pc2400m_drv_cd_suspend(
+        struct pc2400m_drv_cd_if *hnd,
+        cd_suspend_cb cb,
+        void *data)
+{
+
+        wimax_osal_assert(cb);
+
+        /* stop the send queue */
+        hnd->flags |= PC2400M_DRV_CD_FLAGS_SUSPENDED;
+
+        /* wait for a currently possibly executing item to complete */
+        if (!hnd->ctrl_processed) {
+                cb(hnd, data);
+        } else {
+                /* have the suspend call back called when the current
+                   item is done */
+                hnd->suspend_cb = cb;
+                hnd->suspend_cb_data = data;
+        }
+
+        return;
+
+}
+
+/** Request resume of all queues. This function resumes all queues previously
+ *  suspended by the suspend function call. This function invokes the
+ *  processing of the queues.
+ *
+ *  @param hnd handle to the control dispatcher instance
+ *  @return none
+ */
+static void pc2400m_drv_cd_resume(struct pc2400m_drv_cd_if *hnd)
+{
+        /* go out of suspend state and restart the send queue */
+        hnd->flags &= (~PC2400M_DRV_CD_FLAGS_SUSPENDED);
+        pc2400m_drv_cd_send(hnd);
+
+        return;
+
+}
+
+
+/** Enqueue a control message for dispatch. Enqueue a control message for
+ *  sending to the chipset. If possible, the control message is immediately
+ *  transmitted.
+ *
+ *  @param hnd handle to the cd instance
+ *  @param msg packet containing the control message with all headers
+ *  @param cb call back to call with the response to the message
+ *  @param data data pointer to pass to the call back
+ *  @param flags flags to specify the handling of the message
+ *  @return none
+ */
+static void pc2400m_drv_cd_msg_enqueue(
+        struct pc2400m_drv_cd_if *hnd,
+        wimax_osal_packet *msg,
+        cd_msg_enqueue_cb cb,
+        void *data,
+        u32 flags)
+{
+
+        struct pc2400m_drv_cd_ctrl_msg_elem *elem;
+        struct pc2400m_drv_chipif_ctrl_msg *hdrptr;
+
+        hdrptr = (struct pc2400m_drv_chipif_ctrl_msg*)
+                wimax_osal_packet_ptr(msg);
+        elem = (struct pc2400m_drv_cd_ctrl_msg_elem*)
+                  wimax_osal_mem_alloc(
+                          sizeof(struct pc2400m_drv_cd_ctrl_msg_elem));
+
+        elem->msg = msg;
+        elem->cb = cb;
+        elem->data = data;
+        elem->type = WIMAX_OSAL_LE_TO_U16(hdrptr->type);
+        elem->processing = FALSE;
+        WIMAX_OSAL_LIST_ELEM_HDR_INIT(&(elem->list));
+
+        if (flags & PC2400M_CD_FLAG_URGENT) {
+                wimax_osal_list_push(&(hnd->ctrl_list), elem);
+        } else {
+                wimax_osal_list_append(&(hnd->ctrl_list), elem);
+        }
+
+        pc2400m_drv_cd_send(hnd);
+
+        return;
+
+}
+
+
+/** Register handler for an indication message. Associates a call back
+ *  function with a indication op-code (identifier.)
+ *
+ *  @param hnd handle to the cd instance
+ *  @param indid identifier of the indication type
+ *  @param cb the function to call when the indication is received
+ *  @return none
+ */
+static void pc2400m_drv_cd_register_indication(
+        struct pc2400m_drv_cd_if* hnd,
+        u32 indid,
+        cd_indication_cb cb,
+        void *data)
+{
+        struct pc2400m_drv_cd_ind_elem *pos;
+        boolean found = FALSE;
+
+        wimax_osal_assert(indid & L3L4_INDICATION_MASK);
+
+        wimax_osal_list_foreach(&(hnd->ind_list), pos) {
+                if (pos->id == indid) {
+                        if (cb) {
+                                pos->cb = cb;
+                                pos->data = data;
+                        } else {
+                                wimax_osal_list_remove(&(hnd->ind_list), pos);
+                                wimax_osal_mem_free((void**)&pos);
+                        }
+                        found = TRUE;
+                        break;
+
+                }
+        }
+
+        if ((!found) && cb) {
+                pos = (struct pc2400m_drv_cd_ind_elem*)
+                        wimax_osal_mem_alloc(
+                                sizeof(struct pc2400m_drv_cd_ind_elem));
+                pos->id = indid;
+                pos->cb = cb;
+                pos->data = data;
+                WIMAX_OSAL_LIST_ELEM_HDR_INIT(&(pos->list));
+                wimax_osal_list_append(&(hnd->ind_list), pos);
+        }
+
+        return;
+
+}
+
+/** Check if there is space in the queue. This function checks whether the
+ *  high watermark of the data queue has been exceeded. If it has not, it will
+ *  indicate that to the caller. If it has, will indicate that to the caller
+ *  and register a callback to indicate to the caller when the buffer is
+ *  empty again.
+ *
+ *  @param hnd handle to the cd instance
+ *  @param cb call back to call when data is available
+ *  @param data data to pass to the call back
+ *  @return TRUE if there is space in the buffer (the cb will be ignored) or
+ *          FALSE if the buffer is full.
+ */
+static boolean pc2400m_drv_cd_pkt_queue_has_space(
+        struct pc2400m_drv_cd_if *hnd,
+        cd_pkt_queue_empty_cb cb,
+        void *data)
+{
+
+        boolean ret = FALSE;
+
+        if (wimax_osal_packet_list_len(&(hnd->pkt_list)) <=
+            PC2400M_DRV_CD_SEND_BUFFER_HIGH_WATERMARK) {
+
+                /* there is space in the packet queue, so do not call the
+                   call back, instead return TRUE */
+                hnd->pkt_queue_empty_cb = NULL;
+                hnd->pkt_queue_empty_data = NULL;
+                ret = TRUE;
+
+        } else {
+
+                /* the queue is full, register the callback so it can be
+                   called when the queue becomes empty */
+                hnd->pkt_queue_empty_cb = cb;
+                hnd->pkt_queue_empty_data = data;
+
+        }
+
+        return ret;
+
+}
+
+
+/** Queue a data packet for transmission. This function queues a packet for
+ *  transmission to the chipset. If possible, the packet will be immediately
+ *  trasmitted.
+ *
+ *  @param hnd handle to the cd instance
+ *  @param list packet list with the user data and headers
+ *  @param flags flags affecting the processing of the message
+ *  @return none
+ */
+static void pc2400m_drv_cd_pkt_enqueue(
+        struct pc2400m_drv_cd_if *hnd,
+        wimax_osal_packet_list *list)
+{
+
+        wimax_osal_packet *pkt;
+
+        /* drop the packets, if the link is not up */
+        if (hnd->flags & PC2400M_DRV_CD_FLAGS_LINK_DOWN)
+                while ((pkt = wimax_osal_packet_list_pop(list)), pkt) {
+                        wimax_osal_packet_free(&pkt);
+                }
+
+        while ((pkt = wimax_osal_packet_list_pop(list)), pkt) {
+
+                /* enqueue packet, and add transport header */
+                wimax_osal_packet_list_append(&(hnd->pkt_list), pkt);
+
+#define PC2400M_DRV_H2D_PKT_HDR_SIZE  4
+                (void)wimax_osal_packet_head_put(
+                        pkt,
+                        PC2400M_DRV_H2D_PKT_HDR_SIZE);
+
+                /* packet header is zero -> not used by chipset */
+                *((u32*)wimax_osal_packet_ptr(pkt)) = 0;
+
+        }
+
+        /* if in idle mode, start exiting from it. otherwise, start
+           processing the data */
+        if (hnd->flags & PC2400M_DRV_CD_FLAGS_IDLE_HOLD_DATA) {
+                /* if in idle, start exiting now */
+                pc2400m_drv_cd_exit_idle(hnd);
+        } else {
+                /* unless in idle, start processing the data */
+                pc2400m_drv_cd_send(hnd);
+        }
+
+        return;
+
+}
+
+/** Initialize the cd instance. This function initializes internal variables
+ *  of the control dispatcher and prepares it for usage.
+ *
+ *  @hnd: handle to the cd instance
+ *  @hdi: handle to the hardware device instance
+ */
+static void pc2400m_drv_cd_initialize(
+        struct pc2400m_drv_cd_if *hnd,
+        struct pc2400m_drv_hdi_if *hdi)
+{
+
+        /* clear flags, such as suspended state */
+        hnd->flags = 0;
+
+        /* clear the suspend operator */
+        hnd->suspend_cb = NULL;
+
+        /* register handler for power save indication */
+        hnd->register_indication(
+                hnd,
+                L3_L4_OPCODE_REPORT_READY_FOR_POWERSAVE,
+                pc2400m_drv_cd_power_save_entry,
+                NULL);
+
+        hnd->hdi = hdi;
+
+        return;
+
+}
+
+/** Register a handler function for data packets. This function registers
+ *  a call back to be called with data packets from the chipset.
+ *
+ *  @param hnd handle to the cd instance
+ *  @param cb handler function to call with IP data packets
+ *  @param data custom data to be passed to the call back
+ *  @return none
+ */
+static void pc2400m_drv_cd_register_pkt_handler(
+        struct pc2400m_drv_cd_if *hnd,
+        cd_pkt_handler_cb cb,
+        void *data)
+{
+
+        hnd->pkt_handler = cb;
+        hnd->pkt_handler_data = data;
+        return;
+
+}
+
+/** Register a handler function for traces. Associates a call back function
+ *  to be called with debug trace messages from the chipset.
+ *
+ *  @param hnd handle to the cd instance
+ *  @param cb handler function to call with debug trace data
+ *  @param data custom data to be passed to the call back
+ *  @return none
+ */
+static void pc2400m_drv_cd_register_dbg_handler(
+        struct pc2400m_drv_cd_if *hnd,
+        cd_dbg_handler_cb cb,
+        void *data)
+{
+
+        hnd->dbg_handler = cb;
+        hnd->dbg_handler_data = data;
+        return;
+
+}
+
+/** Register a handler function for production testing reports. Registers
+ *  handler function for production testing reports data from the chipset.
+ *
+ *  @param hnd handle to the cd instance
+ *  @param cb handler function to call with production testing reports
+ *  @param data custom data to be passed to the call back
+ *  @return none
+ *
+ */
+static void pc2400m_drv_cd_register_prod_handler(
+        struct pc2400m_drv_cd_if *hnd,
+        cd_prod_handler_cb cb,
+        void *data)
+{
+
+        hnd->prod_handler = cb;
+        hnd->prod_handler_data = data;
+        return;
+
+}
+
+/** Process an indication from the chipset. This function processes the
+ *  indication message by forwarding it to the entity having registered to the
+ *  particular indication. If no such entity is found, the indication is
+ *  dropped.
+ *
+ *  @param hnd handle to the control dispatcher instance
+ *  @param msg indication message
+ *  @return none
+ */
+static void pc2400m_drv_cd_process_ind(
+        struct pc2400m_drv_cd_if *hnd,
+        wimax_osal_packet *msg)
+{
+        struct pc2400m_drv_chipif_ctrl_msg *hdrptr =
+                (struct pc2400m_drv_chipif_ctrl_msg*)
+                wimax_osal_packet_ptr(msg);
+        struct pc2400m_drv_cd_ind_elem *pos;
+
+        /* iterate the list of registered indications to found an entry
+           matching the identifier of this message. the element matching
+           the indication will be pointed to by "pos." */
+        wimax_osal_list_foreach(&(hnd->ind_list), pos) {
+                if (pos->id == WIMAX_OSAL_LE_TO_U16(hdrptr->type)) {
+                        pos->cb(hnd, pos->id, msg, pos->data);
+                        break;
+                }
+        }
+
+        if (!pos) {
+
+                /* forward unregistered production testing reports to the
+                   production report handler */
+                if (((WIMAX_OSAL_LE_TO_U16(hdrptr->type) &
+                      L3L4_INDICATION_MASK) == L3L4_INDICATION_MASK) &&
+                    ((WIMAX_OSAL_LE_TO_U16(hdrptr->type) &
+                      L3L4_MODULE_ID_PRODUCTION) == L3L4_MODULE_ID_PRODUCTION)
+                    && hnd->prod_handler) {
+                        hnd->prod_handler(hnd, msg, hnd->prod_handler_data);
+                } else {
+                        wimax_osal_trace_u16(PC2400M_GROUP_CD_ERROR,
+                                             PC2400M_TRACE_UNKNOWN_TYPE,
+                                             WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                                             WIMAX_OSAL_LE_TO_U16(hdrptr->type)
+                                             );
+                        wimax_osal_packet_free(&msg);
+                }
+
+        }
+
+        return;
+
+}
+
+/** Interrupt handler for the chipset. Processes the interrupt from the
+ *  chipset by reading data from the chipset.
+ *
+ *  @param hnd handle to the cd instance
+ *  @return none
+ */
+static void pc2400m_drv_cd_interrupt(struct pc2400m_drv_cd_if *hnd)
+{
+
+        struct pc2400m_drv_chipif_ctrl_msg *hdrptr;
+        wimax_osal_packet_list pkt_list;
+        wimax_osal_packet *msg;
+        s32 type;
+
+        /* the powersave is canceled when data arrives from the
+           chipset */
+        hnd->flags &= (~(PC2400M_DRV_CD_FLAGS_POWER_SAVE |
+                         PC2400M_DRV_CD_FLAGS_POWER_SAVE_HOLD_DATA));
+
+        /* initialize the packet list */
+        wimax_osal_packet_list_initialize(&pkt_list);
+
+        /* read the data */
+        hnd->hdi->read(hnd->hdi);
+        while ((msg = hnd->hdi->get(hnd->hdi, &type)), msg) {
+                switch (type) {
+                case PC2400M_DRV_SPI_FRAME_TYPE_DATA:
+                        if (hnd->pkt_handler) {
+                                /* append the packet into a list */
+                                wimax_osal_packet_list_append(
+                                        &pkt_list, msg);
+                        } else {
+                                /* this occurs if the chipset is sending data
+                                   packets but no handler has been registered
+                                   to handle the data. */
+                                wimax_osal_trace(
+                                        PC2400M_GROUP_CD_ERROR,
+                                        PC2400M_TRACE_PKT_DISCARDED,
+                                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG);
+                                wimax_osal_packet_free(&msg);
+                        }
+                        break;
+                case PC2400M_DRV_SPI_FRAME_TYPE_CONTROL:
+                        /* check against an ongoing control request */
+                        hdrptr = (struct pc2400m_drv_chipif_ctrl_msg*)
+                                wimax_osal_packet_ptr(msg);
+
+                        /* trace the message content */
+                        wimax_osal_trace_data(
+                                PC2400M_GROUP_CD_DEBUG,
+                                PC2400M_TRACE_D2H,
+                                WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                                wimax_osal_packet_ptr(msg),
+                                wimax_osal_packet_size(msg));
+
+                        /* if its a response to a processed message... */
+                        if (hnd->ctrl_processed &&
+                            hnd->ctrl_processed->type ==
+                            WIMAX_OSAL_LE_TO_U16(hdrptr->type)) {
+
+                                /* stop timeout timer */
+                                wimax_osal_timer_cancel(
+                                        hnd->ctrl_processed->timeout_handle);
+                                hnd->ctrl_processed->timeout_handle = 0;
+
+                                /* call the callback for this message */
+                                if (hnd->ctrl_processed->cb)
+                                        hnd->ctrl_processed->cb(
+                                                hnd, msg,
+                                                hnd->ctrl_processed->data);
+                                else
+                                        wimax_osal_packet_free(&msg);
+
+                                /* get rid of the item */
+                                pc2400m_drv_cd_free_msg_elem(
+                                        (void**)&(hnd->ctrl_processed));
+
+                                /* call the suspend handler, if registered */
+                                if ((hnd->flags &
+                                     PC2400M_DRV_CD_FLAGS_SUSPENDED) &&
+                                    hnd->suspend_cb) {
+                                        hnd->suspend_cb(
+                                                hnd, hnd->suspend_cb_data);
+                                        hnd->suspend_cb = NULL;
+                                }
+
+                        } else {
+                                pc2400m_drv_cd_process_ind(hnd, msg);
+                        }
+                        break;
+                case PC2400M_DRV_SPI_FRAME_TYPE_TRACE_INFO:
+                        /* forward to the registered handler function */
+                        if (hnd->dbg_handler) {
+                                /* forward the packet header */
+                                hnd->dbg_handler(
+                                        hnd, msg, hnd->dbg_handler_data);
+                        } else {
+                                /* lose the data silently */
+                                wimax_osal_packet_free(&msg);
+                        }
+                        break;
+                default:
+                        wimax_osal_packet_free(&msg);
+                        wimax_osal_trace_byte(
+                                PC2400M_GROUP_CD_ERROR,
+                                PC2400M_TRACE_UNKNOWN_FRAME,
+                                WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                                type);
+                        break;
+                }
+
+        }
+
+        /* forward the packets in the list to the handler */
+        if (wimax_osal_packet_list_len(&pkt_list))
+                hnd->pkt_handler(hnd, &pkt_list, hnd->pkt_handler_data);
+
+        /* that the packet list is empty at this stage */
+        wimax_osal_packet_list_release(&pkt_list, FALSE);
+
+        /* process the control dispatcher queues */
+        pc2400m_drv_cd_send(hnd);
+
+        return;
+
+}
+
+
+/** Clean up the control dispatcher. Free the memory and resources used by the
+ *  cd cancelling all ongoing operations and bringing it to an initial state.
+ *
+ *  @param hnd pointer to the instance of the control dispatcher
+ *  @return none
+ */
+static void pc2400m_drv_cd_reset(struct pc2400m_drv_cd_if *hnd)
+{
+
+        /* cancel ongoing timers */
+        if (hnd->ctrl_processed) {
+                if (hnd->ctrl_processed->timeout_handle) {
+                        wimax_osal_timer_cancel(
+                                hnd->ctrl_processed->timeout_handle);
+                }
+                pc2400m_drv_cd_free_msg_elem((void**)&(hnd->ctrl_processed));
+        }
+
+        /* cancel power save indication */
+        hnd->register_indication(
+                hnd, L3_L4_OPCODE_REPORT_READY_FOR_POWERSAVE, NULL, NULL);
+
+        /* release flags and suspend handlers */
+        hnd->flags = 0;
+        hnd->suspend_cb = NULL;
+
+        /* clean up message queue */
+        wimax_osal_list_release(
+                &(hnd->ctrl_list), pc2400m_drv_cd_free_msg_elem);
+        wimax_osal_list_initialize(
+                &(hnd->ctrl_list),
+                WIMAX_OSAL_LIST_ELEM_HDR_OFFSET(
+                        struct pc2400m_drv_cd_ctrl_msg_elem, list));
+
+        /* clean up the enqueued packet list */
+        wimax_osal_packet_list_release(&(hnd->pkt_list), TRUE);
+        wimax_osal_packet_list_initialize(&(hnd->pkt_list));
+
+}
+
+/** Remove an instance of the control dispatcher. Free the memory and resources
+ *  used up by the specified instance of the control dispatcher.
+ *
+ *  @param hnd pointer to the instance of the control dispatcher
+ *  @return none
+ */
+static void pc2400m_drv_cd_cleanup(struct pc2400m_drv_cd_if *hnd)
+{
+
+        pc2400m_drv_cd_reset(hnd);
+
+        /* destroy the packet and control lists */
+        wimax_osal_list_release(&(hnd->ctrl_list), NULL);
+        wimax_osal_packet_list_release(&(hnd->pkt_list), FALSE);
+
+        /* enforce assumption, that everyone has cleared their indication
+           registrations */
+        wimax_osal_assert(wimax_osal_list_first(&(hnd->ind_list)) == NULL);
+
+        wimax_osal_mem_free((void**)&hnd);
+
+}
+
+/*****************************************************************************
+ * Exported functions
+ */
+
+/** Create new instance of the control dispatcher. Allocate and initialize a
+ *  new instance of the control dispatcher module, bound to a specific device
+ *  instance.
+ *
+ *  @param ctx the device context to bind this dispatcher instance to
+ *  @return pointer to the newly created instance
+ */
+struct pc2400m_drv_cd_if *pc2400m_drv_cd_if_new(wimax_osal_context* ctx)
+{
+
+        struct pc2400m_drv_cd_if *iface = NULL;
+
+        iface = (struct pc2400m_drv_cd_if*)
+                  wimax_osal_mem_alloc(sizeof(struct pc2400m_drv_cd_if));
+        wimax_osal_mem_set(iface, 0x00,
+                           sizeof(struct pc2400m_drv_cd_if));
+        iface->ctx = ctx;
+        iface->cleanup = pc2400m_drv_cd_cleanup;
+        iface->reset = pc2400m_drv_cd_reset;
+        iface->msg_enqueue = pc2400m_drv_cd_msg_enqueue;
+        iface->register_indication = pc2400m_drv_cd_register_indication;
+        iface->pkt_enqueue = pc2400m_drv_cd_pkt_enqueue;
+        iface->pkt_queue_has_space = pc2400m_drv_cd_pkt_queue_has_space;
+        iface->initialize = pc2400m_drv_cd_initialize;
+        iface->register_pkt_handler = pc2400m_drv_cd_register_pkt_handler;
+        iface->register_dbg_handler = pc2400m_drv_cd_register_dbg_handler;
+        iface->register_prod_handler = pc2400m_drv_cd_register_prod_handler;
+        iface->interrupt = pc2400m_drv_cd_interrupt;
+        iface->suspend = pc2400m_drv_cd_suspend;
+        iface->resume = pc2400m_drv_cd_resume;
+        iface->idle = pc2400m_drv_cd_idle;
+        iface->link_state = pc2400m_drv_cd_link_state;
+
+        /* initialize the SPI queue */
+        wimax_osal_packet_list_initialize(&(iface->pkt_list));
+
+        /* initialize message lists */
+        wimax_osal_list_initialize(
+                &(iface->ind_list),
+                WIMAX_OSAL_LIST_ELEM_HDR_OFFSET(
+                        struct pc2400m_drv_cd_ind_elem, list));
+        wimax_osal_list_initialize(
+                &(iface->ctrl_list),
+                WIMAX_OSAL_LIST_ELEM_HDR_OFFSET(
+                        struct pc2400m_drv_cd_ctrl_msg_elem, list));
+
+        return iface;
+
+}
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_cd.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_cd.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_cd.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_cd.h	2011-02-06 20:12:12.226666605 -0500
@@ -0,0 +1,195 @@
+/*
+ * pc2400m_drv_cd.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         16      APPROVED 21-Feb-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_drv_cd.h
+ *
+ * This file declares the control dispatcher module.
+ *
+ */
+
+#ifndef PC2400M_DRV_CD_H
+#define PC2400M_DRV_CD_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include "pc2400m_osal.h"
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/** flags for packet and data enqueueing */
+#define PC2400M_CD_FLAG_NONE      0x00000000
+#define PC2400M_CD_FLAG_URGENT    0x00000001
+
+/** control dispatcher state flags */
+#define PC2400M_DRV_CD_FLAGS_SUSPENDED            0x00000001
+#define PC2400M_DRV_CD_FLAGS_POWER_SAVE           0x00000002
+#define PC2400M_DRV_CD_FLAGS_POWER_SAVE_HOLD_DATA 0x00000004
+#define PC2400M_DRV_CD_FLAGS_IDLE_HOLD_DATA       0x00000008
+#define PC2400M_DRV_CD_FLAGS_IDLE_EXITING         0x00000010
+#define PC2400M_DRV_CD_FLAGS_LINK_DOWN            0x00000020
+#define PC2400M_DRV_CD_FLAGS_HOLD_DATA            0x0000002c
+
+
+/*****************************************************************************
+ * Data types
+ */
+
+struct pc2400m_drv_cd_if;
+struct pc2400m_drv_hdi_if;
+
+typedef void (*cd_msg_enqueue_cb)(
+        struct pc2400m_drv_cd_if*,
+        wimax_osal_packet*,
+        void*);
+typedef void (*cd_msg_enqueue_func)(
+        struct pc2400m_drv_cd_if*,
+        wimax_osal_packet*,
+        cd_msg_enqueue_cb,
+        void*,
+        u32);
+typedef void (*cd_reset_func)(struct pc2400m_drv_cd_if*);
+typedef void (*cd_cleanup_func)(struct pc2400m_drv_cd_if*);
+typedef void (*cd_indication_cb)(
+        struct pc2400m_drv_cd_if*,
+        u32,
+        wimax_osal_packet*,
+        void*);
+typedef void (*cd_register_indication_func)(
+        struct pc2400m_drv_cd_if*,
+        u32,
+        cd_indication_cb,
+        void*);
+typedef void (*cd_pkt_enqueue_func)(
+        struct pc2400m_drv_cd_if*,
+        wimax_osal_packet_list*);
+typedef void (*cd_initialize_func)(
+        struct pc2400m_drv_cd_if*,
+        struct pc2400m_drv_hdi_if*);
+typedef void (*cd_pkt_handler_cb)(
+        struct pc2400m_drv_cd_if*,
+        wimax_osal_packet_list*,
+        void*);
+typedef void (*cd_register_pkt_handler_func)(
+        struct pc2400m_drv_cd_if*,
+        cd_pkt_handler_cb, void*);
+typedef void (*cd_pkt_queue_empty_cb)(struct pc2400m_drv_cd_if*, void*);
+typedef boolean (*cd_pkt_queue_has_space_func)(
+        struct pc2400m_drv_cd_if*,
+        cd_pkt_queue_empty_cb,
+        void*);
+
+typedef void (*cd_dbg_handler_cb)(
+        struct pc2400m_drv_cd_if*,
+        wimax_osal_packet*,
+        void*);
+typedef void (*cd_register_dbg_handler_func)(
+        struct pc2400m_drv_cd_if*,
+        cd_dbg_handler_cb, void*);
+typedef void (*cd_prod_handler_cb)(
+        struct pc2400m_drv_cd_if*,
+        wimax_osal_packet*,
+        void*);
+typedef void (*cd_register_prod_handler_func)(
+        struct pc2400m_drv_cd_if*,
+        cd_prod_handler_cb, void*);
+typedef void (*cd_interrupt_func)(struct pc2400m_drv_cd_if*);
+typedef void (*cd_suspend_cb)(struct pc2400m_drv_cd_if*, void*);
+typedef void (*cd_suspend_func)(
+        struct pc2400m_drv_cd_if*,
+        cd_suspend_cb,
+        void*);
+typedef void (*cd_resume_func)(struct pc2400m_drv_cd_if*);
+typedef void (*cd_idle_func)(struct pc2400m_drv_cd_if*, boolean);
+typedef void (*cd_link_state_func)(struct pc2400m_drv_cd_if*, boolean);
+
+
+struct pc2400m_drv_cd_ctrl_msg_elem;
+
+/** structure representing the control dispatcher */
+struct pc2400m_drv_cd_if {
+        wimax_osal_context *ctx;
+        cd_msg_enqueue_func msg_enqueue;
+        cd_cleanup_func cleanup;
+        cd_reset_func reset;
+        cd_register_indication_func register_indication;
+        cd_pkt_enqueue_func pkt_enqueue;
+        cd_pkt_queue_has_space_func pkt_queue_has_space;
+        cd_initialize_func initialize;
+        cd_register_pkt_handler_func register_pkt_handler;
+        cd_register_dbg_handler_func register_dbg_handler;
+        cd_register_prod_handler_func register_prod_handler;
+        cd_interrupt_func interrupt;
+        cd_suspend_func suspend;
+        cd_resume_func resume;
+        cd_idle_func idle;
+        cd_link_state_func link_state;
+
+
+        /* instance variables */
+        struct pc2400m_drv_hdi_if *hdi;
+        struct wimax_osal_list ind_list;
+        struct wimax_osal_list ctrl_list;
+        wimax_osal_packet_list pkt_list;
+        struct pc2400m_drv_cd_ctrl_msg_elem *ctrl_processed;
+
+        /* state flags */
+        u32 flags;
+
+        /* data handlers */
+        cd_pkt_handler_cb pkt_handler;
+        void *pkt_handler_data;
+        cd_pkt_queue_empty_cb pkt_queue_empty_cb;
+        void *pkt_queue_empty_data;
+
+        cd_dbg_handler_cb dbg_handler;
+        void *dbg_handler_data;
+
+        cd_prod_handler_cb prod_handler;
+        void *prod_handler_data;
+
+        cd_suspend_cb suspend_cb;
+        void *suspend_cb_data;
+
+};
+
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/* cd instantiator function */
+extern struct pc2400m_drv_cd_if *pc2400m_drv_cd_if_new(
+        wimax_osal_context* ctx);
+
+#endif /* PC2400M_DRV_CD_H */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_chipif.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_chipif.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_chipif.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_chipif.h	2011-02-06 20:12:11.699999939 -0500
@@ -0,0 +1,893 @@
+/*
+ * pc2400m_drv_chipif.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         37      APPROVED 11-Aug-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_drv_chipif.h
+ *
+ * This file declares the message structures and opcodes used with the chipset.
+ *
+ */
+
+#ifndef PC2400M_DRV_CHIPIF_H
+#define PC2400M_DRV_CHIPIF_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+#ifdef PC2400M_OLD_FW_SUPPORT
+
+/* define firmware interface version mappings */
+#define L3L4_VERSION_BETA           0x0005
+#define L3L4_VERSION_BETA30         0x0006
+#define L3L4_VERSION_BETA47         0x0007
+
+#define L3L4_SUPPORTED_VERSIONS \
+        { \
+                {0x0008, 0x0000, 0x0000, L3L4_VERSION_BETA, \
+                 256, (u8*)"Pre-BETA.30"}, \
+                {0x0008, 0x0001, 0x0000, L3L4_VERSION_BETA30, \
+                 256, NULL}, \
+                {0x0009, 0x0000, 0x0000, L3L4_VERSION_BETA30, \
+                 256, NULL}, \
+                {0x0009, 0x0001, 0x0001, L3L4_VERSION_BETA47, \
+                 256, NULL}, \
+                {0xffff, 0xffff, 0xfffc, L3L4_VERSION_BETA47, \
+                 0, (u8*)"Testing"}, \
+                {0xffff, 0xffff, 0xfffd, L3L4_VERSION_BETA47, \
+                 0, NULL}, \
+        };
+
+
+#else /* PC2400M_OLD_FW_SUPPORT */
+#define L3L4_VERSION_BETA30           0x0000
+
+#define L3L4_SUPPORTED_VERSIONS \
+        { \
+                {0x0009, 0x0001, 0x0001, L3L4_VERSION_BETA47, \
+                 256, NULL}, \
+                {0xffff, 0xffff, 0xfffc, L3L4_VERSION_BETA47, \
+                 0, (u8*)"Testing"}, \
+                {0xffff, 0xffff, 0xfffd, L3L4_VERSION_BETA47, \
+                 0, NULL}, \
+        };
+#endif /* PC2400M_OLD_FW_SUPPORT */
+
+
+/* SDIO interface definitions */
+#define PC2400M_DRV_SPI_IO_ENABLE_REG              0x02
+#define PC2400M_DRV_SPI_IO_ENABLE_REG_IOE1         0x02
+
+#define PC2400M_DRV_SPI_IO_READY_REG               0x03
+#define PC2400M_DRV_SPI_IO_READY_REG_NONE          0x00
+
+#define PC2400M_DRV_SPI_INT_ENABLE_REG             0x04
+#define PC2400M_DRV_SPI_INT_ENABLE_REG_IENM        0x01
+#define PC2400M_DRV_SPI_INT_ENABLE_REG_IEN1        0x02
+
+#define PC2400M_DRV_SPI_INT_PENDING_REG            0x05
+#define PC2400M_DRV_SPI_INT_PENDING_REG_INT1       0x02
+
+#define PC2400M_DRV_SPI_CARD_CAPA_REG              0x08
+#define PC2400M_DRV_SPI_CARD_CAPA_REG_E4MI         0x20
+
+#define PC2400M_DRV_SPI_FULL_SPEED_REG             0x13
+#define PC2400M_DRV_SPI_FULL_SPEED_REG_FSM         0x01
+#define PC2400M_DRV_SPI_FULL_SPEED_REG_FS1         0x02
+
+#define PC2400M_DRV_SPI_IO_BLOCK_SIZE_FNC1_LSB_REQ 0x110
+#define PC2400M_DRV_SPI_IO_BLOCK_SIZE_FNC1_MSB_REQ 0x111
+
+
+/* SPI interface definitions */
+#define PC2400M_DRV_SPI_FRAME_TYPE_DATA       0x0
+#define PC2400M_DRV_SPI_FRAME_TYPE_CONTROL    0x1
+#define PC2400M_DRV_SPI_FRAME_TYPE_TRACE_INFO 0x2
+
+#define PC2400M_DRV_SPI_BLOCK_SIZE            256
+#if (PC2400M_DRV_SPI_BLOCK_SIZE == 256)
+#define PC2400M_DRV_SPI_CALC_BLOCK_EXCESS(_len) \
+        (((u32)(_len)) & 0xff)
+#define PC2400M_DRV_SPI_CALC_NUMBER_OF_BLOCKS(_len) \
+        (((u32)(_len)) >> 8)
+#else
+#error Block size must be 256 for the full block determination to work.
+#endif
+#define PC2400M_DRV_SPI_MAX_NUM_OF_BLOCKS     64
+#define PC2400M_DRV_SPI_START_ARASAN          1
+#define PC2400M_DRV_SPI_MAX_TRANSACTION \
+        (PC2400M_DRV_SPI_MAX_NUM_OF_BLOCKS * PC2400M_DRV_SPI_BLOCK_SIZE)
+#define PC2400M_DRV_SPI_GAP                   1
+#define PC2400M_DRV_SPI_SDIO_CMD_SIZE         6
+#define PC2400M_DRV_SPI_CMD_SIZE \
+        (PC2400M_DRV_SPI_START_ARASAN + PC2400M_DRV_SPI_SDIO_CMD_SIZE + \
+         PC2400M_DRV_SPI_GAP)
+#define PC2400M_DRV_SPI_MAX_RESP_SIZE         8
+#define PC2400M_DRV_SPI_BLOCK_EXCESS          40
+#define PC2400M_DRV_SPI_DATA_SIZE \
+        (PC2400M_DRV_SPI_MAX_NUM_OF_BLOCKS * \
+         (PC2400M_DRV_SPI_BLOCK_SIZE + PC2400M_DRV_SPI_BLOCK_EXCESS))
+#define PC2400M_DRV_SPI_DESCRIPTOR_SIZE       4
+#define PC2400M_DRV_SPI_TRANSPORT_HDR_SIZE    16
+#define PC2400M_DRV_SPI_MAX_DESCRIPTORS       60
+#define PC2400M_DRV_SPI_HDR_SIZE \
+        (PC2400M_DRV_SPI_TRANSPORT_HDR_SIZE + \
+         PC2400M_DRV_SPI_DESCRIPTOR_SIZE * PC2400M_DRV_SPI_MAX_DESCRIPTORS)
+#define PC2400M_DRV_SPI_MAX_PAYLOAD \
+        (PC2400M_DRV_SPI_MAX_TRANSACTION - PC2400M_DRV_SPI_HDR_SIZE)
+#define PC2400M_DRV_SPI_FRAME_PAD             16
+
+#ifndef PC2400M_DRV_DISABLE_AGGREGATION
+#define PC2400M_DRV_SPI_MAX_SPI_TX_AGGREGATION  22
+#else /* PC2400M_DRV_DISABLE_AGGREGATION */
+#define PC2400M_DRV_SPI_MAX_SPI_TX_AGGREGATION  1
+#endif /* PC2400M_DRV_DISABLE_AGGREGATION */
+
+#define PC2400M_DRV_SPI_MAX_SPI_RX_AGGREGATION  PC2400M_DRV_SPI_MAX_DESCRIPTORS
+
+#define PC2400M_DRV_SPI_TX_Q_SIZE \
+        PC2400M_DRV_SPI_MAX_SPI_TX_AGGREGATION
+#define PC2400M_DRV_SPI_RX_Q_SIZE \
+        PC2400M_DRV_SPI_MAX_SPI_RX_AGGREGATION
+
+#define PC2400M_DRV_SPI_BLOCK_HEADER      4
+#define PC2400M_DRV_SPI_BLOCK_FOOTER      4
+#define PC2400M_DRV_SPI_BLOCK_PADDING \
+        (PC2400M_DRV_SPI_BLOCK_HEADER + PC2400M_DRV_SPI_BLOCK_FOOTER)
+
+#define PC2400M_DRV_SPI_BLOCK_HEADER_PAT  0xfffffffc
+#define PC2400M_DRV_SPI_BLOCK_FOOTER_PAT  0xffffffff
+
+
+#define PC2400M_DRV_SPI_FW_DL_RETRIES 5
+
+#define PC2400M_DRV_SPI_FW_HEADER    16
+
+/* SPI barkers */
+#define PC2400M_DRV_SPI_H2D_BARKER             0xcafe900d
+#define PC2400M_DRV_SPI_D2H_BARKER             0xbeefbabe
+#define PC2400M_DRV_SPI_UNSECURE_BOOT_BARKER   0xdeadbeef
+#define PC2400M_DRV_SPI_SECURE_BOOT_BARKER     0x0ff1c1a1
+
+/* Boot loader commands */
+#define PC2400M_DRV_SPI_CMD_SIGNATURE          0xcbbc0000
+#define PC2400M_DRV_SPI_CMD_OPCODE_WRITE       2
+#define PC2400M_DRV_SPI_CMD_OPCODE_JUMP        3
+#define PC2400M_DRV_SPI_CMD_OPCODE_SJUMP       8
+#define PC2400M_DRV_SPI_CMD_OPCODE_HASH        9
+#define PC2400M_DRV_SPI_CMD_BIT_RESP_REQD      (1<<9)
+#define PC2400M_DRV_SPI_CMD_SETUP \
+        (PC2400M_DRV_SPI_CMD_SIGNATURE | \
+         PC2400M_DRV_SPI_CMD_OPCODE_WRITE | \
+         PC2400M_DRV_SPI_CMD_BIT_RESP_REQD)
+#define PC2400M_DRV_SPI_CMD_HASH_PAYLOAD \
+        (PC2400M_DRV_SPI_CMD_SIGNATURE | \
+         PC2400M_DRV_SPI_CMD_OPCODE_HASH | \
+         PC2400M_DRV_SPI_CMD_BIT_RESP_REQD)
+
+#define PC2400M_DRV_SPI_CMD_GET_OPCODE(x) ((x)&0xf)
+#define PC2400M_DRV_SPI_CMD_SET_OPCODE(x, oc) (((x)&0xfffffff0) | oc)
+#define PC2400M_DRV_SPI_CMD_IS_JUMP(x) \
+        (PC2400M_DRV_SPI_CMD_GET_OPCODE(x) == \
+         PC2400M_DRV_SPI_CMD_OPCODE_JUMP || \
+         PC2400M_DRV_SPI_CMD_GET_OPCODE(x) == \
+         PC2400M_DRV_SPI_CMD_OPCODE_SJUMP)
+
+/* SPI transport padding macros */
+#define PC2400M_DRV_SPI_PAYLOAD_PAD(x) \
+        WIMAX_OSAL_PAD_GENERIC(x, PC2400M_DRV_SPI_FRAME_PAD)
+#define PC2400M_DRV_SPI_BLOCK_PAD(x)   \
+        WIMAX_OSAL_PAD_GENERIC(x, PC2400M_DRV_SPI_BLOCK_SIZE)
+#define PC2400M_DRV_SPI_XFER_PAD(x) WIMAX_OSAL_PAD4(x)
+
+/* control message header definitions */
+#define L3L4_VERSION         0x00
+#define L3L4_ACCESSIBILITY   0x00
+
+/* message status codes */
+enum L3L4ResponseStatus {
+        L3L4_RESPONSE_STATUS_SUCCESS_DONE = 0x00,
+        L3L4_RESPONSE_STATUS_SUCCESS_IN_PROCESS,
+        L3L4_RESPONSE_STATUS_INVALID_OPCODE,
+        L3L4_RESPONSE_STATUS_ERROR_BAD_STATE,
+        L3L4_RESPONSE_STATUS_ILLEGAL_VALUE,
+        L3L4_RESPONSE_STATUS_MISSING_PARAMS,
+        L3L4_RESPONSE_STATUS_VERSION_ERROR,
+        L3L4_RESPONSE_STATUS_ACCESSIBILITY_ERROR,
+        L3L4_RESPONSE_STATUS_BUSY,
+        L3L4_RESPONSE_STATUS_CORRUPTED_TLV,
+        L3L4_RESPONSE_STATUS_UNINITIALIZED,
+        L3L4_RESPONSE_STATUS_UNKNOWN_ERROR,
+        L3L4_RESPONSE_STATUS_PRODUCTION_ERROR,
+        L3L4_RESPONSE_STATUS_NO_RF,
+        L3L4_RESPONSE_STATUS_NOT_READY_FOR_POWER_SAVE,
+        L3L4_RESPONSE_STATUS_THERMAL_CRITICAL
+};
+
+#define L3L4_SUCCESS(x) ((x) == L3L4_RESPONSE_STATUS_SUCCESS_DONE || \
+                         (x) == L3L4_RESPONSE_STATUS_SUCCESS_IN_PROCESS)
+
+enum L3L4ReportStateReason {
+        L3L4_REPORT_STATE_REASON_NORMAL = 0x01,
+        L3L4_REPORT_STATE_REASON_FAIL_TO_CONNECT_TO_NW,
+        L3L4_REPORT_STATE_REASON_FAIL_TO_CONNECT_RANGING,
+        L3L4_REPORT_STATE_REASON_FAIL_TO_CONNECT_SBC,
+        L3L4_REPORT_STATE_REASON_FAIL_TO_CONNECT_EAP_AUTH,
+        L3L4_REPORT_STATE_REASON_FAIL_TO_CONNECT_3_WAY_HANDSHAKE,
+        L3L4_REPORT_STATE_REASON_FAIL_TO_CONNECT_REGISTRATION,
+        L3L4_REPORT_STATE_REASON_FAIL_TO_CONNECT_DATA_PATH,
+        L3L4_REPORT_STATE_REASON_COEX_NO_RF,
+        L3L4_REPORT_STATE_REASON_DISCONNECT_DREG,
+        L3L4_REPORT_STATE_REASON_DISCONNECT_ABORT,
+        L3L4_REPORT_STATE_REASON_DISCONNECT_RESET,
+        L3L4_REPORT_STATE_REASON_DISCONNECT_DROP,
+        L3L4_REPORT_STATE_REASON_DISCONNECT_SECURITY = 15,
+};
+
+
+
+/* chipset states */
+enum L3L4SystemState {
+        L3L4_SYSTEM_STATE_UNINITIALIZED = 1,
+        L3L4_SYSTEM_STATE_INIT,
+        L3L4_SYSTEM_STATE_READY,
+        L3L4_SYSTEM_STATE_SCAN,
+        L3L4_SYSTEM_STATE_CONNECTING = 6,
+        L3L4_SYSTEM_STATE_WIMAX_CONNECTED,
+        L3L4_SYSTEM_STATE_DATA_PATH_CONNECTED,
+        L3L4_SYSTEM_STATE_IDLE,
+        L3L4_SYSTEM_STATE_DISCONNECTING,
+        L3L4_SYSTEM_STATE_PRODUCTION = 13,
+        L3L4_SYSTEM_STATE_CONFIG,
+        L3L4_SYSTEM_STATE_RF_OFF,
+        L3L4_SYSTEM_STATE_RF_SHUTDOWN
+};
+
+#define L3L4_SYSTEM_STATE_COUNT 16
+
+
+/** scan commands */
+enum L3L4ScanCommand {
+        L3L4_SCAN_COMMAND_START    = 0x01,
+        L3L4_SCAN_COMMAND_STOP
+};
+
+
+enum L3L4ScanPolicy {
+        L3L4_SCAN_POLICY_FIND_FIRST = 0x01,
+        L3L4_SCAN_POLICY_FIND_ALL
+};
+
+enum L3L4Bandwidth {
+        L3L4_BANDWIDTH_NA = 0x00,
+        L3L4_BANDWIDTH_3_5,
+        L3L4_BANDWIDTH_5,
+        L3L4_BANDWIDTH_7,
+        L3L4_BANDWIDTH_8_75,
+        L3L4_BANDWIDTH_10
+};
+
+enum L3L4Fft{
+        L3L4_FFT_NA = 0x00,
+        L3L4_FFT_512,
+        L3L4_FFT_1024
+};
+
+enum L3L4ScanStatus {
+        L3L4_SCAN_STATUS_DONE = 0x01,
+        L3L4_SCAN_STATUS_SCANING,
+        L3L4_SCAN_STATUS_FAILURE,
+        L3L4_SCAN_STATUS_STOPPED,
+        L3L4_SCAN_STATUS_COEXISTENCE_STOP
+};
+
+enum L3L4ConnectProgress {
+        L3L4_CONNECT_PROGRESS_RANGING = 0x01,
+        L3L4_CONNECT_PROGRESS_SBC,
+        L3L4_CONNECT_PROGRESS_EAP_AUTHENTICATION,
+        L3L4_CONNECT_PROGRESS_3_WAY_HANDSHAKE,
+        L3L4_CONNECT_PROGRESS_REGISTRATION
+};
+
+enum L3L4MediaStatus {
+        L3L4_MEDIA_STATUS_LINK_UP   = 0x01,
+        L3L4_MEDIA_STATUS_LINK_DOWN,
+        L3L4_MEDIA_STATUS_LINK_RENEW
+};
+
+enum L3L4RfStatus {
+        L3L4_RF_STATUS_ON    = 0x01,
+        L3L4_RF_STATUS_OFF
+};
+
+enum L3L4ModeOfOperation {
+        L3L4_MODE_OF_OPERATION_NORMAL = 0x01,
+        L3L4_MODE_OF_OPERATION_PRODUCTION
+};
+
+enum L3L4EapKeyValid {
+        L3L4_EAP_KEY_VALID_VALID = 0x01,
+        L3L4_EAP_KEY_VALID_INVALID,
+        L3L4_EAP_KEY_VALID_INTERNAL,
+};
+
+enum L3L4RfSwitch {
+        L3L4_RF_SWITCH_ON = 0x01,
+        L3L4_RF_SWITCH_OFF
+};
+
+enum L3L4RequestRealm {
+        L3L4_REQUEST_REALM_YES = 0x01,
+        L3L4_REQUEST_REALM_NO
+};
+
+enum L3L4WakeupMode {
+        L3L4_WAKEUP_MODE_ENABLED = 0x01,
+};
+
+enum L3L4D2HChannelSwitch {
+        L3L4_D2H_CHANNEL_SWITCH_ON = 0x01,
+        L3L4_D2H_CHANNEL_SWITCH_OFF,
+};
+
+enum L3L4ConfigResetOnAssert {
+        L3L4_CONFIG_RESET_ON_ASSERT_OFF = 0x00,
+        L3L4_CONFIG_RESET_ON_ASSERT_ON,
+};
+
+enum L3L4ConfigHarqCategory {
+        L3L4_CONFIG_HARQ_CATEGORY_2 = 0x02,
+        L3L4_CONFIG_HARQ_CATEGORY_3 = 0x03,
+        L3L4_CONFIG_HARQ_CATEGORY_4 = 0x04,
+};
+
+/* idle timer value limits */
+#define L3L4_IDLE_TIMER_DISABLED  0
+#define L3L4_IDLE_TIMER_MIN       100
+#define L3L4_IDLE_TIMER_MAX       300000
+#define L3L4_IDLE_TIMER_STEP      100
+
+#define L3L4_SLEEP_TIMER_DISABLED 0
+#define L3L4_SLEEP_TIMER_MIN      100
+#define L3L4_SLEEP_TIMER_MAX      300000
+#define L3L4_SLEEP_TIMER_STEP     100
+
+/* opcode masks */
+#define L3L4_INDICATION_MASK         (0x8000)
+
+/* module identifiers */
+#define L3L4_MODULE_ID_PRODUCTION    (0x7000)
+
+/* get opcodes */
+#define L4_L3_OPCODE_GET_LM_VERSION                0x5201
+#define L4_L3_OPCODE_GET_DEVICE_INFO               0x5202
+#define L4_L3_OPCODE_GET_LINK_STATUS               0x5203
+#define L4_L3_OPCODE_GET_STATE                     0x5205
+
+/* set opcodes */
+#define L4_L3_OPCODE_SET_SCAN_PARAM                0x4402
+#define L4_L3_OPCODE_SET_EAP_SUCCESS               0x6402
+#define L4_L3_OPCODE_SET_EAP_FAIL                  0x6403
+#define L4_L3_OPCODE_SET_EAP_KEY                   0x6404
+#define L4_L3_OPCODE_SET_PREINIT_CONFIG            0x5404
+#define L4_L3_OPCODE_SET_D2H_CHANNEL_MASK          0x5405
+
+/* command opcodes */
+#define L4_L3_OPCODE_CMD_RF_CONTROL                0x4602
+#define L4_L3_OPCODE_CMD_SCAN                      0x4603
+#define L4_L3_OPCODE_CMD_CONNECT                   0x4604
+#define L4_L3_OPCODE_CMD_DISCONNECT                0x4605
+#define L4_L3_OPCODE_CMD_EXIT_IDLE                 0x4606
+#define L4_L3_OPCODE_CMD_INIT                      0x5601
+#define L4_L3_OPCODE_CMD_TERMINATE                 0x5602
+#define L4_L3_OPCODE_CMD_MODE_OF_OPERATION         0x5603
+#define L4_L3_OPCODE_CMD_ENTER_POWER_SAVE          0x5606
+#define L4_L3_OPCODE_CMD_SEND_EAP_RESPONSE         0x6602
+
+/* indication opcodes */
+#define L3_L4_OPCODE_REPORT_SCAN_RESULT            0xc002
+#define L3_L4_OPCODE_REPORT_BS_INFO                0xc003
+#define L3_L4_OPCODE_REPORT_SII                    0xc004
+#define L3_L4_OPCODE_REPORT_STATE                  0xd002
+#define L3_L4_OPCODE_REPORT_READY_FOR_POWERSAVE    0xd005
+#define L3_L4_OPCODE_REPORT_EAP_REQUEST            0xe002
+#define L3_L4_OPCODE_REPORT_EAP_RESTART            0xe003
+#define L3_L4_OPCODE_REPORT_ALT_ACCEPT             0xe004
+#define L3_L4_OPCODE_REPORT_KEY_REQUEST            0xe005
+
+
+/*****************************************************************************
+ * Data types
+ */
+
+/** supported message versions */
+struct L3L4SupportedVersion {
+        u16 major;
+        u16 minor;
+        u16 branch;
+        u16 id;
+        u16 hdr_ver;
+        u8 *note;
+};
+
+
+/* SPI transfer message header */
+struct pc2400m_drv_spi_transfer_msg_hdr {
+        u32 barker;
+        u32 seq;
+        u16 num_desc;
+        u16 pad1;
+        u16 pad_cnt;
+        u16 pad2;
+};
+
+/* SPI transfer descriptor */
+struct pc2400m_drv_spi_transfer_desc {
+        u16 size;
+        u16 type;
+};
+
+/* ASIC command header */
+struct pc2400m_drv_spi_asic_hdr {
+        u32 command;
+        u32 address;
+        u32 size;
+        u32 checksum;
+};
+
+
+/* TLV header */
+struct L3L4_TLV_HDR_STR {
+        u16 type;
+        u16 length;
+};
+#define L3L4_TLV_HDR_LEN         (sizeof(struct L3L4_TLV_HDR_STR))
+
+/* TLV definitions */
+#define L3L4_TLV_TYPE_L4_MESSAGE_VERSION 129
+struct L3L4_TLV_STR_L4_MESSAGE_VERSION {
+        struct L3L4_TLV_HDR_STR tlv;
+        u16 version_major;
+        u16 version_minor;
+        u16 version_branch;
+        u16 reserved;
+};
+#define L3L4_TLV_SIZE_L4_MESSAGE_VERSION \
+                            (sizeof(struct L3L4_TLV_STR_L4_MESSAGE_VERSION))
+
+
+#define L3L4_TLV_TYPE_VERSIONS_STRINGS 130
+struct L3L4_TLV_STR_VERSIONS_STRINGS {
+        struct L3L4_TLV_HDR_STR tlv;
+        u16 actual_size;
+        u8 strings[1];
+};
+
+#define L3L4_TLV_TYPE_MODE_OF_OPERATION 131
+struct L3L4_TLV_STR_MODE_OF_OPERATION {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32 mode;
+};
+#define L3L4_TLV_SIZE_MODE_OF_OPERATION \
+                            (sizeof(struct L3L4_TLV_STR_MODE_OF_OPERATION))
+
+#define L3L4_TLV_TYPE_D2H_CHANNEL_MASK 134
+struct L3L4_TLV_STR_D2H_CHANNEL_MASK {
+        struct L3L4_TLV_HDR_STR tlv;
+        u8 data_channel_switch;
+        u8 diagnostics_channel_switch;
+        u8 reserved1;
+        u8 reserved2;
+};
+#define L3L4_TLV_SIZE_D2H_CHANNEL_MASK \
+                            (sizeof(struct L3L4_TLV_STR_D2H_CHANNEL_MASK))
+
+#define L3L4_TLV_TYPE_ODM_INFORMATION 138
+struct L3L4_TLV_STR_ODM_INFORMATION {
+        struct L3L4_TLV_HDR_STR tlv;
+#define L3L4_ODM_LOCATION_LEN 2
+        u8 location[L3L4_ODM_LOCATION_LEN];
+#define L3L4_ODM_PRODUCTION_LINE_LEN 2
+        u8 production_line[L3L4_ODM_PRODUCTION_LINE_LEN];
+#define L3L4_ODM_MANUFACTURING_DATE_LEN 8
+        u8 manufacturing_date[L3L4_ODM_MANUFACTURING_DATE_LEN];
+#define L3L4_ODM_RESERVED1_LEN 8
+        u8 reserved1[L3L4_ODM_RESERVED1_LEN];
+#define L3L4_ODM_CODE_LEN 2
+        u8 odm_code[L3L4_ODM_CODE_LEN];
+#define L3L4_ODM_RESERVED2_LEN 66
+        u8 reserved2[L3L4_ODM_RESERVED2_LEN];
+#define L3L4_ODM_SERIAL_NUMBER_LEN 20
+        u8 serial_number[L3L4_ODM_SERIAL_NUMBER_LEN];
+};
+#define L3L4_TLV_SIZE_ODM_INFORMATION  \
+                           (sizeof(struct L3L4_TLV_STR_ODM_INFORMATION))
+
+#define L3L4_TLV_TYPE_NVM_INFORMATION 139
+struct L3L4_TLV_STR_NVM_INFORMATION {
+        struct L3L4_TLV_HDR_STR tlv;
+        u16 image_version;
+        u16 content_version;
+};
+#define L3L4_TLV_SIZE_NVM_INFORMATION  \
+                           (sizeof(struct L3L4_TLV_STR_NVM_INFORMATION))
+
+#define L3L4_TLV_TYPE_DEVICE_DETAILS 140
+struct L3L4_TLV_STR_DEVICE_DETAILS {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32 model_type;
+        u32 model_type_str_len;
+#define L3L4_MODEL_TYPE_STR_LEN      124
+        u8 model_type_str[L3L4_MODEL_TYPE_STR_LEN];
+        u32 manufacturer_id;
+        u32 manufacturer_id_str_len;
+#define L3L4_MANUFACTURER_ID_STR_LEN 124
+        u8 manufacturer_id_str[L3L4_MANUFACTURER_ID_STR_LEN];
+        u32 product_str_len;
+#define L3L4_PRODUCT_STR_LEN      124
+        u8 product_str[L3L4_PRODUCT_STR_LEN];
+#define L3L4_PRLOCK_TS_LEN           8
+        u8 prlock_ts[L3L4_PRLOCK_TS_LEN];
+#define L3L4_MAC_ADDR_LEN            6
+        u8 mac_address[L3L4_MAC_ADDR_LEN];
+        u8 reserved1;
+        u8 reserved2;
+};
+#define L3L4_TLV_SIZE_DEVICE_DETAILS \
+                            (sizeof(struct L3L4_TLV_STR_DEVICE_DETAILS))
+
+
+#define L3L4_TLV_TYPE_SYSTEM_STATE 141
+struct L3L4_TLV_STR_SYSTEM_STATE {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32 state;
+};
+#define L3L4_TLV_SIZE_SYSTEM_STATE (sizeof(struct L3L4_TLV_STR_SYSTEM_STATE))
+
+#define L3L4_TLV_TYPE_WAKEUP_MODE 144
+struct L3L4_TLV_STR_WAKEUP_MODE {
+        struct L3L4_TLV_HDR_STR tlv;
+        u8 wake_up_mode;
+        u8 reserved1;
+        u8 reserved2;
+        u8 reserved3;
+};
+#define L3L4_TLV_SIZE_WAKEUP_MODE   (sizeof(struct L3L4_TLV_STR_WAKEUP_MODE))
+
+#define L3L4_TLV_TYPE_REPORT_STATE_REASON 150
+struct L3L4_TLV_STR_REPORT_STATE_REASON {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32 reason;
+};
+#define L3L4_TLV_SIZE_REPORT_STATE_REASON \
+                            (sizeof(struct L3L4_TLV_STR_REPORT_STATE_REASON))
+
+
+#define L3L4_TLV_TYPE_LINK_STATUS 160
+struct L3L4_TLV_STR_LINK_STATUS {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32  up_link_speed;
+        u32  down_link_speed;
+        u32  center_frequency;
+        u8   tx_power;
+        u8   rx_rssi;
+        u8   rx_cinr;
+#define L3L4_BSID_LENGTH  6
+        u8   bsid[L3L4_BSID_LENGTH];
+        u8   link_quality;
+        u8   reserved1;
+        u8   reserved2;
+};
+#define L3L4_TLV_SIZE_LINK_STATUS (sizeof(struct L3L4_TLV_STR_LINK_STATUS))
+
+
+#define L3L4_TLV_TYPE_MEDIA_STATUS 161
+struct L3L4_TLV_STR_MEDIA_STATUS {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32  media_status;
+};
+#define L3L4_TLV_SIZE_MEDIA_STATUS (sizeof(struct L3L4_TLV_STR_MEDIA_STATUS))
+
+
+
+#define L3L4_TLV_TYPE_RF_OPERATION 162
+struct L3L4_TLV_STR_RF_OPERATION {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32  rf_operation;
+};
+#define L3L4_TLV_SIZE_RF_OPERATION (sizeof(struct L3L4_TLV_STR_RF_OPERATION))
+
+#define L3L4_TLV_TYPE_RF_SWITCHES_STATUS 163
+struct L3L4_TLV_STR_RF_SWITCHES_STATUS {
+        struct L3L4_TLV_HDR_STR tlv;
+        u8 sw_rf_switch;
+        u8 hw_rf_switch;
+        u8 reserved1;
+        u8 reserved2;
+};
+#define L3L4_TLV_SIZE_RF_SWITCHES_STATUS \
+                               (sizeof(struct L3L4_TLV_STR_RF_SWITCHES_STATUS))
+
+#define L3L4_TLV_TYPE_CHANNEL_INFO 181
+struct L3L4_TLV_STR_CHANNEL_INFO {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32  frequency;
+        u16  channel_id;
+        u8   bandwidth;
+        u8   fft;
+#define L3L4_PREAMBLE_SIZE 15
+        u8   preambles[L3L4_PREAMBLE_SIZE];
+        u8   reserved;
+};
+#define L3L4_TLV_SIZE_CHANNEL_INFO (sizeof(struct L3L4_TLV_STR_CHANNEL_INFO))
+#define L3L4_MAX_CHANNEL_INFO_COUNT   32
+
+#define L3L4_TLV_TYPE_SCAN_POLICY 183
+struct L3L4_TLV_STR_SCAN_POLICY {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32 scan_mode;
+};
+#define L3L4_TLV_SIZE_SCAN_POLICY (sizeof(struct L3L4_TLV_STR_SCAN_POLICY))
+
+#define L3L4_TLV_TYPE_TH_CRITERIA 182
+struct L3L4_TLV_STR_TH_CRITERIA {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32 rssi;
+        u32 cinr;
+};
+#define L3L4_TLV_SIZE_TH_CRITERIA (sizeof(struct L3L4_TLV_STR_TH_CRITERIA))
+
+
+#define L3L4_TLV_TYPE_NETWORK_SCAN_RESULT 185
+struct L3L4_TLV_STR_NETWORK_SCAN_RESULT {
+        struct L3L4_TLV_HDR_STR tlv;
+        u8  best_rssi;
+        u8  best_cinr;
+        u8  network_id_mask[L3L4_BSID_LENGTH];
+        u8  network_id[L3L4_BSID_LENGTH];
+        u16 num_of_links;
+        u16 channel_id[1];
+};
+#define L3L4_TLV_SIZE_NETWORK_SCAN_RESULT(ids) \
+        ((sizeof(struct L3L4_TLV_STR_NETWORK_SCAN_RESULT)-sizeof(u16)) + \
+        (ids) * sizeof(u16))
+
+#define L3L4_MAX_SCAN_RESULT_COUNT     32
+
+
+#define L3L4_TLV_TYPE_NETWORK_SCAN_RESULT_ALPHA1 185
+struct L3L4_TLV_STR_NETWORK_SCAN_RESULT_ALPHA1 {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32  best_rssi;
+#define L3L4_NAPID_SIZE 3
+        u8   network_id[L3L4_NAPID_SIZE];
+        u8   num_of_links;
+};
+#define L3L4_TLV_SIZE_NETWORK_SCAN_RESULT_ALPHA1 \
+                       (sizeof(struct L3L4_TLV_STR_NETWORK_SCAN_RESULT_ALPHA1))
+#define L3L4_MAX_SCAN_RESULT_COUNT_ALPHA1     16
+
+
+
+#define L3L4_TLV_TYPE_SCAN_COMMAND 186
+struct L3L4_TLV_STR_SCAN_COMMAND {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32  do_scan_command;
+};
+#define L3L4_TLV_SIZE_SCAN_COMMAND (sizeof(struct L3L4_TLV_STR_SCAN_COMMAND))
+
+#define L3L4_TLV_TYPE_SCAN_STATUS 187
+struct L3L4_TLV_STR_SCAN_STATUS {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32 scan_status;
+};
+#define L3L4_TLV_SIZE_SCAN_STATUS (sizeof(struct L3L4_TLV_STR_SCAN_STATUS))
+
+
+#define L3L4_TLV_TYPE_BS_CRITERIA 190
+struct L3L4_TLV_STR_BS_CRITERIA {
+        struct L3L4_TLV_HDR_STR tlv;
+        u8   bsid_criterion[L3L4_BSID_LENGTH];
+        u8   bsid_criterion_mask[L3L4_BSID_LENGTH];
+};
+#define L3L4_TLV_SIZE_BS_CRITERIA (sizeof(struct L3L4_TLV_STR_BS_CRITERIA))
+
+
+#define L3L4_TLV_TYPE_CONNECT_PROGRESS 191
+struct L3L4_TLV_STR_CONNECT_PROGRESS {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32  progress;
+};
+#define L3L4_TLV_SIZE_CONNECT_PROGRESS \
+                             (sizeof(struct L3L4_TLV_STR_CONNECT_PROGRESS))
+
+#define L3L4_TLV_TYPE_CONNECT_FLAGS 192
+struct L3L4_TLV_STR_CONNECT_FLAGS {
+        struct L3L4_TLV_HDR_STR tlv;
+        u8 request_realm;
+#define L3L4_NSP_ID_LENGTH 3
+        u8 nsp_id[L3L4_NSP_ID_LENGTH];
+#define L3L4_CONNECT_FLAGS_SIQ_REQUEST_NSP_ID_LIST           0x01
+#define L3L4_CONNECT_FLAGS_SIQ_REQUEST_NSP_VERBOSE_NAME_LIST 0x02
+        u8 siq;
+        u8 reserved1;
+        u8 reserved2;
+        u8 reserved3;
+};
+#define L3L4_TLV_SIZE_CONNECT_FLAGS (sizeof(struct L3L4_TLV_STR_CONNECT_FLAGS))
+
+#define L3L4_TLV_TYPE_NSPID_LIST 193
+struct L3L4_TLV_STR_NSPID_LIST {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32 nsp_id_list_length;
+        u8  nsp_id_list_data[1];
+};
+#define L3L4_TLV_SIZE_NSPID_LIST(len) \
+                    (sizeof(struct L3L4_TLV_STR_NSPID_LIST) + len - sizeof(u8))
+
+#define L3L4_TLV_TYPE_NSP_VERBOSE_NAME_LIST 194
+struct L3L4_TLV_STR_NSP_VERBOSE_NAME_LIST {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32 nsp_list_length;
+        u8  nsp_list_data[1];
+};
+#define L3L4_TLV_SIZE_NSP_VERBOSE_NAME_LIST(len) \
+         (sizeof(struct L3L4_TLV_STR_NSP_VERBOSE_NAME_LIST) + len - sizeof(u8))
+
+#define L3L4_TLV_TYPE_REALM 195
+struct L3L4_TLV_STR_REALM {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32 realm_length;
+        u8  realm_data[1];
+};
+#define L3L4_TLV_SIZE_REALM(len) \
+                         (sizeof(struct L3L4_TLV_STR_REALM) + len - sizeof(u8))
+
+#define L3L4_TLV_TYPE_BSID 196
+struct L3L4_TLV_STR_BSID {
+        struct L3L4_TLV_HDR_STR tlv;
+        u8 bsid[L3L4_BSID_LENGTH];
+        u8 reserved1;
+        u8 reserved2;
+};
+#define L3L4_TLV_SIZE_BSID                (sizeof(struct L3L4_TLV_STR_BSID))
+
+#define L3L4_TLV_TYPE_NSP_CHANGE_COUNT 197
+struct L3L4_TLV_STR_NSP_CHANGE_COUNT {
+        struct L3L4_TLV_HDR_STR tlv;
+        u8 nsp_change_count;
+        u8 reserved1;
+        u8 reserved2;
+        u8 reserved3;
+};
+#define L3L4_TLV_SIZE_NSP_CHANGE_COUNT \
+                             (sizeof(struct L3L4_TLV_STR_NSP_CHANGE_COUNT))
+
+#define L3L4_TLV_TYPE_CONFIG_IDLE_PARAMETERS 601
+struct L3L4_TLV_STR_CONFIG_IDLE_PARAMETERS {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32 idle_timeout;
+        u32 idle_paging_interval;
+};
+#define L3L4_TLV_SIZE_CONFIG_IDLE_PARAMETERS \
+                       (sizeof(struct L3L4_TLV_STR_CONFIG_IDLE_PARAMETERS))
+
+#define L3L4_TLV_TYPE_CONFIG_LINK_DOWN_TIMER 602
+struct L3L4_TLV_STR_CONFIG_LINK_DOWN_TIMER {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32 link_retry_period;
+};
+#define L3L4_TLV_SIZE_CONFIG_LINK_DOWN_TIMER \
+                       (sizeof(struct L3L4_TLV_STR_CONFIG_LINK_DOWN_TIMER))
+
+#define L3L4_TLV_TYPE_CONFIG_SLEEP_PARAMETERS 603
+struct L3L4_TLV_STR_CONFIG_SLEEP_PARAMETERS {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32 sleep_timeout;
+};
+#define L3L4_TLV_SIZE_CONFIG_SLEEP_PARAMETERS \
+                      (sizeof(struct L3L4_TLV_STR_CONFIG_SLEEP_PARAMETERS))
+
+#define L3L4_TLV_TYPE_CONFIG_RESET_ON_ASSERT 605
+struct L3L4_TLV_STR_CONFIG_RESET_ON_ASSERT {
+        struct L3L4_TLV_HDR_STR tlv;
+        u8 state;
+        u8 reserved1;
+        u8 reserved2;
+        u8 reserved3;
+};
+#define L3L4_TLV_SIZE_CONFIG_RESET_ON_ASSERT \
+                       (sizeof(struct L3L4_TLV_STR_CONFIG_RESET_ON_ASSERT))
+
+#define L3L4_TLV_TYPE_CONFIG_HARQ_PARAMETERS 610
+struct L3L4_TLV_STR_CONFIG_HARQ_PARAMETERS {
+        struct L3L4_TLV_HDR_STR tlv;
+        u8 harq_category;
+        u8 reserved1;
+        u8 reserved2;
+        u8 reserved3;
+};
+#define L3L4_TLV_SIZE_CONFIG_HARQ_PARAMETERS \
+                       (sizeof(struct L3L4_TLV_STR_CONFIG_HARQ_PARAMETERS))
+
+#define L3L4_TLV_TYPE_REPORT_EAP_REQUEST 1026
+struct L3L4_TLV_STR_REPORT_EAP_REQUEST {
+        struct L3L4_TLV_HDR_STR tlv;
+        u16 length;
+        u8 data; /* variable length data, up to 1600 bytes */
+};
+#define L3L4_TLV_SIZE_REPORT_EAP_REQUEST       (L3L4_TLV_HDR_LEN + sizeof(u16))
+
+#define L3L4_TLV_TYPE_REPORT_EAP_RESPONSE 1027
+struct L3L4_TLV_STR_REPORT_EAP_RESPONSE {
+        struct L3L4_TLV_HDR_STR tlv;
+        u16 length;
+        u8 data; /* variable length data, up to 1600 bytes */
+};
+#define L3L4_TLV_SIZE_REPORT_EAP_RESPONSE      (L3L4_TLV_HDR_LEN + sizeof(u16))
+
+#define L3L4_TLV_TYPE_SET_EAP_KEY_VALID 1028
+struct L3L4_TLV_STR_SET_EAP_KEY_VALID {
+        struct L3L4_TLV_HDR_STR tlv;
+        u32 key_valid;
+};
+#define L3L4_TLV_SIZE_SET_EAP_KEY_VALID \
+                             (sizeof(struct L3L4_TLV_STR_SET_EAP_KEY_VALID))
+
+#define L3L4_TLV_TYPE_SET_EAP_KEY_MSK 1029
+struct L3L4_TLV_STR_SET_EAP_KEY_MSK {
+        struct L3L4_TLV_HDR_STR tlv;
+#define L3L4_MSK_LENGTH 64
+        u8 msk[L3L4_MSK_LENGTH];
+};
+#define L3L4_TLV_SIZE_SET_EAP_KEY_MSK \
+                             (sizeof(struct L3L4_TLV_STR_SET_EAP_KEY_MSK))
+
+
+/* Generic control message header */
+struct pc2400m_drv_chipif_ctrl_msg {
+        u16 type;
+        u16 length;
+        u16 version;
+        u16 accessibility;
+        u16 status;
+        u16 reserved;
+};
+#define PC2400M_DRV_CHIPIF_CTRL_MSG_LEN (12)
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+
+#endif /* PC2400M_DRV_CHIPIF_H */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_com.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_com.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_com.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_com.h	2011-02-06 20:12:11.979999938 -0500
@@ -0,0 +1,258 @@
+/*
+ * pc2400m_drv_com.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         32      APPROVED 12-May-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_drv_com.h
+ *
+ * This file declares common definitions used throughout the driver, and
+ * declares the main instance representing the driver.
+ *
+ */
+
+#ifndef PC2400M_DRV_COM_H
+#define PC2400M_DRV_COM_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include "pc2400m_osal.h"
+#include "pc2400m_drv_conf.h"
+#include "pc2400m_drv_if.h"
+#include "pc2400m_drv_chipif.h"
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/* internal status codes */
+#define ESUCCESS     0
+#define ECANCEL      1
+#define EGENERAL    19
+#define ESTATE      20
+#define EVALUE      21
+
+/* conversion between chipset and WiHAL types */
+#define PC2400M_DRV_GET_WIHAL_RSSI(priv, x) \
+        ((u8)(123-x))
+#define PC2400M_DRV_GET_WIHAL_CINR(priv, x) \
+        (x)
+#define PC2400M_DRV_GET_WIHAL_NAP_ID_MASK(priv, x) \
+        (priv)->get_nap_id_mask((priv)->ctx, x)
+#define PC2400M_DRV_GET_WIHAL_NAP_ID(priv, x) \
+        ( ((u32)((x)[0])<<16) | ((u32)((x)[1])<<8) | ((u32)((x)[2])) )
+#define PC2400M_DRV_FULL_BSID_MASK \
+        ((u8*)"\xff\xff\xff\xff\xff\xff")
+#define PC2400M_DRV_EMPTY_BSID_MASK \
+        ((u8)"\x00\x00\x00\x00\x00\x00")
+#define PC2400M_DRV_GET_WIHAL_NAP_AND_NSP(priv, mask, id) \
+        (priv)->get_nap_and_nsp_flag((priv)->ctx, mask, id)
+#define PC2400M_DRV_GET_WIHAL_CHANNEL_PLAN(priv, cp, freq, bw, fft, preamble) \
+        (priv)->get_channel_plan( \
+                (priv->ctx), cp, freq, bw, fft, preamble)
+#define PC2400M_DRV_GET_WIHAL_ERROR(code) ((enum t_wihal_status)(1 - (code)))
+#define PC2400M_DRV_SET_WIHAL_CHANNEL_PLAN(priv, cp, freq, bw, fft, preambles)\
+        { \
+                *(freq) = WIMAX_OSAL_U32_TO_LE((cp)->carrier_freq); \
+                *(bw) = (u8)((cp)->channel_bandwidth); \
+                *(fft) = (u8)((cp)->fft_size); \
+                wimax_osal_mem_cpy((preambles), (cp)->preamble, \
+                                   WIHAL_PREAMBLE_SIZE); \
+        }
+
+/* conversion between WiHAL and chipset types */
+#define PC2400M_DRV_SET_NAP_ID(priv, w, napid) \
+        { \
+                wimax_osal_mem_set((napid), 0x00, L3L4_BSID_LENGTH); \
+                (napid)[0] = (u8)(((u32)w) >> 16); \
+                (napid)[1] = (u8)(((u32)w) >> 8); \
+                (napid)[2] = (u8)(((u32)w)); \
+        }
+
+#define PC2400M_DRV_SET_NAP_ID_MASK(priv, w, mask) \
+        { \
+                wimax_osal_mem_set((mask), 0x00, L3L4_BSID_LENGTH); \
+                (mask)[0] = (u8)(((u32)w) >> 16); \
+                (mask)[1] = (u8)(((u32)w) >> 8); \
+                (mask)[2] = (u8)(((u32)w)); \
+        }
+
+/* parameter validity checker helpers */
+#define PC2400M_DRV_IS_VALID_NAP_ID_MASK(priv, x) \
+        (((x) == E_WIHAL_NAP_ID_MASK_COMPRESSED) || \
+         ((x) == E_WIHAL_NAP_ID_MASK_FULL))
+#define PC2400M_DRV_IS_VALID_SEARCH_NSP_INFO(priv, x) \
+        (((x) == E_WIHAL_SEARCH_NSP_INFO_REQ_NONE) || \
+         ((x) == E_WIHAL_SEARCH_NSP_INFO_REQ_NSP_LIST) || \
+         ((x) == E_WIHAL_SEARCH_NSP_INFO_REQ_NSP_LIST_AND_NAMES))
+#define PC2400M_DRV_IS_VALID_SEARCH_PLAN(priv, x) \
+        ((((x)->fft_size == E_WIHAL_FFT_SIZE_512) || \
+          ((x)->fft_size == E_WIHAL_FFT_SIZE_1024)) && \
+         (((x)->channel_bandwidth == E_WIHAL_CHANNEL_BANDWIDTH_3_5MHZ) || \
+          ((x)->channel_bandwidth == E_WIHAL_CHANNEL_BANDWIDTH_5MHZ) || \
+          ((x)->channel_bandwidth == E_WIHAL_CHANNEL_BANDWIDTH_7MHZ) || \
+          ((x)->channel_bandwidth == E_WIHAL_CHANNEL_BANDWIDTH_8_75MHZ) || \
+          ((x)->channel_bandwidth == E_WIHAL_CHANNEL_BANDWIDTH_10MHZ)))
+
+/* generic helper macros */
+#define PC2400M_DRV_UNWARN(x)  x = x
+
+/*****************************************************************************
+ * Data types
+ */
+
+struct pc2400m_drv_dm_if;
+
+/* functions for sending WiHAL event messages */
+typedef void (*drv_send_system_state_ind_fnc)(
+        wimax_osal_context*,
+        enum t_wihal_system_state);
+typedef void (*drv_send_network_status_ind_fnc)(
+        wimax_osal_context*,
+        enum t_wihal_network_status,
+        enum t_wihal_network_status_err,
+        t_wihal_bsid,
+        struct t_wihal_search_plan*,
+        u32,
+        u8*);
+typedef void (*drv_send_search_ind_fnc)(
+        wimax_osal_context*,
+        u32,
+        enum t_wihal_nap_id_mask,
+        enum t_wihal_nap_and_nsp,
+        u8,
+        u8,
+        struct t_wihal_search_plan*);
+typedef void (*drv_send_search_nap_resp_fnc)(
+        wimax_osal_context*,
+        enum t_wihal_status,
+        void*);
+typedef void (*drv_send_search_nsp_resp_fnc)(
+        wimax_osal_context*,
+        enum t_wihal_status,
+        t_wihal_nap_id,
+        t_wihal_nsp_change_count,
+        enum t_wihal_nap_and_nsp,
+        u32,
+        struct t_wihal_nsp_info*,
+        void*);
+typedef void (*drv_send_network_status_resp_fnc)(
+        wimax_osal_context*,
+        enum t_wihal_status,
+        enum t_wihal_network_status,
+        t_wihal_bsid,
+        struct t_wihal_search_plan*,
+        u8,
+        u8,
+        void*);
+
+/* functions to aid conversion to WiHAL data types */
+typedef enum t_wihal_nap_id_mask (*drv_get_nap_id_mask_fnc)(
+        wimax_osal_context*,
+        u8*);
+typedef enum t_wihal_nap_and_nsp (*drv_get_nap_and_nsp_flag_fnc)(
+        wimax_osal_context*,
+        u8*,
+        u8*);
+typedef void (*drv_get_channel_plan_fnc)(
+        wimax_osal_context*,
+        struct t_wihal_search_plan*,
+        u32,
+        u8,
+        u8,
+        u8*);
+
+struct pc2400m_private;
+typedef void (*drv_unref_cb)(wimax_osal_context*, void*);
+typedef void (*drv_ref_fnc)(struct pc2400m_private*);
+typedef void (*drv_unref_fnc)(struct pc2400m_private*);
+typedef void (*drv_unref_data_fnc)(
+        struct pc2400m_private*,
+        drv_unref_cb,
+        void*);
+
+struct pc2400m_private {
+
+        /* client interfaces */
+        struct t_wihal_event_if *eif;
+        struct t_wihal_adaptation_if *aif;
+
+        /* function interface */
+        drv_send_network_status_ind_fnc send_network_status_ind;
+        drv_send_system_state_ind_fnc send_system_state_ind;
+        drv_send_search_ind_fnc send_search_ind;
+        drv_send_search_nap_resp_fnc send_search_nap_resp;
+        drv_send_search_nsp_resp_fnc send_search_nsp_resp;
+        drv_send_network_status_resp_fnc send_network_status_resp;
+
+        drv_get_nap_id_mask_fnc get_nap_id_mask;
+        drv_get_nap_and_nsp_flag_fnc get_nap_and_nsp_flag;
+        drv_get_channel_plan_fnc get_channel_plan;
+
+        drv_ref_fnc ref;
+        drv_unref_fnc unref;
+        drv_unref_data_fnc unref_data;
+
+        /* subsystem instance pointers */
+        void *ctx;
+        struct pc2400m_drv_dm_if *dm;
+        struct pc2400m_drv_dm_if *dm_old;
+
+        /* data credit counter */
+        u32 send_credit;
+
+        /* receive ring definition */
+        int recv_polled;
+        wimax_osal_packet_list pkt_list;
+
+        /* EAP msk storage */
+        u8 msk[L3L4_MSK_LENGTH];
+#define PC2400M_DRV_MSK_FLAG_VALID   0x01
+#define PC2400M_DRV_MSK_FLAG_REQD    0x02
+        u8 msk_flags;
+        wimax_osal_timer_handle msk_req_timer;
+
+        /* driver mode flags */
+#define PC2400M_DRV_COM_PROD_TEST_MODE 0x00000001
+#define PC2400M_DRV_COM_DATA_HOLD_MODE 0x00000002
+#define PC2400M_DRV_COM_CLOSE_MODE     0x00000004
+        u32 mode_flags;
+
+        /* reference counter */
+        u32 ref_cnt;
+        drv_unref_cb unref_cb;
+        void *unref_cb_data;
+
+};
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+#endif /* PC2400M_DRV_COM_H */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_conf.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_conf.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_conf.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_conf.h	2011-02-06 20:12:11.539999941 -0500
@@ -0,0 +1,116 @@
+/*
+ * pc2400m_drv_conf.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         8  APPROVED 09-Sep-2008 Jouni Lappi
+*/
+
+/** @file pc2400m_drv_conf.h
+ *
+ * This file defines compile-time configuration items.
+ *
+ */
+
+#ifndef PC2400M_DRV_CONF_H
+#define PC2400M_DRV_CONF_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/*****************************************************************************
+ * Data types
+ */
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+#ifndef CONFIG_NET_PC2400M_DISABLE_LEGACY_FW
+/** defined to request support for old legacy firmware versions */
+#define PC2400M_OLD_FW_SUPPORT
+#endif /* !CONFIG_NET_PC2400M_DISABLE_LEGACY_FW */
+
+/** defined to disable SPI message aggregation */
+#define PC2400M_DRV_DISABLE_AGGREGATION
+#ifdef CONFIG_NET_PC2400M_ALLOW_SPI_AGGREGATION
+#undef PC2400M_DRV_DISABLE_AGGREGATION
+#endif /* CONFIG_NET_PC2400M_ALLOW_SPI_AGGREGATION */
+
+#ifdef CONFIG_NET_PC2400M_ENABLE_CHIPSET_INTERNAL_RESET
+/** defined to enable the chipset internal reset functionality */
+#define PC2400M_DRV_ENABLE_CHIPSET_RESET
+#endif /* CONFIG_NET_PC2400M_ENABLE_CHIPSET_INTERNAL_RESET */
+
+/** downlink data buffer low watermark */
+#define PC2400M_DRV_RECEIVE_BUFFER_LOW_WATERMARK    10
+
+/** downlink data buffer high watermark */
+#define PC2400M_DRV_RECEIVE_BUFFER_HIGH_WATERMARK   20
+
+/** uplink data buffer low watermark */
+#define PC2400M_DRV_CD_SEND_BUFFER_LOW_WATERMARK    10
+
+/** uplink data buffer low watermark */
+#define PC2400M_DRV_CD_SEND_BUFFER_HIGH_WATERMARK   20
+
+/** device manager transaction timeout value in microseconds */
+#define PC2400M_DRV_DM_TRANSITION_TIMEOUT           3000000 /* 3 seconds */
+
+/** handover detection interval in microseconds */
+#define PC2400M_DRV_DM_HANDOVER_CHECK_INTERVAL      30000000 /* 30 seconds */
+
+/** control dispatcher control message timeout in microseconds */
+#define PC2400M_DRV_CD_RESPONSE_TIMEOUT             2000000 /* 2 seconds */
+
+/** timeout for waiting for MSK from EAP */
+#define PC2400M_DRV_MSK_REQ_TIMEOUT  1000000 /* microseconds */
+
+/** define to have the chipset be configured to HARQ category 3 during
+    bootup (requires BETA.47 or newer.) */
+#define PC2400M_DRV_DM_CONFIGURE_HARQ_CATEGORY_3
+
+/** define to have the driver enforce a single bandwidth used during a
+    WiMAX session (some chipset version will reset if intermixed.) */
+#define PC2400M_DRV_DM_LOCK_SESSION_BANDWIDTH
+
+/** define the number of channels grouped into single scan request. Minimum
+    is 1 and maximum is 128 */
+#define PC2400M_DRV_DM_SCAN_CHANNEL_GROUP_SIZE      6
+
+/* define the special timeout for the scan stop transition, because
+   currently the chipset does not support correct scan stop and therefore
+   a timeout might occur. Not defining a value will revert to the
+   generic transition timeout handling. */
+#define PC2400M_DRV_DM_SCAN_STOP_TIMEOUT \
+        (PC2400M_DRV_DM_SCAN_CHANNEL_GROUP_SIZE * 3 * 1000000) /* microsecs */
+
+
+#endif /* PC2400M_DRV_CONF_H */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_dm_bg.c maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_dm_bg.c
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_dm_bg.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_dm_bg.c	2011-02-06 20:12:12.296666606 -0500
@@ -0,0 +1,2764 @@
+/*
+ * pc2400m_drv_dm_bg.c
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         16      APPROVED 14-Aug-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_drv_dm_bg.c
+ *
+ * This file implements the abortable background transitions for the
+ * device manager.
+ *
+ */
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include "pc2400m_drv_com.h"
+#include "pc2400m_drv_dm_bg.h"
+#include "pc2400m_drv_dm.h"
+#include "pc2400m_drv_cd.h"
+#include "pc2400m_drv_chipif.h"
+
+/*****************************************************************************
+ * Global constants and macros
+ */
+
+/* internal states for transitions */
+#define PC2400M_DRV_DM_BG_INVALID                   0
+
+#define PC2400M_DRV_DM_BG_SCAN_NAP_SET_PARAMS_WAIT  1
+#define PC2400M_DRV_DM_BG_SCAN_NAP_SET_PARAMS       2
+#define PC2400M_DRV_DM_BG_SCAN_NAP_START_SCAN       3
+#define PC2400M_DRV_DM_BG_SCAN_NAP_WAITING_SCAN     4
+#define PC2400M_DRV_DM_BG_SCAN_NAP_CANCELED         6
+#define PC2400M_DRV_DM_BG_SCAN_NAP_COMPLETE_WAIT    7
+
+#define PC2400M_DRV_DM_BG_CONNECT_SET_PARAMS        8
+#define PC2400M_DRV_DM_BG_CONNECT_SCAN              9
+#define PC2400M_DRV_DM_BG_CONNECT_SCAN_WAITING      10
+#define PC2400M_DRV_DM_BG_CONNECT_CONNECT           11
+#define PC2400M_DRV_DM_BG_CONNECT_WAITING           12
+#define PC2400M_DRV_DM_BG_CONNECT_CANCELED          13
+#define PC2400M_DRV_DM_BG_CONNECT_COMPLETE_WAIT     14
+
+#define PC2400M_DRV_DM_BG_DISCONNECT_DISCONNECT     15
+#define PC2400M_DRV_DM_BG_DISCONNECT_COMPLETE_WAIT  16
+
+#define PC2400M_DRV_DM_BG_SCAN_NSP_SET_PARAMS       17
+#define PC2400M_DRV_DM_BG_SCAN_NSP_SCAN             18
+#define PC2400M_DRV_DM_BG_SCAN_NSP_SCAN_WAITING     19
+#define PC2400M_DRV_DM_BG_SCAN_NSP_CONNECT          20
+#define PC2400M_DRV_DM_BG_SCAN_NSP_CONNECTING       21
+#define PC2400M_DRV_DM_BG_SCAN_NSP_DISCONNECT       22
+#define PC2400M_DRV_DM_BG_SCAN_NSP_DISCONNECTING    23
+#define PC2400M_DRV_DM_BG_SCAN_NSP_CANCELED         24
+
+/*****************************************************************************
+ * Global data types
+ */
+
+/** scan parameters */
+struct pc2400m_drv_dm_bg_scan_nap {
+        u32 channel_plan_count;
+        u32 channel_plan_idx;
+        struct t_wihal_search_plan *search_plan;
+        void *client_data;
+};
+
+/** nsp scan parameters */
+struct pc2400m_drv_dm_bg_scan_nsp {
+        u32 napid;
+        enum t_wihal_nap_id_mask napid_mask;
+#define PC2400M_DRV_DM_BG_SCAN_NSP_NSP_LIST_DONE         0x01000000
+#define PC2400M_DRV_DM_BG_SCAN_NSP_NSP_CHANGE_COUNT_DONE 0x02000000
+        u32 siq_flags;
+        struct t_wihal_search_plan search_plan;
+        enum t_wihal_nap_and_nsp nap_and_nsp;
+        void *client_data;
+        u32 number_of_nsps;
+        boolean nsp_change_count_valid;
+        u32 nsp_change_count;
+#define PC2400M_DRV_DM_BG_SCAN_NSP_FLAGS_WAS_SCAN  0x01
+        u32 flags;
+        struct t_wihal_nsp_info *nsp_list;
+};
+
+/** connect parameters */
+struct pc2400m_drv_dm_bg_connect {
+        u32 napid;
+        enum t_wihal_nap_id_mask napid_mask;
+        u32 nspid;
+        boolean bslock;
+        t_wihal_bsid bsid;
+        boolean realm_req;
+#define PC2400M_DRV_DM_BG_CONNECT_FLAGS_WAS_SCAN  0x01
+        u32 flags;
+        u8 prev_state;
+        struct t_wihal_search_plan search_plan;
+};
+
+/** Enqueue a message for transsion. This macro enqueues a message for
+ *  transmission to the control dispatcher. The response will be handled in
+ *  the central dm response handling function.
+ *
+ *  @param _msg (wimax_osal_packet*) the message to enqueue
+ *  @param _flags (u32) the flags to pass to the control dispatcher enqueue
+ *                      function
+ *  @return None.
+ */
+#define DM_BG_MSG_ENQUEUE(_msg, _flags)  hnd->dm->cd->msg_enqueue( \
+        hnd->dm->cd, _msg, dm_bg_resp_handler, (void*)hnd, _flags);
+
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/* NAP scan handlers */
+static void dm_bg_ind_scan_result(
+        struct pc2400m_drv_cd_if*,
+        u32,
+        wimax_osal_packet*,
+        void*);
+static boolean dm_bg_scan_param_set(struct pc2400m_drv_dm_bg_if*);
+static void dm_bg_scan_command_send(struct pc2400m_drv_dm_bg_if*, u32);
+
+/* CONNECT handlers */
+static void dm_bg_connect_param_set(struct pc2400m_drv_dm_bg_if*);
+static void dm_bg_connect_command_send(struct pc2400m_drv_dm_bg_if*);
+static void dm_bg_connect_send_progress(struct pc2400m_drv_dm_bg_if*, u32);
+static u32 dm_bg_connect_get_flags(struct pc2400m_drv_dm_bg_if*);
+static void dm_bg_connect_set_flags(struct pc2400m_drv_dm_bg_if*, u32);
+static void dm_bg_ind_connect_sii_report(struct pc2400m_drv_cd_if*,
+                                         u32,
+                                         wimax_osal_packet*,
+                                         void*);
+static void dm_bg_ind_connect_bsinfo_report(
+        struct pc2400m_drv_cd_if*,
+        u32,
+        wimax_osal_packet*,
+        void*);
+
+/* DISCONNECT handlers */
+static void dm_bg_disconnect_command_send(struct pc2400m_drv_dm_bg_if*);
+
+/* NSP SCAN handlers */
+static void dm_bg_scan_nsp_param_set(struct pc2400m_drv_dm_bg_if*);
+static void dm_bg_scan_nsp_command_send(struct pc2400m_drv_dm_bg_if*);
+static void dm_bg_connect_send_network_status(
+        struct pc2400m_drv_dm_bg_if*, u8);
+static void dm_bg_ind_scan_nsp_bsinfo_report(
+        struct pc2400m_drv_cd_if*,
+        u32,
+        wimax_osal_packet*,
+        void*);
+static void dm_bg_ind_scan_nsp_sii_report(
+        struct pc2400m_drv_cd_if*,
+        u32,
+        wimax_osal_packet*,
+        void*);
+static u32 dm_bg_scan_nsp_get_flags(struct pc2400m_drv_dm_bg_if*);
+static void dm_bg_scan_nsp_set_flags(struct pc2400m_drv_dm_bg_if*, u32);
+
+
+/*****************************************************************************
+ * Local functions
+ */
+
+/** Get status from L3L4 header. This function extracts the status code from
+ *  an L3L4 message header.
+ *
+ *  @param msg packet containing the message header
+ *  @return the status code in native endianness
+ */
+static u16 dm_bg_header_status(wimax_osal_packet *msg)
+{
+        struct pc2400m_drv_chipif_ctrl_msg *header =
+                (struct pc2400m_drv_chipif_ctrl_msg*)
+                wimax_osal_packet_ptr(msg);
+
+        return WIMAX_OSAL_LE_TO_U16(header->status);
+}
+
+#ifdef PC2400M_DRV_DM_LOCK_SESSION_BANDWIDTH
+/** Check whether the bandwidth is allowed. This function checks whether
+ *  the provided channel plan has a bandwidth corresponding with the
+ *  bandwidth locked for the session. The first invocation will lock
+ *  the bandwidth.
+ *
+ *  @param hnd handle to the dm bg instance
+ *  @param sp search plan with the bandwidth to check
+ *  @return FALSE if the bandwidth is ok, TRUE if it is not allowed.
+ */
+static boolean dm_bg_bandwidth_check(
+        struct pc2400m_drv_dm_bg_if *hnd,
+        struct t_wihal_search_plan *sp)
+{
+
+        boolean ret = FALSE;
+
+        /* lock bandwidth for this session */
+        if (hnd->dm->locked_bandwidth ==  E_WIHAL_CHANNEL_BANDWIDTH_NA)
+                hnd->dm->locked_bandwidth = sp->channel_bandwidth;
+
+        /* enfore only the locked bandwidth is used */
+        if (hnd->dm->locked_bandwidth != sp->channel_bandwidth) {
+                wimax_osal_trace_u32(
+                        PC2400M_GROUP_DM_ERROR,
+                        PC2400M_TRACE_BG_MIXED_BANDWIDTH,
+                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                        sp->channel_bandwidth);
+
+                ret = TRUE;
+
+        }
+
+        return ret;
+
+}
+#endif /* PC2400M_DRV_DM_LOCK_SESSION_BANDWIDTH */
+
+/** Complete the running background transition. This function handles the
+ *  completion of a background transition by clearing resources and sending
+ *  possible notifications.
+ *
+ *  @param hnd the dm bg instance
+ *  @param TRUE to cause the DM bg handler to be called, FALSE to not call it
+ *  @return none
+ */
+static void dm_bg_complete(
+        struct pc2400m_drv_dm_bg_if *hnd,
+        boolean do_call_handler)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->dm->ctx);
+        enum pc2400m_drv_dm_bg_transitions id;
+
+        wimax_osal_trace_u32(
+                PC2400M_GROUP_DM_DEBUG,
+                PC2400M_TRACE_BG_OPERATION_COMPLETE,
+                WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                hnd->id);
+
+        switch ((s32)hnd->id) {
+        case PC2400M_DRV_DM_BG_SCAN_NAP:
+        {
+
+                struct pc2400m_drv_dm_bg_scan_nap *params =
+                        (struct pc2400m_drv_dm_bg_scan_nap*)hnd->params;
+
+                /* unregister scan reports */
+                hnd->dm->cd->register_indication(
+                        hnd->dm->cd, L3_L4_OPCODE_REPORT_SCAN_RESULT,
+                        NULL, NULL);
+
+                /* send the scan response to the client */
+                priv->send_search_nap_resp(
+                        priv->ctx,
+                        PC2400M_DRV_GET_WIHAL_ERROR(hnd->status),
+                        params->client_data);
+
+                /* free the memory used up by the parameters */
+                wimax_osal_mem_free((void**)&(params->search_plan));
+                wimax_osal_mem_free((void**)&(hnd->params));
+                break;
+        }
+
+        case PC2400M_DRV_DM_BG_SCAN_NSP:
+        {
+
+                struct pc2400m_drv_dm_bg_scan_nsp *params =
+                        (struct pc2400m_drv_dm_bg_scan_nsp*)hnd->params;
+                u32 i;
+
+                /* cancel the indication handling for SII and BSINFO reports */
+                hnd->dm->cd->register_indication(
+                        hnd->dm->cd, L3_L4_OPCODE_REPORT_SII, NULL, NULL);
+
+                hnd->dm->cd->register_indication(
+                        hnd->dm->cd, L3_L4_OPCODE_REPORT_BS_INFO, NULL, NULL);
+
+                /* send the result data to the client */
+                if (do_call_handler) {
+                        priv->send_search_nsp_resp(
+                                priv->ctx,
+                                PC2400M_DRV_GET_WIHAL_ERROR(hnd->status),
+                                params->napid,
+                                params->nsp_change_count,
+                                params->nap_and_nsp,
+                                params->number_of_nsps,
+                                params->nsp_list,
+                                params->client_data);
+                }
+
+                /* free the memory associated with the result */
+                if (params->nsp_list) {
+
+                        /* free the dynamic nsp list memory */
+                        for (i=0; i<params->number_of_nsps; i++)
+                                wimax_osal_mem_free(
+                                        (void**)
+                                        &(params->nsp_list[i].p_nsp_name));
+                        wimax_osal_mem_free((void**)&(params->nsp_list));
+
+                }
+
+                wimax_osal_mem_free((void**)&(hnd->params));
+                break;
+        }
+        case PC2400M_DRV_DM_BG_CONNECT:
+        {
+
+                /* cancel registration of the REALM report */
+                hnd->dm->cd->register_indication(
+                        hnd->dm->cd, L3_L4_OPCODE_REPORT_SII, NULL, NULL);
+                hnd->dm->cd->register_indication(
+                        hnd->dm->cd, L3_L4_OPCODE_REPORT_BS_INFO, NULL, NULL);
+
+                if (hnd->state != PC2400M_DRV_DM_BG_INVALID &&
+                    hnd->dm->state == PC2400M_DRV_DM_READY(hnd->dm) &&
+                    !do_call_handler) {
+
+                        /* if the chipset is still in ready state, and the
+                           transition is forcibly terminated from any other
+                           state than from initialize, then send a
+                           disconnected indication to the client as it will
+                           otherwise not be sent */
+                        priv->send_network_status_ind(
+                                priv->ctx,
+                                E_WIHAL_NETWORK_STATUS_DISCONNECTED,
+                                E_WIHAL_NETWORK_STATUS_ERR_CONNECTION_CREATION,
+                                NULL,
+                                NULL,
+                                0,
+                                NULL);
+                        hnd->dm->chipset.trans.network_status =
+                                E_WIHAL_NETWORK_STATUS_DISCONNECTED;
+
+                }
+
+                /* free the memory taken by the connect parameters */
+                wimax_osal_mem_free((void**)&(hnd->params));
+                break;
+        }
+
+        default:
+                /* case PC2400M_DRV_DM_BG_DISCONNECT: */
+                wimax_osal_assert(hnd->id == PC2400M_DRV_DM_BG_DISCONNECT);
+
+                /* if the disconnect is forcibly terminated, send a
+                   disconnect indication to the client */
+                priv->send_network_status_ind(
+                        priv->ctx,
+                        E_WIHAL_NETWORK_STATUS_DISCONNECTED,
+                        E_WIHAL_NETWORK_STATUS_ERR_NONE,
+                        NULL,
+                        NULL,
+                        0,
+                        NULL);
+                hnd->dm->chipset.trans.network_status =
+                        E_WIHAL_NETWORK_STATUS_DISCONNECTED;
+
+                break;
+
+        }
+
+        /* perform generic handling for the completion of a transition */
+        wimax_osal_assert(!hnd->params);
+
+
+        /* note that the handler will most likely destroy this bg
+           instance immediately, causing a recurring call to this function.
+           after this returns, the instance may no longer be accessed. also,
+           clear the type of the instance to avoid multiple handling. */
+        id = hnd->id;
+        hnd->id = PC2400M_DRV_DM_BG_NONE;
+        if (do_call_handler) {
+                hnd->dm->bg_complete(
+                        hnd->dm, hnd, id, hnd->status, hnd->completion_data);
+        }
+}
+
+
+/** Handle response to a chipset message. This function handles the response
+ *  message to a request sent to the chipset.
+ *
+ *  @param cdhnd the control dispatcher instance
+ *  @param msg osal packet containing the response message
+ *  @data custom cookie data carrying the dm bg instance
+ *  @return none
+ */
+static void dm_bg_resp_handler(
+        struct pc2400m_drv_cd_if* cdhnd,
+        wimax_osal_packet *msg,
+        void *data)
+{
+
+        struct pc2400m_drv_dm_bg_if *hnd = (struct pc2400m_drv_dm_bg_if*)data;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->dm->ctx);
+        u16 status = dm_bg_header_status(msg);
+
+        PC2400M_DRV_UNWARN(cdhnd);
+
+        switch ((s32)hnd->id) {
+        case PC2400M_DRV_DM_BG_SCAN_NAP:
+
+                switch(hnd->state) {
+                case PC2400M_DRV_DM_BG_SCAN_NAP_SET_PARAMS:
+
+                        if (L3L4_SUCCESS(status)) {
+                                /* send the scan command request to the
+                                   chipset */
+                                dm_bg_scan_command_send(
+                                        hnd, L3L4_SCAN_COMMAND_START);
+                                hnd->state =
+                                        PC2400M_DRV_DM_BG_SCAN_NAP_START_SCAN;
+                        } else {
+                                wimax_osal_trace_byte(
+                                        PC2400M_GROUP_DM_ERROR,
+                                        PC2400M_TRACE_CHANNEL_PLAN_SET_FAULT,
+                                        WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                                        status);
+                                hnd->status = -EGENERAL;
+                                dm_bg_complete(hnd, TRUE);
+                        }
+                        break;
+
+                case PC2400M_DRV_DM_BG_SCAN_NAP_START_SCAN:
+
+                        /* check starting status... */
+                        if (!L3L4_SUCCESS(status)) {
+                                hnd->status = -EGENERAL;
+                                dm_bg_complete(hnd, TRUE);
+                                wimax_osal_trace_byte(
+                                        PC2400M_GROUP_DM_ERROR,
+                                        PC2400M_TRACE_SCAN_START_FAILURE,
+                                        WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                                        status);
+                                break;
+                        } else {
+                                hnd->state =
+                                        PC2400M_DRV_DM_BG_SCAN_NAP_WAITING_SCAN;
+                        }
+
+                        /* ... then wait for scan status reports */
+                        break;
+
+                case PC2400M_DRV_DM_BG_SCAN_NAP_CANCELED:
+
+                        /* arriving here implies, that the last operation
+                           will end up in READY state, which means the
+                           transition can be cancelled right away. */
+                        hnd->state =
+                                PC2400M_DRV_DM_BG_SCAN_NAP_COMPLETE_WAIT;
+                        hnd->state_change(hnd, hnd->dm->state, 0, 0);
+                        break;
+
+                }
+                break;
+
+        case PC2400M_DRV_DM_BG_SCAN_NSP:
+
+                switch(hnd->state) {
+                case PC2400M_DRV_DM_BG_SCAN_NSP_SET_PARAMS:
+
+                        if (L3L4_SUCCESS(status)) {
+
+                                /* channel parameters configured, now
+                                   perform a scan */
+                                hnd->state =
+                                        PC2400M_DRV_DM_BG_SCAN_NSP_SCAN;
+                                dm_bg_scan_command_send(
+                                        hnd, L3L4_SCAN_COMMAND_START);
+
+                        } else {
+
+                                /* the discovery fails */
+                                hnd->status = -EGENERAL;
+                                dm_bg_complete(hnd, TRUE);
+
+                        }
+                        break;
+
+                case PC2400M_DRV_DM_BG_SCAN_NSP_SCAN:
+
+                        if (L3L4_SUCCESS(status)) {
+
+                                if (!hnd->canceled) {
+                                        /* start waiting for the state change
+                                           to SCAN state and back to READY
+                                           state */
+                                        hnd->state =
+                                                PC2400M_DRV_DM_BG_SCAN_NSP_SCAN_WAITING;
+                                        hnd->state_change(
+                                                hnd, hnd->dm->state, 0, 0);
+
+                                } else if (
+                                        (dm_bg_scan_nsp_get_flags(hnd) &&
+                                         PC2400M_DRV_DM_BG_SCAN_NSP_FLAGS_WAS_SCAN)) {
+
+                                        /* the transition will end up in
+                                           READY state and then complete */
+                                        hnd->state =
+                                                PC2400M_DRV_DM_BG_SCAN_NSP_CANCELED;
+                                        hnd->state_change(
+                                                hnd, hnd->dm->state, 0, 0);
+                                } else {
+
+                                        /* the transition will end up in
+                                           READY state and then complete. Dont
+                                           call the state change handler,
+                                           because the scan state has not yet
+                                           been visited, and the current READY
+                                           state will result in an early
+                                           completion. */
+                                        hnd->state =
+                                                PC2400M_DRV_DM_BG_SCAN_NSP_CANCELED;
+                                }
+
+                        } else {
+
+                                /* the discovery fails */
+                                hnd->status = -EGENERAL;
+                                dm_bg_complete(hnd, TRUE);
+
+                        }
+                        break;
+
+                case PC2400M_DRV_DM_BG_SCAN_NSP_CONNECT:
+
+                        if (L3L4_SUCCESS(status)) {
+
+                                /* the connect procedure is ongoing, now just
+                                   wait for the appropriate indications and
+                                   especially the sii reports with the NSP
+                                   info */
+                                hnd->state =
+                                        PC2400M_DRV_DM_BG_SCAN_NSP_CONNECTING;
+
+
+                                /* if the transition was cancelled in the
+                                   mean while, start disconnecting now */
+                                if (hnd->canceled) {
+                                        hnd->state =
+                                                PC2400M_DRV_DM_BG_SCAN_NSP_CANCELED;
+                                        dm_bg_disconnect_command_send(hnd);
+                                }
+
+                        } else {
+
+                                wimax_osal_trace_byte(
+                                        PC2400M_GROUP_DM_ERROR,
+                                        PC2400M_TRACE_CHANNEL_PLAN_SET_FAULT,
+                                        WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                                        status);
+
+                                /* the discovery fails */
+                                hnd->status = -EGENERAL;
+                                dm_bg_complete(hnd, TRUE);
+
+                        }
+                        break;
+
+                case PC2400M_DRV_DM_BG_SCAN_NSP_DISCONNECT:
+                case PC2400M_DRV_DM_BG_SCAN_NSP_CANCELED:
+
+                        /* the transition is complete, when the system
+                           reaches the READY state */
+                        hnd->state = PC2400M_DRV_DM_BG_SCAN_NSP_DISCONNECTING;
+                        hnd->state_change(hnd, hnd->dm->state, 0, 0);
+                        break;
+
+                }
+                break;
+
+        case PC2400M_DRV_DM_BG_CONNECT:
+
+                switch(hnd->state) {
+                case PC2400M_DRV_DM_BG_CONNECT_SET_PARAMS:
+
+                        if (L3L4_SUCCESS(status)) {
+
+                                /* send the scan request to the chipset */
+                                dm_bg_scan_command_send(
+                                        hnd, L3L4_SCAN_COMMAND_START);
+                                hnd->state =
+                                        PC2400M_DRV_DM_BG_CONNECT_SCAN;
+                        } else {
+
+                                /* send a disconnected notification to the
+                                   client */
+                                priv->send_network_status_ind(
+                                        priv->ctx,
+                                        E_WIHAL_NETWORK_STATUS_DISCONNECTED,
+                                        E_WIHAL_NETWORK_STATUS_ERR_CONNECTION_CREATION,
+                                        NULL,
+                                        NULL,
+                                        0,
+                                        NULL);
+                                hnd->dm->chipset.trans.network_status =
+                                        E_WIHAL_NETWORK_STATUS_DISCONNECTED;
+
+                                wimax_osal_trace_byte(
+                                        PC2400M_GROUP_DM_ERROR,
+                                        PC2400M_TRACE_CHANNEL_PLAN_SET_FAULT,
+                                        WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                                        status);
+
+                                /* end processing the transition */
+                                hnd->status = -EGENERAL;
+                                dm_bg_complete(hnd, TRUE);
+                        }
+                        break;
+
+                case PC2400M_DRV_DM_BG_CONNECT_SCAN:
+
+                        if (L3L4_SUCCESS(status)) {
+
+                                if (!hnd->canceled) {
+                                        /* start waiting for the state change
+                                           to SCAN state and back to READY
+                                           state */
+                                        hnd->state =
+                                                PC2400M_DRV_DM_BG_CONNECT_SCAN_WAITING;
+                                        hnd->state_change(
+                                                hnd, hnd->dm->state, 0, 0);
+
+                                } else if (
+                                        (dm_bg_connect_get_flags(hnd) &&
+                                         PC2400M_DRV_DM_BG_CONNECT_FLAGS_WAS_SCAN)) {
+
+                                        /* the transition will end up in
+                                           READY state and then complete */
+                                        hnd->state =
+                                                PC2400M_DRV_DM_BG_CONNECT_COMPLETE_WAIT;
+                                        hnd->state_change(
+                                                hnd, hnd->dm->state, 0, 0);
+                                } else {
+                                        /* the transition will end up in
+                                           READY state and then complete. Dont
+                                           call the state change handler,
+                                           because the scan state has not yet
+                                           been visited, and the current READY
+                                           state will result in an early
+                                           completion. */
+                                        hnd->state =
+                                                PC2400M_DRV_DM_BG_CONNECT_COMPLETE_WAIT;
+                                }
+
+                        } else {
+
+                                /* send a disconnected notification to the
+                                   client */
+                                priv->send_network_status_ind(
+                                        priv->ctx,
+                                        E_WIHAL_NETWORK_STATUS_DISCONNECTED,
+                                        E_WIHAL_NETWORK_STATUS_ERR_CONNECTION_CREATION,
+                                        NULL,
+                                        NULL,
+                                        0,
+                                        NULL);
+
+                                hnd->dm->chipset.trans.network_status =
+                                        E_WIHAL_NETWORK_STATUS_DISCONNECTED;
+
+                                wimax_osal_trace_byte(
+                                        PC2400M_GROUP_DM_ERROR,
+                                        PC2400M_TRACE_CHANNEL_PLAN_SCAN_FAULT,
+                                        WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                                        status);
+
+                                /* end processing the transition */
+                                hnd->status = -EGENERAL;
+                                dm_bg_complete(hnd, TRUE);
+                        }
+                        break;
+
+                case PC2400M_DRV_DM_BG_CONNECT_CONNECT:
+
+                        if (L3L4_SUCCESS(status)) {
+
+                                /* wait for the connection to complete ... */
+                                hnd->state =
+                                        PC2400M_DRV_DM_BG_CONNECT_WAITING;
+
+                                /* ... unless already complete */
+                                if (hnd->dm->state ==
+                                    PC2400M_DRV_DM_DATA_PATH_CONNECTED(
+                                            hnd->dm)) {
+                                        dm_bg_complete(hnd, TRUE);
+                                        break;
+                                }
+                        } else {
+
+                                /* stop processing the transition */
+                                hnd->status = -EGENERAL;
+
+                                wimax_osal_trace_byte(
+                                        PC2400M_GROUP_DM_ERROR,
+                                        PC2400M_TRACE_CONNECT_START_FAILURE,
+                                        WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                                        status);
+
+                                priv->send_network_status_ind(
+                                        priv->ctx,
+                                        E_WIHAL_NETWORK_STATUS_DISCONNECTED,
+                                        E_WIHAL_NETWORK_STATUS_ERR_CONNECTION_CREATION,
+                                        NULL,
+                                        NULL,
+                                        0,
+                                        NULL);
+                                hnd->dm->chipset.trans.network_status =
+                                        E_WIHAL_NETWORK_STATUS_DISCONNECTED;
+
+                                dm_bg_complete(hnd, TRUE);
+                                break;
+
+                        }
+
+                        /* if the transition has been cancelled, stop
+                           connecting immediately. */
+                        if (hnd->canceled == TRUE) {
+                                dm_bg_disconnect_command_send(hnd);
+                                hnd->state =
+                                        PC2400M_DRV_DM_BG_CONNECT_CANCELED;
+                        }
+                        break;
+
+                case PC2400M_DRV_DM_BG_CONNECT_CANCELED:
+
+                        /* arriving here implies, that the last operation
+                           will end up in READY state, which means the
+                           transition can be cancelled right away. */
+
+                        hnd->state = PC2400M_DRV_DM_BG_CONNECT_COMPLETE_WAIT;
+                        hnd->state_change(hnd, hnd->dm->state, 0, 0);
+                        break;
+
+                }
+                break;
+
+        default:
+                /* case PC2400M_DRV_DM_BG_DISCONNECT: */
+                wimax_osal_assert(hnd->id == PC2400M_DRV_DM_BG_DISCONNECT);
+
+                wimax_osal_assert(
+                        hnd->state == PC2400M_DRV_DM_BG_DISCONNECT_DISCONNECT);
+
+                if (!L3L4_SUCCESS(status)) {
+                        wimax_osal_trace_byte(
+                                PC2400M_GROUP_DM_ERROR,
+                                PC2400M_TRACE_DISCONNECT_FAULT_CODE,
+                                WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                                status);
+
+                        /* although disconnect should never fail,
+                           we terminate the transition here to avoid
+                           a deadlock for the transition engine. */
+                        hnd->status = -EGENERAL;
+                        dm_bg_complete(hnd, TRUE);
+                        break;
+                }
+
+                if (hnd->dm->state == PC2400M_DRV_DM_READY(hnd->dm)) {
+                        /* disconnect is complete when after the
+                           response the system state has changed to
+                           READY */
+                        dm_bg_complete(hnd, TRUE);
+                } else {
+                        hnd->state =
+                                PC2400M_DRV_DM_BG_DISCONNECT_COMPLETE_WAIT;
+                }
+                break;
+        }
+
+        /* remove the message */
+        wimax_osal_packet_free(&msg);
+
+}
+
+/** Notify of a system state change. This function is called to inform the
+ *  background transition of a system state change.
+ *
+ *  @param hnd the dm bg instance
+ *  @param state the state the system changed to
+ *  @param reason the reason code for the state change
+ *  @param conn_progress current connection progress
+ *  @return none
+ */
+static void pc2400m_drv_dm_bg_state_change(
+        struct pc2400m_drv_dm_bg_if *hnd,
+        u8 state,
+        u8 reason,
+        u32 conn_progress)
+{
+
+        PC2400M_DRV_UNWARN(reason);
+
+        switch((s32)hnd->id) {
+        case PC2400M_DRV_DM_BG_SCAN_NAP:
+
+                switch (hnd->state) {
+                case PC2400M_DRV_DM_BG_SCAN_NAP_SET_PARAMS_WAIT:
+
+                        /* wait specificly for the READY state */
+                        if (state != PC2400M_DRV_DM_READY(hnd->dm))
+                                break;
+
+                        if (!dm_bg_scan_param_set(hnd)) {
+                                /* scanning is ongoing, and still more
+                                   channel plans remaing, keep on
+                                   scanning */
+                                hnd->state =
+                                        PC2400M_DRV_DM_BG_SCAN_NAP_SET_PARAMS;
+                        } else {
+                                /* we have exhausted our list of
+                                   channel plans */
+                                dm_bg_complete(hnd, TRUE);
+                        }
+                        break;
+
+                case PC2400M_DRV_DM_BG_SCAN_NAP_WAITING_SCAN:
+
+                        /* if the transition has been cancelled, stop
+                           scanning immediately. before cancelling, the
+                           change to the SCAN state is required, because
+                           otherwise it is next to impossible to determine
+                           whether such a state change will occur at all or
+                           not. */
+                        if (hnd->state == PC2400M_DRV_DM_SCAN(hnd->dm) &&
+                            hnd->canceled == TRUE) {
+
+                                dm_bg_scan_command_send(
+                                        hnd, L3L4_SCAN_COMMAND_STOP);
+                                hnd->state =
+                                        PC2400M_DRV_DM_BG_SCAN_NAP_CANCELED;
+
+                        }
+                        break;
+
+                case PC2400M_DRV_DM_BG_SCAN_NAP_COMPLETE_WAIT:
+                        if (state == PC2400M_DRV_DM_READY(hnd->dm))
+                                dm_bg_complete(hnd, TRUE);
+                        break;
+                }
+                break;
+
+        case PC2400M_DRV_DM_BG_SCAN_NSP:
+        {
+
+                struct pc2400m_drv_dm_bg_scan_nsp *scan_params =
+                        (struct pc2400m_drv_dm_bg_scan_nsp*)hnd->params;
+
+                if (hnd->dm->state == PC2400M_DRV_DM_SCAN(hnd->dm)) {
+
+                        /* set a flag indicating, that the scan state
+                           has been visited */
+                        dm_bg_scan_nsp_set_flags(
+                                hnd,
+                                dm_bg_scan_nsp_get_flags(hnd) |
+                                PC2400M_DRV_DM_BG_SCAN_NSP_FLAGS_WAS_SCAN);
+
+                }
+
+                switch (hnd->state) {
+
+                case PC2400M_DRV_DM_BG_SCAN_NSP_SCAN_WAITING:
+
+                        /* the initial scanning state will be complete once
+                           in READY state after a visit to the SCAN state. */
+                        if (state == PC2400M_DRV_DM_READY(hnd->dm) &&
+                            (dm_bg_scan_nsp_get_flags(hnd) &&
+                             PC2400M_DRV_DM_BG_SCAN_NSP_FLAGS_WAS_SCAN)) {
+
+                                        /* proceed by starting the connect
+                                           sequence */
+                                        dm_bg_scan_nsp_command_send(hnd);
+                                        hnd->state =
+                                                PC2400M_DRV_DM_BG_SCAN_NSP_CONNECT;
+                        }
+                        break;
+
+                case PC2400M_DRV_DM_BG_SCAN_NSP_CONNECTING:
+
+                        /* determine based on the state change reason whether
+                           the request has failed or not - also proceding too
+                           far in the connection is considered an error */
+                        if (reason != L3L4_REPORT_STATE_REASON_NORMAL) {
+
+                                /* set an error code and start disconnection */
+                                hnd->status = -EGENERAL;
+                                hnd->state =
+                                        PC2400M_DRV_DM_BG_SCAN_NSP_DISCONNECTING;
+                                hnd->state_change(hnd, hnd->dm->state, 0, 0);
+                                break;
+
+                        } else if (state ==
+                            PC2400M_DRV_DM_DATA_PATH_CONNECTED(hnd->dm)) {
+
+                                /* set an error code and start disconnection */
+                                hnd->status = -EGENERAL;
+                                hnd->state =
+                                        PC2400M_DRV_DM_BG_SCAN_NSP_DISCONNECTING;
+                                dm_bg_disconnect_command_send(hnd);
+                                hnd->state_change(hnd, hnd->dm->state, 0, 0);
+                                break;
+                        }
+
+                        /* once all information has been received, send
+                           a disconnect to start the disconnecting phase */
+                        if ((scan_params->siq_flags &
+                             PC2400M_DRV_DM_BG_SCAN_NSP_NSP_LIST_DONE) &&
+                            (scan_params->siq_flags &
+                             PC2400M_DRV_DM_BG_SCAN_NSP_NSP_CHANGE_COUNT_DONE))
+                        {
+
+                                /* start disconnection to complete the NSP
+                                   scan */
+                                hnd->state =
+                                        PC2400M_DRV_DM_BG_SCAN_NSP_DISCONNECT;
+                                dm_bg_disconnect_command_send(hnd);
+
+                        }
+                        break;
+
+                case PC2400M_DRV_DM_BG_SCAN_NSP_DISCONNECTING:
+                case PC2400M_DRV_DM_BG_SCAN_NSP_CANCELED:
+
+                        /* the transition is complete upon returning to the
+                           READY state */
+                        if (state == PC2400M_DRV_DM_READY(hnd->dm)) {
+                                dm_bg_complete(hnd, TRUE);
+                        }
+                        break;
+
+                }
+                break;
+        }
+
+        case PC2400M_DRV_DM_BG_CONNECT:
+
+                if (hnd->dm->state == PC2400M_DRV_DM_SCAN(hnd->dm)) {
+
+                        /* set a flag indicating, that the scan state
+                           has been visited */
+                        dm_bg_connect_set_flags(
+                                hnd,
+                                dm_bg_connect_get_flags(hnd) |
+                                PC2400M_DRV_DM_BG_CONNECT_FLAGS_WAS_SCAN);
+
+                        /* register this state change so that if cancelled,
+                           change to the READY state will show up as a state
+                           change and cause a DISCONNECTED indication to be
+                           sent to the client */
+                        dm_bg_connect_send_network_status(hnd, state);
+
+                }
+
+                switch (hnd->state) {
+
+                case PC2400M_DRV_DM_BG_CONNECT_SCAN:
+                        /* this case branch is here to prevent going into
+                           the default branch and hence cause a network
+                           status indication to be sent due to the READY
+                           state change while scan is ongoing */
+                        break;
+
+                case PC2400M_DRV_DM_BG_CONNECT_SCAN_WAITING:
+
+                        /* the initial scanning state will be complete once
+                           in READY state after a visit to the SCAN state. */
+                        if (state == PC2400M_DRV_DM_READY(hnd->dm) &&
+                            (dm_bg_connect_get_flags(hnd) &&
+                             PC2400M_DRV_DM_BG_CONNECT_FLAGS_WAS_SCAN)) {
+
+                                        /* proceed by starting the connect
+                                           sequence */
+                                        dm_bg_connect_command_send(hnd);
+                                        hnd->state =
+                                                PC2400M_DRV_DM_BG_CONNECT_CONNECT;
+                        }
+                        break;
+
+                case PC2400M_DRV_DM_BG_CONNECT_WAITING:
+
+                        /* send network status indications reflecting state
+                           changes to the client during the entire lifetime of
+                           the connect transition */
+                        dm_bg_connect_send_network_status(hnd, state);
+
+                        /* during the connecting state, send detailed
+                           connection progress info to the client. */
+                        if (state == PC2400M_DRV_DM_CONNECTING(hnd->dm)) {
+                                dm_bg_connect_send_progress(
+                                        hnd, conn_progress);
+                        }
+
+                        /* the state change related connection state changes
+                           are handled in the main DM state change handler */
+                        if (state == PC2400M_DRV_DM_DATA_PATH_CONNECTED(
+                                    hnd->dm) ||
+                            state == PC2400M_DRV_DM_READY(hnd->dm))
+                                dm_bg_complete(hnd, TRUE);
+                        break;
+
+                case PC2400M_DRV_DM_BG_CONNECT_COMPLETE_WAIT:
+                case PC2400M_DRV_DM_BG_CONNECT_CANCELED:
+
+                        /* send network status indications reflecting state
+                           changes to the client during the entire lifetime of
+                           the connect transition */
+                        dm_bg_connect_send_network_status(hnd, state);
+
+                        /* waiting for returning to READY state after
+                           canceled connection */
+                        if (state == PC2400M_DRV_DM_READY(hnd->dm)) {
+                                dm_bg_complete(hnd, TRUE);
+                        }
+                        break;
+
+                default:
+
+                        /* send network status indications reflecting state
+                           changes to the client during the entire lifetime of
+                           the connect transition */
+                        dm_bg_connect_send_network_status(hnd, state);
+                        break;
+
+
+                }
+                break;
+
+        default:
+                /* case PC2400M_DRV_DM_BG_DISCONNECT: */
+                wimax_osal_assert(hnd->id == PC2400M_DRV_DM_BG_DISCONNECT);
+
+                /* the disconnect is complete when the system ends up
+                   in the READY state */
+                if (hnd->state ==
+                    PC2400M_DRV_DM_BG_DISCONNECT_COMPLETE_WAIT &&
+                    state == PC2400M_DRV_DM_READY(hnd->dm)) {
+                        dm_bg_complete(hnd, TRUE);
+                }
+                break;
+
+        }
+}
+
+
+/** Bring instance back to initial state. Bring the instance back to initial
+ *  state freeing any resources relating to state changes within the instance,
+ *  but not the instance itself.
+ *
+ *  @param hnd the dm bg instance
+ *  @return none
+ */
+static void pc2400m_drv_dm_bg_reset(struct pc2400m_drv_dm_bg_if *hnd)
+{
+
+        switch((s32)hnd->id) {
+        case PC2400M_DRV_DM_BG_NONE:
+                break;
+        case PC2400M_DRV_DM_BG_SCAN_NAP:
+        case PC2400M_DRV_DM_BG_SCAN_NSP:
+        case PC2400M_DRV_DM_BG_CONNECT:
+                /* finalize the currently executing transition,
+                   not indicating completion */
+                dm_bg_complete(hnd, FALSE);
+                break;
+
+        default:
+                /* case PC2400M_DRV_DM_BG_DISCONNECT: */
+                wimax_osal_assert(hnd->id == PC2400M_DRV_DM_BG_DISCONNECT);
+                /* finalize the currently executing transition,
+                   not indicating completion */
+                dm_bg_complete(hnd, FALSE);
+                break;
+        }
+
+        /* above, the FALSE parameter certifies, that this instance has
+           not disappeared from under our feet. */
+        hnd->id = PC2400M_DRV_DM_BG_NONE;
+
+}
+
+/** Free resources taken by the instance. Free all resources taken by the
+ *  specified instance. the instance is no longer usable after this operation.
+ *  any ongoing transition will be simply dropped as is.
+ *
+ *  @param hnd the dm bg instance
+ *  @return none
+ */
+static void pc2400m_drv_dm_bg_cleanup(struct pc2400m_drv_dm_bg_if *hnd)
+{
+
+        /* clean up transition memory */
+        hnd->reset(hnd);
+
+        /* clean up the instance */
+        wimax_osal_mem_free((void**)&hnd);
+
+}
+
+/** Start executing a background transition.
+ *
+ *  @param hnd the dm bg instance
+ *  @param completion_data cookie data to be passed to the completion function
+ *  @param id identifier of the background transition to execute
+ *  @param transaction_params parameters for the specific background transition
+ *  @return TRUE if the transition was successfully started, -EGENERAL if
+ *          transition was not started.
+ */
+static s32 pc2400m_drv_dm_bg_initialize(
+        struct pc2400m_drv_dm_bg_if *hnd,
+        void *completion_data,
+        enum pc2400m_drv_dm_bg_transitions id,
+        void *transaction_params)
+{
+
+        u32 i;
+        s32 ret = ESUCCESS;
+
+        /* fill in transition basic information */
+        hnd->id = id;
+        hnd->canceled = FALSE;
+        hnd->status = ESUCCESS;
+        hnd->completion_data = completion_data;
+
+        wimax_osal_trace_u32(
+                PC2400M_GROUP_DM_DEBUG,
+                PC2400M_TRACE_BG_OPERATION_STARTED,
+                WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                hnd->id);
+
+        /* start executing a new background transition */
+        switch ((s32)id) {
+        case PC2400M_DRV_DM_BG_SCAN_NAP:
+        {
+
+                struct pc2400m_drv_dm_bg_scan_nap_params *params =
+                        (struct pc2400m_drv_dm_bg_scan_nap_params*)
+                        transaction_params;
+                struct pc2400m_drv_dm_bg_scan_nap *scan_params;
+
+                /* prepare scan information structure */
+                scan_params = (struct pc2400m_drv_dm_bg_scan_nap*)
+                        wimax_osal_mem_alloc(
+                                sizeof(struct pc2400m_drv_dm_bg_scan_nap));
+
+                /* take hold of the client data */
+                scan_params->client_data = params->client_data;
+
+                scan_params->channel_plan_idx = 0;
+                scan_params->channel_plan_count =
+                        params->req.search_plan_count;
+                scan_params->search_plan = params->req.p_search_plan;
+
+                /* prepare local instance for the operation */
+                hnd->params = (void*)scan_params;
+                hnd->state = PC2400M_DRV_DM_BG_SCAN_NAP_SET_PARAMS;
+
+                /* take ownership of the list pointer */
+                params->req.p_search_plan = NULL;
+
+                /* register scan status reports */
+                hnd->dm->cd->register_indication(
+                        hnd->dm->cd, L3_L4_OPCODE_REPORT_SCAN_RESULT,
+                        dm_bg_ind_scan_result, (void*)hnd);
+
+                /* validate the channel plans */
+                for (i=0; i<scan_params->channel_plan_count; i++) {
+
+                        /* check for legal values */
+                        if (!PC2400M_DRV_IS_VALID_SEARCH_PLAN(
+                                    priv, &(scan_params->search_plan[i]))
+#ifdef PC2400M_DRV_DM_LOCK_SESSION_BANDWIDTH
+                            || dm_bg_bandwidth_check(
+                                    hnd, &(scan_params->search_plan[i]))
+#endif /* PC2400M_DRV_DM_LOCK_SESSION_BANDWIDTH */
+                                ) {
+                                ret = -EVALUE;
+                                hnd->status = -EVALUE;
+                                break;
+                        }
+
+                }
+
+                /* start the operation by sending a params set request */
+                if (ret || dm_bg_scan_param_set(hnd)) {
+                        /* if at this point there are no parameters to
+                           set, none were specified */
+                        ret = -EVALUE;
+                        /* note that the memory for scan_params is free'd
+                           in dm_bg_complete. */
+                }
+
+                break;
+        }
+
+        case PC2400M_DRV_DM_BG_SCAN_NSP:
+        {
+
+                struct pc2400m_private *priv =
+                        wimax_osal_ctx_priv_get(hnd->dm->ctx);
+                struct pc2400m_drv_dm_bg_scan_nsp_params *params =
+                        (struct pc2400m_drv_dm_bg_scan_nsp_params*)
+                        transaction_params;
+                struct pc2400m_drv_dm_bg_scan_nsp *scan_params;
+
+                wimax_osal_assert(params);
+
+                /* prepare connect information structure */
+                scan_params = (struct pc2400m_drv_dm_bg_scan_nsp*)
+                        wimax_osal_mem_alloc(
+                                sizeof(struct pc2400m_drv_dm_bg_scan_nsp));
+                wimax_osal_mem_set(scan_params, 0x00,
+                                   sizeof(struct pc2400m_drv_dm_bg_scan_nsp));
+
+                scan_params->napid = params->req.nap_id;
+                scan_params->napid_mask = params->req.nap_id_mask;
+                wimax_osal_mem_cpy(
+                        &scan_params->search_plan,
+                        &params->req.channel,
+                        sizeof(struct t_wihal_search_plan));
+                scan_params->client_data = params->client_data;
+                scan_params->number_of_nsps = 0;
+                scan_params->nap_and_nsp = E_WIHAL_NAP_AND_NSP_NA;
+                scan_params->nsp_list = NULL;
+                scan_params->nsp_change_count = params->req.nsp_change_count;
+                scan_params->nsp_change_count_valid =
+                        params->req.nsp_change_count_valid;
+                hnd->params = (void*)scan_params;
+
+                /* specify level of required NSP info */
+                switch (params->req.search_nsp_info) {
+                case E_WIHAL_SEARCH_NSP_INFO_REQ_NONE:
+                        scan_params->siq_flags = 0;
+                        break;
+                case E_WIHAL_SEARCH_NSP_INFO_REQ_NSP_LIST:
+                        scan_params->siq_flags =
+                                L3L4_CONNECT_FLAGS_SIQ_REQUEST_NSP_ID_LIST;
+                        break;
+                case E_WIHAL_SEARCH_NSP_INFO_REQ_NSP_LIST_AND_NAMES:
+                        scan_params->siq_flags =
+                                L3L4_CONNECT_FLAGS_SIQ_REQUEST_NSP_ID_LIST |
+                                L3L4_CONNECT_FLAGS_SIQ_REQUEST_NSP_VERBOSE_NAME_LIST;
+                        break;
+                }
+
+                /* check that the parameter values are acceptable */
+                if ((!PC2400M_DRV_IS_VALID_NAP_ID_MASK(
+                             priv, params->req.nap_id_mask)) ||
+                    (!PC2400M_DRV_IS_VALID_SEARCH_NSP_INFO(
+                            priv, params->req.search_nsp_info)) ||
+                    (!PC2400M_DRV_IS_VALID_SEARCH_PLAN(
+                            priv, &params->req.channel))
+#ifdef PC2400M_DRV_DM_LOCK_SESSION_BANDWIDTH
+                    || dm_bg_bandwidth_check(hnd, &(params->req.channel))
+#endif /* PC2400M_DRV_DM_LOCK_SESSION_BANDWIDTH */
+                        ) {
+
+                        ret = -EVALUE;
+
+                        priv->send_search_nsp_resp(
+                                priv->ctx,
+                                PC2400M_DRV_GET_WIHAL_ERROR(ret),
+                                scan_params->napid,
+                                scan_params->nsp_change_count,
+                                scan_params->nap_and_nsp,
+                                scan_params->number_of_nsps,
+                                scan_params->nsp_list,
+                                scan_params->client_data);
+
+                        break;
+                }
+
+                /* during the course of this scan, we expect to get indications
+                   containing NSP information => register to them */
+                hnd->dm->cd->register_indication(
+                        hnd->dm->cd, L3_L4_OPCODE_REPORT_SII,
+                        dm_bg_ind_scan_nsp_sii_report, (void*)hnd);
+
+                hnd->dm->cd->register_indication(
+                        hnd->dm->cd, L3_L4_OPCODE_REPORT_BS_INFO,
+                        dm_bg_ind_scan_nsp_bsinfo_report, (void*)hnd);
+
+                hnd->state = PC2400M_DRV_DM_BG_SCAN_NSP_SET_PARAMS;
+                dm_bg_scan_nsp_param_set(hnd);
+
+                break;
+        }
+        case PC2400M_DRV_DM_BG_CONNECT:
+        {
+
+                struct pc2400m_drv_dm_bg_connect_params *params =
+                        (struct pc2400m_drv_dm_bg_connect_params*)
+                        transaction_params;
+                struct pc2400m_drv_dm_bg_connect *connect_params;
+
+                wimax_osal_assert(params);
+
+                /* check that the parameter values are acceptable */
+                if ((!PC2400M_DRV_IS_VALID_NAP_ID_MASK(
+                             priv, params->req.nap_id_mask)) ||
+                    (!PC2400M_DRV_IS_VALID_SEARCH_PLAN(
+                            priv, &params->req.channel))) {
+
+                        ret = -EVALUE;
+                        break;
+
+                }
+
+#ifdef PC2400M_DRV_DM_LOCK_SESSION_BANDWIDTH
+                /* check that the bandwidth is allowed */
+                if (dm_bg_bandwidth_check(hnd, &(params->req.channel))) {
+                        ret = -EVALUE;
+                        break;
+                }
+#endif /* PC2400M_DRV_DM_LOCK_SESSION_BANDWIDTH */
+
+                /* clear the realm information */
+                wimax_osal_mem_free(
+                        (void**)&(hnd->dm->chipset.link.nsp_realm));
+                hnd->dm->chipset.link.nsp_realm_len = 0;
+
+                /* use the specified channel as preliminary info in the
+                   status indications */
+                wimax_osal_mem_cpy(
+                        &hnd->dm->chipset.link.channel_plan,
+                        &params->req.channel,
+                        sizeof(struct t_wihal_search_plan));
+                hnd->dm->chipset.link.channel_set |=
+                        PC2400M_DRV_DM_CHIPSET_CHANNEL_SET_CHANNEL_INFO;
+
+
+                /* prepare connect information structure */
+                connect_params = (struct pc2400m_drv_dm_bg_connect*)
+                        wimax_osal_mem_alloc(
+                                sizeof(struct pc2400m_drv_dm_bg_connect));
+                connect_params->napid = params->req.nap_id;
+                connect_params->napid_mask = params->req.nap_id_mask;
+                wimax_osal_mem_cpy(
+                        &connect_params->search_plan,
+                        &params->req.channel,
+                        sizeof(struct t_wihal_search_plan));
+                connect_params->nspid = params->req.nsp_id;
+                connect_params->realm_req = params->req.realm_req;
+                connect_params->prev_state = PC2400M_DRV_DM_READY(hnd->dm);
+                connect_params->flags = 0;
+
+                if (hnd->dm->chipset.config.handover_scheme ==
+                    E_WIHAL_HANDOVER_SCHEME_BS_LOCK) {
+                        connect_params->bslock = TRUE;
+                        wimax_osal_mem_cpy(
+                                connect_params->bsid,
+                                hnd->dm->chipset.config.bsid,
+                                WIHAL_BSID_LENGTH);
+                } else {
+                        connect_params->bslock = FALSE;
+                }
+
+                hnd->params = (void*)connect_params;
+
+                /* clear bsid information from the chipset cache */
+                hnd->dm->chipset.link.channel_set = 0;
+
+                /* start the connection procedure by setting the appropriate
+                   channel plans to the device */
+                hnd->dm->cd->register_indication(
+                        hnd->dm->cd, L3_L4_OPCODE_REPORT_BS_INFO,
+                        dm_bg_ind_connect_bsinfo_report, (void*)hnd);
+
+                dm_bg_connect_param_set(hnd);
+                hnd->state = PC2400M_DRV_DM_BG_CONNECT_SET_PARAMS;
+                break;
+        }
+        default:
+                /* case PC2400M_DRV_DM_BG_DISCONNECT: */
+                wimax_osal_assert(hnd->id == PC2400M_DRV_DM_BG_DISCONNECT);
+
+                /* clear bsid information from the chipset cache */
+                hnd->dm->chipset.link.channel_set = 0;
+
+                /* start disconnecting */
+                hnd->state =  PC2400M_DRV_DM_BG_DISCONNECT_DISCONNECT;
+                dm_bg_disconnect_command_send(hnd);
+                break;
+        };
+
+        return ret;
+
+}
+
+/** Cancel an ongoing background transition. The transition will not stop
+ *  immediately, instead will find the shortest path back to its original
+ *  state. The transition will then complete via the normal mechanisms.
+ *
+ *  @param hnd the dm bg instance
+ *  @return none
+ */
+static void pc2400m_drv_dm_bg_cancel(struct pc2400m_drv_dm_bg_if *hnd)
+{
+
+        wimax_osal_assert(!hnd->canceled);
+
+        wimax_osal_trace_u32(
+                PC2400M_GROUP_DM_DEBUG,
+                PC2400M_TRACE_BG_OPERATION_CANCELED,
+                WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                hnd->id);
+
+
+        switch ((s32)hnd->id) {
+        case PC2400M_DRV_DM_BG_SCAN_NAP:
+
+                /* abort the scan procedure bringing the chipset back
+                   to the READY state */
+
+                /* if waiting for scaning to proceed, STOPping the scan will
+                   lead back to the READY state */
+                if (hnd->state == PC2400M_DRV_DM_BG_SCAN_NAP_WAITING_SCAN) {
+                        dm_bg_scan_command_send(hnd, L3L4_SCAN_COMMAND_STOP);
+                }
+
+                /* unless currently requesting for start scan, the next
+                   response will result in the READY state */
+                if (hnd->state != PC2400M_DRV_DM_BG_SCAN_NAP_START_SCAN) {
+                        hnd->state = PC2400M_DRV_DM_BG_SCAN_NAP_CANCELED;
+                }
+                hnd->canceled = TRUE;
+                break;
+
+        case PC2400M_DRV_DM_BG_SCAN_NSP:
+
+                /* abort the NSP discovery procedure bringing the chipset back
+                   to the READY state */
+
+                /* if a connect is ongoing to discover NSP information,
+                   disconnecting will lead back to the READY state */
+                if (hnd->state == PC2400M_DRV_DM_BG_SCAN_NSP_CONNECTING) {
+                        hnd->state = PC2400M_DRV_DM_BG_SCAN_NSP_CANCELED;
+                        dm_bg_disconnect_command_send(hnd);
+                }
+
+                /* unless currently requesting for start scan, the next
+                   response will result in the READY state */
+                if (hnd->state != PC2400M_DRV_DM_BG_SCAN_NSP_CONNECT &&
+                    hnd->state != PC2400M_DRV_DM_BG_SCAN_NSP_SCAN) {
+                        hnd->state = PC2400M_DRV_DM_BG_SCAN_NSP_CANCELED;
+                }
+                hnd->canceled = TRUE;
+                break;
+
+        case PC2400M_DRV_DM_BG_CONNECT:
+
+                /* abort the connect procedure bringing the chipset back
+                   to the READY state */
+
+                /* if waiting for connection to proceed, a disconnect request
+                   will lead back to the READY state */
+                if (hnd->state == PC2400M_DRV_DM_BG_CONNECT_WAITING) {
+                        dm_bg_disconnect_command_send(hnd);
+                        hnd->state = PC2400M_DRV_DM_BG_CONNECT_CANCELED;
+                }
+
+                /* unless currently requesting for connecting or scanning,
+                   the next response will result in the READY state */
+                if (hnd->state != PC2400M_DRV_DM_BG_CONNECT_CONNECT &&
+                    hnd->state != PC2400M_DRV_DM_BG_CONNECT_SCAN) {
+                        hnd->state = PC2400M_DRV_DM_BG_CONNECT_CANCELED;
+                }
+                hnd->canceled = TRUE;
+                break;
+
+        default:
+                /* case PC2400M_DRV_DM_BG_DISCONNECT: */
+                wimax_osal_assert(hnd->id == PC2400M_DRV_DM_BG_DISCONNECT);
+
+                /* the disconnect cannot be canceled - thus mark the item
+                   as being canceled and proceed with disconnect normally */
+
+                hnd->canceled = TRUE;
+                break;
+
+        }
+
+        return;
+
+}
+
+
+/* NAP SCAN handlers */
+
+/** Send scan command to the chipset. This function sends a command to start
+ *  scanning to the chipset with appropriate TLV's.
+ *
+ *  @param hnd the dm bg instance
+ *  @param either  L3L4_SCAN_COMMAND_STOP or  L3L4_SCAN_COMMAND_START
+ *  @return none
+ */
+static void dm_bg_scan_command_send(
+        struct pc2400m_drv_dm_bg_if *hnd,
+        u32 command)
+{
+
+        struct L3L4_TLV_STR_SCAN_COMMAND *scan_cmd;
+        wimax_osal_packet *msg;
+        u8 *ptr;
+
+        wimax_osal_trace(
+                PC2400M_GROUP_DM_DEBUG,
+                PC2400M_TRACE_BG_SCAN_START,
+                WIMAX_OSAL_TRACE_PRIORITY_DEBUG);
+
+        msg = wimax_osal_packet_alloc
+                (PC2400M_DRV_CHIPIF_CTRL_MSG_LEN +
+                 L3L4_TLV_SIZE_SCAN_COMMAND);
+
+        /* create and send a request to stop scanning */
+        ptr = wimax_osal_packet_put(
+                msg, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+        hnd->dm->setup_header(
+                hnd->dm, ptr, L4_L3_OPCODE_CMD_SCAN,
+                L3L4_TLV_SIZE_SCAN_COMMAND);
+
+        scan_cmd = (struct L3L4_TLV_STR_SCAN_COMMAND*)
+                wimax_osal_packet_put(msg, L3L4_TLV_SIZE_SCAN_COMMAND);
+
+        scan_cmd->tlv.type = WIMAX_OSAL_U16_TO_LE(
+                L3L4_TLV_TYPE_SCAN_COMMAND);
+        scan_cmd->tlv.length = WIMAX_OSAL_U16_TO_LE(
+                L3L4_TLV_SIZE_SCAN_COMMAND - L3L4_TLV_HDR_LEN);
+        scan_cmd->do_scan_command = WIMAX_OSAL_U32_TO_LE(command);
+
+        DM_BG_MSG_ENQUEUE(msg, PC2400M_CD_FLAG_NONE);
+
+}
+
+/** Send scan parameter command to the chipset. This function sends a command
+ *  setting the to be scanned list of channel plans to the chipset.
+ *
+ *  @param hnd the dm bg instance
+ *  @return none
+ */
+static boolean dm_bg_scan_param_set(struct pc2400m_drv_dm_bg_if *hnd)
+{
+
+        struct pc2400m_drv_dm_bg_scan_nap *scan_params =
+                (struct pc2400m_drv_dm_bg_scan_nap*)hnd->params;
+        struct L3L4_TLV_STR_CHANNEL_INFO *chinfo;
+        struct L3L4_TLV_STR_SCAN_POLICY *scanpol;
+        wimax_osal_packet *msg;
+        boolean ret = FALSE;
+        s32 cnt, size;
+        u32 i;
+        u8 *ptr;
+
+        wimax_osal_assert(scan_params != NULL);
+
+        /* calculate number of channel plans */
+        cnt = scan_params->channel_plan_count -
+                scan_params->channel_plan_idx;
+        wimax_osal_trace_u32(
+                PC2400M_GROUP_DM_DEBUG,
+                PC2400M_TRACE_BG_SCAN_PARAMS,
+                WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                cnt);
+
+        /* if no more channel plans are left, the search is over */
+        if (cnt  == 0) {
+                ret = TRUE;
+                goto out;
+        }
+
+        /* determine number of channels to group */
+        if (cnt > PC2400M_DRV_DM_SCAN_CHANNEL_GROUP_SIZE)
+                cnt = PC2400M_DRV_DM_SCAN_CHANNEL_GROUP_SIZE;
+
+        /* construct search parameter message */
+        size = PC2400M_DRV_CHIPIF_CTRL_MSG_LEN +
+                L3L4_TLV_SIZE_SCAN_POLICY +
+                L3L4_TLV_SIZE_CHANNEL_INFO * cnt;
+
+        msg = wimax_osal_packet_alloc(size);
+
+        /* setup message header */
+        ptr = wimax_osal_packet_put(msg, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+        hnd->dm->setup_header(hnd->dm, ptr, L4_L3_OPCODE_SET_SCAN_PARAM,
+                          size - PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+
+        /* WARNING: assumption made, that same numbering is
+           used on chipset if and WiHAL */
+        wimax_osal_assert(L3L4_BANDWIDTH_10 ==E_WIHAL_CHANNEL_BANDWIDTH_10MHZ);
+        wimax_osal_assert(L3L4_FFT_1024 == E_WIHAL_FFT_SIZE_1024);
+
+        /* construct the scan policy sub block */
+        scanpol = hnd->dm->insert_tlv(
+                hnd->dm, msg,
+                L3L4_TLV_TYPE_SCAN_POLICY, L3L4_TLV_SIZE_SCAN_POLICY);
+        scanpol->scan_mode = WIMAX_OSAL_U32_TO_LE(L3L4_SCAN_POLICY_FIND_ALL);
+
+        while (cnt) {
+
+                /* construct the channel plan */
+                i = scan_params->channel_plan_idx;
+                chinfo = hnd->dm->insert_tlv(
+                        hnd->dm, msg,
+                        L3L4_TLV_TYPE_CHANNEL_INFO,
+                        L3L4_TLV_SIZE_CHANNEL_INFO);
+
+                /* indexing supports up to u16 of plans */
+                wimax_osal_assert(i < 65536);
+
+                chinfo->channel_id = WIMAX_OSAL_U16_TO_LE((u16)i);
+                chinfo->frequency = WIMAX_OSAL_U32_TO_LE(
+                        scan_params->search_plan[i].carrier_freq);
+                chinfo->bandwidth = (u8)(scan_params->search_plan[i].
+                                         channel_bandwidth);
+                chinfo->fft = (u8)(scan_params->search_plan[i].fft_size);
+                wimax_osal_mem_cpy(chinfo->preambles,
+                                   scan_params->search_plan[i].preamble,
+                                   WIHAL_PREAMBLE_SIZE);
+                chinfo->reserved = 0;
+
+                /* increment the channel plan index */
+                scan_params->channel_plan_idx += 1;
+
+                /* decrement the channel count */
+                cnt -= 1;
+
+        }
+
+        /* send the params set message to the chipset */
+        DM_BG_MSG_ENQUEUE(msg, PC2400M_CD_FLAG_NONE);
+
+ out:
+        return ret;
+
+}
+
+
+/** Handle a scan result indication from the chipset. This function handles
+ *  the scan result indication by extracting possible results and either
+ *  finalizing or continuing scanning depending on scan state.
+ *
+ *  @param hnd the control dispatcher instance
+ *  @param indid identifier of the indication being handled
+ *  @param msg message containing the indication message
+ *  @param data client cookie data carrying the dm bg instance
+ *  @return none
+ */
+static void dm_bg_ind_scan_result(
+        struct pc2400m_drv_cd_if *cdhnd,
+        u32 indid,
+        wimax_osal_packet *msg,
+        void *data)
+{
+        struct pc2400m_drv_dm_bg_if *hnd = (struct pc2400m_drv_dm_bg_if*)data;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->dm->ctx);
+        struct pc2400m_drv_dm_bg_scan_nap *scan_params =
+                (struct pc2400m_drv_dm_bg_scan_nap*)hnd->params;
+        struct L3L4_TLV_STR_SCAN_STATUS *scstatus;
+        struct L3L4_TLV_STR_NETWORK_SCAN_RESULT *scres = NULL;
+
+        u8 status = L3L4_SCAN_STATUS_FAILURE;
+        u16 channel_id;
+        u32 i;
+
+        PC2400M_DRV_UNWARN(cdhnd);
+        PC2400M_DRV_UNWARN(indid);
+
+        /* only process the status if expecting it */
+        if (hnd->state != PC2400M_DRV_DM_BG_SCAN_NAP_WAITING_SCAN) {
+                wimax_osal_trace_u32(
+                        PC2400M_GROUP_DM_DEBUG,
+                        PC2400M_TRACE_BG_SCAN_IGNORING_RESULT,
+                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                        hnd->state);
+
+                goto out;
+        }
+
+        /* extract the status TLV from the message */
+        scstatus = (struct L3L4_TLV_STR_SCAN_STATUS*)
+                hnd->dm->get_tlv(hnd->dm, wimax_osal_packet_ptr(msg),
+                                 L3L4_TLV_TYPE_SCAN_STATUS, NULL);
+        wimax_osal_assert(scstatus);
+        wimax_osal_assert(
+                WIMAX_OSAL_LE_TO_U16(scstatus->tlv.length) ==
+                L3L4_TLV_SIZE_SCAN_STATUS - L3L4_TLV_HDR_LEN);
+        status = (u8)WIMAX_OSAL_LE_TO_U32(scstatus->scan_status);
+
+        if (status == L3L4_SCAN_STATUS_DONE ||
+            status == L3L4_SCAN_STATUS_SCANING ||
+            status == L3L4_SCAN_STATUS_STOPPED) {
+
+                /* the scan is performed one channel plan at a time, so
+                   either no results or one result is expected */
+                while ((scres = (struct L3L4_TLV_STR_NETWORK_SCAN_RESULT*)
+                        hnd->dm->get_tlv(hnd->dm, wimax_osal_packet_ptr(msg),
+                                         L3L4_TLV_TYPE_NETWORK_SCAN_RESULT,
+                                         (u8*)scres)), scres) {
+
+                        for (i=0; i<scres->num_of_links; i++) {
+
+                                /* the chipset orders the result best-first,
+                                   so we know the given best rssi and cinr
+                                   value belong to the first channel. the
+                                   remaining channels will get an rssi and
+                                   cinr value of zero for now. */
+
+                                channel_id =
+                                        WIMAX_OSAL_LE_TO_U16(
+                                                scres->channel_id[i]);
+                                wimax_osal_assert(
+                                        channel_id <
+                                        scan_params->channel_plan_count);
+
+                                priv->send_search_ind(
+                                        hnd->dm->ctx,
+                                        PC2400M_DRV_GET_WIHAL_NAP_ID(
+                                                priv, scres->network_id),
+                                        PC2400M_DRV_GET_WIHAL_NAP_ID_MASK(
+                                                priv, scres->network_id_mask),
+                                        PC2400M_DRV_GET_WIHAL_NAP_AND_NSP(
+                                                priv,
+                                                scres->network_id_mask,
+                                                scres->network_id),
+                                        (i!=0)?0:PC2400M_DRV_GET_WIHAL_RSSI(
+                                                priv, scres->best_rssi),
+                                        (i!=0)?0:PC2400M_DRV_GET_WIHAL_CINR(
+                                                priv, scres->best_cinr),
+                                        &scan_params->search_plan[channel_id]);
+                        }
+                }
+        }
+
+        switch (status) {
+        case L3L4_SCAN_STATUS_FAILURE:
+
+                /* scanning failed, so stop now. if already in READY state,
+                   complete immediately, otherwise wait for change to READY
+                   state */
+                hnd->status = -EGENERAL;
+                hnd->state =
+                        PC2400M_DRV_DM_BG_SCAN_NAP_COMPLETE_WAIT;
+                hnd->state_change(hnd, hnd->dm->state, 0, 0);
+                break;
+
+        case L3L4_SCAN_STATUS_DONE:
+
+                /* once back in READY state, attempt to scan more channel
+                   plans */
+                hnd->state = PC2400M_DRV_DM_BG_SCAN_NAP_SET_PARAMS_WAIT;
+                hnd->state_change(hnd, hnd->dm->state, 0, 0);
+                break;
+
+        case L3L4_SCAN_STATUS_STOPPED:
+                break;
+
+        default:
+                /* case L3L4_SCAN_STATUS_SCANING: */
+                wimax_osal_assert(status == L3L4_SCAN_STATUS_SCANING);
+                break;
+        }
+
+ out:
+        wimax_osal_packet_free(&msg);
+
+        return;
+
+}
+
+
+/* CONNECT handlers */
+
+/** This function sets the channel plan for connect. This function sets the
+ *  channel plan for the to-be-connected NAP to the chipset.
+ *
+ *  @param hnd the device manager background transition instance
+ *  @return none
+ */
+static void dm_bg_connect_param_set(struct pc2400m_drv_dm_bg_if *hnd)
+{
+
+        struct pc2400m_drv_dm_bg_connect *connect_params =
+                (struct pc2400m_drv_dm_bg_connect*)hnd->params;
+        struct L3L4_TLV_STR_SCAN_POLICY *scanpol;
+        struct L3L4_TLV_STR_CHANNEL_INFO *chinfo;
+        wimax_osal_packet *msg;
+        s32 size;
+        u8 *ptr;
+
+        wimax_osal_assert(connect_params != NULL);
+
+        /* construct connect parameter message */
+        size = PC2400M_DRV_CHIPIF_CTRL_MSG_LEN +
+                L3L4_TLV_SIZE_SCAN_POLICY +
+                L3L4_TLV_SIZE_CHANNEL_INFO;
+
+        msg = wimax_osal_packet_alloc(size);
+
+        /* setup message header */
+        ptr = wimax_osal_packet_put(msg, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+        hnd->dm->setup_header(hnd->dm, ptr, L4_L3_OPCODE_SET_SCAN_PARAM,
+                              size - PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+
+        /* construct scan policy, get the first found BS from the plan */
+        scanpol = hnd->dm->insert_tlv(
+                hnd->dm, msg,
+                L3L4_TLV_TYPE_SCAN_POLICY, L3L4_TLV_SIZE_SCAN_POLICY);
+        scanpol->scan_mode = WIMAX_OSAL_U32_TO_LE(L3L4_SCAN_POLICY_FIND_FIRST);
+
+        /* construct the channel plan */
+        chinfo = hnd->dm->insert_tlv(hnd->dm, msg,
+                                     L3L4_TLV_TYPE_CHANNEL_INFO,
+                                     L3L4_TLV_SIZE_CHANNEL_INFO);
+
+        chinfo->channel_id = WIMAX_OSAL_U16_TO_LE((u16)0);
+        chinfo->reserved = 0;
+
+        /* store the channel plan itself */
+        PC2400M_DRV_SET_WIHAL_CHANNEL_PLAN(
+                priv,
+                &connect_params->search_plan,
+                &chinfo->frequency,
+                &chinfo->bandwidth,
+                &chinfo->fft,
+                chinfo->preambles);
+
+        /* send the params set message to the chipset */
+        DM_BG_MSG_ENQUEUE(msg, PC2400M_CD_FLAG_NONE);
+        return;
+
+}
+
+/** This function sends a connect command to the chipset.
+ *
+ *  @param hnd the device manager background transition instance
+ *  @return none
+ */
+static void dm_bg_connect_command_send(struct pc2400m_drv_dm_bg_if *hnd)
+{
+
+        struct L3L4_TLV_STR_BS_CRITERIA *bscr;
+        struct L3L4_TLV_STR_TH_CRITERIA *thcr;
+        struct L3L4_TLV_STR_CONNECT_FLAGS *cflags;
+        struct pc2400m_drv_dm_bg_connect *connect_params =
+                (struct pc2400m_drv_dm_bg_connect*)hnd->params;
+        wimax_osal_packet *msg;
+        u8 *ptr;
+        u32 size;
+
+        wimax_osal_assert(connect_params);
+
+
+        wimax_osal_trace(
+                PC2400M_GROUP_DM_DEBUG,
+                PC2400M_TRACE_BG_CONNECT_START,
+                WIMAX_OSAL_TRACE_PRIORITY_DEBUG);
+
+
+        /* specify the provided channel info as data used in the
+           status reports */
+        wimax_osal_mem_cpy(
+                &hnd->dm->chipset.link.channel_plan,
+                &connect_params->search_plan,
+                sizeof(struct t_wihal_search_plan));
+        hnd->dm->chipset.link.channel_set |=
+                PC2400M_DRV_DM_CHIPSET_CHANNEL_SET_CHANNEL_INFO;
+
+        /* send connect command to the chipset */
+        size = L3L4_TLV_SIZE_BS_CRITERIA + L3L4_TLV_SIZE_CONNECT_FLAGS +
+                L3L4_TLV_SIZE_TH_CRITERIA;
+        msg = wimax_osal_packet_alloc
+                (PC2400M_DRV_CHIPIF_CTRL_MSG_LEN + size);
+
+        ptr = wimax_osal_packet_put(
+                msg, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+        hnd->dm->setup_header(hnd->dm, ptr, L4_L3_OPCODE_CMD_CONNECT, size);
+
+
+        /* fill in the th criteria tlv */
+        thcr = hnd->dm->insert_tlv(hnd->dm, msg,
+                                   L3L4_TLV_TYPE_TH_CRITERIA,
+                                   L3L4_TLV_SIZE_TH_CRITERIA);
+        thcr->rssi = WIMAX_OSAL_U32_TO_LE(0);
+        thcr->cinr = WIMAX_OSAL_U32_TO_LE(0);
+
+        /* fill the connection flags */
+        cflags = hnd->dm->insert_tlv(hnd->dm, msg,
+                                     L3L4_TLV_TYPE_CONNECT_FLAGS,
+                                     L3L4_TLV_SIZE_CONNECT_FLAGS);
+
+        if (connect_params->realm_req) {
+
+                /* request NSP realm, specifying the associated NSP ID */
+                cflags->request_realm = (u8)L3L4_REQUEST_REALM_YES;
+                cflags->nsp_id[0] = (u8)(connect_params->nspid >> 16);
+                cflags->nsp_id[1] = (u8)(connect_params->nspid >> 8);
+                cflags->nsp_id[2] = (u8)(connect_params->nspid);
+
+                /* order the report providing the realm */
+                hnd->dm->cd->register_indication(
+                        hnd->dm->cd, L3_L4_OPCODE_REPORT_SII,
+                        dm_bg_ind_connect_sii_report, (void*)hnd);
+
+        } else {
+
+                /* no realm request with this connect request */
+                cflags->request_realm = (u8)L3L4_REQUEST_REALM_NO;
+                cflags->nsp_id[0] = 0;
+                cflags->nsp_id[1] = 0;
+                cflags->nsp_id[2] = 0;
+
+        }
+
+        cflags->reserved1 = 0;
+        cflags->reserved2 = 0;
+        cflags->reserved3 = 0;
+
+        /* no NSP ID list or NSP verbose name list */
+        cflags->siq = 0;
+
+        /* fill in the bs criteria tlv */
+        bscr = hnd->dm->insert_tlv(hnd->dm, msg,
+                                   L3L4_TLV_TYPE_BS_CRITERIA,
+                                   L3L4_TLV_SIZE_BS_CRITERIA);
+
+        if (connect_params->bslock) {
+
+                /* if a BS lock is specified, use that BSID as connection
+                   criterion */
+                wimax_osal_mem_cpy(
+                        bscr->bsid_criterion,
+                        connect_params->bsid,
+                        WIHAL_BSID_LENGTH);
+
+                wimax_osal_mem_set(
+                        bscr->bsid_criterion_mask,
+                        0xff,
+                        WIHAL_BSID_LENGTH);
+
+        } else {
+
+                /* construct the criterion from the NAP id */
+                PC2400M_DRV_SET_NAP_ID(
+                        priv, connect_params->napid, bscr->bsid_criterion);
+
+                /* BSID criterion mask */
+                PC2400M_DRV_SET_NAP_ID_MASK(
+                        priv, connect_params->napid_mask,
+                        bscr->bsid_criterion_mask);
+
+        }
+
+        wimax_osal_trace_data(PC2400M_GROUP_DM_DEBUG,
+                              PC2400M_TRACE_DM_BS_CRITERIA,
+                              WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                              bscr->bsid_criterion, WIHAL_BSID_LENGTH);
+
+        wimax_osal_trace_data(PC2400M_GROUP_DM_DEBUG,
+                              PC2400M_TRACE_DM_BS_CRITERIA_MASK,
+                              WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                              bscr->bsid_criterion_mask,
+                              WIHAL_BSID_LENGTH);
+
+        DM_BG_MSG_ENQUEUE(msg, PC2400M_CD_FLAG_NONE);
+
+}
+
+/** This function sends a WiHAL network status indication with connection
+ *  progress if there is a change in the progress.
+ *
+ *  @param hnd the device manager background transition instance
+ *  @param progress the current connection progress
+ *  @return none
+ */
+static void dm_bg_connect_send_progress(
+        struct pc2400m_drv_dm_bg_if *hnd, u32 progress)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->dm->ctx);
+        enum t_wihal_network_status stat;
+
+        switch (progress) {
+        case L3L4_CONNECT_PROGRESS_RANGING:
+                stat = E_WIHAL_NETWORK_STATUS_RANGING;
+                break;
+        case L3L4_CONNECT_PROGRESS_SBC:
+                stat = E_WIHAL_NETWORK_STATUS_CAPABILITY_NEGOTIATION;
+                break;
+        case L3L4_CONNECT_PROGRESS_EAP_AUTHENTICATION:
+                stat = E_WIHAL_NETWORK_STATUS_AUTHENTICATION;
+                break;
+        case L3L4_CONNECT_PROGRESS_3_WAY_HANDSHAKE:
+                stat = E_WIHAL_NETWORK_STATUS_3_WAY_HANDSHAKE;
+                break;
+        case L3L4_CONNECT_PROGRESS_REGISTRATION:
+                stat = E_WIHAL_NETWORK_STATUS_REGISTRATION;
+                break;
+        default:
+                stat = E_WIHAL_NETWORK_STATUS_CONNECTED;
+                break;
+        }
+
+        /* send a status indication */
+        if (stat != E_WIHAL_NETWORK_STATUS_CONNECTED) {
+                priv->send_network_status_ind(
+                        priv->ctx,
+                        stat,
+                        E_WIHAL_NETWORK_STATUS_ERR_NONE,
+                        hnd->dm->chipset.link.bs_id,
+                        &hnd->dm->chipset.link.channel_plan,
+                        hnd->dm->chipset.link.nsp_realm_len,
+                        hnd->dm->chipset.link.nsp_realm);
+                hnd->dm->chipset.trans.network_status = stat;
+
+        }
+
+        return;
+
+}
+
+/** This function sends a WiHAL network status indication with connection
+ *  state if there is a change in the state.
+ *
+ *  @param hnd the device manager background transition instance
+ *  @param progress the current connection progress
+ *  @return none
+ */
+static void dm_bg_connect_send_network_status(
+        struct pc2400m_drv_dm_bg_if *hnd, u8 new_state)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->dm->ctx);
+        struct pc2400m_drv_dm_bg_connect *connect_params =
+                (struct pc2400m_drv_dm_bg_connect*)hnd->params;
+        enum t_wihal_network_status status =
+                E_WIHAL_NETWORK_STATUS_DISCONNECTED;
+        boolean send = FALSE;
+
+        /* only send network status indications for changed states */
+        if (connect_params->prev_state == new_state)
+                goto out;
+
+        switch (new_state) {
+        case L3L4_SYSTEM_STATE_WIMAX_CONNECTED:
+                send = TRUE;
+                status = E_WIHAL_NETWORK_STATUS_DATA_PATH_CREATION;
+                break;
+
+        case L3L4_SYSTEM_STATE_DATA_PATH_CONNECTED:
+
+                /* moving between the IDLE and DATA_PATH_CONNECTED states
+                   should not induce a status indication */
+                if (connect_params->prev_state != L3L4_SYSTEM_STATE_IDLE) {
+                        send = TRUE;
+                        status = E_WIHAL_NETWORK_STATUS_CONNECTED;
+                }
+                break;
+
+        case L3L4_SYSTEM_STATE_READY:
+                send = TRUE;
+                status = E_WIHAL_NETWORK_STATUS_DISCONNECTED;
+                break;
+
+        }
+
+        /* send a status indication */
+        if (send) {
+                priv->send_network_status_ind(
+                        priv->ctx,
+                        status,
+                        hnd->dm->chipset.trans.disconnect_status,
+                        hnd->dm->chipset.link.bs_id,
+                        &hnd->dm->chipset.link.channel_plan,
+                        hnd->dm->chipset.link.nsp_realm_len,
+                        hnd->dm->chipset.link.nsp_realm);
+                hnd->dm->chipset.trans.network_status = status;
+        }
+
+        connect_params->prev_state = new_state;
+
+ out:
+        return;
+
+}
+
+
+/** This function handlers a bs-info from the chipset. This function parses
+ *  the BS info TLV from the chipset, and stores the information into the
+ *  chipset cache.
+ *
+ *  @param cdhnd the control dispatcher instance
+ *  @param indid identifier of the processed indication
+ *  @param msg packet containing the message to process
+ *  @param data client cookie pointer carrying the dm bg instance
+ *  @return none
+ */
+static void dm_bg_ind_connect_bsinfo_report(
+        struct pc2400m_drv_cd_if *cdhnd,
+        u32 indid,
+        wimax_osal_packet *msg,
+        void *data)
+{
+
+        struct pc2400m_drv_dm_bg_if *hnd = (struct pc2400m_drv_dm_bg_if*)data;
+        struct L3L4_TLV_STR_BSID *bsid;
+
+        PC2400M_DRV_UNWARN(cdhnd);
+        PC2400M_DRV_UNWARN(indid);
+
+        wimax_osal_assert(hnd->id == PC2400M_DRV_DM_BG_CONNECT);
+
+        /* consider the NSP change count */
+        bsid = (struct L3L4_TLV_STR_BSID*)
+                hnd->dm->get_tlv(hnd->dm, wimax_osal_packet_ptr(msg),
+                                 L3L4_TLV_TYPE_BSID, NULL);
+
+        wimax_osal_assert(bsid);
+
+        /* copy the BSID to the chipset cache */
+        wimax_osal_mem_cpy(
+                hnd->dm->chipset.link.bs_id,
+                bsid->bsid,
+                L3L4_BSID_LENGTH);
+        hnd->dm->chipset.link.channel_set |=
+                PC2400M_DRV_DM_CHIPSET_CHANNEL_SET_BSID;
+
+        /* set the "last bsid" value as well (for detecting
+           handovers) */
+        wimax_osal_mem_cpy(
+                hnd->dm->chipset.link.last_bs_id,
+                bsid->bsid,
+                L3L4_BSID_LENGTH);
+        hnd->dm->chipset.link.channel_set |=
+                PC2400M_DRV_DM_CHIPSET_CHANNEL_SET_LAST_BSID;
+
+        wimax_osal_packet_free(&msg);
+
+}
+
+
+/** This function handlers a sii from the chipset. This function parses
+ *  the NSP and NSP verbose name info from the chipset sii TLV, and stores the
+ *  information into the chipset cache.
+ *
+ *  @param cdhnd the control dispatcher instance
+ *  @param indid identifier of the processed indication
+ *  @param msg packet containing the message to process
+ *  @param data client cookie pointer carrying the dm bg instance
+ *  @return none
+ */
+static void dm_bg_ind_connect_sii_report(struct pc2400m_drv_cd_if *cdhnd,
+                                         u32 indid,
+                                         wimax_osal_packet *msg,
+                                         void *data)
+{
+
+        struct pc2400m_drv_dm_bg_if *hnd = (struct pc2400m_drv_dm_bg_if*)data;
+        struct L3L4_TLV_STR_REALM *realm;
+
+        PC2400M_DRV_UNWARN(cdhnd);
+        PC2400M_DRV_UNWARN(indid);
+
+        wimax_osal_assert(hnd->id == PC2400M_DRV_DM_BG_CONNECT);
+
+        /* extract the realm from the message */
+        realm = (struct L3L4_TLV_STR_REALM*)
+                hnd->dm->get_tlv(hnd->dm, wimax_osal_packet_ptr(msg),
+                                 L3L4_TLV_TYPE_REALM, NULL);
+
+        if (realm) {
+
+                /* copy the provided realm string into the chipset cache,
+                   and append a trailing zero for easier handling and
+                   tracing. be mindful of pre-existing realm buffers */
+
+                wimax_osal_mem_free(
+                        (void**)&(hnd->dm->chipset.link.nsp_realm));
+
+                hnd->dm->chipset.link.nsp_realm_len =
+                        WIMAX_OSAL_LE_TO_U16(realm->realm_length);
+
+                wimax_osal_assert(hnd->dm->chipset.link.nsp_realm_len > 0);
+
+                hnd->dm->chipset.link.nsp_realm =
+                        wimax_osal_mem_alloc(
+                                hnd->dm->chipset.link.nsp_realm_len + 1);
+                wimax_osal_mem_cpy(
+                        hnd->dm->chipset.link.nsp_realm,
+                        realm->realm_data,
+                        hnd->dm->chipset.link.nsp_realm_len);
+                hnd->dm->chipset.link.nsp_realm
+                        [hnd->dm->chipset.link.nsp_realm_len] = '\0';
+
+                wimax_osal_trace_str(
+                        PC2400M_GROUP_DM_DEBUG,
+                        PC2400M_TRACE_BG_RECEIVED_REALM,
+                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                        hnd->dm->chipset.link.nsp_realm);
+
+        } else {
+
+                wimax_osal_trace(
+                        PC2400M_GROUP_DM_ERROR,
+                        PC2400M_TRACE_BG_MISSING_REALM,
+                        WIMAX_OSAL_TRACE_PRIORITY_ERROR);
+
+        }
+
+        wimax_osal_packet_free(&msg);
+
+}
+
+/** This function retrieves the flags for the connect procedure.
+ *
+ *  @param hnd the device manager background transition instance
+ *  @return the flags for the ongoing connect procedure
+ */
+static u32 dm_bg_connect_get_flags(struct pc2400m_drv_dm_bg_if *hnd)
+{
+
+        struct pc2400m_drv_dm_bg_connect *connect_params =
+                (struct pc2400m_drv_dm_bg_connect*)hnd->params;
+
+        wimax_osal_assert(hnd->id == PC2400M_DRV_DM_BG_CONNECT);
+        return connect_params->flags;
+
+}
+
+/** This function stores the flags for the connect procedure.
+ *
+ *  @param hnd the device manager background transition instance
+ *  @param flags the flags to be stored
+ *  @return none
+ */
+static void dm_bg_connect_set_flags(
+        struct pc2400m_drv_dm_bg_if *hnd,
+        u32 flags)
+{
+
+        struct pc2400m_drv_dm_bg_connect *connect_params =
+                (struct pc2400m_drv_dm_bg_connect*)hnd->params;
+
+        wimax_osal_assert(hnd->id == PC2400M_DRV_DM_BG_CONNECT);
+        connect_params->flags = flags;
+
+}
+
+
+
+
+/* DISCONNECT handlers */
+
+/** This function sends a disconnect command to the chipset.
+ *
+ *  @param hnd the dm bg instance
+ *  @return none
+ */
+static void dm_bg_disconnect_command_send(struct pc2400m_drv_dm_bg_if *hnd)
+{
+
+
+        wimax_osal_packet *msg;
+        u8 *ptr;
+
+        wimax_osal_trace(
+                PC2400M_GROUP_DM_DEBUG,
+                PC2400M_TRACE_BG_DISCONNECT_START,
+                WIMAX_OSAL_TRACE_PRIORITY_DEBUG);
+
+        /* send the disconnect command to the chipset */
+        msg = wimax_osal_packet_alloc(PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+
+        ptr = wimax_osal_packet_put(msg, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+        hnd->dm->setup_header(hnd->dm, ptr, L4_L3_OPCODE_CMD_DISCONNECT, 0);
+
+        DM_BG_MSG_ENQUEUE(msg, PC2400M_CD_FLAG_NONE);
+
+}
+
+
+/* NSP SCAN handlers */
+/** This function sets the channel parameters for an upcoming NSP scan.
+ *
+ *  @param hnd the dm bg instance
+ *  @return none
+ */
+static void dm_bg_scan_nsp_param_set(struct pc2400m_drv_dm_bg_if *hnd)
+{
+
+        struct pc2400m_drv_dm_bg_scan_nsp *scan_params =
+                (struct pc2400m_drv_dm_bg_scan_nsp*)hnd->params;
+        struct L3L4_TLV_STR_SCAN_POLICY *scanpol;
+        struct L3L4_TLV_STR_CHANNEL_INFO *chinfo;
+        wimax_osal_packet *msg;
+        s32 size;
+        u8 *ptr;
+
+        wimax_osal_assert(scan_params != NULL);
+
+        /* construct connect parameter message */
+        size = PC2400M_DRV_CHIPIF_CTRL_MSG_LEN +
+                L3L4_TLV_SIZE_SCAN_POLICY +
+                L3L4_TLV_SIZE_CHANNEL_INFO;
+
+        msg = wimax_osal_packet_alloc(size);
+
+        /* setup message header */
+        ptr = wimax_osal_packet_put(msg, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+        hnd->dm->setup_header(hnd->dm, ptr, L4_L3_OPCODE_SET_SCAN_PARAM,
+                              size - PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+
+        /* construct scan policy, get the first found BS from the plan */
+        scanpol = hnd->dm->insert_tlv(
+                hnd->dm, msg,
+                L3L4_TLV_TYPE_SCAN_POLICY, L3L4_TLV_SIZE_SCAN_POLICY);
+        scanpol->scan_mode = WIMAX_OSAL_U32_TO_LE(L3L4_SCAN_POLICY_FIND_FIRST);
+
+        /* construct the channel plan TLV */
+        chinfo = hnd->dm->insert_tlv(hnd->dm, msg,
+                                     L3L4_TLV_TYPE_CHANNEL_INFO,
+                                     L3L4_TLV_SIZE_CHANNEL_INFO);
+
+        chinfo->channel_id = 0;
+        chinfo->reserved = 0;
+
+        /* store the channel plan itself */
+        PC2400M_DRV_SET_WIHAL_CHANNEL_PLAN(
+                priv,
+                &scan_params->search_plan,
+                &chinfo->frequency,
+                &chinfo->bandwidth,
+                &chinfo->fft,
+                chinfo->preambles);
+
+        /* send the params set message to the chipset */
+        DM_BG_MSG_ENQUEUE(msg, PC2400M_CD_FLAG_NONE);
+        return;
+
+}
+
+/** This function sends a connect command for NSP discovery.
+ *
+ *  @param hnd the dm bg instance
+ *  @return none
+ */
+static void dm_bg_scan_nsp_command_send(struct pc2400m_drv_dm_bg_if *hnd)
+{
+
+
+        struct L3L4_TLV_STR_TH_CRITERIA *thcr;
+        struct L3L4_TLV_STR_BS_CRITERIA *bscr;
+        struct L3L4_TLV_STR_CONNECT_FLAGS *cflags;
+        struct pc2400m_drv_dm_bg_scan_nsp *scan_params =
+                (struct pc2400m_drv_dm_bg_scan_nsp*)hnd->params;
+        wimax_osal_packet *msg;
+        u8 *ptr;
+        u32 size;
+
+        wimax_osal_assert(scan_params);
+
+        wimax_osal_trace(
+                PC2400M_GROUP_DM_DEBUG,
+                PC2400M_TRACE_BG_SCAN_NSP_START,
+                WIMAX_OSAL_TRACE_PRIORITY_DEBUG);
+
+        /* send connect command to the chipset */
+        size = L3L4_TLV_SIZE_BS_CRITERIA +
+                L3L4_TLV_SIZE_CONNECT_FLAGS +
+                L3L4_TLV_SIZE_TH_CRITERIA;
+        msg = wimax_osal_packet_alloc
+                (PC2400M_DRV_CHIPIF_CTRL_MSG_LEN + size);
+
+        ptr = wimax_osal_packet_put(
+                msg, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+        hnd->dm->setup_header(hnd->dm, ptr, L4_L3_OPCODE_CMD_CONNECT, size);
+
+        /* fill the threshold criteria tlv */
+        thcr = hnd->dm->insert_tlv(hnd->dm, msg,
+                                   L3L4_TLV_TYPE_TH_CRITERIA,
+                                   L3L4_TLV_SIZE_TH_CRITERIA);
+        thcr->rssi = WIMAX_OSAL_U32_TO_LE(0);
+        thcr->cinr = WIMAX_OSAL_U32_TO_LE(0);
+
+        /* fill the connection flags */
+        cflags = hnd->dm->insert_tlv(hnd->dm, msg,
+                                     L3L4_TLV_TYPE_CONNECT_FLAGS,
+                                     L3L4_TLV_SIZE_CONNECT_FLAGS);
+
+        /* no realm request with this connect request */
+        cflags->request_realm = (u8)L3L4_REQUEST_REALM_NO;
+        cflags->nsp_id[0] = 0;
+        cflags->nsp_id[1] = 0;
+        cflags->nsp_id[2] = 0;
+
+        /* specify level of required NSP info */
+        cflags->siq = scan_params->siq_flags;
+
+        /* initialize padding bytes too */
+        cflags->reserved1 = 0;
+        cflags->reserved2 = 0;
+        cflags->reserved3 = 0;
+
+        /* fill in the bs criteria tlv */
+        bscr = hnd->dm->insert_tlv(hnd->dm, msg,
+                                   L3L4_TLV_TYPE_BS_CRITERIA,
+                                   L3L4_TLV_SIZE_BS_CRITERIA);
+
+        /* Specify the BSID criterion */
+        PC2400M_DRV_SET_NAP_ID(
+                priv, scan_params->napid, bscr->bsid_criterion);
+
+        /* BSID criterion mask */
+        PC2400M_DRV_SET_NAP_ID_MASK(
+                priv, scan_params->napid_mask, bscr->bsid_criterion_mask);
+
+        /* let the more enlightened users know what we just did ... ;) */
+        wimax_osal_trace_data(PC2400M_GROUP_DM_DEBUG,
+                              PC2400M_TRACE_DM_BS_CRITERIA,
+                              WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                              bscr->bsid_criterion, WIHAL_BSID_LENGTH);
+
+        wimax_osal_trace_data(PC2400M_GROUP_DM_DEBUG,
+                              PC2400M_TRACE_DM_BS_CRITERIA_MASK,
+                              WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                              bscr->bsid_criterion_mask,
+                              WIHAL_BSID_LENGTH);
+
+        DM_BG_MSG_ENQUEUE(msg, PC2400M_CD_FLAG_NONE);
+
+}
+
+/** This function handlers a bs-info from the chipset. This function parses
+ *  the BS info TLV from the chipset. The information is stored into the
+ *  NSP scan parameter info, and will be sent to the client.
+ *
+ *  @param cdhnd the control dispatcher instance
+ *  @param indid identifier of the processed indication
+ *  @param msg packet containing the message to process
+ *  @param data client cookie pointer carrying the dm bg instance
+ *  @return none
+ */
+static void dm_bg_ind_scan_nsp_bsinfo_report(
+        struct pc2400m_drv_cd_if *cdhnd,
+        u32 indid,
+        wimax_osal_packet *msg,
+        void *data)
+{
+
+        struct pc2400m_drv_dm_bg_if *hnd = (struct pc2400m_drv_dm_bg_if*)data;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->dm->ctx);
+        struct pc2400m_drv_dm_bg_scan_nsp *scan_params =
+                (struct pc2400m_drv_dm_bg_scan_nsp*)hnd->params;
+        struct L3L4_TLV_STR_NSP_CHANGE_COUNT *ccount;
+        struct L3L4_TLV_STR_BSID *bsid;
+
+        PC2400M_DRV_UNWARN(cdhnd);
+        PC2400M_DRV_UNWARN(indid);
+
+        wimax_osal_assert(hnd->id == PC2400M_DRV_DM_BG_SCAN_NSP);
+
+        bsid = (struct L3L4_TLV_STR_BSID*)
+                hnd->dm->get_tlv(hnd->dm, wimax_osal_packet_ptr(msg),
+                                 L3L4_TLV_TYPE_BSID, NULL);
+
+        /* determine the NAP and NSP flag based on the provided BSID */
+        if (bsid) {
+
+                scan_params->nap_and_nsp =
+                        PC2400M_DRV_GET_WIHAL_NAP_AND_NSP(
+                                priv, PC2400M_DRV_FULL_BSID_MASK, bsid->bsid);
+
+        }
+
+
+        /* consider the NSP change count */
+        ccount = (struct L3L4_TLV_STR_NSP_CHANGE_COUNT*)
+                hnd->dm->get_tlv(hnd->dm, wimax_osal_packet_ptr(msg),
+                                 L3L4_TLV_TYPE_NSP_CHANGE_COUNT, NULL);
+
+        if (ccount) {
+
+#define PC2400M_DRV_DM_BG_SIQ_BIT_MASK 0x03
+                if (scan_params->nsp_change_count_valid &&
+                    (scan_params->nsp_change_count ==
+                     ccount->nsp_change_count)) {
+
+                        /* if the change count matches to the one specified in
+                           the request, the NSP discovery can be immediately
+                           completed, and we need not wait for the NSP lists */
+                        hnd->state = PC2400M_DRV_DM_BG_SCAN_NSP_DISCONNECT;
+                        dm_bg_disconnect_command_send(hnd);
+
+                } else if (!(scan_params->siq_flags &
+                             PC2400M_DRV_DM_BG_SIQ_BIT_MASK)) {
+
+                        /* if no more NSP information was requested,
+                           the NSP discovery is complete now and can start
+                           disconnecting */
+                        hnd->state = PC2400M_DRV_DM_BG_SCAN_NSP_DISCONNECT;
+                        dm_bg_disconnect_command_send(hnd);
+
+                }
+
+
+                /* return the current NSP change count */
+                scan_params->nsp_change_count = ccount->nsp_change_count;
+
+                wimax_osal_trace_byte(
+                        PC2400M_GROUP_DM_DEBUG,
+                        PC2400M_TRACE_BG_RECEIVED_NSP_CHANGE_COUNT,
+                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                        scan_params->nsp_change_count);
+
+                /* mark the change count information as received */
+                scan_params->siq_flags |=
+                        PC2400M_DRV_DM_BG_SCAN_NSP_NSP_CHANGE_COUNT_DONE;
+                hnd->state_change(hnd, hnd->dm->state,
+                                  L3L4_REPORT_STATE_REASON_NORMAL, 0);
+
+
+        }
+
+        wimax_osal_packet_free(&msg);
+
+}
+
+/** This function handlers NSP and NSP verbose name information from the
+ *  chipset. This function parses the SII info TLV from the chipset. The
+ *  information is stored into the NSP scan parameter info, and will be sent
+ *  to the client.
+ *
+ *  @param cdhnd the control dispatcher instance
+ *  @param indid identifier of the processed indication
+ *  @param msg packet containing the message to process
+ *  @param data client cookie pointer carrying the dm bg instance
+ *  @return none
+ */
+static void dm_bg_ind_scan_nsp_sii_report(struct pc2400m_drv_cd_if *cdhnd,
+                                          u32 indid,
+                                          wimax_osal_packet *msg,
+                                          void *data)
+{
+
+        struct pc2400m_drv_dm_bg_if *hnd = (struct pc2400m_drv_dm_bg_if*)data;
+        struct pc2400m_drv_dm_bg_scan_nsp *scan_params =
+                (struct pc2400m_drv_dm_bg_scan_nsp*)hnd->params;
+        struct L3L4_TLV_STR_NSPID_LIST *nspid_list;
+        struct L3L4_TLV_STR_NSP_VERBOSE_NAME_LIST *nspname_list;
+        u32 i;
+        u8 *ptr;
+
+        PC2400M_DRV_UNWARN(cdhnd);
+        PC2400M_DRV_UNWARN(indid);
+
+        wimax_osal_assert(hnd->id == PC2400M_DRV_DM_BG_SCAN_NSP);
+
+
+        /* consider the NSP list */
+        nspid_list = (struct L3L4_TLV_STR_NSPID_LIST*)
+                hnd->dm->get_tlv(hnd->dm, wimax_osal_packet_ptr(msg),
+                                 L3L4_TLV_TYPE_NSPID_LIST, NULL);
+
+        if ((scan_params->siq_flags &
+             L3L4_CONNECT_FLAGS_SIQ_REQUEST_NSP_ID_LIST) && nspid_list) {
+
+                wimax_osal_assert(!scan_params->nsp_list);
+
+                /* allocate memory for and list the NSP ID's in the scan NSP
+                   parameters */
+#define PC2400M_DRV_DM_BG_NSP_ID_LEN 3
+                scan_params->number_of_nsps =
+                        WIMAX_OSAL_LE_TO_U32(nspid_list->nsp_id_list_length) /
+                        PC2400M_DRV_DM_BG_NSP_ID_LEN;
+
+                scan_params->nsp_list =
+                        wimax_osal_mem_alloc(
+                                sizeof(struct t_wihal_nsp_info) *
+                                scan_params->number_of_nsps);
+
+                ptr = nspid_list->nsp_id_list_data;
+                for (i=0; i<scan_params->number_of_nsps; i++) {
+                        scan_params->nsp_list[i].nsp_id =
+                                (((u32)ptr[0]) << 16) |
+                                (((u32)ptr[1]) << 8) |
+                                (((u32)ptr[2]));
+
+                        scan_params->nsp_list[i].nsp_name_len = 0;
+                        scan_params->nsp_list[i].p_nsp_name = NULL;
+                }
+
+                wimax_osal_trace_u32(
+                        PC2400M_GROUP_DM_DEBUG,
+                        PC2400M_TRACE_BG_RECEIVED_NSPID_LIST,
+                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                        scan_params->number_of_nsps);
+
+                /* mark NSP data as received */
+                scan_params->siq_flags |=
+                        PC2400M_DRV_DM_BG_SCAN_NSP_NSP_LIST_DONE;
+
+        }
+
+
+        /* consider the NSP verbose name list */
+        nspname_list = (struct L3L4_TLV_STR_NSP_VERBOSE_NAME_LIST*)
+                hnd->dm->get_tlv(hnd->dm, wimax_osal_packet_ptr(msg),
+                                 L3L4_TLV_TYPE_NSP_VERBOSE_NAME_LIST, NULL);
+
+        if ((scan_params->siq_flags &
+             L3L4_CONNECT_FLAGS_SIQ_REQUEST_NSP_VERBOSE_NAME_LIST) &&
+            nspname_list) {
+
+                /* copy the verbose names for the NSP's into the scan
+                   parameters */
+                ptr = nspname_list->nsp_list_data;
+                for (i=0; i<scan_params->number_of_nsps; i++) {
+
+                        /* certify, that there is still enough data in the
+                           NSP verbose name list buffer */
+                        wimax_osal_assert(
+                                (u32)(ptr - nspname_list->nsp_list_data + 1) <=
+                                WIMAX_OSAL_LE_TO_U32(
+                                        nspname_list->nsp_list_length));
+
+                        /* certify, that there is enough data for the
+                           next verbose name in the buffer */
+                        wimax_osal_assert(
+                                (u32)(ptr - nspname_list->nsp_list_data + 1 +
+                                 ptr[0]) <=
+                                WIMAX_OSAL_LE_TO_U32(
+                                        nspname_list->nsp_list_length));
+
+                        /* allocate space for and copy the verbose name into
+                           the NSP data in the scan parameters */
+                        scan_params->nsp_list[i].nsp_name_len = ptr[0];
+                        scan_params->nsp_list[i].p_nsp_name =
+                                wimax_osal_mem_alloc(ptr[0]+1);
+                        wimax_osal_mem_cpy(
+                                scan_params->nsp_list[i].p_nsp_name,
+                                ptr+1,
+                                ptr[0]);
+                        scan_params->nsp_list[i].p_nsp_name[ptr[0]] = '\0';
+                        ptr += (ptr[0] + 1);
+
+                        wimax_osal_trace_str(
+                                PC2400M_GROUP_DM_DEBUG,
+                                PC2400M_TRACE_BG_RECEIVED_NSPNAME,
+                                WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                                scan_params->nsp_list[i].p_nsp_name);
+
+                }
+
+                wimax_osal_trace_u32(
+                        PC2400M_GROUP_DM_DEBUG,
+                        PC2400M_TRACE_BG_RECEIVED_NSPNAME_LIST,
+                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                        scan_params->number_of_nsps);
+
+
+        }
+
+        /* check if all required information has been received */
+        hnd->state_change(hnd, hnd->dm->state,
+                          L3L4_REPORT_STATE_REASON_NORMAL, 0);
+
+        wimax_osal_packet_free(&msg);
+
+}
+
+/** This function retrieves the flags for the NSP scan procedure.
+ *
+ *  @param hnd the device manager background transition instance
+ *  @return the flags for the ongoing connect procedure
+ */
+static u32 dm_bg_scan_nsp_get_flags(struct pc2400m_drv_dm_bg_if *hnd)
+{
+
+        struct pc2400m_drv_dm_bg_scan_nsp *nsp_scan_params =
+                (struct pc2400m_drv_dm_bg_scan_nsp*)hnd->params;
+
+        wimax_osal_assert(hnd->id == PC2400M_DRV_DM_BG_SCAN_NSP);
+        return nsp_scan_params->flags;
+
+}
+
+/** This function stores the flags for the connect procedure.
+ *
+ *  @param hnd the device manager background transition instance
+ *  @param flags the flags to be stored
+ *  @return none
+ */
+static void dm_bg_scan_nsp_set_flags(
+        struct pc2400m_drv_dm_bg_if *hnd,
+        u32 flags)
+{
+
+        struct pc2400m_drv_dm_bg_scan_nsp *nsp_scan_params =
+                (struct pc2400m_drv_dm_bg_scan_nsp*)hnd->params;
+
+        wimax_osal_assert(hnd->id == PC2400M_DRV_DM_BG_SCAN_NSP);
+        nsp_scan_params->flags = flags;
+
+}
+
+
+/*****************************************************************************
+ * Exported functions
+ */
+
+/** Create new instance of the dm background handler. Allocate and initialize
+ *  a new instance of the device manager background handler module, bound to a
+ *  specific device manager instance.
+ *
+ *  @param dm the device manager to whom this belongs
+ *  @return pointer to the newly instantiated dm bg.
+ */
+struct pc2400m_drv_dm_bg_if *pc2400m_drv_dm_bg_if_new(
+        struct pc2400m_drv_dm_if *dm) {
+
+        struct pc2400m_drv_dm_bg_if *iface;
+
+        iface = (struct pc2400m_drv_dm_bg_if*)
+                  wimax_osal_mem_alloc(sizeof(struct pc2400m_drv_dm_bg_if));
+        wimax_osal_mem_set(
+                iface, 0x00, sizeof(struct pc2400m_drv_dm_bg_if));
+        iface->dm = dm;
+        iface->cleanup = pc2400m_drv_dm_bg_cleanup;
+        iface->reset = pc2400m_drv_dm_bg_reset;
+        iface->initialize = pc2400m_drv_dm_bg_initialize;
+        iface->cancel = pc2400m_drv_dm_bg_cancel;
+        iface->state_change = pc2400m_drv_dm_bg_state_change;
+
+        return iface;
+
+}
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_dm_bg.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_dm_bg.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_dm_bg.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_dm_bg.h	2011-02-06 20:12:12.086666606 -0500
@@ -0,0 +1,126 @@
+/*
+ * pc2400m_drv_dm_bg.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         3       APPROVED 21-Feb-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_drv_dm_bg.h
+ *
+ * This function declares the device manager background transition handler.
+ *
+ */
+
+#ifndef PC2400M_DRV_DM_BG_H
+#define PC2400M_DRV_DM_BG_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include "pc2400m_osal.h"
+#include "pc2400m_drv_if.h"
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/** background transition identifiers */
+enum pc2400m_drv_dm_bg_transitions {
+        PC2400M_DRV_DM_BG_NONE = 0,
+        PC2400M_DRV_DM_BG_SCAN_NAP,
+        PC2400M_DRV_DM_BG_SCAN_NSP,
+        PC2400M_DRV_DM_BG_CONNECT,
+        PC2400M_DRV_DM_BG_DISCONNECT,
+};
+
+/*****************************************************************************
+ * Data types
+ */
+
+/** parameter structure for the NAP scanning operation */
+struct pc2400m_drv_dm_bg_scan_nap_params {
+        struct t_wihal_cmd_search_nap req;
+        void *client_data;
+};
+
+/** parameter structure for the NSP scanning operation */
+struct pc2400m_drv_dm_bg_scan_nsp_params {
+        struct t_wihal_cmd_search_nsp req;
+        void *client_data;
+};
+
+/** parameter structure for the connect operation */
+struct pc2400m_drv_dm_bg_connect_params {
+        struct t_wihal_cmd_entry req;
+};
+
+struct pc2400m_drv_dm_bg_if;
+
+typedef void (*dm_bg_reset_func)(struct pc2400m_drv_dm_bg_if*);
+typedef void (*dm_bg_cleanup_func)(struct pc2400m_drv_dm_bg_if*);
+typedef s32 (*dm_bg_initialize_func)(
+        struct pc2400m_drv_dm_bg_if*,
+        void *,
+        enum pc2400m_drv_dm_bg_transitions,
+        void *);
+typedef void (*dm_bg_state_change_func)(
+        struct pc2400m_drv_dm_bg_if*,
+        u8,
+        u8,
+        u32);
+typedef void (*dm_bg_cancel_func)(struct pc2400m_drv_dm_bg_if*);
+
+struct pc2400m_drv_dm_if;
+
+struct pc2400m_drv_dm_bg_if {
+        struct pc2400m_drv_dm_if *dm;
+        dm_bg_cleanup_func cleanup;
+        dm_bg_reset_func reset;
+        dm_bg_initialize_func initialize;
+        dm_bg_cancel_func cancel;
+        dm_bg_state_change_func state_change;
+
+        /* data to pass to completion function */
+        void *completion_data;
+
+        /* hold operation parameters */
+        enum pc2400m_drv_dm_bg_transitions id;
+        u32 state;
+        void *params;
+        boolean canceled;
+        s32 status;
+};
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/** dm bg instantiator function */
+extern struct pc2400m_drv_dm_bg_if *pc2400m_drv_dm_bg_if_new(
+        struct pc2400m_drv_dm_if *);
+
+#endif /* PC2400M_DRV_DM_BG_H */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_dm.c maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_dm.c
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_dm.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_dm.c	2011-02-06 20:12:11.916666606 -0500
@@ -0,0 +1,3475 @@
+/*
+ * pc2400m_drv_dm.c
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         72      APPROVED 10-Sep-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_drv_dm.c
+ *
+ * This file implements the device manager. The DM manages the chipset states,
+ * state changes and all transitions used to trigger state changes.
+ *
+ */
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include "pc2400m_drv_com.h"
+#include "pc2400m_drv_dm.h"
+#include "pc2400m_drv_dm_bg.h"
+#include "pc2400m_drv_cd.h"
+#include "pc2400m_drv_hdi.h"
+
+/*****************************************************************************
+ * Global constants and macros
+ */
+
+
+/** Enqueue a message for transsion. This macro enqueues a message for
+ *  transmission to the control dispatcher. The response will be handled in
+ *  the central dm response handling function.
+ *
+ *  @param _msg (wimax_osal_packet*) the message to enqueue
+ *  @param _flags (u32) the flags to pass to the control dispatcher enqueue
+ *                      function
+ *  @return None.
+ */
+#define DM_MSG_ENQUEUE(_msg, _flags) \
+             hnd->cd->msg_enqueue(hnd->cd, _msg, pc2400m_drv_dm_resp_handler, \
+             (void*)hnd, _flags)
+
+/** Change the device manager state. This function changes the device manager
+ *  state. As a side effect, it traces the new state for debugging purposes.
+ *
+ *  @param _x (u32) name of the device manager state variable
+ *  @param _y (u16) new state value
+ *  @return None.
+ */
+#define GOTO_STATE(x,y)       { ((x) = (y)); wimax_osal_trace_byte(\
+                                  PC2400M_GROUP_DM_DEBUG, \
+                                  PC2400M_TRACE_DM_STATE_CHANGE, \
+                                  WIMAX_OSAL_TRACE_PRIORITY_DEBUG, (y)); }
+
+/** This macro resets the device manager state. The macro sets the state to
+ *  "UNINITIALIZED."
+ *
+ *  @param _x (u32) name of the device manager state variable
+ *  @return None.
+ */
+#define RESET_STATE(x)        ((x) = L3L4_SYSTEM_STATE_UNINITIALIZED)
+
+/** PC2400M_DRV_DM_ENABLE_RADIO internal states */
+#define DM_STATE_RADIO_ON_MODE_REQ           0
+#define DM_STATE_RADIO_ON_MODE_REQ_DONE      1
+#define DM_STATE_RADIO_ON_REQ                2
+#define DM_STATE_RADIO_ON_COMPLETE           3
+
+/** PC2400M_DRV_DM_DISABLE_RADIO internal states */
+#define DM_STATE_RADIO_OFF_REQ               0
+#define DM_STATE_RADIO_OFF_COMPLETE          1
+
+
+/** PC2400M_DRV_DM_CONFIGURE internal states */
+#define DM_STATE_CONFIGURE_WAITING_CONFIG    0
+#define DM_STATE_CONFIGURE_PRECONFIG_REQ     1
+#define DM_STATE_CONFIGURE_REQ               2
+#define DM_STATE_CONFIGURE_WAITING_CH        3
+#define DM_STATE_CONFIGURE_WAITING_L3M       4
+#define DM_STATE_CONFIGURE_WAITING_DETAILS   5
+
+/** PC2400M_DRV_DM_TERMINATE internal states */
+#define DM_STATE_TERMINATE_REQ               0
+#define DM_STATE_TERMINATE_WAITING_CH        1
+
+/** PC2400M_DRV_DM_PRODUCTION internal states */
+#define DM_STATE_PRODUCTION_REQ              0
+#define DM_STATE_PRODUCTION_WAITING_CH       1
+
+/*****************************************************************************
+ * Global data types
+ */
+
+/** transition state and status information */
+struct pc2400m_drv_dm_trans {
+        /* owning instance */
+        struct pc2400m_drv_dm_if *hnd;
+
+        /* transition type */
+        enum pc2400m_drv_dm_transitions id;
+
+        /* parameter data */
+        void *params;
+
+        /* transition internal data */
+        struct {
+                u32 state;
+        } intdata;
+
+        /* flags */
+#define DM_TRANS_FLAG_COMPLETING 0x00000001
+        u32 flags;
+
+        /* transition completion callback */
+        dm_transition_cb cb;
+        void *cb_data;
+        void *cb_cl_data;
+
+        /* timeout timer handle */
+        wimax_osal_timer_handle timerhnd;
+
+        /* list element */
+        struct wimax_osal_list_elem_hdr list;
+};
+
+/** transition state and status information */
+struct pc2400m_drv_dm_abort_cb {
+        dm_abort_mission_cb cb;
+        void *data;
+
+        /* list element */
+        struct wimax_osal_list_elem_hdr list;
+};
+
+/** structure to hold intermediate data for the network status operation */
+struct pc2400m_drv_dm_get_network_status_params {
+        struct pc2400m_drv_dm_if *hnd;
+        void *client_data;
+        void *abort_cb;
+        boolean send_resp;
+};
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/** transition handling helpers */
+static void pc2400m_drv_dm_trans_execute(struct pc2400m_drv_dm_if*);
+static void pc2400m_drv_dm_trans_complete(
+        struct pc2400m_drv_dm_if*, s32);
+static void pc2400m_drv_dm_trans_abort(struct pc2400m_drv_dm_if*);
+static struct pc2400m_drv_dm_trans *pc2400m_drv_dm_trans_new(
+        struct pc2400m_drv_dm_if*,
+        enum pc2400m_drv_dm_transitions,
+        void*,
+        dm_transition_cb,
+        void*,
+        void*);
+
+/** state machine handlers */
+static void pc2400m_drv_dm_timeout_handler(wimax_osal_timer_handle, void*);
+static void pc2400m_drv_dm_resp_handler(
+        struct pc2400m_drv_cd_if*,
+        wimax_osal_packet*,
+        void*);
+
+/** indication handlers */
+static void pc2400m_drv_dm_ind_report_state(
+        struct pc2400m_drv_cd_if*,
+        u32,
+        wimax_osal_packet*,
+        void*);
+static void pc2400m_drv_dm_process_state_change(struct pc2400m_drv_dm_if*);
+
+/** general helpers */
+static void pc2400m_drv_dm_get_utf16_string(u8*, u8*, u32);
+static void pc2400m_drv_dm_value_adapt(
+        struct pc2400m_drv_dm_if*,
+        u32*,
+        u32,
+        u32,
+        u32);
+
+/** DM_ENABLE_RADIO helpers */
+static void pc2400m_drv_dm_ind_report_state_enable_radio(
+        struct pc2400m_drv_dm_if*);
+
+/** DM_DISABLE_RADIO helpers */
+static void pc2400m_drv_dm_ind_report_state_disable_radio(
+        struct pc2400m_drv_dm_if*);
+
+/** DM_CONFIGURE helpers */
+static boolean pc2400m_drv_dm_configure_get_device_details(
+        struct pc2400m_drv_dm_if*,
+        wimax_osal_packet*);
+static void pc2400m_drv_dm_ind_report_state_configure(
+        struct pc2400m_drv_dm_if*);
+static void pc2400m_drv_dm_configure_send_preconfig_req(
+        struct pc2400m_drv_dm_if*);
+static void dm_configure_fill_capabilities(
+        struct pc2400m_drv_dm_if*,
+        struct t_wihal_capabilities*);
+
+/** DM_TERMINATE helpers */
+static void pc2400m_drv_dm_ind_report_state_terminate(
+        struct pc2400m_drv_dm_if*);
+
+/** DM_GET_NETWORK_STATUS helpers */
+static void pc2400m_drv_dm_get_network_status_for_handover(
+        struct pc2400m_drv_dm_if*);
+static void pc2400m_drv_dm_get_network_status(
+        struct pc2400m_drv_dm_if*,
+        void*);
+static s32 pc2400m_drv_dm_get_network_status_process(
+        struct pc2400m_drv_dm_if*,
+        wimax_osal_packet*,
+        u16);
+static void pc2400m_drv_dm_get_network_status_process_channel_info(
+        struct pc2400m_drv_dm_if*,
+        wimax_osal_packet*);
+static void pc2400m_drv_dm_get_network_status_process_link_status(
+        struct pc2400m_drv_dm_if*,
+        wimax_osal_packet*);
+
+/** Handover checker helpers */
+static void pc2400m_drv_dm_handover_check(struct pc2400m_drv_dm_if*);
+static void pc2400m_drv_dm_handover_timer_set(
+        struct pc2400m_drv_dm_if*,
+        boolean);
+
+/*****************************************************************************
+ * Local functions
+ */
+
+/** Get status field from L3L4 header. This function retuns the status of the
+ *  BxP L3L4 header.
+ *
+ *  @param msg pointer to OSAL packet containing the message
+ *  @return The value of the status field in native endianness
+ */
+static u16 pc2400m_drv_dm_header_status(wimax_osal_packet *msg)
+{
+        struct pc2400m_drv_chipif_ctrl_msg *header =
+                (struct pc2400m_drv_chipif_ctrl_msg*)
+                wimax_osal_packet_ptr(msg);
+
+        return WIMAX_OSAL_LE_TO_U16(header->status);
+}
+
+/** Validate firmware interface version. This function checks the L4M version
+ *  reported by the firmware and sees whether it is in the supported list. The
+ *  identifier tag of the version is saved to chipset cache if the fw is
+ *  supported.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @return TRUE if the firmware is supported, FALSE if it is not supported
+ */
+static boolean pc2400m_drv_dm_supported_ver_check(
+        struct pc2400m_drv_dm_if *hnd)
+{
+
+        u32 i;
+        struct L3L4SupportedVersion versions[] = L3L4_SUPPORTED_VERSIONS;
+
+        for (i=0;
+             i<sizeof(versions)/sizeof(struct L3L4SupportedVersion);
+             i++) {
+                if (hnd->chipset.cap.L4Mversion[0] == versions[i].major &&
+                    hnd->chipset.cap.L4Mversion[1] == versions[i].minor &&
+                    hnd->chipset.cap.L4Mversion[2] == versions[i].branch) {
+
+                        /* supported version */
+                        if (versions[i].note) {
+                                wimax_osal_trace_str(
+                                        PC2400M_GROUP_DM_ERROR,
+                                        PC2400M_TRACE_VERSION_NOTE,
+                                        WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                                        versions[i].note);
+                        }
+
+                        /* copy the id used for easy identification later */
+                        hnd->chipset.chipif.version = versions[i].id;
+
+                        /* copy the value user for L3L4 header versions */
+                        hnd->chipset.chipif.hdr_version = versions[i].hdr_ver;
+
+                        return TRUE;
+
+                }
+        }
+
+        wimax_osal_trace_data(PC2400M_GROUP_DM_ERROR,
+                              PC2400M_TRACE_UNSUPPORTED_VERSION,
+                              WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                              (u8*)hnd->chipset.cap.L4Mversion,
+                              sizeof(hnd->chipset.cap.L4Mversion));
+
+        return FALSE;
+
+}
+
+/** Copy a UTF-16 string to an ascii string. This function converts
+ *  provided UTF-16 string (expected to be in LE byte order) into an
+ *  ascii string. Only the ascii characters are copied - any other character
+ *  may produce garble.
+ *
+ *  @param dst pointer to target ascii string buffer
+ *  @param src pointer to source UTF-16 string buffer in LE byte order
+ *  @param len number of characters in the string
+ *  @return none
+ */
+static void pc2400m_drv_dm_get_utf16_string(u8 *dst, u8 *src, u32 len)
+{
+
+        u32 i;
+
+        for (i=0; i<len; i++) {
+
+                /* from each character, use the least significant byte as
+                   pure ASCII value. this will work for plain ascii
+                   characters */
+                dst[i] = WIMAX_OSAL_GET_LE16(src + (i<<1)) & 0x00ff;
+
+        }
+
+        return;
+
+}
+
+
+/** Adapt the provided value to the given rules. This function adapts the
+ *  provided integer value to the range and stepping provided as parameter.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @param val value to adapt
+ *  @param min range minimum for the value
+ *  @param max range maximum for the value
+ *  @param increment stepping for the value
+ *  @return none
+ */
+static void pc2400m_drv_dm_value_adapt(
+        struct pc2400m_drv_dm_if *hnd,
+        u32 *val,
+        u32 min,
+        u32 max,
+        u32 increment)
+{
+
+        PC2400M_DRV_UNWARN(hnd);
+        wimax_osal_assert(val);
+
+        /* if the value is below the minimum, change it to the minimum */
+        if (*val != 0 && *val < min)
+                *val = min;
+
+        /* if the value is above the maximum, change it to the maximum */
+        if (*val > max)
+                *val = max;
+
+        /* floor the value down to the nearest full increment */
+        *val = *val - (*val % increment);
+
+}
+
+
+
+
+/** Find start of next tlv of specified type. This function searches the
+ *  given buffer for the TLV type specified as parameter. The first TLV
+ *  encountered is returned.
+ *
+ *  @param hnd pointer to the instance of the device manager
+ *  @param ptr pointer to the start of the message (including the header)
+ *  @param reqtype type of the tlv to be found
+ *  @param last pointer to previous tlv of the type to find the next
+ *  @return return a pointer to the beginning of the TLV (including TLV header)
+ */
+static u8* pc2400m_drv_dm_get_tlv(
+        struct pc2400m_drv_dm_if *hnd,
+        u8 *ptr,
+        u16 reqtype,
+        u8 *last)
+{
+        struct L3L4_TLV_HDR_STR *tlvhdr;
+        u32 length;
+        u16 tlvlen;
+        u8 *ret = NULL;
+
+        PC2400M_DRV_UNWARN(hnd);
+
+        length = WIMAX_OSAL_LE_TO_U16
+                (((struct pc2400m_drv_chipif_ctrl_msg*)ptr)->length);
+        ptr += PC2400M_DRV_CHIPIF_CTRL_MSG_LEN;
+
+        while (length) {
+                wimax_osal_assert(length > 0);
+
+                tlvhdr = (struct L3L4_TLV_HDR_STR*)ptr;
+                if ((ptr > last) &&
+                    (reqtype == WIMAX_OSAL_LE_TO_U16(tlvhdr->type))) {
+                        ret = ptr;
+                        break;
+                }
+
+                tlvlen = WIMAX_OSAL_LE_TO_U16(tlvhdr->length);
+                wimax_osal_assert(tlvlen > 0);
+
+                ptr += (tlvlen + L3L4_TLV_HDR_LEN);
+                length -= (tlvlen + L3L4_TLV_HDR_LEN);
+
+                if (length <= (s32)L3L4_TLV_HDR_LEN)
+                        length = 0;
+        }
+
+        return ret;
+
+}
+
+
+
+/** Create and send a plain request message. This function constructs a L3L4
+ *  header constituting a plain message without any associated TLV's.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @param opcode opcode for the request to send
+ *  @return none
+ */
+static void pc2400m_drv_dm_send_get_req(
+        struct pc2400m_drv_dm_if *hnd,
+        u16 opcode)
+{
+
+        struct pc2400m_drv_chipif_ctrl_msg* header;
+        wimax_osal_packet *msg;
+
+        wimax_osal_assert(hnd->cd);
+
+        msg = wimax_osal_packet_alloc(
+                  PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+        header = (struct pc2400m_drv_chipif_ctrl_msg*)
+                wimax_osal_packet_put(msg, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+        hnd->setup_header(hnd, (u8*)header, opcode, 0);
+        DM_MSG_ENQUEUE(msg, PC2400M_CD_FLAG_NONE);
+
+        return;
+}
+
+/** Create and send a mode of operation request. This function creates and
+ *  sends to the chipset a mode of operation request, with the requested mode
+ *  provided as paramter.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @param mode requested mode of operation
+ *  @return none
+ */
+static void pc2400m_drv_dm_send_mode_of_operation_req(
+        struct pc2400m_drv_dm_if *hnd,
+        u32 mode)
+{
+
+        struct L3L4_TLV_STR_MODE_OF_OPERATION *moo;
+        wimax_osal_packet *msg;
+        u8 *ptr;
+
+        msg = wimax_osal_packet_alloc
+                (PC2400M_DRV_CHIPIF_CTRL_MSG_LEN +
+                 L3L4_TLV_SIZE_MODE_OF_OPERATION);
+
+        ptr = wimax_osal_packet_put(
+                msg, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+        hnd->setup_header(hnd, ptr,
+                          L4_L3_OPCODE_CMD_MODE_OF_OPERATION,
+                          L3L4_TLV_SIZE_MODE_OF_OPERATION);
+
+        moo = (struct L3L4_TLV_STR_MODE_OF_OPERATION*)
+                wimax_osal_packet_put(
+                        msg, L3L4_TLV_SIZE_MODE_OF_OPERATION);
+
+        moo->tlv.type = WIMAX_OSAL_U16_TO_LE(L3L4_TLV_TYPE_MODE_OF_OPERATION);
+        moo->tlv.length =
+                WIMAX_OSAL_U16_TO_LE(L3L4_TLV_SIZE_MODE_OF_OPERATION-
+                                     L3L4_TLV_HDR_LEN);
+        moo->mode = WIMAX_OSAL_U32_TO_LE(mode);
+
+        DM_MSG_ENQUEUE(msg, PC2400M_CD_FLAG_NONE);
+
+}
+
+/** Create and send a rf state request. This function constructs and sends to
+ *  the chipset a rf operation message. The requested RF state is provided as
+ *  parameter.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @param state desired RF state
+ *  @return none
+ */
+static void pc2400m_drv_dm_send_rf_operation_req(
+        struct pc2400m_drv_dm_if *hnd,
+        u32 state)
+{
+
+        struct L3L4_TLV_STR_RF_OPERATION *rfop;
+        wimax_osal_packet *msg;
+        u8 *ptr;
+
+        msg = wimax_osal_packet_alloc(
+                PC2400M_DRV_CHIPIF_CTRL_MSG_LEN +
+                L3L4_TLV_SIZE_RF_OPERATION);
+
+        ptr = wimax_osal_packet_put(
+                msg, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+        hnd->setup_header(hnd, ptr, L4_L3_OPCODE_CMD_RF_CONTROL,
+                L3L4_TLV_SIZE_RF_OPERATION);
+
+        /* fill the rf-operation message */
+        rfop = (struct L3L4_TLV_STR_RF_OPERATION*)
+                wimax_osal_packet_put(msg, L3L4_TLV_SIZE_RF_OPERATION);
+        rfop->tlv.type = WIMAX_OSAL_U16_TO_LE(L3L4_TLV_TYPE_RF_OPERATION);
+        rfop->tlv.length = WIMAX_OSAL_U16_TO_LE(L3L4_TLV_SIZE_RF_OPERATION-
+                                                L3L4_TLV_HDR_LEN);
+        rfop->rf_operation = WIMAX_OSAL_U32_TO_LE(state);
+
+        DM_MSG_ENQUEUE(msg, PC2400M_CD_FLAG_NONE);
+
+}
+
+
+/* DM_ENABLE_RADIO helpers */
+
+/** Handle state changes. Handle state changes specifically for the enable
+ *  radio transition.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @return none
+ */
+static void pc2400m_drv_dm_ind_report_state_enable_radio(
+        struct pc2400m_drv_dm_if *hnd)
+{
+
+        wimax_osal_assert(hnd->trans);
+        wimax_osal_assert(hnd->trans->id == PC2400M_DRV_DM_ENABLE_RADIO);
+
+        if (hnd->state == PC2400M_DRV_DM_RF_OFF(hnd) &&
+            hnd->trans->intdata.state == DM_STATE_RADIO_ON_MODE_REQ_DONE) {
+
+                hnd->trans->intdata.state = DM_STATE_RADIO_ON_REQ;
+                pc2400m_drv_dm_send_rf_operation_req(hnd, L3L4_RF_STATUS_ON);
+
+        } else if (hnd->state == PC2400M_DRV_DM_READY(hnd) &&
+                   hnd->trans->intdata.state == DM_STATE_RADIO_ON_COMPLETE) {
+
+                /* the state change completes the transition */
+                pc2400m_drv_dm_trans_complete(hnd, ESUCCESS);
+
+        }
+
+}
+
+
+/* DM_DISABLE_RADIO helpers */
+/** Handle state changes. Handle state changes specifically for the disable
+ *  radio transition.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @return none
+ */
+static void pc2400m_drv_dm_ind_report_state_disable_radio(
+        struct pc2400m_drv_dm_if *hnd)
+{
+
+        wimax_osal_assert(hnd->trans);
+        wimax_osal_assert(hnd->trans->id == PC2400M_DRV_DM_DISABLE_RADIO);
+
+        if (hnd->state == PC2400M_DRV_DM_RF_OFF(hnd) &&
+            hnd->trans->intdata.state == DM_STATE_RADIO_OFF_COMPLETE) {
+
+                /* the state change completes the transition */
+                pc2400m_drv_dm_trans_complete(hnd, ESUCCESS);
+
+        }
+
+}
+
+
+/* DM_CONFIGURE helpers */
+
+/** Handle state changes. Handle state changes specifically for the configure
+ *  transition.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @return none
+ */
+static void pc2400m_drv_dm_ind_report_state_configure(
+        struct pc2400m_drv_dm_if *hnd)
+{
+
+        wimax_osal_assert(hnd->trans);
+        wimax_osal_assert(hnd->trans->id == PC2400M_DRV_DM_CONFIGURE);
+
+
+        /* handle state changes during the DM_CONFIGURE transition */
+        if (hnd->trans->intdata.state == DM_STATE_CONFIGURE_WAITING_CONFIG &&
+            hnd->state == PC2400M_DRV_DM_CONFIG(hnd)) {
+
+                pc2400m_drv_dm_send_get_req(hnd, L4_L3_OPCODE_GET_LM_VERSION);
+                hnd->trans->intdata.state = DM_STATE_CONFIGURE_WAITING_L3M;
+
+        } else if (hnd->trans->intdata.state ==
+                   DM_STATE_CONFIGURE_WAITING_CH &&
+                   hnd->state == PC2400M_DRV_DM_INIT(hnd)) {
+
+                /* send the GET Device Info request */
+                hnd->trans->intdata.state =
+                        DM_STATE_CONFIGURE_WAITING_DETAILS;
+                pc2400m_drv_dm_send_get_req(
+                        hnd, L4_L3_OPCODE_GET_DEVICE_INFO);
+
+        }
+
+        return;
+}
+
+/** Fill capablities to wihal response.  This function copies capability
+ *  information from the chipset cache to the provided WiHAL response
+ *  structure.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @param capa WiHAL response capability structure
+ *  @return none
+ */
+static void dm_configure_fill_capabilities(
+        struct pc2400m_drv_dm_if *hnd,
+        struct t_wihal_capabilities *capa)
+{
+
+        /* copy WiHAL version */
+        wimax_osal_str_cpy(
+                capa->p_wihal_version,
+                WIHAL_VERSION_STR);
+
+        /* copy model name and manufacturer names */
+        wimax_osal_str_cpy(
+                capa->p_model_name,
+                hnd->chipset.cap.model_name);
+        wimax_osal_str_cpy(
+                capa->p_manufacturer_name,
+                hnd->chipset.cap.manuf_name);
+
+        /* copy serial number information */
+        wimax_osal_str_cpy(
+                capa->p_serial_number,
+                hnd->chipset.cap.ser_number);
+
+        /* copy firmware and hardware versions */
+        wimax_osal_mem_cpy(
+                capa->p_fw_version,
+                hnd->chipset.cap.fw_version,
+                WIHAL_VERSION_STR_LEN);
+
+        wimax_osal_mem_cpy(
+                capa->p_hw_version,
+                hnd->chipset.cap.hw_version,
+                WIHAL_VERSION_STR_LEN);
+
+        /* copy MAC address */
+        wimax_osal_mem_cpy(
+                capa->mac_address,
+                hnd->chipset.cap.mac_addr,
+                WIHAL_MAC_ADDRESS_LEN);
+
+};
+
+/** Process device details. This function copies device details information
+ *  from a chipset TLV into the chipset cache.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @param msg message containing device details information
+ *  @return none
+ */
+static boolean pc2400m_drv_dm_configure_get_device_details(
+        struct pc2400m_drv_dm_if *hnd,
+        wimax_osal_packet *msg)
+{
+
+        boolean ret = TRUE;
+        u32 len = 0;
+
+        struct L3L4_TLV_STR_DEVICE_DETAILS *dd;
+        struct L3L4_TLV_STR_ODM_INFORMATION *odm;
+        struct L3L4_TLV_STR_NVM_INFORMATION *nvm;
+
+        /* MAC address */
+        dd = (struct L3L4_TLV_STR_DEVICE_DETAILS*)
+                hnd->get_tlv(hnd, wimax_osal_packet_ptr(msg),
+                             L3L4_TLV_TYPE_DEVICE_DETAILS,
+                             NULL);
+
+        if (dd) {
+
+                wimax_osal_assert(
+                        WIMAX_OSAL_LE_TO_U16(
+                                dd->tlv.length) ==
+                        L3L4_TLV_SIZE_DEVICE_DETAILS -
+                        L3L4_TLV_HDR_LEN);
+
+                /* copy the serial model and manufacturer of the
+                   device */
+                len = WIMAX_OSAL_LE_TO_U32(
+                        dd->manufacturer_id_str_len);
+                wimax_osal_mem_set(
+                        hnd->chipset.cap.manuf_name,
+                        0x00,
+                        WIHAL_MODEL_STR_LEN);
+                pc2400m_drv_dm_value_adapt(
+                        hnd, &len, 0, WIHAL_MODEL_STR_LEN-1, 1);
+                pc2400m_drv_dm_get_utf16_string(
+                        hnd->chipset.cap.manuf_name,
+                        dd->manufacturer_id_str,
+                        len);
+
+                len = WIMAX_OSAL_LE_TO_U32(dd->model_type_str_len);
+                wimax_osal_mem_set(
+                        hnd->chipset.cap.model_name,
+                        0x00,
+                        WIHAL_MODEL_STR_LEN);
+                pc2400m_drv_dm_value_adapt(
+                        hnd, &len, 0, WIHAL_MODEL_STR_LEN-1, 1);
+                pc2400m_drv_dm_get_utf16_string(
+                        hnd->chipset.cap.model_name,
+                        dd->model_type_str,
+                        len);
+
+                /* copy the MAC address of the device */
+                wimax_osal_mem_cpy(
+                        hnd->chipset.cap.mac_addr,
+                        dd->mac_address,
+                        DM_MAC_ADDR_LEN);
+
+                wimax_osal_trace_data(
+                        PC2400M_GROUP_DM_INFO,
+                        PC2400M_TRACE_CHIP_MAC_ADDR,
+                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                        hnd->chipset.cap.mac_addr,
+                        DM_MAC_ADDR_LEN);
+
+                /* ready to rock */
+                hnd->chipset.cap.set = 1;
+        } else {
+                wimax_osal_trace_u16(
+                        PC2400M_GROUP_DM_ERROR,
+                        PC2400M_TRACE_CHIP_EXP_TLV_MISSING,
+                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                        L3L4_TLV_TYPE_DEVICE_DETAILS);
+
+                /* the MAC address is mandatory, so fail now */
+                ret = FALSE;
+
+        }
+
+        /* Serial number */
+        odm = (struct L3L4_TLV_STR_ODM_INFORMATION*)
+                hnd->get_tlv(hnd, wimax_osal_packet_ptr(msg),
+                             L3L4_TLV_TYPE_ODM_INFORMATION,
+                             NULL);
+
+        if (odm) {
+                wimax_osal_assert(
+                        WIMAX_OSAL_LE_TO_U16(
+                                odm->tlv.length) ==
+                        L3L4_TLV_SIZE_ODM_INFORMATION -
+                        L3L4_TLV_HDR_LEN);
+
+                /* copy the serial number field */
+                len = L3L4_ODM_SERIAL_NUMBER_LEN;
+                wimax_osal_mem_set(
+                        hnd->chipset.cap.ser_number,
+                        0x00,
+                        WIHAL_SERIAL_NBR_STR_LEN);
+                pc2400m_drv_dm_value_adapt(
+                        hnd, &len, 0, WIHAL_SERIAL_NBR_STR_LEN-1,
+                        1);
+                wimax_osal_mem_cpy(
+                        hnd->chipset.cap.ser_number,
+                        odm->serial_number,
+                        len);
+
+        } else {
+                wimax_osal_trace_u16(
+                        PC2400M_GROUP_DM_ERROR,
+                        PC2400M_TRACE_CHIP_EXP_TLV_MISSING,
+                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                        L3L4_TLV_TYPE_ODM_INFORMATION);
+
+                /* the ODM information is mandatory, so fail
+                   now */
+                ret = FALSE;
+
+        }
+
+        /* Serial number */
+        nvm = (struct L3L4_TLV_STR_NVM_INFORMATION*)
+                hnd->get_tlv(hnd, wimax_osal_packet_ptr(msg),
+                             L3L4_TLV_TYPE_NVM_INFORMATION,
+                             NULL);
+
+        if (nvm) {
+                wimax_osal_assert(
+                        WIMAX_OSAL_LE_TO_U16(
+                                nvm->tlv.length) ==
+                        L3L4_TLV_SIZE_NVM_INFORMATION -
+                        L3L4_TLV_HDR_LEN);
+
+                /* trace the NVM version info */
+                wimax_osal_trace_u16(
+                        PC2400M_GROUP_DM_DEBUG,
+                        PC2400M_TRACE_NVM_IMAGE_FORMAT_VERSION,
+                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                        WIMAX_OSAL_LE_TO_U16(nvm->image_version));
+
+                wimax_osal_trace_u16(
+                        PC2400M_GROUP_DM_DEBUG,
+                        PC2400M_TRACE_NVM_IMAGE_VERSION,
+                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                        WIMAX_OSAL_LE_TO_U16(nvm->content_version));
+
+        }
+
+        return ret;
+
+}
+
+/** Send configuration message. Send pre-init configuration message to the
+ *  chipset based on the values found in the chipset cache.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @return none
+ */
+static void pc2400m_drv_dm_configure_send_preconfig_req(
+        struct pc2400m_drv_dm_if *hnd)
+{
+
+        struct L3L4_TLV_STR_CONFIG_IDLE_PARAMETERS *idle;
+        struct L3L4_TLV_STR_CONFIG_LINK_DOWN_TIMER *link_down;
+        struct L3L4_TLV_STR_CONFIG_RESET_ON_ASSERT *reset;
+#ifdef PC2400M_DRV_DM_CONFIGURE_HARQ_CATEGORY_3
+        struct L3L4_TLV_STR_CONFIG_HARQ_PARAMETERS *harq;
+#endif /* PC2400M_DRV_DM_CONFIGURE_HARQ_CATEGORY_3 */
+        wimax_osal_packet *msg;
+        u32 size;
+
+        /* allocate memory for the message */
+#ifdef PC2400M_OLD_FW_SUPPORT
+        if (!IS_CHIPSET_API_BETA30(hnd) && !IS_CHIPSET_API_BETA47(hnd)) {
+
+                size = PC2400M_DRV_CHIPIF_CTRL_MSG_LEN +
+                        L3L4_TLV_SIZE_CONFIG_IDLE_PARAMETERS +
+                        L3L4_TLV_SIZE_CONFIG_LINK_DOWN_TIMER;
+
+
+        } else if (!IS_CHIPSET_API_BETA47(hnd)) {
+
+                size = PC2400M_DRV_CHIPIF_CTRL_MSG_LEN +
+                        L3L4_TLV_SIZE_CONFIG_IDLE_PARAMETERS +
+                        L3L4_TLV_SIZE_CONFIG_LINK_DOWN_TIMER +
+                        L3L4_TLV_SIZE_CONFIG_RESET_ON_ASSERT;
+
+        } else {
+#endif /* PC2400M_OLD_FW_SUPPORT */
+
+                size = PC2400M_DRV_CHIPIF_CTRL_MSG_LEN +
+                        L3L4_TLV_SIZE_CONFIG_IDLE_PARAMETERS +
+                        L3L4_TLV_SIZE_CONFIG_LINK_DOWN_TIMER +
+                        L3L4_TLV_SIZE_CONFIG_RESET_ON_ASSERT
+#ifdef PC2400M_DRV_DM_CONFIGURE_HARQ_CATEGORY_3
+                        + L3L4_TLV_SIZE_CONFIG_HARQ_PARAMETERS
+#endif /* PC2400M_DRV_DM_CONFIGURE_HARQ_CATEGORY_3 */
+                        ;
+
+#ifdef PC2400M_OLD_FW_SUPPORT
+        }
+#endif /* PC2400M_OLD_FW_SUPPORT */
+
+        msg = wimax_osal_packet_alloc(size);
+
+        /* initialize message header */
+        hnd->setup_header(
+                hnd,
+                wimax_osal_packet_put(msg, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN),
+                L4_L3_OPCODE_SET_PREINIT_CONFIG,
+                size - PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+
+        /* configure the idle timer */
+        idle = hnd->insert_tlv(hnd, msg,
+                               L3L4_TLV_TYPE_CONFIG_IDLE_PARAMETERS,
+                               L3L4_TLV_SIZE_CONFIG_IDLE_PARAMETERS);
+        wimax_osal_assert(hnd->chipset.config.idle_timer ==
+                          L3L4_IDLE_TIMER_DISABLED ||
+                          (hnd->chipset.config.idle_timer >=
+                           L3L4_IDLE_TIMER_MIN &&
+                           hnd->chipset.config.idle_timer <=
+                           L3L4_IDLE_TIMER_MAX));
+        wimax_osal_assert(!(hnd->chipset.config.idle_timer %
+                            L3L4_IDLE_TIMER_STEP));
+        idle->idle_timeout =
+                WIMAX_OSAL_U32_TO_LE(hnd->chipset.config.idle_timer);
+
+        /* configure the idle paging interval */
+        idle->idle_paging_interval =
+                WIMAX_OSAL_U32_TO_LE(hnd->chipset.config.idle_paging_interval);
+
+        /* configure the link down timer */
+        link_down = hnd->insert_tlv(hnd, msg,
+                                    L3L4_TLV_TYPE_CONFIG_LINK_DOWN_TIMER,
+                                    L3L4_TLV_SIZE_CONFIG_LINK_DOWN_TIMER);
+        link_down->link_retry_period =
+                WIMAX_OSAL_U32_TO_LE(
+                        hnd->chipset.config.signal_recovery_limit);
+
+        /* configure the reset-on-assert option */
+#ifdef PC2400M_OLD_FW_SUPPORT
+        if (IS_CHIPSET_API_BETA30(hnd)) {
+#endif /* PC2400M_OLD_FW_SUPPORT */
+
+                reset = hnd->insert_tlv(
+                        hnd, msg,
+                        L3L4_TLV_TYPE_CONFIG_RESET_ON_ASSERT,
+                        L3L4_TLV_SIZE_CONFIG_RESET_ON_ASSERT);
+#ifdef PC2400M_DRV_ENABLE_CHIPSET_RESET
+                reset->state = (u8)L3L4_CONFIG_RESET_ON_ASSERT_ON;
+#else /* PC2400M_DRV_ENABLE_CHIPSET_RESET */
+                reset->state = (u8)L3L4_CONFIG_RESET_ON_ASSERT_OFF;
+#endif /* PC2400M_DRV_ENABLE_CHIPSET_RESET */
+                reset->reserved1 = 0;
+                reset->reserved2 = 0;
+                reset->reserved3 = 0;
+
+#ifdef PC2400M_OLD_FW_SUPPORT
+        }
+#endif /* PC2400M_OLD_FW_SUPPORT */
+
+        /* configure the HARQ category */
+#ifdef PC2400M_DRV_DM_CONFIGURE_HARQ_CATEGORY_3
+#ifdef PC2400M_OLD_FW_SUPPORT
+        if (IS_CHIPSET_API_BETA47(hnd)) {
+#endif /* PC2400M_OLD_FW_SUPPORT */
+                harq = hnd->insert_tlv(
+                        hnd, msg,
+                        L3L4_TLV_TYPE_CONFIG_HARQ_PARAMETERS,
+                        L3L4_TLV_SIZE_CONFIG_HARQ_PARAMETERS);
+                harq->harq_category = (u8)L3L4_CONFIG_HARQ_CATEGORY_3;
+                harq->reserved1 = 0;
+                harq->reserved2 = 0;
+                harq->reserved3 = 0;
+#ifdef PC2400M_OLD_FW_SUPPORT
+        }
+#endif /* PC2400M_OLD_FW_SUPPORT */
+#endif /* PC2400M_DRV_DM_CONFIGURE_HARQ_CATEGORY_3 */
+
+        /* queue the message */
+        DM_MSG_ENQUEUE(msg, PC2400M_CD_FLAG_NONE);
+
+}
+
+
+/* DM_TERMINATE helpers */
+/** Handle state changes. Handle state changes specifically for the terminate
+ *  transition.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @return none
+ */
+static void pc2400m_drv_dm_ind_report_state_terminate(
+        struct pc2400m_drv_dm_if *hnd)
+{
+
+        wimax_osal_assert(hnd->trans);
+        wimax_osal_assert(hnd->trans->id == PC2400M_DRV_DM_TERMINATE);
+
+        if ((hnd->state == L3L4_SYSTEM_STATE_RF_OFF ||
+             hnd->state == L3L4_SYSTEM_STATE_CONFIG ||
+             hnd->state == L3L4_SYSTEM_STATE_INIT) &&
+            (hnd->trans->intdata.state == DM_STATE_TERMINATE_WAITING_CH)) {
+
+                /* one of the ending states for the DM_TERMINATE transition
+                   was reached, so complete the transition and move to
+                   UNITIALIZED state */
+                GOTO_STATE(hnd->state, L3L4_SYSTEM_STATE_UNINITIALIZED);
+                pc2400m_drv_dm_trans_complete(hnd, ESUCCESS);
+
+        }
+
+}
+
+
+/* DM_GET_NETWORK_STATUS helpers */
+
+/** Handle link state. Handle the link state response message from the chipset
+ *  by processing the link information and sending a response to the client if
+ *  requested.
+ *
+ *  @param cdhnd handle to the control dispatcher instance
+ *  @param msg response message
+ *  @param data user pointer carrying the device manager instance
+ *  @return none
+ */
+static void pc2400m_drv_dm_get_network_status_link_state_resp_handler(
+        struct pc2400m_drv_cd_if *cdhnd,
+        wimax_osal_packet *msg,
+        void *data)
+{
+
+        struct pc2400m_drv_dm_get_network_status_params *params =
+                (struct pc2400m_drv_dm_get_network_status_params*)data;
+        struct pc2400m_drv_dm_if *hnd = params->hnd;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->ctx);
+        u16 status = pc2400m_drv_dm_header_status(msg);
+        s16 ret;
+
+        PC2400M_DRV_UNWARN(cdhnd);
+
+        wimax_osal_assert(data);
+
+        hnd->abort_mission_cb_unregister(hnd, params->abort_cb);
+
+        ret = pc2400m_drv_dm_get_network_status_process(
+                hnd, msg, status);
+
+        /* send a response */
+        if (params->send_resp) {
+
+                /* the values for the response are conveniently
+                   available in the chipset cache. */
+                priv->send_network_status_resp(
+                        priv->ctx,
+                        PC2400M_DRV_GET_WIHAL_ERROR(ret),
+                        hnd->chipset.trans.network_status,
+                        hnd->chipset.link.bs_id,
+                        &hnd->chipset.link.channel_plan,
+                        hnd->chipset.link.rssi,
+                        hnd->chipset.link.cinr,
+                        params->client_data);
+
+
+        }
+
+        wimax_osal_packet_free(&msg);
+        wimax_osal_mem_free((void**)&params);
+
+}
+
+/** Handle link state abort. Handle the link state abort, which occurred
+ *  while the link state was queried.
+ *
+ *  @param cdhnd handle to the device manager instance
+ *  @param data cookie value
+ *  @return none
+ */
+static void pc2400m_drv_dm_get_network_status_link_state_abort_handler(
+        struct pc2400m_drv_dm_if *hnd,
+        void *data)
+{
+
+        struct pc2400m_drv_dm_get_network_status_params *params =
+                (struct pc2400m_drv_dm_get_network_status_params*)data;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->ctx);
+
+        wimax_osal_assert(data);
+
+        hnd->abort_mission_cb_unregister(hnd, params->abort_cb);
+
+        /* send a response */
+        if (params->send_resp) {
+
+                /* the values for the response are conveniently
+                   available in the chipset cache. */
+                priv->send_network_status_resp(
+                        priv->ctx,
+                        PC2400M_DRV_GET_WIHAL_ERROR(-EGENERAL),
+                        hnd->chipset.trans.network_status,
+                        hnd->chipset.link.bs_id,
+                        &hnd->chipset.link.channel_plan,
+                        hnd->chipset.link.rssi,
+                        hnd->chipset.link.cinr,
+                        params->client_data);
+
+
+        }
+
+        wimax_osal_mem_free((void**)&params);
+
+}
+
+
+/** Query and return current network status. Send a get link status request to
+ *  the chipset to find the current network status, and send that to the
+ *  client. This function will return (call the priv->send_network_status_resp)
+ *  with failure code (-ESTATE) immediately, unless the current state is
+ *  IDLE or DATA_PATH_CONNECTED.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @param client_data data to be passed back to the client
+ *  @return none
+ */
+static void pc2400m_drv_dm_get_network_status(
+        struct pc2400m_drv_dm_if *hnd,
+        void *client_data)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->ctx);
+        struct pc2400m_drv_dm_get_network_status_params *params;
+        wimax_osal_packet *msg;
+        u8 *ptr;
+
+        /* only proceed with the network status query, if currently
+           connected */
+        if ((hnd->state != PC2400M_DRV_DM_DATA_PATH_CONNECTED(hnd)) &&
+            (hnd->state != PC2400M_DRV_DM_IDLE(hnd))) {
+
+                /* return the values currently in the chipset cache for
+                   the various items in the result. the client must not rely
+                   on these in any level however, as the erroneous status
+                   code invalidates them. */
+                priv->send_network_status_resp(
+                        priv->ctx,
+                        PC2400M_DRV_GET_WIHAL_ERROR(-ESTATE),
+                        hnd->chipset.trans.network_status,
+                        hnd->chipset.link.bs_id,
+                        &hnd->chipset.link.channel_plan,
+                        hnd->chipset.link.rssi,
+                        hnd->chipset.link.cinr,
+                        client_data);
+
+        } else {
+
+                /* send get link status request */
+                msg = wimax_osal_packet_alloc(PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+
+                ptr = wimax_osal_packet_put(
+                        msg, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+                hnd->setup_header(hnd, ptr,L4_L3_OPCODE_GET_LINK_STATUS, 0);
+
+                /* allocate memory for operation params */
+                params = wimax_osal_mem_alloc(
+                        sizeof(struct
+                               pc2400m_drv_dm_get_network_status_params));
+                params->hnd = hnd;
+                params->client_data = client_data;
+                params->send_resp = TRUE;
+
+                params->abort_cb = hnd->abort_mission_cb_register(
+                        hnd,
+                        pc2400m_drv_dm_get_network_status_link_state_abort_handler,
+                        params);
+
+                hnd->cd->msg_enqueue(
+                        hnd->cd, msg,
+                        pc2400m_drv_dm_get_network_status_link_state_resp_handler,
+                        (void*)params, PC2400M_CD_FLAG_NONE);
+
+        }
+
+}
+
+
+/** Query current nw status. Send a get link status request to the chipset to
+ *  find the current network status. The information is used for internal
+ *  handover detection.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @return none
+ */
+static void pc2400m_drv_dm_get_network_status_for_handover(
+        struct pc2400m_drv_dm_if *hnd)
+{
+
+        struct pc2400m_drv_dm_get_network_status_params *params;
+        wimax_osal_packet *msg;
+        u8 *ptr;
+
+        /* send get link status request */
+        msg = wimax_osal_packet_alloc(PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+
+        ptr = wimax_osal_packet_put(msg, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+        hnd->setup_header(hnd, ptr,L4_L3_OPCODE_GET_LINK_STATUS, 0);
+
+        /* allocate memory for operation params */
+        params = wimax_osal_mem_alloc(
+                sizeof(struct pc2400m_drv_dm_get_network_status_params));
+        params->hnd = hnd;
+        params->client_data = NULL;
+        params->send_resp = FALSE;
+
+        params->abort_cb = hnd->abort_mission_cb_register(
+                hnd,
+                pc2400m_drv_dm_get_network_status_link_state_abort_handler,
+                params);
+
+        hnd->cd->msg_enqueue(
+                hnd->cd, msg,
+                pc2400m_drv_dm_get_network_status_link_state_resp_handler,
+                (void*)params, PC2400M_CD_FLAG_NONE);
+
+}
+
+
+/** Process the channel info TLV. Process the channel info TLV by finding it
+ *  from the message, and updating the channel information into the chipset
+ *  cache. This is processed before link status TLV so that the channel info is
+ *  up-to-date if the BS has changed.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @param msg message containing the TLV
+ *  @return none
+ */
+static void pc2400m_drv_dm_get_network_status_process_channel_info(
+        struct pc2400m_drv_dm_if *hnd,
+        wimax_osal_packet *msg)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->ctx);
+        struct L3L4_TLV_STR_CHANNEL_INFO *chinfo;
+
+        /* get the channel info TLV */
+        chinfo = (struct L3L4_TLV_STR_CHANNEL_INFO*)
+                hnd->get_tlv(hnd, wimax_osal_packet_ptr(msg),
+                             L3L4_TLV_TYPE_CHANNEL_INFO, NULL);
+        if (chinfo) {
+
+                /* update the channel plan in the chipset cache */
+                PC2400M_DRV_GET_WIHAL_CHANNEL_PLAN(
+                        priv,
+                        &hnd->chipset.link.channel_plan,
+                        chinfo->frequency,
+                        chinfo->bandwidth,
+                        chinfo->fft,
+                        chinfo->preambles);
+
+                hnd->chipset.link.channel_set |=
+                        PC2400M_DRV_DM_CHIPSET_CHANNEL_SET_CHANNEL_INFO;
+
+        }
+
+        return;
+
+}
+
+/** Process the link status TLV. Process the link status TLV by finding it from
+ *  the message, and updating the link information into the chipset cache. Once
+ *  the information is updated perform a handover check to see whether the BS
+ *  has changed.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @param msg message containing the TLV
+ *  @return none
+ */
+static void pc2400m_drv_dm_get_network_status_process_link_status(
+        struct pc2400m_drv_dm_if *hnd,
+        wimax_osal_packet *msg)
+{
+
+        struct L3L4_TLV_STR_LINK_STATUS *ls;
+
+        /* find the link status TLV */
+        ls = (struct L3L4_TLV_STR_LINK_STATUS*)
+                hnd->get_tlv(hnd, wimax_osal_packet_ptr(msg),
+                             L3L4_TLV_TYPE_LINK_STATUS, NULL);
+        if (ls) {
+
+                /* update the chipset cache with the returned values */
+                hnd->chipset.link.rssi =
+                        PC2400M_DRV_GET_WIHAL_RSSI(priv, ls->rx_rssi);
+                hnd->chipset.link.cinr =
+                        PC2400M_DRV_GET_WIHAL_CINR(priv, ls->rx_cinr);
+                wimax_osal_mem_cpy(
+                        hnd->chipset.link.bs_id, ls->bsid, L3L4_BSID_LENGTH);
+                hnd->chipset.link.channel_set |=
+                        PC2400M_DRV_DM_CHIPSET_CHANNEL_SET_BSID;
+
+                /* check for handovers */
+                pc2400m_drv_dm_handover_check(hnd);
+
+        }
+
+        return;
+
+}
+
+
+/** Process network status. Process the network status message (link status and
+ *  channel info TLV)
+ *
+ *  @param hnd handle to the device manager instance
+ *  @param msg message with the network status
+ *  @param status status code of the message
+ *  @return ESUCCESS if the message was OK, -EGENERAL if the message was
+ *          erroneous
+ */
+static s32 pc2400m_drv_dm_get_network_status_process(
+        struct pc2400m_drv_dm_if *hnd,
+        wimax_osal_packet *msg,
+        u16 status)
+{
+
+        s16 ret = ESUCCESS;
+
+        /* if the request failed, skip parsing of the message */
+        if (!L3L4_SUCCESS(status)) {
+                ret = -EGENERAL;
+                goto out;
+        }
+
+        /* get the channel info TLV */
+        pc2400m_drv_dm_get_network_status_process_channel_info(hnd, msg);
+
+        /* find the link status TLV */
+        pc2400m_drv_dm_get_network_status_process_link_status(hnd, msg);
+
+ out:
+        return ret;
+
+}
+
+
+/* Handover checker helpers */
+
+/** Check for handover. Check for handover by comparing information on a
+ *  previous basestation and the current basestation. If different, send
+ *  indication to the client.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @return none
+ */
+static void pc2400m_drv_dm_handover_check(struct pc2400m_drv_dm_if *hnd)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->ctx);
+
+        /* only perform the checks in DATA_PATH_CONNECTED state */
+        if (hnd->state == PC2400M_DRV_DM_DATA_PATH_CONNECTED(hnd) ||
+            hnd->state == PC2400M_DRV_DM_IDLE(hnd)) {
+
+                /* compare the current BSID with the last one to detect
+                   a handover */
+                if ((hnd->chipset.link.channel_set &
+                     PC2400M_DRV_DM_CHIPSET_CHANNEL_SET_LAST_BSID) &&
+                    wimax_osal_mem_cmp(
+                            hnd->chipset.link.bs_id,
+                            hnd->chipset.link.last_bs_id,
+                            L3L4_BSID_LENGTH)) {
+
+                        /* send an indication to the client */
+                        priv->send_network_status_ind(
+                                hnd->ctx,
+                                E_WIHAL_NETWORK_STATUS_HANDOVER,
+                                E_WIHAL_NETWORK_STATUS_ERR_NONE,
+                                hnd->chipset.link.bs_id,
+                                &hnd->chipset.link.channel_plan,
+                                0,
+                                NULL);
+
+                }
+
+                /* reset the handover timer */
+                pc2400m_drv_dm_handover_timer_set(hnd, TRUE);
+
+                /* update the last bsid value to reflect current BSID */
+                hnd->chipset.link.channel_set |=
+                        PC2400M_DRV_DM_CHIPSET_CHANNEL_SET_LAST_BSID;
+                wimax_osal_mem_cpy(
+                        hnd->chipset.link.last_bs_id,
+                        hnd->chipset.link.bs_id,
+                        L3L4_BSID_LENGTH);
+
+        }
+
+        return;
+
+}
+
+/** Handle handover timer timeout. Get the chipset network status to update
+ *  information on the current basestation.
+ *
+ *  @param id identifier of expired timer
+ *  @param hnd user data carrying a handle to the device manager instance
+ *  @return none
+ */
+static void pc2400m_drv_dm_handover_timer_handler(
+        wimax_osal_timer_handle id, void *data)
+{
+
+        struct pc2400m_drv_dm_if *hnd = (struct pc2400m_drv_dm_if*)data;
+
+        wimax_osal_assert(id == hnd->handover_timer);
+        hnd->handover_timer = 0;
+
+        /* request status update for handover check purposes */
+        pc2400m_drv_dm_get_network_status_for_handover(hnd);
+
+}
+
+/** (Re)start/stop handover timer. Start or restart the handover timer, or
+ *  cancel the timer if so requested.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @param enable TRUE to (re)start the timer, FALSE to stop the timer
+ *  @return none
+ */
+static void pc2400m_drv_dm_handover_timer_set(
+        struct pc2400m_drv_dm_if *hnd,
+        boolean enable)
+{
+
+        /* cancel a possibly existing timer */
+        wimax_osal_timer_cancel(hnd->handover_timer);
+        hnd->handover_timer = 0;
+
+        if (enable) {
+
+                /* start a new timer */
+                hnd->handover_timer = wimax_osal_timer_create(
+                        PC2400M_DRV_DM_HANDOVER_CHECK_INTERVAL,
+                        WIMAX_OSAL_TR_10MS,
+                        FALSE,
+                        (void*)hnd,
+                        pc2400m_drv_dm_handover_timer_handler);
+
+        }
+
+}
+
+
+/** Interrupt handler function.  Handle an interrupt by calling the control
+ *  dispatcher interrupt handling routine.
+ *
+ *  @param ctx handle to the OSAL context
+ *  @return none
+ */
+static void pc2400m_drv_dm_interrupt(wimax_osal_context *ctx)
+{
+        struct pc2400m_private *priv  = wimax_osal_ctx_priv_get(ctx);
+        wimax_osal_assert(priv->dm->cd);
+        priv->dm->cd->interrupt(priv->dm->cd);
+}
+
+
+/** Handle control dispatcher suspend complete. Handle the completion of
+ *  suspend of the control dispatcher by completing the suspend transition.
+ *
+ *  @param cdhnd handle to the control dispatcher instance
+ *  @param data user data used to carry the device manager instance
+ *  @return none
+ */
+static void pc2400m_drv_dm_suspend_resp(
+        struct pc2400m_drv_cd_if *cdhnd,
+        void *data)
+{
+
+        struct pc2400m_drv_dm_if *hnd = (struct pc2400m_drv_dm_if*)data;
+
+        PC2400M_DRV_UNWARN(cdhnd);
+
+        /* once the control dispatcher has also suspended (completed any
+           ongoing operation) we are ready to go down */
+        pc2400m_drv_dm_trans_complete(hnd, ESUCCESS);
+
+}
+
+
+
+/** Execute the next transition in queue. Start processing the next transition
+ *  in queue unless another transition is ongoing or the device manager has
+ *  been suspended. If an abortable background transition is ongoing, cancel it
+ *  before executing the new transition.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @return none
+ */
+static void pc2400m_drv_dm_trans_execute(struct pc2400m_drv_dm_if *hnd)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->ctx);
+        s32 ret = ESUCCESS;
+
+        /* if a transition is ongoing or there are no items in the queue,
+           bail out */
+        if (hnd->trans || !wimax_osal_list_first(&(hnd->transq)))
+                goto out;
+
+        hnd->trans = wimax_osal_list_pop(&(hnd->transq));
+
+        /* if suspended, do not execute unless this is the resume operation */
+        if (hnd->flags & PC2400M_DRV_DM_FLAGS_SUSPENDED &&
+            hnd->trans->id != PC2400M_DRV_DM_RESUME) {
+                wimax_osal_list_push(&(hnd->transq), hnd->trans);
+                hnd->trans = NULL;
+                goto out;
+        }
+
+        /* cancel the background transition before executing other
+           transitions */
+        if (hnd->bg) {
+
+                /* cancel the background transition */
+                hnd->bg->cancel(hnd->bg);
+
+                /* return the current transition to the queue */
+                wimax_osal_list_push(&(hnd->transq), hnd->trans);
+                hnd->trans = NULL;
+
+                /* execute the background transition synchronization
+                   transition first */
+                hnd->trans =
+                        pc2400m_drv_dm_trans_new(hnd, PC2400M_DRV_DM_BG_SYNCH,
+                                                 NULL, NULL, NULL, NULL);
+        }
+
+        wimax_osal_trace_u32(PC2400M_GROUP_DM_DEBUG,
+                             PC2400M_TRACE_TRANSITION_START,
+                             WIMAX_OSAL_TRACE_PRIORITY_DEBUG, hnd->trans->id);
+
+        /* start the timeout timer */
+#ifdef PC2400M_DRV_DM_SCAN_STOP_TIMEOUT
+        if (hnd->trans->id == PC2400M_DRV_DM_STOP_SCAN ||
+            hnd->trans->id == PC2400M_DRV_DM_BG_SYNCH)
+                hnd->trans->timerhnd =
+                        wimax_osal_timer_create(
+                                PC2400M_DRV_DM_SCAN_STOP_TIMEOUT,
+                                WIMAX_OSAL_TR_10MS,
+                                0,
+                                (void*)hnd,
+                                pc2400m_drv_dm_timeout_handler);
+        else
+#endif /* PC2400M_DRV_DM_SCAN_STOP_TIMEOUT */
+                hnd->trans->timerhnd =
+                        wimax_osal_timer_create(
+                                PC2400M_DRV_DM_TRANSITION_TIMEOUT,
+                                WIMAX_OSAL_TR_10MS,
+                                0,
+                                (void*)hnd,
+                                pc2400m_drv_dm_timeout_handler);
+
+        /* start handling the transition */
+        switch (hnd->trans->id) {
+        case PC2400M_DRV_DM_ENABLE_RADIO:
+        {
+
+                /* check prereq state */
+                if (hnd->state != PC2400M_DRV_DM_INIT(hnd) &&
+                    hnd->state != PC2400M_DRV_DM_RF_OFF(hnd) &&
+                    hnd->state != PC2400M_DRV_DM_READY(hnd))
+                        goto err1;
+
+                /* if in INIT state, quietly perform the mode of operation
+                   request first to change state */
+                if (hnd->state == PC2400M_DRV_DM_INIT(hnd)) {
+
+                        /* enqueue request to select "normal" operation mode.
+                           RF enable will be requested once that completes. */
+                        hnd->trans->intdata.state = DM_STATE_RADIO_ON_MODE_REQ;
+                        pc2400m_drv_dm_send_mode_of_operation_req
+                                (hnd, L3L4_MODE_OF_OPERATION_NORMAL);
+
+                } else if (hnd->state == PC2400M_DRV_DM_RF_OFF(hnd)) {
+
+                        /* enqueue request to switch on RF */
+                        hnd->trans->intdata.state = DM_STATE_RADIO_ON_REQ;
+                        pc2400m_drv_dm_send_rf_operation_req(
+                                hnd, L3L4_RF_STATUS_ON);
+                } else {
+
+                        /* the RF is already on, so just complete */
+                        pc2400m_drv_dm_trans_complete(hnd, ESUCCESS);
+
+                }
+                break;
+        }
+
+        case PC2400M_DRV_DM_DISABLE_RADIO:
+        {
+
+                /* check prereq state */
+                if (hnd->state == PC2400M_DRV_DM_UNINITIALIZED(hnd) ||
+                    hnd->state == PC2400M_DRV_DM_CONFIG(hnd) ||
+                    hnd->state == PC2400M_DRV_DM_PRODUCTION(hnd) ||
+                    hnd->state == PC2400M_DRV_DM_RF_SHUTDOWN(hnd))
+                        goto err1;
+
+                if (hnd->state == PC2400M_DRV_DM_RF_OFF(hnd) ||
+                    hnd->state == PC2400M_DRV_DM_INIT(hnd)) {
+
+                        /* the RF is already off, so just complete */
+                        pc2400m_drv_dm_trans_complete(hnd, ESUCCESS);
+
+                } else {
+
+                        /* send radio off request to the chipset */
+                        hnd->trans->intdata.state = DM_STATE_RADIO_OFF_REQ;
+                        pc2400m_drv_dm_send_rf_operation_req(
+                                hnd, L3L4_RF_STATUS_OFF);
+                }
+                break;
+        }
+
+
+        case PC2400M_DRV_DM_START_SCAN:
+        {
+
+                struct pc2400m_drv_dm_bg_scan_nap_params *params;
+                s32 ret;
+
+                /* scan parameters */
+                wimax_osal_assert(hnd->trans->params);
+                params = (struct pc2400m_drv_dm_bg_scan_nap_params*)
+                        hnd->trans->params;
+
+                /* check prereq state */
+                if (hnd->state != PC2400M_DRV_DM_READY(hnd)) {
+                        priv->send_search_nap_resp(
+                                priv->ctx,
+                                PC2400M_DRV_GET_WIHAL_ERROR(-ESTATE),
+                                params->client_data);
+                        goto err1;
+                }
+
+                /* initialize a new background transition object to
+                   perform the scanning */
+                hnd->bg = pc2400m_drv_dm_bg_if_new(hnd);
+                ret = hnd->bg->initialize(
+                        hnd->bg, NULL, PC2400M_DRV_DM_BG_SCAN_NAP, params);
+
+                /* the start transition is the complete */
+                if (ret != ESUCCESS) {
+                        hnd->bg->cleanup(hnd->bg);
+                        hnd->bg = NULL;
+                }
+
+                pc2400m_drv_dm_trans_complete(hnd, ret);
+                break;
+        }
+
+        case PC2400M_DRV_DM_START_SCAN_NSP:
+        {
+
+                struct pc2400m_drv_dm_bg_scan_nsp_params *params;
+                s32 ret;
+
+                /* scan parameters */
+                wimax_osal_assert(hnd->trans->params);
+                params = (struct pc2400m_drv_dm_bg_scan_nsp_params*)
+                        hnd->trans->params;
+
+                /* check prereq state */
+                if (hnd->state != PC2400M_DRV_DM_READY(hnd)) {
+                        priv->send_search_nsp_resp(
+                                priv->ctx,
+                                PC2400M_DRV_GET_WIHAL_ERROR(-ESTATE),
+                                params->req.nap_id,
+                                0,
+                                E_WIHAL_NAP_AND_NSP_NA,
+                                0,
+                                NULL,
+                                params->client_data);
+                        goto err1;
+                }
+
+                /* initialize a new background transition object to
+                   perform the nsp discovery */
+                hnd->bg = pc2400m_drv_dm_bg_if_new(hnd);
+                ret = hnd->bg->initialize(
+                        hnd->bg, NULL, PC2400M_DRV_DM_BG_SCAN_NSP, params);
+
+                /* if the initialization failed, remove the instance */
+                if (ret != ESUCCESS) {
+                        hnd->bg->cleanup(hnd->bg);
+                        hnd->bg = NULL;
+                }
+
+                pc2400m_drv_dm_trans_complete(hnd, ret);
+                break;
+        }
+
+        case PC2400M_DRV_DM_CONNECT:
+        {
+
+                /* check prereq state */
+                if ((hnd->state != PC2400M_DRV_DM_READY(hnd)) &&
+                    (hnd->state != PC2400M_DRV_DM_DATA_PATH_CONNECTED(hnd)) &&
+                    (hnd->state != PC2400M_DRV_DM_IDLE(hnd)))
+                        goto err1;
+
+                wimax_osal_assert(hnd->trans->params);
+
+                if (hnd->state == PC2400M_DRV_DM_READY(hnd)) {
+
+                        /* create background transition handler for connect */
+                        hnd->bg = pc2400m_drv_dm_bg_if_new(hnd);
+                        ret = hnd->bg->initialize(
+                                hnd->bg, NULL, PC2400M_DRV_DM_BG_CONNECT,
+                                hnd->trans->params);
+
+                        /* if the initialization failed, remove the instance */
+                        if (ret != ESUCCESS) {
+                                hnd->bg->cleanup(hnd->bg);
+                                hnd->bg = NULL;
+                        }
+
+                }
+
+                pc2400m_drv_dm_trans_complete(hnd, ret);
+                break;
+        }
+
+        case PC2400M_DRV_DM_DISCONNECT:
+
+                if (hnd->state == PC2400M_DRV_DM_READY(hnd)) {
+                        /* the system is in disconnected state */
+                        pc2400m_drv_dm_trans_complete(hnd, ESUCCESS);
+                        break;
+                } else if (hnd->state !=
+                           PC2400M_DRV_DM_DATA_PATH_CONNECTED(hnd) &&
+                           hnd->state != PC2400M_DRV_DM_IDLE(hnd)) {
+                        goto err1;
+                }
+
+                /* send the disconnect command to the chipset */
+                hnd->bg = pc2400m_drv_dm_bg_if_new(hnd);
+                ret = hnd->bg->initialize(
+                        hnd->bg, NULL, PC2400M_DRV_DM_BG_DISCONNECT,
+                        hnd->trans->params);
+                wimax_osal_assert(ret == ESUCCESS);
+
+                pc2400m_drv_dm_trans_complete(hnd, ESUCCESS);
+                break;
+
+        case PC2400M_DRV_DM_CONFIGURE:
+        {
+                /* this transition can occur in any state, although
+                   specific parameters may be valid only in specific
+                   states */
+                struct pc2400m_drv_dm_configure_params *config_params;
+
+                wimax_osal_assert(hnd->trans->params);
+
+                config_params = (struct pc2400m_drv_dm_configure_params*)
+                        hnd->trans->params;
+
+                /* during boot, all fields must be specified once */
+                wimax_osal_assert(
+                        (hnd->flags & PC2400M_DRV_DM_FLAGS_CONFIGURED) ||
+                        ((config_params->req.config_mask &
+                          E_WIHAL_CONFIG_MASK_SIGNAL_RECOVERY_LIMIT) &&
+                         (config_params->req.config_mask &
+                          E_WIHAL_CONFIG_MASK_IDLE_TIMER) &&
+                         (config_params->req.config_mask &
+                          E_WIHAL_CONFIG_MASK_HANDOVER_LOCK) &&
+                         (config_params->req.config_mask &
+                          E_WIHAL_CONFIG_MASK_IDLE_PAGING_INTERVAL) &&
+                         (config_params->req.config_mask &
+                          E_WIHAL_CONFIG_MASK_SLEEP_TIMER)));
+
+                if (config_params->req.config_mask &
+                    E_WIHAL_CONFIG_MASK_SIGNAL_RECOVERY_LIMIT) {
+                        hnd->chipset.config.signal_recovery_limit =
+                                config_params->req.signal_recovery_limit;
+                }
+
+                if (config_params->req.config_mask &
+                    E_WIHAL_CONFIG_MASK_IDLE_TIMER) {
+                        hnd->chipset.config.idle_timer =
+                                config_params->req.idle_timer;
+
+                        /* the PC2400M requires the range to be 100-300000 in
+                           100 increments. make it so. */
+                        pc2400m_drv_dm_value_adapt(
+                                hnd,
+                                &hnd->chipset.config.idle_timer,
+                                L3L4_IDLE_TIMER_MIN,
+                                L3L4_IDLE_TIMER_MAX,
+                                L3L4_IDLE_TIMER_STEP);
+
+                }
+
+                if (config_params->req.config_mask &
+                    E_WIHAL_CONFIG_MASK_HANDOVER_LOCK) {
+                        wimax_osal_assert(config_params->req.handover_scheme !=
+                               E_WIHAL_HANDOVER_SCHEME_NA);
+                        hnd->chipset.config.handover_scheme =
+                                config_params->req.handover_scheme;
+                }
+
+                if (config_params->req.config_mask &
+                    E_WIHAL_CONFIG_MASK_BS_ID) {
+                        wimax_osal_mem_cpy(
+                                hnd->chipset.config.bsid,
+                                config_params->req.bsid,
+                                WIHAL_BSID_LENGTH);
+                }
+
+                if (config_params->req.config_mask &
+                    E_WIHAL_CONFIG_MASK_IDLE_PAGING_INTERVAL) {
+                        hnd->chipset.config.sleep_timer =
+                                config_params->req.sleep_timer;
+
+                        /* the pc2400m requires the sleep timer to be 0 or
+                           between 100 and 300000 with 100ms granularity. */
+                        pc2400m_drv_dm_value_adapt(
+                                hnd,
+                                &hnd->chipset.config.sleep_timer,
+                                L3L4_SLEEP_TIMER_MIN,
+                                L3L4_SLEEP_TIMER_MAX,
+                                L3L4_SLEEP_TIMER_STEP);
+
+                }
+
+                if (config_params->req.config_mask &
+                    E_WIHAL_CONFIG_MASK_SLEEP_TIMER) {
+
+#define PC2400M_DRV_DM_MS_PER_FRAME 5
+                        hnd->chipset.config.idle_paging_interval =
+                                config_params->req.idle_paging_interval /
+                                PC2400M_DRV_DM_MS_PER_FRAME;
+
+                }
+
+                /* on the first configure invocation, perform also
+                   initialization and startup queries to get version
+                   and mac address info */
+                if (!(hnd->flags & PC2400M_DRV_DM_FLAGS_CONFIGURED)) {
+
+                        /* perform preconfig and init once shifted to the
+                           CONFIG state */
+                        hnd->trans->intdata.state =
+                                DM_STATE_CONFIGURE_WAITING_CONFIG;
+                        pc2400m_drv_dm_ind_report_state_configure(hnd);
+                        hnd->flags |= PC2400M_DRV_DM_FLAGS_CONFIGURED;
+
+                } else {
+
+                        /* complete immediately relying on the cached chipset
+                           info - nothing will be updated to the chipset */
+                        dm_configure_fill_capabilities(
+                                hnd, &(config_params->capa));
+                        pc2400m_drv_dm_trans_complete(hnd, ESUCCESS);
+
+                }
+                break;
+        }
+
+        case PC2400M_DRV_DM_TERMINATE:
+
+                /* terminate can occur in any state */
+                if (hnd->state != L3L4_SYSTEM_STATE_UNINITIALIZED) {
+                        hnd->trans->intdata.state = DM_STATE_TERMINATE_REQ;
+                        pc2400m_drv_dm_send_get_req(
+                                hnd, L4_L3_OPCODE_CMD_TERMINATE);
+                } else {
+                        pc2400m_drv_dm_trans_complete(hnd, ESUCCESS);
+                }
+                break;
+
+        case PC2400M_DRV_DM_PRODUCTION:
+
+                if (hnd->state != PC2400M_DRV_DM_INIT(hnd))
+                        goto err1;
+
+                pc2400m_drv_dm_send_mode_of_operation_req
+                        (hnd, L3L4_MODE_OF_OPERATION_PRODUCTION);
+
+
+                break;
+
+        case PC2400M_DRV_DM_SUSPEND:
+
+                /* stop execution of the transition queue,
+                   and then immediately complete */
+                hnd->flags |= PC2400M_DRV_DM_FLAGS_SUSPENDED;
+
+                /* suspend the control dispatcher to suspend */
+                hnd->cd->suspend(
+                        hnd->cd,
+                        pc2400m_drv_dm_suspend_resp,
+                        (void*)hnd);
+                break;
+
+        case PC2400M_DRV_DM_RESUME:
+
+                /* resume execution of the transition queue,
+                   and then immediately complete */
+                hnd->flags &= (~PC2400M_DRV_DM_FLAGS_SUSPENDED);
+                hnd->cd->resume(hnd->cd);
+                pc2400m_drv_dm_trans_complete(hnd, ESUCCESS);
+                break;
+
+        case PC2400M_DRV_DM_BG_SYNCH:
+
+                /* wait for a background transition to complete */
+                wimax_osal_assert(hnd->bg);
+                break;
+
+
+        case PC2400M_DRV_DM_STOP_SCAN:
+
+                /* the background scan transition will have been stopped
+                   by the time this transition gets to execute. */
+                if (hnd->state == PC2400M_DRV_DM_READY(hnd)) {
+                        pc2400m_drv_dm_trans_complete(hnd, ESUCCESS);
+                } else {
+                        pc2400m_drv_dm_trans_complete(hnd, -ESTATE);
+                }
+                break;
+
+        case PC2400M_DRV_DM_STOP_SCAN_NSP:
+
+                /* the background NSP discovery transition will have been
+                   stopped by the time this transition gets to execute. */
+                if (hnd->state == PC2400M_DRV_DM_READY(hnd)) {
+                        pc2400m_drv_dm_trans_complete(hnd, ESUCCESS);
+                } else {
+                        pc2400m_drv_dm_trans_complete(hnd, -ESTATE);
+                }
+                break;
+
+        };
+
+
+        goto out;
+
+ err1:
+        ret = -ESTATE;
+        wimax_osal_trace_u32(PC2400M_GROUP_DM_ERROR,
+                             PC2400M_TRACE_INVALID_DM_STATE,
+                             WIMAX_OSAL_TRACE_PRIORITY_DEBUG, hnd->state);
+
+        pc2400m_drv_dm_trans_complete(hnd, ret);
+
+ out:
+        return;
+
+}
+
+/** Complete the execution of a transition. Handle the completion of a
+ *  transition by freeing generic resources taken by the transition, calling
+ *  the transition completion handler, and calling the execute function to
+ *  execute the next transition in the queue.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @param status end status of the completing transition
+ *  @return none
+ */
+static void pc2400m_drv_dm_trans_complete(
+        struct pc2400m_drv_dm_if *hnd,
+        s32 status)
+{
+
+        struct pc2400m_drv_dm_trans *trans = hnd->trans;
+
+        /* avoid recursive completions in error handling */
+        if (trans->flags & DM_TRANS_FLAG_COMPLETING)
+                goto out;
+        trans->flags |= DM_TRANS_FLAG_COMPLETING;
+
+        /* clear current transition data */
+        wimax_osal_timer_cancel(hnd->trans->timerhnd);
+        trans->timerhnd = 0;
+
+        /* call the transition callback */
+        if (trans->cb)
+                /* -ECANCEL is not a valid state in WiHAL */
+                hnd->trans->cb(hnd, (status==-ECANCEL?-EGENERAL:status),
+                               trans->params, trans->cb_data,
+                               trans->cb_cl_data);
+
+        /* cleanup transition */
+        hnd->trans = NULL;
+        wimax_osal_mem_free((void**)&trans);
+
+        /* start next queued transition */
+        if (status != -ECANCEL)
+                pc2400m_drv_dm_trans_execute(hnd);
+
+ out:
+        return;
+}
+
+
+/** Abort the currently executing transition. Violently abort the currently
+ *  executing transition. The transition communication with the chipset may be
+ *  amidst and there is no quarantee of any sane continuation. This function is
+ *  to be used for cancelling a transition if the chipset is dead or will be
+ *  dead shortly.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @return none
+ */
+static void pc2400m_drv_dm_trans_abort(struct pc2400m_drv_dm_if *hnd)
+{
+
+        /* call the transition completion, if the transition exists */
+        if (!hnd->trans)
+                goto err1;
+
+        pc2400m_drv_dm_trans_complete(hnd, -ECANCEL);
+
+ err1:
+        return;
+}
+
+
+/** Create new transition. Create and fill a transition structure, and return
+ *  pointer to it.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @param id type of the transition
+ *  @param data parameter data structure for the transition
+ *  @param trans_cb completion callback for the transition
+ *  @param trans_data data pointer to be carried to the callback
+ *  @param client_data secondary pointer also to be carried to the callback
+ *  @return pointer to the allocated transition structure
+ */
+static struct pc2400m_drv_dm_trans *pc2400m_drv_dm_trans_new(
+        struct pc2400m_drv_dm_if *hnd,
+        enum pc2400m_drv_dm_transitions id,
+        void *data,
+        dm_transition_cb trans_cb,
+        void *trans_data,
+        void *client_data)
+{
+
+        struct pc2400m_drv_dm_trans *trans_info;
+
+        /* enqueue transition */
+        trans_info = (struct pc2400m_drv_dm_trans*)wimax_osal_mem_alloc
+                  (sizeof(struct pc2400m_drv_dm_trans));
+
+        wimax_osal_mem_set(trans_info, 0x00,
+                           sizeof(struct pc2400m_drv_dm_trans));
+        trans_info->hnd = hnd;
+        trans_info->id = id;
+        trans_info->params = data;
+        trans_info->cb_data = trans_data;
+        trans_info->cb_cl_data = client_data;
+        trans_info->cb = trans_cb;
+        WIMAX_OSAL_LIST_ELEM_HDR_INIT(&(trans_info->list));
+
+        return trans_info;
+
+}
+
+
+/** Handler transition timeout.
+ *
+ *  @param id identifier of the expired timer
+ *  @param data user data used to carry the device manager instance
+ *  @return none
+ */
+static void pc2400m_drv_dm_timeout_handler(
+        wimax_osal_timer_handle id,
+        void* data)
+{
+
+        struct pc2400m_drv_dm_if *hnd = (struct pc2400m_drv_dm_if*)data;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->ctx);
+
+        PC2400M_DRV_UNWARN(id);
+
+        wimax_osal_assert(hnd->trans);
+
+        priv->ref(priv);
+
+        wimax_osal_trace_u32(PC2400M_GROUP_DM_ERROR,
+                             PC2400M_TRACE_CHIP_TRANS_TOUT,
+                             WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                             hnd->trans->id);
+
+        switch (hnd->trans->id) {
+        case PC2400M_DRV_DM_TERMINATE:
+                /* this returns ESUCCESS, because the driver will be shutdown
+                   anyway right after. */
+                GOTO_STATE(hnd->state, L3L4_SYSTEM_STATE_UNINITIALIZED);
+                pc2400m_drv_dm_trans_complete(hnd, ESUCCESS);
+                break;
+
+        case PC2400M_DRV_DM_ENABLE_RADIO:
+                if (hnd->trans->intdata.state == DM_STATE_RADIO_ON_COMPLETE) {
+                        /* unable to switch radio on, set the sw
+                           switch of the radio to off */
+                        hnd->transition(hnd, PC2400M_DRV_DM_DISABLE_RADIO,
+                                        NULL, NULL, NULL, NULL);
+                        wimax_osal_trace(
+                                PC2400M_GROUP_DM_ERROR,
+                                PC2400M_TRACE_HW_RF_SWITCH_OFF,
+                                WIMAX_OSAL_TRACE_PRIORITY_ERROR);
+                }
+                pc2400m_drv_dm_trans_complete(hnd, -EGENERAL);
+                break;
+
+        default:
+                /* normally the timeout indicates irrecoverable failure */
+                hnd->abort_mission(hnd);
+                break;
+
+        };
+
+        /* if the system was deleted during the handling of this,
+           handle it now */
+        priv->unref(priv);
+
+
+}
+
+
+
+/** Collectively handle chipset response messages. Handle a response to a
+ *  request inside an executing transition.
+ *
+ *  @param cdhnd handle to the control dispatcher instance
+ *  @param msg response message contents
+ *  @param user data used to carry the device manager instance
+ *  @return none
+ */
+static void pc2400m_drv_dm_resp_handler(
+        struct pc2400m_drv_cd_if* cdhnd,
+        wimax_osal_packet *msg,
+        void *data)
+{
+
+        struct pc2400m_drv_dm_if *hnd = (struct pc2400m_drv_dm_if*)data;
+        u16 status = pc2400m_drv_dm_header_status(msg);
+
+        PC2400M_DRV_UNWARN(cdhnd);
+
+        wimax_osal_assert(hnd->trans);
+
+        wimax_osal_assert(
+                hnd->trans->id == PC2400M_DRV_DM_ENABLE_RADIO ||
+                hnd->trans->id == PC2400M_DRV_DM_DISABLE_RADIO||
+                hnd->trans->id == PC2400M_DRV_DM_CONFIGURE ||
+                hnd->trans->id == PC2400M_DRV_DM_TERMINATE ||
+                hnd->trans->id == PC2400M_DRV_DM_PRODUCTION);
+
+        /* process the response */
+        switch ((s32)hnd->trans->id) {
+        case PC2400M_DRV_DM_ENABLE_RADIO:
+                if (!L3L4_SUCCESS(status)) {
+                        wimax_osal_trace_u16(
+                                PC2400M_GROUP_DM_ERROR,
+                                PC2400M_TRACE_REQUEST_FAILED,
+                                WIMAX_OSAL_TRACE_PRIORITY_DEBUG, status);
+                        pc2400m_drv_dm_trans_complete(hnd, -EGENERAL);
+                } else {
+
+                        wimax_osal_assert(hnd->trans->intdata.state ==
+                                          DM_STATE_RADIO_ON_MODE_REQ ||
+                                          hnd->trans->intdata.state ==
+                                          DM_STATE_RADIO_ON_REQ);
+
+                        switch (hnd->trans->intdata.state) {
+                        case DM_STATE_RADIO_ON_MODE_REQ:
+
+                                /* once the mode of operation has been
+                                   requested, wait for the state to change
+                                   to RF_OFF */
+                                hnd->trans->intdata.state =
+                                        DM_STATE_RADIO_ON_MODE_REQ_DONE;
+                                pc2400m_drv_dm_ind_report_state_enable_radio(
+                                        hnd);
+                                break;
+
+                        case DM_STATE_RADIO_ON_REQ:
+
+                                /* once the rf enable request has been started,
+                                   wait for the state to change to READY */
+                                hnd->trans->intdata.state =
+                                        DM_STATE_RADIO_ON_COMPLETE;
+                                pc2400m_drv_dm_ind_report_state_enable_radio(
+                                        hnd);
+                                break;
+                        }
+
+                }
+                break;
+
+        case PC2400M_DRV_DM_DISABLE_RADIO:
+                if (!L3L4_SUCCESS(status)) {
+                        wimax_osal_trace_u16(
+                                PC2400M_GROUP_DM_ERROR,
+                                PC2400M_TRACE_REQUEST_FAILED,
+                                WIMAX_OSAL_TRACE_PRIORITY_DEBUG, status);
+                        pc2400m_drv_dm_trans_complete(hnd, -EGENERAL);
+                } else {
+
+                        /* once the request is complete, wait for the
+                           change to RF_OFF state */
+                        hnd->trans->intdata.state =
+                                DM_STATE_RADIO_OFF_COMPLETE;
+                        pc2400m_drv_dm_ind_report_state_disable_radio(hnd);
+
+                }
+                break;
+
+        case PC2400M_DRV_DM_CONFIGURE:
+        {
+
+                struct L3L4_TLV_STR_L4_MESSAGE_VERSION *l4mv;
+                struct L3L4_TLV_STR_VERSIONS_STRINGS *verstr;
+                struct pc2400m_drv_dm_configure_params *config_params =
+                        (struct pc2400m_drv_dm_configure_params*)
+                        hnd->trans->params;
+                u8 *ptr;
+
+                /* check response status code */
+                if (status != L3L4_RESPONSE_STATUS_SUCCESS_IN_PROCESS &&
+                    status != L3L4_RESPONSE_STATUS_SUCCESS_DONE) {
+                        wimax_osal_trace_u16(
+                                PC2400M_GROUP_DM_ERROR,
+                                PC2400M_TRACE_UNABLE_TO_INITIALIZE,
+                                WIMAX_OSAL_TRACE_PRIORITY_DEBUG, status);
+                        pc2400m_drv_dm_trans_complete(hnd, -EGENERAL);
+                        break;
+                }
+
+                switch (hnd->trans->intdata.state) {
+                case DM_STATE_CONFIGURE_PRECONFIG_REQ:
+                        /* as we got this far, the preconfig was a success,
+                           and we can proceed to the init state */
+                        hnd->trans->intdata.state = DM_STATE_CONFIGURE_REQ;
+                        pc2400m_drv_dm_send_get_req(
+                                hnd, L4_L3_OPCODE_CMD_INIT);
+                        break;
+                case DM_STATE_CONFIGURE_REQ:
+                case DM_STATE_CONFIGURE_WAITING_CH:
+                        hnd->trans->intdata.state =
+                                DM_STATE_CONFIGURE_WAITING_CH;
+                        pc2400m_drv_dm_ind_report_state_configure(hnd);
+                        break;
+                case DM_STATE_CONFIGURE_WAITING_L3M:
+                        l4mv = (struct L3L4_TLV_STR_L4_MESSAGE_VERSION*)
+                                hnd->get_tlv(hnd,
+                                             wimax_osal_packet_ptr(msg),
+                                             L3L4_TLV_TYPE_L4_MESSAGE_VERSION,
+                                             NULL);
+                        if (l4mv) {
+                                wimax_osal_assert(
+                                        WIMAX_OSAL_LE_TO_U16(
+                                                l4mv->tlv.length) ==
+                                        L3L4_TLV_SIZE_L4_MESSAGE_VERSION-
+                                        L3L4_TLV_HDR_LEN);
+
+                                hnd->chipset.cap.L4Mversion[0] =
+                                        WIMAX_OSAL_LE_TO_U16(
+                                                l4mv->version_major);
+                                hnd->chipset.cap.L4Mversion[1] =
+                                        WIMAX_OSAL_LE_TO_U16(
+                                                l4mv->version_minor);
+                                hnd->chipset.cap.L4Mversion[2] =
+                                        WIMAX_OSAL_LE_TO_U16(
+                                                l4mv->version_branch);
+
+                        } else {
+                                wimax_osal_trace_u16(
+                                        PC2400M_GROUP_DM_ERROR,
+                                        PC2400M_TRACE_CHIP_EXP_TLV_MISSING,
+                                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                                        L3L4_TLV_TYPE_L4_MESSAGE_VERSION);
+                                pc2400m_drv_dm_trans_complete(hnd, -EGENERAL);
+                                break;
+                        }
+
+                        /* enforce supported firmware version */
+                        if (!pc2400m_drv_dm_supported_ver_check(hnd)) {
+                                pc2400m_drv_dm_trans_complete(hnd, -EGENERAL);
+                                break;
+                        }
+
+                        wimax_osal_trace_data(
+                                PC2400M_GROUP_DM_DEBUG,
+                                PC2400M_TRACE_CHIP_L4M_VERSION,
+                                WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                                (u8*)hnd->chipset.cap.L4Mversion,
+                                sizeof(hnd->chipset.cap.L4Mversion));
+
+                        hnd->trans->intdata.state =
+                                DM_STATE_CONFIGURE_PRECONFIG_REQ;
+                        pc2400m_drv_dm_configure_send_preconfig_req(
+                                hnd);
+
+                        break;
+                case DM_STATE_CONFIGURE_WAITING_DETAILS:
+                        verstr = (struct L3L4_TLV_STR_VERSIONS_STRINGS*)
+                                hnd->get_tlv(hnd, wimax_osal_packet_ptr(msg),
+                                             L3L4_TLV_TYPE_VERSIONS_STRINGS,
+                                             NULL);
+
+                        if (verstr) {
+                                ptr = verstr->strings;
+
+                                /* extract the HW version */
+                                wimax_osal_trace_str(
+                                        PC2400M_GROUP_DM_INFO,
+                                        PC2400M_TRACE_CHIP_ASIC_VER,
+                                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                                        ptr);
+                                wimax_osal_str_ncpy(
+                                        hnd->chipset.cap.hw_version,
+                                             ptr, WIHAL_VERSION_STR_LEN);
+                                hnd->chipset.cap.hw_version
+                                        [WIHAL_VERSION_STR_LEN-1] = '\0';
+                                ptr += wimax_osal_str_len(ptr) + 1;
+
+                                /* extract the RF version */
+                                wimax_osal_trace_str(
+                                        PC2400M_GROUP_DM_INFO,
+                                        PC2400M_TRACE_CHIP_BOARD_VER,
+                                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                                        ptr);
+                                ptr += wimax_osal_str_len(ptr) + 1;
+
+                                /* extract the FW version */
+                                wimax_osal_trace_str(
+                                        PC2400M_GROUP_DM_INFO,
+                                        PC2400M_TRACE_CHIP_FW_VER,
+                                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                                        ptr);
+                                wimax_osal_str_ncpy(
+                                        hnd->chipset.cap.fw_version,
+                                             ptr, WIHAL_VERSION_STR_LEN);
+                                hnd->chipset.cap.fw_version
+                                        [WIHAL_VERSION_STR_LEN-1] = '\0';
+                                ptr += wimax_osal_str_len(ptr) + 1;
+
+
+                        } else {
+                                wimax_osal_trace_u16(
+                                        PC2400M_GROUP_DM_ERROR,
+                                        PC2400M_TRACE_CHIP_EXP_TLV_MISSING,
+                                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                                        L3L4_TLV_TYPE_VERSIONS_STRINGS);
+                        }
+
+                        /* get the MAC address information */
+                        if (!pc2400m_drv_dm_configure_get_device_details(
+                                    hnd, msg)) {
+                                pc2400m_drv_dm_trans_complete(hnd, -EGENERAL);
+                                break;
+                        }
+
+                        /* fill out the capabilities structure, and
+                           return it to the caller */
+                        dm_configure_fill_capabilities(
+                                hnd, &(config_params->capa));
+                        pc2400m_drv_dm_trans_complete(hnd, ESUCCESS);
+
+                        break;
+                }
+                break;
+        }
+
+        case PC2400M_DRV_DM_TERMINATE:
+
+                /* terminate cannot fail */
+                wimax_osal_assert(
+                        status == L3L4_RESPONSE_STATUS_SUCCESS_IN_PROCESS||
+                        status == L3L4_RESPONSE_STATUS_SUCCESS_DONE);
+
+                /* wait for one of the end states of the terminate */
+                hnd->trans->intdata.state =
+                        DM_STATE_TERMINATE_WAITING_CH;
+                pc2400m_drv_dm_ind_report_state_terminate(hnd);
+                break;
+
+        case PC2400M_DRV_DM_PRODUCTION:
+
+                if (status == L3L4_RESPONSE_STATUS_SUCCESS_IN_PROCESS ||
+                    status == L3L4_RESPONSE_STATUS_SUCCESS_DONE) {
+
+                        if (hnd->chipset.state ==
+                            PC2400M_DRV_DM_PRODUCTION(hnd)) {
+                                GOTO_STATE(hnd->state,
+                                           PC2400M_DRV_DM_PRODUCTION(hnd));
+                                pc2400m_drv_dm_trans_complete(hnd, ESUCCESS);
+                        } else {
+                                hnd->trans->intdata.state =
+                                        DM_STATE_PRODUCTION_WAITING_CH;
+                        }
+                } else {
+                        wimax_osal_trace_u16(
+                                PC2400M_GROUP_DM_ERROR,
+                                PC2400M_TRACE_CANNOT_GO_PRODUCTION,
+                                WIMAX_OSAL_TRACE_PRIORITY_ERROR, status);
+                        pc2400m_drv_dm_trans_complete(hnd, -EGENERAL);
+                }
+                break;
+
+        };
+
+        wimax_osal_packet_free(&msg);
+        return;
+
+}
+
+
+/** Handle EAP restart message from chipset.
+ *
+ *  @param cdhnd handle to the control dispatcher instance
+ *  @param indid opcode of the report (unused)
+ *  @param msg response message contents
+ *  @param data user data used to carry the device manager instance
+ *  @return none
+ */
+static void pc2400m_drv_dm_ind_eap_restart(
+        struct pc2400m_drv_cd_if *cdhnd,
+        u32 indid,
+        wimax_osal_packet *msg,
+        void *data)
+{
+
+        struct pc2400m_drv_dm_if *hnd = (struct pc2400m_drv_dm_if*)data;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->ctx);
+
+        PC2400M_DRV_UNWARN(cdhnd);
+        PC2400M_DRV_UNWARN(indid);
+
+        /* send WiHAL indication */
+        priv->send_network_status_ind(
+                hnd->ctx,
+                E_WIHAL_NETWORK_STATUS_EAP_RESTART,
+                E_WIHAL_NETWORK_STATUS_ERR_NONE,
+                hnd->chipset.link.bs_id,
+                &hnd->chipset.link.channel_plan,
+                0,
+                NULL);
+
+        /* free the memory of the data packet */
+        wimax_osal_packet_free(&msg);
+
+}
+
+
+
+/** Collectively handle chipset state change. Handle chipset state change in a
+ *  collective fashion. Will call transition specific handling if necessary.
+ *
+ *  @param cdhnd handle to the control dispatcher instance
+ *  @param indid opcode of the report (unused)
+ *  @param msg response message contents
+ *  @param data user data used to carry the device manager instance
+ *  @return none
+ */
+static void pc2400m_drv_dm_ind_report_state(
+        struct pc2400m_drv_cd_if *cdhnd,
+        u32 indid,
+        wimax_osal_packet *msg,
+        void *data)
+{
+        struct pc2400m_drv_dm_if *hnd = (struct pc2400m_drv_dm_if*)data;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->ctx);
+        union {
+                struct L3L4_TLV_STR_REPORT_STATE_REASON *rsreason;
+                struct L3L4_TLV_STR_SYSTEM_STATE *rsstate;
+                struct L3L4_TLV_STR_RF_SWITCHES_STATUS *rfswitches;
+                struct L3L4_TLV_STR_CONNECT_PROGRESS *rscprog;
+                struct L3L4_TLV_STR_MEDIA_STATUS *mediastatus;
+        } tlv;
+
+        u32 conn_progress = 0;
+        u8 reason = L3L4_REPORT_STATE_REASON_NORMAL;
+
+        PC2400M_DRV_UNWARN(cdhnd);
+        PC2400M_DRV_UNWARN(indid);
+
+        /* get the new chipset state */
+        tlv.rsstate = (struct L3L4_TLV_STR_SYSTEM_STATE*)
+                hnd->get_tlv(hnd, wimax_osal_packet_ptr(msg),
+                             L3L4_TLV_TYPE_SYSTEM_STATE, NULL);
+        if (tlv.rsstate) {
+                wimax_osal_assert(
+                        WIMAX_OSAL_LE_TO_U16(tlv.rsstate->tlv.length) ==
+                        L3L4_TLV_SIZE_SYSTEM_STATE - L3L4_TLV_HDR_LEN);
+                hnd->chipset.state =
+                        (u8)WIMAX_OSAL_LE_TO_U32(tlv.rsstate->state);
+
+                wimax_osal_trace_byte(PC2400M_GROUP_DM_DEBUG,
+                                      PC2400M_TRACE_CHIP_ST_CH_STATE,
+                                      WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                                      hnd->chipset.state);
+
+        }
+
+
+        /* check the reason for the status message */
+        tlv.rsreason = (struct L3L4_TLV_STR_REPORT_STATE_REASON*)
+                hnd->get_tlv(hnd, wimax_osal_packet_ptr(msg),
+                             L3L4_TLV_TYPE_REPORT_STATE_REASON, NULL);
+        if (tlv.rsreason) {
+                wimax_osal_assert(
+                        WIMAX_OSAL_LE_TO_U16(tlv.rsreason->tlv.length) ==
+                        L3L4_TLV_SIZE_REPORT_STATE_REASON-
+                        L3L4_TLV_HDR_LEN);
+                reason = (u8)WIMAX_OSAL_LE_TO_U32(tlv.rsreason->reason);
+                wimax_osal_trace_byte(PC2400M_GROUP_DM_DEBUG,
+                                      PC2400M_TRACE_CHIP_ST_CH_REASON,
+                                      WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                                      reason);
+
+                /* regardless of the name of the field below,
+                   'disconnect_status' it is also used for connection phase
+                   status code tracking. */
+
+                switch(reason) {
+                case L3L4_REPORT_STATE_REASON_NORMAL:
+                        hnd->chipset.trans.disconnect_status =
+                                E_WIHAL_NETWORK_STATUS_ERR_NONE;
+                        break;
+                case L3L4_REPORT_STATE_REASON_FAIL_TO_CONNECT_TO_NW:
+                        hnd->chipset.trans.disconnect_status =
+                                E_WIHAL_NETWORK_STATUS_ERR_CONNECTION_CREATION;
+                        break;
+                case L3L4_REPORT_STATE_REASON_FAIL_TO_CONNECT_RANGING:
+                        hnd->chipset.trans.disconnect_status =
+                                E_WIHAL_NETWORK_STATUS_ERR_RANGING;
+                        break;
+                case L3L4_REPORT_STATE_REASON_FAIL_TO_CONNECT_SBC:
+                        hnd->chipset.trans.disconnect_status =
+                                E_WIHAL_NETWORK_STATUS_ERR_CAPABILITY_NEGOTIATION;
+                        break;
+                case L3L4_REPORT_STATE_REASON_FAIL_TO_CONNECT_EAP_AUTH:
+                        hnd->chipset.trans.disconnect_status =
+                                E_WIHAL_NETWORK_STATUS_ERR_AUTHENTICATION;
+                        break;
+                case L3L4_REPORT_STATE_REASON_FAIL_TO_CONNECT_3_WAY_HANDSHAKE:
+                        hnd->chipset.trans.disconnect_status =
+                                E_WIHAL_NETWORK_STATUS_ERR_3_WAY_HANDSHAKE;
+                        break;
+                case L3L4_REPORT_STATE_REASON_FAIL_TO_CONNECT_REGISTRATION:
+                        hnd->chipset.trans.disconnect_status =
+                                E_WIHAL_NETWORK_STATUS_ERR_REGISTRATION;
+                        break;
+                case L3L4_REPORT_STATE_REASON_FAIL_TO_CONNECT_DATA_PATH:
+                        hnd->chipset.trans.disconnect_status =
+                                E_WIHAL_NETWORK_STATUS_ERR_DATA_PATH_CREATION;
+                        break;
+                case L3L4_REPORT_STATE_REASON_COEX_NO_RF:
+                        hnd->chipset.trans.disconnect_status =
+                                E_WIHAL_NETWORK_STATUS_ERR_CONNECTION_LOST;
+                        break;
+                case L3L4_REPORT_STATE_REASON_DISCONNECT_ABORT:
+                case L3L4_REPORT_STATE_REASON_DISCONNECT_DREG:
+                        hnd->chipset.trans.disconnect_status =
+                                E_WIHAL_NETWORK_STATUS_ERR_EXIT_BY_NETWORK;
+                        break;
+                case L3L4_REPORT_STATE_REASON_DISCONNECT_RESET:
+                        hnd->chipset.trans.disconnect_status =
+                                E_WIHAL_NETWORK_STATUS_ERR_RESET_BY_NETWORK;
+                        break;
+                case L3L4_REPORT_STATE_REASON_DISCONNECT_DROP:
+                        hnd->chipset.trans.disconnect_status =
+                                E_WIHAL_NETWORK_STATUS_ERR_CONNECTION_LOST;
+                        break;
+                case L3L4_REPORT_STATE_REASON_DISCONNECT_SECURITY:
+                        hnd->chipset.trans.disconnect_status =
+                                E_WIHAL_NETWORK_STATUS_ERR_REAUTHENTICATION_FAIL;
+                        break;
+                };
+        } else {
+                wimax_osal_trace_u16(
+                        PC2400M_GROUP_DM_ERROR,
+                        PC2400M_TRACE_CHIP_EXP_TLV_MISSING,
+                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                        L3L4_TLV_TYPE_REPORT_STATE_REASON);
+        }
+
+        /* check rf switches status */
+        tlv.rfswitches = (struct L3L4_TLV_STR_RF_SWITCHES_STATUS*)
+                hnd->get_tlv(hnd, wimax_osal_packet_ptr(msg),
+                             L3L4_TLV_TYPE_RF_SWITCHES_STATUS, NULL);
+        if (tlv.rfswitches) {
+
+                /* update the chipset cache with the current status of the
+                   rf HW switch */
+                if (tlv.rfswitches->hw_rf_switch == L3L4_RF_SWITCH_ON)
+                        hnd->chipset.rf.hw_switch = TRUE;
+                else
+                        hnd->chipset.rf.hw_switch = FALSE;
+
+        }
+
+        /* check connection progress */
+        tlv.rscprog = (struct L3L4_TLV_STR_CONNECT_PROGRESS*)
+                hnd->get_tlv(hnd, wimax_osal_packet_ptr(msg),
+                             L3L4_TLV_TYPE_CONNECT_PROGRESS, NULL);
+        if (tlv.rscprog) {
+                wimax_osal_trace_u32(
+                        PC2400M_GROUP_DM_DEBUG,
+                        PC2400M_TRACE_CHIP_CONNECT_PROG,
+                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                        WIMAX_OSAL_LE_TO_U32(tlv.rscprog->progress));
+                conn_progress = WIMAX_OSAL_LE_TO_U32(tlv.rscprog->progress);
+        }
+
+
+        /* update the media status in the chipset cache */
+        tlv.mediastatus = (struct L3L4_TLV_STR_MEDIA_STATUS*)
+                hnd->get_tlv(hnd, wimax_osal_packet_ptr(msg),
+                             L3L4_TLV_TYPE_MEDIA_STATUS, NULL);
+        if (tlv.mediastatus) {
+                wimax_osal_assert(
+                        WIMAX_OSAL_LE_TO_U16(tlv.mediastatus->tlv.length) ==
+                        L3L4_TLV_SIZE_MEDIA_STATUS - L3L4_TLV_HDR_LEN);
+                wimax_osal_trace_u32(
+                        PC2400M_GROUP_DM_DEBUG,
+                        PC2400M_TRACE_LINK_STATE,
+                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                        WIMAX_OSAL_LE_TO_U32(tlv.mediastatus->media_status));
+
+
+                wimax_osal_assert(
+                        WIMAX_OSAL_LE_TO_U32(tlv.mediastatus->media_status) ==
+                        L3L4_MEDIA_STATUS_LINK_UP ||
+                        WIMAX_OSAL_LE_TO_U32(tlv.mediastatus->media_status) ==
+                        L3L4_MEDIA_STATUS_LINK_DOWN ||
+                        WIMAX_OSAL_LE_TO_U32(tlv.mediastatus->media_status) ==
+                        L3L4_MEDIA_STATUS_LINK_RENEW);
+
+                switch(WIMAX_OSAL_LE_TO_U32(
+                               tlv.mediastatus->media_status)) {
+                case L3L4_MEDIA_STATUS_LINK_UP:
+                        hnd->chipset.link.up = 1;
+                        hnd->cd->link_state(hnd->cd, TRUE);
+                        break;
+                case L3L4_MEDIA_STATUS_LINK_DOWN:
+                        hnd->chipset.link.up = 0;
+                        hnd->cd->link_state(hnd->cd, FALSE);
+                        break;
+                case L3L4_MEDIA_STATUS_LINK_RENEW:
+
+                        /* this link status is actually no change in the
+                           link status. a notification is sent to the client,
+                           but the state is unchanged. */
+                        wimax_osal_assert(hnd->chipset.link.up);
+                        priv->send_network_status_ind(
+                                hnd->ctx,
+                                E_WIHAL_NETWORK_STATUS_IP_RENEW,
+                                E_WIHAL_NETWORK_STATUS_ERR_NONE,
+                                hnd->chipset.link.bs_id,
+                                &hnd->chipset.link.channel_plan,
+                                0,
+                                NULL);
+                        break;
+                }
+        }
+
+        /* get the channel info TLV */
+        pc2400m_drv_dm_get_network_status_process_channel_info(
+                hnd, msg);
+
+        /* find the link status TLV */
+        pc2400m_drv_dm_get_network_status_process_link_status(
+                hnd, msg);
+
+        wimax_osal_packet_free(&msg);
+
+        /* process unsolicited state changes */
+        pc2400m_drv_dm_process_state_change(hnd);
+
+        /* process the new status according to transition */
+        if (hnd->trans) switch (hnd->trans->id) {
+        case PC2400M_DRV_DM_ENABLE_RADIO:
+
+                pc2400m_drv_dm_ind_report_state_enable_radio(hnd);
+                break;
+
+        case PC2400M_DRV_DM_DISABLE_RADIO:
+
+                pc2400m_drv_dm_ind_report_state_disable_radio(hnd);
+                break;
+
+        case PC2400M_DRV_DM_CONFIGURE:
+
+                pc2400m_drv_dm_ind_report_state_configure(hnd);
+                break;
+
+        case PC2400M_DRV_DM_TERMINATE:
+
+                pc2400m_drv_dm_ind_report_state_terminate(hnd);
+                break;
+
+        case PC2400M_DRV_DM_PRODUCTION:
+
+                if (hnd->state == PC2400M_DRV_DM_PRODUCTION(hnd)) {
+                        if (hnd->trans->intdata.state ==
+                            DM_STATE_PRODUCTION_WAITING_CH) {
+                                pc2400m_drv_dm_trans_complete(hnd, ESUCCESS);
+                        }
+                } else {
+                        wimax_osal_trace_byte(
+                                PC2400M_GROUP_DM_ERROR,
+                                PC2400M_TRACE_CHIP_UNEXP_STATE_IND,
+                                WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                                hnd->chipset.state);
+                }
+                break;
+
+        default:
+                break;
+        }
+
+
+        /* notify background transition of the state change */
+        if (hnd->bg)
+                hnd->bg->state_change(
+                        hnd->bg, hnd->state, reason, conn_progress);
+
+        return;
+
+}
+
+/** Validate state change. Validate chipset state change legality, and perform
+ *  special operations for state change events requiring them.
+ *
+ *  @param hnd handle to device manager instance
+ *  @return none
+ */
+static void pc2400m_drv_dm_process_state_change(struct pc2400m_drv_dm_if *hnd)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->ctx);
+#define DM_NO_STATE  0x00000000
+#define DM_ANY_STATE 0xffffffff
+        enum t_wihal_network_status_err disconnect_cause;
+        static u32 allowed_state_change[L3L4_SYSTEM_STATE_COUNT+1] = {
+                /* TO 0: */
+                DM_NO_STATE,
+
+                /* TO L3L4_SYSTEM_STATE_UNINITIALIZED: */
+                DM_ANY_STATE,
+
+                /* TO L3L4_SYSTEM_STATE_INIT: */
+                (1 << L3L4_SYSTEM_STATE_INIT) |
+                (1 << L3L4_SYSTEM_STATE_CONFIG),
+
+                /* TO L3L4_SYSTEM_STATE_READY: */
+                (1 << L3L4_SYSTEM_STATE_READY) |
+                (1 << L3L4_SYSTEM_STATE_SCAN) |
+                (1 << L3L4_SYSTEM_STATE_RF_OFF) |
+                (1 << L3L4_SYSTEM_STATE_CONNECTING) |
+                (1 << L3L4_SYSTEM_STATE_WIMAX_CONNECTED) |
+                (1 << L3L4_SYSTEM_STATE_DATA_PATH_CONNECTED) |
+                (1 << L3L4_SYSTEM_STATE_IDLE) |
+                (1 << L3L4_SYSTEM_STATE_DISCONNECTING),
+
+                /* TO L3L4_SYSTEM_STATE_SCAN: */
+                (1 << L3L4_SYSTEM_STATE_SCAN) |
+                (1 << L3L4_SYSTEM_STATE_READY),
+
+                /* TO UNUSED STATE: */
+                DM_NO_STATE,
+
+                /* TO L3L4_SYSTEM_STATE_CONNECTING: */
+                (1 << L3L4_SYSTEM_STATE_CONNECTING) |
+                (1 << L3L4_SYSTEM_STATE_READY),
+
+                /* TO L3L4_SYSTEM_STATE_WIMAX_CONNECTED: */
+                (1 << L3L4_SYSTEM_STATE_WIMAX_CONNECTED) |
+                (1 << L3L4_SYSTEM_STATE_CONNECTING),
+
+                /* TO L3L4_SYSTEM_STATE_DATA_PATH_CONNECTED: */
+                (1 << L3L4_SYSTEM_STATE_DATA_PATH_CONNECTED) |
+                (1 << L3L4_SYSTEM_STATE_CONNECTING) |
+                (1 << L3L4_SYSTEM_STATE_WIMAX_CONNECTED) |
+                (1 << L3L4_SYSTEM_STATE_IDLE),
+
+                /* TO L3L4_SYSTEM_STATE_IDLE: */
+                (1 << L3L4_SYSTEM_STATE_IDLE) |
+                (1 << L3L4_SYSTEM_STATE_DATA_PATH_CONNECTED),
+
+                /* TO L3L4_SYSTEM_STATE_DISCONNECTING: */
+                (1 << L3L4_SYSTEM_STATE_DISCONNECTING) |
+                (1 << L3L4_SYSTEM_STATE_CONNECTING) |
+                (1 << L3L4_SYSTEM_STATE_WIMAX_CONNECTED) |
+                (1 << L3L4_SYSTEM_STATE_DATA_PATH_CONNECTED) |
+                (1 << L3L4_SYSTEM_STATE_IDLE),
+
+                /* TO UNUSED STATE: */
+                DM_NO_STATE,
+
+                /* TO UNUSED STATE: */
+                DM_NO_STATE,
+
+                /* TO L3L4_SYSTEM_STATE_PRODUCTION: */
+                (1 << L3L4_SYSTEM_STATE_PRODUCTION) |
+                (1 << L3L4_SYSTEM_STATE_INIT),
+
+                /* TO L3L4_SYSTEM_STATE_CONFIG: */
+                (1 << L3L4_SYSTEM_STATE_CONFIG) |
+                (1 << L3L4_SYSTEM_STATE_UNINITIALIZED),
+
+                /* TO L3L4_SYSTEM_STATE_RF_OFF: */
+                (1 << L3L4_SYSTEM_STATE_RF_OFF) |
+                (1 << L3L4_SYSTEM_STATE_INIT) |
+                (1 << L3L4_SYSTEM_STATE_RF_SHUTDOWN),
+
+                /* TO L3L4_SYSTEM_STATE_RF_SHUTDOWN: */
+                (1 << L3L4_SYSTEM_STATE_RF_SHUTDOWN) |
+                (1 << L3L4_SYSTEM_STATE_READY) |
+                (1 << L3L4_SYSTEM_STATE_DISCONNECTING) |
+                (1 << L3L4_SYSTEM_STATE_SCAN) |
+                (1 << L3L4_SYSTEM_STATE_CONNECTING) |
+                (1 << L3L4_SYSTEM_STATE_WIMAX_CONNECTED) |
+                (1 << L3L4_SYSTEM_STATE_DATA_PATH_CONNECTED) |
+                (1 << L3L4_SYSTEM_STATE_IDLE) |
+                (1 << L3L4_SYSTEM_STATE_PRODUCTION),
+
+        };
+
+        /* if the state change is legitimate, do it */
+        if (allowed_state_change[hnd->chipset.state] & (1 << (hnd->state))) {
+                if (hnd->chipset.state != hnd->state)
+                        if ((!hnd->bg) &&
+                            hnd->chipset.state == L3L4_SYSTEM_STATE_READY &&
+                            (hnd->state == L3L4_SYSTEM_STATE_CONNECTING ||
+                             hnd->state == L3L4_SYSTEM_STATE_WIMAX_CONNECTED ||
+                             hnd->state ==
+                             L3L4_SYSTEM_STATE_DATA_PATH_CONNECTED ||
+                             hnd->state == L3L4_SYSTEM_STATE_IDLE ||
+                             hnd->state == L3L4_SYSTEM_STATE_DISCONNECTING)) {
+
+
+                                /* invalidate BSID information in the
+                                   chipset cache */
+                                hnd->chipset.link.channel_set = 0;
+
+                                /* choose cause code for the indication */
+                                if (hnd->chipset.trans.disconnect_status !=
+                                    E_WIHAL_NETWORK_STATUS_ERR_NONE)
+                                        disconnect_cause =
+                                                hnd->chipset.trans.
+                                                disconnect_status;
+                                else
+                                        disconnect_cause =
+                                                E_WIHAL_NETWORK_STATUS_ERR_CONNECTION_LOST;
+
+                                /* a unsolicited disconnect -> send
+                                   indication */
+                                priv->send_network_status_ind(
+                                        hnd->ctx,
+                                        E_WIHAL_NETWORK_STATUS_DISCONNECTED,
+                                        disconnect_cause,
+                                        NULL,
+                                        NULL,
+                                        0,
+                                        NULL);
+                                hnd->chipset.trans.network_status =
+                                        E_WIHAL_NETWORK_STATUS_DISCONNECTED;
+
+                        }
+
+                /* tell the control dispatcher to go to idle */
+                if (hnd->chipset.state == PC2400M_DRV_DM_IDLE(hnd) &&
+                    hnd->state != PC2400M_DRV_DM_IDLE(hnd))
+                        hnd->cd->idle(hnd->cd, TRUE);
+
+                /* tell the control dispatcher to exit idle */
+                if (hnd->state == PC2400M_DRV_DM_IDLE(hnd) &&
+                    hnd->chipset.state != PC2400M_DRV_DM_IDLE(hnd))
+                        hnd->cd->idle(hnd->cd, FALSE);
+
+                if (hnd->chipset.state == PC2400M_DRV_DM_RF_OFF(hnd)) {
+
+                        /* invalidate BSID information in the
+                           chipset cache */
+                        hnd->chipset.link.channel_set = 0;
+
+                }
+
+                if (hnd->chipset.state ==
+                    PC2400M_DRV_DM_DATA_PATH_CONNECTED(hnd)) {
+
+                        /* start the handover timer when entering the
+                           data path connected state */
+                        pc2400m_drv_dm_handover_timer_set(hnd, TRUE);
+
+                } else {
+
+                        /* stop the handover timer when not in the data
+                           path connected state */
+                        pc2400m_drv_dm_handover_timer_set(hnd, FALSE);
+
+                }
+
+                GOTO_STATE(hnd->state, hnd->chipset.state);
+                goto out;
+
+
+        }
+
+        wimax_osal_trace_u16(PC2400M_GROUP_DM_ERROR,
+                             PC2400M_TRACE_CHIP_UNEXP_STATE_IND,
+                             WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                             hnd->chipset.state);
+
+        /* the chipset will be out of sync in this event, irrecoverably */
+        hnd->abort_mission(hnd);
+
+ out:
+        return;
+
+}
+
+
+/** Violently abort transition. Used for completing all the transitions in the
+ *  queue when cleaning device manager resources. Makes the given transition
+ *  currently executing, and the complete operation is called on it.
+ *
+ *  @param ptr pointer to transition to be aborted.
+ */
+static void pc2400m_drv_dm_forcecancel_transition(void **ptr) {
+
+        struct pc2400m_drv_dm_trans *trans =
+                (struct pc2400m_drv_dm_trans*)*ptr;
+
+        /* get rid of the transaction without scheduling the next */
+        trans->hnd->trans = trans;
+
+        pc2400m_drv_dm_trans_complete(trans->hnd, -ECANCEL);
+        *ptr = NULL;
+
+}
+
+
+/** Clean up the device manager. Free the memory and resources used by the cd
+ *  cancelling all ongoing operations and bringing it to an initial state.
+ *
+ *  @param hnd pointer to the instance of the device manager
+ *  @return none
+ */
+static void pc2400m_drv_dm_reset(struct pc2400m_drv_dm_if *hnd)
+{
+
+        /* forcibly abort ongoing transition */
+        pc2400m_drv_dm_trans_abort(hnd);
+
+        /* clean up the remaining queue */
+        wimax_osal_list_release(
+                &(hnd->transq), pc2400m_drv_dm_forcecancel_transition);
+
+        /* clean up the abort callback queue */
+        wimax_osal_assert(!wimax_osal_list_first(&(hnd->abort_cb_queue)));
+        wimax_osal_list_release(
+                &(hnd->abort_cb_queue), NULL);
+
+        /* both lists must remain in existence */
+        wimax_osal_list_initialize(
+                &(hnd->transq),
+                WIMAX_OSAL_LIST_ELEM_HDR_OFFSET(
+                        struct pc2400m_drv_dm_trans, list));
+        wimax_osal_list_initialize(
+                &(hnd->abort_cb_queue),
+                WIMAX_OSAL_LIST_ELEM_HDR_OFFSET(
+                        struct pc2400m_drv_dm_abort_cb, list));
+
+        /* stop the handover timer */
+        pc2400m_drv_dm_handover_timer_set(hnd, FALSE);
+
+        /* bring subsystems to an initial state (the subsystems always
+           exist when dm exists */
+        hnd->cd->reset(hnd->cd);
+        hnd->hdi->reset(hnd->hdi);
+
+        /* put down the link state in control dispatcher */
+        hnd->cd->link_state(hnd->cd, FALSE);
+
+        /* delete possibly ongoing background operation */
+        if (hnd->bg) {
+                hnd->bg->cleanup(hnd->bg);
+                hnd->bg = NULL;
+        }
+
+        /* clear flags (suspension etc) */
+        hnd->flags = 0;
+
+        /* clear device info cache */
+        wimax_osal_mem_free((void**)&(hnd->chipset.link.nsp_realm));
+        wimax_osal_mem_set(&(hnd->chipset), 0x00,
+               sizeof(struct pc2400m_drv_dm_chipset));
+        hnd->chipset.trans.network_status =
+                E_WIHAL_NETWORK_STATUS_DISCONNECTED;
+
+        /* reset system state */
+        RESET_STATE(hnd->state);
+
+
+
+}
+
+/** Enqueue a transition. Queues the transition of the specified type with the
+ *  specified parameters into the transition queue. If no other transition is
+ *  executing, and the device manager is not suspended, the transition will
+ *  start execution immediately.
+ *
+ *  @param hnd handle to the dm instance
+ *  @param id identifier of the transition
+ *  @param data message structure containing transition parameters
+ *  @param trans_cb completion callback for the transition
+ *  @param trans_data data to be passed to the completion callback
+ *  @param client_data data to be passed to the completion callback
+ *  @return none
+ */
+static void pc2400m_drv_dm_transition(
+        struct pc2400m_drv_dm_if *hnd,
+        enum pc2400m_drv_dm_transitions id,
+        void *data,
+        dm_transition_cb trans_cb,
+        void *trans_data,
+        void *client_data)
+{
+
+        struct pc2400m_drv_dm_trans *trans_info;
+
+        trans_info = pc2400m_drv_dm_trans_new(
+                hnd, id, data, trans_cb, trans_data, client_data);
+
+
+        /* the RESUME operation must go first, if there are multiple items
+           queued otherwise we will never wake up */
+        if (id != PC2400M_DRV_DM_RESUME) {
+                wimax_osal_list_append(
+                        &(hnd->transq), trans_info);
+        } else {
+                wimax_osal_list_push(
+                        &(hnd->transq), trans_info);
+        }
+
+        /* execute if possible */
+        pc2400m_drv_dm_trans_execute(hnd);
+
+        return;
+}
+
+/** Initialize a L3L4 message header. Initialize a L3L4 header with the
+ *  provided parameters into the memory provided by ptr.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @param ptr pointer to the data buffer
+ *  @param type opcode for the message
+ *  @param length length of TLV data to follow the message
+ *  @return none
+ */
+static void pc2400m_drv_dm_setup_header(
+        struct pc2400m_drv_dm_if *hnd,
+        u8* ptr,
+        u16 type,
+        u16 length)
+{
+
+        struct pc2400m_drv_chipif_ctrl_msg *hdr =
+                (struct pc2400m_drv_chipif_ctrl_msg*)ptr;
+
+        PC2400M_DRV_UNWARN(hnd);
+
+        hdr->type = WIMAX_OSAL_U16_TO_LE(type);
+        hdr->length = WIMAX_OSAL_U16_TO_LE(length);
+        hdr->version = WIMAX_OSAL_U16_TO_LE(hnd->chipset.chipif.hdr_version);
+        hdr->accessibility = WIMAX_OSAL_U16_TO_LE(L3L4_ACCESSIBILITY);
+        hdr->status = WIMAX_OSAL_U16_TO_LE(L3L4_RESPONSE_STATUS_SUCCESS_DONE);
+        hdr->reserved = 0;
+        return;
+}
+
+/** Append a TLV into the given message. Append a TLV and initialize the TLV
+ *  header to the message provided. Return pointer to the beginning of the TLV.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @param msg pointer to OSAL packet holding the message
+ *  @param type TLV type
+ *  @param size TLV size
+ *  @return pointer to the beginning of the inserted TLV.
+ */
+static void *pc2400m_drv_dm_insert_tlv(
+        struct pc2400m_drv_dm_if *hnd,
+        wimax_osal_packet *msg,
+        u16 type,
+        u16 size)
+{
+
+        struct L3L4_TLV_HDR_STR *tlv =
+                (struct L3L4_TLV_HDR_STR*)wimax_osal_packet_put(msg, size);
+
+        PC2400M_DRV_UNWARN(hnd);
+
+        tlv->type = WIMAX_OSAL_U16_TO_LE(type);
+        tlv->length = WIMAX_OSAL_U16_TO_LE(
+                size - L3L4_TLV_HDR_LEN);
+
+        return (void*)tlv;
+
+}
+
+
+/** Initialize the dm instance. Initializes internal variables and prepares the
+ *  dm for usage. Initializes the control dispatcher and HDI subsystem. The HDI
+ *  will synchronously download the firmware to the chipset during this call.
+ *
+ *  @param hnd handle to the dm instance
+ *  @param firmware pointer to firmware image
+ *  @param len length of the firmware image
+ *  @param cb initialize completion callback
+ *  @param cbdata data to pass to the callback
+ *  @return none
+ */
+static void pc2400m_drv_dm_initialize(
+        struct pc2400m_drv_dm_if *hnd,
+        u8 *firmware,
+        u32 len,
+        dm_initialize_cb cb,
+        void *cbdata)
+{
+
+        s32 ret = 0;
+
+        wimax_osal_assert(hnd->cd != NULL);
+        wimax_osal_assert(hnd->hdi != NULL);
+        wimax_osal_assert(cb);
+
+        /* on subsequent calls to initialize do not perform actual
+           initialization -> only return success to indicate that
+           initialization has actually been performed. */
+        if (hnd->state == L3L4_SYSTEM_STATE_UNINITIALIZED) {
+
+                /* initialize the subsystems required for the dm */
+                hnd->cd->initialize(hnd->cd, hnd->hdi);
+
+                /* put down the link state in control dispatcher */
+                hnd->cd->link_state(hnd->cd, FALSE);
+
+                /* register global DM indications */
+                hnd->cd->register_indication(
+                        hnd->cd,
+                        L3_L4_OPCODE_REPORT_STATE,
+                        pc2400m_drv_dm_ind_report_state,
+                        (void*)hnd);
+
+                hnd->cd->register_indication(
+                        hnd->cd,
+                        L3_L4_OPCODE_REPORT_EAP_RESTART,
+                        pc2400m_drv_dm_ind_eap_restart,
+                        (void*)hnd);
+
+                if (hnd->hdi->initialize(hnd->hdi, firmware, len,
+                                         pc2400m_drv_dm_interrupt))
+                        goto err3;
+
+                /* clear flags (suspension etc) */
+                hnd->flags = 0;
+
+                /* specify an initial network state */
+                hnd->chipset.trans.network_status =
+                        E_WIHAL_NETWORK_STATUS_DISCONNECTED;
+
+#ifdef PC2400M_DRV_DM_LOCK_SESSION_BANDWIDTH
+                /* reset locked bandwidth */
+                hnd->locked_bandwidth = E_WIHAL_CHANNEL_BANDWIDTH_NA;
+#endif /* PC2400M_DRV_DM_LOCK_SESSION_BANDWIDTH */
+
+                /* upgrade state */
+                RESET_STATE(hnd->state);
+
+        }
+
+        /* return to sender */
+        cb(hnd, ESUCCESS, cbdata);
+
+        goto out;
+
+ err3:
+        hnd->cd->reset(hnd->cd);
+        hnd->hdi->reset(hnd->hdi);
+
+        ret = -EGENERAL;
+        cb(hnd, ret, cbdata);
+ out:
+        return;
+
+}
+
+/** Remove an instance of the device manager. Free the memory and resources
+ *  used up by the specified instance of the device manager.
+ *
+ *  @param hnd pointer to the instance of the device manager
+ *  @return none
+ */
+static void pc2400m_drv_dm_cleanup(struct pc2400m_drv_dm_if *hnd)
+{
+
+        hnd->reset(hnd);
+
+        /* the lists are empty at this stage, but must be de-initialized */
+        wimax_osal_list_release(&(hnd->transq), NULL);
+        wimax_osal_list_release(&(hnd->abort_cb_queue), NULL);
+
+
+        /* unregister indications */
+        hnd->cd->register_indication(
+                hnd->cd, L3_L4_OPCODE_REPORT_STATE, NULL, NULL);
+
+        hnd->cd->register_indication(
+                hnd->cd, L3_L4_OPCODE_REPORT_EAP_RESTART, NULL, NULL);
+
+        /* get rid of the control dispatcher */
+        hnd->cd->cleanup(hnd->cd);
+        hnd->hdi->cleanup(hnd->hdi);
+
+        wimax_osal_mem_free((void**)&hnd);
+
+}
+
+
+/** Handle background transition completion. Process the completion of a
+ *  background transition by allowing further transitions in the queue to
+ *  beging executing. Cleanup the resources used by the background transition.
+ *
+ *  @param hnd handle to the device manager instance
+ *  @param bg handle to the background transition instance
+ *  @param id type of the background transition
+ *  @param status end status of the background transition
+ *  @param data user data for the completion call, unused
+ *  @return none
+ */
+static void pc2400m_drv_dm_bg_complete(
+        struct pc2400m_drv_dm_if *hnd,
+        struct pc2400m_drv_dm_bg_if *bg,
+        enum pc2400m_drv_dm_bg_transitions id,
+        s32 status,
+        void *data)
+{
+
+        PC2400M_DRV_UNWARN(status);
+        PC2400M_DRV_UNWARN(data);
+
+        wimax_osal_assert(hnd->bg == bg);
+        wimax_osal_assert(
+                id == PC2400M_DRV_DM_BG_SCAN_NAP ||
+                id == PC2400M_DRV_DM_BG_SCAN_NSP ||
+                id == PC2400M_DRV_DM_BG_CONNECT ||
+                id == PC2400M_DRV_DM_BG_DISCONNECT);
+
+
+        /* destroy the bg instance */
+        bg->cleanup(bg);
+        hnd->bg = NULL;
+
+        /* awake the bg synchronization transition */
+        if (hnd->trans && hnd->trans->id == PC2400M_DRV_DM_BG_SYNCH) {
+                pc2400m_drv_dm_trans_complete(hnd, ESUCCESS);
+        }
+
+}
+
+/** Go back to initial state. Abort all ongoing actions immediately and go back
+ *  to boot state assuming the chip is dead or rebooted. All resources of the
+ *  device manager and subsystems (control dispatcher and the HDI)
+ *  will be released.
+ *
+ *  @param hnd pointer to the instance of the device manager
+ *  @return none
+ */
+static void pc2400m_drv_dm_abort_mission(struct pc2400m_drv_dm_if *hnd)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->ctx);
+        struct pc2400m_drv_dm_abort_cb *pos;
+        struct pc2400m_drv_dm_abort_cb *npos;
+
+        /* call functions in the abort mission callback stack */
+        wimax_osal_list_foreach_safe(&(hnd->abort_cb_queue), pos, npos) {
+
+                /* the abort mission call back shall clean itself
+                   from the queue during this call */
+                wimax_osal_assert(pos->cb);
+                pos->cb(hnd, pos->data);
+        }
+
+        /* bring the remaining system to initial state */
+        hnd->reset(hnd);
+
+        /* power down the chipset */
+        priv->aif->set_power(priv->ctx, FALSE);
+
+        /* send indication to client */
+        priv->send_system_state_ind(
+                hnd->ctx, E_WIHAL_SYSTEM_STATE_FATAL_ERROR);
+
+        return;
+
+}
+
+
+/** Register call back to be called upon an abort mission. This function
+ *  registers a callback function to be called just before the system is
+ *  taken down during an abort mission handling.
+ *
+ *  @param hnd pointer to the instance of the device manager
+ *  @param cb pointer to callback function
+ *  @param data client cookie data to be passed to the callback
+ *  @return handle to the callback
+ */
+static void *pc2400m_drv_dm_abort_mission_cb_register(
+        struct pc2400m_drv_dm_if *hnd,
+        dm_abort_mission_cb cb,
+        void *data)
+{
+
+        struct pc2400m_drv_dm_abort_cb *new;
+
+        new = wimax_osal_mem_alloc(sizeof(struct pc2400m_drv_dm_abort_cb));
+        new->cb = cb;
+        new->data = data;
+        WIMAX_OSAL_LIST_ELEM_HDR_INIT(&(new->list));
+
+        /* append the new callback to the list */
+        wimax_osal_list_append(&(hnd->abort_cb_queue), new);
+
+        return new;
+
+}
+
+
+/** Unregister call back to be called upon an abort mission. This function
+ *  removes a prior registration from the list.
+ *
+ *  @param hnd pointer to the instance of the device manager
+ *  @param handle handle to the callback
+ *  @return none
+ */
+static void pc2400m_drv_dm_abort_mission_cb_unregister(
+        struct pc2400m_drv_dm_if *hnd,
+        void *handle)
+{
+
+        /* append the new callback to the list */
+        wimax_osal_list_remove(&(hnd->abort_cb_queue), handle);
+        wimax_osal_mem_free((void**)&handle);
+
+        return;
+
+}
+
+
+/** Enable or disable data filtering. Enable / disable data filtering from the
+ *  chipset.
+ *
+ *  @param hnd pointer to the instance of the device manager
+ *  @param enable TRUE to enable data flow, FALSE to disable it
+ *  @return none
+ */
+static void pc2400m_drv_dm_set_data_filter(
+        struct pc2400m_drv_dm_if *hnd, boolean enable)
+{
+
+        struct L3L4_TLV_STR_D2H_CHANNEL_MASK *cmask;
+        wimax_osal_packet *msg;
+
+        msg = wimax_osal_packet_alloc(
+                L3L4_TLV_SIZE_D2H_CHANNEL_MASK +
+                PC2400M_DRV_CHIPIF_CTRL_MSG_LEN);
+
+        hnd->setup_header(
+                hnd,
+                wimax_osal_packet_put(
+                        msg, PC2400M_DRV_CHIPIF_CTRL_MSG_LEN),
+                L4_L3_OPCODE_SET_D2H_CHANNEL_MASK,
+                L3L4_TLV_SIZE_D2H_CHANNEL_MASK);
+
+        cmask = hnd->insert_tlv(hnd, msg,
+                                L3L4_TLV_TYPE_D2H_CHANNEL_MASK,
+                                L3L4_TLV_SIZE_D2H_CHANNEL_MASK);
+
+        cmask->data_channel_switch =
+                (u8)(enable?
+                     L3L4_D2H_CHANNEL_SWITCH_ON:
+                     L3L4_D2H_CHANNEL_SWITCH_OFF);
+        cmask->diagnostics_channel_switch =
+                (u8)L3L4_D2H_CHANNEL_SWITCH_ON;
+        cmask->reserved1 = 0;
+        cmask->reserved2 = 0;
+
+        /* off with the message, expect no response */
+        hnd->cd->msg_enqueue(
+                hnd->cd, msg, NULL, (void*)hnd,
+                PC2400M_CD_FLAG_URGENT);
+
+}
+
+/*****************************************************************************
+ * Exported functions
+ */
+
+/** Create new instance of the device manager. Allocate and initialize a new
+ *  instance of the device manager module, bound to a specific device instance.
+ *
+ *  @param ctx the device context to bind this dm instance to
+ *  @return none
+ */
+struct pc2400m_drv_dm_if *pc2400m_drv_dm_if_new(wimax_osal_context* ctx) {
+
+        struct pc2400m_drv_dm_if *iface;
+
+        iface = (struct pc2400m_drv_dm_if*)
+                  wimax_osal_mem_alloc(sizeof(struct pc2400m_drv_dm_if));
+        wimax_osal_mem_set(
+                iface, 0x00, sizeof(struct pc2400m_drv_dm_if));
+        iface->ctx = ctx;
+        iface->cleanup = pc2400m_drv_dm_cleanup;
+        iface->reset = pc2400m_drv_dm_reset;
+        iface->initialize = pc2400m_drv_dm_initialize;
+        iface->abort_mission = pc2400m_drv_dm_abort_mission;
+        iface->abort_mission_cb_register =
+                pc2400m_drv_dm_abort_mission_cb_register;
+        iface->abort_mission_cb_unregister =
+                pc2400m_drv_dm_abort_mission_cb_unregister;
+        iface->transition = pc2400m_drv_dm_transition;
+        iface->get_tlv = pc2400m_drv_dm_get_tlv;
+        iface->setup_header = pc2400m_drv_dm_setup_header;
+        iface->insert_tlv = pc2400m_drv_dm_insert_tlv;
+        iface->bg_complete = pc2400m_drv_dm_bg_complete;
+        iface->set_data_filter = pc2400m_drv_dm_set_data_filter;
+        iface->get_network_status = pc2400m_drv_dm_get_network_status;
+
+        /* instance variables */
+        wimax_osal_mem_set(&(iface->chipset), 0x00,
+                           sizeof(struct pc2400m_drv_dm_chipset));
+
+        iface->cd = pc2400m_drv_cd_if_new(ctx);
+        iface->hdi = pc2400m_drv_hdi_if_new(ctx);
+
+        /* prepare the OSAL list used as transition queue */
+        wimax_osal_list_initialize(
+                &(iface->transq),
+                WIMAX_OSAL_LIST_ELEM_HDR_OFFSET(
+                        struct pc2400m_drv_dm_trans, list));
+
+        /* prepare the OSAL list used abort mission callback queue */
+        wimax_osal_list_initialize(
+                &(iface->abort_cb_queue),
+                WIMAX_OSAL_LIST_ELEM_HDR_OFFSET(
+                        struct pc2400m_drv_dm_abort_cb, list));
+
+
+        RESET_STATE(iface->state);
+
+        return iface;
+
+}
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_dm.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_dm.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_dm.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_dm.h	2011-02-06 20:12:11.829999938 -0500
@@ -0,0 +1,273 @@
+/*
+ * pc2400m_drv_dm.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         31      APPROVED 06-Aug-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_drv_dm.h
+ *
+ * This file declares the Device Manager.
+ *
+ */
+
+#ifndef PC2400M_DRV_DM_H
+#define PC2400M_DRV_DM_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include "pc2400m_osal.h"
+#include "pc2400m_drv_if.h"
+#include "pc2400m_drv_dm_bg.h"
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/** transition identifiers */
+enum pc2400m_drv_dm_transitions {
+        PC2400M_DRV_DM_ENABLE_RADIO = 0,
+        PC2400M_DRV_DM_DISABLE_RADIO,
+        PC2400M_DRV_DM_START_SCAN,
+        PC2400M_DRV_DM_STOP_SCAN,
+        PC2400M_DRV_DM_START_SCAN_NSP,
+        PC2400M_DRV_DM_STOP_SCAN_NSP,
+        PC2400M_DRV_DM_CONNECT,
+        PC2400M_DRV_DM_DISCONNECT,
+        PC2400M_DRV_DM_CONFIGURE,
+        PC2400M_DRV_DM_TERMINATE,
+        PC2400M_DRV_DM_PRODUCTION,
+        PC2400M_DRV_DM_SUSPEND,
+        PC2400M_DRV_DM_RESUME,
+        PC2400M_DRV_DM_BG_SYNCH,
+};
+
+/** chipset API version differentiation */
+#ifdef PC2400M_OLD_FW_SUPPORT
+#define IS_CHIPSET_API_VERSION(hnd, ver) \
+        ((hnd)->chipset.chipif.version == (ver))
+#define IS_CHIPSET_API_BETA(hnd) \
+        (IS_CHIPSET_API_VERSION(hnd, L3L4_VERSION_BETA)||\
+         IS_CHIPSET_API_VERSION(hnd, L3L4_VERSION_BETA30)||\
+         IS_CHIPSET_API_VERSION(hnd, L3L4_VERSION_BETA47))
+#define IS_CHIPSET_API_BETA30(hnd) \
+        (IS_CHIPSET_API_VERSION(hnd, L3L4_VERSION_BETA30)||\
+         IS_CHIPSET_API_VERSION(hnd, L3L4_VERSION_BETA47))
+#define IS_CHIPSET_API_BETA47(hnd) \
+        IS_CHIPSET_API_VERSION(hnd, L3L4_VERSION_BETA47)
+#endif /* PC2400M_OLD_FW_SUPPORT */
+
+/* system state mapping */
+#define PC2400M_DRV_DM_UNINITIALIZED(hnd)       L3L4_SYSTEM_STATE_UNINITIALIZED
+#define PC2400M_DRV_DM_INIT(hnd)                L3L4_SYSTEM_STATE_INIT
+#define PC2400M_DRV_DM_READY(hnd)               L3L4_SYSTEM_STATE_READY
+#define PC2400M_DRV_DM_SCAN(hnd)                L3L4_SYSTEM_STATE_SCAN
+#define PC2400M_DRV_DM_CONNECTING(hnd)          L3L4_SYSTEM_STATE_CONNECTING
+#define PC2400M_DRV_DM_WIMAX_CONNECTED(hnd) \
+        L3L4_SYSTEM_STATE_WIMAX_CONNECTED
+#define PC2400M_DRV_DM_DATA_PATH_CONNECTED(hnd) \
+        L3L4_SYSTEM_STATE_DATA_PATH_CONNECTED
+#define PC2400M_DRV_DM_IDLE(hnd)                L3L4_SYSTEM_STATE_IDLE
+#define PC2400M_DRV_DM_DISCONNECTING(hnd)       L3L4_SYSTEM_STATE_DISCONNECTING
+#define PC2400M_DRV_DM_PRODUCTION(hnd)          L3L4_SYSTEM_STATE_PRODUCTION
+#define PC2400M_DRV_DM_CONFIG(hnd)              L3L4_SYSTEM_STATE_CONFIG
+#define PC2400M_DRV_DM_RF_OFF(hnd)              L3L4_SYSTEM_STATE_RF_OFF
+#define PC2400M_DRV_DM_RF_SHUTDOWN(hnd)         L3L4_SYSTEM_STATE_RF_SHUTDOWN
+
+
+/*****************************************************************************
+ * Data types
+ */
+
+struct pc2400m_drv_dm_if;
+struct pc2400m_drv_cd_if;
+struct pc2400m_drv_hdi_if;
+
+/** transition parameters */
+struct pc2400m_drv_dm_configure_params {
+        struct t_wihal_cmd_configure req;
+        struct t_wihal_capabilities capa;
+};
+
+/** dm functions */
+typedef void (*dm_reset_func)(struct pc2400m_drv_dm_if*);
+typedef void (*dm_cleanup_func)(struct pc2400m_drv_dm_if*);
+typedef void (*dm_initialize_cb)(struct pc2400m_drv_dm_if*, s32, void*);
+typedef void (*dm_initialize_func)(
+        struct pc2400m_drv_dm_if*,
+        u8*, u32, dm_initialize_cb, void*);
+typedef void (*dm_abort_mission_func)(struct pc2400m_drv_dm_if*);
+typedef void (*dm_abort_mission_cb)(struct pc2400m_drv_dm_if*, void*);
+typedef void* (*dm_abort_mission_cb_register_func)(
+        struct pc2400m_drv_dm_if*,
+        dm_abort_mission_cb,
+        void*);
+typedef void (*dm_abort_mission_cb_unregister_func)(
+        struct pc2400m_drv_dm_if*,
+        void*);
+
+typedef void (*dm_transition_cb)(
+        struct pc2400m_drv_dm_if*, s32,
+        void*, void*, void*);
+typedef void (*dm_transition_func)(
+        struct pc2400m_drv_dm_if*,
+        enum pc2400m_drv_dm_transitions,
+        void*, dm_transition_cb, void*, void*);
+typedef u8* (*dm_get_tlv_func)(struct pc2400m_drv_dm_if*, u8*, u16, u8*);
+typedef void (*dm_setup_header_func)(struct pc2400m_drv_dm_if*, u8*, u16, u16);
+typedef void (*dm_set_data_filter_func)(struct pc2400m_drv_dm_if*, boolean);
+typedef void (*dm_bg_complete_func)(
+        struct pc2400m_drv_dm_if*,
+        struct pc2400m_drv_dm_bg_if*,
+        enum pc2400m_drv_dm_bg_transitions,
+        s32,
+        void*);
+typedef void* (*dm_insert_tlv_func)(
+        struct pc2400m_drv_dm_if*,
+        wimax_osal_packet*,
+        u16,
+        u16);
+typedef void (*dm_get_network_status_func)(struct pc2400m_drv_dm_if*, void*);
+
+/** structure to hold the chipset state cache */
+struct pc2400m_drv_dm_chipset {
+        struct {
+#define PC2400M_DRV_DM_LM_VERSION_LEN 3
+                u16 L4Mversion[PC2400M_DRV_DM_LM_VERSION_LEN];
+                u8 hw_version[WIHAL_VERSION_STR_LEN];
+                u8 fw_version[WIHAL_VERSION_STR_LEN];
+                u8 model_name[WIHAL_MODEL_STR_LEN];
+                u8 manuf_name[WIHAL_MODEL_STR_LEN];
+                u8 ser_number[WIHAL_SERIAL_NBR_STR_LEN];
+#define DM_MAC_ADDR_LEN 6
+                u8 mac_addr[DM_MAC_ADDR_LEN];
+                u8 set;
+        } cap;
+        struct {
+                u8 rssi;
+                u8 cinr;
+                u8 nsp_realm_len;
+                u8 *nsp_realm;
+                u8 up;
+                u8 set;
+                u8 bs_id[WIHAL_BSID_LENGTH];
+                u8 last_bs_id[WIHAL_BSID_LENGTH];
+                struct t_wihal_search_plan channel_plan;
+#define PC2400M_DRV_DM_CHIPSET_CHANNEL_SET_BSID           0x01
+#define PC2400M_DRV_DM_CHIPSET_CHANNEL_SET_LAST_BSID      0x02
+#define PC2400M_DRV_DM_CHIPSET_CHANNEL_SET_CHANNEL_INFO   0x04
+                u8 channel_set;
+        } link;
+        struct {
+                boolean hw_switch;
+        } rf;
+        struct {
+                enum t_wihal_network_status_err disconnect_status;
+                enum t_wihal_network_status network_status;
+        } trans;
+        struct {
+                u32 signal_time_threshold;
+                u32 signal_recovery_limit;
+                u32 idle_timer;
+                u32 idle_paging_interval;
+                u32 sleep_timer;
+                enum t_wihal_handover_scheme handover_scheme;
+                t_wihal_bsid bsid;
+        } config;
+        struct {
+                u16 version;
+                u16 hdr_version;
+        } chipif;
+        u8 state;
+};
+
+
+/* structure representing the control dispatcher */
+struct pc2400m_drv_dm_if {
+        wimax_osal_context *ctx;
+        dm_cleanup_func cleanup;
+        dm_reset_func reset;
+        dm_initialize_func initialize;
+        dm_abort_mission_func abort_mission;
+        dm_abort_mission_cb_register_func abort_mission_cb_register;
+        dm_abort_mission_cb_unregister_func abort_mission_cb_unregister;
+        dm_transition_func transition;
+        dm_get_tlv_func get_tlv;
+        dm_setup_header_func setup_header;
+        dm_insert_tlv_func insert_tlv;
+        dm_bg_complete_func bg_complete;
+
+        dm_set_data_filter_func set_data_filter;
+        dm_get_network_status_func get_network_status;
+
+        /* instance variables */
+        struct pc2400m_drv_cd_if *cd;
+        struct pc2400m_drv_hdi_if *hdi;
+
+        /* dm state flags */
+#define PC2400M_DRV_DM_FLAGS_SUSPENDED    0x00000001
+#define PC2400M_DRV_DM_FLAGS_CONFIGURED   0x00000004
+        u32 flags;
+
+        /* system state */
+        u32 state;
+
+        /* transition queue */
+        struct wimax_osal_list transq;
+
+        /* abort mission callback queue */
+        struct wimax_osal_list abort_cb_queue;
+
+        /* current transition information */
+        struct pc2400m_drv_dm_trans *trans;
+
+        /* ongoing background operation */
+        struct pc2400m_drv_dm_bg_if *bg;
+
+        /* handover timer handle */
+        wimax_osal_timer_handle handover_timer;
+
+        /* chipset state information */
+        struct pc2400m_drv_dm_chipset chipset;
+
+#ifdef PC2400M_DRV_DM_LOCK_SESSION_BANDWIDTH
+        /* chosen bandwidth for this session */
+        enum t_wihal_channel_bandwidth locked_bandwidth;
+#endif /* PC2400M_DRV_DM_LOCK_SESSION_BANDWIDTH */
+
+};
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/** dm instantiator function */
+extern struct pc2400m_drv_dm_if *pc2400m_drv_dm_if_new(
+        wimax_osal_context* ctx);
+
+#endif /* PC2400M_DRV_DM_H */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv.h	2011-02-06 20:12:11.539999941 -0500
@@ -0,0 +1,58 @@
+/*
+ * pc2400m_drv.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         12      APPROVED 21-Feb-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_drv.h
+ *
+ * Common driver interface handler declaration.
+ *
+ */
+
+#ifndef PC2400M_DRV_H
+#define PC2400M_DRV_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include "pc2400m_drv_if.h"
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/*****************************************************************************
+ * Data types
+ */
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+#endif /* PC2400M_DRV_H */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_hdi.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_hdi.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_hdi.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_hdi.h	2011-02-06 20:12:11.779999941 -0500
@@ -0,0 +1,97 @@
+/*
+ * pc2400m_drv_hdi.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         10      APPROVED 21-Feb-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_drv_hdi.h
+ *
+ * This file defines the Hardware Device Interface, which is implemented
+ * by the SPI module.
+ *
+ */
+
+#ifndef PC2400M_DRV_HDI_H
+#define PC2400M_DRV_HDI_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include "pc2400m_osal.h"
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/*****************************************************************************
+ * Data types
+ */
+
+struct pc2400m_drv_hdi_if;
+
+typedef spi_irq_cb pc2400m_hdi_int_cb;
+typedef wimax_osal_packet* (*pc2400m_hdi_put_fnc)(
+        struct pc2400m_drv_hdi_if*,
+        wimax_osal_packet*,s32);
+typedef wimax_osal_packet* (*pc2400m_hdi_get_fnc)(
+        struct pc2400m_drv_hdi_if*, s32*);
+typedef s32 (*pc2400m_hdi_write_fnc)(struct pc2400m_drv_hdi_if*);
+typedef s32 (*pc2400m_hdi_read_fnc)(struct pc2400m_drv_hdi_if*);
+typedef s32 (*pc2400m_hdi_init_fnc)(
+        struct pc2400m_drv_hdi_if*,
+        u8*,
+        u32,
+        pc2400m_hdi_int_cb);
+typedef void (*pc2400m_hdi_irq_off_fnc)(struct pc2400m_drv_hdi_if*);
+typedef void (*pc2400m_hdi_cleanup_fnc)(struct pc2400m_drv_hdi_if*);
+typedef void (*pc2400m_hdi_reset_fnc)(struct pc2400m_drv_hdi_if*);
+
+struct pc2400m_drv_hdi_if {
+        pc2400m_hdi_put_fnc put;
+        pc2400m_hdi_get_fnc get;
+        pc2400m_hdi_write_fnc write;
+        pc2400m_hdi_read_fnc read;
+        pc2400m_hdi_init_fnc initialize;
+        pc2400m_hdi_irq_off_fnc irq_off;
+        pc2400m_hdi_reset_fnc reset;
+        pc2400m_hdi_cleanup_fnc cleanup;
+
+        wimax_osal_context *ctx;
+
+};
+
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/** instantiator function for the HDI */
+struct pc2400m_drv_hdi_if *pc2400m_drv_hdi_if_new(wimax_osal_context* ctx);
+
+
+#endif /* PC2400M_DRV_HDI_H */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_iffunc.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_iffunc.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_iffunc.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_iffunc.h	2011-02-06 20:12:11.619999940 -0500
@@ -0,0 +1,104 @@
+/*
+ * pc2400m_drv_iffunc.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         6       APPROVED 21-Feb-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_drv_iffunc.h
+ *
+ * This file defines the function prototypes used in WiHAL communication.
+ *
+ */
+
+#ifndef PC2400M_DRV_IFFUNC_H
+#define PC2400M_DRV_IFFUNC_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include "pc2400m_osal.h"
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/*****************************************************************************
+ * Data types
+ */
+
+struct t_wihal_cmd;
+struct t_wihal_resp;
+struct t_wihal_ind;
+
+/** function for executing a command opcode */
+typedef void (*t_wihal_cmd_fnc)(
+        wimax_osal_context*,
+        struct t_wihal_cmd*,
+        void*);
+
+/** function returning the response opcode */
+typedef void (*t_wihal_cmd_response_fnc)(
+        wimax_osal_context*,
+        struct t_wihal_resp*,
+        void*);
+
+/** function sending an indication opcode */
+typedef void (*t_wihal_indication_fnc)(
+        wimax_osal_context*,
+        struct t_wihal_ind*);
+
+/** structure defining the driver interface to the client */
+struct t_wihal_driver_if {
+        /** command exectution function */
+        t_wihal_cmd_fnc wimax_cmd;
+};
+
+struct t_wihal_adaptation_if;
+struct t_wihal_event_if;
+
+/** declare function for retrieving an instance of the driver module */
+#ifndef __cplusplus
+struct t_wihal_driver_if *pc2400m_drv_wihal_open(
+        wimax_osal_context *ctx,
+        struct t_wihal_event_if *eif,
+        struct t_wihal_adaptation_if *aif);
+#else
+extern "C" struct t_wihal_driver_if *pc2400m_drv_wihal_open(
+        wimax_osal_context *ctx,
+        struct t_wihal_event_if *eif,
+        struct t_wihal_adaptation_if *aif);
+#endif
+
+/** macro to remove client symbol dependency to the OPEN function */
+#define WIHAL_OPEN(ctx, eif, aif) pc2400m_drv_wihal_open(ctx, eif, aif)
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+#endif /* PC2400M_DRV_IFFUNC_H */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_if.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_if.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_if.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_if.h	2011-02-06 20:12:12.069999938 -0500
@@ -0,0 +1,741 @@
+/*
+ * pc2400m_drv_if.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         38      APPROVED 09-Sep-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_drv_if.h
+ *
+ * This function defines the WiHAL interface used by this driver.
+ *
+ */
+
+#ifndef PC2400M_DRV_IF_H
+#define PC2400M_DRV_IF_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include "pc2400m_osal.h"
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/**
+
+     INTERFACE IDIOMS
+     ----------------
+
+      1. Concurrent access to the operands is prohibited; all access must
+         be synchronized.
+
+      2. All access to the operands must be in sleep-able process context.
+
+      3. All responses through this interface can be assumed to be in sleep-
+         able process context and concurrency protected.
+
+      4. Ownership of the message structures remain with the caller - the
+         callee may assume the data is valid only for the duration of the
+         invoked function call. Exceptions are listed for each operand
+         individually.
+
+         This rule includes all sub pointers pointed to by the main operand
+         parameter structures.
+
+*/
+
+/*
+ * interface version
+ */
+
+/** WiHAL interface version major */
+#define WIHAL_VERSION_MAJOR  3
+
+/** WiHAL interface version minor */
+#define WIHAL_VERSION_MINOR  0
+
+/** WiHAL interface version string */
+#define WIHAL_VERSION_STR    "3.0"
+
+/*****************************************************************************
+ * Data types
+ */
+
+/*
+ * bitfield definitions
+ */
+
+/** signal lost treshold present in configuration */
+#define E_WIHAL_CONFIG_MASK_SIGNAL_RECOVERY_LIMIT 0x00000002
+/** idle timer value present in configuration */
+#define E_WIHAL_CONFIG_MASK_IDLE_TIMER            0x00000004
+/** handover lock present in configuration */
+#define E_WIHAL_CONFIG_MASK_HANDOVER_LOCK         0x00000008
+/** basestation id present in configuration */
+#define E_WIHAL_CONFIG_MASK_BS_ID                 0x00000010
+/** idle paging timer present in configuration */
+#define E_WIHAL_CONFIG_MASK_IDLE_PAGING_INTERVAL  0x00000020
+/** sleep timer present in configuration */
+#define E_WIHAL_CONFIG_MASK_SLEEP_TIMER           0x00000040
+/** configuration mask  */
+typedef u32 t_wihal_config_mask;
+
+/*
+ * boolean definitions
+ */
+/** boolean value TRUE */
+#define E_WIHAL_TRUE                     1
+/** boolean value FALSE */
+#define E_WIHAL_FALSE                    0
+/** boolean datatype */
+typedef boolean t_wihal_bool;
+
+/** EDataSend fixed credit size */
+#define WIHAL_DATA_SEND_CREDIT_LEN     10
+
+
+/*
+ * enumerations types
+ */
+
+
+/** common operation result status codes */
+enum t_wihal_status {
+        E_WIHAL_SUCCESS = 1,               /**< operation successfull */
+        E_WIHAL_ERR_FAILURE = 20,          /**< generic failure */
+        E_WIHAL_ERR_INVALID_STATE,         /**< invalid state for operation */
+        E_WIHAL_ERR_INVALID_VALUE,         /**< invalid parameter value */
+};
+
+/** network/connection status codes */
+enum t_wihal_network_status {
+        E_WIHAL_NETWORK_STATUS_CONNECTED = 1,      /**< connected */
+        E_WIHAL_NETWORK_STATUS_DISCONNECTED,       /**< disconnected */
+        E_WIHAL_NETWORK_STATUS_LOST,               /**< connection lost */
+        E_WIHAL_NETWORK_STATUS_RECONNECTED,        /**< connection resumed */
+        E_WIHAL_NETWORK_STATUS_HANDOVER = 10,      /**< handover */
+        E_WIHAL_NETWORK_STATUS_RANGING = 50,       /**< ranging ongoing */
+        /** capability negotiation */
+        E_WIHAL_NETWORK_STATUS_CAPABILITY_NEGOTIATION,
+        E_WIHAL_NETWORK_STATUS_AUTHENTICATION,     /**< authentication ongoing
+                                                    */
+        /** 3-way handshake ongoing */
+        E_WIHAL_NETWORK_STATUS_3_WAY_HANDSHAKE,
+        E_WIHAL_NETWORK_STATUS_REGISTRATION,       /**< registering to nw */
+        E_WIHAL_NETWORK_STATUS_DATA_PATH_CREATION, /**< negotiating service
+                                                    *   flows */
+        E_WIHAL_NETWORK_STATUS_IP_RENEW = 100,     /**< DHCP negotiation or
+                                                        HA reregistration
+                                                        required. */
+        E_WIHAL_NETWORK_STATUS_EAP_RESTART,        /**< EAP negotiation will
+                                                        restart. */
+};
+
+/** connection error codes */
+enum t_wihal_network_status_err {
+        E_WIHAL_NETWORK_STATUS_ERR_NONE = 0,         /**< no error */
+        /** network initiated exit */
+        E_WIHAL_NETWORK_STATUS_ERR_EXIT_BY_NETWORK,
+        /** reset sent by network */
+        E_WIHAL_NETWORK_STATUS_ERR_RESET_BY_NETWORK,
+        /** connection has been lost */
+        E_WIHAL_NETWORK_STATUS_ERR_CONNECTION_LOST,
+        /** connection creation failed */
+        E_WIHAL_NETWORK_STATUS_ERR_CONNECTION_CREATION = 20,
+        /** ranging failed */
+        E_WIHAL_NETWORK_STATUS_ERR_RANGING,
+        /** capability negotiation failed */
+        E_WIHAL_NETWORK_STATUS_ERR_CAPABILITY_NEGOTIATION,
+        /** authentication failed */
+        E_WIHAL_NETWORK_STATUS_ERR_AUTHENTICATION,
+        /** 3-way handshake failed */
+        E_WIHAL_NETWORK_STATUS_ERR_3_WAY_HANDSHAKE,
+        /** registration failed */
+        E_WIHAL_NETWORK_STATUS_ERR_REGISTRATION,
+        /** initial service flow creation failed */
+        E_WIHAL_NETWORK_STATUS_ERR_DATA_PATH_CREATION,
+        /** re-authentication failed */
+        E_WIHAL_NETWORK_STATUS_ERR_REAUTHENTICATION_FAIL,
+};
+
+/** system state codes */
+enum t_wihal_system_state {
+        E_WIHAL_SYSTEM_STATE_FATAL_ERROR = 1,      /**< fatal error, reinit
+                                                    *   needed */
+};
+
+/** radio state codes */
+enum t_wihal_radio_state {
+        E_WIHAL_RADIO_STATE_OFF = 0,               /**< radio off */
+        E_WIHAL_RADIO_STATE_ON,                    /**< radio on */
+};
+
+/** channel bandwidth codes */
+enum t_wihal_channel_bandwidth {
+        E_WIHAL_CHANNEL_BANDWIDTH_NA = 0x00,       /**< bandwidth info not
+                                                    *   available */
+        E_WIHAL_CHANNEL_BANDWIDTH_3_5MHZ,          /**< bandwidth 3.5MHz */
+        E_WIHAL_CHANNEL_BANDWIDTH_5MHZ,            /**< bandwidth 5MHz */
+        E_WIHAL_CHANNEL_BANDWIDTH_7MHZ,            /**< bandwidth 7MHz */
+        E_WIHAL_CHANNEL_BANDWIDTH_8_75MHZ,         /**< bandwidth 8.75MHz */
+        E_WIHAL_CHANNEL_BANDWIDTH_10MHZ,           /**< bandwidth 10MHz */
+};
+
+/** classification rule operations */
+enum t_wihal_crule_operation {
+        E_WIHAL_CRULE_OPERATION_NONE = 0,  /**< classification not modified */
+        E_WIHAL_CRULE_OPERATION_CREATE,    /**< classification rule created */
+        E_WIHAL_CRULE_OPERATION_REPLACE,   /**< classification rule replaced */
+        E_WIHAL_CRULE_OPERATION_DELETE,    /**< classification rule deleted */
+};
+
+
+/** fft size codes */
+enum t_wihal_fft_size {
+        E_WIHAL_FFT_SIZE_NA = 0x00,             /**< fft size not available */
+        E_WIHAL_FFT_SIZE_512,                   /**< fft size 512 */
+        E_WIHAL_FFT_SIZE_1024,                  /**< fft size 1024 */
+};
+
+/** handover scheme codes */
+enum t_wihal_handover_scheme {
+        E_WIHAL_HANDOVER_SCHEME_NA = 0,          /**< ho scheme not avail */
+        E_WIHAL_HANDOVER_SCHEME_NORMAL,          /**< device controlled intra
+                                                  *   nap handovers */
+        E_WIHAL_HANDOVER_SCHEME_BS_LOCK,         /**< BS id locked */
+};
+
+/** NAP and NSP have same ID flag values */
+enum t_wihal_nap_and_nsp {
+        E_WIHAL_NAP_AND_NSP_NA = 0,
+        E_WIHAL_NAP_AND_NSP_FALSE,
+        E_WIHAL_NAP_AND_NSP_TRUE,
+};
+
+/** NAP identifier mask values */
+enum t_wihal_nap_id_mask {
+        E_WIHAL_NAP_ID_MASK_NA = 0x00000000,
+        E_WIHAL_NAP_ID_MASK_COMPRESSED = 0x000000ff,
+        E_WIHAL_NAP_ID_MASK_FULL = 0x00ffffff,
+};
+
+/** search result NSP information amount codes */
+enum t_wihal_search_nsp_info_req {
+        E_WIHAL_SEARCH_NSP_INFO_REQ_NONE = 0,    /**< search for no NSP info */
+        E_WIHAL_SEARCH_NSP_INFO_REQ_NSP_LIST,    /**< search for NSP list */
+        /** search for NSP list and associated names */
+        E_WIHAL_SEARCH_NSP_INFO_REQ_NSP_LIST_AND_NAMES,
+};
+
+
+
+/*
+ * standard types
+ */
+
+#define WIHAL_BSID_LENGTH   6                  /**< length of the BSid */
+typedef u8 t_wihal_bsid[WIHAL_BSID_LENGTH];    /**< 48 bit BS identifier */
+typedef u8 t_wihal_cinr;                       /**< CINR in dB, range -10db-
+                                                *   53db, encoded as 0x00-
+                                                *   0x3f */
+typedef wimax_osal_packet* t_wihal_data_block; /**< data packet */
+/** data packet list */
+typedef wimax_osal_packet_list t_wihal_data_block_list;
+typedef const void* t_wihal_data_buffer;       /**< data buffer */
+typedef u32 t_wihal_frequency;                 /**< frequency in kHz */
+#define WIHAL_MSK_LENGTH 64                    /**< length of a 512 bit MSK */
+typedef u8 t_wihal_msk[WIHAL_MSK_LENGTH];      /**< 512 bit MSK type */
+typedef u32 t_wihal_nap_id;                    /**< 24bit NAP id (MSB always
+                                                *   zero */
+typedef u32 t_wihal_network_info_periodic;     /**< period for status
+                                                *   messages in milliseconds
+                                                */
+typedef u8 t_wihal_network_info_signal_change; /**< signal strength delta in
+                                                *   dBm causing status
+                                                *   message */
+typedef u32 t_wihal_nsp_change_count;          /**< nsp change count */
+typedef u32 t_wihal_nsp_id;                    /**< 24bit NSP id (MSB always
+                                                *   zero */
+#define WIHAL_PREAMBLE_SIZE 15                 /**< length of the preamble */
+/** 114 bit preamble, remaining bits zero */
+typedef u8 t_wihal_preamble[WIHAL_PREAMBLE_SIZE];
+typedef u32 t_wihal_power;                     /**< tx power range -40dBm-
+                                                *   25dBm, represented as
+                                                *   0x00-0x41 */
+typedef u8 t_wihal_signal_strength;            /**< signal strength range
+                                                *   -40-(-123) represented as
+                                                *   40-123 */
+typedef u8 t_wihal_string;                     /**< string character type */
+typedef u16 t_wihal_uint16;                    /**< generic 16 bit unsigned
+                                                *   integer */
+typedef u32 t_wihal_uint32;                    /**< generic 32 bit unsigned
+                                                *   integer */
+typedef u8 t_wihal_uint8;                      /**< generic 8 bit unsigned
+                                                *   integer */
+
+
+/** search plan structure */
+struct t_wihal_search_plan {
+        /** carrier center frequency */
+        t_wihal_frequency                carrier_freq;
+        /** channel bandwidth */
+        enum t_wihal_channel_bandwidth   channel_bandwidth;
+        /** fast fourier transform size */
+        enum t_wihal_fft_size            fft_size;
+        /** preambles */
+        t_wihal_preamble                 preamble;
+};
+
+
+/*
+ * structural types
+ */
+/** nsp id and verbose nsp name information for the wihal_search_result
+    structure */
+struct t_wihal_nsp_info {
+        /** NSP identifier */
+        t_wihal_nsp_id                   nsp_id;
+        /** length of character array pointed to by p_nsp_name */
+        t_wihal_uint8                    nsp_name_len;
+        /** array of characters containing name of NSP */
+        t_wihal_string                   *p_nsp_name;
+};
+
+
+/*
+ * message enumerations
+ */
+
+/** interface command opcodes */
+enum t_wihal_command_id {
+        E_WIHAL_DATA_SEND = 1,                 /**< EDataSend */
+        E_WIHAL_DATA_RECEIVE,                  /**< EDataReceive */
+        /* E_WIHAL_OPEN is implemented as a function call */
+        E_WIHAL_INITIALIZE = 11,               /**< EInitialize */
+        E_WIHAL_CONFIGURE,                     /**< EConfigure */
+        E_WIHAL_CLOSE,                         /**< EClose */
+        E_WIHAL_RADIO_STATE,                   /**< ERadioState */
+        E_WIHAL_SUSPEND,                       /**< ESuspend */
+        E_WIHAL_RESUME,                        /**< EResume */
+        E_WIHAL_SEARCH_NAP = 30,               /**< ESearchNap */
+        E_WIHAL_SEARCH_NAP_STOP,               /**< ESearchNapStop */
+        E_WIHAL_SEARCH_NSP,                    /**< ESearchNSP */
+        E_WIHAL_SEARCH_NSP_STOP,               /**< ESearchNSPStop */
+        E_WIHAL_ENTRY,                         /**< EEntry */
+        E_WIHAL_EXIT,                          /**< EExit */
+        E_WIHAL_NETWORK_STATUS,                /**< ENetworkStatus */
+        E_WIHAL_EAP_DATA = 50,                 /**< EEapData */
+        E_WIHAL_EAP_RESULT,                    /**< EEapResult */
+        E_WIHAL_DIAGNOSTICS = 100,             /**< EDiagnostics */
+        E_WIHAL_PROD_TEST,                     /**< EProdTest */
+};
+
+/** interface response opcodes */
+enum t_wihal_command_response_id {
+        E_WIHAL_DATA_SEND_RESP = 1,            /**< ESendDataResponse */
+        E_WIHAL_DATA_RECEIVE_RESP,             /**< EReceiveDataResponse */
+        /* E_WIHAL_OPEN_RESP implemented as a function call */
+        E_WIHAL_INITIALIZE_RESP = 11,          /**< EInitializeResponse */
+        E_WIHAL_CONFIGURE_RESP,                /**< EConfigureResponse */
+        E_WIHAL_CLOSE_RESP,                    /**< ECloseResponse */
+        E_WIHAL_RADIO_STATE_RESP,              /**< ERadioStateResponse */
+        E_WIHAL_SUSPEND_RESP,                  /**< ESuspendResp */
+        E_WIHAL_RESUME_RESP,                   /**< EResumeResp */
+        E_WIHAL_SEARCH_NAP_RESP = 30,          /**< ESearchNAPResponse */
+        E_WIHAL_SEARCH_NAP_STOP_RESP,          /**< ESearchNAPStopResponse */
+        E_WIHAL_SEARCH_NSP_RESP,               /**< ESearchNSPResponse */
+        E_WIHAL_SEARCH_NSP_STOP_RESP,          /**< ESearchNSPStopResponse */
+        E_WIHAL_ENTRY_RESP,                    /**< EEntryResponse */
+        E_WIHAL_EXIT_RESP,                     /**< EExitResponse */
+        E_WIHAL_NETWORK_STATUS_RESP,           /**< ENetworkStatusResponse */
+        E_WIHAL_EAP_DATA_RESP = 50,            /**< EEapDataResponse */
+        E_WIHAL_EAP_RESULT_RESP,               /**< EEapResultResponse */
+        E_WIHAL_DIAGNOSTICS_RESP = 100,        /**< EDiagnosticsResponse */
+        E_WIHAL_PROD_TEST_RESP,                /**< EProdTestResponse */
+};
+
+/** interface indication opcodes */
+enum t_wihal_indication_id {
+        E_WIHAL_DATA_RECV_IND = 1,             /**< EDataReceiveIndication */
+        E_WIHAL_SYSTEM_STATE_IND,              /**< ESystemStateIndication */
+        E_WIHAL_SEARCH_NAP_IND = 30,           /**< ESearchNapIndication */
+        /** ENetworkStatusIndication */
+        E_WIHAL_NETWORK_STATUS_IND,
+        E_WIHAL_EAP_DATA_IND = 50,             /**< EEapDataIndication */
+        E_WIHAL_PROD_TEST_IND = 100,           /**< EProdTestIndication */
+};
+
+/** one firmware data block with associated length */
+struct t_wihal_fw_data_block {
+        /** length of the firmware block pointed to by ptr */
+        t_wihal_uint32                 length;
+        /** pointer to array of bytes containing firmware block */
+        void*                          ptr;
+};
+
+/** E_INITIALIZE command parameters */
+struct t_wihal_cmd_initialize {
+        /** number of blocks in the p_blocks list */
+        t_wihal_uint32                   block_count;
+        /** pointer to list of firmware blocks */
+        struct t_wihal_fw_data_block     *p_blocks;
+};
+
+/** E_CONFIGURE command parameters */
+struct t_wihal_cmd_configure {
+        /** mask specifying valid fields */
+        t_wihal_config_mask                config_mask;
+        /** signal recovery time in milliseconds */
+        t_wihal_uint32                     signal_recovery_limit;
+        /** idle timer value in milliseconds */
+        t_wihal_uint32                     idle_timer;
+        /** idle paging interval in milliseconds */
+        t_wihal_uint32                     idle_paging_interval;
+        /** sleep timer value */
+        t_wihal_uint32                     sleep_timer;
+        /** handover scheme to use */
+        enum t_wihal_handover_scheme       handover_scheme;
+        /** BS id to connect to */
+        t_wihal_bsid                       bsid;
+};
+
+/** capabilities structure for E_CONFIGURE response */
+struct t_wihal_capabilities {
+        /** WiHAL version ID length */
+#define WIHAL_VERSION_ID_LEN   6
+        /** WiHAL version ID */
+        t_wihal_string             p_wihal_version[WIHAL_VERSION_ID_LEN];
+        /** model and manufacturer string lengths */
+#define WIHAL_MODEL_STR_LEN    40
+        /** model name string */
+        t_wihal_string             p_model_name[WIHAL_MODEL_STR_LEN];
+        /** manufacturer name string */
+        t_wihal_string             p_manufacturer_name[WIHAL_MODEL_STR_LEN];
+        /** device serial number string length */
+#define WIHAL_SERIAL_NBR_STR_LEN 50
+        /** device serial number string */
+        t_wihal_string             p_serial_number[WIHAL_SERIAL_NBR_STR_LEN];
+        /** length of the version strings */
+#define WIHAL_VERSION_STR_LEN  40
+        /** null terminated array of characters describing firmware version */
+        t_wihal_string             p_fw_version[WIHAL_VERSION_STR_LEN];
+        /** null terminated array of characters describing hardware version */
+        t_wihal_string             p_hw_version[WIHAL_VERSION_STR_LEN];
+        /** length of the MAC address */
+#define WIHAL_MAC_ADDRESS_LEN  6
+        /** MAC address of the device */
+        t_wihal_uint8              mac_address[WIHAL_MAC_ADDRESS_LEN];
+};
+
+/** E_CONFIGURE response parameters */
+struct t_wihal_resp_configure {
+        /** device capabilities structure */
+        struct t_wihal_capabilities      capabilities;
+};
+
+/** E_RADIO_STATE command parameters */
+struct t_wihal_cmd_radio_state {
+        /** radio state */
+        enum t_wihal_radio_state         radio_state;
+};
+
+
+/** E_SEARCH command parameters */
+struct t_wihal_cmd_search_nap {
+        /** length of the p_search_plan list */
+        t_wihal_uint32                   search_plan_count;
+        /** pointer to a list with search plan definitions */
+        struct t_wihal_search_plan       *p_search_plan;
+};
+
+/** search result element for the E_SEARCH response */
+struct t_wihal_search_result {
+        /** NAP identifier */
+        t_wihal_nap_id                   nap_id;
+        /** NAP identifier mask */
+        enum t_wihal_nap_id_mask         nap_id_mask;
+        /** signal strength of best BS */
+        t_wihal_signal_strength          signal_strength;
+        /** cinr for best BS */
+        t_wihal_cinr                     cinr;
+        /** boolean to determine whether this NAP is also an NSP */
+        enum t_wihal_nap_and_nsp         nap_and_nsp;
+        /** channel parameters for the found BS */
+        struct t_wihal_search_plan       channel;
+};
+
+/** E_SEARCH response parameters */
+struct t_wihal_ind_search_nap {
+        /** number of elements in array pointed to by p_search_result */
+        t_wihal_uint32                   result_count;
+        /** pointer to array of search result elements */
+        struct t_wihal_search_result     *p_search_result;
+};
+
+/** E_SEARCH_NSP command parameters */
+struct t_wihal_cmd_search_nsp {
+        /** NAP whose NSP's are to be returned */
+        t_wihal_nap_id                   nap_id;
+        /** The mask for the NAP */
+        enum t_wihal_nap_id_mask         nap_id_mask;
+        /** boolean determining if the NSP change count field is set */
+        t_wihal_bool                     nsp_change_count_valid;
+        /** NSP change count */
+        t_wihal_nsp_change_count         nsp_change_count;
+        /** indicates what NSP info needs to be searched */
+        enum t_wihal_search_nsp_info_req search_nsp_info;
+        /** channel parameters for the BS to search */
+        struct t_wihal_search_plan       channel;
+};
+
+/* E_SEARCH_NSP response parameters */
+struct t_wihal_resp_search_nsp {
+        /** NAP whose NSP info is returned */
+        t_wihal_nap_id                   nap_id;
+        /** bit indicating whether NAP and NSP are the same */
+        enum t_wihal_nap_and_nsp         nap_and_nsp;
+        /** NSP change count of the NAP */
+        t_wihal_nsp_change_count         nsp_change_count;
+        /** NSP count in list */
+        t_wihal_uint32                   nsp_count;
+        /** NSP information list */
+        struct t_wihal_nsp_info          *p_nsp;
+};
+
+/* E_ENTRY command parameters */
+struct t_wihal_cmd_entry {
+        /** NAP identifier to connect to */
+        t_wihal_nap_id                   nap_id;
+        /** the mask for the NAP ID */
+        enum t_wihal_nap_id_mask         nap_id_mask;
+        /** NSP identifier to connect to */
+        t_wihal_nsp_id                   nsp_id;
+        /** boolean indicating whether realm is needed */
+        t_wihal_bool                     realm_req;
+        /** channel parameters for the BS to connect to */
+        struct t_wihal_search_plan       channel;
+};
+
+/* E_DATA_SEND command parameters */
+struct t_wihal_cmd_data_send {
+        /** length of the array of packets pointed to by p_data */
+        t_wihal_uint32                   data_count;
+        /** list of data packets. ownership of the packets
+            in the list will move to the callee, but responsibility
+            of the list itself will remain by the caller. */
+        t_wihal_data_block_list          p_data;
+};
+
+
+/** E_DATA_RECEIVE indication parameters */
+struct t_wihal_ind_data_receive {
+        /** number of packets available for transmission */
+        t_wihal_uint32                   data_count;
+};
+
+/** E_DATA_RECEIVE command parameters */
+struct t_wihal_cmd_data_receive {
+        /** maximum number of packets allowed to be transmitted */
+        t_wihal_uint32                   data_count;
+};
+
+/** E_DATA_RECEIVE response parameters */
+struct t_wihal_resp_data_receive {
+        /** TRUE if this is the last packet in buffer */
+        t_wihal_bool                     last_packet;
+        /** number of packets in the array of packets pointed to by p_data */
+        t_wihal_uint32                   data_count;
+        /** pointer to array of packets. ownership of the packets in the array
+            is transferred to the callee, but the responsibility of the array
+            itself remains at the caller. */
+        t_wihal_data_block_list           p_data;
+};
+
+/** E_PROD_TEST command parameters */
+struct t_wihal_cmd_prod_test {
+        /** pointer to a data block. ownership of the bytearray is transferred
+            to the callee. */
+        t_wihal_data_block               p_data;
+};
+
+/** E_PROD_TEST response parameters */
+struct t_wihal_resp_prod_test {
+        /** pointer to a data block. ownership of the bytearray is transferred
+            to the callee. */
+        t_wihal_data_block               p_data;
+};
+
+/** E_PROD_TEST indication parameters */
+struct t_wihal_ind_prod_test {
+        /** pointer to a data block. ownership of the bytearray is transferred
+            to the callee. */
+        t_wihal_data_block               p_data;
+};
+
+/** E_DIAGNOSTICS command parameters */
+struct t_wihal_cmd_diagnostics {
+        /** pointer to a data block. ownership of the bytearray is transferred
+            to the callee. */
+        t_wihal_data_block               p_data;
+};
+
+/** E_DIAGNOSTICS response parameters */
+struct t_wihal_resp_diagnostics {
+        /** pointer to a data block. ownership of the bytearray is transferred
+            to the callee. */
+        t_wihal_data_block               p_data;
+};
+
+/** E_NETWORK_STATUS response parameters */
+struct t_wihal_resp_network_status {
+        /** current network status */
+        enum t_wihal_network_status      network_status;
+        /** current signal strength */
+        t_wihal_signal_strength          signal_strength;
+        /** current CINR */
+        t_wihal_cinr                     cinr;
+        /** connected-to BS identifier */
+        t_wihal_bsid                     bsid;
+        /** channel parameters for the BS */
+        struct t_wihal_search_plan       channel;
+};
+
+/** E_NETWORK_STATUS indication parameters */
+struct t_wihal_ind_network_status {
+        /** current network status */
+        enum t_wihal_network_status      network_status;
+        /** reason for the indication */
+        enum t_wihal_network_status_err  network_status_err;
+        /** connected-to BS identifier */
+        t_wihal_bsid                     bsid;
+        /** bit indicating whether NAP and NSP are the same */
+        enum t_wihal_nap_and_nsp         nap_and_nsp;
+        /** channel parameters for the BS */
+        struct t_wihal_search_plan       channel;
+        /** length of the array of characters pointed to by p_nsp_realm */
+        t_wihal_uint32                   nsp_realm_len;
+        /** pointer to array of characters providing verbose name for the
+            connected-to NSP realm*/
+        t_wihal_string                   *p_nsp_realm;
+};
+
+/** E_SYSTEM_STATE indication parameters */
+struct t_wihal_ind_system_state {
+        /** current system state/reason for the indication */
+        enum t_wihal_system_state        system_state;
+};
+
+/** E_EAP_DATA indication parameters */
+struct t_wihal_ind_eap_data {
+        /** pointer to array of bytes containing the EAP payload. ownership
+            of the array is transferred to the callee */
+        t_wihal_data_block               p_payload;
+};
+
+/** E_EAP_DATA command parameters */
+struct t_wihal_cmd_eap_data {
+        /** pointer to array of bytes containing the EAP payload. ownership
+            of the array is transferred to the callee */
+        t_wihal_data_block               p_payload;
+};
+
+/** E_EAP_RESULT command parameters */
+struct t_wihal_cmd_eap_result {
+        /** TRUE if negotiation was successfully completed, FALSE otherwise */
+        t_wihal_bool                     success;
+        /** pointer to an array of bytes containing the calculated MSK */
+        t_wihal_msk                      msk;
+};
+
+
+/** global command structure for passing opcodes and related parameters */
+struct t_wihal_cmd {
+        /** opcode for the command */
+        enum t_wihal_command_id cmd_id;
+        /** opcode specific parameters */
+        union {
+                struct t_wihal_cmd_initialize initialize;
+                struct t_wihal_cmd_configure configure;
+                struct t_wihal_cmd_radio_state radio_state;
+                struct t_wihal_cmd_search_nap search_nap;
+                struct t_wihal_cmd_search_nsp search_nsp;
+                struct t_wihal_cmd_entry entry;
+                struct t_wihal_cmd_data_send data_send;
+                struct t_wihal_cmd_data_receive data_receive;
+                struct t_wihal_cmd_eap_data eap_data;
+                struct t_wihal_cmd_eap_result eap_result;
+                struct t_wihal_cmd_prod_test prod_test;
+                struct t_wihal_cmd_diagnostics diagnostics;
+        } cmd;
+};
+
+/** global response structure for passing opcodes and related status values and
+    parameters */
+struct t_wihal_resp {
+        /** opcode for the response */
+        enum t_wihal_command_response_id cmd_resp_id;
+        /** end status for the operation */
+        enum t_wihal_status cmd_status;
+        /** opcode specific parameters */
+        union {
+                struct t_wihal_resp_configure configure;
+                struct t_wihal_resp_search_nsp search_nsp;
+                struct t_wihal_resp_data_receive data_receive;
+                struct t_wihal_resp_prod_test prod_test;
+                struct t_wihal_resp_network_status network_status;
+                struct t_wihal_resp_diagnostics diagnostics;
+        } resp;
+};
+
+/** global indication structure for passing opcodes and related parameters */
+struct t_wihal_ind {
+        /** indication opcode */
+        enum t_wihal_indication_id ind_id;
+        /** opcode specific parameters */
+        union {
+                struct t_wihal_ind_network_status network_status;
+                struct t_wihal_ind_system_state system_state;
+                struct t_wihal_ind_search_nap search_nap;
+                struct t_wihal_ind_data_receive data_receive;
+                struct t_wihal_ind_eap_data eap_data;
+                struct t_wihal_ind_prod_test prod_test;
+        } ind;
+};
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/*
+ * interface function prototypes
+ */
+
+#include "pc2400m_drv_iffunc.h"
+
+#endif /* PC2400MDRV_IF */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_ring.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_ring.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_ring.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_ring.h	2007-10-02 03:09:32.000000000 -0400
@@ -0,0 +1,31 @@
+/*
+ * pc2400m_drv_ring.h
+ *
+ * Copyright (C) 2007 Nokia Corporation
+ * Author: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+
+#ifndef PC2400M_DRV_RING_H
+#define PC2400M_DRV_RING_H
+
+
+#define Q_EMPTY(q)   (q##_e == q##_s)
+#define Q_FULL(q,s)  (q##_e == q##_s-1 || (q##_s == 0 && \
+                      q##_e == s-1))
+#define Q_PUT(q,s)   (q##_e=(++q##_e)%s)
+#define Q_GET(q,s)   (q##_s=(++q##_s)%s)
+#define Q_LEN(q,s)   (q##_s<=q##_e?q##_e-q##_s:s+q##_e-q##_s)
+
+#define Q_DECLARE(q, type, size) \
+        u32 q##_s; \
+        u32 q##_e; \
+	type q[size];
+
+#endif /* PC2400M_DRV_RING_H */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_sdio.c maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_sdio.c
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_sdio.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_sdio.c	2011-02-06 20:12:11.653333273 -0500
@@ -0,0 +1,461 @@
+/*
+ * pc2400m_drv_sdio.c
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         22      APPROVED 21-Feb-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_drv_sdio.c
+ *
+ * This file implements open SDIO command handling functions.
+ *
+ */
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include "pc2400m_drv_spi.h"
+#include "pc2400m_drv_sdio.h"
+#include "pc2400m_osal.h"
+
+/*****************************************************************************
+ * Global constants and macros
+ */
+
+/*****************************************************************************
+ * Global data types
+ */
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/*****************************************************************************
+ * Local functions
+ */
+
+/** Create an SDIO command 0. This function craetes the CMD0 command into the
+ *  provided command buffer.
+ *
+ *  @param dst buffer to hold the command 0
+ *  @return none
+ */
+static void pc2400m_drv_build_cmd0(void* dst)
+{
+        struct SD_CMD *sd_cmd = (struct SD_CMD*)dst;
+
+        sd_cmd->start_bit      = 0;
+        sd_cmd->direction      = 1;
+        sd_cmd->command_index  = 0;
+        /* the "argument" parameter is split into pieces because not all
+           compilers seem to like u32 assignments in bitfields */
+        sd_cmd->argument1      = 0;
+        sd_cmd->argument2      = 0;
+        sd_cmd->argument3      = 0;
+        sd_cmd->argument4      = 0;
+        sd_cmd->crc7           = 0x4A;
+        sd_cmd->end_bit        = 1;
+        return;
+}
+
+/** Create an SDIO command 5. This function creates the CMD5 command into the
+ *  provided command buffer.
+ *
+ *  @param dst buffer to hold the command 5
+ *  @return none
+ */
+static void pc2400m_drv_build_cmd5(void* dst, u32 ocr)
+{
+        struct SD_CMD *sd_cmd = (struct SD_CMD *)dst;
+
+        ocr &= 0x00ffffff;
+
+        sd_cmd->start_bit     = 0;
+        sd_cmd->direction     = 1;
+        sd_cmd->command_index = 5;
+        /* the "argument" parameter is split into pieces because not all
+           compilers seem to like u32 assignments in bitfields */
+        sd_cmd->argument1     = (u8)(ocr >> 24);
+        sd_cmd->argument2     = (u8)(ocr >> 16);
+        sd_cmd->argument3     = (u8)(ocr >> 8);
+        sd_cmd->argument4     = (u8)(ocr);
+        sd_cmd->crc7          = 0;
+        sd_cmd->end_bit       = 1;
+        return;
+}
+
+/** Create an SDIO command 52. This function creates the CMD52 command into the
+ *  provided command buffer.
+ *
+ *  @param dst buffer to hold the command 5
+ *  @param address target address for the write
+ *  @param data data byte to write
+ *  @param read_write direction of the command
+ *  @param func_num number of the SDIO function for the command
+ *  @return none
+ */
+static void pc2400m_drv_build_cmd52(
+        void* dst,
+        u32 address,
+        u8 data,
+        e_read_write read_write,
+        e_func_num func_num)
+{
+        struct SD_CMD *sd_cmd = (struct SD_CMD*)dst;
+        struct CMD_52 cmd52;
+
+        cmd52.u.bits.address          = address;
+        cmd52.u.bits.data             = data;
+        cmd52.u.bits.function         = (u32)func_num;
+        cmd52.u.bits.read_after_write = FALSE;
+        cmd52.u.bits.reserved1        = 0;
+        cmd52.u.bits.reserved2        = 0;
+        cmd52.u.bits.write_to_device  = (u8)read_write;
+
+        sd_cmd->start_bit             = 0;
+        sd_cmd->direction             = 1;
+        sd_cmd->command_index         = 52;
+        /* the "argument" parameter is split into pieces because not all
+           compilers seem to like u32 assignments in bitfields */
+        sd_cmd->argument1             = (u8)(cmd52.u.as_u32 >> 24);
+        sd_cmd->argument2             = (u8)(cmd52.u.as_u32 >> 16);
+        sd_cmd->argument3             = (u8)(cmd52.u.as_u32 >> 8);
+        sd_cmd->argument4             = (u8)(cmd52.u.as_u32);
+        sd_cmd->crc7                  = 0;
+        sd_cmd->end_bit               = 1;
+        return;
+
+}
+
+/** Create an SDIO command 53. This function creates the CMD53 into the command
+ *  buffer provided as parameter.
+ *
+ * @param dst buffer to hold the command 53
+ * @param byte_block_count number of data blocks following the command
+ * @param address target address for the read or write
+ * @param read_write direction of the command
+ * @return none
+ */
+static void pc2400m_drv_build_cmd53(
+        void* dst,
+        u32 byte_block_count,
+        u32 address,
+        e_read_write read_write)
+{
+        struct SD_CMD *sd_cmd = (struct SD_CMD*)dst;
+        struct CMD_53 cmd53;
+
+        cmd53.u.as_u32 = 0;
+        cmd53.u.bits.count           = byte_block_count;
+        cmd53.u.bits.address         = address;
+        cmd53.u.bits.opcode          = TRUE;
+        cmd53.u.bits.blockmode       = TRUE;
+        cmd53.u.bits.function        = 1;
+        cmd53.u.bits.write_to_device = read_write;
+
+        sd_cmd->start_bit            = 0;
+        sd_cmd->direction            = 1;
+        sd_cmd->command_index        = 53;
+        /* the "argument" parameter is split into pieces because not all
+           compilers seem to like u32 assignments in bitfields */
+        sd_cmd->argument1            = (u8)(cmd53.u.as_u32 >> 24);
+        sd_cmd->argument2            = (u8)(cmd53.u.as_u32 >> 16);
+        sd_cmd->argument3            = (u8)(cmd53.u.as_u32 >> 8);
+        sd_cmd->argument4            = (u8)(cmd53.u.as_u32);
+        sd_cmd->crc7                 = 0;
+        sd_cmd->end_bit              = 1;
+
+        return;
+}
+
+/*****************************************************************************
+ * Exported functions
+ */
+
+/** Create and send an SDIO command 0. This function creates a CMD0 and the
+ *  sends the command over SPI, and checks for proper response.
+ *
+ * @param hdi handle to the hdi interface instance
+ * @return ESUCCESS upon success, -EGENERAL upon failure
+ */
+s32 pc2400m_drv_send_cmd0(struct pc2400m_drv_hdi_if *hdi)
+{
+
+        struct pc2400m_drv_hdi_spi_if *spi =
+                (struct pc2400m_drv_hdi_spi_if*)hdi;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hdi->ctx);
+
+        u8 *cmd = spi->spi_cmd;
+        struct R_1 *r1 = (struct R_1*)spi->spi_resp;
+
+        pc2400m_drv_build_cmd0(&cmd[1]);
+        cmd[0] = 0xff;
+        cmd[PC2400M_DRV_SPI_CMD_SIZE-1] = 0xff;
+
+        /* queue write of the request */
+        priv->aif->h2d(hdi->ctx, cmd, PC2400M_DRV_SPI_CMD_SIZE);
+        /* queue read of the response */
+        priv->aif->d2h(hdi->ctx, (u8*)r1, sizeof(struct R_1));
+        /* commit the transaction */
+        priv->aif->commit(hdi->ctx, NULL, NULL);
+
+        if (r1->u.as_u8 != 1) {
+                wimax_osal_trace_byte(PC2400M_GROUP_SPI_ERROR,
+                                      PC2400M_TRACE_CMD0_ERROR,
+                                      WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                                      r1->u.as_u8);
+                goto err1;
+        }
+
+        goto out;
+
+ err1:
+        return -EGENERAL;
+
+ out:
+        return ESUCCESS;
+
+}
+
+/** Create and send an SDIO command 5. This function creates a CMD5 and the
+ *  sends the command over SPI, and checks for proper response.
+ *
+ * @param hdi handle to the hdi interface instance
+ * @param ocr OCR register value to propose to the chipset
+ * @param r4 the response structure (to be returned to the client)
+ * @return returns the OCR register value returned by the chipset
+ */
+u32 pc2400m_drv_send_cmd5(
+        struct pc2400m_drv_hdi_if *hdi,
+        u32 ocr,
+        struct R_4* r4)
+{
+
+        struct pc2400m_drv_hdi_spi_if *spi =
+                (struct pc2400m_drv_hdi_spi_if*)hdi;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hdi->ctx);
+        u8 *cmd = spi->spi_cmd;
+        struct R_4 *dmar4 = (struct R_4*)spi->spi_resp;
+
+
+        pc2400m_drv_build_cmd5(&cmd[1], ocr);
+        cmd[0] = 0xff;
+        cmd[PC2400M_DRV_SPI_CMD_SIZE-1] = 0xff;
+
+        /* queue write of the request */
+        priv->aif->h2d(hdi->ctx, cmd, PC2400M_DRV_SPI_CMD_SIZE);
+        /* queue read of the response */
+        priv->aif->d2h(hdi->ctx, (u8*)dmar4, sizeof(struct R_4));
+        /* commit the transaction */
+        priv->aif->commit(hdi->ctx, NULL, NULL);
+
+        wimax_osal_mem_cpy(r4, dmar4, sizeof(struct R_4));
+
+        return ((r4->u.bits.io_ocr2<<16) & 0xFF0000) +
+                ((r4->u.bits.io_ocr1<<8) & 0x00FF00) +
+                (r4->u.bits.io_ocr0 & 0x0000FF);
+
+}
+
+/** Create and send an SDIO command 52. This function creates a CMD52 and the
+ *  sends the command over SPI, and checks for proper response.
+ *
+ * @param hdi handle to the hdi interface instance
+ * @param address address for the read/write operation
+ * @param data data to write to the chipset
+ * @param read_write direction of the CMD52
+ * @param func_num function number of the target of the CMD52
+ * @return Returns the read register value for read, the written value for
+ *         write, and -EGENERAL upon failure
+ */
+s32 pc2400m_drv_send_cmd52(
+        struct pc2400m_drv_hdi_if *hdi,
+        u32 address,
+        u8 data,
+        e_read_write read_write,
+        e_func_num func_num)
+{
+        struct pc2400m_drv_hdi_spi_if *spi =
+                (struct pc2400m_drv_hdi_spi_if*)hdi;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hdi->ctx);
+        u8 *cmd = spi->spi_cmd;
+        struct R_5 *r5 = (struct R_5*)spi->spi_resp;
+
+        pc2400m_drv_build_cmd52(&cmd[1], address, data, read_write, func_num);
+        cmd[0] = 0xff;
+        cmd[PC2400M_DRV_SPI_CMD_SIZE-1] = 0xff;
+
+        /* queue write of the request */
+        priv->aif->h2d(hdi->ctx, cmd, PC2400M_DRV_SPI_CMD_SIZE);
+        /* queue read of the response */
+        priv->aif->d2h(hdi->ctx, (u8*)r5, sizeof(struct R_5));
+        /* commit the transaction */
+        priv->aif->commit(hdi->ctx, NULL, NULL);
+
+        if (r5->u.bits.r1.u.as_u8 != 0) {
+                wimax_osal_trace_byte(
+                        PC2400M_GROUP_SPI_ERROR,
+                        PC2400M_TRACE_CMD52_ERROR,
+                        WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                        r5->u.bits.r1.u.as_u8);
+                goto err;
+        }
+        if (read_write == h2d && r5->u.bits.read_data != data) {
+                wimax_osal_trace_byte(
+                        PC2400M_GROUP_SPI_ERROR,
+                        PC2400M_TRACE_CMD52_ERROR,
+                        WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                        r5->u.bits.read_data);
+                goto err;
+        }
+
+        goto out;
+
+ err:
+        return -EGENERAL;
+
+ out:
+        return r5->u.bits.read_data;
+
+}
+
+
+/** Create and send an SDIO command 53 for write. This function creates a CMD53
+ *  and then sends the command over SPI checking for proper response. This
+ *  function generates a write command, appending the requested number of
+ *  blocks to the end of the command.
+ *
+ * @param hdi handle to the hdi interface instance
+ * @param byte_block_count number of blocks to write
+ * @param address address for the write operation
+ * @param data pointer to the data to write to the chipset
+ * @param len length of the data to write
+ * @return Returns the number of bytes written or -EGENERAL upon failure
+ */
+s32 pc2400m_drv_send_write_cmd53(
+        struct pc2400m_drv_hdi_if *hdi,
+        u32 byte_block_count,
+        u32 address,
+        u8 *data,
+        u32 len)
+{
+
+        struct pc2400m_drv_hdi_spi_if *spi =
+                (struct pc2400m_drv_hdi_spi_if*)hdi;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hdi->ctx);
+        u8 *cmd53 = spi->spi_cmd;
+        struct R_5 *r5 = (struct R_5*)spi->spi_resp;
+        s32 ret;
+
+        /* queue a write command */
+        pc2400m_drv_build_cmd53(&cmd53[1], byte_block_count, address, h2d);
+        cmd53[0] = 0xff;
+        cmd53[PC2400M_DRV_SPI_CMD_SIZE-1] = 0xff;
+        priv->aif->h2d(hdi->ctx, cmd53, PC2400M_DRV_SPI_CMD_SIZE);
+
+        /* queue the response */
+        priv->aif->d2h(hdi->ctx, (u8*)r5, sizeof(struct R_5));
+
+        /* queue the data */
+        wimax_osal_assert(len <= PC2400M_DRV_SPI_DATA_SIZE);
+        priv->aif->h2d(hdi->ctx, data, len);
+
+        /* commit the entire transaction synchronously */
+        priv->aif->commit(hdi->ctx, NULL, NULL);
+
+        /* check on the response to the cmd53 */
+        ret = len;
+        if (r5->u.bits.read_data != 0 || r5->u.bits.r1.u.as_u8 != 0 ) {
+                wimax_osal_trace_u16(PC2400M_GROUP_SPI_ERROR,
+                                     PC2400M_TRACE_TX_CMD_FAIL,
+                                     WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                                     r5->u.as_u16);
+                ret = -EGENERAL; /* I/O error */
+        }
+
+        return ret;
+
+}
+
+
+
+/** Create and send an SDIO command 53 for read. This function creates a CMD53
+ *  and then sends the command over SPI checking for proper response. This
+ *  function generates a read command, appending space for the requested number
+ *  of blocks to the end of the command.
+ *
+ * @param hdi handle to the hdi interface instance
+ * @param byte_block_count number of blocks to read
+ * @param address address for the read operation
+ * @param data pointer to the data to read from the chipset
+ * @param len length of the data to read
+ * @return Returns the number of bytes read or -EGENERAL upon failure
+ */
+s32 pc2400m_drv_send_read_cmd53(
+        struct pc2400m_drv_hdi_if *hdi,
+        u32 byte_block_count,
+        u32 address,
+        u8 *data,
+        u32 len)
+{
+
+        struct pc2400m_drv_hdi_spi_if *spi =
+                (struct pc2400m_drv_hdi_spi_if*)hdi;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hdi->ctx);
+        u8 *cmd53 = spi->spi_cmd;
+        struct R_5 *r5;                      /* 4 bytes */
+        s32 ret;
+
+        PC2400M_DRV_UNWARN(address);
+
+        /* queue a data read command (cmd53) */
+        pc2400m_drv_build_cmd53(&cmd53[1], byte_block_count, 0, d2h);
+        cmd53[0] = 0xff;
+        cmd53[PC2400M_DRV_SPI_CMD_SIZE-1] = 0xff;
+        priv->aif->h2d(hdi->ctx, cmd53, PC2400M_DRV_SPI_CMD_SIZE);
+
+        /* queue the read (including the R5 response) */
+        priv->aif->d2h(hdi->ctx, data, len + R_5_SIZE);
+
+        /* asynchronously commit the transaction */
+        priv->aif->commit(hdi->ctx, NULL, NULL);
+
+        /* check the response for cmd53 */
+        ret = len;
+        r5 = (struct R_5*)((struct pc2400m_drv_hdi_spi_if*)hdi)->spi_data;
+        if (r5->u.bits.read_data != 0 || r5->u.bits.r1.u.as_u8) {
+                wimax_osal_trace_byte(
+                        PC2400M_GROUP_SPI_ERROR,
+                        PC2400M_TRACE_RX_CMD_FAIL,
+                        WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                        r5->u.bits.r1.u.as_u8);
+                ret = -EGENERAL;
+        }
+
+        return ret;
+
+}
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_sdio.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_sdio.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_sdio.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_sdio.h	2011-02-06 20:12:11.649999940 -0500
@@ -0,0 +1,217 @@
+/*
+ * pc2400m_drv_sdio.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         12      APPROVED 21-Feb-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_drv_sdio.h
+ *
+ * This file declares structures used to construct open SDIO commands.
+ *
+ */
+
+#ifndef PC2400M_DRV_SDIO_H
+#define PC2400M_DRV_SDIO_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/*****************************************************************************
+ * Data types
+ */
+
+typedef enum {
+        d2h     = 0,
+        h2d     = 1
+} e_read_write;
+
+typedef enum {
+        func0   = 0,
+        func1   = 1
+} e_func_num;
+
+struct R_1 {
+        union {
+                struct {
+                        u8 idle_state:1;
+                        u8 erase_reset:1;
+                        u8 illegal_cmd:1;
+                        u8 com_crc_err:1;
+                        u8 erase_seq_err:1;
+                        u8 addr_err:1;
+                        u8 parameter_err:1;
+                        u8 zero:1;
+                } bits;
+                u8 as_u8;
+        } u;
+        u8 pad;
+        u8 pad2;
+        u8 pad3;
+};
+
+struct MOD_R_1 {
+        union {
+                struct {
+                        u8 idle_state:1;
+                        u8 zero1:1;
+                        u8 illegal_cmd:1;
+                        u8 com_crc_err:1;
+                        u8 func_num_err:1;
+                        u8 zero0:1;
+                        u8 parameter_err:1;
+                        u8 start:1;
+                } bits;
+                u8 as_u8;
+        } u;
+};
+
+#pragma pack(push,1)
+struct R_4 {
+        union {
+                struct {
+                        struct MOD_R_1 R1;
+                        u8 memory_present:1;
+                        u8 stuff_bits:3;
+                        u8 num_of_io_fct:3;
+                        u8 card_bit:1;
+                        u8 io_ocr2;
+                        u8 io_ocr1;
+                        u8 io_ocr0;
+                } bits;
+                u8 as_u8[5];
+        } u;
+        u8 pad;
+        u8 pad2;
+        u8 pad3;
+};
+#pragma pack(pop)
+
+struct CMD_52 {
+        union {
+                struct {
+                        u32 data:8;
+                        u32 reserved1:1;
+                        u32 address:17;
+                        u32 reserved2:1;
+                        u32 read_after_write:1;
+                        u32 function:3;
+                        u32 write_to_device:1;
+                } bits;
+                u32 as_u32;
+        } u;
+};
+
+struct CMD_53 {
+        union {
+                struct {
+                        u32 count:9;
+                        u32 address:17;
+                        u32 opcode:1;
+                        u32 blockmode:1;
+                        u32 function:3;
+                        u32 write_to_device:1;
+                } bits;
+                u32 as_u32;
+        } u;
+};
+
+struct R_5 {
+        union {
+                struct {
+                        struct MOD_R_1 r1;
+                        u8 read_data:8;
+                } bits;
+                u16 as_u16;
+        } u;
+        u8 pad;
+        u8 pad2;
+};
+#define R_5_SIZE    2
+
+struct SPI_DATA_R {
+        union {
+                struct {
+                        u8 end:1;
+                        u8 status:3;
+                        u8 zero:1;
+                        u8 dont_c:3;
+                } bits;
+                u8 as_u8;
+        } u;
+};
+
+
+#pragma pack(push,1)
+struct SD_CMD {
+        u8 command_index:6;
+        u8 direction:1;
+        u8 start_bit:1;
+        u8 argument1:8;
+        u8 argument2:8;
+        u8 argument3:8;
+        u8 argument4:8;
+        u8 end_bit:1;
+        u8 crc7:7;
+};
+#pragma pack(pop)
+
+struct pc2400m_drv_hdi_if;
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+extern s32 pc2400m_drv_send_cmd0(
+        struct pc2400m_drv_hdi_if *hnd);
+extern u32 pc2400m_drv_send_cmd5(
+        struct pc2400m_drv_hdi_if *hnd, u32 ocr,
+        struct R_4* r4);
+extern s32 pc2400m_drv_send_cmd52(
+        struct pc2400m_drv_hdi_if *hnd,
+        u32 address,
+        u8 data,
+        e_read_write read_write,
+        e_func_num func_num);
+extern s32 pc2400m_drv_send_write_cmd53(
+        struct pc2400m_drv_hdi_if *hnd,
+        u32 byte_block_count,
+        u32 address,
+        u8 *data,
+        u32 len);
+extern s32 pc2400m_drv_send_read_cmd53(
+        struct pc2400m_drv_hdi_if *hnd,
+        u32 byte_block_count,
+        u32 address,
+        u8 *data,
+        u32 len);
+
+#endif /* PC2400M_DRV_SDIO_H */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_sllist.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_sllist.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_sllist.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_sllist.h	2007-10-02 03:09:32.000000000 -0400
@@ -0,0 +1,93 @@
+/*
+ * pc2400m_drv_sllist.h
+ *
+ * Copyright (C) 2007 Nokia Corporation
+ * Author: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+
+#ifndef PC2400M_DRV_SLLIST
+#define PC2400M_DRV_SLLIST
+
+struct sllist {
+	struct sllist *next;
+	struct sllist *last;
+};
+
+#define sllist_foreach(list, pos) \
+	for(pos=list; pos; pos=pos->next)
+
+#define sllist_init_elem(elem) { (elem)->last = (elem); (elem)->next = NULL; }
+
+static inline void sllist_free(struct sllist **list, void (*freecb)(void*))
+{
+	struct sllist *pos;
+
+	while (*list) {
+		pos = *list;
+		*list=(*list)->next;
+		freecb((void*)pos);
+	}
+	*list = NULL;
+	return;
+}
+
+static inline void sllist_append(struct sllist **list, struct sllist *elem)
+{
+
+	wimax_osal_assert(elem != NULL);
+
+	if (*list) {
+		(*list)->last->next = elem;
+		(*list)->last = elem;
+		elem->next = NULL;
+	} else {
+		(*list) = elem;
+		elem->next = NULL;
+		elem->last = elem;
+	}
+}
+
+static inline void sllist_insert(struct sllist **list, struct sllist *elem)
+{
+
+	wimax_osal_assert(elem != NULL);
+
+	if (*list) {
+		elem->last = (*list)->last;
+		elem->next = (*list);
+		*list = elem;
+	} else {
+		*list = elem;
+		elem->next = NULL;
+		elem->last = elem;
+	}
+}
+
+static inline struct sllist *sllist_pop(struct sllist **list)
+{
+
+	struct sllist *elem = NULL;
+
+	if (*list) {
+		elem = *list;
+		*list = elem->next;
+		if (*list) (*list)->last = elem->last;
+	}
+	
+	return elem;
+
+}
+
+
+
+
+
+
+#endif /* PC2400M_DRV_SLLIST */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_spi.c maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_spi.c
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_spi.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_spi.c	2011-02-06 20:12:11.896666607 -0500
@@ -0,0 +1,711 @@
+/*
+ * pc2400m_drv_spi.c
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         42      APPROVED 01-Jul-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_drv_spi.c
+ *
+ * This file implements the SPI transfer protocol utilized by the Intel
+ * i2400m WiMAX chipset.
+ *
+ */
+
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include "pc2400m_osal.h"
+#include "pc2400m_drv_sdio.h"
+#include "pc2400m_drv_com.h"
+#include "pc2400m_drv_if.h"
+#include "pc2400m_drv_hdi.h"
+#include "pc2400m_drv_dm.h"
+#include "pc2400m_drv_spi_fw.h"
+#include "pc2400m_drv_spi.h"
+
+/*****************************************************************************
+ * Global constants and macros
+ */
+
+/*****************************************************************************
+ * Global data types
+ */
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/*****************************************************************************
+ * Local functions
+ */
+
+/** Queue a frame for SPI transmission. Queue the provided packet frame for SPI
+ *  transmission and assume ownership of the frame.
+ *
+ *  @param hnd pointer of the HDI instance
+ *  @param data the packet frame to queue for transmission
+ *  @param type the packet type to be set into the header
+ *  @return Returns NULL upon success, or the original frame if failure occurs.
+ */
+static wimax_osal_packet *pc2400m_drv_spi_put(
+        struct pc2400m_drv_hdi_if *hnd,
+        wimax_osal_packet *data,
+        s32 type)
+{
+
+        struct pc2400m_drv_hdi_spi_if *spif =
+                (struct pc2400m_drv_hdi_spi_if*)hnd;
+        u32 len;
+
+        /* assert that 'data' points somewhere, and that the type is
+           no larger that 4 bits. */
+        wimax_osal_assert(data != NULL &&
+                          (type & 0xfffffff0) == 0);
+
+        /* check whether the packet is of allowable size */
+        if (wimax_osal_packet_size(data) > PC2400M_DRV_SPI_MAX_PAYLOAD) {
+                /* illegally large packet, drop it */
+                wimax_osal_trace_u32(PC2400M_GROUP_SPI_ERROR,
+                                     PC2400M_TRACE_TOO_LARGE_PACKET,
+                                     WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                                     wimax_osal_packet_size(data));
+                wimax_osal_packet_free(&data);
+                goto out;
+        }
+
+        /* check if the packet will fit into the current transaction */
+        len = PC2400M_DRV_SPI_PAYLOAD_PAD(wimax_osal_packet_size(data));
+        if (((PC2400M_DRV_SPI_MAX_PAYLOAD - spif->tx_q_len) < len) ||
+            (wimax_osal_packet_list_len(
+                    &(spif->tx_q)) >= PC2400M_DRV_SPI_TX_Q_SIZE))
+                return data;
+
+        /* add the packet into the current transaction */
+        spif->tx_q_len += len;
+        wimax_osal_packet_type_set(
+                data, WIMAX_OSAL_PACKET_TYPE_EXTENDED, (void*)type);
+        wimax_osal_packet_list_append(&(spif->tx_q), data);
+
+ out:
+        return NULL;
+
+}
+
+
+/** Extract one frame from SPI transmission buffer. The frame will be removed
+ *  from the buffer. The returned packet will be the responsibility of the
+ *  called once received.
+ *
+ *  @param hnd handle to the spi instance
+ *  @param type the packet type read from the header
+ *  @return Returnes the next packet from the SPI transmission queue. The
+ *          ownership of the packet is transferred to the caller.
+ */
+static wimax_osal_packet *pc2400m_drv_spi_get(
+        struct pc2400m_drv_hdi_if *hnd,
+        s32 *type)
+{
+
+        struct pc2400m_drv_hdi_spi_if *spif =
+                (struct pc2400m_drv_hdi_spi_if*)hnd;
+        wimax_osal_packet *ret;
+
+        if (wimax_osal_packet_list_len(&(spif->rx_q)) == 0)
+                return NULL;
+
+        /* get the oldest packet from the list */
+        ret = wimax_osal_packet_list_pop(&(spif->rx_q));
+        *type = (s32)wimax_osal_packet_subtype_get(ret);
+
+        return ret;
+
+}
+
+
+/** Write an SPI message to SPI. Synchronously transmit the requested number of
+ *  data blocks onto the SPI bus to the device specified by ctx.
+ *
+ *  @param hnd handle to the HDI instance
+ *  @return Returns ESUCCESS on success, or a negative value on error
+ */
+static s32 pc2400m_drv_spi_write(struct pc2400m_drv_hdi_if *hnd)
+{
+
+        struct pc2400m_drv_hdi_spi_if *spif =
+                (struct pc2400m_drv_hdi_spi_if*)hnd;
+        wimax_osal_packet *pkt;
+        s32 num_desc;
+        s32 total;
+        s32 pad;
+        s32 i, ctr, len, size, ret;
+        u8* ptr;
+        u8* desc_ptr;
+        u8* pkt_ptr;
+        struct pc2400m_drv_spi_transfer_msg_hdr *xfer_hdr;
+        struct pc2400m_drv_spi_transfer_desc *xfer_desc;
+        u32 hdr;
+        u32 ftr;
+
+        /* check that there is data to send */
+        if (wimax_osal_packet_list_len(&(spif->tx_q)) == 0) {
+                ret = ESUCCESS;
+                goto out;
+        }
+
+        /* calculate padding needed */
+        num_desc = wimax_osal_packet_list_len(&(spif->tx_q));
+        total = PC2400M_DRV_SPI_TRANSPORT_HDR_SIZE +
+                PC2400M_DRV_SPI_PAYLOAD_PAD(
+                        num_desc * PC2400M_DRV_SPI_DESCRIPTOR_SIZE) +
+                spif->tx_q_len;
+        pad = PC2400M_DRV_SPI_BLOCK_PAD(total) - total;
+        total = total + pad;
+
+        ptr = spif->spi_data + PC2400M_DRV_SPI_BLOCK_HEADER;
+
+        /* the transfer header and descriptors will never exceed the
+           block limit */
+
+        /* transfer message header */
+        xfer_hdr = (struct pc2400m_drv_spi_transfer_msg_hdr*)ptr;
+        xfer_hdr->barker = WIMAX_OSAL_U32_TO_LE(PC2400M_DRV_SPI_H2D_BARKER);
+        xfer_hdr->seq = WIMAX_OSAL_U32_TO_LE(spif->tx_seq);
+        spif->tx_seq++;
+        xfer_hdr->num_desc = WIMAX_OSAL_U16_TO_LE(num_desc);
+        xfer_hdr->pad1 = 0;
+        xfer_hdr->pad_cnt = WIMAX_OSAL_U16_TO_LE(pad);
+        xfer_hdr->pad2 = 0;
+        ptr += sizeof(struct pc2400m_drv_spi_transfer_msg_hdr);
+
+        /* transfer descriptors & payload */
+        desc_ptr = ptr;
+        pad = num_desc * PC2400M_DRV_SPI_DESCRIPTOR_SIZE;
+        ptr = desc_ptr + PC2400M_DRV_SPI_PAYLOAD_PAD(pad);
+        ctr = ptr - spif->spi_data - PC2400M_DRV_SPI_BLOCK_HEADER;
+
+        /* fill excess descriptor space with 0xff */
+        wimax_osal_mem_set(
+                desc_ptr + pad, 0xff, PC2400M_DRV_SPI_PAYLOAD_PAD(pad)-pad);
+
+        while ((pkt = wimax_osal_packet_list_pop(&(spif->tx_q))), pkt) {
+
+                /* transfer descriptor */
+                size = wimax_osal_packet_size(pkt);
+                pkt_ptr = wimax_osal_packet_ptr(pkt);
+                xfer_desc = (struct pc2400m_drv_spi_transfer_desc*)desc_ptr;
+                xfer_desc->size = WIMAX_OSAL_U16_TO_LE((u16)size);
+                xfer_desc->type =
+                        WIMAX_OSAL_U16_TO_LE(
+                                (u16)(u32)wimax_osal_packet_subtype_get(pkt));
+                desc_ptr += sizeof(struct pc2400m_drv_spi_transfer_desc);
+
+                /* payload */
+                while (size) {
+                        if (!(PC2400M_DRV_SPI_CALC_BLOCK_EXCESS(ctr)))
+                                ptr += PC2400M_DRV_SPI_BLOCK_PADDING;
+                        len = PC2400M_DRV_SPI_BLOCK_SIZE -
+                                PC2400M_DRV_SPI_CALC_BLOCK_EXCESS(ctr);
+                        if (len > size)
+                                len = size;
+                        wimax_osal_mem_cpy(ptr, pkt_ptr, len);
+                        size -= len;
+                        pkt_ptr += len;
+                        ptr += len;
+                        ctr += len;
+                }
+
+                size = wimax_osal_packet_size(pkt);
+                size = PC2400M_DRV_SPI_PAYLOAD_PAD(size) - size;
+
+                while (size) {
+                        if (!(PC2400M_DRV_SPI_CALC_BLOCK_EXCESS(ctr)))
+                                ptr += PC2400M_DRV_SPI_BLOCK_PADDING;
+                        len = PC2400M_DRV_SPI_BLOCK_SIZE -
+                                PC2400M_DRV_SPI_CALC_BLOCK_EXCESS(ctr);
+                        if (len > size)
+                                len = size;
+                        wimax_osal_mem_set(ptr, 0xff, len);
+                        size -= len;
+                        ptr += len;
+                        ctr += len;
+                }
+
+                wimax_osal_packet_free(&pkt);
+        }
+
+        /* add block padding if necessary */
+        if (PC2400M_DRV_SPI_CALC_BLOCK_EXCESS(ctr)) {
+                len = PC2400M_DRV_SPI_BLOCK_SIZE -
+                        PC2400M_DRV_SPI_CALC_BLOCK_EXCESS(ctr);
+                wimax_osal_mem_set(ptr, 0xff, len);
+                ctr += len;
+        }
+
+        /* add block headers and footers */
+#if (PC2400M_DRV_SPI_BLOCK_HEADER != 4 || PC2400M_DRV_SPI_BLOCK_FOOTER != 4)
+#error Code relies on block header sizes 4!
+#endif
+        ptr = spif->spi_data;
+        hdr = WIMAX_OSAL_U32_TO_BE(PC2400M_DRV_SPI_BLOCK_HEADER_PAT);
+        ftr = WIMAX_OSAL_U32_TO_BE(PC2400M_DRV_SPI_BLOCK_FOOTER_PAT);
+        for (i=0; i<ctr; i+=PC2400M_DRV_SPI_BLOCK_SIZE) {
+                *((u32*)ptr) = hdr;
+                *((u32*)(ptr + PC2400M_DRV_SPI_BLOCK_HEADER +
+                         PC2400M_DRV_SPI_BLOCK_SIZE)) = ftr;
+                ptr += (PC2400M_DRV_SPI_BLOCK_SIZE +
+                        PC2400M_DRV_SPI_BLOCK_PADDING);
+        }
+
+        /* queue a write command */
+        ret = pc2400m_drv_send_write_cmd53(
+                hnd, PC2400M_DRV_SPI_CALC_NUMBER_OF_BLOCKS(total), 0,
+                spif->spi_data, ptr-spif->spi_data);
+        spif->tx_q_len = 0;
+
+
+ out:
+        return ret;
+
+}
+
+
+/** Search for a logical rx block. Search for an SPI logical transfer block
+ *  within the stream of data stored in the buffer provided.
+ *
+ *  @param ptr pointer to data buffer beginning
+ *  @param end pointer to data buffer end
+ *  @return returns a pointer to the start of the transfer block
+ */
+static u8 *pc2400m_drv_spi_find_next_block(u8 *ptr, u8 *end) {
+
+        s32 i = 0;
+        while (*(ptr++) != 0xfe) {
+                i++;
+                if (i >= PC2400M_DRV_SPI_BLOCK_EXCESS ||
+                    (ptr + PC2400M_DRV_SPI_BLOCK_SIZE >= end)) {
+                        wimax_osal_trace_byte(PC2400M_GROUP_SPI_ERROR,
+                                              PC2400M_TRACE_OUT_OF_DATA,
+                                              WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                                              i);
+                        goto err1;
+                }
+        }
+
+        goto out;
+ err1:
+        ptr = NULL;
+ out:
+        return ptr;
+
+}
+
+/** Read an SPI message from SPI. Synchronously receive the indicated number
+ *  of data blocks from the SPI bus from the device specified.
+ *
+ *  @param hnd handle to the HDI instance
+ *  @return Returns ESUCCESS upon success, a negative value upon error.
+ */
+static s32 pc2400m_drv_spi_read(struct pc2400m_drv_hdi_if *hnd)
+{
+
+        struct pc2400m_drv_spi_transfer_msg_hdr *xfer_hdr;
+        struct pc2400m_drv_spi_transfer_desc *xfer_desc;
+        struct pc2400m_drv_hdi_spi_if *spif =
+                (struct pc2400m_drv_hdi_spi_if*)hnd;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->ctx);
+        u16 len;
+        s32 ret = ESUCCESS;
+        s32 total, i;
+        u32 barker;
+        u32 seq;
+        u16 num_desc;
+        u16 btype;
+        u16 blength;
+        u16 pad_blength;
+        u8 *start;
+        u8 *ptr;
+        u8 *desc_ptr;
+        wimax_osal_packet *packet;
+        s32 res1, res2;
+
+#define COUNT_REG_OFFSET  0x1c
+        res1 = pc2400m_drv_send_cmd52(hnd, COUNT_REG_OFFSET, 0, d2h, func1);
+        res2 = pc2400m_drv_send_cmd52(hnd, COUNT_REG_OFFSET+1, 0, d2h, func1);
+
+        if (res1 < 0 || res2 < 0)
+                goto err1;
+
+        len = ((u16)res1) | (((u16)res2) << 8);
+        if (len == 0)
+                goto out;
+
+        if (PC2400M_DRV_SPI_CALC_BLOCK_EXCESS(len) != 0) {
+                wimax_osal_trace_u16(PC2400M_GROUP_SPI_ERROR,
+                                     PC2400M_TRACE_NOT_FULL_BLOCKS,
+                                     WIMAX_OSAL_TRACE_PRIORITY_ERROR, len);
+                goto err1;
+        }
+
+        total = len + PC2400M_DRV_SPI_CALC_NUMBER_OF_BLOCKS(len) *
+                PC2400M_DRV_SPI_BLOCK_EXCESS;
+        if (pc2400m_drv_send_read_cmd53(
+                    hnd, PC2400M_DRV_SPI_CALC_NUMBER_OF_BLOCKS(len), 0,
+                    spif->spi_data, total) < 0)
+                goto err1;
+
+        ret = len;
+        ptr = spif->spi_data + R_5_SIZE;
+
+        /* parse the transfer header */
+        if ((start = pc2400m_drv_spi_find_next_block(
+                     ptr, spif->spi_data + total)), !start) {
+                wimax_osal_trace(PC2400M_GROUP_SPI_ERROR,
+                                 PC2400M_TRACE_CORRUPT_XFER_HDR,
+                                 WIMAX_OSAL_TRACE_PRIORITY_ERROR);
+                goto err1;
+        }
+
+        ptr = start;
+
+        /* the assumption: the block will start at correct alignment */
+        xfer_hdr = (struct pc2400m_drv_spi_transfer_msg_hdr*)ptr;
+        barker = WIMAX_OSAL_LE_TO_U32(xfer_hdr->barker);
+        seq = WIMAX_OSAL_LE_TO_U32(xfer_hdr->seq);
+        num_desc = WIMAX_OSAL_LE_TO_U16(xfer_hdr->num_desc);
+        ptr += sizeof(struct pc2400m_drv_spi_transfer_msg_hdr);
+
+        if (barker == PC2400M_DRV_SPI_UNSECURE_BOOT_BARKER ||
+            barker == PC2400M_DRV_SPI_SECURE_BOOT_BARKER) {
+                wimax_osal_trace(PC2400M_GROUP_SPI_ERROR,
+                                 PC2400M_TRACE_DEVICE_REBOOT,
+                                 WIMAX_OSAL_TRACE_PRIORITY_ERROR);
+                priv->dm->abort_mission(priv->dm);
+                goto err1;
+        }
+
+        if (barker != PC2400M_DRV_SPI_D2H_BARKER) {
+                wimax_osal_trace_u32(PC2400M_GROUP_SPI_ERROR,
+                                     PC2400M_TRACE_CORRUPT_XFER_HDR,
+                                     WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                                     barker);
+                goto err1;
+        }
+
+        if (seq != spif->rx_seq++) {
+                wimax_osal_trace_u32(PC2400M_GROUP_SPI_ERROR,
+                                     PC2400M_TRACE_RX_SYNC_LOST,
+                                     WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                                     spif->rx_seq-1);
+                spif->rx_seq = seq + 1;
+        }
+
+        if (num_desc == 0) {
+                wimax_osal_trace(PC2400M_GROUP_SPI_ERROR,
+                                 PC2400M_TRACE_RX_EMPTY,
+                                 WIMAX_OSAL_TRACE_PRIORITY_ERROR);
+        }
+
+        /* start parsing the descriptors, and read the appropriate data */
+        desc_ptr = ptr;
+        ptr = ptr + PC2400M_DRV_SPI_PAYLOAD_PAD(
+                num_desc * PC2400M_DRV_SPI_DESCRIPTOR_SIZE);
+
+        for (i=0; i<num_desc; i++) {
+                xfer_desc = (struct pc2400m_drv_spi_transfer_desc*)desc_ptr;
+                pad_blength = WIMAX_OSAL_LE_TO_U16(xfer_desc->size);
+                btype = WIMAX_OSAL_LE_TO_U16(xfer_desc->type);
+                desc_ptr += sizeof(struct pc2400m_drv_spi_transfer_desc);
+
+                blength = PC2400M_DRV_SPI_PAYLOAD_PAD(pad_blength);
+                pad_blength = blength - pad_blength;
+                packet = wimax_osal_packet_alloc(blength);
+
+                while (blength) {
+                        len = PC2400M_DRV_SPI_BLOCK_SIZE - (ptr-start);
+                        if (len > blength) len = blength;
+                        wimax_osal_mem_cpy(wimax_osal_packet_put(packet, len),
+                                           ptr, len);
+                        ptr += len;
+                        blength -= len;
+
+                        if (blength) {
+                                /* a block is always followed by four status
+                                   bytes (which could be misinterpreted as
+                                   the "ready" code for the next block) */
+#define PC2400M_DRV_SPI_BLOCK_STATUS_LENGTH  4
+                                ptr += PC2400M_DRV_SPI_BLOCK_STATUS_LENGTH;
+                                if ((start =
+                                     pc2400m_drv_spi_find_next_block(
+                                             ptr, spif->spi_data + total)),
+                                    !start) {
+                                        goto err2;
+                                }
+                                ptr = start;
+                        } else {
+                                wimax_osal_packet_trim
+                                        (packet,
+                                         wimax_osal_packet_size(packet) -
+                                         pad_blength);
+                        }
+                }
+
+                wimax_osal_assert(
+                        wimax_osal_packet_list_len(
+                                &(spif->rx_q)) <= PC2400M_DRV_SPI_RX_Q_SIZE);
+                wimax_osal_packet_list_append(&(spif->rx_q), packet);
+                wimax_osal_packet_type_set(
+                        packet,
+                        WIMAX_OSAL_PACKET_TYPE_EXTENDED,
+                        (void*)(u32)btype);
+
+        }
+
+        goto out;
+
+ err2:
+        wimax_osal_packet_free(&packet);
+ err1:
+        ret = -EGENERAL;
+
+ out:
+        return ret;
+
+}
+
+
+/** Hardware interrupt handler. This function checks for and acknowledges the
+ *  interrupt, and the calls a function for further processing within the
+ *  driver (the control dispatcher.)
+ *
+ * @param ctx pointer to the osal context bound to the driver
+ * @return none
+ */
+static void pc2400m_drv_spi_irq(wimax_osal_context *ctx)
+{
+
+        struct pc2400m_private *priv =
+                (struct pc2400m_private*)wimax_osal_ctx_priv_get(ctx);
+        struct pc2400m_drv_hdi_spi_if *spif =
+                (struct pc2400m_drv_hdi_spi_if*)priv->dm->hdi;
+        s32 ret;
+
+        priv->ref(priv);
+
+        /* check interrupt */
+        ret = pc2400m_drv_send_cmd52(
+                priv->dm->hdi,
+                PC2400M_DRV_SPI_INT_PENDING_REG,
+                0,
+                d2h,
+                func0);
+        if (ret < 0 || !(ret & PC2400M_DRV_SPI_INT_PENDING_REG_INT1)) {
+                wimax_osal_trace(PC2400M_GROUP_SPI_ERROR,
+                                 PC2400M_TRACE_FAKE_IRQ,
+                                 WIMAX_OSAL_TRACE_PRIORITY_ERROR);
+                goto out;
+        }
+
+        /* acknowledge interrupt */
+        ret = pc2400m_drv_send_cmd52(
+                priv->dm->hdi,
+                PC2400M_DRV_SPI_INT_ENABLE_REG,
+                0,
+                d2h,
+                func1);
+        if (ret < 0 || !(ret & PC2400M_DRV_SPI_INT_ENABLE_REG_IENM)) {
+                wimax_osal_trace(PC2400M_GROUP_SPI_ERROR,
+                                 PC2400M_TRACE_UNSET_IRQ_FLAG,
+                                 WIMAX_OSAL_TRACE_PRIORITY_ERROR);
+                goto out;
+        }
+
+        spif->irq_cb(ctx);
+
+ out:
+
+        priv->unref(priv);
+        return;
+
+}
+
+
+/** Perform full card initialization. This function performs full card
+ *  initialization, including boot-up, card initialization, firmware
+ *  download and interrupt registration.
+ *
+ * @param ctx handle to identify the physical device for the driver
+ * @param fw pointer to a buffer containing the firmware image
+ * @param len length of the firmware image
+ * @param callback interrupt handler function to register
+ * @return Returns ESUCCESS upon success, or a negative value upon error.
+ */
+static s32 pc2400m_drv_spi_initialize(
+        struct pc2400m_drv_hdi_if *hnd,
+        u8* fw,
+        u32 len,
+        pc2400m_hdi_int_cb callback)
+{
+
+        struct pc2400m_drv_hdi_spi_if *spif =
+                (struct pc2400m_drv_hdi_spi_if*)hnd;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->ctx);
+        s32 ret = ESUCCESS;
+
+        /* perform hardware initialization */
+        ret = pc2400m_drv_spi_fw_init(hnd, fw, len);
+        if (ret == ESUCCESS) {
+
+                /* register the interrupt handler */
+                if (callback) {
+                        spif->irq_cb = callback;
+                        priv->aif->enable_irq(hnd->ctx, pc2400m_drv_spi_irq);
+                }
+        }
+
+        return ret;
+
+}
+
+/** Disable hardware interrupts. This function disables the hardware interrupt
+ *  and deregisters any interrupt handing functions.
+ *
+ * @param hnd handle to the HDI instance
+ * @return none
+ */
+static void pc2400m_drv_spi_irq_off(struct pc2400m_drv_hdi_if *hnd)
+{
+
+        struct pc2400m_drv_hdi_spi_if *spif =
+                (struct pc2400m_drv_hdi_spi_if*)hnd;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->ctx);
+
+        /* disconnect interrupts */
+        if (spif->irq_cb) {
+                spif->irq_cb = NULL;
+                priv->aif->enable_irq(hnd->ctx, NULL);
+        }
+
+        return;
+
+}
+
+/** Reset the SPI module. This function brings the SPI module to the state
+ *  it was after instantiation.
+ *
+ *  @param hnd handle to the HDI instance
+ *  @return none
+ */
+static void pc2400m_drv_spi_reset(struct pc2400m_drv_hdi_if *hnd)
+{
+
+        struct pc2400m_drv_hdi_spi_if *spif =
+                (struct pc2400m_drv_hdi_spi_if*)hnd;
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->ctx);
+        wimax_osal_packet *pkt;
+
+        /* disconnect interrupts */
+        if (spif->irq_cb) {
+                spif->irq_cb = NULL;
+                priv->aif->enable_irq(hnd->ctx, NULL);
+        }
+
+        /* free queued blocks and packets */
+        while ((pkt = wimax_osal_packet_list_pop(&(spif->tx_q))), pkt) {
+                wimax_osal_packet_free(&pkt);
+        }
+
+        while ((pkt = wimax_osal_packet_list_pop((&spif->rx_q))), pkt) {
+                wimax_osal_packet_free(&pkt);
+        }
+
+        spif->tx_q_len = 0;
+
+        spif->tx_seq = 0;
+        spif->rx_seq = 0;
+
+        return;
+
+}
+
+/** Deinstantiate the HDI SPI instance. This function cleans up all resources
+ *  allocated by the SPI instane.
+ *
+ * @param hnd handle to the HDI instance
+ * @return none
+ */
+static void pc2400m_drv_spi_cleanup(struct pc2400m_drv_hdi_if *hnd)
+{
+
+        /* free resources, cancel ongoing actions */
+        pc2400m_drv_spi_reset(hnd);
+
+        /* free the instance */
+        wimax_osal_mem_free((void**)&hnd);
+        return;
+
+}
+
+
+/*****************************************************************************
+ * Exported functions
+ */
+
+/** Instantiate new HDI SPI instance. This function creates a new instance
+ *  of the HDI SPI module, and brings the instance to an initial state.
+ *
+ * @param ctx the OSAL context to bind to the instance
+ * @return Returns a pointer to the newly created instance
+ */
+struct pc2400m_drv_hdi_if *pc2400m_drv_hdi_if_new(wimax_osal_context* ctx)
+{
+
+        struct pc2400m_drv_hdi_spi_if *iface;
+
+        iface = wimax_osal_mem_alloc_ex(sizeof(struct pc2400m_drv_hdi_spi_if),
+                                        WIMAX_OSAL_MEM_TYPE_DMA);
+        wimax_osal_mem_set(iface, 0x00, sizeof(struct pc2400m_drv_hdi_spi_if));
+
+        /* HDI generic part */
+        iface->hdi.ctx = ctx;
+        iface->hdi.put = pc2400m_drv_spi_put;
+        iface->hdi.get = pc2400m_drv_spi_get;
+        iface->hdi.write = pc2400m_drv_spi_write;
+        iface->hdi.read = pc2400m_drv_spi_read;
+        iface->hdi.initialize = pc2400m_drv_spi_initialize;
+        iface->hdi.irq_off = pc2400m_drv_spi_irq_off;
+        iface->hdi.cleanup = pc2400m_drv_spi_cleanup;
+        iface->hdi.reset = pc2400m_drv_spi_reset;
+
+        /* SPI part */
+        wimax_osal_packet_list_initialize(&(iface->rx_q));
+        wimax_osal_packet_list_initialize(&(iface->tx_q));
+
+        return (struct pc2400m_drv_hdi_if*)iface;
+
+}
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_spi_fw.c maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_spi_fw.c
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_spi_fw.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_spi_fw.c	2011-02-06 20:12:11.703333272 -0500
@@ -0,0 +1,1141 @@
+/*
+ * pc2400m_drv_spi_fw.c
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         7       APPROVED 15-May-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_drv_spi_fw.c
+ *
+ * This file implements code to support firmware downloading to the chipset.
+ * The secure and unsecure method are supported, and two firmware image types,
+ * legacy and SBCF are supported.
+ *
+ */
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include "pc2400m_osal.h"
+#include "pc2400m_drv_sdio.h"
+#include "pc2400m_drv_com.h"
+#include "pc2400m_drv_if.h"
+#include "pc2400m_drv_hdi.h"
+#include "pc2400m_drv_dm.h"
+#include "pc2400m_drv_spi.h"
+#include "pc2400m_drv_spi_fw.h"
+
+/*****************************************************************************
+ * Global constants and macros
+ */
+
+#ifdef CONFIG_NET_PC2400M_SPI_48MHZ
+#define PC2400M_USE_HIGH_SPEED
+#endif /* CONFIG_NET_PC2400M_SPI_48MHZ */
+
+/** this macro specifies the "illegal" boot barker */
+#define PC2400M_DRV_SPI_NULL_BOOT_BARKER   0x00000000
+
+
+/*****************************************************************************
+ * Global data types
+ */
+
+struct pc2400m_drv_spi_fw_bcf_header {
+        u32 module_type;
+        u32 header_len;
+        u32 header_version;
+        u32 module_id;
+        u32 module_vendor;
+        u32 date;
+        u32 size;
+        u32 key_size;
+        u32 modulus_size;
+        u32 exponent_size;
+        u32 reserved[22];
+};
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/*****************************************************************************
+ * Local functions
+ */
+
+/** Write raw data to the chipset. This function writes the data in the SPI
+ *  buffer onto the chipset not looking at the contents of the data.
+ *
+ * @param hnd handle to the instance of the SPI module
+ * @param len length of the data to write
+ * @return returns ESUCCESS upon success, otherwise a negative value.
+ */
+static s32 pc2400m_drv_spi_fw_raw_write(
+        struct pc2400m_drv_hdi_spi_if *hnd,
+        s32 len)
+{
+
+        u8 *spi_data_ptr = hnd->spi_data + len;
+        u8 *ptr;
+        s32 i,ret;
+        u32 hdr;
+        u32 ftr;
+
+        /* transfer occurs in full blocks, pad if necessary, add
+           padding data and ready signals */
+        if (PC2400M_DRV_SPI_CALC_BLOCK_EXCESS(len)) {
+                i = PC2400M_DRV_SPI_BLOCK_SIZE -
+                        PC2400M_DRV_SPI_CALC_BLOCK_EXCESS(len);
+                wimax_osal_mem_set(spi_data_ptr, 0xff, i);
+                spi_data_ptr += i;
+                len += i;
+        }
+
+        /* add intermediate headers to the mix */
+        hdr = WIMAX_OSAL_U32_TO_BE(PC2400M_DRV_SPI_BLOCK_HEADER_PAT);
+        ftr = WIMAX_OSAL_U32_TO_BE(PC2400M_DRV_SPI_BLOCK_FOOTER_PAT);
+        spi_data_ptr -= PC2400M_DRV_SPI_BLOCK_SIZE;
+        for (i=len/PC2400M_DRV_SPI_BLOCK_SIZE-1; i>=0; i--) {
+                ptr = hnd->spi_data + i * (PC2400M_DRV_SPI_BLOCK_SIZE +
+                                            PC2400M_DRV_SPI_BLOCK_PADDING) +
+                        PC2400M_DRV_SPI_BLOCK_HEADER;
+                wimax_osal_mem_move(
+                        ptr, spi_data_ptr, PC2400M_DRV_SPI_BLOCK_SIZE);
+
+                *((u32*)(ptr-PC2400M_DRV_SPI_BLOCK_HEADER)) = hdr;
+                *((u32*)(ptr+PC2400M_DRV_SPI_BLOCK_SIZE)) = ftr;
+
+                spi_data_ptr -= PC2400M_DRV_SPI_BLOCK_SIZE;
+
+        }
+
+        /* queue a write command */
+        ret = pc2400m_drv_send_write_cmd53(
+                &hnd->hdi,
+                len/PC2400M_DRV_SPI_BLOCK_SIZE,
+                0,
+                hnd->spi_data,
+                (len/PC2400M_DRV_SPI_BLOCK_SIZE) *
+                (PC2400M_DRV_SPI_BLOCK_SIZE + PC2400M_DRV_SPI_BLOCK_PADDING));
+        hnd->tx_q_len = 0;
+
+        return ret;
+
+}
+
+/** Read raw data from the chipset. This function fills the buffer with data
+ *  from the chipset in the amount reported by the chipset. The contents of
+ *  the data is ignored.
+ *
+ * @param hnd handle to the instance of the SPI module
+ * @return Returns ESUCCESS upon success, otherwise a negative value.
+ */
+static s32 pc2400m_drv_spi_fw_raw_read(struct pc2400m_drv_hdi_spi_if *hnd)
+{
+
+        u8 *spi_data_ptr;
+        u16 len;
+        s32 i, block, ret = ESUCCESS;
+        s32 res1, res2;
+
+#define COUNT_REG_OFFSET  0x1c
+
+        /* the zeroes below are "don't care" as the parameter is valid only
+           for h2d operations. */
+        res1 = pc2400m_drv_send_cmd52(
+                &hnd->hdi, COUNT_REG_OFFSET, 0, d2h, func1);
+        res2 = pc2400m_drv_send_cmd52(
+                &hnd->hdi, COUNT_REG_OFFSET+1, 0, d2h, func1);
+
+        if (res1 < 0 || res2 < 0)
+                goto err1;
+
+        len = ((u16)res1) | (((u16)res2) << 8);
+        if (!len)
+                goto err1;
+
+        if (0 != PC2400M_DRV_SPI_CALC_BLOCK_EXCESS(len)) {
+                wimax_osal_trace_u16(PC2400M_GROUP_SPI_ERROR,
+                                     PC2400M_TRACE_NOT_FULL_BLOCKS,
+                                     WIMAX_OSAL_TRACE_PRIORITY_ERROR, len);
+                goto err1;
+        }
+
+        if (pc2400m_drv_send_read_cmd53(
+                    &hnd->hdi,
+                    PC2400M_DRV_SPI_CALC_NUMBER_OF_BLOCKS(len),
+                    0,
+                    hnd->spi_data,
+                    len + PC2400M_DRV_SPI_CALC_NUMBER_OF_BLOCKS(len) *
+                    PC2400M_DRV_SPI_BLOCK_EXCESS) < 0)
+                goto err1;
+
+        /* parse the data */
+        ret = len;
+        spi_data_ptr = hnd->spi_data + R_5_SIZE;
+        block = 0;
+        do {
+                /* look for a start code */
+                i = 0;
+                while (*(spi_data_ptr++) != 0xfe) {
+                        i++;
+                        if ((i >= PC2400M_DRV_SPI_BLOCK_EXCESS) ||
+                            (spi_data_ptr - hnd->spi_data >=
+                             PC2400M_DRV_SPI_DATA_SIZE -
+                             PC2400M_DRV_SPI_BLOCK_SIZE)) {
+                                wimax_osal_trace_u32(
+                                        PC2400M_GROUP_SPI_ERROR,
+                                        PC2400M_TRACE_OUT_OF_DATA,
+                                        WIMAX_OSAL_TRACE_PRIORITY_ERROR, i);
+                                goto err1;
+                        }
+                }
+
+                wimax_osal_mem_move(hnd->spi_data + block, spi_data_ptr,
+                                    PC2400M_DRV_SPI_BLOCK_SIZE);
+                block += PC2400M_DRV_SPI_BLOCK_SIZE;
+                spi_data_ptr += PC2400M_DRV_SPI_BLOCK_SIZE;
+                len -= PC2400M_DRV_SPI_BLOCK_SIZE;
+
+        } while (len);
+
+        goto out;
+
+ err1:
+        ret = -EGENERAL;
+
+ out:
+
+        return ret;
+
+}
+
+
+
+/** Power on and initialize the chipset. This function synchronously
+ *  powers up and initializes the chipset. The initialization consists
+ *  of configuration of the SPI/SDIO controller.
+ *
+ * @param hnd handle to the instance of the SPI module
+ * @return ESUCCESS upon success, a negative value upon error. the power to
+ *         the chipset will remain off if an error occurs.
+ */
+static s32 pc2400m_drv_spi_fw_power_on(struct pc2400m_drv_hdi_spi_if *hnd)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->hdi.ctx);
+        struct R_4 r4;
+        u32 ocr;
+        s32 ret = ESUCCESS;
+
+        /* power on the device */
+        priv->aif->set_power(hnd->hdi.ctx, TRUE);
+
+        /* perform a card reset */
+        if (pc2400m_drv_send_cmd0(&hnd->hdi))
+                goto err1;
+
+        /* query the operating conditions register */
+#define PC2400M_DRV_SPI_FW_EMPTY_OCR   0x00000000
+        ocr = pc2400m_drv_send_cmd5(
+                &hnd->hdi, PC2400M_DRV_SPI_FW_EMPTY_OCR, &r4 );
+
+        /* pc2400m always returns this praticular value */
+#define PC2400M_DRV_SPI_FW_FIXED_OCR   0x000FF8000
+        if (ocr != PC2400M_DRV_SPI_FW_FIXED_OCR)
+                goto err1;
+
+        /* offer the same operating conditions to the card until it is
+           ready */
+        do
+        {
+                pc2400m_drv_send_cmd5(&hnd->hdi, ocr, &r4 );
+        }
+        while( !r4.u.bits.card_bit);
+
+        /* enable interrupts */
+        pc2400m_drv_send_cmd52(
+                &hnd->hdi,
+                PC2400M_DRV_SPI_INT_ENABLE_REG,
+                PC2400M_DRV_SPI_INT_ENABLE_REG_IENM |
+                PC2400M_DRV_SPI_INT_ENABLE_REG_IEN1,
+                h2d,
+                func0);
+
+        /* enable I/O */
+        pc2400m_drv_send_cmd52(
+                &hnd->hdi,
+                PC2400M_DRV_SPI_IO_ENABLE_REG,
+                PC2400M_DRV_SPI_IO_ENABLE_REG_IOE1,
+                h2d,
+                func0);
+
+        /* set I/O ready */
+        pc2400m_drv_send_cmd52(
+                &hnd->hdi,
+                PC2400M_DRV_SPI_IO_READY_REG,
+                PC2400M_DRV_SPI_IO_READY_REG_NONE,
+                h2d,
+                func0);
+
+        /* card capability */
+        pc2400m_drv_send_cmd52(
+                &hnd->hdi,
+                PC2400M_DRV_SPI_CARD_CAPA_REG,
+                PC2400M_DRV_SPI_CARD_CAPA_REG_E4MI,
+                h2d,
+                func0);
+
+#ifdef PC2400M_USE_HIGH_SPEED
+        /* configure for full speed SPI transfers */
+        pc2400m_drv_send_cmd52(
+                &hnd->hdi,
+                PC2400M_DRV_SPI_FULL_SPEED_REG,
+                PC2400M_DRV_SPI_FULL_SPEED_REG_FSM |
+                PC2400M_DRV_SPI_FULL_SPEED_REG_FS1,
+                h2d,
+                func0);
+#define PC2400M_DRV_SPI_FULL_SPEED_FREQ    48000000
+        priv->aif->configure(
+                hnd->hdi.ctx,
+                PC2400M_DRV_SPI_FULL_SPEED_FREQ,
+                0);
+#endif /* PC2400M_USE_HIGH_SPEED */
+
+        /* set cmd53 block size */
+        pc2400m_drv_send_cmd52(
+                &hnd->hdi,
+                PC2400M_DRV_SPI_IO_BLOCK_SIZE_FNC1_LSB_REQ,
+                PC2400M_DRV_SPI_BLOCK_SIZE&0xFF,
+                h2d,
+                func0);
+        pc2400m_drv_send_cmd52(
+                &hnd->hdi,
+                PC2400M_DRV_SPI_IO_BLOCK_SIZE_FNC1_MSB_REQ,
+                (PC2400M_DRV_SPI_BLOCK_SIZE&0xFF00)>>8,
+                h2d,
+                func0);
+
+        goto out;
+
+ err1:
+        /* power off the chipset and fail */
+#define PC2400M_DRV_SPI_POWERDOWN_DELAY 20000
+        wimax_osal_sleep(PC2400M_DRV_SPI_POWERDOWN_DELAY);
+        priv->aif->set_power(hnd->hdi.ctx, FALSE);
+        ret = -EGENERAL;
+
+ out:
+        return ret;
+
+}
+
+
+/** Poll for interrupt and then read data. This function first polls the
+ *  chipset interrupt register, and when the interrupt occurs, it reads
+ *  data from the chipset.
+ *
+ *  @param hnd handle to the instance of the SPI module
+ *  @return ESUCCESS on success, otherwise negative value
+ */
+static s32 pc2400m_drv_spi_fw_wait_read(struct pc2400m_drv_hdi_spi_if *hnd)
+{
+
+        s32 ret;
+        s32 i = 0;
+#define PC2400M_DRV_SPI_FW_ACK_WAIT_MAX   1000
+
+        do {
+
+                ret = pc2400m_drv_send_cmd52(
+                        &hnd->hdi,
+                        PC2400M_DRV_SPI_INT_PENDING_REG,
+                        0,
+                        d2h,
+                        func0);
+                if (ret < 0)
+                        goto err;
+                if (i++ > PC2400M_DRV_SPI_FW_ACK_WAIT_MAX)
+                        goto err;
+        } while (!(ret & PC2400M_DRV_SPI_INT_PENDING_REG_INT1));
+
+        /* clear the interrupt */
+        if (pc2400m_drv_send_cmd52(
+                    &hnd->hdi,
+                    PC2400M_DRV_SPI_INT_ENABLE_REG,
+                    0,
+                    d2h,
+                    func1) < 0)
+                goto err;
+
+        if (pc2400m_drv_spi_fw_raw_read(hnd) < 0)
+                goto err;
+
+
+        /* the above functions return also another success values than
+           ESUCCESS - force the official success code */
+        ret = ESUCCESS;
+        goto out;
+
+ err:
+        ret = -EGENERAL;
+
+ out:
+        return ret;
+
+}
+
+
+/** Check for reboot barker. Check the interrupt register, and if and
+ *  interrupt is pending, read the data. If the response is a reboot barker,
+ *  indicate that to the caller.
+ *
+ *  @param hnd handle to the instance of the SPI module
+ *  @return TRUE if the reboot barker was received, FALSE otherwise
+ */
+static boolean pc2400m_drv_spi_fw_check_reboot(
+        struct pc2400m_drv_hdi_spi_if *hnd)
+{
+
+        boolean ret = FALSE;
+        s32 val;
+
+        /* the interrupt register is set (or reading it fails) then
+           proceed to check deeper */
+        val = pc2400m_drv_send_cmd52(
+                &hnd->hdi,
+                PC2400M_DRV_SPI_INT_PENDING_REG,
+                0,
+                d2h,
+                func0);
+        if ((val < 0) || (val & PC2400M_DRV_SPI_INT_PENDING_REG_INT1))
+                ret = TRUE;
+
+        if (ret) {
+                pc2400m_drv_send_cmd52(
+                        &hnd->hdi,
+                        PC2400M_DRV_SPI_INT_ENABLE_REG,
+                        0,
+                        d2h,
+                        func1);
+                val = pc2400m_drv_spi_fw_raw_read(hnd);
+
+                /* if reading did not fail, and the returned data is not
+                   the reboot barker, then the chipset surely has not
+                   rebooted */
+                if ((WIMAX_OSAL_LE_TO_U32(*((u32*)hnd->spi_data)) !=
+                    PC2400M_DRV_SPI_UNSECURE_BOOT_BARKER) &&
+                    (WIMAX_OSAL_LE_TO_U32(*((u32*)hnd->spi_data)) !=
+                     PC2400M_DRV_SPI_SECURE_BOOT_BARKER) &&
+                    (val >= 0))
+                {
+                        ret = FALSE;
+                } else {
+
+                        wimax_osal_trace_u32(
+                                PC2400M_GROUP_SPI_ERROR,
+                                PC2400M_TRACE_DEVICE_REBOOT,
+                                WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                                WIMAX_OSAL_LE_TO_U32(*((u32*)hnd->spi_data)));
+                }
+        }
+
+        return ret;
+
+}
+
+
+/** Tingle the chipset to get the barker. This function sends an illegal
+ *  bootloader command to the chipset to cause it to reset. As response to
+ *  the reset a reboot barker is sent, which the driver then reads.
+ *
+ * @param hnd handle to identify the physical device for the driver
+ */
+static u32 pc2400m_drv_spi_fw_get_boot_barker(
+        struct pc2400m_drv_hdi_spi_if *hnd)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->hdi.ctx);
+        struct pc2400m_drv_spi_asic_hdr *asic_hdr;
+        u32 boot_barker = PC2400M_DRV_SPI_NULL_BOOT_BARKER;
+
+        /* write an illegal command to the chipset. The following values
+           were randomly chosen. The important part is that the two most
+           significant bytes of the "command" are not 0xcbbc */
+        asic_hdr = (struct pc2400m_drv_spi_asic_hdr*)hnd->spi_data;
+        asic_hdr->command = WIMAX_OSAL_U32_TO_LE(0x12345678);
+        asic_hdr->address = WIMAX_OSAL_U32_TO_LE(0x00000000);
+        asic_hdr->size = WIMAX_OSAL_U32_TO_LE(0x00000000);
+        asic_hdr->checksum = WIMAX_OSAL_U32_TO_LE(0x00000000);
+
+        /* off with the block! */
+        if (pc2400m_drv_spi_fw_raw_write(hnd, PC2400M_DRV_SPI_FW_HEADER) < 0)
+                goto err;
+
+        /* wait for the device boot barker */
+        if (pc2400m_drv_spi_fw_wait_read(hnd) < 0)
+                goto err;
+
+        /* extract the boot barker */
+        boot_barker = WIMAX_OSAL_LE_TO_U32(*((u32*)hnd->spi_data));
+
+        goto out;
+
+ err:
+        wimax_osal_sleep(PC2400M_DRV_SPI_POWERDOWN_DELAY);
+
+ out:
+        /* power off the chipset */
+        priv->aif->set_power(hnd->hdi.ctx, 0);
+
+        return boot_barker;
+
+}
+
+/** Send bootloader command to chipset. This function sends a bootloader
+ *  command with the specified parameters and payload to the chipset. This
+ *  function does not split the payload into smaller pieces. This function
+ *  checks for a reboot barker after the write, or, if specified by the command
+ *  opcode, waits for acknowledgement.
+ *
+ * @param hnd handle to the instance of the SPI module
+ * @param command command identifier
+ * @param address target address
+ * @param data pointer to command data
+ * @param size size of the data
+ * @param checksum checksum for the command
+ * @return ESUCCESS upon success, a negative value otherwise
+ */
+static s32 pc2400m_drv_spi_fw_download_bcf_send_cmd(
+        struct pc2400m_drv_hdi_spi_if *hnd,
+        u32 command,
+        u32 address,
+        u8 *data,
+        u32 size,
+        u32 checksum)
+{
+
+        struct pc2400m_drv_spi_asic_hdr *asic_cmd;
+        u8 *dataptr;
+        s32 ret = ESUCCESS;
+
+        /* prepare the setup command */
+        asic_cmd = (struct pc2400m_drv_spi_asic_hdr*)hnd->spi_data;
+        dataptr = (u8*)(asic_cmd + 1);
+
+        /* specify command parameters */
+        asic_cmd->command = WIMAX_OSAL_U32_TO_LE(command);
+        asic_cmd->address = WIMAX_OSAL_U32_TO_LE(address);
+        asic_cmd->size = WIMAX_OSAL_U32_TO_LE(size);
+        asic_cmd->checksum = WIMAX_OSAL_U32_TO_LE(checksum);
+
+        wimax_osal_mem_cpy(
+                dataptr,
+                data,
+                PC2400M_DRV_SPI_XFER_PAD(size));
+
+        /* send the command */
+        if (pc2400m_drv_spi_fw_raw_write(
+                    hnd, sizeof(struct pc2400m_drv_spi_asic_hdr) +
+                    PC2400M_DRV_SPI_XFER_PAD(size)) < 0)
+                goto err1;
+
+        if (command & PC2400M_DRV_SPI_CMD_BIT_RESP_REQD) {
+
+                /* if specified in the command, wait for an ack */
+                if (pc2400m_drv_spi_fw_wait_read(hnd) != ESUCCESS)
+                        goto err1;
+
+                /* check if the data is the reboot barker */
+                if (WIMAX_OSAL_LE_TO_U32(*((u32*)hnd->spi_data)) ==
+                    PC2400M_DRV_SPI_UNSECURE_BOOT_BARKER ||
+                    WIMAX_OSAL_LE_TO_U32(*((u32*)hnd->spi_data)) ==
+                    PC2400M_DRV_SPI_SECURE_BOOT_BARKER) {
+                        goto err1;
+
+                }
+
+        } else {
+
+                /* if not ack is expected, check that none is received */
+                if (pc2400m_drv_spi_fw_check_reboot(hnd))
+                        goto err1;
+        }
+
+        goto out;
+
+ err1:
+        ret = -EGENERAL;
+
+ out:
+        return ret;
+
+}
+
+/** Setup chipset for unsecure firmware. This function writes a set of
+ *  cryptic values to the chipset in order to correctly prepare it for
+ *
+ *  @param hnd handle to the instance of the SPI module
+ *  @return ESUCCESS on success, a negative value otherwise
+ */
+static s32 pc2400m_drv_spi_fw_download_bcf_setup(
+        struct pc2400m_drv_hdi_spi_if *hnd)
+{
+
+        static u32 setup_address[] = {
+                0x00081a58,
+                0x00080040,
+                0x00080048,
+                0x0008004c,
+                0x00080054,
+                0x00080058,
+                0x0008005c,
+                0x00080060,
+                0x00080574,
+                0x00080550,
+                0x00ae0000
+        };
+#define PC2400M_DRV_SPI_FW_SETUP_DATA_BYTES 4
+        static u8 setup_data[][PC2400M_DRV_SPI_FW_SETUP_DATA_BYTES] = {
+                {0x30, 0x02, 0x81, 0xa7},
+                {0x00, 0x00, 0x00, 0x00},
+                {0x82, 0x00, 0x00, 0x00},
+                {0x1f, 0x08, 0x00, 0x00},
+                {0x85, 0x00, 0x00, 0x00},
+                {0x80, 0x01, 0x00, 0x00},
+                {0x18, 0x00, 0x00, 0x00},
+                {0x10, 0x00, 0x00, 0x00},
+                {0x01, 0x00, 0x00, 0x00},
+                {0x05, 0x00, 0x00, 0x00},
+                {0x00, 0x00, 0x00, 0x00}
+        };
+
+        s32 ret = ESUCCESS;
+        u32 i;
+
+        /* send the configuration commands to the chipset */
+        for (i=0; i < sizeof(setup_address)/sizeof(u32); i++) {
+
+                if (pc2400m_drv_spi_fw_download_bcf_send_cmd(
+                        hnd,
+                        PC2400M_DRV_SPI_CMD_SETUP,
+                        setup_address[i],
+                        setup_data[i],
+                        PC2400M_DRV_SPI_FW_SETUP_DATA_BYTES,
+                        0) < 0) {
+
+                        wimax_osal_trace_u32(
+                                PC2400M_GROUP_SPI_ERROR,
+                                PC2400M_TRACE_FW_SETUP_FAILED,
+                                WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                                i);
+                        goto err1;
+                }
+
+        }
+
+        goto out;
+
+ err1:
+        ret = -EGENERAL;
+
+ out:
+        return ret;
+
+}
+
+
+/** Send fw header to boot loader. This function sends the header of the
+ *  BCF file to the chipset for hashing purposes.
+ *
+ *  @param hnd handle to the instance of the SPI module
+ *  @header pointer to the header of the file
+ *  @return ESUCCESS upon success, a negative value otherwise
+ */
+static s32 pc2400m_drv_spi_fw_download_bcf_send_header(
+        struct pc2400m_drv_hdi_spi_if *hnd,
+        struct pc2400m_drv_spi_fw_bcf_header *header)
+{
+
+
+        s32 ret = ESUCCESS;
+
+        if (pc2400m_drv_spi_fw_download_bcf_send_cmd(
+                    hnd,
+                    PC2400M_DRV_SPI_CMD_HASH_PAYLOAD,
+                    0x00000000,
+                    (u8*)header,
+                    sizeof(struct pc2400m_drv_spi_fw_bcf_header),
+                    0) < 0) {
+
+                wimax_osal_trace(
+                        PC2400M_GROUP_SPI_ERROR,
+                        PC2400M_TRACE_FW_HASH_ONLY_FAILED,
+                        WIMAX_OSAL_TRACE_PRIORITY_ERROR);
+                ret = -EGENERAL;
+        }
+
+        return ret;
+
+}
+
+/** Send fw body to the chipset. This function parses the boot loader commands
+ *  in the body of the BCF file and sends them to the chipset one by one.
+ *  The parsing ends once a JUMP command is encountered, and the offset
+ *  variable is updated to point to the beginning of the JUMP command. The
+ *  function also asserts by returning a success value, that the jump command
+ *  in the file is legal (all bytes are present.)
+ *
+ *  @param hnd handle to the instance of the SPI module
+ *  @param fw pointer to the firmware
+ *  @param fw_length length of the firmware
+ *  @param offset returns the offset of the jump command if successful
+ *  @return ESUCCESS upon success, a negative value otherwise
+ */
+static s32 pc2400m_drv_spi_fw_download_bcf_send_body(
+        struct pc2400m_drv_hdi_spi_if *hnd,
+        u8 *fw,
+        u32 fw_length,
+        u32 *offset)
+
+{
+
+        struct pc2400m_drv_spi_fw_bcf_header *bcf_hdr =
+                (struct pc2400m_drv_spi_fw_bcf_header*)fw;
+        struct pc2400m_drv_spi_asic_hdr *asic_hdr;
+
+        boolean do_loop = TRUE;
+        s32 ret = ESUCCESS;
+
+        /* calculate the offset for the start of the commands */
+        *offset = sizeof(struct pc2400m_drv_spi_fw_bcf_header) +
+                WIMAX_OSAL_LE_TO_U32(bcf_hdr->modulus_size) * sizeof(u32) +
+                WIMAX_OSAL_LE_TO_U32(bcf_hdr->exponent_size) * sizeof(u32) +
+                WIMAX_OSAL_LE_TO_U32(bcf_hdr->key_size) * sizeof(u32);
+
+        while (do_loop) {
+
+                /* process the next command */
+                asic_hdr = (struct pc2400m_drv_spi_asic_hdr*)(fw + *offset);
+
+
+                /* if the command size exceeds the size of the file, the
+                   firmware is corrupt, unless the header is there and it is
+                   the jump command */
+                if ((sizeof(struct pc2400m_drv_spi_asic_hdr)
+                     +*offset > fw_length) ||
+                    ((sizeof(struct pc2400m_drv_spi_asic_hdr) +
+                      WIMAX_OSAL_LE_TO_U32(asic_hdr->size) +
+                      *offset > fw_length) &&
+                     !PC2400M_DRV_SPI_CMD_IS_JUMP(
+                             WIMAX_OSAL_LE_TO_U32(asic_hdr->command)))) {
+
+                        /* the next command does not fit within the boundary of
+                           the firmware image. */
+                        wimax_osal_trace_u32(
+                                PC2400M_GROUP_SPI_ERROR,
+                                PC2400M_TRACE_FW_INVALID,
+                                WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                                *offset);
+                        goto err1;
+
+                }
+
+                /* if the command is a jump command, were done */
+                if (PC2400M_DRV_SPI_CMD_IS_JUMP(
+                            WIMAX_OSAL_LE_TO_U32(asic_hdr->command))) {
+                        do_loop = FALSE;
+                        continue;
+                }
+
+                /* send the command to the chipset */
+                if (pc2400m_drv_spi_fw_download_bcf_send_cmd(
+                            hnd,
+                            WIMAX_OSAL_LE_TO_U32(asic_hdr->command),
+                            WIMAX_OSAL_LE_TO_U32(asic_hdr->address),
+                            (u8*)(fw + *offset +
+                                  sizeof(struct pc2400m_drv_spi_asic_hdr)),
+                            WIMAX_OSAL_LE_TO_U32(asic_hdr->size),
+                            WIMAX_OSAL_LE_TO_U32(asic_hdr->checksum)) < 0) {
+
+                        wimax_osal_trace_u32(
+                                PC2400M_GROUP_SPI_ERROR,
+                                PC2400M_TRACE_FW_DL_FAIL,
+                                WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                                *offset);
+
+                        goto err1;
+                }
+
+                /* increment the offset to the next command */
+                *offset += PC2400M_DRV_SPI_XFER_PAD(
+                        (sizeof(struct pc2400m_drv_spi_asic_hdr) +
+                         WIMAX_OSAL_LE_TO_U32(asic_hdr->size)));
+
+        }
+
+        goto out;
+
+ err1:
+        ret = -EGENERAL;
+
+ out:
+
+        return ret;
+
+}
+
+
+/** Send jump command to the chipset. This function sends the JUMP command
+ *  found in the firmware image at "offset" to the chipset. The JUMP command
+ *  is changed to one without signature, if the "boot_barker" indicates
+ *  unsecured chipset, otherwise the JUMP command remains as-is. In the
+ *  secured chipset case, the signature from the BCF image is appended
+ *  to the JUMP command.
+ *
+ *  @param hnd handle to the instance of the SPI module
+ *  @param boot_barker barker sent by the chipset upon boot
+ *  @param fw pointer to the firmware
+ *  @param offset pointer to the start of the jump command
+ *  @return ESUCCESS upon success, a negative value otherwise
+ */
+static s32 pc2400m_drv_spi_fw_download_bcf_send_jump(
+        struct pc2400m_drv_hdi_spi_if *hnd,
+        u32 boot_barker,
+        u8 *fw,
+        u32 offset)
+{
+
+        struct pc2400m_drv_spi_fw_bcf_header *bcf_hdr =
+                (struct pc2400m_drv_spi_fw_bcf_header*)fw;
+        struct pc2400m_drv_spi_asic_hdr *asic_hdr;
+        s32 ret = ESUCCESS;
+        u32 command;
+        u32 size = 0;
+        u8 *dataptr = NULL;
+
+        /* process the jump command */
+        asic_hdr = (struct pc2400m_drv_spi_asic_hdr*)(fw + offset);
+        command = WIMAX_OSAL_LE_TO_U32(asic_hdr->command);
+
+        if (boot_barker == PC2400M_DRV_SPI_SECURE_BOOT_BARKER) {
+
+                /* append the signature from the BCF file to the command */
+                size = WIMAX_OSAL_LE_TO_U32(bcf_hdr->key_size) * sizeof(u32);
+                dataptr = fw +
+                        sizeof(struct pc2400m_drv_spi_fw_bcf_header) +
+                        WIMAX_OSAL_LE_TO_U32(bcf_hdr->modulus_size) *
+                        sizeof(u32) +
+                        WIMAX_OSAL_LE_TO_U32(bcf_hdr->exponent_size) *
+                        sizeof(u32);
+
+
+        } else {
+
+                /* change the command opcode to JUMP without signature */
+                command = PC2400M_DRV_SPI_CMD_SET_OPCODE(
+                        command, PC2400M_DRV_SPI_CMD_OPCODE_JUMP);
+
+        }
+
+        /* send the jump command to the chipset */
+        if (pc2400m_drv_spi_fw_download_bcf_send_cmd(
+                    hnd,
+                    command,
+                    WIMAX_OSAL_LE_TO_U32(asic_hdr->address),
+                    dataptr,
+                    size,
+                    WIMAX_OSAL_LE_TO_U32(asic_hdr->checksum)) < 0) {
+
+                wimax_osal_trace_u32(
+                        PC2400M_GROUP_SPI_ERROR,
+                        PC2400M_TRACE_FW_JUMP_FAILED,
+                        WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                        WIMAX_OSAL_LE_TO_U32(asic_hdr->address));
+                goto err1;
+        }
+
+        goto out;
+
+ err1:
+        ret = -EGENERAL;
+
+ out:
+        return ret;
+
+}
+
+
+/** Download bcf firmware image. This function synchronously downloads a
+ *  firmware image in BCF format to the chipset. This function selects between
+ *  the secure and unsecure method based on the "boot_barker" provided.
+ *
+ *  @param hnd handle to the instance of the SPI module
+ *  @param fw pointer to buffer containing firmware
+ *  @param fw_length length of the firmware
+ *  @param boot_barker the barker from the chipset upon boot
+ *  @return ESUCCESS upon success, a negative value otherwise.
+ */
+static s32 pc2400m_drv_spi_fw_download_bcf(
+        struct pc2400m_drv_hdi_spi_if *hnd,
+        u8 *fw,
+        u32 fw_length,
+        u32 boot_barker)
+{
+
+        s32 ret = ESUCCESS;
+        u32 offset;
+        struct pc2400m_drv_spi_fw_bcf_header *bcf_hdr =
+                (struct pc2400m_drv_spi_fw_bcf_header*)fw;
+
+        /* double check the image size to be sure it contains the header
+           at least */
+        if ((fw_length < sizeof(struct pc2400m_drv_spi_fw_bcf_header)) ||
+            (fw_length < (sizeof(struct pc2400m_drv_spi_fw_bcf_header) +
+                          WIMAX_OSAL_LE_TO_U32(bcf_hdr->modulus_size) *
+                          sizeof(u32) +
+                          WIMAX_OSAL_LE_TO_U32(bcf_hdr->exponent_size) *
+                          sizeof(u32) +
+                          WIMAX_OSAL_LE_TO_U32(bcf_hdr->key_size) *
+                          sizeof(u32)))) {
+
+                /* the firmware image is not supported */
+                wimax_osal_trace(
+                        PC2400M_GROUP_SPI_ERROR,
+                        PC2400M_TRACE_FW_INVALID,
+                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG);
+                goto err1;
+
+        }
+
+
+        /* double check image header fields to determine, whether the format
+           is supported or not. */
+#define PC2400M_DRV_SPI_BCF_HEADER_VER    0x00010000
+#define PC2400M_DRV_SPI_BCF_MODULE_VENDOR 0x00008086
+        if (WIMAX_OSAL_LE_TO_U32(bcf_hdr->header_version) !=
+            PC2400M_DRV_SPI_BCF_HEADER_VER ||
+            WIMAX_OSAL_LE_TO_U32(bcf_hdr->module_vendor) !=
+            PC2400M_DRV_SPI_BCF_MODULE_VENDOR) {
+
+                /* the firmware image is not supported */
+                wimax_osal_trace_data(
+                        PC2400M_GROUP_SPI_ERROR,
+                        PC2400M_TRACE_FW_INVALID,
+                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG,
+                        (u8*)bcf_hdr,
+                        sizeof(struct pc2400m_drv_spi_fw_bcf_header));
+                goto err1;
+
+        }
+
+        if (boot_barker == PC2400M_DRV_SPI_SECURE_BOOT_BARKER) {
+
+                /* for secured boot, send the header to the chipset */
+                if (pc2400m_drv_spi_fw_download_bcf_send_header(
+                            hnd, bcf_hdr) < 0)
+                        goto err1;
+
+        } else {
+
+                /* give trace, that the device is unsecure */
+                wimax_osal_trace(
+                        PC2400M_GROUP_SPI_DEBUG,
+                        PC2400M_TRACE_FW_CHIPSET_UNSECURE,
+                        WIMAX_OSAL_TRACE_PRIORITY_DEBUG);
+
+                /* for unsecured boot, perform the device setup
+                   procedure */
+                if (pc2400m_drv_spi_fw_download_bcf_setup(hnd) < 0)
+                        goto err1;
+
+        }
+
+        /* send the commands the commands from the BCF file to the chipset */
+        if (pc2400m_drv_spi_fw_download_bcf_send_body(
+                    hnd, fw, fw_length, &offset) < 0)
+                goto err1;
+
+        /* send the jump command to the chipset to start the firmware */
+        if (pc2400m_drv_spi_fw_download_bcf_send_jump(
+                    hnd, boot_barker, fw, offset) < 0)
+                goto err1;
+
+        /* firmware download done! */
+
+        goto out;
+
+ err1:
+        ret = -EGENERAL;
+
+ out:
+        return ret;
+
+}
+
+
+/** Download the firmware based on image type. This function downloads the
+ *  provided firmware image to the chipset. This function selects the
+ *  method and image type based on the "boot_barker" and the firmware
+ *  image contents.
+ *
+ *  @param hnd handle to the instance of the SPI module
+ *  @param boot_barker boot barker value for the chipset
+ *  @param fw pointer to buffer containing firmware
+ *  @param fw_length length of the firmware
+ *  @return ESUCCESS upon success, a negative value otherwise
+ */
+static s32 pc2400m_drv_spi_fw_download(
+        struct pc2400m_drv_hdi_spi_if *hnd,
+        u32 boot_barker,
+        u8 *fw,
+        u32 fw_length)
+{
+
+        struct pc2400m_private *priv = wimax_osal_ctx_priv_get(hnd->hdi.ctx);
+        s32 ret = ESUCCESS;
+
+#define PC2400M_DRV_SPI_FW_SECURE_FW_COOKIE  0x00000006
+        if (WIMAX_OSAL_GET_LE32(fw) == PC2400M_DRV_SPI_FW_SECURE_FW_COOKIE) {
+
+                /* the firmware image is the new secure BCF format */
+                ret = pc2400m_drv_spi_fw_download_bcf(
+                        hnd, fw, fw_length, boot_barker);
+                if (ret < 0)
+                        goto err;
+
+        } else {
+                wimax_osal_trace_data(
+                        PC2400M_GROUP_SPI_ERROR,
+                        PC2400M_TRACE_FW_INVALID,
+                        WIMAX_OSAL_TRACE_PRIORITY_ERROR,
+                        fw, sizeof(u32));
+                goto err1;
+        }
+
+        goto out;
+
+ err1:
+        ret = -EGENERAL;
+
+ err:
+
+        wimax_osal_sleep(PC2400M_DRV_SPI_POWERDOWN_DELAY);
+
+        /* power off the chipset */
+        priv->aif->set_power(hnd->hdi.ctx, 0);
+
+ out:
+        return ret;
+
+}
+
+/** Initialize the hardware and download firmware. This function powers-up and
+ *  initializes the chipset, and then downloads the firmware to chipset and
+ *  starts it up.
+ *
+ *  @param hdi pointer to the HDI interface instance
+ *  @param fw pointer to buffer containing the firmware
+ *  @param fw_length length of the firmware
+ *  @return ESUCCESS upon success, a negative value otherwise
+ */
+s32 pc2400m_drv_spi_fw_init(
+        struct pc2400m_drv_hdi_if *hdi,
+        u8 *fw,
+        u32 fw_length)
+{
+
+        struct pc2400m_drv_hdi_spi_if *hnd =
+                (struct pc2400m_drv_hdi_spi_if*)hdi;
+        u32 boot_barker;
+        s32 retries = PC2400M_DRV_SPI_FW_DL_RETRIES;
+        s32 ret = ESUCCESS;
+
+#define PC2400M_DRV_SPI_POWERUP_DELAY 10 /* ms */
+
+        wimax_osal_trace_u32(PC2400M_GROUP_SPI_INFO,
+                             PC2400M_TRACE_FW_DL,
+                             WIMAX_OSAL_TRACE_PRIORITY_DEBUG, fw_length);
+
+        while (retries) {
+
+                retries--;
+
+                /* power on and hardware initialize the device */
+                ret = pc2400m_drv_spi_fw_power_on(hnd);
+                if (ret < 0) {
+                        wimax_osal_trace(PC2400M_GROUP_SPI_ERROR,
+                                         PC2400M_TRACE_INIT_ERR,
+                                         WIMAX_OSAL_TRACE_PRIORITY_ERROR);
+
+                        wimax_osal_sleep(PC2400M_DRV_SPI_POWERUP_DELAY);
+                        continue;
+                }
+
+                /* get the boot barker */
+                boot_barker = pc2400m_drv_spi_fw_get_boot_barker(hnd);
+                if (!boot_barker) {
+                        ret = -EGENERAL;
+                        wimax_osal_sleep(PC2400M_DRV_SPI_POWERUP_DELAY);
+                        continue;
+                }
+
+                wimax_osal_sleep(PC2400M_DRV_SPI_POWERUP_DELAY);
+
+                /* power on and hardware initialize the device again */
+                ret = pc2400m_drv_spi_fw_power_on(hnd);
+                if (ret < 0) {
+                        wimax_osal_trace(PC2400M_GROUP_SPI_ERROR,
+                                         PC2400M_TRACE_INIT_ERR,
+                                         WIMAX_OSAL_TRACE_PRIORITY_ERROR);
+                        wimax_osal_sleep(PC2400M_DRV_SPI_POWERUP_DELAY);
+                        continue;
+                }
+
+                /* attempt firmware download */
+                ret = pc2400m_drv_spi_fw_download(
+                        hnd, boot_barker, fw, fw_length);
+                if (ret < 0) {
+                        wimax_osal_trace_byte(
+                                PC2400M_GROUP_SPI_ERROR,
+                                PC2400M_TRACE_FW_DL_RETRY,
+                                WIMAX_OSAL_TRACE_PRIORITY_DEBUG, retries);
+                        wimax_osal_sleep(PC2400M_DRV_SPI_POWERUP_DELAY);
+                        continue;
+                }
+
+                /* the firmware download was a success */
+                break;
+        }
+
+        return ret;
+
+}
+
+/*****************************************************************************
+ * Exported functions
+ */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_spi_fw.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_spi_fw.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_spi_fw.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_spi_fw.h	2011-02-06 20:12:11.829999938 -0500
@@ -0,0 +1,61 @@
+/*
+ * pc2400m_drv_spi_fw.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         3       APPROVED 21-Feb-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_drv_spi_fw.h
+ *
+ * This file defines the functionalities for chipset initialization
+ * and firmware download.
+ *
+ */
+
+#ifndef PC2400M_DRV_SPI_FW_H
+#define PC2400M_DRV_SPI_FW_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/*****************************************************************************
+ * Data types
+ */
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/** this function powers on, initializes and downloads firmware to the chipset
+ */
+s32 pc2400m_drv_spi_fw_init(struct pc2400m_drv_hdi_if*, u8*, u32);
+
+#endif /* PC2400M_DRV_SPI_FW_H */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_spi.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_spi.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_spi.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_spi.h	2011-02-06 20:12:11.779999941 -0500
@@ -0,0 +1,83 @@
+/*
+ * pc2400_drv_spi.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         13      APPROVED 21-Feb-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_drv_spi.h
+ *
+ * This file declares the object representing the SPI hardware device interface
+ * for the common driver.
+ *
+ */
+
+#ifndef PC2400M_DRV_SPI_H
+#define PC2400M_DRV_SPI_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include "pc2400m_drv_com.h"
+#include "pc2400m_drv_hdi.h"
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/*****************************************************************************
+ * Data types
+ */
+
+struct pc2400m_drv_hdi_spi_if {
+
+        /* inherit HDI stuff */
+        struct pc2400m_drv_hdi_if hdi;
+
+        /* IRQ callback */
+        pc2400m_hdi_int_cb irq_cb;
+
+        /* SPI queue */
+        u32 rx_seq;
+        u32 tx_seq;
+        wimax_osal_packet_list rx_q;
+        wimax_osal_packet_list tx_q;
+        u32 tx_q_len;
+
+        /* blocks for handling SPI traffic */
+        u8 spi_cmd[PC2400M_DRV_SPI_CMD_SIZE];
+        u8 spi_resp[PC2400M_DRV_SPI_MAX_RESP_SIZE];
+
+        u8 spi_data[PC2400M_DRV_SPI_DATA_SIZE+2]; /* 2 = sizeof struct R_5 */
+
+};
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+#endif /* PC2400M_DRV_SPI_H */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_traces.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_traces.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_drv_traces.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_drv_traces.h	2011-02-06 20:12:12.459999939 -0500
@@ -0,0 +1,592 @@
+/*
+ * pc2400m_drv_sllist.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         13      APPROVED 15-Sep-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_drv_traces.h
+ *
+ * This file declares the trace identifiers used in the driver code.
+ *
+ */
+
+/* Intentionally left out:
+   #ifndef PC2400M_DRV_TRACES_H
+   #define PC2400M_DRV_TRACES_H
+*/
+
+/*****************************************************************************
+ * Include files
+ */
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+#ifndef PC2400M_TRACE_ENABLE
+#define PC2400M_TRACE_ENABLE ON
+#endif
+
+/** trace groups, and trace identifiers */
+RES_BEGIN(WIMAX_OSAL_AUTOGEN_RESOURCE_TRC_WIMAX, AUTOGEN_NO_RESOURCE_ID,
+           WIMAXDD, "WIMAX Driver Traces", "", FALSE )
+
+/** CHIPSET group */
+TRACE_GROUP_BEGIN(PC2400M_GROUP_CHIPSET, "Chipset", PC2400M_TRACE_ENABLE)
+        TRACE_BEGIN(PC2400M_TRACE_UNSOLICITED,
+                    "Unsolicited")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+TRACE_GROUP_END()
+
+/** SPI INFO group */
+TRACE_GROUP_BEGIN(PC2400M_GROUP_SPI_INFO, "SPI", PC2400M_TRACE_ENABLE)
+        TRACE_BEGIN(PC2400M_TRACE_FW_DL,
+                    "Firmware download")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+TRACE_GROUP_END()
+
+/** SPI DEBUG group */
+TRACE_GROUP_BEGIN(PC2400M_GROUP_SPI_DEBUG, "SPI", PC2400M_TRACE_ENABLE)
+        TRACE_BEGIN(PC2400M_TRACE_FW_BLOCK_ADDRESS,
+                    "Firmware block address")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_FW_BLOCK_SIZE,
+                    "Firmware block size")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_FW_CHIPSET_UNSECURE,
+                    "Chipset is unsecure")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+TRACE_GROUP_END()
+
+/** SPI ERROR group */
+TRACE_GROUP_BEGIN(PC2400M_GROUP_SPI_ERROR, "SPI", PC2400M_TRACE_ENABLE)
+        TRACE_BEGIN(PC2400M_TRACE_INIT_ERR,
+                    "Initialization failure")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_FW_DL_RETRY,
+                    "Retrying firmware download")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_FW_DL_FAIL,
+                    "Firmware download failed")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_FW_INVALID,
+                    "Firmware file invalid")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_FW_SETUP_FAILED,
+                    "Unsecure boot loader setup failed")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_FW_HASH_ONLY_FAILED,
+                    "Secure boot header hash only failed")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_FW_JUMP_FAILED,
+                    "Starting the firmware failed")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_FW_JUMPING,
+                    "Jumping to address")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_TX_CMD_FAIL,
+                    "Transmit command fail")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_RX_CMD_FAIL,
+                    "Receive command fail")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_NOT_FULL_BLOCKS,
+                    "Transmit not full blocks")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_OUT_OF_DATA,
+                    "Out of data in read")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CORRUPT_XFER_HDR,
+                    "Corrupt transfer header")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_RX_SYNC_LOST,
+                    "Rx sequence number mismatch")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_RX_EMPTY,
+                    "Rx empty transaction")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_DEVICE_REBOOT,
+                    "Device reboot detected")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CMD0_ERROR,
+                    "CMD0 response error")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CMD52_ERROR,
+                    "CMD52 response error")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_FAKE_IRQ,
+                    "Fake interrupt")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_UNSET_IRQ_FLAG,
+                    "Interrupt flag not set")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_TOO_LARGE_PACKET,
+                    "Packet too large, dropped")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_TEST_ERR,
+                    "Test error")
+               WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_UNSUPPORTED_FW_DL_METHOD,
+                    "Chipset does not support this download method")
+               WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+TRACE_GROUP_END()
+
+/** WIHAL DEBUG group */
+TRACE_GROUP_BEGIN(PC2400M_GROUP_WIHAL_DEBUG, "WIHAL", PC2400M_TRACE_ENABLE)
+        TRACE_BEGIN(PC2400M_TRACE_DRIVER_UNLOADED,
+                 "Device driver successfully unloaded")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_WIHAL_CTRL,
+                    "WiHAL control message")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+TRACE_GROUP_END()
+
+/** WIHAL ERROR group */
+TRACE_GROUP_BEGIN(PC2400M_GROUP_WIHAL_ERROR, "WiHAL", PC2400M_TRACE_ENABLE)
+        TRACE_BEGIN(PC2400M_TRACE_UNKNOWN_CMD,
+                    "Unknown command")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_DRIVER_INIT_FAIL,
+                    "Driver initialization failed")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_DROPPED_PACKET,
+                    "Recv buffer overflow")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_LINK_DOWN,
+                    "Link down, data dropped")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+TRACE_GROUP_END()
+
+/** EAP INFO group */
+TRACE_GROUP_BEGIN(PC2400M_GROUP_EAP_INFO, "EAP", PC2400M_TRACE_ENABLE)
+        TRACE_BEGIN(PC2400M_TRACE_MSK_SET,
+                    "EAP MSK set")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_ALT_ACCEPT_IGN,
+                    "EAP ALT ACCEPT ignored")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+TRACE_GROUP_END()
+
+/** EAP DEBUG group */
+TRACE_GROUP_BEGIN(PC2400M_GROUP_EAP_DEBUG, "EAP", PC2400M_TRACE_ENABLE)
+        TRACE_BEGIN(PC2400M_TRACE_MSK_RECVD,
+                    "EAP MSK received")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_EAP_REQ,
+                    "EAP request")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_EAP_RESP,
+                    "EAP response")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+TRACE_GROUP_END()
+
+/** EAP ERROR group */
+TRACE_GROUP_BEGIN(PC2400M_GROUP_EAP_ERROR, "EAP", PC2400M_TRACE_ENABLE)
+        TRACE_BEGIN(PC2400M_TRACE_MSK_NOT_RECVD,
+                    "EAP MSK not received in due time")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+TRACE_GROUP_END()
+
+/** CONTROL DISPATCHER ERROR group */
+TRACE_GROUP_BEGIN(PC2400M_GROUP_CD_ERROR, "CD", PC2400M_TRACE_ENABLE)
+        TRACE_BEGIN(PC2400M_TRACE_UNKNOWN_FRAME,
+                    "Unrecognized frame type")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_UNKNOWN_TYPE,
+                    "Discarded unknown indication")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_MSG_TIMEOUT,
+                    "Command response timeout")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_QUEUE_FAILED,
+                    "Failed to queue control message")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_PKT_DISCARDED,
+                    "No handler for incoming data")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_EXIT_IDLE_FAILED,
+                    "Failed to exit from IDLE")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+TRACE_GROUP_END()
+
+/** CONTROL DISPATCHER DEBUG group */
+TRACE_GROUP_BEGIN(PC2400M_GROUP_CD_DEBUG, "CD", PC2400M_TRACE_ENABLE)
+        TRACE_BEGIN(PC2400M_TRACE_D2H,
+                    "L4L3 D2H")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_H2D,
+                    "L4L3 H2D")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_REQUEST_POWER_SAVE,
+                    "Requesting interface power save")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_ENTERED_POWER_SAVE,
+                    "Entered interface power save")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_ENTERED_IDLE,
+                    "Entered IDLE mode")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_EXITED_IDLE,
+                    "Exited IDLE mode")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_IDLE_MODE_EXIT,
+                    "Starting idle mode exit")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_POWER_SAVE_EXIT,
+                    "Starting power save exit")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+TRACE_GROUP_END()
+
+/** DEVICE MANAGER INFO group */
+TRACE_GROUP_BEGIN(PC2400M_GROUP_DM_INFO, "DM", PC2400M_TRACE_ENABLE)
+        TRACE_BEGIN(PC2400M_TRACE_CHIP_ASIC_VER,
+                    "Hardware")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CHIP_BOARD_VER,
+                    "RF")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CHIP_FW_VER,
+                    "Firmware")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CHIP_L1_VER,
+                    "L1")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CHIP_L2_VER,
+                    "L2")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CHIP_L3_VER,
+                    "L3")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CHIP_MAC_ADDR,
+                    "MAC Address")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_LINK_STATE,
+                    "Link status")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CHANNEL_PLANS_TRUNCATED,
+                    "Truncated number of channel plans")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+TRACE_GROUP_END()
+
+/** DEVICE MANAGER DEBUG group */
+TRACE_GROUP_BEGIN(PC2400M_GROUP_DM_DEBUG, "DM", PC2400M_TRACE_ENABLE)
+        TRACE_BEGIN(PC2400M_TRACE_RF_CONTROL_RADIO_ON,
+                    "RF control radio enabled")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_RF_CONTROL_RADIO_OFF,
+                    "RF control radio disabled")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_START_SCAN,
+                    "Scanning started")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_STOP_SCAN,
+                    "Scanning stopped")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CONNECTING,
+                    "Connecting started")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_TRANSITION_START,
+                    "Starting transition")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CHIP_ST_CH_REASON,
+                    "State change reason")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CHIP_ST_CH_STATE,
+                    "State change state")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CHIP_L4M_VERSION,
+                    "Reported L4M version")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_DM_STATE_CHANGE,
+                    "DM State change")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_DM_BS_CRITERIA,
+                    "DM BS ID criteria")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_DM_BS_CRITERIA_MASK,
+                    "DM BS ID criteria mask")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CHIP_CONNECT_PROG,
+                    "Chipset connection progress")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_BG_OPERATION_CANCELED,
+                    "BG Transition canceled")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_BG_OPERATION_STARTED,
+                    "BG Transition started")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_BG_OPERATION_COMPLETE,
+                    "BG Transition complete")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_BG_CONNECT_PARAMS,
+                    "BG Connect setting channel plan")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_BG_CONNECT_START,
+                    "BG Connect starting connect")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_BG_SCAN_NSP_PARAMS,
+                    "BG NSP scan setting channel plan")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_BG_SCAN_NSP_START,
+                    "BG NSP scan starting connect")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_BG_RECEIVED_REALM,
+                    "BG Connect received realm info")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_BG_RECEIVED_NSPID_LIST,
+                    "BG Scan NSP received NSP ID list")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_BG_RECEIVED_NSPNAME_LIST,
+                    "BG Scan NSP received NSP verbose name list")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_BG_RECEIVED_NSPNAME,
+                    "BG Scan NSP received NSP verbose name")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_BG_RECEIVED_NSP_CHANGE_COUNT,
+                    "BG Scan NSP received NSP change count")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_BG_DISCONNECT_START,
+                    "BG Disconnect starting disconnect")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_BG_SCAN_START,
+                    "BG Scan starting scan")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_BG_SCAN_PARAMS,
+                    "BG Scan setting channel plan")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_BG_SCAN_IGNORING_RESULT,
+                    "BG Scan ignoring result due to state")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_NVM_IMAGE_FORMAT_VERSION,
+                    "NVM image format version")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_NVM_IMAGE_VERSION,
+                    "NVM image content version")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+TRACE_GROUP_END()
+
+/** DEVICE MANAGER ERROR group */
+TRACE_GROUP_BEGIN(PC2400M_GROUP_DM_ERROR, "DM", PC2400M_TRACE_ENABLE)
+        TRACE_BEGIN(PC2400M_TRACE_REQUEST_FAILED,
+                    "Request failed with status")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_INVALID_DM_STATE,
+                    "Invalid state for transition")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CHIP_UNEXP_END_STATE,
+                    "Unexpected end state for transition")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CHIP_UNEXP_RESP,
+                    "Unexpected command response")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CHIP_UNEXP_STATE_IND,
+                    "Unexpected chipset state change")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CHIP_TRANS_TOUT,
+                    "Transition timed out")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CHIP_EXP_TLV_MISSING,
+                    "Expected TLV missing")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_UNKNOWN_SCAN_STATUS,
+                    "Unknown scan status received")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_EXCEEDED_SEARCH_LIMIT,
+                    "Channel plan split into multiple parts")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_UNKNOWN_STATUS_IN_INIT,
+                    "Unknown status while initializing")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_UNKNOWN_STATUS_IN_TERMINATE,
+                    "Unknown status while terminating")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_UNABLE_TO_INITIALIZE,
+                    "Chip initialization failure")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CANNOT_GO_PRODUCTION,
+                    "Cannot switch to production mode")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_HW_RF_SWITCH_OFF,
+                    "HW RF Switch off")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_VERSION_NOTE,
+                    "Firmware note")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_UNSUPPORTED_VERSION,
+                    "Unsupported firmware interface")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_DISCONNECT_FAULT_CODE,
+                    "Disconnect request returned fault code")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CHANNEL_PLAN_SET_FAULT,
+                    "Failure setting channel plan")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CHANNEL_PLAN_SCAN_FAULT,
+                    "Failure scanning channel plan")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_SCAN_START_FAILURE,
+                    "Failure starting scan")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_CONNECT_START_FAILURE,
+                    "Failure starting connect")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+        TRACE_BEGIN(PC2400M_TRACE_BG_MISSING_REALM,
+                    "SII Report is missing realm")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+/* PC2400M_DRV_DM_LOCK_SESSION_BANDWIDTH => */
+        TRACE_BEGIN(PC2400M_TRACE_BG_MIXED_BANDWIDTH,
+                    "Mixed bandwidths used during one session")
+                WIMAX_OSAL_AUTOGEN_TRACE_INFO
+        TRACE_END()
+/* <= PC2400M_DRV_DM_LOCK_SESSION_BANDWIDTH */
+TRACE_GROUP_END()
+
+RES_END
+
+/*****************************************************************************
+ * Data types
+ */
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_i2c.c maemo_src/drivers/net/wireless/pc2400m/pc2400m_i2c.c
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_i2c.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_i2c.c	2011-02-06 20:12:11.899999940 -0500
@@ -0,0 +1,273 @@
+/*
+ * pc2400m_spi.c
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         5       APPROVED 19-May-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_i2c.c
+ *
+ * This file controls the I2C controlled step down converter on the power
+ * supply of the pc2400m chipset.
+ *
+ */
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+
+#include <linux/i2c.h>
+
+#include "pc2400m_com.h"
+
+/*****************************************************************************
+ * Global constants and macros
+ */
+
+/* I2C address of the TPS62352 step down converter */
+#define PC2400M_I2C_TPS62352 0x94 /* 10010100 */
+
+/*****************************************************************************
+ * Global data types
+ */
+
+/** I2C client structure for the instance */
+static struct i2c_client *pc2400m_i2c_client = NULL;
+
+/** variable tracking driver installation */
+static int pc2400m_i2c_driver_added = 0;
+
+/** an array holding the supported addresses for the step down converter */
+static unsigned short normal_i2c[] = {
+        PC2400M_I2C_TPS62352 >> 1,
+        I2C_CLIENT_END,
+};
+
+/** an array holding bus numbers to ignore during probing */
+static unsigned short ignore_i2c[] = {
+        1,
+        PC2400M_I2C_TPS62352 >> 1,
+        I2C_CLIENT_END,
+        I2C_CLIENT_END,
+};
+
+/** empty address list array */
+static unsigned short ignore = I2C_CLIENT_END;
+
+/** structure defining I2C address information of the step down converter */
+static struct i2c_client_address_data addr_data = {
+        .normal_i2c             = normal_i2c,
+        .probe                  = &ignore,
+        .ignore                 = ignore_i2c,
+};
+
+static int pc2400m_i2c_attach_adapter(struct i2c_adapter*);
+static int pc2400m_i2c_detach_client(struct i2c_client*);
+
+/** structure defining I2C driver functions */
+static struct i2c_driver pc2400m_i2c_driver = {
+        .driver = {
+                .name = "pc2400m-i2c",
+        },
+
+        .id = 0,
+
+        .attach_adapter = pc2400m_i2c_attach_adapter,
+        .detach_client = pc2400m_i2c_detach_client,
+        .command = NULL,
+};
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/*****************************************************************************
+ * Local functions
+ */
+
+/** Probe the I2C device found on a bus on the specified address. This
+ *  function will perform a test communication with the device a mark the
+ *  step down converter as usable.
+ *
+ *  @return 0 on success, -ENOMEM on memory outage, -ENODEV if the
+ *          addressed device does not exist after all
+ */
+static int pc2400m_i2c_probe_device(
+        struct i2c_adapter *adapter,
+        int address,
+        int kind)
+{
+
+        struct i2c_client *client = NULL;
+        int ret = 0;
+
+        PC2400M_UNWARN(kind);
+
+        client = kzalloc(sizeof(struct i2c_client), GFP_KERNEL);
+        if (!client)
+                goto err1;
+
+        client->addr = address;
+        client->adapter = adapter;
+        client->driver = &pc2400m_i2c_driver;
+
+        strlcpy(client->name, "pc2400m-i2c", I2C_NAME_SIZE);
+
+        ret = i2c_attach_client(client);
+        if (ret)
+                goto err2;
+
+        DEBUG("Registered I2C step down converter TPS62352 on "
+              "address %2.2x\n", PC2400M_I2C_TPS62352);
+
+        goto out;
+
+ err2:
+        kfree(client);
+        client = NULL;
+
+ err1:
+        ret = -ENOMEM;
+
+ out:
+        pc2400m_i2c_client = client;
+        return ret;
+
+}
+
+/** Attach this I2C driver to an adapter and a device.
+ *
+ *  @return 0 on success, -ENOMEM on memory outage, -ENODEV if the
+ *          addressed device does not exist after all
+ */
+static int pc2400m_i2c_attach_adapter(struct i2c_adapter *adapter)
+{
+
+        return i2c_probe(
+                adapter,
+                &addr_data,
+                pc2400m_i2c_probe_device);
+
+
+}
+
+/** Remove this I2C driver from and adapter and device.
+ *
+ *  @return 0 on success, -ENOMEM on memory outage, -ENODEV if the
+ *          addressed device does not exist after all
+ */
+static int pc2400m_i2c_detach_client(struct i2c_client *client)
+{
+
+        int ret = i2c_detach_client(client);
+        kfree(client);
+
+        BUG_ON(client != pc2400m_i2c_client);
+        pc2400m_i2c_client = NULL;
+
+        return ret;
+
+}
+
+/*****************************************************************************
+ * Exported functions
+ */
+
+/** Configure the TPS62352 to output 1.8 volts, if the device has been
+ *  successfully detected. Otherwise do nothing.
+ *
+ *  @return always returns 0
+ */
+int pc2400m_i2c_set_1_8_volts(void)
+{
+
+#define PC2400M_I2C_TPS62352_VSEL0_REG 0
+#define PC2400M_I2C_TPS62352_VSEL0_VAL 228 /* 11100100 = 1.8V */
+
+        if (pc2400m_i2c_client) {
+
+                i2c_smbus_write_byte_data(
+                        pc2400m_i2c_client,
+                        PC2400M_I2C_TPS62352_VSEL0_REG,
+                        PC2400M_I2C_TPS62352_VSEL0_VAL);
+
+        } else {
+
+                DEBUG("TPS62352 step down converter control disabled.\n");
+
+        }
+
+        return 0;
+
+}
+
+/** Initialize the I2C driver and step down converter device.
+ *
+ *  @return 0 on success, -ENOMEM on memory outage, -ENODEV if the
+ *          addressed device does not exist after all
+ */
+int pc2400m_i2c_init(void)
+{
+
+        int ret = 0;
+
+
+        if (!pc2400m_i2c_driver_added) {
+
+                BUG_ON(pc2400m_i2c_client != NULL);
+                ret = i2c_add_driver(&pc2400m_i2c_driver);
+
+                /* if the ret value is 0, then the driver is added,
+                   otherwise not */
+                pc2400m_i2c_driver_added = !ret;
+        }
+
+        return ret;
+
+}
+
+/** Finalize the I2C driver and step down converter device.
+ *
+ *  @return 0 on success, -ENOMEM on memory outage, -ENODEV if the
+ *          addressed device does not exist after all
+ */
+int pc2400m_i2c_exit(void)
+{
+
+        int ret = 0;
+
+        if (pc2400m_i2c_driver_added) {
+                ret = i2c_del_driver(&pc2400m_i2c_driver);
+                pc2400m_i2c_driver_added = 0;
+        }
+        BUG_ON(pc2400m_i2c_client != NULL);
+        return ret;
+
+}
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_i2c.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_i2c.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_i2c.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_i2c.h	2011-02-06 20:12:11.613333272 -0500
@@ -0,0 +1,61 @@
+/*
+ * pc2400m_spi.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         1       APPROVED 17-Mar-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_i2c.h
+ *
+ * This file declares the I2C step down converter driver module.
+ *
+ */
+
+#ifndef PC2400M_I2C_H
+#define PC2400M_I2C_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/*****************************************************************************
+ * Data types
+ */
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+int pc2400m_i2c_set_1_8_volts(void);
+
+int pc2400m_i2c_init(void);
+int pc2400m_i2c_exit(void);
+
+#endif /* PC2400M_I2C_H */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_if.c maemo_src/drivers/net/wireless/pc2400m/pc2400m_if.c
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_if.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_if.c	2011-02-06 20:12:12.346666605 -0500
@@ -0,0 +1,1498 @@
+/*
+ * pc2400m_if.c
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Jouni Lappi <jouni.lappi@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         98      APPROVED 09-Sep-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_if.c
+ *
+ * Networking if functions for WiMAX driver
+ *
+ */
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/firmware.h>
+#include <linux/completion.h>
+#include <linux/platform_device.h>
+#include <linux/wireless.h>
+#include <net/iw_handler.h>
+#include <asm/arch/pm.h>
+
+#include "pc2400m_com.h"
+#include "pc2400m_if.h"
+#include "pc2400m_al.h"
+#include "pc2400m_drv_if.h"
+#include "pc2400m_if_we.h"
+#include "pc2400m_if_sysfs.h"
+#include "pc2400m_if_netlink.h"
+#include "pc2400m_conf.h"
+#include "pc2400m_release.h"
+
+/*****************************************************************************
+ * Global constants and macros
+ */
+
+/* TX lock flags */
+#define PC2400M_IF_SL_OFF                          0x00
+#define PC2400M_IF_SL_ON_FLAG                      0x02
+/** definition for zero */
+#define PC2400M_IF_IDX_ZR                          0
+/** Set for closing variable */
+#define WIMAX_WCO_SET 1
+
+/*****************************************************************************
+ * Global data types
+ */
+
+/** Driver handle */
+struct t_wihal_driver_if *pc2400m_driver_if = NULL;
+/** Event if struct */
+static struct t_wihal_event_if pc2400m_eif;
+/** SPI adaptaion struct */
+extern struct t_wihal_adaptation_if pc2400m_spi_wihal_adapt;
+
+/** externalization of the wireless extensions structure */
+extern const struct iw_handler_def  pc2400m_we_handler_def;
+/* Netlink sockets */
+extern struct sock *pc2400m_nl_sk1;
+extern struct sock *pc2400m_nl_sk2;
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/** Interface open function */
+static int pc2400m_if_open(struct net_device *dev);
+
+/** Interface stop function */
+static int pc2400m_if_stop(struct net_device *dev);
+
+/** TX function */
+static int pc2400m_if_xmit(struct sk_buff *skb, struct net_device *dev);
+
+/** Device statistics function */
+static struct net_device_stats *pc2400m_if_get_stats(struct net_device *dev);
+
+/** This function resets all network connection parameters */
+static void pc2400m_if_reset_nl_params(struct net_local *nl);
+
+
+
+/*****************************************************************************
+ * Local functions
+ */
+
+/** This function sends an interface down indication to the
+ *  diagnostics netlink socket.
+ *
+ *  @param ndev pointer to the associated net device structure
+ *  @return none
+ */
+static void pc2400m_if_send_diag_if_down(struct net_device *ndev) {
+
+        struct sk_buff *skb;
+        struct netlink_pipe_msg_str *pipehdr;
+
+        if (pc2400m_nl_sk2 && pc2400m_netlink_trace_pipe_ready(ndev)) {
+
+                /* create netlink message buffer */
+                skb = wimax_osal_packet_alloc(
+                        sizeof(struct netlink_pipe_msg_str));
+
+                /* insert multiplex header */
+                pipehdr = (struct netlink_pipe_msg_str*)
+                        skb_put(skb, sizeof(struct netlink_pipe_msg_str));
+                pipehdr->type = PC2400M_IF_NETLINK_PIPE_TYPE_IF_DOWN;
+                pipehdr->length = skb->len;
+                pipehdr->version = PC2400M_IF_NETLINK_PIPE_VERSION;
+
+                pc2400m_netlink_send_data(
+                        ndev, skb, PC2400M_IF_NETLINK_PC2400M2);
+        }
+
+}
+
+/** This function resets scan results.
+ *
+ *  @param nl devices local struct
+ *  @return none
+ */
+static void pc2400m_if_reset_scan_results(struct net_local *nl)
+{
+        NL_PROT_ON;
+        /* empty scan buffer */
+        nl->event_stream_len = 0;
+        kfree(nl->event_stream);
+        nl->event_stream = NULL;
+        NL_PROT_OFF;
+
+        return ;
+}
+
+/** Driver is stopped on failure.
+ *  Called by us to disable network interface.
+ *
+ * @param dev pointer to network device
+ * @return always 0
+ */
+static int pc2400m_if_stop_on_failure(struct net_device *dev)
+{
+        struct t_wihal_cmd cmd;
+        struct net_local *nl = netdev_priv(dev);
+
+        if (nl->if_status == PC2400M_IF_UNINITIALIZED)
+                goto out;
+        if (nl->wimax_closing_ongoing)
+                goto out;
+        nl->if_status = PC2400M_IF_UNINITIALIZED;
+
+        /* release resources, such as memory areas */
+        nl->wimax_closing_ongoing = WIMAX_WCO_SET;
+
+        DEBUG("WiHAL Closed due to chip reset!\n");
+        cmd.cmd_id = E_WIHAL_CLOSE;
+        WIMAX_NO_LOCK_CMD(dev, &cmd);
+
+        /* stop the transmit queue (device can no longer transmit data)*/
+        netif_stop_queue(dev);
+
+        pc2400m_if_reset_nl_params(nl);
+
+        pc2400m_if_reset_scan_results(nl);
+
+        nl->radio_disabled = PC2400M_WMX_RADIO_OFF;
+
+        /* send diagnostics notification of the closing interface */
+        pc2400m_if_send_diag_if_down(dev);
+        pc2400m_netlink_close();
+out:
+        return 0;
+
+}
+
+/** This function resets all serving basestation parameters.
+ *
+ *  @param nl devices local struct
+ *  @return none
+ */
+static void pc2400m_if_reset_network_params(struct net_local *nl)
+{
+
+        NL_PROT_ON;
+        nl->cinr = 0;
+        nl->level = 0;
+        kfree(nl->channel_plan);
+        nl->channel_plan = NULL;
+        memset(nl->bsid, 0x00, 6);
+        NL_PROT_OFF;
+
+        return;
+}
+
+/** This function resets all network connection parameters.
+ *
+ *  @param nl devices local struct
+ *  @return none
+ */
+static void pc2400m_if_reset_nl_params(struct net_local *nl)
+{
+        u32 i;
+
+        NL_PROT_ON;
+
+        nl->tx_buff = NULL;
+        nl->tx_flags = 0;
+        nl->nap = PC2400M_IF_NO_NAP;
+        kfree(nl->p_nsp_realm);
+        nl->p_nsp_realm = NULL;
+        nl->nsp_realm_len = 0;
+        nl->errcod = we_wmx_no_error;
+        nl->tx_buff_len = 0;
+
+        if (nl->nsp_rsp) {
+                if (nl->nsp_rsp->p_nsp) {
+                        for(i=0; i < nl->nsp_rsp->nsp_count; i++)
+                                kfree(nl->nsp_rsp->p_nsp[i].p_nsp_name);
+                        kfree(nl->nsp_rsp->p_nsp);
+                }
+                kfree(nl->nsp_rsp);
+                nl->nsp_rsp = NULL;
+        }
+
+        kfree(nl->channel_plan);
+        nl->channel_plan = NULL;
+
+        NL_PROT_OFF;
+
+        pc2400m_if_reset_network_params(nl);
+
+        return ;
+}
+
+/** This is for error mapping/setting in WiHAL cmd responses.
+ *
+ *  @param cmd_status error status
+ *  @param nl devices local struct
+ *  @return none
+ */
+static void pc2400m_if_set_errcod(
+        enum t_wihal_status cmd_status,
+        struct net_local *nl)
+{
+        NL_PROT_ON;
+        switch (cmd_status){
+        case E_WIHAL_SUCCESS:
+                nl->errcod = we_wmx_no_error;
+                break;
+        case E_WIHAL_ERR_FAILURE:
+                nl->errcod = we_wmx_unspecified_error;
+                break;
+        case E_WIHAL_ERR_INVALID_STATE:
+                nl->errcod = we_wmx_device_in_invalid_state;
+                break;
+        default:
+                BUG_ON(cmd_status != E_WIHAL_ERR_INVALID_VALUE);
+                nl->errcod = we_wmx_invalid_input_value;
+                break;
+
+        }
+        NL_PROT_OFF;
+}
+
+/** Writes firmware to device.
+ *  kernel's sysfs provides firmware to write to device.
+ *
+ *  @param ndev pointer to network device
+ *  @param fw_id pointer to firmware filename
+ *  @param dev pointer to device
+ *  @return 0 success, -EIO if firmware loading fails
+ */
+static int pc2400m_if_fetch_firmware(struct net_device *ndev,
+                                     char *fw_id,
+                                     struct device *dev)
+{
+        const struct firmware *fw_entry = NULL;
+        struct net_local *nl = netdev_priv(ndev);
+        struct t_wihal_cmd cmd;
+        struct t_wihal_fw_data_block fwblock;
+        int ret = 0;
+        WIMAX_WAIT_RSP;
+
+        omap2_block_sleep();
+
+        ret = request_firmware(&fw_entry, fw_id, dev);
+
+        if (ret) {
+                ERROR("WiMAX firmware loading failed (err: %d) "
+                        "for '%s' \n", ret, fw_id);
+        } else {
+                cmd.cmd_id = E_WIHAL_INITIALIZE;
+#define PC2400M_IF_FW_BLK_CNT 1
+                cmd.cmd.initialize.block_count = PC2400M_IF_FW_BLK_CNT;
+                cmd.cmd.initialize.p_blocks = &fwblock;
+                cmd.cmd.initialize.p_blocks->length = fw_entry->size;
+                cmd.cmd.initialize.p_blocks->ptr = fw_entry->data;
+
+                WIMAX_WAIT_CMD(ndev, &cmd);
+
+                if (nl->if_status == PC2400M_IF_INIT_DONE)
+                        ret = 0;
+                else
+                        ret = -EIO;
+
+                release_firmware(fw_entry);
+        }
+
+        omap2_allow_sleep();
+
+        return ret;
+}
+
+/** Scheduled function to send data to device.
+ *
+ *  @param work pointer to work structure containing
+ *        -device and data
+ *  @return none
+ */
+static void pc2400m_tx(struct work_struct *work)
+{
+        struct net_local *nl = container_of(work, struct net_local, tx_work);
+        struct net_device_stats *stats = &(nl->stats);
+        struct t_wihal_cmd cmd;
+        u16 skb_protocol;
+        unsigned long flags;
+        struct sk_buff *skb;
+        struct sk_buff *skbcopy;
+        wimax_osal_packet_list *list = &(cmd.cmd.data_send.p_data);
+        boolean wake = TRUE;
+
+        wimax_osal_packet_list_initialize(list);
+        /* process the tx queue within the limits of the credit */
+        spin_lock_irqsave(&(nl->tx_lock), flags);
+        while(nl->tx_buff &&
+              (nl->tx_credit || nl->if_status != PC2400M_IF_CONNECTED)) {
+                skb = nl->tx_buff;
+                nl->tx_buff = nl->tx_buff->next;
+                nl->tx_buff_len --;
+                skb->next = skb->prev = NULL;
+                spin_unlock_irqrestore(&(nl->tx_lock), flags);
+
+                skb_protocol = cpu_to_be16(skb->protocol);
+
+                /* check the header for EAP packets */
+                if(skb_protocol == PC2400M_CONF_ETH_P_EAP) {
+
+                        /* eap packets will be delivered immediately */
+                        DEBUG("EAP packet from socket\n");
+                        skb_pull(skb,ETH_HLEN);
+                        cmd.cmd_id = E_WIHAL_EAP_DATA;
+                        cmd.cmd.eap_data.p_payload = skb;
+                        WIMAX_NO_WAIT_CMD(nl->net_dev, &cmd);
+
+                } else {
+                        if (nl->tx_credit) {
+
+                                /* if there are other references to the skb,
+                                   its content must not be modified => a new
+                                   copy is required. This especially happens
+                                   with tcpdump */
+                                if (skb_cloned(skb)) {
+                                        skbcopy = skb_copy(skb, __GFP_NOFAIL);
+                                        kfree_skb(skb);
+                                        skb = skbcopy;
+                                }
+
+                                /* IP packets will be aggregated into an array
+                                   and sent in one hump */
+                                skb_pull(skb, ETH_HLEN);
+                                wimax_osal_packet_list_append(list, skb);
+
+                                stats->tx_packets++;
+                                stats->tx_bytes += skb->len;
+
+                                /* remove the sent amount of packets from the
+                                        credit */
+                                nl->tx_credit -= 1;
+                        } else {
+                                kfree_skb(skb);
+                        }
+                }
+                spin_lock_irqsave(&(nl->tx_lock), flags);
+        }
+        nl->tx_flags &= ~(PC2400M_IF_SL_ON_FLAG);
+
+        /* if the send buffer is empty wake up the kernel queue */
+        if (nl->tx_buff_len == 0)
+                wake = FALSE;
+
+        spin_unlock_irqrestore(&(nl->tx_lock), flags);
+
+        if (wake)
+                netif_wake_queue(nl->net_dev);
+        if (wimax_osal_packet_list_len(list)) {
+                cmd.cmd_id = E_WIHAL_DATA_SEND;
+                cmd.cmd.data_send.data_count =
+                        wimax_osal_packet_list_len(list);
+
+                WIMAX_NO_WAIT_CMD(nl->net_dev, &cmd);
+        }
+
+        wimax_osal_packet_list_release(list, FALSE);
+
+        return;
+}
+
+/** Schedules pc2400m_tx to send data to device.
+ *
+ *  @param skb pointer to data to send
+ *  @param dev pointer to net device
+ *  @return always 0
+ */
+static int pc2400m_if_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+
+        struct net_local *nl = netdev_priv(dev);
+        unsigned long flags;
+        int schedule = 1;
+
+        spin_lock_irqsave(&(nl->tx_lock), flags);
+
+        nl->tx_buff_len ++;
+
+        if (!nl->tx_buff) {
+                nl->tx_buff = skb;
+                nl->tx_last_buff = nl->tx_buff;
+        } else {
+                nl->tx_last_buff->next = skb;
+                nl->tx_last_buff = nl->tx_last_buff->next;
+        }
+
+        /* this will work on the assumption that there is no actual data
+           transfer while EAP negotiations are performed - otherwise the
+           data transfer could block the EAP negotiations. */
+
+        /* only schedule transmission if none is currently scheduled AND
+           there is credit left. This might block milliseconds */
+
+        if ((nl->tx_flags & PC2400M_IF_SL_ON_FLAG) ||
+            (nl->tx_credit == 0 && nl->if_status == PC2400M_IF_CONNECTED))
+                schedule = PC2400M_IF_SL_OFF;
+        else
+                nl->tx_flags |= PC2400M_IF_SL_ON_FLAG;
+
+        if ((nl->tx_buff_len > PC2400M_CONF_TX_BUF_TOO_HIGH) &&
+            (nl->if_status == PC2400M_IF_CONNECTED)) {
+                netif_stop_queue(dev);
+        }
+        spin_unlock_irqrestore(&(nl->tx_lock), flags);
+
+        if (schedule) {
+                queue_work(nl->wq,&nl->tx_work);
+        }
+
+        return 0;
+
+}
+
+/** Returns net devices statistics.
+ *  Statistics are updated if we are connected
+ *
+ *  @param dev pointer to net device
+ *  @return net device statistics struct
+ */
+static struct net_device_stats *pc2400m_if_get_stats(struct net_device *dev)
+{
+
+        struct net_local *nl = netdev_priv(dev);
+        struct t_wihal_cmd cmd;
+        WIMAX_WAIT_RSP;
+
+        /* update the data only if the driver has been connected */
+        if (nl->if_status == PC2400M_IF_CONNECTED) {
+                cmd.cmd_id = E_WIHAL_NETWORK_STATUS;
+                WIMAX_WAIT_CMD(nl->net_dev, &cmd);
+        }
+
+        /* the net device stats are in the local data */
+        return &(nl->stats);
+
+}
+
+/** Receive a response from the WiMAX driver.
+ *  This is a direct result of issuing the driver a command.
+ *  Do not lock inside this because lock is already used downstrairs.
+ *
+ *  @param ndev pointer to network device
+ *  @param resp pointer containing response type and parameters
+ *  @param complete pointer data given in cmd
+ *  @return none
+ */
+static void pc2400m_if_resp(
+        struct net_device *ndev,
+        struct t_wihal_resp *resp,
+        void *pc2400m_complete)
+{
+
+        struct net_local *nl = netdev_priv(ndev);
+        struct net_device_stats *stats = &(nl->stats);
+        struct sk_buff *skb;
+        struct sk_buff *nlskb;
+        struct ethhdr *eth;
+        struct pc2400m_complete_struct *bes;
+        int err = 0;
+        u32 i;
+        unsigned long flags;
+        int schedule = 1;
+
+        pc2400m_if_set_errcod(resp->cmd_status,nl);
+
+        if (resp->cmd_status == E_WIHAL_SUCCESS) {
+                switch (resp->cmd_resp_id) {
+
+                case E_WIHAL_INITIALIZE_RESP:
+                        /* firmware and init done */
+                        BUG_ON(!(nl->if_status == PC2400M_IF_UNINITIALIZED));
+                        nl->if_status = PC2400M_IF_INIT_DONE;
+                        break;
+
+                case E_WIHAL_DATA_SEND_RESP:
+
+                        spin_lock_irqsave(&(nl->tx_lock), flags);
+
+                        /* the response indicates full credit */
+                        nl->tx_credit = WIHAL_DATA_SEND_CREDIT_LEN;
+
+                        /* determine if a new transfer should be scheduled */
+                        if ((nl->tx_flags & PC2400M_IF_SL_ON_FLAG) ||
+                                (nl->tx_buff == NULL)) {
+                                schedule = 0;
+                        } else {
+                                nl->tx_flags |= PC2400M_IF_SL_ON_FLAG;
+                        }
+
+                        spin_unlock_irqrestore(&(nl->tx_lock), flags);
+
+                        if (schedule) {
+
+                                queue_work(nl->wq,&nl->tx_work);
+                        }
+                        break;
+
+                case E_WIHAL_DATA_RECEIVE_RESP:
+
+                        while ((skb =
+                                wimax_osal_packet_list_pop(
+                                &(resp->resp.data_receive.p_data))),skb) {
+
+                                BUG_ON(!skb);
+                                skb->dev = ndev;
+                                skb->ip_summed = CHECKSUM_UNNECESSARY;
+                                skb->h.raw = skb->nh.raw = skb->data;
+
+                                eth = (struct ethhdr *) skb_push(skb,ETH_HLEN);
+                                eth->h_proto = cpu_to_be16(ETH_P_IP);
+                                memcpy(eth->h_dest, ndev->dev_addr, ETH_ALEN);
+                                memcpy(eth->h_source,
+                                        ndev->dev_addr,ETH_ALEN);
+                                eth->h_source[ETH_ALEN - 1] ^= 0x01;
+
+                                skb->protocol = eth_type_trans(skb,ndev);
+
+
+
+                                err = netif_rx(skb);
+
+                                stats->rx_packets++;
+                                stats->rx_bytes += skb->len;
+                        }
+                        break;
+
+                case E_WIHAL_CONFIGURE_RESP:
+
+                        /* the capability info will not be valid if an error
+                           occurred */
+
+                        /* copy and output the capability info */
+                        DEBUG("fw vrs:%s\n",
+                                resp->resp.configure.capabilities.p_fw_version);
+                        DEBUG("hw vrs:%s\n",
+                                resp->resp.configure.capabilities.p_hw_version);
+
+                        DEBUG("Mac address:%02x:%02x:%02x:%02x:%02x:%02x\n",
+                                resp->resp.configure.
+                                        capabilities.mac_address[0],
+                                resp->resp.configure.
+                                        capabilities.mac_address[1],
+                                resp->resp.configure.
+                                        capabilities.mac_address[2],
+                                resp->resp.configure.
+                                        capabilities.mac_address[3],
+                                resp->resp.configure.
+                                        capabilities.mac_address[4],
+                                resp->resp.configure.
+                                        capabilities.mac_address[5]);
+
+#if (WIHAL_VERSION_STR_LEN > PC2400M_CONF_HW_FW_VERSION_STR_LEN)
+#error FW version string length not matching
+#endif
+                        strcpy(nl->fw_vrs,
+                               (char *)
+                               resp->resp.configure.capabilities.p_fw_version);
+
+#if (WIHAL_VERSION_STR_LEN > PC2400M_CONF_HW_FW_VERSION_STR_LEN)
+#error HW version string length not matching
+#endif
+                        strcpy(nl->hw_vrs,
+                               (char *)
+                               resp->resp.configure.capabilities.p_hw_version);
+
+#if (WIHAL_SERIAL_NBR_STR_LEN > PC2400M_CONF_SERIAL_NBR_STR_LEN)
+#error Serial NUmber string length not matching
+#endif
+                        strcpy(nl->serial_nbr,
+                               (char *)
+                               resp->
+                               resp.configure.capabilities.p_serial_number);
+
+#if (WIHAL_MODEL_STR_LEN > PC2400M_CONF_MODEL_STR_LEN)
+#error Model name string length not matching
+#endif
+                        strcpy(nl->model_vrs,
+                               (char *)
+                               resp->resp.configure.capabilities.p_model_name);
+
+#if (WIHAL_MODEL_STR_LEN > PC2400M_CONF_MANUFACTURER_STR_LEN)
+#error Manufacturer name string length not matching
+#endif
+                        strcpy(nl->manufacturer_vrs,
+                               (char *)
+                               resp->resp.configure.
+                               capabilities.p_manufacturer_name);
+
+                        /* set release version */
+                        strncpy(nl->release_vrs,
+                                RELEASE_VAL,
+                                PC2400M_CONF_RELEASE_STR_LEN);
+                        nl->release_vrs[PC2400M_CONF_RELEASE_STR_LEN - 1] =
+                                '\0';
+                        /* set mac to device */
+
+                        memcpy(ndev->dev_addr,
+                                resp->resp.configure.capabilities.mac_address,
+                                ETH_ALEN);
+
+                        break;
+
+                case E_WIHAL_SEARCH_NAP_RESP:
+                        /* search completed
+                           send wireless event for this in we */
+                        pc2400m_send_simple_event(ndev, WE_WMX_SCAN_COMPLETED);
+                        break;
+
+                case E_WIHAL_SEARCH_NSP_RESP:
+                        /* search completed
+                           send wireless event for this in we */
+                        NL_PROT_ON;
+                        if(nl->nsp_rsp) {
+                                DEBUG("freeing old nsp search results\n");
+
+                                if (nl->nsp_rsp->p_nsp) {
+                                        for(
+                                                i=0;
+                                                i < nl->nsp_rsp->nsp_count;
+                                                i++)
+                                        kfree(
+                                        nl->nsp_rsp->p_nsp[i].p_nsp_name);
+                                        kfree(nl->nsp_rsp->p_nsp);
+                                }
+                                kfree(nl->nsp_rsp);
+                                nl->nsp_rsp = NULL;
+
+                        }
+                        NL_PROT_OFF;
+                        if (resp->cmd_status != E_WIHAL_SUCCESS){
+                                pc2400m_send_simple_event(
+                                        ndev,
+                                        WE_WMX_SEARCH_COMPLETED);
+                                DEBUG("NSP search resp FAILED %02x\n"
+                                        ,resp->cmd_status);
+                                nl->errcod = we_wmx_nsp_search_failed;
+                                goto out;
+                                break;
+                        }
+                        NL_PROT_ON;
+                        DEBUG("NSP search resp SUCCESS\n");
+                        nl->nsp_rsp = kmalloc(sizeof(
+                                              struct t_wihal_resp_search_nsp)
+                                              ,GFP_KERNEL | __GFP_NOFAIL);
+
+                        memcpy(
+                                nl->nsp_rsp,
+                                &resp->resp.search_nsp,
+                                (sizeof(struct t_wihal_resp_search_nsp)));
+
+                        nl->nsp_rsp->p_nsp = kmalloc(
+                                (sizeof(struct t_wihal_nsp_info) *
+                                        resp->resp.search_nsp.nsp_count),
+                                        GFP_KERNEL| __GFP_NOFAIL);
+
+                        memcpy(
+                                nl->nsp_rsp->p_nsp,
+                                resp->resp.search_nsp.p_nsp,
+                                (sizeof(struct t_wihal_nsp_info) *
+                                        resp->resp.search_nsp.nsp_count));
+                        for(i = 0; i < resp->resp.search_nsp.nsp_count; i++) {
+                                nl->nsp_rsp->p_nsp[i].p_nsp_name = kmalloc(
+                                        nl->nsp_rsp->p_nsp[i].nsp_name_len,
+                                        GFP_KERNEL | __GFP_NOFAIL);
+                                memcpy(nl->nsp_rsp->p_nsp[i].p_nsp_name,
+                                       resp->resp.search_nsp.p_nsp[i].
+                                       p_nsp_name,
+                                       resp->resp.search_nsp.p_nsp[i].
+                                       nsp_name_len);
+                        }
+                        NL_PROT_OFF;
+                        pc2400m_send_simple_event(
+                                ndev,
+                                WE_WMX_SEARCH_COMPLETED);
+                        break;
+
+                case E_WIHAL_EXIT_RESP:
+                        nl->nap = PC2400M_IF_NO_NAP;
+                        pc2400m_if_reset_nl_params(nl);
+                        break;
+
+                case E_WIHAL_NETWORK_STATUS_RESP:
+                        nl->cinr = resp->resp.network_status.cinr;
+                        nl->level = resp->resp.network_status.signal_strength;
+                        memcpy(nl->bsid,
+                               resp->resp.network_status.bsid,
+                               PC2400M_BSID_LEN);
+                        kfree(nl->channel_plan);
+                        nl->channel_plan = kmalloc(sizeof(
+                                                   struct we_wmx_channel_plan),
+                                                   GFP_KERNEL | __GFP_NOFAIL);
+
+                        channel_plan_from_wihal(&resp->
+                                                resp.network_status.channel,
+                                                nl->channel_plan,
+                                                nl);
+                        break;
+
+                case E_WIHAL_PROD_TEST_RESP:
+                        if (resp->resp.prod_test.p_data && pc2400m_nl_sk1) {
+                                /* send output to netlink */
+                                pc2400m_netlink_send_data(
+                                        ndev,
+                                        resp->resp.prod_test.p_data,
+                                        PC2400M_IF_NETLINK_PC2400M1);
+                        }
+                        break;
+
+                case E_WIHAL_DIAGNOSTICS_RESP:
+                {
+                        struct netlink_pipe_msg_str *pipehdr;
+
+                        if (resp->resp.diagnostics.p_data && pc2400m_nl_sk2) {
+                                /* send output to netlink */
+                                nlskb = resp->resp.diagnostics.p_data;
+
+                                /* insert multiplex header */
+                                pipehdr = (struct netlink_pipe_msg_str*)
+                                        skb_push(nlskb,
+                                                 sizeof(struct
+                                                       netlink_pipe_msg_str));
+                                pipehdr->type =
+                                        PC2400M_IF_NETLINK_PIPE_TYPE_MESSAGE;
+                                pipehdr->length = nlskb->len;
+                                pipehdr->version =
+                                        PC2400M_IF_NETLINK_PIPE_VERSION;
+
+                                pc2400m_netlink_send_data(
+                                        ndev, nlskb,
+                                        PC2400M_IF_NETLINK_PC2400M2);
+                        }
+
+                        break;
+                }
+
+                case E_WIHAL_CLOSE_RESP:
+                        nl->wimax_closing_ongoing = 0;
+                        break;
+                /* no special handling, these are for synchronization
+                   purposes only. */
+                case E_WIHAL_SEARCH_NAP_STOP_RESP:
+                case E_WIHAL_SEARCH_NSP_STOP_RESP:
+                case E_WIHAL_ENTRY_RESP:
+
+                case E_WIHAL_EAP_DATA_RESP:
+                case E_WIHAL_EAP_RESULT_RESP:
+                case E_WIHAL_RADIO_STATE_RESP:
+                case E_WIHAL_SUSPEND_RESP:
+                        break;
+                default:
+                        BUG_ON(resp->cmd_resp_id != E_WIHAL_RESUME_RESP);
+                        break;
+                }
+        } else {
+                switch (resp->cmd_resp_id) {
+                case E_WIHAL_INITIALIZE_RESP:
+                        nl->if_status = PC2400M_IF_UNINITIALIZED;
+                        nl->errcod = we_wmx_unspecified_error;
+                        break;
+                case E_WIHAL_NETWORK_STATUS_RESP:
+                        pc2400m_if_reset_network_params(nl);
+                        nl->errcod = we_wmx_device_in_invalid_state;
+                        break;
+                case E_WIHAL_SEARCH_NAP_RESP:
+                        /* search complete send wireless event for this in we */
+                        pc2400m_send_simple_event(ndev,
+                                WE_WMX_SCAN_COMPLETED);
+                        break;
+                case E_WIHAL_SEARCH_NSP_RESP:
+                /* search complete send wireless event for this in we */
+                        pc2400m_send_simple_event(ndev,
+                                                  WE_WMX_SEARCH_COMPLETED);
+                        break;
+                default:
+                        break;
+                }
+
+        }
+
+        /* if after resp there is need to do spi commands use completion
+           to make things synchronous */
+        bes = (struct pc2400m_complete_struct *)pc2400m_complete;
+        if (bes) {
+                bes->pc2400m_result = resp->cmd_status;
+                complete(&bes->comp);
+        }
+
+ out:
+        return;
+
+}
+
+/** Receive an indication from the WiMAX driver module.
+ *  Do not lock inside ind because lock is already used downstrairs.
+ *
+ *  @param ndev pointer to network device
+ *  @param ind pointer containing indication type and parameters
+ *  @return none
+ */
+static void pc2400m_if_ind(struct net_device *ndev, struct t_wihal_ind *ind)
+{
+        struct t_wihal_cmd cmd;
+        struct net_local *nl = netdev_priv(ndev);
+        struct sk_buff *nlskb = NULL;
+        struct ethhdr *eth = NULL;
+        int err = 0;
+
+        switch (ind->ind_id) {
+
+        case E_WIHAL_SYSTEM_STATE_IND:
+                ERROR("CHIP RESET DETECTED!!!!\n");
+                pc2400m_send_simple_event(ndev, WE_WMX_FATAL_SYSTEM_ERROR);
+                pc2400m_if_stop_on_failure(ndev);
+                ndev->flags &= ~IFF_UP;
+                break;
+
+        case E_WIHAL_DATA_RECV_IND:
+
+                /* now we must fetch the data */
+                cmd.cmd_id = E_WIHAL_DATA_RECEIVE;
+
+                /* receive all packets */
+                cmd.cmd.data_receive.data_count =
+                        ind->ind.data_receive.data_count;
+
+                WIMAX_NO_LOCK_CMD(ndev, &cmd);
+
+                break;
+
+        case E_WIHAL_SEARCH_NAP_IND:
+
+                if (!pc2400m_we_scan_result(&ind->ind.search_nap, ndev)) {
+                        DEBUG("NAP SCAN RESP saved\n");
+                } else {
+                        ERROR("NAP SCAN RESULTS COULD NOT BE SAVED!\n");
+                        nl->errcod = we_wmx_scan_failed;
+                }
+                break;
+
+        case E_WIHAL_NETWORK_STATUS_IND:
+
+                switch(ind->ind.network_status.network_status) {
+                /* connecting */
+                case E_WIHAL_NETWORK_STATUS_DATA_PATH_CREATION:
+                        DEBUG("Data path created\n");
+                        break;
+
+                /* connected */
+                case E_WIHAL_NETWORK_STATUS_CONNECTED:
+                        DEBUG("Network Status connected\n");
+
+                        /* save nap */
+                        nl->nap = ((u32)
+                                (ind->ind.network_status.bsid[2])|
+                                ((u32)
+                                (ind->ind.network_status.bsid[1])
+                                 <<8)|
+                                ((u32)
+                                (ind->ind.network_status.bsid[0])
+                                <<16)
+                                );
+                        /* ready for sending data,
+                           start the interface transmit queue */
+                        netif_start_queue(ndev);
+                        /* search complete send wireless
+                           event for this in we */
+                        pc2400m_send_simple_event
+                                (ndev, WE_WMX_WIMAX_CONNECTED);
+                        nl->if_status = PC2400M_IF_CONNECTED;
+                        break;
+
+                case E_WIHAL_NETWORK_STATUS_DISCONNECTED:
+                        /* ready for sending EAP data,
+                           start the interface transmit queue */
+                        netif_start_queue(ndev);
+                        pc2400m_if_reset_nl_params(nl);
+                        pc2400m_send_simple_event
+                                (ndev, WE_WMX_WIMAX_DISCONNECTED);
+                        if (nl->if_status == PC2400M_IF_CONNECTED)
+                                nl->if_status = PC2400M_IF_INIT_DONE;
+                        break;
+
+                case E_WIHAL_NETWORK_STATUS_HANDOVER:
+                        pc2400m_send_simple_event(ndev, WE_WMX_BS_HO);
+                        break;
+
+                case E_WIHAL_NETWORK_STATUS_AUTHENTICATION:
+                        NL_PROT_ON;
+                        nl->nsp_realm_len =
+                                ind->ind.network_status.nsp_realm_len;
+                        if ( nl->nsp_realm_len > 0) {
+                                nl->p_nsp_realm =
+                                        kmalloc(nl->nsp_realm_len,
+                                                GFP_KERNEL| __GFP_NOFAIL);
+
+                                memcpy(nl->p_nsp_realm,
+                                       ind->
+                                       ind.network_status.p_nsp_realm,
+                                       nl->nsp_realm_len);
+                                NL_PROT_OFF;
+                                pc2400m_send_simple_event(ndev,
+                                                          WE_WMX_REALM_AVAIL);
+                        } else {
+                                NL_PROT_OFF;
+                        }
+                        break;
+
+                case E_WIHAL_NETWORK_STATUS_IP_RENEW:
+                        pc2400m_send_simple_event(ndev,WE_WMX_IP_RENEW);
+                        break;
+
+                case E_WIHAL_NETWORK_STATUS_EAP_RESTART:
+                        pc2400m_send_simple_event(ndev,WE_WMX_EAP_RESTART);
+                        break;
+
+                case E_WIHAL_NETWORK_STATUS_CAPABILITY_NEGOTIATION:
+                case E_WIHAL_NETWORK_STATUS_RECONNECTED:
+                case E_WIHAL_NETWORK_STATUS_RANGING:
+                case E_WIHAL_NETWORK_STATUS_REGISTRATION:
+                case E_WIHAL_NETWORK_STATUS_3_WAY_HANDSHAKE:
+                        if (memcmp(nl->bsid,
+                               ind->ind.network_status.bsid,
+                               PC2400M_BSID_LEN))
+                        {
+                                memcpy(nl->bsid,
+                                        ind->ind.network_status.bsid,
+                                        PC2400M_BSID_LEN);
+                                DEBUG("BSINFO AVAIL send to client\n");
+                                pc2400m_send_simple_event(ndev,
+                                        WE_WMX_BSINFO_AVAIL);
+                                kfree(nl->channel_plan);
+                                nl->channel_plan = kmalloc(sizeof(
+                                        struct we_wmx_channel_plan),
+                                        GFP_KERNEL | __GFP_NOFAIL);
+                                channel_plan_from_wihal(
+                                        &ind->ind.network_status.channel,
+                                        nl->channel_plan,
+                                        nl);
+                        }
+                        break;
+
+                default:
+                        BUG_ON(ind->ind.network_status.network_status !=
+                                E_WIHAL_NETWORK_STATUS_LOST);
+                        break;
+                }
+
+                switch(ind->ind.network_status.network_status_err) {
+                case E_WIHAL_NETWORK_STATUS_ERR_NONE:
+                        nl->errcod = we_wmx_no_error;
+                        break;
+                case E_WIHAL_NETWORK_STATUS_ERR_EXIT_BY_NETWORK:
+                        nl->errcod = we_wmx_remote_disconnection;
+                        break;
+                case E_WIHAL_NETWORK_STATUS_ERR_RESET_BY_NETWORK:
+                        nl->errcod = we_wmx_remote_reset;
+                        break;
+                case E_WIHAL_NETWORK_STATUS_ERR_CONNECTION_LOST:
+                        nl->errcod = we_wmx_network_lost;
+                        break;
+                case E_WIHAL_NETWORK_STATUS_ERR_CONNECTION_CREATION:
+                case E_WIHAL_NETWORK_STATUS_ERR_CAPABILITY_NEGOTIATION:
+                case E_WIHAL_NETWORK_STATUS_ERR_RANGING:
+                case E_WIHAL_NETWORK_STATUS_ERR_AUTHENTICATION:
+                case E_WIHAL_NETWORK_STATUS_ERR_3_WAY_HANDSHAKE:
+                case E_WIHAL_NETWORK_STATUS_ERR_DATA_PATH_CREATION:
+                        nl->errcod =
+                                we_wmx_creation_of_connection_failed;
+                        break;
+                case E_WIHAL_NETWORK_STATUS_ERR_REAUTHENTICATION_FAIL:
+                        nl->errcod = we_wmx_reauth_failed;
+                        break;
+                default:
+                        BUG_ON(ind->ind.network_status.network_status_err !=
+                                E_WIHAL_NETWORK_STATUS_ERR_REGISTRATION);
+                        nl->errcod =
+                                we_wmx_creation_of_connection_failed;
+                        break;
+                }
+                break;
+
+        case E_WIHAL_EAP_DATA_IND:
+                nlskb = ind->ind.eap_data.p_payload;
+
+                nlskb->protocol = cpu_to_be16(PC2400M_CONF_ETH_P_EAP);
+                nlskb->dev = ndev;
+                nlskb->ip_summed = CHECKSUM_UNNECESSARY;
+                nlskb->h.raw = nlskb->nh.raw = nlskb->data;
+                skb_push(nlskb,ETH_HLEN);
+                nlskb->mac.raw = nlskb->data;
+                eth = (struct ethhdr *) nlskb->mac.raw;
+                eth->h_proto = cpu_to_be16(PC2400M_CONF_ETH_P_EAP);
+                memcpy(eth->h_dest, ndev->dev_addr, ETH_ALEN);
+                memcpy(eth->h_source, PC2400M_CONF_MAC_SOURCE, ETH_ALEN);
+
+                err = netif_rx(nlskb);
+                break;
+
+        default:
+                BUG_ON(ind->ind_id != E_WIHAL_PROD_TEST_IND);
+                /* send output to netlink */
+                if(pc2400m_nl_sk1) {
+                        pc2400m_netlink_send_data(ndev,
+                                                  ind->ind.prod_test.p_data,
+                                                  PC2400M_IF_NETLINK_PC2400M1);
+                }
+                break;
+        }
+
+        return;
+
+}
+
+/** Driver is opened.
+ *  Called by kernel to enable a network interface.
+ *
+ *  @param dev pointer to network device
+ *  @return 0 success and -EIO chipset failure
+ */
+static int pc2400m_if_open(struct net_device *dev)
+{
+        struct net_local *nl = netdev_priv(dev);
+        struct t_wihal_cmd cmd;
+        int ret = 0;
+        WIMAX_WAIT_RSP;
+
+        /* initialize the local event interface */
+        pc2400m_eif.cmd_resp = pc2400m_if_resp;
+        pc2400m_eif.ind = pc2400m_if_ind;
+
+        /* register the new instance in the driver */
+        pc2400m_driver_if = WIHAL_OPEN(dev,
+                                       &pc2400m_eif,
+                                       &pc2400m_spi_wihal_adapt);
+        BUG_ON(!pc2400m_driver_if);
+        /* prepare the credit counter (this is instance specific) */
+        NL_PROT_ON;
+        nl->tx_credit = WIHAL_DATA_SEND_CREDIT_LEN;
+        NL_PROT_OFF;
+
+        if(nl->chip_type == PC2400M_CONF_FW_CHIP_TYPE_1)
+                ret = pc2400m_if_fetch_firmware(dev,
+                                                PC2400M_CONF_FIRMWARE_FNAME_1,
+                                                &(nl->spi_dev->dev));
+        else
+                ret = pc2400m_if_fetch_firmware(dev,
+                                                PC2400M_CONF_FIRMWARE_FNAME_2,
+                                                &(nl->spi_dev->dev));
+        /* the driver structure */
+        if (ret)
+                goto err1;
+
+        /* configure the driver with default values */
+        cmd.cmd_id = E_WIHAL_CONFIGURE;
+
+        cmd.cmd.configure.config_mask =
+                E_WIHAL_CONFIG_MASK_SIGNAL_RECOVERY_LIMIT |
+                E_WIHAL_CONFIG_MASK_IDLE_TIMER |
+                E_WIHAL_CONFIG_MASK_HANDOVER_LOCK |
+                E_WIHAL_CONFIG_MASK_IDLE_PAGING_INTERVAL |
+                E_WIHAL_CONFIG_MASK_SLEEP_TIMER;
+
+        if (!(nl->validity & PC2400M_IF_VALID_IDLE_TIMER)) {
+                cmd.cmd.configure.idle_timer =
+                        PC2400M_CONF_WIMAX_DEFAULT_IDLE_TIMER;
+                nl->idle_timer = cmd.cmd.configure.idle_timer;
+        } else {
+                DEBUG("Configuring idle timer value %d\n", nl->idle_timer);
+                cmd.cmd.configure.idle_timer = nl->idle_timer;
+        }
+
+        if (!(nl->validity & PC2400M_IF_VALID_SLEEP_TIMER)) {
+                cmd.cmd.configure.sleep_timer =
+                        PC2400M_CONF_WIMAX_DEFAULT_SLEEP_TIMER;
+                nl->sleep_timer = cmd.cmd.configure.sleep_timer;
+        } else {
+                DEBUG("Configuring sleep timer value %d\n", nl->sleep_timer);
+                cmd.cmd.configure.sleep_timer = nl->sleep_timer;
+        }
+
+        if (!(nl->validity & PC2400M_IF_VALID_SIGNAL_RECOVERY_LIMIT)) {
+                cmd.cmd.configure.signal_recovery_limit =
+                        PC2400M_CONF_WIMAX_DEFAULT_SIGNAL_RECOVERY_LIMIT;
+                nl->signal_recovery_limit =
+                        cmd.cmd.configure.signal_recovery_limit;
+        } else {
+                DEBUG("Configuring signal time recovery value %d\n",
+                        nl->signal_recovery_limit);
+                cmd.cmd.configure.signal_recovery_limit =
+                        nl->signal_recovery_limit;
+        }
+
+        if (!(nl->validity & PC2400M_IF_VALID_IDLE_PAGING_INTERVAL)) {
+                cmd.cmd.configure.idle_paging_interval =
+                        PC2400M_CONF_WIMAX_DEFAULT_IDLE_PAGING_INTERVAL;
+                nl->idle_paging_interval =
+                        cmd.cmd.configure.idle_paging_interval;
+        } else {
+                DEBUG("Configuring idle paging interval value %d\n",
+                        nl->idle_paging_interval);
+                cmd.cmd.configure.idle_paging_interval =
+                        nl->idle_paging_interval;
+        }
+
+        cmd.cmd.configure.handover_scheme = E_WIHAL_HANDOVER_SCHEME_NORMAL;
+
+        WIMAX_WAIT_CMD(dev,&cmd);
+        pc2400m_if_set_errcod(pc2400m_complete.pc2400m_result,nl);
+        if (pc2400m_complete.pc2400m_result != E_WIHAL_SUCCESS) {
+                ret = -EIO;
+                if (nl->if_status == PC2400M_IF_INIT_DONE)
+                        goto err1;
+                else
+                        goto out;
+        }
+
+        /* Initialize netlink */
+        pc2400m_netlink_init(dev);
+
+        /* ready for sending EAP data,start the interface transmit queue */
+        netif_start_queue(dev);
+
+        DEBUG("Driver release %s\n", RELEASE_VAL);
+
+        goto out;
+
+ err1:
+        ret = -EIO;
+        /* close the driver instance */
+        nl->if_status = PC2400M_IF_UNINITIALIZED;
+        cmd.cmd_id = E_WIHAL_CLOSE;
+        WIMAX_WAIT_CMD(dev,&cmd);
+ out:
+        return ret; /* all OK */
+
+}
+
+/** Driver is stopped.
+ *  Called by kernel to disable network interface.
+ *
+ * @param dev pointer to network device
+ * @return always 0
+ */
+static int pc2400m_if_stop(struct net_device *dev)
+{
+        struct t_wihal_cmd cmd;
+        struct net_local *nl = netdev_priv(dev);
+        WIMAX_WAIT_RSP;
+
+        if( nl->if_status == PC2400M_IF_UNINITIALIZED ||
+                nl->wimax_closing_ongoing )
+                goto out;
+
+        nl->wimax_closing_ongoing = WIMAX_WCO_SET;
+
+        nl->if_status = PC2400M_IF_UNINITIALIZED;
+
+        BUG_ON(nl->driver_state & PC2400M_IF_DRIVER_STATE_SUSPENDED);
+
+        /* release resources, such as memory areas */
+        DEBUG("WiHAL Closed normally!\n");
+        cmd.cmd_id = E_WIHAL_CLOSE;
+        WIMAX_WAIT_CMD(dev, &cmd);
+
+        /* stop the transmit queue (device can no longer transmit data)*/
+        netif_stop_queue(dev);
+
+        pc2400m_if_reset_nl_params(nl);
+
+        pc2400m_if_reset_scan_results(nl);
+
+        nl->radio_disabled = PC2400M_WMX_RADIO_OFF;
+
+        /* send diagnostics notification of the closing interface */
+        pc2400m_if_send_diag_if_down(dev);
+        pc2400m_netlink_close();
+out:
+        return 0;
+
+}
+
+/** for creating ethernet headers.
+ *  Inserts and fills a ethernet device header according to given parameters.
+ *
+ *  @param skb socket buffer
+ *  @param dev network device
+ *  @param type protocol type
+ *  @param daddr destination ethernet address
+ *  @param saddr source ethernet address
+ *  @param len length of header
+ *  @return length of devices header
+ */
+static int pc2400m_if_hard_header(
+        struct sk_buff *skb,
+        struct net_device *dev,
+        unsigned short type,
+        void *daddr,
+        void *saddr,
+        unsigned int len)
+{
+        struct ethhdr *eth = (struct ethhdr *)skb_push(skb,ETH_HLEN);
+        PC2400M_UNWARN(len);
+        daddr = daddr;
+        saddr = saddr;
+        eth->h_proto = cpu_to_be16(type);
+        memcpy(eth->h_source, dev->dev_addr, ETH_ALEN);
+        memcpy(eth->h_dest, dev->dev_addr, ETH_ALEN);
+        eth->h_dest[ETH_ALEN -1] ^= 0x01;
+
+        return(dev->hard_header_len);
+
+}
+
+/** If UP from host.
+ *  Called upon struct_net device initialization to setup device specific
+ *  default values.
+ *
+ *  @param dev pointer to network device
+ *  @return none
+ */
+static void pc2400m_if_setup(struct net_device *dev)
+{
+
+        struct net_local *nl;
+
+        nl = netdev_priv(dev);
+
+        /* default ethernet values */
+        ether_setup(dev);
+
+        /* kernel interface */
+        dev->get_stats          = pc2400m_if_get_stats;
+        dev->hard_start_xmit    = pc2400m_if_xmit;
+        dev->hard_header_cache  = NULL; /* no ARP caching */
+        dev->open               = pc2400m_if_open;
+        dev->stop               = pc2400m_if_stop;
+        /* No ARP => must be implemented */
+        dev->hard_header        = pc2400m_if_hard_header;
+        dev->mtu                = PC2400M_CONF_WIMAX_DEFAULT_MTU;/* mtu size*/
+
+        /* wireless extensions */
+        dev->wireless_handlers  = (struct iw_handler_def *)
+                                    &pc2400m_we_handler_def;
+
+        /* no ARP, and no hardware address caching */
+        dev->flags             |= IFF_NOARP;
+
+        /* broadcasting is not possible (no hardware addresses) */
+        dev->flags             &= ~IFF_BROADCAST;
+
+        /* multicasting is not possible (no hardware addresses) */
+        dev->flags             &= ~IFF_MULTICAST;
+
+        /* turn of debugging by default */
+        dev->flags             &= ~IFF_DEBUG;
+
+        /* set hardware MAC address */
+        memset(dev->dev_addr,0,ETH_ALEN);
+
+        /* interface status tracking */
+        dev->trans_start       = 0;
+        dev->last_rx           = 0;
+
+}
+
+/*****************************************************************************
+ * Exported functions
+ */
+
+/** Receive an indication from the WiMAX driver.
+ *  Allocates, initializes and registers a new network device interface.
+ *
+ *  @param void
+ *  @return structure of net device or NULL upon failure
+ */
+struct net_device *pc2400m_if_new_device(void)
+{
+
+        struct net_device *dev_pc2400m;
+        struct net_local *nl;
+
+        dev_pc2400m = alloc_netdev(sizeof(struct net_local), "wimax%d",
+                                   pc2400m_if_setup);
+
+        if (!dev_pc2400m) {
+
+                ERROR("Failed to init net if (out of memory).\n");
+                goto err1;
+
+        }
+
+        if (register_netdev(dev_pc2400m)) {
+                ERROR("Failed to register net if.\n");
+                goto err1;
+        }
+
+        nl = netdev_priv(dev_pc2400m);
+        memset(nl,0,sizeof(struct net_local));
+
+        nl->net_dev = dev_pc2400m;
+        nl->if_status = PC2400M_IF_UNINITIALIZED;
+
+        spin_lock_init(&(nl->tx_lock));
+
+        init_MUTEX(&nl->nl_prot_sem);
+
+        NL_PROT_ON;
+        nl->radio_disabled = PC2400M_WMX_RADIO_OFF;
+        INIT_WORK(&nl->tx_work,pc2400m_tx);
+        NL_PROT_OFF;
+
+        goto out;
+
+ err1:
+        free_netdev(dev_pc2400m);
+        dev_pc2400m = NULL;
+
+ out:
+
+        return dev_pc2400m;
+
+}
+
+/** Receive an indication from the WiMAX driver.
+ *  Finalizes initialization of a new network device interface with SPI
+ *  specific elements.
+ *
+ *  @param dev_pc2400m net device pointer
+ *  @return always 0
+ */
+int pc2400m_if_init_device(struct net_device *dev_pc2400m)
+{
+
+        struct net_local *nl;
+
+        nl = netdev_priv(dev_pc2400m);
+        nl->if_status = PC2400M_IF_UNINITIALIZED;
+
+        /* reset driver state */
+        nl->driver_state = 0;
+
+        /* initialize sysfs */
+        pc2400m_if_sysfs_create_files(&(nl->spi_dev->dev));
+        nl->driver_state |= PC2400M_IF_SYSFS_FILES_CREATED;
+        nl->wimax_closing_ongoing = 0;
+
+        return 0;
+}
+
+/** Receive an indication from the WiMAX driver.
+ *
+ *  @param dev_pc2400m net device pointer
+ *  @return none
+ */
+void pc2400m_if_free_device(struct net_device *dev_pc2400m)
+{
+
+        struct net_local *nl = netdev_priv(dev_pc2400m);
+
+        /* Uncreatation of sysfs.
+           This must be done before stop because sysfs might dissappear
+           in shutdown scenario */
+        if (nl->driver_state & PC2400M_IF_SYSFS_FILES_CREATED) {
+                pc2400m_if_sysfs_uncreate_files(&(nl->spi_dev->dev));
+                nl->driver_state &= (~PC2400M_IF_SYSFS_FILES_CREATED);
+        }
+
+        /* free the device driver instance if that exists */
+        pc2400m_if_stop(dev_pc2400m);
+
+        /* free remaining resources */
+        kfree(nl->event_stream);
+
+        unregister_netdev(dev_pc2400m);
+        free_netdev(dev_pc2400m);
+
+        return ;
+
+}
+
+/** Suspend the specified device.
+ *
+ *  @param dev_pc2400m net device pointer
+ *  @return none
+ */
+void pc2400m_if_suspend_device(struct net_device *dev_pc2400m)
+{
+
+        struct net_local *nl = netdev_priv(dev_pc2400m);
+        struct t_wihal_cmd cmd;
+        WIMAX_WAIT_RSP;
+
+        nl->driver_state |= PC2400M_IF_DRIVER_STATE_SUSPENDED;
+
+        if (nl->if_status != PC2400M_IF_UNINITIALIZED) {
+                cmd.cmd_id = E_WIHAL_SUSPEND;
+                WIMAX_WAIT_CMD(dev_pc2400m, &cmd);
+        }
+
+        return ;
+
+}
+
+/** Resume the specified device.
+ *
+ *  @param dev_pc2400m net device pointer
+ *  @return none
+ */
+void pc2400m_if_resume_device(struct net_device *dev_pc2400m)
+{
+
+        struct net_local *nl = netdev_priv(dev_pc2400m);
+        struct t_wihal_cmd cmd;
+        WIMAX_WAIT_RSP;
+
+        nl->driver_state &= (~PC2400M_IF_DRIVER_STATE_SUSPENDED);
+
+        if (nl->if_status != PC2400M_IF_UNINITIALIZED) {
+                cmd.cmd_id = E_WIHAL_RESUME;
+                WIMAX_WAIT_CMD(dev_pc2400m, &cmd);
+        }
+}
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_if.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_if.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_if.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_if.h	2011-02-06 20:12:11.699999939 -0500
@@ -0,0 +1,244 @@
+/*
+ * pc2400m_if.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Jouni Lappi <jouni.lappi@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         45      APPROVED 26-Feb-2008 Jouni Lappi
+*/
+
+/** @file pc2400m_if.h
+ *
+ * Definitions for driver structure
+ *
+ */
+
+#ifndef PC2400M_IF_H
+#define PC2400M_IF_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include <linux/netdevice.h>
+#include <linux/spi/spi.h>
+#include <linux/list.h>
+#include <linux/workqueue.h>
+#include <linux/wireless.h>
+#include <linux/spinlock.h>
+
+#include "pc2400m_conf.h"
+#include "pc2400m_if_we.h"
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/** BS ID variable length */
+#define PC2400M_BSID_LEN           6
+
+/** Wimax radio off value.*/
+#define PC2400M_WMX_RADIO_OFF      0xff
+
+/** macros for wimax commands send to driver
+ *
+ *  @param _device (struct net_device) This pointer to used device
+ *  @param _cmd (enum t_wihal_command_id) This is id of command to be requested
+ *  @return void
+ */
+#define WIMAX_WAIT_CMD(_device, _cmd) \
+        pc2400m_com_lock(_device); \
+        pc2400m_driver_if->wimax_cmd(_device, _cmd, &pc2400m_complete); \
+        pc2400m_com_unlock(); \
+        wait_for_completion(&pc2400m_complete.comp);
+
+#define WIMAX_NO_WAIT_CMD(_device,_cmd) \
+        pc2400m_com_lock(_device); \
+        pc2400m_driver_if->wimax_cmd(_device, _cmd, NULL); \
+        pc2400m_com_unlock();
+
+#define WIMAX_NO_LOCK_CMD(_device,_cmd) \
+        pc2400m_driver_if->wimax_cmd(_device, _cmd, NULL); \
+
+/** macro for wimax wait initialization for commands send to driver
+ *
+ *  @param void
+ *  @return void
+ */
+#define WIMAX_WAIT_RSP \
+        struct pc2400m_complete_struct pc2400m_complete;\
+        init_completion(&pc2400m_complete.comp);
+
+/** Macros to protect net_local structure
+ *
+ *  @param &nl->nl_prot_sem (struct semaphore) semaphore to protect and serve
+ *  @return void
+ */
+#define NL_PROT_ON down_interruptible(&nl->nl_prot_sem)
+
+#define NL_PROT_OFF up(&nl->nl_prot_sem)
+
+/*****************************************************************************
+ * Data types
+ */
+
+/** States for OSSO driver */
+enum pc2400_ifstatus {
+        PC2400M_IF_UNINITIALIZED,
+        PC2400M_IF_INIT_DONE,
+        PC2400M_IF_CONNECTED
+};
+
+/** To carry completion information */
+struct pc2400m_complete_struct {
+        struct completion comp;
+        int pc2400m_result;
+};
+
+/** Presentation of external structure */
+struct socket;
+
+/** hold the device interface data specific to our particular
+ *  piece of hardware. will hold all relevant status information
+ *  specific to one interface, spinlocks, etc */
+struct net_local {
+        /* regular net device statistics */
+        struct net_device_stats stats;
+        /* wireless extensions statistics */
+        struct iw_statistics wstats;
+
+        /* for maintaining a list of devices */
+        struct list_head listelem;
+
+        /* pointers to linked device structures */
+        struct net_device *net_dev;
+        struct spi_device *spi_dev;
+
+        /* SPI transaction data */
+        struct pc2400m_spi_data *spi_data;
+        struct pc2400m_spi_irq_data *irq_data;
+
+        /* chipset GPIOs */
+        int irq_gpio;
+        int power_gpio;
+        int reset_gpio;
+
+        /* client data pointer for the driver */
+        void *driver_priv;
+
+        /* temporary scan buffer */
+        int   event_stream_len;
+        int   event_stream_maxlen;
+        char *event_stream;
+
+        /* work queue for data sending */
+        struct work_struct tx_work;
+        struct workqueue_struct *wq;
+        struct sk_buff *tx_buff;
+        struct sk_buff *tx_last_buff;
+        int tx_buff_len;
+        unsigned long tx_flags;
+        spinlock_t tx_lock;
+        u32 tx_credit;
+
+        /* radio state */
+        int radio_disabled;
+
+        /* current network connection */
+        u32 nap;
+        u8  level;
+
+
+        /* Chipset configuration option flags */
+#define PC2400M_IF_VALID_IDLE_TIMER             0x00000001
+#define PC2400M_IF_VALID_SLEEP_TIMER            0x00000002
+#define PC2400M_IF_VALID_SIGNAL_RECOVERY_LIMIT  0x00000004
+#define PC2400M_IF_VALID_IDLE_PAGING_INTERVAL   0x00000008
+        u32 validity;
+        u32 idle_timer;
+        u32 sleep_timer;
+        u32 signal_recovery_limit;
+        u32 idle_paging_interval;
+
+        /* driver state flags */
+#define PC2400M_IF_DRIVER_STATE_SUSPENDED       0x00000001
+#define PC2400M_IF_SYSFS_FILES_CREATED          0x00000002
+        u32 driver_state;
+
+        /* Netlink tube's process id's */
+        u32 tube1_pid;
+        u32 tube2_pid;
+
+        /* Device info*/
+        char fw_vrs[PC2400M_CONF_HW_FW_VERSION_STR_LEN];
+        char hw_vrs[PC2400M_CONF_HW_FW_VERSION_STR_LEN];
+        char model_vrs[PC2400M_CONF_MODEL_STR_LEN];
+        char manufacturer_vrs[PC2400M_CONF_MANUFACTURER_STR_LEN];
+        char release_vrs[PC2400M_CONF_RELEASE_STR_LEN];
+        char serial_nbr[PC2400M_CONF_SERIAL_NBR_STR_LEN];
+
+        /*  Runtime device info */
+        u8 cinr;
+        char bsid[PC2400M_BSID_LEN];
+        u8 nsp_name_len;
+        u8 nsp_realm_len;
+        char *p_nsp_name;
+        char *p_nsp_realm;
+        u32 nsp_id;
+        enum pc2400_ifstatus  if_status;
+        enum we_wmx_error_code errcod;
+        struct t_wihal_resp_search_nsp *nsp_rsp;
+        u32 nap_nsp;
+        struct we_wmx_channel_plan *channel_plan;
+        u8 chip_type;
+
+        /** If this is set close has already been started */
+        int wimax_closing_ongoing;
+
+        /** Semaphore to protect this struct from simultaneous access */
+        struct semaphore nl_prot_sem;
+
+};
+
+
+/** public global variable */
+/** This is used as function handle to WiHAL commands */
+extern struct t_wihal_driver_if *pc2400m_driver_if;
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/* These initializes device */
+extern struct net_device *pc2400m_if_new_device(void);
+extern int pc2400m_if_init_device(struct net_device *dev);
+/* This releases device */
+extern void pc2400m_if_free_device(struct net_device *dev_pc2400m);
+/* This suspends/resumes device */
+extern void pc2400m_if_suspend_device(struct net_device *dev_pc2400m);
+extern void pc2400m_if_resume_device(struct net_device *dev_pc2400m);
+/** declaration of the wireless statistics handler */
+struct iw_statistics *pc2400m_get_wireless_stats(struct net_device *dev);
+
+#endif /* PC2400M_IF_H */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_if_netlink.c maemo_src/drivers/net/wireless/pc2400m/pc2400m_if_netlink.c
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_if_netlink.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_if_netlink.c	2011-02-06 20:12:11.596666606 -0500
@@ -0,0 +1,363 @@
+/*
+ * pc2400m_if_netlink.c
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Jouni Lappi <jouni.lappi@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         25      APPROVED 07-May-2008 Jouni Lappi
+*/
+
+/** @file pc2400m_if_netlink.c
+ *
+ * Functions for netlink usage
+ *
+ */
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/firmware.h>
+#include <linux/completion.h>
+#include <linux/platform_device.h>
+#include <linux/netlink.h>
+#include <linux/socket.h>
+#include <net/sock.h>
+
+#include "pc2400m_com.h"
+#include "pc2400m_if.h"
+#include "pc2400m_al.h"
+#include "pc2400m_drv.h"
+#include "pc2400m_drv_if.h"
+#include "pc2400m_if.h"
+#include "pc2400m_if_netlink.h"
+
+/*****************************************************************************
+ * Global constants and macros
+ */
+
+/*****************************************************************************
+ * Global data types
+ */
+
+/* socket structs */
+struct sock *pc2400m_nl_sk1 = NULL;
+struct sock *pc2400m_nl_sk2 = NULL;
+
+/** list definition */
+extern struct list_head pc2400m_spi_wimax_device;
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/*****************************************************************************
+ * Local functions
+ */
+
+/** Handler for incoming netlink packets from host.
+ *  This is for production data.
+ *
+ *  @param sk socket
+ *  @param len data length
+ *  @return none
+ */
+static void nl_data_ready1(struct sock *sk, int len)
+{
+        struct net_local *pos;
+        struct net_local *nl = NULL;
+        struct sk_buff *skb = NULL;
+        struct nlmsghdr *nlh = NULL;
+        struct t_wihal_cmd cmd;
+        char *wmx_ifname;
+
+        PC2400M_UNWARN(len);
+        if (!pc2400m_nl_sk1) {
+                ERROR("No netlink initialization done\n");
+                goto err1;
+        }
+
+        while((skb = skb_dequeue(&sk->sk_receive_queue)), skb) {
+                /* get netlink message header */
+                nlh = (struct nlmsghdr *)skb->data;
+                wmx_ifname = (skb->data + sizeof(struct nlmsghdr));
+                /* check that this message is for us */
+                list_for_each_entry(pos, &pc2400m_spi_wimax_device, listelem) {
+                        if(!strcmp(wmx_ifname,
+                                   pos->net_dev->name))
+                                nl = pos;
+                        break;
+                }
+
+                if (!nl) {
+                        kfree_skb(skb);
+                        continue;
+                }
+
+                /* save pid */
+                nl->tube1_pid = nlh->nlmsg_pid;
+
+                /* remove netlink header */
+                skb_pull(skb,sizeof(struct nlmsghdr));
+
+                /* remove ifname */
+                skb_pull(skb,IFNAMSIZ);
+
+                if ((skb->len > 1) && 
+                        (nl->if_status != PC2400M_IF_UNINITIALIZED) &&
+                        (!nl->wimax_closing_ongoing))
+                {
+                        cmd.cmd_id = E_WIHAL_PROD_TEST; 
+                        cmd.cmd.prod_test.p_data = skb;
+ 
+                        WIMAX_NO_WAIT_CMD(pc2400m_nl_sk1->sk_user_data, &cmd);
+                } else {
+                        kfree_skb(skb);
+                }
+        }
+        goto out;
+err1:
+out:
+        return ;
+}
+
+/** Handler for incoming netlink packets from host.
+ *  This is for diagnostic data.
+ *
+ *  @param sk socket
+ *  @param len data length
+ *  @return none
+ */
+static void nl_data_ready2(struct sock *sk, int len)
+{
+
+        struct netlink_pipe_msg_str *pipehdr;
+        struct net_local *nl = NULL;
+        struct net_local *pos = NULL;
+        struct sk_buff *skb = NULL;
+        struct nlmsghdr *nlh = NULL;
+        struct t_wihal_cmd cmd; 
+        char *wmx_ifname;
+
+        PC2400M_UNWARN(len);
+
+        if (!pc2400m_nl_sk2) {
+                ERROR("No netlink initialization done\n");
+                goto err1;      
+        }
+
+        while((skb = skb_dequeue(&sk->sk_receive_queue)), skb) {
+                /* get netlink message header */
+                nlh = (struct nlmsghdr *)skb->data;
+                wmx_ifname = (skb->data + sizeof(struct nlmsghdr));
+                /* check that this message is for us */
+                list_for_each_entry(pos, &pc2400m_spi_wimax_device, listelem) {
+                        if(!strcmp(wmx_ifname,
+                                   pos->net_dev->name)) nl = pos;
+                        break;
+                }
+
+                if (!nl) {
+                        kfree_skb(skb);
+                        continue;
+                }
+
+                /* save pid */
+                nl->tube2_pid = nlh->nlmsg_pid;
+
+                /* remove netlink header */
+                skb_pull(skb,sizeof(struct nlmsghdr));
+
+                /* remove ifname */
+                skb_pull(skb,IFNAMSIZ);
+
+                /* check utilized version */
+                pipehdr = (struct netlink_pipe_msg_str*)skb->data;
+                if (pipehdr->version != PC2400M_IF_NETLINK_PIPE_VERSION) {
+                        ERROR("Unsupported netlink multiplex version!\n");
+                        kfree_skb(skb);
+                        continue;
+                }
+                BUG_ON(pipehdr->type != PC2400M_IF_NETLINK_PIPE_TYPE_MESSAGE);
+
+                /* remove the pipe multiplex header */
+                skb_pull(skb, sizeof(struct netlink_pipe_msg_str));
+
+                if ((skb->len > 1) &&
+                        (nl->if_status != PC2400M_IF_UNINITIALIZED) && 
+                        (!nl->wimax_closing_ongoing))
+                {
+                        cmd.cmd_id = E_WIHAL_DIAGNOSTICS;
+                        cmd.cmd.diagnostics.p_data = skb;
+
+                        WIMAX_NO_WAIT_CMD(pc2400m_nl_sk2->sk_user_data, &cmd);
+                } else {
+                        kfree_skb(skb);
+                }
+        }
+        goto out;
+err1:
+out:
+        return ;
+}
+
+/*****************************************************************************
+ * Exported functions
+ */
+
+/** Check whether trace pipe can send.
+ *
+ *  @param ndev net device struct
+ *  @return Returns true if the socket exist and it has an associated pid,
+ *          false otherwise
+ */
+int pc2400m_netlink_trace_pipe_ready(struct net_device *ndev)
+{
+
+        struct net_local *nl = netdev_priv(ndev);
+        return ((int)pc2400m_nl_sk2) && nl->tube2_pid;
+
+}
+
+
+/** Data from device to host.
+ *
+ *  @param skb data buffer
+ *  @param netlink netlink number
+ *  @return always 0
+ */
+int pc2400m_netlink_send_data(
+        struct net_device *ndev,
+        struct sk_buff *skb,
+        char netlink)
+{
+        struct net_local *nl = netdev_priv(ndev);
+        struct sock *pc2400m_nl_sk = NULL;
+        int tube_pid = 0;
+
+        BUG_ON(!skb);
+
+        BUG_ON((netlink != PC2400M_IF_NETLINK_PC2400M1) &&
+                (netlink != PC2400M_IF_NETLINK_PC2400M2));
+
+        switch (netlink) {
+        case PC2400M_IF_NETLINK_PC2400M1:  /* Production testing */
+                pc2400m_nl_sk = pc2400m_nl_sk1;
+                tube_pid = nl->tube1_pid;
+                break;
+        default:  /* Diagnostics access */
+                pc2400m_nl_sk = pc2400m_nl_sk2;
+                tube_pid = nl->tube2_pid;
+                break;
+        }
+
+        if (pc2400m_nl_sk) {
+                /* we'll add ifname */
+                skb_push(skb,IFNAMSIZ);
+                memcpy(skb->data,ndev->name,IFNAMSIZ);
+
+                /* we make room for nlmsghdr */
+                skb_push(skb,sizeof(struct nlmsghdr));
+                memset(skb->data,0,sizeof(struct nlmsghdr));
+
+                NETLINK_CB(skb).pid = 0;
+                NETLINK_CB(skb).dst_group = 0;
+
+                if (tube_pid == 0) {
+                        netlink_broadcast(pc2400m_nl_sk, skb, 0, 0,
+                                GFP_ATOMIC);
+                } else {
+                        netlink_unicast(pc2400m_nl_sk, skb, tube_pid,
+                                        MSG_DONTWAIT);
+                }
+        }
+
+        return 0;
+
+}
+
+/** Initializes netlink sockets.
+ *
+ *  @param ndev net device struct
+ *  @return none
+ */
+void pc2400m_netlink_init(struct net_device *ndev) 
+{
+        struct net_local *nl = netdev_priv(ndev);
+
+        DEBUG("Creating netlinks\n");
+
+        pc2400m_nl_sk1 = netlink_kernel_create(PC2400M_IF_NETLINK_PC2400M1,
+                                                0,
+                                                nl_data_ready1,
+                                                THIS_MODULE);
+
+        if(!pc2400m_nl_sk1) {
+                ERROR("Failed to create netlink1\n");
+                goto out;
+        }
+        pc2400m_nl_sk1->sk_user_data = ndev;
+        nl->tube1_pid = 0;
+
+        pc2400m_nl_sk2 = netlink_kernel_create(PC2400M_IF_NETLINK_PC2400M2,
+                                               0,
+                                               nl_data_ready2,
+                                               THIS_MODULE);
+
+        if(!pc2400m_nl_sk2) {
+                ERROR("Failed to create netlink3\n");
+                goto out;
+        }
+        pc2400m_nl_sk2->sk_user_data = ndev;
+        nl->tube2_pid = 0;
+
+ out:
+        return ;
+
+}
+
+/** Releases netlink sockets.
+ *
+ *  @return none
+ */
+void pc2400m_netlink_close(void)
+{
+
+        if (pc2400m_nl_sk1)
+                sock_release(pc2400m_nl_sk1->sk_socket);
+        if (pc2400m_nl_sk2)
+                sock_release(pc2400m_nl_sk2->sk_socket);
+
+        pc2400m_nl_sk1 = NULL;
+        pc2400m_nl_sk2 = NULL;
+
+        return ;
+
+}
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_if_netlink.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_if_netlink.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_if_netlink.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_if_netlink.h	2011-02-06 20:12:12.013333273 -0500
@@ -0,0 +1,104 @@
+/*
+ * pc2400m_if_netlink.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Jouni Lappi <jouni.lappi@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         12      APPROVED 19-Mar-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_if_netlink.h
+ *
+ * Pc2400m driver netlink socket handling header
+ *
+ */
+
+#ifndef PC2400M_NETLINK_H
+#define PC2400M_NETLINK_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/* Netlink protocol number */
+#define PC2400M_IF_NETLINK_PC2400M1             17
+#define PC2400M_IF_NETLINK_PC2400M2             18
+
+/* Netlink diagnostics messages */
+#define PC2400M_IF_NETLINK_PIPE_TYPE_TRACE      0x01
+#define PC2400M_IF_NETLINK_PIPE_TYPE_MESSAGE    0x02
+#define PC2400M_IF_NETLINK_PIPE_TYPE_IF_DOWN    0x03
+
+/* Netlink traces*/
+#define PC2400M_IF_NETLINK_TRACE_TYPE_EMPTY     0x00
+#define PC2400M_IF_NETLINK_TRACE_TYPE_BYTE      0x01
+#define PC2400M_IF_NETLINK_TRACE_TYPE_U16       0x02
+#define PC2400M_IF_NETLINK_TRACE_TYPE_U32       0x03
+#define PC2400M_IF_NETLINK_TRACE_TYPE_STR       0x04
+#define PC2400M_IF_NETLINK_TRACE_TYPE_HEX       0x05
+
+/** version info */
+#define PC2400M_IF_NETLINK_PIPE_VERSION         0x00000002
+
+/*****************************************************************************
+ * Data types
+ */
+
+/** netlink message header */
+struct netlink_pipe_msg_str {
+        u32 type;
+        u32 length;
+        u32 version;
+};
+
+/** netlink trace message header */
+struct netlink_trace_msg_str {
+        struct netlink_pipe_msg_str header;
+        u32 trace_type;
+        u32 trace_group;
+        u32 trace_id;
+        u32 trace_len;
+};
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/** Netlink Initialization function */
+void pc2400m_netlink_init(struct net_device *ndev);
+/** Netlink trace pipe data receive */
+int  pc2400m_netlink_trace_pipe_ready(struct net_device *ndev);
+/** Netlink data send */
+int  pc2400m_netlink_send_data(struct net_device *ndev,
+                               struct sk_buff *skb,
+                               char netlink);
+/** Netlink close */
+void pc2400m_netlink_close(void);
+
+#endif /* PC2400M_NETLINK_H */
+
+/* End of File */
+
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_if_sysfs.c maemo_src/drivers/net/wireless/pc2400m/pc2400m_if_sysfs.c
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_if_sysfs.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_if_sysfs.c	2011-02-06 20:12:11.783333274 -0500
@@ -0,0 +1,379 @@
+/*
+ * pc2400m_if_sysfs.c
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Jouni Lappi <jouni.lappi@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         31      APPROVED 03-Jul-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_if_sysfs.c
+ *
+ *  This creates,removes and handles sysfs fw_version file for the device
+ *
+ */
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+
+#include "pc2400m_com.h"
+#include "pc2400m_drv_if.h"
+#include "pc2400m_if_sysfs.h"
+#include "pc2400m_if.h"
+#include "pc2400m_drv.h"
+#include "pc2400m_release.h"
+
+/*****************************************************************************
+ * Global constants and macros
+ */
+
+#ifdef PC2400M_SIMULATION_INTERFACE_ENABLED
+static u8 *pc2400m_if_sysfs_simul_xml = NULL;
+static u32 pc2400m_if_sysfs_simul_xml_len = 0;
+#endif /* PC2400M_SIMULATION_INTERFACE_ENABLED */
+
+/*****************************************************************************
+ * Local functions
+ */
+
+#ifdef PC2400M_SIMULATION_INTERFACE_ENABLED
+/* function declarations for the simulation interface */
+extern s32 wxsimul_init(void);
+extern void wxsimul_uninit(void);
+extern u8 *wxsimul_script_set(u8 *xml);
+extern void wxsimul_namespace_reset(void);
+extern void wxsimul_start_param_set(u8*, u8*);
+extern s32 wxsimul_start(void);
+extern void wxsimul_stop(void);
+extern u8 *wxsimul_verdict(void);
+#endif /* PC2400M_SIMULATION_INTERFACE_ENABLED */
+
+/** Outputs fw version related info.
+ *
+ *  @param dev sys device
+ *  @param attr file attributes
+ *  @param buf buffer in user space
+ *  @return size of file
+ */
+static ssize_t pc2400m_if_show_fw_version(
+        struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+        struct net_device *ndev;
+        struct net_local *nl;
+        int offset = 0;
+
+        PC2400M_UNWARN(attr);
+
+        ndev = (struct net_device *)dev->driver_data;
+        nl = netdev_priv(ndev);
+
+        offset += sprintf(buf + offset,
+                "Manufacturer=%s\n",(char *)nl->manufacturer_vrs);
+        offset += sprintf(buf + offset,
+                "Model_name=%s\n",(char *)nl->model_vrs);
+        offset += sprintf(buf + offset,
+                "Serial_number=%s\n",(char *)nl->serial_nbr);
+        offset += sprintf(buf + offset,
+                "API_VRS=%s\n",PC2400M_CONF_WE_API_VRS);
+        offset += sprintf(buf + offset,
+                "FW_VRS=%s\n",(char *)nl->fw_vrs);
+        offset += sprintf(buf + offset,
+                "HW_VRS=%s\n",(char *)nl->hw_vrs);
+        offset += sprintf(buf + offset,"REL_VRS=%s\n", RELEASE_VAL);
+
+        return offset;
+}
+
+#ifdef PC2400M_SIMULATION_INTERFACE_ENABLED
+/** Start or stop the simulation.
+ *
+ *  @param dev sys device
+ *  @param attr file attributes
+ *  @param buf buffer in user space
+ *  @param count size of the buffer
+ *  @return consumed number of bytes, or negative error code
+ */
+static ssize_t pc2400m_if_set_simul_state(
+        struct device *dev,
+        struct device_attribute *attr,
+        const char *buf,
+        size_t count)
+{
+
+        ssize_t ret = count;
+        u8 *res;
+
+        PC2400M_UNWARN(dev);
+        PC2400M_UNWARN(attr);
+
+#define PC2400M_SIMULATION_START_CMD  "START"
+#define PC2400M_SIMULATION_STOP_CMD   "STOP"
+#define PC2400M_SIMULATION_PARSE_CMD  "PARSE"
+#define PC2400M_SIMULATION_RESET_CMD  "RESET"
+
+        if (count >= strlen(PC2400M_SIMULATION_START_CMD) &&
+            (!memcmp(
+                    buf,
+                    PC2400M_SIMULATION_START_CMD,
+                    strlen(PC2400M_SIMULATION_START_CMD)))) {
+
+                /* start the simulation */
+                wxsimul_start();
+
+        } else if (count >= strlen(PC2400M_SIMULATION_STOP_CMD) &&
+                   (!memcmp(
+                           buf,
+                           PC2400M_SIMULATION_STOP_CMD,
+                           strlen(PC2400M_SIMULATION_STOP_CMD)))) {
+
+                /* stop the simulation */
+                wxsimul_stop();
+
+        } else if (count >= strlen(PC2400M_SIMULATION_PARSE_CMD) &&
+                   (!memcmp(
+                           buf,
+                           PC2400M_SIMULATION_PARSE_CMD,
+                           strlen(PC2400M_SIMULATION_PARSE_CMD)))) {
+
+                res = wxsimul_script_set(pc2400m_if_sysfs_simul_xml);
+                kfree(pc2400m_if_sysfs_simul_xml);
+                pc2400m_if_sysfs_simul_xml = NULL;
+                pc2400m_if_sysfs_simul_xml_len = 0;
+
+                if (res) {
+                        /* upon error, print an error message */
+                        count = -EFAULT;
+                        ERROR("Simulation script error: %s\n", res);
+                        kfree(res);
+                }
+
+        } else if (count >= strlen(PC2400M_SIMULATION_RESET_CMD) &&
+                   (!memcmp(
+                           buf,
+                           PC2400M_SIMULATION_RESET_CMD,
+                           strlen(PC2400M_SIMULATION_RESET_CMD)))) {
+
+                wxsimul_namespace_reset();
+
+        } else {
+
+                /* unknown command */
+                ret = -EFAULT;
+
+        }
+
+        return ret;
+
+}
+
+/** Set an XML simulation script into the simulation.
+ *
+ *  @param dev sys device
+ *  @param attr file attributes
+ *  @param buf buffer in user space
+ *  @param count size of the buffer
+ *  @return consumed number of bytes, or negative error code
+ */
+static ssize_t pc2400m_if_set_simul_xml(
+        struct device *dev,
+        struct device_attribute *attr,
+        const char *buf,
+        size_t count)
+{
+
+        u8 *tmp;
+
+        PC2400M_UNWARN(dev);
+        PC2400M_UNWARN(attr);
+
+        /* copy the XML into a local buffer. the kernel stupidly
+           gives it to use in unknown size pieces, so we'll have
+           to buffer it. */
+        if (!pc2400m_if_sysfs_simul_xml_len) {
+                pc2400m_if_sysfs_simul_xml =
+                        kmalloc(count + 1, __GFP_NOFAIL | GFP_KERNEL);
+
+        } else {
+
+                tmp = kmalloc(
+                        pc2400m_if_sysfs_simul_xml_len + count + 1,
+                        __GFP_NOFAIL | GFP_KERNEL);
+                memcpy(tmp,
+                       pc2400m_if_sysfs_simul_xml,
+                       pc2400m_if_sysfs_simul_xml_len);
+                kfree(pc2400m_if_sysfs_simul_xml);
+                pc2400m_if_sysfs_simul_xml = tmp;
+
+        }
+
+        /* copy the new stuff into our buffer */
+        memcpy(
+                pc2400m_if_sysfs_simul_xml+pc2400m_if_sysfs_simul_xml_len,
+                buf,
+                count);
+        pc2400m_if_sysfs_simul_xml_len += count;
+
+        /* put a NULL terminating character at the end */
+        pc2400m_if_sysfs_simul_xml[pc2400m_if_sysfs_simul_xml_len] = '\0';
+
+        return count;
+
+}
+
+
+/** Return the verdict of the latest executed simulation.
+ *
+ *  @param dev sys device
+ *  @param attr file attributes
+ *  @param buf buffer in user space
+ *  @return size of file
+ */
+static ssize_t pc2400m_if_get_simul_verdict(
+        struct device *dev,
+        struct device_attribute *attr,
+        char *buf)
+{
+        int offset = 0;
+        u8 *verdict;
+
+        PC2400M_UNWARN(dev);
+        PC2400M_UNWARN(attr);
+
+        verdict = wxsimul_verdict();
+
+        if (verdict) {
+
+                /* a problem has occurred */
+                offset += sprintf(
+                        buf + offset,
+                        "FAILED! Error in scenario '%s'.",
+                        verdict);
+
+        } else {
+
+                /* simulation success */
+                offset += sprintf(
+                        buf + offset, "PASSED!");
+
+        }
+
+        return offset;
+}
+#endif /* PC2400M_SIMULATION_INTERFACE_ENABLED */
+
+
+/** This is kernel sysfs macro that creates file definitions */
+static DEVICE_ATTR(fw_version,
+                   S_IRUGO | S_IWUSR,
+                   pc2400m_if_show_fw_version,
+                   NULL);
+
+#ifdef PC2400M_SIMULATION_INTERFACE_ENABLED
+static DEVICE_ATTR(simul_state,
+                   S_IRUGO | S_IWUSR,
+                   NULL,
+                   pc2400m_if_set_simul_state);
+static DEVICE_ATTR(simul_script,
+                   S_IRUGO | S_IWUSR,
+                   pc2400m_if_get_simul_verdict,
+                   pc2400m_if_set_simul_xml);
+#endif /* PC2400M_SIMULATION_INTERFACE_ENABLED */
+
+/*****************************************************************************
+ * Exported functions
+ */
+
+/** Creates sysfs files.
+ *  This creates fw_version file in devices sysfs directory tree
+ *
+ *  @param dev sys device
+ *  @return 0 success, -Exxx file creation failed
+ */
+int pc2400m_if_sysfs_create_files(struct device *dev)
+{
+
+        int ret;
+
+#ifdef PC2400M_SIMULATION_INTERFACE_ENABLED
+        /* initialize the simulation interface */
+        BUG_ON(wxsimul_init());
+#endif /* PC2400M_SIMULATION_INTERFACE_ENABLED */
+
+        ret = device_create_file(dev, &dev_attr_fw_version);
+        if (ret)
+                goto err1;
+
+#ifdef PC2400M_SIMULATION_INTERFACE_ENABLED
+        /* create sysfs files related to simulation control */
+        ret = device_create_file(dev, &dev_attr_simul_state);
+        if (ret)
+                goto err2;
+        ret = device_create_file(dev, &dev_attr_simul_script);
+        if (ret)
+                goto err3;
+
+        goto out;
+
+ err3:
+        device_remove_file(dev, &dev_attr_simul_state);
+
+ err2:
+        device_remove_file(dev, &dev_attr_fw_version);
+
+#else /* PC2400M_SIMULATION_INTERFACE_ENABLED */
+        goto out;
+#endif /* PC2400M_SIMULATION_INTERFACE_ENABLED */
+
+ err1:
+ out:
+        return ret;
+}
+
+/** Removes sysfs files.
+ *
+ *  @param dev sys device
+ *  @return none
+ */
+void pc2400m_if_sysfs_uncreate_files(struct device *dev)
+{
+
+#ifdef PC2400M_SIMULATION_INTERFACE_ENABLED
+        /* finalize the simulation interface */
+        wxsimul_uninit();
+
+        /* remove simulation related files */
+        device_remove_file(dev, &dev_attr_simul_state);
+        device_remove_file(dev, &dev_attr_simul_script);
+#endif /* PC2400M_SIMULATION_INTERFACE_ENABLED */
+
+        device_remove_file(dev, &dev_attr_fw_version);
+
+}
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_if_sysfs.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_if_sysfs.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_if_sysfs.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_if_sysfs.h	2011-02-06 20:12:11.613333272 -0500
@@ -0,0 +1,63 @@
+/*
+ * pc2400m_if_sysfs.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Jouni Lappi <jouni.lappi@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         7       APPROVED 21-Feb-2008 Jouni Lappi
+*/
+
+/** @file pc2400m_if_sysfs.h
+ *
+ * Header file for sysfs
+ *
+ */
+
+#ifndef PC2400M_IF_SYSFS_H
+#define PC2400M_IF_SYSFS_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/*****************************************************************************
+ * Data types
+ */
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/** Function to create sysfs files */
+int pc2400m_if_sysfs_create_files(struct device *dev);
+/** Function to uncreate sysfs files */
+void pc2400m_if_sysfs_uncreate_files(struct device *dev);
+/** Global driver struct */
+extern struct t_wihal_driver_if *pc2400m_driver_if;
+
+#endif /* PC2400M_IF_SYSFS_H */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_if_we.c maemo_src/drivers/net/wireless/pc2400m/pc2400m_if_we.c
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_if_we.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_if_we.c	2011-02-06 20:12:12.233333273 -0500
@@ -0,0 +1,1904 @@
+/*
+ * pc2400m_if_we.c
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Jouni Lappi <jouni.lappi@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         47      APPROVED 28-Aug-2008 Jouni Lappi
+*/
+
+/** @file pc2400m_if_we.c
+ *
+ * Wireless extension handlers
+ *
+ */
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include <linux/if_arp.h>
+#include <linux/wireless.h>
+#include <net/iw_handler.h>
+
+#include "pc2400m_drv_if.h"
+#include "pc2400m_if_we.h"
+#include "pc2400m_if.h"
+#include "pc2400m_com.h"
+#include "pc2400m_drv.h"
+#include "pc2400m_conf.h"
+
+/*****************************************************************************
+ * Global constants and macros
+ */
+
+/** Everything is fine, rest a bit before you go on */
+#define PC2400M_IF_ALLA_OKKO               0
+/** maximum size of single event */
+#define PC2400M_IF_SCAN_RES_MAX_LEN        256
+
+/*****************************************************************************
+ * Global data types
+ */
+
+/** externalization of the wireless extensions structure */
+extern const struct iw_handler_def  pc2400m_we_handler_def;
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/** This converts channel plan from we to wihal */
+static int channel_plan_to_wihal(
+        struct we_wmx_channel_plan *source,
+        struct t_wihal_search_plan *dest,
+        struct net_local *nl);
+
+/** This function finds last NAP event from event stream */
+static int last_nap_from_stream(char ** stream, int stream_len);
+
+/** standard IOCTL's */
+
+static int pc2400m_we_get_name(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra);
+
+static int pc2400m_we_set_frag(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        struct iw_param *vwrq,
+        char *extra);
+
+static int pc2400m_we_get_frag(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        struct iw_param *vwrq,
+        char *extra);
+
+static int pc2400m_we_set_txpower(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        struct iw_param *vwrq,
+        char *extra);
+
+static int pc2400m_we_get_txpower(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        struct iw_param *vwrq,
+        char *extra);
+
+
+
+/** private IOCTL's */
+static int pc2400m_we_set_nap_scan(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra);
+
+static int pc2400m_we_get_nap_scan(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra);
+
+static int pc2400m_we_set_nsp_scan(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra);
+
+static int pc2400m_we_get_nsp_scan(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra);
+
+static int pc2400m_we_set_eap_result(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra);
+
+static int pc2400m_we_get_bsinfo(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra);
+
+static int pc2400m_we_disconnect(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra);
+
+static int pc2400m_we_get_error_code(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra);
+
+static int pc2400m_we_connect(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra);
+
+static int pc2400m_we_get_nsp_realm(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra);
+
+static int pc2400m_we_configure(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra);
+
+static int pc2400m_we_devinfo(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra);
+
+
+/** handlers for the default wireless extension IOCTL's */
+static const iw_handler pc2400m_we_handler[] =
+{
+
+        (iw_handler)NULL,                            /* SIOCSIWCOMMIT */
+        (iw_handler)pc2400m_we_get_name,             /* SIOCGIWNAME */
+        (iw_handler)NULL,                            /* SIOCSIWNWID */
+        (iw_handler)NULL,                            /* SIOCGIWNWID */
+        (iw_handler)NULL,                            /* SIOCSIWFREQ */
+        (iw_handler)NULL,                            /* SIOCGIWFREQ */
+        (iw_handler)NULL,                            /* SIOCSIWMODE */
+        (iw_handler)NULL,                            /* SIOCGIWMODE */
+        (iw_handler)NULL,                            /* SIOCSIWSENS */
+        (iw_handler)NULL,                            /* SIOCGIWSENS */
+        (iw_handler)NULL,                            /* SIOCSIWRANGE */
+        (iw_handler)NULL,                            /* SIOCGIWRANGE */
+        (iw_handler)NULL,                            /* SIOCSIWPRIV */
+        (iw_handler)NULL,                            /* SIOCGIWPRIV */
+        (iw_handler)NULL,                            /* SIOCSIWSTATS */
+        (iw_handler)pc2400m_get_wireless_stats,      /* SIOCGIWSTATS */
+        (iw_handler)NULL,                            /* SIOCSIWSPY */
+        (iw_handler)NULL,                            /* SIOCGIWSPY */
+        (iw_handler)NULL,                            /* SIOCSIWTHRSPY */
+        (iw_handler)NULL,                            /* SIOCGIWTHRSPY */
+        (iw_handler)NULL,                            /* SIOCSIWAP */
+        (iw_handler)NULL,                            /* SIOCGIWAP */
+        (iw_handler)NULL,
+        (iw_handler)NULL,                            /* SIOCGIWAPLIST */
+        (iw_handler)NULL,                            /* SIOCSIWSCAN */
+        (iw_handler)NULL,                            /* SIOCGIWSCAN */
+        (iw_handler)NULL,                            /* SIOCSIWESSID */
+        (iw_handler)NULL,                            /* SIOCGIWESSID */
+        (iw_handler)NULL,                            /* SIOCSIWNICKN */
+        (iw_handler)NULL,                            /* SIOCGIWNICKN */
+        (iw_handler)NULL,
+        (iw_handler)NULL,
+        (iw_handler)NULL,                           /* SIOCSIWRATE */
+        (iw_handler)NULL,                           /* SIOCGIWRATE */
+        (iw_handler)NULL,                           /* SIOCSIWRTS */
+        (iw_handler)NULL,                           /* SIOCGIWRTS */
+        (iw_handler)pc2400m_we_set_frag,            /* SIOCSIWFRAG */
+        (iw_handler)pc2400m_we_get_frag,            /* SIOCGIWFRAG */
+        (iw_handler)pc2400m_we_set_txpower,         /* SIOCSIWTXPOW */
+        (iw_handler)pc2400m_we_get_txpower,         /* SIOCGIWTXPOW */
+        (iw_handler)NULL,                           /* SIOCSIWRETRY */
+        (iw_handler)NULL,                           /* SIOCGIWRETRY */
+        (iw_handler)NULL,                           /* SIOCSIWENCODE */
+        (iw_handler)NULL,                           /* SIOCGIWENCODE */
+};
+
+/** argument specification for the own wireless extensions below. one for
+    each private extension below
+    even numbered ioctls are SET, restricted to root, and should not
+    return arguments (get_args = 0) */
+static const struct iw_priv_args pc2400m_private_we_args[] =
+{
+        {
+                SIOCIWFIRSTPRIV,
+                IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+                0,
+                "set nap scan"
+
+        },
+
+        {
+
+                SIOCIWFIRSTPRIV + 1,
+                0,
+                IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+                "get nap scan"
+
+        },
+
+        {
+
+                SIOCIWFIRSTPRIV + 3,
+                IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+                0,
+                "set nsp search"
+
+        },
+
+        {
+
+                SIOCIWFIRSTPRIV + 4,
+                0,
+                IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+                "get nsp search"
+
+        },
+
+        {
+
+                SIOCIWFIRSTPRIV + 5,
+                IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+                0,
+                "set eap key"
+
+        },
+
+        {
+
+                SIOCIWFIRSTPRIV + 6,
+                0,
+                IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+                "get bs info"
+
+        },
+
+        {
+
+                SIOCIWFIRSTPRIV + 7,
+                IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+                0,
+                "disconnect"
+
+        },
+
+        {
+
+                SIOCIWFIRSTPRIV + 8,
+                0,
+                IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+                "get error code"
+
+        },
+
+        {
+
+                SIOCIWFIRSTPRIV + 9,
+                IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+                0,
+                "connect"
+
+        },
+        {
+
+                SIOCIWFIRSTPRIV + 10,
+                0,
+                IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+                "get realm"
+
+        },
+        {
+
+                SIOCIWFIRSTPRIV + 11,
+                IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+                0,
+                "set config"
+
+        },
+        {
+
+                SIOCIWFIRSTPRIV + 12,
+                IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+                0,
+                "get device info"
+
+        },
+
+};
+
+/* handlers for own (WIMAX specific) wireless extensions.
+    these are allocated in order starting from SIOCIWFIRSTPRIV.*/
+
+/** below are registered simple testing purpose handlers; they
+    are a starting point for private handlers. */
+static const iw_handler pc2400m_private_we_handler[] =
+{
+        (iw_handler)pc2400m_we_set_nap_scan,    /* SIOCSIWIMAXSCAN */
+        (iw_handler)pc2400m_we_get_nap_scan,    /* SIOCGIWIMAXSCAN */
+        (iw_handler)pc2400m_we_set_nsp_scan,    /* SIOCSIWNSPSEARCH */
+        (iw_handler)pc2400m_we_get_nsp_scan,    /* SIOCGIWNSPSEARCH */
+        (iw_handler)pc2400m_we_set_eap_result,  /* SIOCSIWEAPRESULT */
+        (iw_handler)pc2400m_we_get_bsinfo,        /* SIOCGIWBSID */
+        (iw_handler)pc2400m_we_disconnect,      /* SIOCSIWDISCONNECT */
+        (iw_handler)pc2400m_we_get_error_code,  /* SIOCGIWERRORCODE */
+        (iw_handler)pc2400m_we_connect,         /* SIOCSIWCONNECT */
+        (iw_handler)pc2400m_we_get_nsp_realm,   /* SIOCGIWNSPREALM */
+        (iw_handler)pc2400m_we_configure,       /* SIOCSIWIMAXCONF */
+        (iw_handler)pc2400m_we_devinfo,        /* SIOCGIWDEVINFO */
+};
+
+
+/** finally, the wireless extensions definition */
+const struct iw_handler_def  pc2400m_we_handler_def =
+{
+
+        .num_standard = sizeof(pc2400m_we_handler) / sizeof(iw_handler),
+        .num_private = sizeof(pc2400m_private_we_handler) / sizeof(iw_handler),
+        .num_private_args =
+        sizeof(pc2400m_private_we_args) / sizeof(struct iw_priv_args),
+        .standard = (iw_handler *) pc2400m_we_handler,
+        .private = (iw_handler *) pc2400m_private_we_handler,
+        .private_args = (struct iw_priv_args *) pc2400m_private_we_args,
+        .get_wireless_stats = pc2400m_get_wireless_stats,
+
+};
+
+/*****************************************************************************
+ * Local functions
+ */
+
+/* standard IOCTL's */
+
+/** Return protocol name.
+ *
+ *  @param dev pointer to net device
+ *  @param info pointer to IOCTL info
+ *  @param wrqu pointer IOCTL parameters
+ *  @param extra pointer to extra data
+ *  @return always 0
+ */
+static int pc2400m_we_get_name(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra)
+{
+
+        /* this ioctl returns the "name" of the protocol supported by
+           this wireless networking driver. */
+        PC2400M_UNWARN(extra);
+        PC2400M_UNWARN(info);
+        PC2400M_UNWARN(dev);
+
+        strncpy(wrqu->name, WE_WMX_WIMAX_PROTOCOL, IFNAMSIZ);
+
+        return 0;
+
+}
+
+/** Sets socket MTU value.
+ *
+ *  @param dev pointer to net device
+ *  @param info pointer to IOCTL info
+ *  @param wrqu pointer IOCTL parameters
+ *  @param extra pointer to extra data
+ *  @return 0 success, -EIO device uninitialized
+ */
+static int pc2400m_we_set_frag(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        struct iw_param *vwrq,
+        char *extra)
+{
+
+        struct net_local *nl = netdev_priv(dev);
+        int ret = -ERANGE;
+
+        PC2400M_UNWARN(extra);
+        PC2400M_UNWARN(info);
+
+        /* this ioctl is used to set the fragmentation threshold: this is the
+           maximum size of fragment being set over the air. this seems to be
+           the exact same value as MTU */
+
+        DEBUG("SET FRAG value: %d\n", vwrq->value);
+
+        if ((nl->if_status == PC2400M_IF_UNINITIALIZED) ||
+                nl->wimax_closing_ongoing) 
+                ret = -EIO;
+        else if((vwrq->value <= PC2400M_CONF_WIMAX_MAX_MTU)&&
+                (vwrq->value >= PC2400M_CONF_WIMAX_MIN_MTU)) {
+                ret = PC2400M_IF_ALLA_OKKO;
+                dev->mtu = vwrq->value;
+        }
+
+        return ret;
+
+}
+
+/** Gets socket MTU value.
+ *
+ *  @param dev pointer to net device
+ *  @param info pointer to IOCTL info
+ *  @param wrqu pointer IOCTL parameters
+ *  @param extra pointer to extra data
+ *  @return 0 success, -EIO device uninitialized
+ */
+static int pc2400m_we_get_frag(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        struct iw_param *vwrq,
+        char *extra)
+{
+
+        struct net_local *nl = netdev_priv(dev);
+        int ret = PC2400M_IF_ALLA_OKKO;
+
+        PC2400M_UNWARN(extra);
+        PC2400M_UNWARN(info);
+
+        /* this ioctl is used to get the currently used
+           fragmentation threshold value */
+
+        DEBUG("GET FRAG value: %d\n", dev->mtu);
+
+        if ((nl->if_status == PC2400M_IF_UNINITIALIZED) ||
+                nl->wimax_closing_ongoing) 
+                ret = -EIO;
+
+        vwrq->value = dev->mtu;
+
+        return ret;
+
+}
+
+/** Set radio on off.
+ *  pc2400m has only support for setting this to enable/disable 
+ *
+ *  @param dev pointer to net device
+ *  @param info pointer to IOCTL info
+ *  @param wrqu pointer IOCTL parameters
+ *  @param extra pointer to extra data
+ *  @return 0 success, -EIO device uninitialized, -EINVAL invalid value
+ */
+static int pc2400m_we_set_txpower(
+        struct net_device *ndev,
+        struct iw_request_info *info,
+        struct iw_param *vwrq,
+        char *extra)
+{
+
+        struct net_local *nl = netdev_priv(ndev);
+        struct t_wihal_cmd cmd;
+        int ret = PC2400M_IF_ALLA_OKKO;
+        WIMAX_WAIT_RSP;
+
+        PC2400M_UNWARN(extra);
+        PC2400M_UNWARN(info);
+
+        /* this ioctl is used to control the transmit power used by the
+        chip, or to enable/disable the transmission altogether. */
+
+         if ((nl->if_status == PC2400M_IF_UNINITIALIZED) ||
+                nl->wimax_closing_ongoing) {
+                goto error2;
+        }
+
+        /* the requested transmit power is provided in dBm */
+
+        if (vwrq->disabled) {
+        /* here we should set radio off */
+                cmd.cmd_id = E_WIHAL_RADIO_STATE;
+                cmd.cmd.radio_state.radio_state = E_WIHAL_RADIO_STATE_OFF;
+
+                WIMAX_WAIT_CMD(ndev, &cmd);
+
+                DEBUG("RADIO OFF\n");
+        } else {
+                /* here we should set radio on */
+                cmd.cmd_id = E_WIHAL_RADIO_STATE;
+                cmd.cmd.radio_state.radio_state = E_WIHAL_RADIO_STATE_ON;
+
+                WIMAX_WAIT_CMD(ndev, &cmd);
+
+                DEBUG("RADIO ON\n");
+        }
+
+        if (pc2400m_complete.pc2400m_result != E_WIHAL_SUCCESS)
+                goto error1;
+        else
+                nl->radio_disabled = vwrq->disabled;
+
+        goto out;
+error2:
+        ret = -EIO;
+        goto out;
+error1:
+        ret = -EINVAL;
+out:
+        return ret;
+
+}
+
+/** Get state of radio.
+ * 
+ *  @param dev pointer to net device
+ *  @param info pointer to IOCTL info
+ *  @param wrqu pointer IOCTL parameters
+ *  @param extra pointer to extra data
+ *  @return 0 success, -EIO device uninitialized
+ */
+static int pc2400m_we_get_txpower(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        struct iw_param *vwrq,
+        char *extra)
+{
+
+        struct net_local *nl = netdev_priv(dev);
+        int ret = PC2400M_IF_ALLA_OKKO;
+        /* this ioctl is used to get the current txpower state, on or off*/
+        PC2400M_UNWARN(extra);
+        PC2400M_UNWARN(info);
+
+        DEBUG("GET TXPOWER \n");
+
+        if ((nl->if_status == PC2400M_IF_UNINITIALIZED) ||
+                nl->wimax_closing_ongoing) 
+                ret = -EIO;
+
+        vwrq->disabled = nl->radio_disabled;
+
+        return ret;
+}
+
+
+
+
+/* private IOCTL's */
+
+/** Starts network scanning.
+ *
+ *  @param dev pointer to net device
+ *  @param info pointer to IOCTL info
+ *  @param wrqu pointer IOCTL parameters
+ *  @param extra pointer to extra data
+ *  @return 0 success, -EIO device uninitialized, -EINVAL invalid values
+ */
+static int pc2400m_we_set_nap_scan(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra)
+{
+
+        struct net_local *nl = netdev_priv(dev);
+        struct we_wmx_wimax_scan_req *wmxscan = NULL;
+        struct we_wmx_channel_plan *struct_source = NULL;
+        struct t_wihal_search_plan *struct_dest = NULL;
+        u8 *u8_source = NULL;
+        u8 *u8_dest = NULL;
+        struct t_wihal_cmd cmd;
+        int res, ret = PC2400M_IF_ALLA_OKKO;
+        u32 i;
+        WIMAX_WAIT_RSP;
+
+        PC2400M_UNWARN(extra);
+        PC2400M_UNWARN(info);
+
+        DEBUG("set scan ->%s\n",dev->name);
+
+        if ((nl->if_status == PC2400M_IF_UNINITIALIZED) ||
+                nl->wimax_closing_ongoing) {
+                goto error2;
+        }
+
+        /* this ioctl is used to request the device to start scanning for
+        available networks. the IOCTL simply starts the scanning procedure,
+        the scan will complete later and userspace can poll for the results
+        via the get method of this ioctl.
+        */
+
+        wmxscan = kmalloc(wrqu->data.length,GFP_KERNEL| __GFP_NOFAIL);
+
+        res = copy_from_user(wmxscan,wrqu->data.pointer,wrqu->data.length);
+
+        BUG_ON(res);
+
+        if (wmxscan->start_stop == we_wmx_start) {
+
+                /* here we reset the previous scan list */
+                NL_PROT_ON;
+                nl->event_stream_len = 0;
+                kfree(nl->event_stream);
+                nl->event_stream = NULL;
+                NL_PROT_OFF;
+                cmd.cmd.search_nap.p_search_plan =
+                        kmalloc(wmxscan->num_channel_plans *
+                                sizeof(struct t_wihal_search_plan),
+                                GFP_KERNEL| __GFP_NOFAIL);
+
+                cmd.cmd.search_nap.search_plan_count =
+                        wmxscan->num_channel_plans;
+
+                u8_dest = (u8 *)cmd.cmd.search_nap.p_search_plan;
+                u8_source = (u8 *)wmxscan->channel_plan_list;
+
+                struct_source = kmalloc(
+                        sizeof(struct we_wmx_channel_plan),
+                               GFP_KERNEL | __GFP_NOFAIL);
+
+                struct_dest = kmalloc(
+                        sizeof(struct t_wihal_search_plan),
+                               GFP_KERNEL| __GFP_NOFAIL);
+
+                for (i = 1; i <= wmxscan->num_channel_plans; i++) {
+
+                        memcpy(struct_source,u8_source,
+                               sizeof(struct we_wmx_channel_plan));
+
+                        if (channel_plan_to_wihal(struct_source,
+                            struct_dest,
+                            nl)) {
+                                DEBUG("channel_plan to wihal failed\n");
+                                kfree(cmd.cmd.search_nap.p_search_plan);
+                                goto error1;
+                        }
+
+                        memcpy(u8_dest,
+                               struct_dest,
+                               sizeof(struct t_wihal_search_plan));
+
+                        u8_dest += (sizeof(struct t_wihal_search_plan));
+                        u8_source += (sizeof(struct we_wmx_channel_plan));
+                }
+
+                cmd.cmd_id = E_WIHAL_SEARCH_NAP;
+                WIMAX_NO_WAIT_CMD(dev, &cmd);
+                kfree(cmd.cmd.search_nap.p_search_plan);
+
+                DEBUG("scan started num chnlplans %02x\n",
+                      wmxscan->num_channel_plans);
+        } else {
+                cmd.cmd_id = E_WIHAL_SEARCH_NAP_STOP;
+                WIMAX_WAIT_CMD(dev, &cmd);
+                DEBUG("scan stopped\n");
+        }
+        goto out;
+error2:
+        ret = -EIO;
+        goto out;
+error1:
+        ret = -EINVAL;
+out:
+        kfree(struct_source);
+        kfree(struct_dest);
+        kfree(wmxscan);
+
+        return ret;
+
+}
+
+/** Host asks for scan results.
+ *  if host doesn't deliver enough memory -E2BIG is returned.
+ *
+ *  @param dev pointer to net device
+ *  @param info pointer to IOCTL info
+ *  @param wrqu pointer IOCTL parameters
+ *  @param extra pointer to extra data
+ *  @return 0 success, -EIO device uninitialized, -E2BIG not enough memory
+ *          received
+ */
+static int pc2400m_we_get_nap_scan(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra)
+{
+
+        struct net_local *nl = netdev_priv(dev);
+        int res,ret = PC2400M_IF_ALLA_OKKO;
+
+        PC2400M_UNWARN(extra);
+        PC2400M_UNWARN(info);
+
+        /* this IOCTL is used to return scan results once scanning for
+        networks has been completed or requested */
+
+        DEBUG("GET SCAN\n");
+
+        if ((nl->if_status == PC2400M_IF_UNINITIALIZED) ||
+                nl->wimax_closing_ongoing) {
+                goto error2;
+        }
+
+        /* Return scanning result so far with this function
+           If we do not get enough memory from user space
+           we will ask for more */
+        NL_PROT_ON;
+        if (nl->event_stream_len > wrqu->data.length) {
+                wrqu->data.length = nl->event_stream_len;
+                NL_PROT_OFF;
+                goto error1;
+        }
+
+        res = copy_to_user(wrqu->data.pointer,
+                           nl->event_stream,
+                           nl->event_stream_len);
+
+        BUG_ON(res);
+
+        wrqu->data.length = nl->event_stream_len;
+        wrqu->data.flags = 0;
+
+        DEBUG("returned scan result len:%08x\n",nl->event_stream_len);
+        NL_PROT_OFF;
+        goto out;
+error2:
+        ret = -EIO;
+        goto out;
+error1:
+        ret = -E2BIG;
+out:
+        return ret;
+
+}
+
+/** Configures devices wimax parameters.
+ *
+ *  @param dev pointer to net device
+ *  @param info pointer to IOCTL info
+ *  @param wrqu pointer IOCTL parameters
+ *  @param extra pointer to extra data
+ *  @return always 0
+ */
+
+static int pc2400m_we_configure(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra)
+{
+        struct net_local *nl = netdev_priv(dev);
+        struct we_wmx_wimax_conf wmx_conf;
+        struct t_wihal_cmd cmd;
+        int res;
+
+        PC2400M_UNWARN(extra);
+        PC2400M_UNWARN(info);
+
+        res = copy_from_user(&wmx_conf,
+                             wrqu->data.pointer,
+                             sizeof(struct we_wmx_wimax_conf));
+
+        /* the bit values are one higher in WE than in WiHAL */
+        cmd.cmd.configure.config_mask =
+                wmx_conf.config_mask >> 1;
+
+        if ((nl->if_status == PC2400M_IF_UNINITIALIZED) ||
+                nl->wimax_closing_ongoing) {
+                /* these values can only be set before the driver is initialized
+                   - setting it here will make it set as default upon opening
+                   the driver instance */
+                if (cmd.cmd.configure.config_mask & 
+                    E_WIHAL_CONFIG_MASK_IDLE_TIMER) {
+                        nl->idle_timer = wmx_conf.idle_timer;
+                        nl->validity |= PC2400M_IF_VALID_IDLE_TIMER;
+                }
+                if (cmd.cmd.configure.config_mask & 
+                    E_WIHAL_CONFIG_MASK_SLEEP_TIMER) {
+                        nl->sleep_timer = wmx_conf.sleep_timer;
+                        nl->validity |= PC2400M_IF_VALID_SLEEP_TIMER;
+                }
+                if (cmd.cmd.configure.config_mask & 
+                    E_WIHAL_CONFIG_MASK_SIGNAL_RECOVERY_LIMIT) {
+                        nl->signal_recovery_limit = 
+                                wmx_conf.signal_recovery_limit;
+                        nl->validity |= PC2400M_IF_VALID_SIGNAL_RECOVERY_LIMIT;
+                }
+                if (cmd.cmd.configure.config_mask & 
+                    E_WIHAL_CONFIG_MASK_IDLE_PAGING_INTERVAL) {
+                        nl->idle_paging_interval = 
+                                wmx_conf.idle_paging_interval;
+                        nl->validity |= PC2400M_IF_VALID_IDLE_PAGING_INTERVAL;
+                }
+
+        }
+
+        /* in this configure message, the initialization is never sent to the
+           driver so remove them from the config mask */
+        cmd.cmd.configure.config_mask &=
+                (E_WIHAL_CONFIG_MASK_HANDOVER_LOCK|
+                 E_WIHAL_CONFIG_MASK_BS_ID);
+
+        if (wmx_conf.handover_lock == we_wmx_na)
+                cmd.cmd.configure.handover_scheme =
+                        E_WIHAL_HANDOVER_SCHEME_NORMAL;
+        else
+                cmd.cmd.configure.handover_scheme =
+                        E_WIHAL_HANDOVER_SCHEME_BS_LOCK;
+
+        memcpy(cmd.cmd.configure.bsid, wmx_conf.bs_id, WE_WMX_WIMAX_BSID_LEN);
+
+        /* if the configure is performed before opening the interface,
+           it cannot be done as the driver is unitialized */
+        if ((nl->if_status == PC2400M_IF_UNINITIALIZED) ||
+                nl->wimax_closing_ongoing) {
+                DEBUG("WiMAX configuration deferred\n");
+        } else {
+                /* Setting not used fields as invalid */
+                DEBUG("WiHAL Configuration send to chipset!\n");
+                cmd.cmd.configure.idle_timer = 0;
+                cmd.cmd.configure.signal_recovery_limit = 0;
+                cmd.cmd_id = E_WIHAL_CONFIGURE;
+
+                WIMAX_NO_WAIT_CMD(dev, &cmd);
+        }
+
+        return 0;
+}
+
+/** For converting channel plan to WiHAL format 
+ *
+ *  @param source pointer to we channel plan
+ *  @param dest pointer to destination
+ *  @param nl pointer to net local of device
+ *  @return 0 success, -EINVAL invalid input values
+ */
+static int channel_plan_to_wihal(
+        struct we_wmx_channel_plan *source,
+        struct t_wihal_search_plan *dest,
+        struct net_local *nl)
+{
+        int ret = 0;
+
+        switch (source->channel_bandwidth) {
+        case WE_WMX_MHZ_3_5:
+                dest->channel_bandwidth =
+                        E_WIHAL_CHANNEL_BANDWIDTH_3_5MHZ;
+                break;
+        case WE_WMX_MHZ_5:
+                dest->channel_bandwidth =
+                        E_WIHAL_CHANNEL_BANDWIDTH_5MHZ;
+                break;
+        case WE_WMX_MHZ_7:
+                dest->channel_bandwidth =
+                        E_WIHAL_CHANNEL_BANDWIDTH_7MHZ;
+                break;
+        case WE_WMX_MHZ_8_75:
+                dest->channel_bandwidth =
+                        E_WIHAL_CHANNEL_BANDWIDTH_8_75MHZ;
+                break;
+        case WE_WMX_MHZ_10:
+                dest->channel_bandwidth =
+                        E_WIHAL_CHANNEL_BANDWIDTH_10MHZ;
+                break;
+        default:
+                nl->errcod = we_wmx_invalid_input_value;
+                DEBUG("Invalid values for bw\n");
+                goto error1;
+                break;
+        }
+
+        switch (source->fft_size) {
+        case WE_WMX_FFT_512:
+                dest->fft_size =
+                        E_WIHAL_FFT_SIZE_512;
+                break;
+        case WE_WMX_FFT_1024:
+                dest->fft_size =
+                        E_WIHAL_FFT_SIZE_1024;
+                break;
+        default:
+                nl->errcod = we_wmx_invalid_input_value;
+                DEBUG("Invalid values for fft\n");
+                goto error1;
+                break;
+        }
+
+        memcpy(dest->preamble, source->preamble, WE_WMX_PREAMBLE_SIZE);
+
+        dest->carrier_freq = source->carrier_freq;
+
+        goto out;
+error1:
+        ret = -EINVAL;
+out:
+        return ret;
+}
+
+/** Get nsps info for nap.
+ *
+ *  @param dev pointer to net device
+ *  @param info pointer to IOCTL info
+ *  @param wrqu pointer IOCTL parameters
+ *  @param extra pointer to extra data
+ *  @return 0 success. -EIO device uninitialized
+ */
+static int pc2400m_we_set_nsp_scan(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra)
+{
+
+        struct net_local *nl = netdev_priv(dev);
+        struct we_wmx_nsp_search_req *nsp_srch_req = NULL;
+        struct t_wihal_cmd cmd;
+        int res, ret = 0;
+        WIMAX_WAIT_RSP;
+
+        PC2400M_UNWARN(extra);
+        PC2400M_UNWARN(info);
+
+        if ((nl->if_status == PC2400M_IF_UNINITIALIZED) ||
+                nl->wimax_closing_ongoing) {
+                goto error1;
+        }
+
+        nsp_srch_req = kmalloc(sizeof(struct we_wmx_nsp_search_req),
+                               GFP_KERNEL | __GFP_NOFAIL);
+
+        res = copy_from_user(nsp_srch_req,
+                             wrqu->data.pointer,
+                             sizeof(struct we_wmx_nsp_search_req));
+
+        if (nsp_srch_req->start_stop == we_wmx_start) {
+                cmd.cmd.search_nsp.nap_id = nsp_srch_req->nap_id;
+                if (nsp_srch_req->nap_mask == we_wmx_nap_id_full)
+                        cmd.cmd.search_nsp.nap_id_mask = 
+                                E_WIHAL_NAP_ID_MASK_FULL;
+                else
+                        cmd.cmd.search_nsp.nap_id_mask = 
+                                E_WIHAL_NAP_ID_MASK_COMPRESSED;
+
+                ret = channel_plan_to_wihal(&nsp_srch_req->channel_plan,
+                        &cmd.cmd.search_nsp.channel, nl);
+
+                cmd.cmd.search_nsp.nsp_change_count_valid =
+                        nsp_srch_req->nsp_cc_valid;
+                cmd.cmd.search_nsp.nsp_change_count =
+                        nsp_srch_req->nsp_cc;
+                cmd.cmd.search_nsp.search_nsp_info =
+                        nsp_srch_req->nsp_info;
+
+                cmd.cmd_id = E_WIHAL_SEARCH_NSP;
+                WIMAX_NO_WAIT_CMD(dev, &cmd);
+                DEBUG("Wimax nsp search started fo NAP:%08x\n",
+                      nsp_srch_req->nap_id);
+        } else {
+                cmd.cmd_id = E_WIHAL_SEARCH_NSP_STOP;
+                WIMAX_WAIT_CMD(dev, &cmd);
+                DEBUG("Wimax nsp search stopped\n");
+        }
+        goto out;
+error1:
+        ret = -EIO;
+out:
+        kfree(nsp_srch_req);
+
+        return ret;
+}
+
+/** Get nsps info for nap.
+ *
+ *  @param dev pointer to net device
+ *  @param info pointer to IOCTL info
+ *  @param wrqu pointer IOCTL parameters
+ *  @param extra pointer to extra data
+ *  @return 0 success. -EIO device uninitialized, -E2BIG not enough memory
+ *          received
+ */
+static int pc2400m_we_get_nsp_scan(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra)
+{
+
+        struct net_local *nl = netdev_priv(dev);
+        struct we_wmx_nsp_search_resp *nsp_srch_rsp;
+        struct we_wmx_nsp_list_str *nsp_list;
+        int ret = 0;
+        u32 i, size;
+
+        PC2400M_UNWARN(extra);
+        PC2400M_UNWARN(info);
+
+        NL_PROT_ON;
+
+        if ((nl->if_status == PC2400M_IF_UNINITIALIZED) ||
+                nl->wimax_closing_ongoing) {
+                goto error1;
+        }
+
+        if (!nl->nsp_rsp) {
+                goto error1;
+        }
+
+        size = (sizeof(struct we_wmx_nsp_search_resp) +
+                sizeof(struct we_wmx_nsp_list_str) *
+                nl->nsp_rsp->nsp_count);
+
+        if (size > wrqu->data.length) {
+                goto error2;
+        }
+
+        /* allocate memory for the response */
+        nsp_srch_rsp = (struct we_wmx_nsp_search_resp*)
+                        kmalloc(size, GFP_KERNEL | __GFP_NOFAIL);
+
+        nsp_srch_rsp->nap_id = nl->nsp_rsp->nap_id;
+        switch (nl->nsp_rsp->nap_and_nsp) {
+        case E_WIHAL_NAP_AND_NSP_TRUE:
+                nsp_srch_rsp->nap_nsp = we_wmx_equals;
+                break;
+        case E_WIHAL_NAP_AND_NSP_FALSE:
+                nsp_srch_rsp->nap_nsp = we_wmx_many_nsps;
+                break;
+        default:
+                BUG_ON(nl->nsp_rsp->nap_and_nsp != E_WIHAL_NAP_AND_NSP_NA);
+                nsp_srch_rsp->nap_nsp = we_wmx_no_info;
+                break;
+        }
+
+        nsp_srch_rsp->nsp_cc = nl->nsp_rsp->nsp_change_count;
+        nsp_srch_rsp->nbr_of_nsps = nl->nsp_rsp->nsp_count;
+        nsp_list = (struct we_wmx_nsp_list_str *)nsp_srch_rsp->nsp_list;
+
+        for(i = 0;i < nl->nsp_rsp->nsp_count; i++) {
+                nsp_list[i].name_len = nl->nsp_rsp->p_nsp[i].nsp_name_len;
+                nsp_list[i].nsp_id = nl->nsp_rsp->p_nsp[i].nsp_id;
+
+                /* the data type of "nsp_name_len" below is u8, which is
+                   why it never exceeds the maximum size reserved in
+                   "nsp_name." */
+                memset(nsp_list[i].nsp_name, 0x00, WE_WMX_NSP_NAME_MAX_LEN);
+                memcpy(nsp_list[i].nsp_name,
+                       nl->nsp_rsp->p_nsp[i].p_nsp_name,
+                       nl->nsp_rsp->p_nsp[i].nsp_name_len);
+        }
+
+        wrqu->data.length = size;
+        ret = copy_to_user(wrqu->data.pointer, nsp_srch_rsp, size);
+
+        kfree(nsp_srch_rsp);
+
+        for(i=0; i < nl->nsp_rsp->nsp_count; i++)
+                kfree(nl->nsp_rsp->p_nsp[i].p_nsp_name);
+        kfree(nl->nsp_rsp->p_nsp);
+        kfree(nl->nsp_rsp);
+        nl->nsp_rsp = NULL;
+        goto out;
+error2:
+        ret = -E2BIG;
+        goto out;
+error1:
+        ret = -EIO;
+out:
+        NL_PROT_OFF;
+        return ret;
+}
+
+/** Saves EAP key to device.
+ *
+ *  @param dev pointer to net device
+ *  @param info pointer to IOCTL info
+ *  @param wrqu pointer IOCTL parameters
+ *  @param extra pointer to extra data
+ *  @return 0 success. -EIO device uninitialized
+ */
+static int pc2400m_we_set_eap_result(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra)
+{
+
+        struct net_local *nl = netdev_priv(dev);
+        struct we_wmx_eap_result *result;
+        struct t_wihal_cmd cmd;
+        int ret = PC2400M_IF_ALLA_OKKO;
+
+        PC2400M_UNWARN(extra);
+        PC2400M_UNWARN(info);
+
+        if ((nl->if_status == PC2400M_IF_UNINITIALIZED) ||
+                nl->wimax_closing_ongoing) {
+                goto error1;
+        }
+
+        /* this ioctl is used by userspace to set eap success */
+        result = (struct we_wmx_eap_result *)wrqu->data.pointer;
+        if (result->eap_success) {
+                DEBUG("Setting msk\n");
+                ret = copy_from_user(cmd.cmd.eap_result.msk,
+                                     (void *)(&result->p_msk[0]),
+                                      WIHAL_MSK_LENGTH);
+
+                cmd.cmd.eap_result.success = E_WIHAL_TRUE;
+        } else {
+                DEBUG("Setting eap failure\n");
+                cmd.cmd.eap_result.success = E_WIHAL_FALSE;
+        }
+
+        cmd.cmd_id = E_WIHAL_EAP_RESULT;
+        WIMAX_NO_WAIT_CMD(dev, &cmd);
+        goto out;
+error1:
+        ret = -EIO;
+out:
+        return ret;
+
+}
+
+/** Get bsid of connection.
+ *
+ *  @param dev pointer to net device
+ *  @param info pointer to IOCTL info
+ *  @param wrqu pointer IOCTL parameters
+ *  @param extra pointer to extra data
+ *  @return 0 success, -EIO device ininitialized, -EFAULT connection error,
+ *          -E2BIG not enough memory received
+ */
+static int pc2400m_we_get_bsinfo(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra)
+{
+
+        struct net_local *nl = netdev_priv(dev);
+        int ret = PC2400M_IF_ALLA_OKKO;
+        struct t_wihal_cmd cmd;
+        struct we_wmx_wimax_bsinfo *bsinfo;
+        WIMAX_WAIT_RSP;
+
+        PC2400M_UNWARN(extra);
+        PC2400M_UNWARN(info);
+
+        if ((nl->if_status == PC2400M_IF_UNINITIALIZED) ||
+                nl->wimax_closing_ongoing) {
+                goto error2;
+        }
+        if (wrqu->data.length < sizeof(struct we_wmx_wimax_bsinfo)) {
+                goto error3;
+        }
+        if (nl->if_status == PC2400M_IF_CONNECTED) {
+                cmd.cmd_id = E_WIHAL_NETWORK_STATUS;
+                WIMAX_WAIT_CMD(nl->net_dev, &cmd);
+
+                NL_PROT_ON;
+                if (nl->errcod == we_wmx_device_in_invalid_state) {
+                        NL_PROT_OFF;
+                        goto error1;
+                }
+                NL_PROT_OFF;
+        }
+
+        bsinfo = wrqu->data.pointer;
+
+        bsinfo->nap_nsp = nl->nap_nsp;
+
+        if (nl->channel_plan) {
+                memcpy(&bsinfo->channel_plan,
+                       nl->channel_plan,
+                       sizeof(struct we_wmx_channel_plan));
+        } else {
+                memset(&bsinfo->channel_plan,
+                       0,
+                       sizeof(struct we_wmx_channel_plan));
+        }
+        memcpy(bsinfo->bs_id,
+               nl->bsid,
+               WE_WMX_WIMAX_BSID_LEN);
+
+        goto out;
+error3:
+        ret = -E2BIG;
+        goto out;
+error2:
+        ret = -EIO;
+        goto out;
+error1:
+        ret = -EFAULT;
+out:
+        return ret;
+}
+
+/** Disconnects from nw.
+ *
+ *  @param dev pointer to net device
+ *  @param info pointer to IOCTL info
+ *  @param wrqu pointer IOCTL parameters
+ *  @param extra pointer to extra data
+ *  @return 0 success, -EIO device ininitialized, -EFAULT connection error
+ */
+static int pc2400m_we_disconnect(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra)
+{
+
+        struct net_local *nl = netdev_priv(dev);
+        struct t_wihal_cmd cmd;
+        int ret = PC2400M_IF_ALLA_OKKO;
+        WIMAX_WAIT_RSP;
+
+        PC2400M_UNWARN(extra);
+        PC2400M_UNWARN(info);
+        PC2400M_UNWARN(wrqu);
+
+        if ((nl->if_status == PC2400M_IF_UNINITIALIZED) ||
+                nl->wimax_closing_ongoing) {
+                goto error2;
+        }
+
+        /*disconnect*/
+        cmd.cmd_id = E_WIHAL_EXIT;
+        WIMAX_WAIT_CMD(dev, &cmd);
+        /* At currently there is no "NO NAP" value and thus we set NAP only to
+           0 */
+        nl->nap = 0;
+        /* save nap and quality to netlocal */
+        if (pc2400m_complete.pc2400m_result != E_WIHAL_SUCCESS) {
+                goto error1;
+        }
+        goto out;
+error2:
+        ret = -EIO;
+        goto out;
+error1:
+        ret = -EFAULT;
+out:
+        DEBUG("Disconnecting\n");
+
+        return ret;
+
+}
+
+/** Returns codes for failures.
+ *
+ *  @param dev pointer to net device
+ *  @param info pointer to IOCTL info
+ *  @param wrqu pointer IOCTL parameters
+ *  @param extra pointer to extra data
+ *  @return always 0
+ */
+static int pc2400m_we_get_error_code(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra)
+{
+
+        struct net_local *nl = netdev_priv(dev);
+        struct we_wmx_err_cod *errcod = (struct we_wmx_err_cod *)
+                wrqu->data.pointer;
+        int ret = PC2400M_IF_ALLA_OKKO;
+
+        PC2400M_UNWARN(extra);
+        PC2400M_UNWARN(info);
+
+        DEBUG("Get error code\n");
+
+	if(wrqu->data.length < sizeof(struct we_wmx_err_cod)) {
+
+	        goto error;
+	}
+
+        errcod->err_code = nl->errcod;
+
+        nl->errcod = we_wmx_no_error;
+
+	goto out;
+ error:
+        ret = -E2BIG;
+
+ out:
+        return ret;
+
+}
+
+
+/** Connect to a network.
+ *
+ *  @param dev pointer to net device
+ *  @param info pointer to IOCTL info
+ *  @param wrqu pointer IOCTL parameters
+ *  @param extra pointer to extra data
+ *  @return 0 success, -EIO device ininitialized, -EFAULT connection error
+ */
+static int pc2400m_we_connect(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra)
+{
+
+        struct net_local *nl = netdev_priv(dev);
+        struct t_wihal_cmd cmd;
+        struct we_wmx_connect *wmx_cnt = 
+	       (struct we_wmx_connect *)wrqu->data.pointer;
+        int ret = PC2400M_IF_ALLA_OKKO;
+        WIMAX_WAIT_RSP;
+
+        PC2400M_UNWARN(extra);
+        PC2400M_UNWARN(info);
+
+        if ((nl->if_status == PC2400M_IF_UNINITIALIZED) ||
+                nl->wimax_closing_ongoing) {
+                goto error1;
+        }
+        /* this ioctl is used by userspace to request a specific nap
+        to be used for connectivity. */
+        DEBUG("Entering nap:%08x nsp:%08x\n",
+              wmx_cnt->nap_id,
+              wmx_cnt->nsp_id);
+
+        cmd.cmd.entry.nap_id = wmx_cnt->nap_id;
+        if (wmx_cnt->nap_mask == we_wmx_nap_id_full)
+                cmd.cmd.entry.nap_id_mask = E_WIHAL_NAP_ID_MASK_FULL;
+        else
+                cmd.cmd.entry.nap_id_mask = E_WIHAL_NAP_ID_MASK_COMPRESSED;
+
+        channel_plan_to_wihal(&wmx_cnt->channel_plan,
+                              &cmd.cmd.entry.channel,
+                              nl);
+
+        cmd.cmd.entry.nsp_id = wmx_cnt->nsp_id;
+        cmd.cmd.entry.realm_req = wmx_cnt->request_realm;
+
+        cmd.cmd_id = E_WIHAL_ENTRY;
+
+        WIMAX_WAIT_CMD(dev, &cmd);
+
+        DEBUG("Entry status:%02x\n",
+              pc2400m_complete.pc2400m_result);
+
+        if (pc2400m_complete.pc2400m_result != E_WIHAL_SUCCESS) {
+                goto error2;
+        }
+        goto out;
+error2:
+        ret = -EFAULT;
+        goto out;
+error1:
+        ret = -EIO;
+out:
+        return ret;
+
+}
+
+/** Get the realm of nsp.
+ *
+ *  @param dev pointer to net device
+ *  @param info pointer to IOCTL info
+ *  @param wrqu pointer IOCTL parameters
+ *  @param extra pointer to extra data
+ *  @return 0 success, -EIO device ininitialized
+ */
+static int pc2400m_we_get_nsp_realm(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra)
+{
+
+        struct net_local *nl = netdev_priv(dev);
+        struct we_wmx_realm *nsprealm = 
+                (struct we_wmx_realm *)wrqu->data.pointer;
+        int ret = PC2400M_IF_ALLA_OKKO;
+
+        PC2400M_UNWARN(extra);
+        PC2400M_UNWARN(info);
+
+	if (wrqu->data.length < (nl->nsp_realm_len + 
+				 sizeof(struct we_wmx_realm))) {
+	        goto error2;
+	}
+        if ((nl->if_status == PC2400M_IF_UNINITIALIZED) ||
+                nl->wimax_closing_ongoing) {
+
+                goto error1;
+        }
+
+        NL_PROT_ON;
+        nsprealm->realm_len = nl->nsp_realm_len;
+        memcpy(nsprealm->realm_name,
+               nl->p_nsp_realm,
+               nsprealm->realm_len);
+        NL_PROT_OFF;
+        DEBUG("Get nsp realm\n");
+        goto out;
+ error2:
+	ret = -E2BIG;
+	goto out;
+ error1:
+        ret = -EIO;
+ out:
+        return ret;
+}
+
+
+/** Returns device information.
+ *
+ *  @param info_array pointer to tlvs
+ *  @param type tlv type
+ *  @param len length of data to be added
+ *  @param data pointer to data to be added
+ *  @param wrqu pointer IOCTL parameters
+ *  @return pointer to next empty tlv space
+ */
+static struct we_wmx_tlv *pc2400m_add_devinfo_tlv(
+        struct we_wmx_tlv *info_array,
+        enum we_wmx_dev_info_type type,
+        u32 tlv_len,
+        void *tlv_data,
+        union iwreq_data *wrqu)
+{
+
+        info_array->type = type;
+        info_array->len = tlv_len;
+        memcpy(info_array->values, tlv_data, tlv_len);
+
+#define WE_TLV_HDR_LEN 8
+        wrqu->data.length += (WE_TLV_HDR_LEN + info_array->len);
+
+        return (struct we_wmx_tlv *)((void *)info_array + WE_TLV_HDR_LEN +
+               info_array->len);
+}
+
+/** Returns device information.
+ *
+ *  @param dev pointer to net device
+ *  @param info pointer to IOCTL info
+ *  @param wrqu pointer IOCTL parameters
+ *  @param extra pointer to extra data
+ *  @return 0 success, -EIO if uninitialized, -E2BIG if not enough memory
+ *          delivered
+ */
+static int pc2400m_we_devinfo(
+        struct net_device *dev,
+        struct iw_request_info *info,
+        union iwreq_data *wrqu,
+        char *extra)
+{
+
+        struct net_local *nl = netdev_priv(dev);
+        struct we_wmx_tlv *info_array = 
+                (struct we_wmx_tlv *)wrqu->data.pointer;
+        int max_len,ret = PC2400M_IF_ALLA_OKKO;
+
+        PC2400M_UNWARN(extra);
+        PC2400M_UNWARN(info);
+
+        if ((nl->if_status == PC2400M_IF_UNINITIALIZED) ||
+                nl->wimax_closing_ongoing) {
+                goto error1;
+        }
+
+        max_len = (PC2400M_CONF_MODEL_STR_LEN + WE_TLV_HDR_LEN +
+                   PC2400M_CONF_MANUFACTURER_STR_LEN + WE_TLV_HDR_LEN +
+                   PC2400M_CONF_RELEASE_STR_LEN + WE_TLV_HDR_LEN +
+                   PC2400M_CONF_HW_FW_VERSION_STR_LEN + WE_TLV_HDR_LEN +
+                   PC2400M_CONF_HW_FW_VERSION_STR_LEN + WE_TLV_HDR_LEN +
+                   PC2400M_CONF_SERIAL_NBR_STR_LEN + WE_TLV_HDR_LEN +
+                   PC2400M_CONF_WE_API_VRS_STR_LEN + WE_TLV_HDR_LEN);
+
+        if (wrqu->data.length < max_len) {
+
+                goto error2;
+        }
+
+        NL_PROT_ON;
+
+        wrqu->data.length = 0;
+
+        /* model version */
+        info_array = pc2400m_add_devinfo_tlv(
+                info_array,
+                we_wmx_model_name,
+                PC2400M_CONF_MODEL_STR_LEN,
+                nl->model_vrs,
+                wrqu);
+        /* manufacturer version */
+        info_array = pc2400m_add_devinfo_tlv(
+                info_array,
+                we_wmx_manufacturer,
+                PC2400M_CONF_MANUFACTURER_STR_LEN,
+                nl->manufacturer_vrs,
+                wrqu);
+        /* api version */
+        info_array = pc2400m_add_devinfo_tlv(
+                info_array,
+                we_wmx_driver_api,
+                PC2400M_CONF_WE_API_VRS_STR_LEN,
+                PC2400M_CONF_WE_API_VRS,
+                wrqu);
+        /* fw version */
+        info_array = pc2400m_add_devinfo_tlv(
+                info_array,
+                we_wmx_fw,
+                PC2400M_CONF_HW_FW_VERSION_STR_LEN,
+                nl->fw_vrs,
+                wrqu);
+        /* hw version */
+        info_array = pc2400m_add_devinfo_tlv(
+                info_array,
+                we_wmx_hw,
+                PC2400M_CONF_HW_FW_VERSION_STR_LEN,
+                nl->hw_vrs,
+                wrqu);
+        /* serial number */
+        info_array = pc2400m_add_devinfo_tlv(
+                info_array,
+                we_wmx_serial_number,
+                PC2400M_CONF_SERIAL_NBR_STR_LEN,
+                nl->serial_nbr,
+                wrqu);
+        /* release version */
+       info_array = pc2400m_add_devinfo_tlv(info_array,
+                                             we_wmx_release_version,
+                                             PC2400M_CONF_RELEASE_STR_LEN,
+                                             nl->release_vrs,
+                                             wrqu);
+
+        NL_PROT_OFF;
+        DEBUG("Get device info\n");
+
+        goto out;
+error2:
+        ret = -E2BIG;
+        goto out;
+error1:
+        ret = -EIO;
+out:
+        return ret;
+}
+
+/** Find_nap_from_stream.
+ * stream points to first empty space.
+ *
+ * @param stream pointer to stream of events
+ * @param stream_len Original stream length
+ * @return always 0
+ */
+static int last_nap_from_stream(
+        char ** stream,
+        int stream_len)
+{
+
+        struct iw_event *iwe;
+        char *temp_st;
+
+        /* Extract the event header (to get the event id).
+         * Note : the event may be unaligned, therefore copy... */
+        temp_st = *stream;
+        while (temp_st < (char *)(*stream + stream_len))
+        {
+                iwe = (struct iw_event *)temp_st;
+                temp_st += iwe->len;
+        }
+
+
+        *stream = temp_st;
+
+        return 0;
+}
+
+/*****************************************************************************
+ * Exported functions
+ */
+
+/** For converting channel plan to WE format.
+ *
+ *  @param source pointer to WiHAL channel plan
+ *  @param dest pointer to destination
+ *  @param nl pointer to net local of device
+ *  @return 0 success, -EINVAL invalid values fail
+ */
+int channel_plan_from_wihal(
+        struct t_wihal_search_plan *source,
+        struct we_wmx_channel_plan *dest,
+        struct net_local *nl)
+{
+        int ret = 0;
+
+        switch (source->channel_bandwidth) {
+        case E_WIHAL_CHANNEL_BANDWIDTH_3_5MHZ:
+                dest->channel_bandwidth =
+                        WE_WMX_MHZ_3_5;
+                break;
+        case E_WIHAL_CHANNEL_BANDWIDTH_5MHZ:
+                dest->channel_bandwidth =
+                        WE_WMX_MHZ_5;
+                break;
+        case E_WIHAL_CHANNEL_BANDWIDTH_7MHZ:
+                dest->channel_bandwidth =
+                        WE_WMX_MHZ_7;
+                break;
+        case E_WIHAL_CHANNEL_BANDWIDTH_8_75MHZ:
+                dest->channel_bandwidth =
+                        WE_WMX_MHZ_8_75;
+                break;
+        case E_WIHAL_CHANNEL_BANDWIDTH_10MHZ:
+                dest->channel_bandwidth =
+                        WE_WMX_MHZ_10;
+                break;
+        default:
+                nl->errcod = we_wmx_invalid_input_value;
+                DEBUG("Invalid values for bw\n");
+                goto error1;
+                break;
+        }
+
+        switch (source->fft_size) {
+        case E_WIHAL_FFT_SIZE_512:
+                dest->fft_size =
+                        WE_WMX_FFT_512;
+                break;
+        case E_WIHAL_FFT_SIZE_1024:
+                dest->fft_size =
+                        WE_WMX_FFT_1024;
+                break;
+        default:
+                nl->errcod = we_wmx_invalid_input_value;
+                DEBUG("Invalid values for fft\n");
+                goto error1;
+                break;
+        }
+
+        memcpy(dest->preamble, source->preamble, WE_WMX_PREAMBLE_SIZE);
+
+        dest->carrier_freq = source->carrier_freq;
+
+        goto out;
+error1:
+        ret = -EINVAL;
+out:
+        return ret;
+}
+
+/** Sends custom event to host
+ *
+ *  @param dev pointer to net device
+ *  @param str IWECUSTOM event to send
+ *  @return none
+ */
+void pc2400m_send_simple_event(struct net_device *dev, const char *str)
+{
+        union iwreq_data wrqu;
+        int n = strlen(str);
+
+        wrqu.data.pointer = kmalloc(IW_CUSTOM_MAX, GFP_KERNEL | __GFP_NOFAIL);
+
+        BUG_ON(n > IW_CUSTOM_MAX);
+        wrqu.data.length = n;
+        strcpy(wrqu.data.pointer, str);
+        DEBUG("send evlen:%d\n",n);
+        wireless_send_event(dev, IWEVCUSTOM, &wrqu, wrqu.data.pointer);
+        kfree(wrqu.data.pointer);
+
+        return ;
+}
+
+/** This functions saves received results.
+ *
+ *  @param resp result to save
+ *  @param dev pointer to net device
+ *  @return always 0
+ */
+int pc2400m_we_scan_result(
+        struct t_wihal_ind_search_nap *resp,
+        struct net_device *dev)
+{
+
+        struct net_local *nl = netdev_priv(dev);
+        struct iw_event *iwe;
+        char *current_ev, *nlevtmp;
+        struct t_wihal_search_result *search_result;
+        struct we_wmx_get_nap *nap_struct;
+        u32 i;
+
+        DEBUG("RECEIVED SCAN RESULT\n");
+        NL_PROT_ON;
+        if (!nl->event_stream)
+        {
+                nl->event_stream = kmalloc(PC2400M_CONF_EV_BUFF,GFP_KERNEL |
+                                           __GFP_NOFAIL);
+
+                nl->event_stream_len = 0;
+                nl->event_stream_maxlen = PC2400M_CONF_EV_BUFF;
+        }
+
+
+        DEBUG("result count %02x\n",resp->result_count);
+        for (i = 0;i < resp->result_count;i++)
+        {
+                current_ev = nl->event_stream;
+                search_result = &(resp->p_search_result[i]);
+
+                /* find this nap from stream or last event */
+                last_nap_from_stream(&current_ev,
+                                     nl->event_stream_len);
+
+                /* check that we have enough buffer*/
+                if (nl->event_stream_maxlen < (int)(
+                    IW_EV_LCP_LEN +
+                    sizeof(struct we_wmx_get_nap) +
+                    IW_EV_QUAL_LEN +
+                    nl->event_stream_len))
+                {
+                        DEBUG("SCAN BUFFER EXPANDED\n");
+                        nlevtmp = kmalloc(nl->event_stream_len +
+                                PC2400M_CONF_EV_BUFF,
+                                GFP_KERNEL | __GFP_NOFAIL);
+
+                        nl->event_stream_maxlen =
+                                nl->event_stream_len + PC2400M_CONF_EV_BUFF;
+
+                        memcpy(nlevtmp,
+                                nl->event_stream,
+                                nl->event_stream_len);
+                        kfree(nl->event_stream);
+                        nl->event_stream = nlevtmp;
+                        current_ev = nl->event_stream;
+
+                }
+
+                /* add new event */
+                /* This is not the best way map event pointer
+                   but because wireless.h doesn't have better 
+                   way for this we use name as extension to WE
+                */
+                iwe = kmalloc(PC2400M_IF_SCAN_RES_MAX_LEN,
+                              GFP_KERNEL | __GFP_NOFAIL);
+
+                nap_struct = (struct we_wmx_get_nap *)iwe->u.name;
+                /* add 32bit nap id*/
+                nap_struct->nap_id =
+                        search_result->nap_id;
+
+                switch (search_result->nap_and_nsp) {
+                case E_WIHAL_NAP_AND_NSP_FALSE:
+                        nap_struct->nap_nsp = we_wmx_many_nsps;
+                        break;
+                case E_WIHAL_NAP_AND_NSP_TRUE:
+                        nap_struct->nap_nsp = we_wmx_equals;
+                        break;
+
+                default:
+                        BUG_ON(search_result->nap_and_nsp !=
+                        E_WIHAL_NAP_AND_NSP_NA);
+                        nap_struct->nap_nsp = we_wmx_no_info;
+                        break;
+                }
+
+                if (search_result->nap_id_mask == E_WIHAL_NAP_ID_MASK_FULL)
+                        nap_struct->nap_mask = 
+                                we_wmx_nap_id_full;
+                else
+                        nap_struct->nap_mask = 
+                                we_wmx_nap_id_comp;
+
+                channel_plan_from_wihal(
+                        &search_result->channel,
+                        &nap_struct->channel_plan,
+                        nl);
+
+                iwe->cmd = SIOCGIWNAP;
+                iwe->len = sizeof(struct we_wmx_get_nap);
+                current_ev = iwe_stream_add_event(current_ev,
+                        nl->event_stream + IW_SCAN_MAX_DATA,
+                        iwe, IW_EV_LCP_LEN + 
+                        sizeof(struct we_wmx_get_nap));
+
+                /* add signal strength */
+                iwe->u.qual.level =
+                        search_result->signal_strength;
+                iwe->u.qual.noise = search_result->cinr;
+                iwe->u.qual.qual = 0;
+                iwe->cmd = IWEVQUAL;
+                iwe->len = IW_EV_QUAL_LEN;
+                current_ev =
+                iwe_stream_add_event(current_ev,
+                        nl->event_stream +
+                        IW_SCAN_MAX_DATA,
+                        iwe, IW_EV_QUAL_LEN);
+
+                nl->event_stream_len =
+                        (current_ev - nl->event_stream);
+
+                kfree(iwe);
+        }
+
+        NL_PROT_OFF;
+        return 0;
+
+}
+
+/** Returns statistic for interface.
+ *
+ *  @dev pointer to net device
+ *  @return wireless statistics
+ */
+struct iw_statistics *pc2400m_get_wireless_stats(struct net_device *dev)
+{
+
+        struct net_local *lp = netdev_priv(dev);
+        struct iw_statistics *wstats;
+        struct t_wihal_cmd cmd;
+        WIMAX_WAIT_RSP;
+
+        DEBUG("%s: wireless stats requested!\n", dev->name);
+
+        wstats = &lp->wstats;
+
+        /* update the data only if the driver has been connected */
+        if (lp->if_status == PC2400M_IF_CONNECTED) {
+                cmd.cmd_id = E_WIHAL_NETWORK_STATUS;
+                WIMAX_WAIT_CMD(dev, &cmd);
+        }
+        wstats->status = 1;
+        wstats->qual.qual = 0;
+        wstats->qual.noise = lp->cinr;
+        /* fake some wireless status data */
+        wstats->qual.level = lp->level;
+        wstats->qual.updated = 0;
+        wstats->discard.nwid = 0;
+        wstats->discard.code = 0L;
+        wstats->discard.misc = 0L;
+
+        return &lp->wstats;
+
+}
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_if_we.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_if_we.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_if_we.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_if_we.h	2011-02-06 20:12:11.683333273 -0500
@@ -0,0 +1,394 @@
+/*
+ * pc2400m_if_we.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Jouni Lappi <jouni.lappi@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         25      APPROVED 09-Sep-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_if_we.h
+ *
+ * Headers for wireless extensions
+ *
+ */
+
+#ifndef PC2400M_IF_WE_H
+#define PC2400M_IF_WE_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+/* include files for user-space compatibility */
+#ifndef __KERNEL__
+#include <net/if_arp.h>        /* For ARPHRD_ETHER */
+#include <sys/socket.h>        /* For AF_INET & struct sockaddr */
+#include <netinet/in.h>        /* For struct sockaddr_in */
+#include <netinet/if_ether.h>
+#include <linux/types.h>
+#include <net/if.h>            /* for IFNAMSIZ and co... */
+#include <wireless.h>          /* for SIOCIWFIRSTPRIV */
+#endif /* __KERNEL__ */
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/*strings for custom events */
+/** This event happens when Scanning has completed */
+#define WE_WMX_SCAN_COMPLETED           "SCAN_COMPLETED"
+/** This event happens when nsp search is completed */
+#define WE_WMX_SEARCH_COMPLETED         "SEARCH_COMPLETED"
+/** This event happens when network is disconnected */
+#define WE_WMX_WIMAX_DISCONNECTED       "DISCONNECTED"
+/** This event happens when network is connected */
+#define WE_WMX_WIMAX_CONNECTED          "CONNECTED"
+/** This event happens when there is a handover */
+#define WE_WMX_BS_HO                    "BS_HO"
+/** This event happens when realm info is available */
+#define WE_WMX_REALM_AVAIL              "REALM_AVAIL"
+/** This event happens when basestation info is available */
+#define WE_WMX_BSINFO_AVAIL             "BSINFO_AVAIL"
+/** This event happens when chipset crashes */
+#define WE_WMX_FATAL_SYSTEM_ERROR       "FATAL_SYSTEM_ERROR"
+/** This event happens when chipset loses network and re-entry is done */
+#define WE_WMX_IP_RENEW                 "IP_RENEW"
+/** This event is sent when EAP negotiations are restarted from scratch */
+#define WE_WMX_EAP_RESTART              "EAP_RESTART"
+
+/** value definitions */
+#define WE_WMX_WIMAX_BSID_LEN   6
+
+/* WiMAX : WiMAX specific private IOCTLs:
+ * - even numbered are set and odd get
+ * - set are only available to root */
+
+/** network scanning start */
+#define SIOCSIWIMAXSCAN         SIOCIWFIRSTPRIV
+/** get results for network scanning */
+#define SIOCGIWIMAXSCAN         SIOCIWFIRSTPRIV + 1
+/** set nsp search values */
+#define SIOCSIWNSPSEARCH        SIOCIWFIRSTPRIV + 2
+/** NSP search for found NAP */
+#define SIOCGIWNSPSEARCH        SIOCIWFIRSTPRIV + 3
+/** Saving EAP key */
+#define SIOCSIWEAPRESULT        SIOCIWFIRSTPRIV + 4
+/** get the used bs id */
+#define SIOCGIWBSINFO           SIOCIWFIRSTPRIV + 5
+/** Disconnect from network */
+#define SIOCSIWDISCONNECT       SIOCIWFIRSTPRIV + 6
+/** Get error code of disconnect */
+#define SIOCGIWERRORCODE        SIOCIWFIRSTPRIV + 7
+/** Connect to nw */
+#define SIOCSIWCONNECT          SIOCIWFIRSTPRIV + 8
+/** Get realm of connection */
+#define SIOCGIWNSPREALM         SIOCIWFIRSTPRIV + 9
+/** Save configuration values */
+#define SIOCSIWIMAXCONF         SIOCIWFIRSTPRIV + 10
+/** Get device info **/
+#define SIOCGIWDEVINFO          SIOCIWFIRSTPRIV + 11
+
+/** Number definition for first private event*/
+#define SIOCGIWNAP              0x8c0a
+/** NAP length 32 bit */
+#define WE_WMX_NAP_LEN_OCTETS                  4
+
+/** Definition for protocol used in driver */
+#define WE_WMX_WIMAX_PROTOCOL           "IEEE 802.16"
+
+/* Configuration flag definitions */
+/** How long will device try to reconnect after signal lost */
+#define WE_WMX_CM_SIGNAL_RECOVERY_LIMIT 0x04
+/** Wait before idle */
+#define WE_WMX_CM_IDLE_TIMER            0x08
+/** handover allowed or not */
+#define WE_WMX_CM_HANDOVER_LOCK         0x10
+/** Bsid for handover lock*/
+#define WE_WMX_CM_BSID                  0x20
+/** time period for paging in idle */
+#define WE_WMX_CM_IDLE_PAGING_INTERVAL  0x40
+/** wait before sleep */
+#define WE_WMX_CM_SLEEP_TIMER           0x80
+
+/*****************************************************************************
+ * Data types
+ */
+
+/** Definitions for start and stop */
+enum we_wmx_startstop {
+        we_wmx_start,
+        we_wmx_stop
+};
+
+/** These are here to help userspace implementation */
+#ifndef __KERNEL__
+#define u32 __u32
+#define u8  __u8
+#endif
+
+/** WiMAX error code definitions */
+enum we_wmx_error_code {
+        we_wmx_no_error,
+        we_wmx_unspecified_error,
+        we_wmx_remote_disconnection,
+        we_wmx_remote_reset,
+        we_wmx_network_lost,
+        we_wmx_creation_of_connection_failed,
+        we_wmx_device_in_invalid_state,
+        we_wmx_invalid_input_value,
+        we_wmx_nsp_search_failed,
+        we_wmx_scan_failed,
+        we_wmx_reauth_failed
+};
+
+/** NAP ID mask*/
+enum we_wmx_nap_id_mask {
+        we_wmx_nap_id_full,
+        we_wmx_nap_id_comp
+};
+
+/** Struct for indicating if NAP and NSP are the same */
+enum we_wmx_nap_eq_nsp {
+        we_wmx_no_info,
+        we_wmx_many_nsps,
+        we_wmx_equals
+};
+
+/* SIOCSIWIMAXSCAN */
+/** bandwith enumeration */
+enum we_wmx_channel_bandwidth {
+        WE_WMX_MHZ_3_5,
+        WE_WMX_MHZ_5,
+        WE_WMX_MHZ_7,
+        WE_WMX_MHZ_8_75,
+        WE_WMX_MHZ_10
+};
+
+/** fft enumeration */
+enum we_wmx_fft_size {
+        WE_WMX_FFT_512,
+        WE_WMX_FFT_1024
+};
+
+/** channelplan struct */
+struct we_wmx_channel_plan
+{
+        u32 carrier_freq;
+        enum we_wmx_channel_bandwidth channel_bandwidth;
+        enum we_wmx_fft_size fft_size;
+#define WE_WMX_PREAMBLE_SIZE 15
+        u8 preamble[WE_WMX_PREAMBLE_SIZE];
+};
+#define SIZE_WE_WMX_CHANNEL_PLAN (sizeof(struct we_wmx_channel_plan))
+
+/** Scan request message */
+struct  we_wmx_wimax_scan_req
+{
+        enum we_wmx_startstop start_stop; /* starting or stopping the scan */
+        u32  num_channel_plans; /* num entries in channel_plan */
+        struct we_wmx_channel_plan  channel_plan_list[0];
+};
+/* end SIOCSIWIMAXSCAN */
+
+/* SIOCSIWIMAXCONF */
+/** handover enumeration */
+enum we_wmx_handoverl {
+        we_wmx_na,
+        we_wmx_bslock
+};
+
+/** WiMAX configuration struct */
+struct we_wmx_wimax_conf {
+        u32 config_mask;
+        u32 signal_recovery_limit;
+        u32 idle_timer;
+        u32 idle_paging_interval;
+        u32 sleep_timer;
+        enum we_wmx_handoverl handover_lock;
+        u8 bs_id[WE_WMX_WIMAX_BSID_LEN];
+};
+/* end SIOCSIWIMAXCONF */
+
+/* SIOCGIWBSINFO */
+/** struct for basestation info */
+struct we_wmx_wimax_bsinfo {
+        u8 bs_id[WE_WMX_WIMAX_BSID_LEN];
+        enum we_wmx_nap_eq_nsp nap_nsp;
+        struct we_wmx_channel_plan channel_plan;
+};
+/* end SIOCGIWBSINFO */
+
+
+/* SIOCSIWNSPSEARCH */
+/** enumeration for NSP info delivery */
+enum we_wmx_nsp_info {
+        we_wmx_nonspinfo,
+        we_wmx_nspids,
+        we_wmx_all
+};
+
+/** NSP search request struct */
+struct we_wmx_nsp_search_req {
+        enum we_wmx_startstop start_stop;
+        u32 nap_id;
+        enum we_wmx_nap_id_mask nap_mask;
+        struct we_wmx_channel_plan channel_plan;
+        u32 nsp_cc_valid;
+        u32 nsp_cc;
+        enum we_wmx_nsp_info nsp_info;
+};
+/* end SIOCSIWNSPSEARCH */
+
+/* SIOCGIWNSPSEARCH */
+/** NSP list struct */
+struct we_wmx_nsp_list_str {
+        u32 nsp_id;
+        u32 name_len;
+#define WE_WMX_NSP_NAME_MAX_LEN 30
+        u8  nsp_name[WE_WMX_NSP_NAME_MAX_LEN];
+};
+
+/** NSP search response message */
+struct we_wmx_nsp_search_resp {
+        u32 nap_id;
+        enum we_wmx_nap_eq_nsp nap_nsp;
+        u32 nsp_cc;
+        u32 nbr_of_nsps;
+        struct we_wmx_nsp_list_str nsp_list[0];
+};
+/* end SIOCGIWNSPSEARCH */
+
+/* SIOCSIWEAPRESULT */
+/** Enumeration for eap success*/
+enum we_wmx_eap_success {
+        we_wmx_eap_false,
+        we_wmx_eap_true
+};
+
+/** EAP result message struct */
+struct we_wmx_eap_result {
+        /** TRUE if negotiation as successfully completed, FALSE otherwise */
+        enum we_wmx_eap_success eap_success;
+        /** pointer to an array of bytes containing the calculated MSK */
+        u8 p_msk[64];
+};
+/* end SIOCSIWEAPRESULT */
+
+/* SIOCSIWCONNECT */
+/** Struct for making wimax connection */
+struct we_wmx_connect {
+        u32 nap_id;
+        enum we_wmx_nap_id_mask nap_mask;
+        struct we_wmx_channel_plan channel_plan;
+        u32 nsp_id;
+        u32 request_realm;
+};
+/* end SIOCSIWCONNECT */
+
+/* SIOCGIWNSPREALM */
+/** Struct for realm where connected*/
+struct we_wmx_realm {
+        u32 realm_len;
+        u8  realm_name[0];
+};
+/* end SIOCGIWNSPREALM */
+
+/* SIOCGIWNAP */
+struct we_wmx_get_nap {
+        u32 nap_id;
+        enum we_wmx_nap_id_mask nap_mask;
+        struct we_wmx_channel_plan channel_plan;
+        enum we_wmx_nap_eq_nsp nap_nsp;
+};
+/* end SIOCGIWNAP */
+
+/** NSP id struct */
+struct we_wmx_nsp_id {
+        u32 nsp_n;
+};
+
+/* SIOCSIWERRORCODE */
+struct we_wmx_err_cod {
+        enum we_wmx_error_code err_code;
+};
+/* end SIOCSIWERRORCODE */
+
+/* SIOCGIWDEVINFO */
+/** enumeration for device info */
+enum we_wmx_dev_info_type {
+        we_wmx_model_name = 1,
+        we_wmx_manufacturer,
+        we_wmx_driver_api,
+        we_wmx_fw,
+        we_wmx_hw,
+        we_wmx_serial_number,
+        we_wmx_release_version
+};
+
+/** TLV structure for device info */
+struct we_wmx_tlv {
+        enum we_wmx_dev_info_type type;
+        u32 len;
+        u8 values[0];
+};
+
+/** device info data holder*/
+struct we_wmx_dev_info {
+        struct we_wmx_tlv dev_data[0];
+};
+/* end SIOCGIWDEVINFO */
+
+/** Presenting the great and powerfull netlocal */
+struct net_local;
+
+/** Presentation of external structure */
+struct t_wihal_ind_search_nap;
+
+/** Presentation of external structure */
+struct t_wihal_search_plan;
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+#ifdef __KERNEL__
+
+/** Scan results saving function */
+int pc2400m_we_scan_result(
+        struct t_wihal_ind_search_nap *resp,
+        struct net_device *dev);
+
+/** Channel plan conversion function */
+int channel_plan_from_wihal(
+        struct t_wihal_search_plan *source,
+        struct we_wmx_channel_plan *dest,
+        struct net_local *nl);
+
+/** WE event send function */
+void pc2400m_send_simple_event(struct net_device *dev, const char *str);
+
+#endif /* __KERNEL__ */
+
+#endif /* PC2400M_IF_WE_H */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_osal.c maemo_src/drivers/net/wireless/pc2400m/pc2400m_osal.c
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_osal.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_osal.c	2011-02-06 20:12:12.026666606 -0500
@@ -0,0 +1,771 @@
+/*
+ * pc2400m_osal.c
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         22      APPROVED 21-Feb-2008 Jouni Lappi
+*/
+
+/** @file pc2400m_osal.c
+ *
+ * This file implements OSAL layer functionalities
+ *
+ */
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+
+#include "pc2400m_com.h"
+#include "pc2400m_if_netlink.h"
+#include "pc2400m_osal.h"
+#include "pc2400m_osal_trace.h"
+
+/*****************************************************************************
+ * Global constants and macros
+ */
+
+/** the following constructs string lists for the driver traces */
+#define TRACE_GROUP_BEGIN(name, descr, on) descr,
+#define TRACE_BEGIN(name, descr)
+#define TRACE_GROUP_END()
+static char *wimax_osal_trace_group_str[] = {
+#include PC2400M_OSAL_TRACE_INCLUDE
+};
+#undef TRACE_GROUP_BEGIN
+#undef TRACE_GROUP_END
+#undef TRACE_BEGIN
+
+#define TRACE_GROUP_BEGIN(name, descr, on)
+#define TRACE_BEGIN(name, descr) descr,
+#define TRACE_GROUP_END()
+static char *wimax_osal_trace_id_str[] = {
+#include PC2400M_OSAL_TRACE_INCLUDE
+};
+#undef TRACE_GROUP_BEGIN
+#undef TRACE_GROUP_END
+#undef TRACE_BEGIN
+
+/*****************************************************************************
+ * Global data types
+ */
+
+struct wimax_osal_timer_data {
+        struct timer_list *timer;
+        wimax_osal_context *ctx;
+        struct work_struct timer_work;
+        wimax_osal_timer_cb cb;
+        void *data;
+        s32 timeout;
+        s32 periodic;
+        s32 resolution;
+        u32 in_handler;
+};
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+/*****************************************************************************
+ * Local functions
+ */
+
+/** Timer expiration workqueue function. This function executes a timer
+ *  expiration event which includes freeing the timer resources and calling
+ *  the registered timer handler function.
+ *
+ *  @param work pointer to the work structure
+ *  @returns none
+ */
+static void wimax_osal_timer_work(struct work_struct *work)
+{
+
+        struct wimax_osal_timer_data *td =
+                container_of(work,
+                             struct wimax_osal_timer_data,
+                             timer_work);
+
+        /* this is outside the if to guarantee sync with the
+           wimax_osal_timer_cancel function */
+        pc2400m_com_lock(td->ctx);
+        td->in_handler = 1;
+        if (td->cb && td->timeout != -1) {
+                td->cb((s32)td, td->data);
+        }
+        kfree(td->timer);
+        kfree(td);
+        pc2400m_com_unlock();
+
+}
+
+/** Determine priority. This function determines the requested priority,
+ *  and outputs a trace channel token to the trace channel.
+ *
+ *  @param priority specifies the requested priority
+ *  @returns none
+ */
+inline static void osal_priority(u8 priority)
+{
+        switch (priority) {
+        case WIMAX_OSAL_TRACE_PRIORITY_DEBUG:
+        case WIMAX_OSAL_TRACE_PRIORITY_DIAGNOSTIC:
+                printk(KERN_DEBUG WIMAX_OSAL_DRIVER_SUFFIX);
+                break;
+        case WIMAX_OSAL_TRACE_PRIORITY_ERROR:
+                printk(KERN_ERR WIMAX_OSAL_DRIVER_SUFFIX);
+                break;
+        case WIMAX_OSAL_TRACE_PRIORITY_INFO:
+                printk(KERN_INFO WIMAX_OSAL_DRIVER_SUFFIX);
+                break;
+        }
+}
+
+/** Send trace to trace pipe. This function sends the specified trace to
+ *  the trace pipe (for WiDAPI use.)
+ *
+ *  @param type specifies the type of the trace (u8, u32 etc)
+ *  @param group_id specifies the group identifier of the trace
+ *  @param trace_id specifies the trace identifier of the trace
+ *  @param len specifies the length of the trace payload
+ *  @param ptr specifies a pointer to the trace payload
+ *  @returns none
+ */
+inline static void osal_trace_to_pipe(u32 type,
+                                      u32 group_id,
+                                      u32 trace_id,
+                                      u32 len,
+                                      u8 *ptr)
+{
+
+        wimax_osal_packet *msg;
+        u8 *traceptr;
+        struct netlink_trace_msg_str *trace;
+
+
+        if (!pc2400m_netlink_trace_pipe_ready(
+                    pc2400m_com_running_context)) goto out;
+
+        /* forward the trace data to the trace pipe */
+        msg = wimax_osal_packet_alloc(
+                sizeof(struct netlink_trace_msg_str) + len);
+        trace = (struct netlink_trace_msg_str*)
+                wimax_osal_packet_put(
+                        msg, sizeof(struct netlink_trace_msg_str));
+        trace->header.type = PC2400M_IF_NETLINK_PIPE_TYPE_TRACE;
+        trace->header.length = sizeof(struct netlink_trace_msg_str) + len;
+        trace->header.version = PC2400M_IF_NETLINK_PIPE_VERSION;
+        trace->trace_type = type;
+        trace->trace_group = group_id;
+        trace->trace_id = trace_id;
+        trace->trace_len = len;
+
+        traceptr = (u8*)wimax_osal_packet_put(msg, len);
+        wimax_osal_mem_cpy(traceptr, ptr, len);
+
+        pc2400m_netlink_send_data(
+                pc2400m_com_running_context, msg, PC2400M_IF_NETLINK_PC2400M2);
+
+ out:
+        return;
+}
+
+/** Timer callback handler. This function is called by the kernel driver
+ *  subsystem upon expiration of a timer. This function queues the timer
+ *  expiration workqueue handler for immediate execution.
+ *
+ *  @param data cookie data carrying the timer data structure
+ *  @returns none
+ */
+void wimax_osal_timer_handler(unsigned long data)
+{
+
+        struct wimax_osal_timer_data *td = (struct wimax_osal_timer_data*)data;
+        struct work_struct *work = &td->timer_work;
+        del_timer(td->timer);
+        schedule_work(work);
+
+}
+
+
+/*****************************************************************************
+ * Exported functions
+ */
+
+
+/** Create a timer. This function starts a timer and registers a callback
+ *  function to be invoked upon expiration. A resolution request may be
+ *  provided to help the implementation choose between timer implementations.
+ *  currently only the least accurate resolution is supported.
+ *
+ * @param timeout timeout in microseconds for the timer
+ * @param resolution required accuracy of the timer (WIMAX_OSAL_TR_xxxx)
+ * @param periodic if non-zero, a peridic timer, if zero a one shot timer is
+ *        req'd
+ * @param data a cookie passed to the call back
+ * @param cb the callback function to invoke upon expiration
+ * @returns an integer specifying timer handle.
+ */
+s32 wimax_osal_timer_create(s32 timeout,
+                            enum WIMAX_OSAL_TR resolution,
+                            boolean periodic,
+                            void *data,
+                            wimax_osal_timer_cb cb)
+{
+
+        struct timer_list *timer =
+                wimax_osal_mem_alloc(sizeof(struct timer_list));
+        struct wimax_osal_timer_data *td =
+                wimax_osal_mem_alloc(sizeof(struct wimax_osal_timer_data));
+
+        memset(timer, 0x00, sizeof(struct timer_list));
+        memset(td, 0x00, sizeof(struct wimax_osal_timer_data));
+
+        /* negative timeouts are considered a special value */
+        BUG_ON(timeout < 0);
+
+        /* this implementation does not support periodic timers */
+        BUG_ON(periodic);
+
+        td->timer = timer;
+        td->cb = cb;
+        td->data = data;
+        td->timeout = timeout;
+        td->periodic = periodic;
+        td->resolution = resolution;
+        td->in_handler = 0;
+        td->ctx = pc2400m_com_running_context;
+        INIT_WORK(&td->timer_work, wimax_osal_timer_work);
+
+        setup_timer(timer, wimax_osal_timer_handler,
+                    (unsigned long)td);
+        mod_timer(timer, jiffies + (timeout / 1000) * HZ / 1000);
+
+        return (s32)(td);
+
+}
+
+/** Cancel a timer. This function cancels an ongoing timer. This function
+ *  guarantees, that after its return the expiration call back will not be
+ *  invoked.
+ *
+ *  @param handle handle (returned upon creation) of the timer
+ *  @returns always returns 0
+ */
+s32 wimax_osal_timer_cancel(s32 handle)
+{
+        struct wimax_osal_timer_data *td =
+                (struct wimax_osal_timer_data*)handle;
+
+        if (td && !td->in_handler) {
+
+                /* this guarantees that the timer expiration function has
+                   executed before return; this is safe, as the expiration does
+                   not contain synchronization with the common lock */
+                if (del_timer_sync(td->timer)) {
+                        kfree(td->timer);
+                        kfree(td);
+                } else {
+                        /* note that it is quaranteed this is synched with
+                           the timer_work function locks */
+                        td->timeout = -1;
+                }
+
+        }
+
+        return 0;
+}
+
+
+/** Initialize a packet list. This function initializes the provided packet
+ *  list. Calling the function on a list with existing elements will corrupt
+ *  the elements.
+ *
+ *  @param list pointer to the packet list
+ *  @returns none
+ */
+void wimax_osal_packet_list_initialize(wimax_osal_packet_list *list)
+{
+
+        memset(list, 0x00, sizeof(wimax_osal_packet_list));
+        return;
+
+}
+
+/** Free resources allocated by a packet list. This function frees the memory
+ *  allocated by the packet list, and removes any existing packets from the
+ *  list and optionally frees the removed items.
+ *
+ *  @param list Pointer to the list to clean up
+ *  @param delete TRUE to call free on the removed list elements, FALSE to
+ *         let them be
+ *  @returns none
+ */
+void wimax_osal_packet_list_release(
+        wimax_osal_packet_list *list,
+        boolean delete)
+{
+
+        struct sk_buff *skb = list->first;
+        struct sk_buff *skb2;
+
+        while (skb) {
+                skb2 = skb->next;
+                if (delete) {
+                        kfree_skb(skb);
+                } else {
+                        skb->next = NULL;
+                        skb->prev = NULL;
+                }
+                skb = skb2;
+        }
+
+        list->len = 0;
+        list->first = NULL;
+        list->last = NULL;
+
+        return;
+}
+
+/** Append an osal packet to a packet list. This function appends a packet
+ *  to an existing packet list. The packet is appended to the end of the list.
+ *  An osal_packet can exist in only one list at a time.
+ *
+ * @param list pointer to the packet list
+ * @param packet pointer to the packet
+ * @returns none
+ */
+void wimax_osal_packet_list_append(
+        wimax_osal_packet_list *list,
+        wimax_osal_packet *packet)
+{
+
+        BUG_ON(packet->next || packet->prev);
+
+        if (list->last) {
+                list->last->next = packet;
+                packet->prev = list->last;
+                list->last = packet;
+        } else {
+                list->first = packet;
+                packet->prev = NULL;
+                list->last = packet;
+        }
+        packet->next = NULL;
+
+        list->len ++;
+
+}
+
+/** Push an osal packet to a packet list. This function pushes a packet to
+ *  the beginning of an existing osal packet list. A packet can exist in only
+ *  one list at a time.
+ *
+ *  @param list pointer to the packet list
+ *  @param packet pointer to the packet
+ *  @returns none
+ */
+void wimax_osal_packet_list_push(
+        wimax_osal_packet_list *list,
+        wimax_osal_packet *packet)
+{
+
+        BUG_ON(packet->next || packet->prev);
+
+        packet->next = list->first;
+        packet->prev = NULL;
+        list->first = packet;
+
+        if (!list->last) list->last = packet;
+
+        list->len ++;
+
+}
+
+/** Get the topmost osal packet from the packet. This function returns the
+ *  topmost item in the existing packet list. The returned item is removed
+ *  from the list.
+ *
+ *  @param list pointer to the packet list
+ *  @returns pointer to the topmost wimax_osal_packet or NULL if the list was
+ *           empty.
+ */
+wimax_osal_packet *wimax_osal_packet_list_pop(wimax_osal_packet_list *list)
+{
+
+        wimax_osal_packet *pkt = list->first;
+
+        if (pkt) {
+                if (pkt->next) pkt->next->prev = NULL;
+                list->first = list->first->next;
+                if (!list->first) list->last = NULL;
+
+                pkt->next = NULL;
+                pkt->prev = NULL;
+
+                list->len --;
+        }
+
+        return pkt;
+
+}
+
+/** Initialize the osal list. This function configures the offset to the
+ *  list element header in the client structure to the list, and initializes
+ *  list pointers to NULL.
+ *
+ *  @param list pointer to the osal list
+ *  @param offset to the list element header element in the structure
+ *  @returns none
+ */
+void wimax_osal_list_initialize(struct wimax_osal_list *list, u32 offset)
+{
+
+        list->offset = offset;
+        list->first = NULL;
+        list->last = NULL;
+
+}
+
+/** Release the osal list. This function removes the elements from the list,
+ *  and optionally calls a freeing function for the elements on the list as
+ *  well. If the freeing function is NULL, the elements will remain.
+ *
+ *  @param list pointer to the osal list
+ *  @param free_fnc function to call on each element in the list
+ *  @returns none
+ */
+void wimax_osal_list_release(
+        struct wimax_osal_list *list,
+        wimax_osal_list_elem_free_fnc free_fnc)
+{
+
+        void *elem;
+        void *elem_n;
+        struct wimax_osal_list_elem_hdr *hdr;
+
+        wimax_osal_list_foreach_safe(list, elem, elem_n) {
+                hdr = _wimax_osal_get_elem_hdr(elem, list);
+                hdr->next = NULL;
+                hdr->prev = NULL;
+                if (free_fnc)
+                        free_fnc(&elem);
+        }
+
+        list->first = NULL;
+        list->last = NULL;
+
+        return;
+
+}
+
+/** Insert an element to the beginning of the list. This function asserts, that
+ *  the list is has not been inserted into multiple lists.
+ *
+ *  @param list pointer to the osal list
+ *  @param elem element to push to the list
+ *  @returns none
+ */
+void wimax_osal_list_push(struct wimax_osal_list *list, void *elem)
+{
+
+        struct wimax_osal_list_elem_hdr *hdr =
+                _wimax_osal_get_elem_hdr(elem, list);
+
+        wimax_osal_assert(hdr->next == NULL && hdr->prev == NULL);
+
+        hdr->next = list->first;
+        list->first = elem;
+
+        if (hdr->next)
+                _wimax_osal_get_elem_hdr(hdr->next, list)->prev = elem;
+
+        if (!list->last)
+                list->last = elem;
+
+}
+
+/** Insert an element to the end of the list. This function asserts, that
+ *  the list is has not been inserted into multiple lists.
+ *
+ *  @param list pointer to the osal list
+ *  @param elem element to append to the list
+ *  @returns none
+ */
+void wimax_osal_list_append(struct wimax_osal_list *list, void *elem)
+{
+
+        struct wimax_osal_list_elem_hdr *hdr =
+                _wimax_osal_get_elem_hdr(elem, list);
+
+        wimax_osal_assert(hdr->next == NULL && hdr->prev == NULL);
+
+        hdr->prev = list->last;
+        list->last = elem;
+
+        if (hdr->prev)
+                _wimax_osal_get_elem_hdr(hdr->prev, list)->next = elem;
+
+        if (!list->first)
+                list->first = elem;
+}
+
+/** Return the first element in the list. This function resets the next and
+ *  prev pointers of the returned element.
+ *
+ *  @param list pointer to the osal list
+ *  @returns pointer to the first element in the list, or NULL if the list is
+ *           empty
+ */
+void *wimax_osal_list_pop(struct wimax_osal_list *list)
+{
+
+        void *ret = list->first;
+        struct wimax_osal_list_elem_hdr *hdr =
+                _wimax_osal_get_elem_hdr(ret, list);
+
+        if (ret) {
+                list->first = hdr->next;
+                if (list->first)
+                        _wimax_osal_get_elem_hdr(list->first, list)->
+                                prev = NULL;
+                else
+                        list->last = NULL;
+
+                hdr->next = NULL;
+                hdr->prev = NULL;
+
+        }
+
+        return ret;
+
+}
+
+/** Remove the provided element from the list. The removed element next and
+ *  prev pointers will be reset.
+ *
+ *  @param list pointer to the osal list
+ *  @param elem pointer to element to remove
+ *  @returns none
+ */
+void wimax_osal_list_remove(struct wimax_osal_list *list, void *elem)
+{
+
+        void *pos;
+        struct wimax_osal_list_elem_hdr *prev;
+        struct wimax_osal_list_elem_hdr *next;
+        struct wimax_osal_list_elem_hdr *elemhdr;
+
+        wimax_osal_list_foreach(list, pos) {
+                if (pos == elem)
+                        break;
+        }
+
+        if (pos) {
+                elemhdr = _wimax_osal_get_elem_hdr(pos, list);
+                next = _wimax_osal_get_elem_hdr(elemhdr->next, list);
+                prev = _wimax_osal_get_elem_hdr(elemhdr->prev, list);
+
+                if (elemhdr->prev)
+                        prev->next = elemhdr->next;
+                else {
+                        list->first = elemhdr->next;
+                        if (elemhdr->next)
+                                next->prev = NULL;
+                }
+
+                if (elemhdr->next)
+                        next->prev = elemhdr->prev;
+                else {
+                        list->last = elemhdr->prev;
+                        if (elemhdr->prev)
+                                prev->next = NULL;
+                }
+
+                elemhdr->next = NULL;
+                elemhdr->prev = NULL;
+
+        }
+
+}
+
+/** Output a trace without parameters.
+ *
+ *  @param group_id group identifier of the trace
+ *  @param trace_id trace identifier of the trace within the group
+ *  @param priority the priority of the trace
+ *  @returns none
+ */
+void wimax_osal_trace(u32 group_id, u32 trace_id, u8 priority)
+{
+
+        osal_priority(priority);
+        printk("%s: %s:\n",
+               wimax_osal_trace_group_str[group_id],
+               wimax_osal_trace_id_str[trace_id]);
+        osal_trace_to_pipe(
+                PC2400M_IF_NETLINK_TRACE_TYPE_EMPTY,
+                group_id,
+                trace_id, 0,
+                NULL);
+
+}
+
+/** Output a trace with a byte parameter.
+ *
+ *  @param group_id group identifier of the trace
+ *  @param trace_id trace identifier of the trace within the group
+ *  @param priority the priority of the trace
+ *  @param param the byte to append to the trace
+ *  @returns none
+ */
+void wimax_osal_trace_byte(u32 group_id, u32 trace_id, u8 priority, u8 param)
+{
+
+        osal_priority(priority);
+        printk("%s: %s: Byte %2.2x\n",
+               wimax_osal_trace_group_str[group_id],
+               wimax_osal_trace_id_str[trace_id],
+               param);
+        osal_trace_to_pipe(
+                PC2400M_IF_NETLINK_TRACE_TYPE_BYTE,
+                group_id, trace_id, 1,
+                &param);
+
+}
+
+/** Output a trace with u16 parameter.
+ *
+ *  @param group_id group identifier of the trace
+ *  @param trace_id trace identifier of the trace within the group
+ *  @param priority the priority of the trace
+ *  @param param the u16 to append to the trace
+ *  @returns none
+ */
+void wimax_osal_trace_u16(u32 group_id, u32 trace_id, u8 priority, u16 param)
+{
+
+        osal_priority(priority);
+        printk("%s: %s: Short %4.4x\n",
+               wimax_osal_trace_group_str[group_id],
+               wimax_osal_trace_id_str[trace_id],
+               param);
+        osal_trace_to_pipe(
+                PC2400M_IF_NETLINK_TRACE_TYPE_U16,
+                group_id, trace_id, 2,
+                (u8*)&param);
+}
+
+/** Output a trace with u32 parameter.
+ *
+ *  @param group_id group identifier of the trace
+ *  @param trace_id trace identifier of the trace within the group
+ *  @param priority the priority of the trace
+ *  @param param the u32 to append to the trace
+ *  @returns none
+ */
+void wimax_osal_trace_u32(u32 group_id, u32 trace_id, u8 priority, u32 param)
+{
+
+        osal_priority(priority);
+        printk("%s: %s: Long %8.8x\n",
+               wimax_osal_trace_group_str[group_id],
+               wimax_osal_trace_id_str[trace_id],
+               param);
+        osal_trace_to_pipe(
+                PC2400M_IF_NETLINK_TRACE_TYPE_U32,
+                group_id, trace_id, 4,
+                (u8*)&param);
+
+}
+
+/** Output a trace with custom a string.
+ *
+ *  @param group_id group identifier of the trace
+ *  @param trace_id trace identifier of the trace within the group
+ *  @param priority the priority of the trace
+ *  @param param pointer to the NULL terminated string to append to the trace
+ *  @returns none
+ */
+void wimax_osal_trace_str(u32 group_id, u32 trace_id, u8 priority, u8 *param)
+{
+
+        osal_priority(priority);
+        printk("%s: %s: Str %s\n",
+               wimax_osal_trace_group_str[group_id],
+               wimax_osal_trace_id_str[trace_id],
+               param);
+        osal_trace_to_pipe(
+                PC2400M_IF_NETLINK_TRACE_TYPE_STR,
+                group_id, trace_id,
+                wimax_osal_str_len(param)+1, param);
+
+}
+
+/** Output a trace with a memory dump.
+ *
+ *  @param group_id group identifier of the trace
+ *  @param trace_id trace identifier of the trace within the group
+ *  @param priority the priority of the trace
+ *  @param param pointer to address from which data is to be appended to the
+ *               trace
+ *  @param len length of the data to append to the trace
+ *  @returns none
+ */
+void wimax_osal_trace_data(
+        u32 group_id, u32 trace_id, u8 priority, u8 *param, u32 len)
+{
+
+        u32 j, k;
+
+        if (priority != WIMAX_OSAL_TRACE_PRIORITY_DIAGNOSTIC) {
+                osal_priority(priority);
+
+                printk("%s: %s: Data %d bytes:",
+                       wimax_osal_trace_group_str[group_id],
+                       wimax_osal_trace_id_str[trace_id],
+                       len);
+                for (j=0, k=0; j<len; j++) {
+                        if (!k) {
+                                printk("\n");
+                                osal_priority(priority);
+                        }
+                        k++;
+                        printk("%2.2x ", param[j]);
+                        if (k==16) k=0;
+                }
+                printk("\n");
+        }
+
+        osal_trace_to_pipe(
+                PC2400M_IF_NETLINK_TRACE_TYPE_HEX, group_id, trace_id, len,
+param);
+
+}
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_osal.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_osal.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_osal.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_osal.h	2011-02-06 20:12:11.683333274 -0500
@@ -0,0 +1,391 @@
+/*
+ * pc2400m_osal.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         38      APPROVED 01-Jul-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_osal.h
+ *
+ * This file provides the services of the OSAL layer.
+ *
+ */
+
+#ifndef PC2400M_OSAL_H
+#define PC2400M_OSAL_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+
+#include "pc2400m_if.h"
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+#define wimax_osal_mem_cpy(_dst, _src, _len)    memcpy(_dst, _src, _len)
+#define wimax_osal_mem_move(_dst, _src, _len)   memmove(_dst, _src, _len)
+#define wimax_osal_mem_set(_dst, _val, _len)    memset(_dst, _val, _len)
+#define wimax_osal_mem_cmp(_dst, _val, _len)    memcmp(_dst, _val, _len)
+
+#define wimax_osal_str_len(_str)                strlen((char*)(_str))
+#define wimax_osal_str_ncpy(_tgt, _src, _len)   strncpy((char*)(_tgt), \
+                                                        (char*)(_src), _len)
+#define wimax_osal_str_cpy(_tgt, _src)          strcpy((char*)(_tgt), \
+                                                       (char*)(_src))
+#define wimax_osal_str_cmp(_tgt, _src)          strcmp((char*)(_tgt), \
+                                                       (char*)(_src))
+
+#define wimax_osal_assert(_cond)                BUG_ON(!(_cond))
+
+#define wimax_osal_mem_alloc_ex(_size, _mask)   wimax_osal_mem_alloc(_size)
+#define wimax_osal_mem_alloc(_size)             kmalloc(_size, GFP_KERNEL | \
+                                                              __GFP_NOFAIL)
+#define wimax_osal_sleep(_msec)                 msleep(_msec)
+
+#define WIMAX_OSAL_U16_TO_LE(_x)                cpu_to_le16(_x)
+#define WIMAX_OSAL_LE_TO_U16(_x)                le16_to_cpu(_x)
+#define WIMAX_OSAL_U32_TO_LE(_x)                cpu_to_le32(_x)
+#define WIMAX_OSAL_LE_TO_U32(_x)                le32_to_cpu(_x)
+
+#define WIMAX_OSAL_U32_TO_BE(_x)                cpu_to_be32(_x)
+#define WIMAX_OSAL_BE_TO_U32(_x)                be32_to_cpu(_x)
+
+#define WIMAX_OSAL_GET_LE16(_p)                 ((((u16)((u8*)_p)[1])<<8) | \
+                                                 (((u16)((u8*)_p)[0])))
+#define WIMAX_OSAL_GET_LE32(_p)                 ((((u32)((u8*)_p)[3])<<24) | \
+                                                 (((u32)((u8*)_p)[2])<<16) | \
+                                                 (((u32)((u8*)_p)[1])<<8) | \
+                                                 (((u32)((u8*)_p)[0])))
+#define WIMAX_OSAL_PUT_LE16(_p, _v)             { ((u8*)(_p))[0] = \
+                                                   (u8)(((u16)_v)); \
+                                                  ((u8*)(_p))[1] = \
+                                                   (u8)(((u16)_v)>>8); }
+#define WIMAX_OSAL_PUT_LE32(_p, _v)             { ((u8*)(_p))[0] = \
+                                                   (u8)(((u32)_v)); \
+                                                  ((u8*)(_p))[1] = \
+                                                   (u8)(((u32)_v)>>8); \
+                                                  ((u8*)(_p))[2] = \
+                                                   (u8)(((u32)_v)>>16); \
+                                                  ((u8*)(_p))[3] = \
+                                                   (u8)(((u32)_v)>>24); }
+#define WIMAX_OSAL_GET_BE32(_p)                 ((((u32)((u8*)_p)[0])<<24) | \
+                                                 (((u32)((u8*)_p)[1])<<16) | \
+                                                 (((u32)((u8*)_p)[2])<<8) | \
+                                                 (((u32)((u8*)_p)[3])))
+
+#define wimax_osal_packet_free(_pkt)            { kfree_skb(*_pkt); \
+                                                  *_pkt = NULL; }
+#define wimax_osal_packet_size(_p)              (((wimax_osal_packet*)_p)->len)
+#define wimax_osal_packet_ptr(_p)               ((void*) \
+                                                 (((wimax_osal_packet*) \
+                                                         _p)->data))
+#define wimax_osal_packet_put(_p,_size)         ((void*)skb_put(_p, _size))
+#define wimax_osal_packet_trim(_p,_size)        skb_trim(_p, _size)
+#define wimax_osal_packet_head_cut(_p,_size)    skb_pull(_p, _size)
+#define wimax_osal_packet_head_put(_p,_size)    ((void*)skb_push(_p, _size))
+
+#define wimax_osal_packet_list_len(_list)       ((_list)->len)
+#define wimax_osal_packet_list_first(_list)     ((_list)->first)
+#define wimax_osal_packet_list_last(_list)      ((_list)->last)
+#define wimax_osal_packet_list_next(_packet)    ((_packet)->next)
+#define wimax_osal_packet_list_prev(_packet)    ((_packet)->prev)
+#define wimax_osal_packet_list_foreach(_list, _pos) \
+                                                for ((_pos)=(_list)->first; \
+                                                     (_pos); \
+                                                     (_pos)=(_pos)->next)
+
+
+
+#define WIMAX_OSAL_PAD_GENERIC(_x, _y) (((_x) + ((_y) - 1)) & (~((_y) - 1)))
+#define WIMAX_OSAL_PAD4(_x)            WIMAX_OSAL_PAD_GENERIC(_x, 4)
+
+/** OSAL list get element macro */
+#define _wimax_osal_get_elem_hdr(_elem, _list) \
+        ((struct wimax_osal_list_elem_hdr*)(((u8*)_elem) + (_list)->offset))
+
+/** OSAL list foreach iteration */
+#define wimax_osal_list_foreach(_list, _elem) \
+        for ((_elem) = (_list)->first; \
+             (_elem); \
+             (_elem) = _wimax_osal_get_elem_hdr(_elem, _list)->next)
+
+
+/** OSAL list foreach iteration (delete safe) */
+#define wimax_osal_list_foreach_safe(_list, _elem, _elem_n) \
+        for ((_elem) = (_list)->first, \
+             (_elem_n) = (_elem)? \
+             _wimax_osal_get_elem_hdr(_elem, _list)->next: NULL; \
+             (_elem); \
+             (_elem) = (_elem_n), \
+             (_elem_n) = (_elem)? \
+             _wimax_osal_get_elem_hdr(_elem, _list)->next: NULL)
+
+
+/** OSAL list element hdr offset calculation */
+#define WIMAX_OSAL_LIST_ELEM_HDR_OFFSET(_elem, _elemhdr) \
+        ((u32)(&(((_elem*)0)->_elemhdr)))
+
+/** OSAL list element header initialize */
+#define WIMAX_OSAL_LIST_ELEM_HDR_INIT(_elemhdr) \
+        { (_elemhdr)->next = NULL; (_elemhdr)->prev = NULL; }
+
+/** OSAL list iterators */
+#define wimax_osal_list_first(_list) ((_list)->first)
+#define wimax_osal_list_next(_list, _item) \
+        (_wimax_osal_get_elem_hdr((_item), (_list))->next)
+
+/** Suffix used internally for tracing */
+#define WIMAX_OSAL_DRIVER_SUFFIX "PC2400Mdrv: "
+
+/** Request normal memory */
+#define WIMAX_OSAL_MEM_TYPE_NONE                0
+
+/** Request DMA compliant memory */
+#define WIMAX_OSAL_MEM_TYPE_DMA                 1
+
+
+#ifndef FALSE
+/** OSAL Boolean FALSE value */
+#define FALSE 0
+#endif /* !FALSE */
+
+#ifndef TRUE
+/** OSAL Boolean TRUE value */
+#define TRUE  1
+#endif /* !TRUE */
+
+/** OSAL trace priorities */
+#define WIMAX_OSAL_TRACE_PRIORITY_DIAGNOSTIC            0
+#define WIMAX_OSAL_TRACE_PRIORITY_DEBUG                 1
+#define WIMAX_OSAL_TRACE_PRIORITY_INFO                  2
+#define WIMAX_OSAL_TRACE_PRIORITY_ERROR                 3
+
+
+/*****************************************************************************
+ * Data types
+ */
+
+/** OSAL context data type */
+typedef struct net_device wimax_osal_context;
+
+/** OSAL packet data type */
+typedef struct sk_buff wimax_osal_packet;
+
+/** OSAL boolean type */
+typedef int boolean;
+
+/** OSAL packet list data type */
+typedef struct {
+        wimax_osal_packet *first;
+        wimax_osal_packet *last;
+        s32 len;
+} wimax_osal_packet_list;
+
+/** OSAL timer resolution definitions */
+enum WIMAX_OSAL_TR {
+        WIMAX_OSAL_TR_10MS,
+        WIMAX_OSAL_TR_1MS,
+        WIMAX_OSAL_TR_100US,
+        WIMAX_OSAL_TR_10US,
+        WIMAX_OSAL_TR_1US
+};
+
+/** OSAL timer handle */
+typedef s32 wimax_osal_timer_handle;
+
+/** OSAL timer expiration call back prototype */
+typedef void (*wimax_osal_timer_cb)(wimax_osal_timer_handle, void*);
+
+/** OSAL packet types */
+enum WIMAX_OSAL_PACKET_TYPE {
+        WIMAX_OSAL_PACKET_TYPE_UNDEF = 0,
+        WIMAX_OSAL_PACKET_TYPE_IPV4,
+        WIMAX_OSAL_PACKET_TYPE_IPV6,
+        WIMAX_OSAL_PACKET_TYPE_EAP,
+        WIMAX_OSAL_PACKET_TYPE_EXTENDED = -1,
+};
+
+/** OSAL store for packet type */
+struct wimax_osal_packet_type_cb {
+        enum WIMAX_OSAL_PACKET_TYPE type;
+        void *subtype;
+};
+
+/** OSAL list */
+struct wimax_osal_list {
+        void *first;
+        void *last;
+        u32 count;
+        u32 offset;
+};
+
+/** OSAL list element */
+struct wimax_osal_list_elem_hdr {
+        void *next;
+        void *prev;
+};
+
+/** OSAL list element free function prototype */
+typedef void (*wimax_osal_list_elem_free_fnc)(void **ptr);
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+static inline void wimax_osal_packet_type_set(
+        wimax_osal_packet *packet,
+        enum WIMAX_OSAL_PACKET_TYPE type,
+        void *subtype)
+{
+
+        struct wimax_osal_packet_type_cb *cb =
+                (struct wimax_osal_packet_type_cb*)packet->cb;
+
+        BUG_ON(subtype && (type != WIMAX_OSAL_PACKET_TYPE_EXTENDED));
+
+        cb->type = type;
+        cb->subtype = subtype;
+}
+
+static inline void* wimax_osal_packet_subtype_get(
+        wimax_osal_packet *packet)
+{
+
+        return ((struct wimax_osal_packet_type_cb*)packet->cb)->subtype;
+
+}
+
+static inline void wimax_osal_ctx_priv_set(
+        wimax_osal_context *ctx,
+        void *priv)
+{
+        struct net_local *nl = netdev_priv(ctx);
+        nl->driver_priv = priv;
+}
+
+static inline void *wimax_osal_ctx_priv_get(wimax_osal_context *ctx)
+{
+        return ((struct net_local*)netdev_priv(ctx))->driver_priv;
+}
+
+static inline wimax_osal_packet *wimax_osal_packet_alloc(u32 size)
+{
+        struct sk_buff *skb;
+#define PACKET_SPARE     (30 + 14)
+        while (!(skb = alloc_skb(size + PACKET_SPARE, GFP_KERNEL |
+                                 __GFP_NOFAIL))) {
+                msleep(1);
+        }
+        skb_reserve(skb, PACKET_SPARE);
+
+        /* reset the packet type field */
+        memset(skb->cb, 0x00, sizeof(struct wimax_osal_packet_type_cb));
+
+        return skb;
+}
+
+static inline void wimax_osal_mem_free(void **ptr)
+{
+
+        kfree(*ptr);
+        *ptr = NULL;
+
+        return;
+
+}
+
+extern wimax_osal_packet_list *wimax_osal_packet_list_alloc(void);
+extern void wimax_osal_packet_list_free(wimax_osal_packet_list **, boolean);
+extern void wimax_osal_packet_list_initialize(wimax_osal_packet_list*);
+extern void wimax_osal_packet_list_release(wimax_osal_packet_list *, boolean);
+extern void wimax_osal_packet_list_append(
+        wimax_osal_packet_list*,
+        wimax_osal_packet*);
+extern void wimax_osal_packet_list_push(
+        wimax_osal_packet_list*,
+        wimax_osal_packet*);
+extern void wimax_osal_packet_list_insert(
+        wimax_osal_packet_list*,
+        wimax_osal_packet*,
+        void*);
+extern void wimax_osal_packet_list_cmp_fnc_set(
+        wimax_osal_packet_list*,
+        void (*)(wimax_osal_packet*,
+                 wimax_osal_packet*,
+                 void*));
+extern wimax_osal_packet *wimax_osal_packet_list_pop(wimax_osal_packet_list*);
+
+/** OSAL timer functions */
+extern void wimax_osal_timer_handler(unsigned long);
+extern wimax_osal_timer_handle wimax_osal_timer_create(
+        s32,
+        enum WIMAX_OSAL_TR,
+        boolean,
+        void*,
+        wimax_osal_timer_cb);
+extern s32 wimax_osal_timer_cancel(wimax_osal_timer_handle);
+
+/** OSAL list functions */
+extern void wimax_osal_list_initialize(struct wimax_osal_list*, u32);
+extern void wimax_osal_list_release(
+        struct wimax_osal_list*,
+        wimax_osal_list_elem_free_fnc);
+extern void wimax_osal_list_push(struct wimax_osal_list*, void*);
+extern void wimax_osal_list_append(struct wimax_osal_list*, void*);
+extern void *wimax_osal_list_pop(struct wimax_osal_list*);
+extern void wimax_osal_list_remove(struct wimax_osal_list*, void*);
+
+
+/** OSAL trace functions */
+extern void wimax_osal_trace(
+        u32 group_id, u32 trace_id, u8 priority);
+extern void wimax_osal_trace_byte(
+        u32 group_id, u32 trace_id, u8 priority, u8 param);
+extern void wimax_osal_trace_u16(
+        u32 group_id, u32 trace_id, u8 priority, u16 param);
+extern void wimax_osal_trace_u32(
+        u32 group_id, u32 trace_id, u8 priority, u32 param);
+extern void wimax_osal_trace_str(
+        u32 group_id, u32 trace_id, u8 priority, u8 *param);
+extern void wimax_osal_trace_data(
+        u32 group_id, u32 trace_id, u8 priority, u8 *param, u32 len);
+
+
+/** OSAL include to make trace identifiers visible */
+#include "pc2400m_osal_trace.h"
+
+/** OSAL include to make adaptation layer functions visible */
+#include "pc2400m_al.h"
+
+#endif /* PC2400M_OSAL_H */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_osal_trace.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_osal_trace.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_osal_trace.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_osal_trace.h	2011-02-06 20:12:12.236666607 -0500
@@ -0,0 +1,88 @@
+/*
+ * pc2400m_osal_trace.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         3       APPROVED 21-Feb-2008 Jouni Lappi
+*/
+
+/** @file pc2400m_osal_trace.h
+ *
+ * Description of this file.
+ *
+ */
+
+#ifndef PC2400M_OSAL_TRACE_H
+#define PC2400M_OSAL_TRACE_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/** Osal trace include definition */
+#define PC2400M_OSAL_TRACE_INCLUDE "pc2400m_drv_traces.h"
+
+/** define the trace groups */
+#define RES_BEGIN(a,b,c,d,e,f)
+#define RES_END
+#define TRACE_END()
+#define WIMAX_OSAL_AUTOGEN_TRACE_INFO
+#define TRACE_GROUP_BEGIN(name, descr, on) name,
+#define TRACE_GROUP_END()
+#define TRACE_BEGIN(name, descr)
+
+/** Osal trace group enumeration*/
+enum pc2400m_osal_trace_groups {
+#include PC2400M_OSAL_TRACE_INCLUDE
+};
+
+/** define the trace identifiers */
+#undef TRACE_GROUP_BEGIN
+#undef TRACE_GROUP_END
+#undef TRACE_BEGIN
+#define TRACE_GROUP_BEGIN(name, descr, on)
+#define TRACE_BEGIN(name, descr) name,
+#define TRACE_GROUP_END()
+enum pc2400_osal_trace_ids {
+#include PC2400M_OSAL_TRACE_INCLUDE
+};
+#undef TRACE_GROUP_BEGIN
+#undef TRACE_GROUP_END
+#undef TRACE_BEGIN
+
+/*****************************************************************************
+ * Data types
+ */
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+#endif /* PC2400M_OSAL_TRACE_H */
+
+/* End of File */
+
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_release.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_release.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_release.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_release.h	2011-02-06 20:12:11.619999940 -0500
@@ -0,0 +1,7 @@
+#ifndef PC2400M_RELEASE_H
+#define PC2400M_RELEASE_H
+
+#define RELEASE_VAL "2008.38.001"
+
+#endif /* PC2400M_RELEASE_H */
+
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_sim.c maemo_src/drivers/net/wireless/pc2400m/pc2400m_sim.c
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_sim.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_sim.c	2007-10-02 03:09:32.000000000 -0400
@@ -0,0 +1,1319 @@
+/*
+ * pc2400m_sim.c
+ *
+ * Copyright (C) 2007 Nokia Corporation
+ * Author: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+
+
+#define __KERNEL_SYSCALLS__
+
+#include <linux/version.h>
+#ifdef MODULE
+#ifdef MODVERSIONS
+#include <linux/modversions.h>
+#endif
+#include <linux/module.h>
+#else
+#define MOD_INC_USE_COUNT
+#define MOD_DEC_USE_COUNT
+#endif
+
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/clk.h>
+#include <linux/spi/spi.h>
+#include <linux/platform_device.h>
+#include <linux/string.h>
+#include <linux/firmware.h>
+
+#ifdef CONFIG_NET_PC2400M_SIM
+
+#include <linux/moduleparam.h>
+#include <linux/workqueue.h>
+#include <net/tcp.h>
+#include <linux/net.h>
+#include <linux/in.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
+
+#include <asm/checksum.h>
+
+#if !defined(CONFIG_FW_LOADER) && !defined(CONFIG_FW_LOADER_MODULE)
+#error No Firmware Loading configured in the kernel !
+#endif
+
+#include "pc2400m_if.h"
+#include "pc2400m_drv_com.h"
+#include "pc2400m_drv_hdi.h"
+#include "pc2400m_al.h"
+#include "pc2400m_spi.h"
+#include "pc2400m_com.h"
+
+
+/* simulator connectivity information */
+static u32 sim_addr = 0x7f000001;
+static u16 sim_port = 11045;
+static u32 for_addr = 0x00000000;
+
+/* hook parameters */
+static unsigned int pc2400m_sim_hook(unsigned int, struct sk_buff**,
+				   const struct net_device *, 
+				   const struct net_device *,
+				   int (*)(struct sk_buff *));
+
+static struct nf_hook_ops pc2400m_sim_hook_ops_in = {
+	{NULL, NULL},
+	pc2400m_sim_hook,
+	THIS_MODULE,
+	PF_INET,
+	NF_IP_PRE_ROUTING,
+	NF_IP_PRI_FILTER-1
+};
+
+static struct nf_hook_ops pc2400m_sim_hook_ops_out = {
+	{NULL, NULL},
+	pc2400m_sim_hook,
+	THIS_MODULE,
+	PF_INET,
+	NF_IP_LOCAL_OUT,
+	NF_IP_PRI_FILTER-1
+};
+
+
+/* module options configuration */
+module_param(sim_addr, int, 0);
+MODULE_PARM_DESC(sim_addr, "IPv4 address of simulator in hex\n");
+module_param(sim_port, short, 0);
+MODULE_PARM_DESC(sim_port, "port number of simulator in hex\n");
+module_param(for_addr, int, 0);
+MODULE_PARM_DESC(sim_addr, "IPv4 address of foreign data plane interface\n");
+
+
+/* list to maintain all pc2400m devices managed by this driver */
+static struct net_device *pc2400m_spi_wimax_device = NULL;
+
+/*
+ * Global lock for the adaptation library. This is global, because the driver
+ * lib needs to be concurrency protected from multiple accesses regardless
+ * of the number of instances with one single lock. */
+struct semaphore pc2400m_com_mutex;
+
+/* function structure for adaptation layers */
+struct adaptation_if pc2400m_drv_adapt;
+
+/* internal read data buffer */
+static u8 sim_spi_buf[PC2400M_MAX_TRANSACTION];
+static u32 sim_spi_buf_len = 0;
+static u8 sim_read_buf[PC2400M_MAX_TRANSACTION];
+static u32 sim_read_buf_len = 0;
+
+/* socket functions */
+static void (*orig_data_ready)(struct sock*, int);
+static void (*orig_state_change)(struct sock*);
+
+/* spi queue */
+#define SIM_QUEUE_MAX 5
+struct sim_queue_elem {
+	int read;   /* 1 = read operation, 0 = write operation */
+	int len;
+	u8 *ptr;
+};
+static struct sim_queue_elem sim_queue[SIM_QUEUE_MAX];
+static int sim_queue_len = 0;
+
+/* device registration information */
+static void pc2400m_sim_device_release(struct device * dev);
+struct platform_device pc2400m_sim_device = {
+        .name           = "wimax-simu",
+        .id             = -1,
+        .dev            = {
+                .release = pc2400m_sim_device_release,
+        },
+};
+
+
+#define GENERIC_PAD(x,y) (((x) + (y-1)) & (~(y-1)))
+#define PAYLOAD_PAD(x)  GENERIC_PAD(x, PC2400M_FRAME_PAD)
+#define BLOCK_PAD(x)    GENERIC_PAD(x, PC2400M_BLOCK_SIZE)
+#define PAD4(x)         GENERIC_PAD(x, 4)
+
+
+#define EXTRACT_LE32(ptr) ((((u32)((u8*)ptr)[3])<<24) | \
+                           (((u32)((u8*)ptr)[2])<<16) | \
+		           (((u32)((u8*)ptr)[1])<<8) | (((u32)((u8*)ptr)[0])))
+
+#define EXTRACT_LE16(ptr) ((((u16)((u8*)ptr)[1])<<8) | (((u16)((u8*)ptr)[0])))
+
+#define INSERT_LE32(ptr, val) { ((u8*)(ptr))[0] = (u8)(((u32)val)); \
+                                ((u8*)(ptr))[1] = (u8)(((u32)val)>>8); \
+                                ((u8*)(ptr))[2] = (u8)(((u32)val)>>16); \
+                                ((u8*)(ptr))[3] = (u8)(((u32)val)>>24); }
+
+#define INSERT_LE16(ptr, val) { ((u8*)(ptr))[0] = (u8)(((u32)val)); \
+                                ((u8*)(ptr))[1] = (u8)(((u32)val)>>8); }
+
+static void pc2400m_sim_device_release(struct device * dev)
+{
+
+}
+
+/**
+ * pc2400m_spi_h2d - queue write to simulator socket
+ * @ndev: pointer to network device 
+ * @data: a buffer containing the data to write
+ * @length: length of the buffer to write (in bytes)
+ *
+ * Queue an SPI write to be executed upon the next commit
+ */
+static s32 pc2400m_spi_h2d(struct net_device *ndev, u8* data, s32 length) 
+{
+
+	struct net_local *nl = netdev_priv(ndev);
+
+	/* queue the data for later handling */
+	sim_queue[sim_queue_len].read = 0;
+	sim_queue[sim_queue_len].ptr = data;
+	sim_queue[sim_queue_len++].len = length;
+
+	nl->spi_total += length;
+
+	BUG_ON(sim_queue_len == SIM_QUEUE_MAX);
+
+	return length;
+}
+
+/**
+ * pc2400m_spi_h2d - queue read from simulator data buffer
+ * @ndev: pointer to network device 
+ * @data: a buffer containing space for the read data
+ * @length: length of the data to read (in bytes)
+ *
+ * Queue an SPI write to be executed upon the next commit
+ */
+static s32 pc2400m_spi_d2h(struct net_device *ndev, u8* buf, s32 length) 
+{
+
+	struct net_local *nl = netdev_priv(ndev);
+
+
+	/* queue the data for later handling */
+	sim_queue[sim_queue_len].read = 1;
+	sim_queue[sim_queue_len].ptr = buf;
+	sim_queue[sim_queue_len++].len = length;
+
+	nl->spi_total += length;
+
+	BUG_ON(sim_queue_len == SIM_QUEUE_MAX);
+
+	return length;
+	
+}
+
+static void pc2400m_sim_send_state_ind(struct net_device *ndev, u8 state)
+{
+
+	struct net_local *nl = netdev_priv(ndev);
+
+	INSERT_LE32(sim_read_buf+sim_read_buf_len, 12+8+4);
+	sim_read_buf_len += 4;
+	INSERT_LE32(sim_read_buf+sim_read_buf_len, FRAME_TYPE_CONTROL);
+	sim_read_buf_len += 4;
+
+	/* main message */
+	INSERT_LE16(sim_read_buf+sim_read_buf_len, L3_L4_OPCODE_REPORT_STATE);
+	sim_read_buf_len += 2;
+	INSERT_LE16(sim_read_buf+sim_read_buf_len, 8);
+	sim_read_buf_len += 2;
+	INSERT_LE16(sim_read_buf+sim_read_buf_len, 0);
+	sim_read_buf_len += 2;
+	INSERT_LE16(sim_read_buf+sim_read_buf_len, 0);
+	sim_read_buf_len += 2;
+	INSERT_LE16(sim_read_buf+sim_read_buf_len, 
+		    L3L4_RESPONSE_STATUS_SUCCESS_IN_PROCESS);
+	sim_read_buf_len += 2;
+	INSERT_LE16(sim_read_buf+sim_read_buf_len, 0);
+	sim_read_buf_len += 2;
+
+	/* state TLV */
+	INSERT_LE16(sim_read_buf+sim_read_buf_len, L3L4_TLV_TYPE_SYSTEM_STATE);
+	sim_read_buf_len += 2;
+	INSERT_LE16(sim_read_buf+sim_read_buf_len, 4);
+	sim_read_buf_len += 2;
+	INSERT_LE32(sim_read_buf+sim_read_buf_len, state);
+	sim_read_buf_len += 4;
+	
+	/* signal interrupt for data */
+	schedule_work(&nl->spi_work);
+
+	return;
+
+}
+
+static void pc2400m_sim_send_init_resp(struct net_device *ndev)
+{
+
+	INSERT_LE32(sim_read_buf+sim_read_buf_len, 12+4);
+	sim_read_buf_len += 4;
+	INSERT_LE32(sim_read_buf+sim_read_buf_len, FRAME_TYPE_CONTROL);
+	sim_read_buf_len += 4;
+
+	INSERT_LE16(sim_read_buf+sim_read_buf_len, L4_L3_OPCODE_CMD_INIT);
+	sim_read_buf_len += 2;
+	INSERT_LE16(sim_read_buf+sim_read_buf_len, 0);
+	sim_read_buf_len += 2;
+	INSERT_LE16(sim_read_buf+sim_read_buf_len, 0);
+	sim_read_buf_len += 2;
+	INSERT_LE16(sim_read_buf+sim_read_buf_len, 0);
+	sim_read_buf_len += 2;
+	INSERT_LE16(sim_read_buf+sim_read_buf_len, 
+		    L3L4_RESPONSE_STATUS_SUCCESS_IN_PROCESS);
+	sim_read_buf_len += 2;
+	INSERT_LE16(sim_read_buf+sim_read_buf_len, 0);
+	sim_read_buf_len += 2;
+
+	/* send ind (will also signal interrupt) */
+	pc2400m_sim_send_state_ind(ndev, L3L4_SYSTEM_STATE_INIT);
+
+	return;
+
+}
+
+#define OID_INTEL_80216_CUSTOM (0xff000000)
+
+static int pc2400m_sim_local_resp(struct net_device *ndev, u8 *data_ptr, 
+				  u32 size) 
+{
+
+	int ret = 0;
+	u16 type;
+
+	/* check if this message is something that must be locally handled
+	   to get round DSim limitations */
+	type = EXTRACT_LE16(data_ptr);
+	switch(type) {
+	case L4_L3_OPCODE_CMD_INIT:
+		pc2400m_sim_send_init_resp(ndev);
+		ret = 1;
+		break;
+	}
+
+	return ret;
+
+}
+
+static void pc2400m_sim_send_to_socket(struct net_device *ndev, u8 *data_ptr, 
+				       u32 size) 
+{
+
+	struct msghdr msg;
+        struct kvec iov;
+	struct net_local *nl = netdev_priv(ndev);
+	u8 *message;
+	int ret;
+
+	if (nl->sock) {
+		message = (u8*)kmalloc(size+8, GFP_KERNEL);
+		memcpy(message+8, data_ptr, size);
+		*((u32*)&message[0]) = cpu_to_le32(size+4);
+		*((u32*)&message[4]) = cpu_to_le32(OID_INTEL_80216_CUSTOM);
+		
+		iov.iov_base = message;
+		iov.iov_len = size + 8;
+		msg.msg_name = NULL;
+		msg.msg_control= NULL;
+		msg.msg_controllen = 0;
+		msg.msg_flags = /*0 MSG_DONTWAIT*/MSG_WAITALL;
+		msg.msg_namelen = 0;
+		
+		ret = kernel_sendmsg(nl->sock, &msg, &iov, 1, size + 8);
+		if (ret <= 0) {
+			ERROR("SIM: Sending to socket failed (%d)\n", ret);
+		}
+		kfree(message);
+	} else {
+		ERROR("SIM: Simulator not bound for write.\n");
+	}
+	
+}
+
+static void pc2400m_sim_return_to_sender_work(struct work_struct *work)
+{
+
+	struct net_local *nl = container_of(work, struct net_local, spi_work);
+	spi_irq_cb cb = nl->irq_cb;
+
+	/* BEWARE: entry into the single threaded driver library; must
+	   be protected. */
+	if (cb) {
+		pc2400m_com_lock();
+		cb(nl->net_dev);
+		pc2400m_com_unlock();
+	} else {
+		DEBUG("SIM: Data interrupt lost.\n");
+	}
+
+}
+
+
+static void pc2400m_sim_return_to_sender(struct net_device *ndev, 
+					 u8 *data_ptr, 
+					 u32 size) 
+{
+
+	struct net_local *nl = netdev_priv(ndev);
+	u32 src;
+	u32 dst;
+	u16 checksum;
+
+	/* get rid of old header */
+	data_ptr += 4;
+	size -= 4;
+
+	ERROR("SIM: Data from interface, assuming ping, generating reply\n");
+	
+	/* put in OID headers */
+#if 0   /* MISSING: REMOVED FOR THE SAKE OF COMPLIANCE WITH FW2.0 */
+	INSERT_LE32(sim_read_buf+sim_read_buf_len, size+4+8);
+#else
+	INSERT_LE32(sim_read_buf+sim_read_buf_len, size+4);
+#endif
+	sim_read_buf_len += 4;
+	INSERT_LE32(sim_read_buf+sim_read_buf_len, FRAME_TYPE_DATA);
+	sim_read_buf_len += 4;
+#if 0   /* MISSING: REMOVED FOR THE SAKE OF COMPLIANCE WITH FW2.0 */
+	*(sim_read_buf+sim_read_buf_len) = 1;  /* CS Type IPV4 */
+	sim_read_buf_len += 8;
+#endif
+
+	memcpy(sim_read_buf+sim_read_buf_len, data_ptr, size);
+	
+	/* reverse the IP addresses */
+	src = EXTRACT_LE32(sim_read_buf+sim_read_buf_len+12);
+	dst = EXTRACT_LE32(sim_read_buf+sim_read_buf_len+16);
+	INSERT_LE32(sim_read_buf+sim_read_buf_len+12, dst);
+	INSERT_LE32(sim_read_buf+sim_read_buf_len+16, src);
+	/* ping reply */
+	if (*(sim_read_buf+sim_read_buf_len+20) == 8) {
+		*(sim_read_buf+sim_read_buf_len+20) = 0;
+		
+		/* ICMP checksum */
+		checksum = ntohs(*((u16*)(sim_read_buf+
+					  sim_read_buf_len+22)));
+		checksum = 0xffff-checksum;
+		checksum -= 0x800;
+		checksum = 0xffff-checksum;
+		*((u16*)(sim_read_buf+sim_read_buf_len+22)) = 
+			htons(checksum);
+	}
+	
+	
+	sim_read_buf_len += size;
+	
+	schedule_work(&nl->spi_work);
+
+}
+
+
+static u16 pc2400m_sim_calc_read_size(void) 
+{
+
+#define PC2400M_D2H_BARKER    0xbeefbabe
+	
+	int cnt = 0;
+	int size;
+	u16 type;
+	static u32 seq = 0;
+
+	u8 *ptr = sim_read_buf;
+	u8 *spi_ptr = sim_spi_buf;
+
+	u8 desc[60 * 4];
+	u8 *desc_ptr = desc;
+
+	if (!sim_read_buf_len) {
+		sim_spi_buf_len = 0;
+		return 0;
+	}
+
+	/* prepare the pre-read data for sending to the driver */
+	while (sim_read_buf_len) {
+
+		size = EXTRACT_LE32(ptr);
+		type = (u16)EXTRACT_LE32(ptr+4);
+		wimax_osal_assert(size+4 <= sim_read_buf_len);
+		ptr+=8;
+		sim_read_buf_len -= (size+4);
+		size-=4;
+		
+		/* fill in the descriptor */
+		*((u16*)desc_ptr) = cpu_to_le16(size);
+		*((u16*)desc_ptr+1) = cpu_to_le16(type);
+		desc_ptr += 4;
+
+		/* data block */
+		memcpy(spi_ptr, ptr, size);
+		spi_ptr += PAYLOAD_PAD(size);
+		ptr += (size);
+		cnt++;
+	}
+
+	/* insert the headers before the data */
+	sim_spi_buf_len = spi_ptr - sim_spi_buf;
+	memmove(sim_spi_buf + 16 + PAYLOAD_PAD(cnt*4), sim_spi_buf,
+		sim_spi_buf_len);
+	sim_spi_buf_len += (16 + PAYLOAD_PAD(cnt*4));
+
+	spi_ptr = sim_spi_buf;
+	*((u32*)(&spi_ptr[0])) = cpu_to_le32(PC2400M_D2H_BARKER);
+	*((u32*)(&spi_ptr[4])) = cpu_to_le32(seq);
+	*((u32*)(&spi_ptr[8])) = cpu_to_le16(cnt);
+	*((u32*)(&spi_ptr[12])) = cpu_to_le16(PC2400M_BLOCK_SIZE - 
+					      (sim_spi_buf_len%256));
+	seq++;
+	spi_ptr+=16;
+	memcpy(spi_ptr, desc, cnt * 4);
+	sim_spi_buf_len = BLOCK_PAD(sim_spi_buf_len);
+
+	/* insert SPI/SDIO transaction headers */
+	for (size=sim_spi_buf_len/PC2400M_BLOCK_SIZE-1; size>=0; size--) {
+		
+		memmove(sim_spi_buf+size*(PC2400M_BLOCK_SIZE+8)+4,
+			sim_spi_buf+size*PC2400M_BLOCK_SIZE,
+			PC2400M_BLOCK_SIZE);
+		cnt = size*(PC2400M_BLOCK_SIZE+8);
+		sim_spi_buf[cnt+0] = 0xff;
+		sim_spi_buf[cnt+1] = 0xff;
+		sim_spi_buf[cnt+2] = 0xff;
+		sim_spi_buf[cnt+3] = 0xfe;
+
+		cnt += (PC2400M_BLOCK_SIZE + 4);
+		sim_spi_buf[cnt+0] = 0xff;
+		sim_spi_buf[cnt+1] = 0xff;
+		sim_spi_buf[cnt+2] = 0xff;
+		sim_spi_buf[cnt+3] = 0xff;
+
+	}
+	
+	return sim_spi_buf_len;
+}
+
+#define SIM_BLOCK_FOOTER   4
+#define SIM_BLOCK_HEADER   4
+#define SIM_BLOCK_PAD      (SIM_BLOCK_HEADER + SIM_BLOCK_FOOTER)
+
+static void pc2400m_sim_lose_spi_padding(u8 *buf, u32 len) {
+
+	int i = 0;
+
+	for (i=0; i<len; i+=(PC2400M_BLOCK_SIZE+SIM_BLOCK_PAD)) {
+		memmove(buf+i*PC2400M_BLOCK_SIZE,
+			buf+i*(PC2400M_BLOCK_SIZE+SIM_BLOCK_PAD)
+			+SIM_BLOCK_HEADER,
+			PC2400M_BLOCK_SIZE);
+	}
+
+	return;
+
+}
+
+static void sim_handle_write_data(struct net_device *ndev, u8 *buf, int length)
+{
+
+#define PC2400M_CMD_WRITE    0xcbbc0702
+#define PC2400M_CMD_JUMP     0xcbbc0503
+#define PC2400M_H2D_BARKER   0xcafe900d
+
+	u8 *ptr;
+	u8 *dataptr;
+	u8 *descptr;
+	u32 cnt;
+	u32 val;
+	u16 size;
+
+	/* scan the data for supported blocks */
+	pc2400m_sim_lose_spi_padding(buf, length);
+
+	ptr = buf;
+	val = EXTRACT_LE32(ptr);
+
+
+	/* simulate state change to CONFIG (DSim won't send it) */
+	if (val == PC2400M_CMD_JUMP)
+		pc2400m_sim_send_state_ind(
+			ndev, L3L4_SYSTEM_STATE_CONFIG);
+
+ 	switch (val&0xffff0000) {
+	case PC2400M_CMD_WRITE&0xffff0000:
+	  /*case PC2400M_CMD_JUMP&0xffff0000:*/
+		break;
+		
+	case PC2400M_H2D_BARKER&0xffff0000:
+		DEBUG("SIM: received H2D data.\n");
+		
+		cnt = EXTRACT_LE16(ptr+8);
+		descptr = ptr + 16;
+		dataptr = descptr + PAYLOAD_PAD(PC2400M_DESCRIPTOR_SIZE * cnt);
+
+		while (cnt) {
+			size = EXTRACT_LE16(descptr);
+			switch (EXTRACT_LE16(descptr + 2)) {
+			case FRAME_TYPE_DATA:
+				/* data frames not supported */
+				pc2400m_sim_return_to_sender(
+					ndev, dataptr, size);
+				break;
+			case FRAME_TYPE_CONTROL:
+				/* send to simulator socket */
+				if (!pc2400m_sim_local_resp(
+					    ndev, dataptr, size))
+					pc2400m_sim_send_to_socket
+						(ndev, dataptr, size);
+				break;
+			default:
+				ERROR("SIM: unknown data frame type "
+				      "received\n");
+				break;
+
+			}
+
+			cnt--;
+			descptr += PC2400M_DESCRIPTOR_SIZE;
+			size = PAYLOAD_PAD(size);
+			dataptr += size;
+
+		}
+		break;
+
+	default:
+		ERROR("SIM: Unknown data block ignored\n");
+	
+	}
+
+	return;
+
+}
+
+		
+static void pc2400m_sim_commit(struct net_device *ndev) 
+{
+
+	/* determine operation */
+	static u32 readsize = 0;
+	u32 cmd;
+
+	if (sim_queue_len >= 2) {
+		/* the first message will be the SDIO command */
+		if (sim_queue[0].read) {
+			ERROR("SIM transaction started with a read.\n");
+			return;
+		}
+		
+		switch ((*(sim_queue[0].ptr+1))&0x3f) {
+		case 0:
+			sim_queue[1].ptr[0] = 1;
+			break;
+		case 5:	      
+			memset(sim_queue[1].ptr, 0, sim_queue[1].len);
+			sim_queue[1].ptr[1] = 0x80;
+			sim_queue[1].ptr[2] = 0xff;
+			sim_queue[1].ptr[3] = 0x80;
+			sim_queue[1].ptr[4] = 0x00;
+			break;
+		case 52:
+			/* return the data for a write command */
+			memset(sim_queue[1].ptr, 0, sim_queue[1].len);
+			if (sim_queue[0].ptr[2] & 0x80) {
+				sim_queue[1].ptr[1] = sim_queue[0].ptr[5];
+			} else {
+				sim_queue[1].ptr[1] = 0;
+			}
+			
+			/* for certain registers specific behavior is needed */
+			cmd = ((u32)sim_queue[0].ptr[2]) << 24 |
+				((u32)sim_queue[0].ptr[3]) << 16 |
+				((u32)sim_queue[0].ptr[4]) << 8 |
+				sim_queue[0].ptr[5];
+			cmd >>= 9;
+			cmd &= 0x1ffff;
+			if (cmd == 0x1c) { 
+				readsize = pc2400m_sim_calc_read_size();
+				sim_queue[1].ptr[1] = (readsize)&0xff;
+			}
+			if (cmd == 0x1d) {
+				sim_queue[1].ptr[1] = 
+					((readsize)>>8)&0xff;
+			}
+			if (cmd == 0x05) {
+				sim_queue[1].ptr[1] = 0x02;
+			}
+			if (cmd == 0x04 && !(sim_queue[0].ptr[2] & 0x80)) {
+				sim_queue[1].ptr[1] = 0x01;
+			}
+				
+			break;
+		case 53:
+			if (sim_queue[0].ptr[2] & 0x80 &&
+			    sim_queue_len >= 3) {
+				/* a write command */
+
+				cmd = ((u32)sim_queue[1].ptr[2]) << 24 |
+					((u32)sim_queue[1].ptr[3]) << 16 |
+					((u32)sim_queue[1].ptr[4]) << 8 |
+					sim_queue[1].ptr[5];
+				cmd &= 0x1f;
+
+				/* check the data direction */
+				/* a write command */
+				if (!sim_queue[2].read)
+				{
+					sim_handle_write_data(
+						ndev,
+						sim_queue[2].ptr, 
+						sim_queue[2].len);
+				} else {
+					ERROR("SIM: Assumed write, "
+					      "got read\n");
+				}
+				
+				memset(sim_queue[1].ptr, 0, sim_queue[1].len);
+			} else if (!(sim_queue[0].ptr[2]&0x80) &&
+				    sim_queue_len >= 2) {
+				memcpy(sim_queue[1].ptr+2, sim_spi_buf,
+				       (sim_spi_buf_len/PC2400M_BLOCK_SIZE) *
+				       (PC2400M_BLOCK_SIZE+8));
+
+				sim_queue[1].ptr[0] = 0x00;
+				sim_queue[1].ptr[1] = 0x00; /* cmd53 resp */
+				sim_spi_buf_len = 0;
+			} else {
+				ERROR("SIM: Unknown cmd53\n");
+			}
+		
+
+			break;
+		default:
+			ERROR("Unknown command encountered.\n");
+			break;
+			
+		}
+		
+	} else {
+		ERROR("SIM not enough messages for transaction\n");
+	}
+
+	/* clear the queue */
+	sim_queue_len = 0;
+	return;
+
+}
+
+#if 0
+static void pc2400m_spi_commit_work(void *data)
+{
+
+	struct net_local *nl = netdev_priv((struct net_device*)data);
+	spi_commit_cb cb = nl->complete_cb;
+	void *cbdata = nl->cb_data;
+	s32 total = nl->spi_total;
+
+	/* commit the data */
+	pc2400m_sim_commit((struct net_device*)data);
+	
+	/* BEWARE: entry into the single threaded driver library; must
+	   be protected. */
+	pc2400m_com_lock();
+	nl->complete_cb = NULL;
+	nl->cb_data = NULL;	
+	cb((struct net_device*)data, total, cbdata);
+	pc2400m_com_unlock();
+
+}
+#endif
+
+/**
+ * pc2400m_spi_commit - commit queued simulator socket transactions
+ * @ndev: pointer to network device 
+ * @cb: call back function to be called when transactions complete
+ * @data: a data pointer passed as is to the completion callback
+ *
+ * Perform all queued transactions on the SPI bus
+ */
+static int pc2400m_spi_commit(struct net_device *ndev, spi_commit_cb cb, 
+			    void* data)
+{
+
+	struct net_local *nl = netdev_priv(ndev);
+	int ret = 0;
+
+	if (cb) {
+		BUG_ON(0);
+		nl->complete_cb = cb;
+		nl->cb_data = data;
+	} else {
+		pc2400m_sim_commit(ndev);
+	}
+
+	return ret;
+}
+
+static void pc2400m_spi_irq_work(struct work_struct *work)
+{
+	struct net_local *nl = container_of(work, struct net_local, irq_work);
+	struct socket *csocket = nl->sock;
+	struct socket *cindsocket = nl->indsock;
+
+	u32 start_length;
+	u32 hdrsize;
+
+  	char buffer[100];
+	int ret = 0;
+        struct msghdr msg;
+        struct kvec iov;
+
+	pc2400m_com_lock();
+	read_lock_bh(csocket->sk->sk_callback_lock);
+
+	/* read the data from the socket */
+	start_length = sim_read_buf_len;
+	while (1) {
+		iov.iov_base = buffer;
+		iov.iov_len = 100;
+		msg.msg_name = NULL;
+		msg.msg_control= NULL;
+		msg.msg_controllen = 0;
+		msg.msg_flags = MSG_DONTWAIT;
+		msg.msg_namelen = 0;
+
+		ret = kernel_recvmsg(
+			csocket, &msg, &iov, 1, 100, msg.msg_flags); 
+		if (ret == 0 || ret == -EAGAIN) break;
+		if (ret < 0) {
+			ERROR("SIM: Socket read error occurred (%d)\n", ret);
+			goto err1;
+		}
+
+		if (sim_read_buf_len + ret >= PC2400M_MAX_TRANSACTION) {
+			ERROR("SIM: Read buffer overflow\n");
+			goto err1;
+		}
+		
+		memcpy(sim_read_buf+sim_read_buf_len, buffer, ret);
+		sim_read_buf_len += ret;
+		
+	}
+
+	goto ind;
+ err1:
+	sim_read_buf_len = 0;
+
+ ind:
+	if (sim_read_buf_len > start_length) {
+		hdrsize = EXTRACT_LE32(sim_read_buf+start_length);
+		sim_read_buf_len = start_length + hdrsize + 4;
+		INSERT_LE32(sim_read_buf+start_length+4, FRAME_TYPE_CONTROL);
+	}
+
+	read_unlock_bh(csocket->sk->sk_callback_lock);
+
+	read_lock_bh(cindsocket->sk->sk_callback_lock);
+
+	/* read the data from the indications socket */
+	start_length = sim_read_buf_len;
+	while (1) {
+		iov.iov_base = buffer;
+		iov.iov_len = 100;
+		msg.msg_name = NULL;
+		msg.msg_control= NULL;
+		msg.msg_controllen = 0;
+		msg.msg_flags = MSG_DONTWAIT;
+		msg.msg_namelen = 0;
+
+		ret = kernel_recvmsg(
+			cindsocket, &msg, &iov, 1, 100, msg.msg_flags); 
+		if (ret == 0 || ret == -EAGAIN) break;
+		if (ret < 0) {
+			ERROR("SIM: Socket read error occurred (%d)\n", ret);
+			goto err2;
+		}
+
+		if (sim_read_buf_len + ret >= PC2400M_MAX_TRANSACTION) {
+			ERROR("SIM: Read buffer overflow\n");
+			goto err2;
+		}
+
+#if 0			
+		/* simulate oid message header */
+		INSERT_LE32(sim_read_buf+sim_read_buf_len, ret+4);
+		sim_read_buf_len+=8;
+#endif	
+	
+		memcpy(sim_read_buf+sim_read_buf_len, buffer, ret);
+		sim_read_buf_len += ret;
+	
+	}
+
+	goto out;
+ err2:
+	sim_read_buf_len = 0;
+ out:
+	if (sim_read_buf_len > start_length) {
+		hdrsize = EXTRACT_LE32(sim_read_buf+start_length);
+		sim_read_buf_len = start_length + hdrsize + 4;
+		INSERT_LE32(sim_read_buf+start_length+4, FRAME_TYPE_CONTROL);
+	}
+
+	read_unlock_bh(cindsocket->sk->sk_callback_lock);
+	pc2400m_com_unlock();
+
+	/* BEWARE: entry into the single threaded driver library; must
+	   be protected. */
+	pc2400m_com_lock();
+	if (nl->irq_cb) {
+		nl->irq_cb(nl->net_dev);
+	} else {
+		DEBUG("SIM: Data interrupt lost.\n");
+	}
+	pc2400m_com_unlock();
+
+}
+
+/**
+ * pc2400m_spi_enable_irq - register and enable interrupt handler
+ * @ndev: pointer to network device 
+ * @irq_cb: call back function to be called when interrupt occurs
+ *
+ * Register a callback for interrupt handling and enable interrupts
+ */
+static void pc2400m_spi_enable_irq(struct net_device* ndev, spi_irq_cb irq_cb)
+{
+
+	struct net_local *nl = netdev_priv(ndev);
+
+	if (irq_cb) {
+		nl->irq_cb = irq_cb;
+	} else {
+		nl->irq_cb = NULL;
+	}
+
+}
+
+
+/**
+ * pc2400m_spi_set_power - power on and off the chipset
+ * @ndev: pointer to the device structure identifying the device
+ * @on: nonzero sets power on, zero sets power off
+ *
+ * Use the main power GPIO to set on and off power to the associated
+ * chipset
+ */
+static void pc2400m_spi_set_power(struct net_device *ndev, u8 on)
+{
+
+	if (on) {
+		DEBUG("Switching power on\n");
+	} else {
+		DEBUG("Switching power off\n");
+	}
+
+	return;
+
+}
+/**
+ * pc2400m_spi_configure - change configured bus speed and parameters
+ * @ndev: pointer to the device structure identifying the device
+ * @freq: clock frequency to set for the bus
+ * @flags: bus specific configuration flags
+ *
+ * Change the clock frequency and bus parameters for a specific spi device
+ */
+static void pc2400m_spi_configure(struct net_device *ndev, u32 freq, u32 flags)
+{
+
+	INFO("SPI configuration change ignored\n");
+	return;
+
+}
+
+static void pc2400m_sim_state_change(struct sock *sk) 
+{
+
+	/*struct net_device *ndev = (struct net_device *)sk->sk_user_data;*/
+
+	/* then make our deductions on the info */
+	read_lock(&sk->sk_callback_lock);
+	switch(sk->sk_state) {
+                /* ignore connecting sockets as they make progress */
+	case TCP_SYN_SENT:
+	case TCP_SYN_RECV:
+		break;
+	case TCP_ESTABLISHED:
+		break;
+	default:
+		/* will be released upon module removal */
+
+		ERROR("SIM: Simulator connection lost, reinsert of module "
+		      "needed!\n");
+		
+		break;
+        }
+	
+	read_unlock(&sk->sk_callback_lock);
+
+	/* call the regular state change handler */
+        orig_state_change(sk);
+
+}
+
+
+static void pc2400m_sim_data_ready(struct sock* sock, int bytes)
+{
+	struct net_local *nl = 
+		netdev_priv((struct net_device*)sock->sk_user_data);
+
+	/* indicate an interrupt */
+	schedule_work(&nl->irq_work);
+
+#if 0 /* this may cause troube */
+	/* perform original handling */
+	//orig_data_ready(sock, bytes);
+#endif
+	return;	
+}
+
+
+static unsigned int pc2400m_sim_hook(unsigned int hooknum,
+				   struct sk_buff **skb,
+				   const struct net_device *in,
+				   const struct net_device *out,
+				   int (*okfn)(struct sk_buff *))
+{
+
+	struct net_local *nl;
+	struct in_device *idev;
+
+	if (!pc2400m_spi_wimax_device) return NF_ACCEPT;
+       
+	nl = netdev_priv(pc2400m_spi_wimax_device);
+	idev = (struct in_device*)(pc2400m_spi_wimax_device->ip_ptr);
+
+	/* no mangling is done, until our interface has an address */
+	if (!idev) return NF_ACCEPT;
+	if (!idev->ifa_list) return NF_ACCEPT;
+
+	if (*((u32*)(&((*skb)->data[12]))) == 
+	    idev->ifa_list->ifa_address) {
+
+		DEBUG("SIM: Outgoing: %d.%d.%d.%d => %d.%d.%d.%d\n",
+		      (*skb)->data[12],
+		      (*skb)->data[13], 
+		      (*skb)->data[14], 
+		      (*skb)->data[15],
+		      (*skb)->data[16],
+		      (*skb)->data[17], 
+		      (*skb)->data[18], 
+		      (*skb)->data[19]);
+		
+		/* replace the source address */
+		*((u32*)(&((*skb)->data[12]))) =
+			htonl(for_addr);
+		
+		/* replace the target address network part */
+		(*skb)->data[16] = (u8)(for_addr>>24);
+		(*skb)->data[17] = (u8)(for_addr>>16);
+		(*skb)->data[18] = (u8)(for_addr>>8);
+
+		DEBUG("SIM: Mangled:  %d.%d.%d.%d => %d.%d.%d.%d\n",
+		      (*skb)->data[12],
+		      (*skb)->data[13], 
+		      (*skb)->data[14], 
+		      (*skb)->data[15],
+		      (*skb)->data[16],
+		      (*skb)->data[17], 
+		      (*skb)->data[18], 
+		      (*skb)->data[19]);
+
+		
+		/* recalc the header checksum */
+		*((u16*)(&((*skb)->data[10]))) = 0;
+		*((u16*)(&((*skb)->data[10]))) = 
+			ip_fast_csum((const void*)
+				     ((*skb)->data),
+				     ((*skb)->data[0])&0xf);
+
+		ip_route_me_harder(skb, RTN_UNSPEC);
+		
+	} else if (ntohl(*((u32*)(&((*skb)->data[16])))) == for_addr) {
+		
+		DEBUG("SIM: Incoming: %d.%d.%d.%d => %d.%d.%d.%d\n",
+		      (*skb)->data[12],
+		      (*skb)->data[13], 
+		      (*skb)->data[14], 
+		      (*skb)->data[15],
+		      (*skb)->data[16],
+		      (*skb)->data[17], 
+		      (*skb)->data[18], 
+		      (*skb)->data[19]);
+
+		/* replace the target address */
+		*((u32*)(&((*skb)->data[16]))) =
+			idev->ifa_list->ifa_address;
+		
+		/* replace the source address network part */
+		(*skb)->data[12] = (u8)((idev->ifa_list->ifa_address));
+		(*skb)->data[13] = (u8)((idev->ifa_list->ifa_address>>8));
+		(*skb)->data[14] = (u8)((idev->ifa_list->ifa_address>>16));
+
+		DEBUG("SIM: Mangled:  %d.%d.%d.%d => %d.%d.%d.%d\n",
+		      (*skb)->data[12],
+		      (*skb)->data[13], 
+		      (*skb)->data[14], 
+		      (*skb)->data[15],
+		      (*skb)->data[16],
+		      (*skb)->data[17], 
+		      (*skb)->data[18], 
+		      (*skb)->data[19]);
+
+		/* recalc the header checksum */
+		*((u16*)(&((*skb)->data[10]))) = 0;
+		*((u16*)(&((*skb)->data[10]))) = 
+			ip_fast_csum((const void*)
+				     ((*skb)->data),
+				     ((*skb)->data[0])&0xf);
+				
+	}
+	
+	return NF_ACCEPT;
+
+}
+
+
+
+static int pc2400m_sim_connect(void)
+{
+	
+	struct net_device *ndev;
+        struct net_local *lp;
+	struct socket *csocket;
+	struct socket *cindsocket;
+	struct sockaddr_in addr;
+	int rc;
+
+	/* create a network device to represent this device */
+	ndev = pc2400m_if_new_device();
+	if (!ndev) {
+		ERROR("Failed to bind %d.%d.%d.%d:%d\n",
+		      (u8)(sim_addr>>24),
+		      (u8)(sim_addr>>16),
+		      (u8)(sim_addr>>8),
+		      (u8)(sim_addr),
+		      sim_port);
+		return -ENOMEM;
+	}
+	lp = netdev_priv(ndev);
+	
+	rc = platform_device_register(&pc2400m_sim_device);
+	if (rc) {
+		ERROR("SIM: Could not register Pc2400m simulator dev\n");
+		goto err3;
+	}
+	lp->spi_dev = &pc2400m_sim_device;
+	lp->spi_dev->dev.driver_data = (void*)ndev;
+	
+	/* initialize workqueues */
+	INIT_WORK(&(lp->irq_work), pc2400m_spi_irq_work);
+	INIT_WORK(&(lp->spi_work), pc2400m_sim_return_to_sender_work);
+
+	pc2400m_com_lock();
+	rc = sock_create_kern(PF_INET, SOCK_STREAM, IPPROTO_TCP, &csocket);
+	if (rc < 0) {
+		ERROR("Error %d creating socket\n",rc);
+		pc2400m_com_unlock();
+		goto err2;
+	} else {
+		csocket->sk->sk_allocation = GFP_NOFS;
+	}
+
+	rc = sock_create_kern(PF_INET, SOCK_STREAM, IPPROTO_TCP, &cindsocket);
+	if (rc < 0) {
+		ERROR("Error %d creating socket\n",rc);
+		pc2400m_com_unlock();
+		goto err1;
+	} else {
+		cindsocket->sk->sk_allocation = GFP_NOFS;
+	}
+	
+	/* register callbacks */
+	write_lock_bh(csocket->sk->sk_callback_lock);
+	csocket->sk->sk_user_data = (void*)ndev;
+	orig_data_ready = csocket->sk->sk_data_ready;
+	orig_state_change = csocket->sk->sk_state_change;
+	csocket->sk->sk_data_ready = pc2400m_sim_data_ready;
+	csocket->sk->sk_state_change = pc2400m_sim_state_change;
+	write_unlock_bh(csocket->sk->sk_callback_lock);
+
+	write_lock_bh(cindsocket->sk->sk_callback_lock);
+	cindsocket->sk->sk_user_data = (void*)ndev;
+	cindsocket->sk->sk_data_ready = pc2400m_sim_data_ready;
+	cindsocket->sk->sk_state_change = pc2400m_sim_state_change;
+	write_unlock_bh(cindsocket->sk->sk_callback_lock);
+
+	memset(&addr, 0x00, sizeof(struct sockaddr_in));
+        addr.sin_family = AF_INET;
+	addr.sin_port = htons(sim_port);
+	addr.sin_addr.s_addr = htonl(sim_addr);
+	rc = csocket->ops->connect(csocket, (struct sockaddr*)&addr, 
+				   sizeof(struct sockaddr_in), 0);
+	if (rc < 0) {
+		ERROR("Connect failure %d\n", rc);
+		pc2400m_com_unlock();
+		goto err0;
+        }
+	lp->sock = csocket;
+
+	memset(&addr, 0x00, sizeof(struct sockaddr_in));
+        addr.sin_family = AF_INET;
+	addr.sin_port = htons(sim_port+1);
+	addr.sin_addr.s_addr = htonl(sim_addr);
+	rc = cindsocket->ops->connect(cindsocket, (struct sockaddr*)&addr, 
+				      sizeof (struct sockaddr_in), 0);
+	if (rc < 0) {
+		ERROR("Connect (ind) failure %d\n", rc);
+		pc2400m_com_unlock();
+		goto err0;
+        }
+	lp->indsock = cindsocket;
+
+	pc2400m_com_unlock();
+
+	if (pc2400m_if_init_device(ndev)) {
+		ERROR("Device init failed (%s)\n", ndev->name);
+		goto err0;
+	}
+
+	/* register a netfilter hook to steal interface data */
+	if (for_addr) {
+
+		if (nf_register_hook(&pc2400m_sim_hook_ops_in)) {
+			ERROR("Registering nf hook failed.\n");
+		}
+
+		if (nf_register_hook(&pc2400m_sim_hook_ops_out)) {
+			ERROR("Registering nf hook failed.\n");
+		}
+		
+	}
+
+		
+	ERROR("Bound %s to simulator @ %d.%d.%d.%d:%d (%d)\n",
+	      ndev->name,
+	      (u8)(sim_addr>>24),
+	      (u8)(sim_addr>>16),
+	      (u8)(sim_addr>>8),
+	      (u8)(sim_addr),
+	      sim_port, sim_port+1);
+
+	goto out;
+
+ err0:
+	sock_release(cindsocket);
+
+ err1:
+	sock_release(csocket);
+
+ err2:
+	platform_device_unregister(&pc2400m_sim_device);
+
+ err3:
+	pc2400m_if_free_device(ndev);
+	return -ENODEV;
+
+ out:	 
+	pc2400m_spi_wimax_device = ndev;
+        return 0;
+}
+
+static int pc2400m_sim_remove(void)
+{
+
+	struct net_local *lp = NULL;
+	struct socket *sock = NULL;
+	struct socket *indsock = NULL;
+
+	/* MISSING: be sure that there is no asynchronous operation ongoing
+	   depending on the network interfaces */
+
+	/* need to get rid of the corresponding network device */
+	if (pc2400m_spi_wimax_device) {
+		lp = netdev_priv(pc2400m_spi_wimax_device);
+		sock = lp->sock;
+		indsock = lp->indsock;
+
+		if (for_addr) {
+			nf_unregister_hook(&pc2400m_sim_hook_ops_in);
+			nf_unregister_hook(&pc2400m_sim_hook_ops_out);
+		}
+
+		INFO("Unbinding %s\n", lp->net_dev->name);
+		pc2400m_if_free_device(lp->net_dev);
+		platform_device_unregister(&pc2400m_sim_device);
+		if (sock) sock_release(sock);
+		if (indsock) sock_release(indsock);
+
+	}
+
+        return 0;
+}
+
+void pc2400m_spi_stop(struct net_device *dev)
+{
+#if 0
+	omap_free_gpio(wlan_config->power_gpio);
+	omap_free_gpio(wlan_config->irq_gpio);
+#endif
+}
+
+
+static int __init pc2400m_spi_init_module(void)
+{
+
+	INFO("Pc2400m driver (c) Nokia 2007 loaded.\n");
+
+	memset(&pc2400m_drv_adapt, 0, sizeof(pc2400m_drv_adapt));
+	init_MUTEX(&pc2400m_com_mutex);
+	pc2400m_drv_adapt.h2d = pc2400m_spi_h2d;
+	pc2400m_drv_adapt.d2h = pc2400m_spi_d2h;
+	pc2400m_drv_adapt.commit = pc2400m_spi_commit;
+	pc2400m_drv_adapt.enable_irq = pc2400m_spi_enable_irq;
+	pc2400m_drv_adapt.configure = pc2400m_spi_configure;
+	pc2400m_drv_adapt.set_power = pc2400m_spi_set_power;
+
+	return pc2400m_sim_connect();
+	
+}
+
+static void __exit pc2400m_spi_cleanup_module(void)
+{
+
+	/* MISSING: be sure that no transactions are ongoing when doing
+	   this */
+
+	pc2400m_sim_remove();
+
+}
+
+module_init(pc2400m_spi_init_module);
+module_exit(pc2400m_spi_cleanup_module);
+
+MODULE_LICENSE("GPL v2");
+
+
+#endif /* CONFIG_NET_PC2400M_SIM */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_spi.c maemo_src/drivers/net/wireless/pc2400m/pc2400m_spi.c
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_spi.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_spi.c	2011-02-06 20:12:11.623333273 -0500
@@ -0,0 +1,849 @@
+/*
+ * pc2400m_spi.c
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         43      APPROVED 06-Aug-2008 Juuso Oikarinen
+*/
+
+/** @file pc2400m_spi.c
+ *
+ * This file provides the SPI adaptation for the common driver.
+ *
+ */
+
+/*****************************************************************************
+ * Include files
+ */
+
+#define __KERNEL_SYSCALLS__
+
+#include <linux/version.h>
+#ifdef MODULE
+#ifdef MODVERSIONS
+#include <linux/modversions.h>
+#endif
+#include <linux/module.h>
+#else
+#define MOD_INC_USE_COUNT
+#define MOD_DEC_USE_COUNT
+#endif
+
+#include <linux/init.h>
+#include <linux/netdevice.h>
+#include <linux/clk.h>
+#include <linux/spi/spi.h>
+#include <linux/platform_device.h>
+#include <linux/string.h>
+#include <linux/firmware.h>
+#include <asm/bitops.h>
+#include <asm/arch/gpio.h>
+
+#if !defined(CONFIG_FW_LOADER) && !defined(CONFIG_FW_LOADER_MODULE)
+#error No Firmware Loading configured in the kernel !
+#endif
+
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/arch/board.h>
+
+#include "pc2400m_if.h"
+#include "pc2400m_spi.h"
+#include "pc2400m_i2c.h"
+#include "pc2400m_com.h"
+#include "pc2400m_al.h"
+#include "pc2400m_release.h"
+
+/*****************************************************************************
+ * Global constants and macros
+ */
+
+/** device name for identification */
+#define PC2400M_SPI_DEVICE_NAME "pc2400m"
+
+/** treshold for using PIO instead of DMA */
+#define PC2400M_SPI_DMA_THRESHOLD  12
+
+/** maximum number of SPI transfers in one SPI transaction */
+#define PC2400M_SPI_MAX_TRANSFERS  3
+
+/*****************************************************************************
+ * Global data types
+ */
+
+/** structure to hold IRQ handler data */
+struct pc2400m_spi_irq_data {
+        struct work_struct work;
+        spinlock_t lock;
+        struct net_local *nl;
+        void (*cb)(struct net_device*);
+#define PC2400M_IRQ_PENDING   0x00000001
+#define PC2400M_IRQ_EXECUTING 0x00000002
+        u32 flags;
+};
+
+/** structure to hold SPI data */
+struct pc2400m_spi_data {
+        u32 spi_total;
+        u32 spi_xfer_idx;
+        struct spi_message spi_msg;
+        struct spi_transfer spi_xfer[PC2400M_SPI_MAX_TRANSFERS];
+};
+
+/** list to maintain all pc2400m devices managed by this driver */
+LIST_HEAD(pc2400m_spi_wimax_device);
+
+/** global variable holding the currently executing context -
+    this is valid only within the common driver. */
+struct net_device *pc2400m_com_running_context;
+
+/**
+ * Global lock for the adaptation library. This is global, because the driver
+ * lib needs to be concurrency protected from multiple accesses regardless
+ * of the number of instances with one single lock. */
+struct semaphore pc2400m_com_mutex;
+
+/** function interface structure for adaptation layers */
+struct t_wihal_adaptation_if pc2400m_spi_wihal_adapt;
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+static irqreturn_t pc2400m_spi_irq(int irq, void *config);
+static int pc2400m_spi_probe(struct spi_device *spi);
+static int pc2400m_spi_remove(struct spi_device *spi);
+static void pc2400m_spi_shutdown(struct spi_device *spi);
+static int pc2400m_spi_suspend(struct spi_device *spi, pm_message_t mesg);
+static int pc2400m_spi_resume(struct spi_device *spi);
+
+/** driver registration structure */
+static struct spi_driver pc2400m_driver = {
+        .driver = {
+                .name           = PC2400M_SPI_DEVICE_NAME,
+                .bus            = &spi_bus_type,
+                .owner          = THIS_MODULE,
+        },
+
+        .probe          = pc2400m_spi_probe,
+        .shutdown       = pc2400m_spi_shutdown,
+        .remove         = __devexit_p(pc2400m_spi_remove),
+        .suspend        = pc2400m_spi_suspend,
+        .resume         = pc2400m_spi_resume,
+};
+
+
+/*****************************************************************************
+ * Local functions
+ */
+
+/** Queue an SPI write. This function is used to queue an SPI write for
+ *  execution upon the next commit. The function quarantees sane memory
+ *  behavior even upon failure, so the return status can safely be
+ *  ignored.
+ *
+ *  @param ndev pointer to network device
+ *  @param data a buffer containing the data to write
+ *  @param length length of the buffer to write (in bytes)
+ *  @return the length scheduled for write
+ */
+static s32 pc2400m_spi_h2d(struct net_device *ndev, u8* data, s32 length)
+{
+
+        struct net_local *nl = netdev_priv(ndev);
+        struct spi_transfer *t;
+
+        t = &(nl->spi_data->spi_xfer[nl->spi_data->spi_xfer_idx++]);
+        wimax_osal_assert(
+                nl->spi_data->spi_xfer_idx <= PC2400M_SPI_MAX_TRANSFERS);
+        nl->spi_data->spi_total += length;
+
+        /* t->cs_change = 0;
+           t->bits_per_word = 0;
+           t->speed_hz = 0; */
+        t->tx_buf = data;
+        t->rx_buf = NULL;
+        t->tx_dma = length<=PC2400M_SPI_DMA_THRESHOLD?0:virt_to_phys(data);
+        t->rx_dma = 0;
+        t->len = length;
+
+        spi_message_add_tail(t, &(nl->spi_data->spi_msg));
+
+        return length;
+}
+
+/** Queue an SPI read. This function is used to queue an SPI read for
+ *  execution upon the next commit. The function quarantees sane memory
+ *  behavior even upon failure, so the return status can safely be
+ *  ignored.
+ *
+ *  @param ndev pointer to network device
+ *  @param data a buffer containing space for the read data
+ *  @param length length of the data to read (in bytes)
+ *  @return the length scheduled for read
+ */
+static s32 pc2400m_spi_d2h(struct net_device *ndev, u8* buf, s32 length)
+{
+
+        struct net_local *nl = netdev_priv(ndev);
+        struct spi_transfer *t;
+
+        t = &(nl->spi_data->spi_xfer[nl->spi_data->spi_xfer_idx++]);
+        wimax_osal_assert(
+                nl->spi_data->spi_xfer_idx <= PC2400M_SPI_MAX_TRANSFERS);
+        nl->spi_data->spi_total += length;
+
+        /* t->cs_change = 0;
+           t->bits_per_word = 0;
+           t->speed_hz = 0; */
+        t->tx_buf = NULL;
+        t->rx_buf = buf;
+        t->tx_dma = 0;
+        t->rx_dma = length<=PC2400M_SPI_DMA_THRESHOLD?0:virt_to_phys(buf);
+        t->len = length;
+
+        spi_message_add_tail(t, &(nl->spi_data->spi_msg));
+
+        return length;
+
+}
+
+/** Commit queued SPI transactions. This function performs scheduled write and
+ *  read transactions on the SPI bus. This function only supports synchronous
+ *  access. The memory behavior of the function remains sane even if an error
+ *  occurs, so the return value may be safely ignored.
+ *
+ *  @param ndev pointer to network device
+ *  @param cb call back function to be called when transactions complete
+ *  @param data a data pointer passed as is to the completion callback
+ *  @return returns the total bytes read and written during the transaction
+ */
+static int pc2400m_spi_commit(struct net_device *ndev, spi_commit_cb cb,
+                              void* data)
+{
+
+        struct net_local *nl = netdev_priv(ndev);
+        int spi_total = 0;
+
+        PC2400M_UNWARN(data);
+
+        /* asynchronous operations are not implemented by this interface */
+        BUG_ON((int)cb);
+
+        spi_total = nl->spi_data->spi_total;
+
+        wimax_osal_assert(nl->spi_data->spi_xfer_idx != 0);
+        spi_sync(nl->spi_dev, &(nl->spi_data->spi_msg));
+
+        nl->spi_data->spi_xfer_idx = 0;
+        nl->spi_data->spi_total = 0;
+
+        spi_message_init(&(nl->spi_data->spi_msg));
+        nl->spi_data->spi_msg.is_dma_mapped = 1;
+
+        return spi_total;
+}
+
+/** Hardware interrupt workqueue handler. This function is executed from the
+ *  actual hardware interrupt handler. This function invokes the underlying
+ *  common driver interrupt handler. This function will execute up to a
+ *  configured number of interrupts without re-invocation, and then yield
+ *  the workqueue for subsequent functions.
+ *
+ *  @param work pointer to the work structure
+ *  @return none
+ */
+static void pc2400m_spi_irq_work(struct work_struct *work)
+{
+        struct pc2400m_spi_irq_data *irq_data =
+                container_of(work, struct pc2400m_spi_irq_data, work);
+        unsigned long flags;
+        int schedule = 0;
+        int count = 0;
+
+        spin_lock_irqsave(&(irq_data->lock), flags);
+        while((irq_data->flags & PC2400M_IRQ_PENDING) &&
+              (count < PC2400M_CONF_MAX_IRQ_LOOPS)) {
+                irq_data->flags &= (~PC2400M_IRQ_PENDING);
+                spin_unlock_irqrestore(&(irq_data->lock), flags);
+
+                /* increment the counter used to avoid too many subsequent
+                   loops of interrupt handling -> otherwise uplink tasks
+                   will be starved in the workqueue */
+                count ++;
+
+                /* BEWARE: entry into the single threaded driver
+                   library; must be protected. */
+                pc2400m_com_lock(irq_data->nl->net_dev);
+
+                /* if the interrupt call back is still set, we can trust
+                   that the nl still exists -> this has been enforced with
+                   asserts in the appropriate places. */
+                if (irq_data->cb)
+                        irq_data->cb(irq_data->nl->net_dev);
+                pc2400m_com_unlock();
+
+                spin_lock_irqsave(&(irq_data->lock), flags);
+        }
+
+        /* if the loop was exited due to the loop variable and interrupts
+           are still pending, schedule another run */
+        if (irq_data->flags & PC2400M_IRQ_PENDING)
+                schedule = 1;
+        else
+                irq_data->flags &= (~PC2400M_IRQ_EXECUTING);
+
+        /* if the IRQ structure has been marked for deleting, do so */
+        if (!irq_data->cb) {
+                spin_unlock_irqrestore(&(irq_data->lock), flags);
+                kfree(irq_data);
+        } else {
+                spin_unlock_irqrestore(&(irq_data->lock), flags);
+        }
+
+        if (schedule)
+                queue_work(irq_data->nl->wq, &(irq_data->work));
+
+        return;
+}
+
+
+/** Hardware interrupt handler. This function services the registered
+ *  hardware interrupt. The interrupt is serviced by enqueueing an workqueue
+ *  handler for the interrupt, and if one is already enqueued/executing, by
+ *  signalling the workqueue function of a further interrupt.
+ *
+ *  @param irq identifier of the interrupt
+ *  @param config user cookie value carrying the IRQ data structure
+ *  @return IRQ_HANDLED
+ */
+static irqreturn_t pc2400m_spi_irq(int irq, void *config)
+{
+        struct pc2400m_spi_irq_data *irq_data = config;
+        unsigned long flags;
+        int schedule = 1;
+
+        PC2400M_UNWARN(irq);
+
+        spin_lock_irqsave(&(irq_data->lock), flags);
+
+        /* mark a pending interrupt */
+        irq_data->flags |= PC2400M_IRQ_PENDING;
+
+        /* if the worker is already running for this device, do not schedule
+           a new one */
+        if (irq_data->flags & PC2400M_IRQ_EXECUTING)
+                schedule = 0;
+        else
+                irq_data->flags |= PC2400M_IRQ_EXECUTING;
+        spin_unlock_irqrestore(&(irq_data->lock), flags);
+
+        if (schedule) {
+                queue_work(irq_data->nl->wq, &(irq_data->work));
+        }
+
+        return IRQ_HANDLED;
+
+}
+
+/** Check whether an interrupt is waiting execution. This function checks
+ *  whether an interrupt is pending execution. If this function returns TRUE,
+ *  it is quaranteed that the interrupt handler will be invoked shortly.
+ *
+ *  @param ndev pointer to network device structure
+ *  @return TRUE if the interrupt handler is pending execution, FALSE
+ *          otherwise.
+ */
+static boolean pc2400m_spi_irq_pending(struct net_device *ndev)
+{
+
+        struct net_local *nl = netdev_priv(ndev);
+        unsigned long flags;
+        boolean ret = FALSE;
+
+        /* the irq_data will not disappear within the scope of this function,
+           as this will always be executed within the protection of the common
+           driver lock */
+        if (!nl->irq_data)
+                goto out;
+
+        spin_lock_irqsave(&(nl->irq_data->lock), flags);
+        if (nl->irq_data->flags & PC2400M_IRQ_PENDING)
+                ret = TRUE;
+        spin_unlock_irqrestore(&(nl->irq_data->lock), flags);
+
+ out:
+        return ret;
+
+}
+
+/** Register and enable interrupt handler. This function is used to register
+ *  a handler function for hardware interrupts. The handler function will be
+ *  invoked from within a workqueue function.
+ *
+ *  @param ndev pointer to network device structure
+ *  @param irq_cb call back function to be called when interrupt occurs
+ *  @return none
+ */
+static void pc2400m_spi_enable_irq(struct net_device* ndev, spi_irq_cb irq_cb)
+{
+
+        struct net_local *nl = netdev_priv(ndev);
+        struct pc2400m_spi_irq_data *irq_data;
+        unsigned long flags;
+
+        /* this function is always called under the global lock of the
+           common driver */
+        if (irq_cb) {
+                wimax_osal_assert(!nl->irq_data);
+
+                /* create an IRQ data structure */
+                irq_data = kzalloc(sizeof(struct pc2400m_spi_irq_data),
+                                   GFP_KERNEL | __GFP_NOFAIL);
+
+                irq_data->nl = nl;
+                irq_data->cb = irq_cb;
+                irq_data->flags = 0;
+                spin_lock_init(&(irq_data->lock));
+                INIT_WORK(&(irq_data->work), pc2400m_spi_irq_work);
+
+                nl->irq_data = irq_data;
+
+                /* request the IRQ callback */
+                if (request_irq(
+                            OMAP_GPIO_IRQ(nl->irq_gpio),
+                            pc2400m_spi_irq,
+                            IRQF_TRIGGER_FALLING,
+                            PC2400M_SPI_DEVICE_NAME, (void*)irq_data))
+                        ERROR("Cannot register IRQ on GPIO %d\n",
+                              nl->irq_gpio);
+        } else {
+
+                wimax_osal_assert(nl->irq_data);
+                irq_data = nl->irq_data;
+
+                free_irq(OMAP_GPIO_IRQ(nl->irq_gpio), irq_data);
+
+                /* if the IRQ worker is not running, it is safe to remove
+                   the IRQ structure now, otherwise mark it to be deleted
+                   when the worker is complete */
+                spin_lock_irqsave(&(irq_data->lock), flags);
+                if (irq_data->flags & PC2400M_IRQ_EXECUTING) {
+                        irq_data->cb = NULL;
+                        irq_data->flags &= (~PC2400M_IRQ_PENDING);
+                        nl->irq_data = NULL;
+                        spin_unlock_irqrestore(&(irq_data->lock), flags);
+                } else {
+                        nl->irq_data = NULL;
+                        spin_unlock_irqrestore(&(irq_data->lock), flags);
+                        kfree(irq_data);
+                }
+
+        }
+
+}
+
+/** Change SPI bus configuration. This function changes the SPI bus speed
+ *  and the read/write trigger clock edge.
+ *
+ *  @param ndev pointer to the device structure identifying the device
+ *  @param freq clock frequency to set for the bus
+ *  @param flags bus specific configuration flags
+ *  @return none
+ */
+static void pc2400m_spi_configure(struct net_device *ndev, u32 freq, u32 flags)
+{
+
+        struct net_local *nl = netdev_priv(ndev);
+        struct spi_device *spi = nl->spi_dev;
+
+        DEBUG("SPI bus clock set to %d Hz, flags %8.8x.\n", freq, flags);
+        if (flags & SPI_CONFIG_SAMPLE_FALLING)
+                spi->mode = SPI_MODE_0 | SPI_MOSI_HIGH;
+        else
+                spi->mode = SPI_MODE_1 | SPI_MOSI_HIGH;
+        spi->bits_per_word = 8;
+        spi->max_speed_hz = freq;
+        spi_setup(spi);
+        return;
+
+}
+
+/** Power on and off the chipset. This function switches on and off the
+ *  chipset power by enabling or disabling a specific GPIO.
+ *
+ *  @param ndev pointer to the device structure identifying the device
+ *  @param on TRUE to switch power on, FALSE to switch power off
+ */
+static void pc2400m_spi_set_power(struct net_device *ndev, u8 on)
+{
+
+        struct net_local *nl = netdev_priv(ndev);
+
+        /* having interrupts enabled when powering on or off is begging
+           for trouble.. */
+        wimax_osal_assert(!nl->irq_data);
+
+        if (on) {
+                DEBUG("Switching power on\n");
+                omap_set_gpio_dataout(nl->power_gpio, 1);
+
+                /* configure the step down converter */
+                pc2400m_i2c_init();
+                pc2400m_i2c_set_1_8_volts();
+                pc2400m_i2c_exit();
+
+                msleep(10);
+                omap_set_gpio_dataout(nl->reset_gpio, 1);
+                msleep(10);
+        } else {
+                DEBUG("Switching power off\n");
+                omap_set_gpio_dataout(nl->reset_gpio, 0);
+                omap_set_gpio_dataout(nl->power_gpio, 0);
+
+                /* bus clock to slow after power down */
+                pc2400m_spi_configure(ndev, 24000000, 0);
+
+        }
+
+        return;
+
+}
+
+
+/** Probe an SPI device. This function is invoked by the kernel when it has
+ *  identified an SPI device matching this driver. This function initializes
+ *  one instance of the driver and binds it to the found SPI device.
+ *
+ *  @param spi pointer to SPI device structure identifying the device
+ *  @return 0 upon success or -ENOMEM if memory could not be allocated
+ */
+static int pc2400m_spi_probe(struct spi_device *spi)
+{
+
+        struct net_device *ndev;
+        struct net_local *lp;
+        const struct omap_pc2400m_config *config;
+        static int config_cnt = 0;
+
+        /* configure the SPI device */
+        spi->mode = SPI_MODE_1 | SPI_MOSI_HIGH;
+        spi->bits_per_word = 8;
+        if (!spi->max_speed_hz || spi->max_speed_hz > 24000000)
+                spi->max_speed_hz = 24000000;
+        spi_setup(spi);
+
+        /* create a network device to represent this device */
+        ndev = pc2400m_if_new_device();
+        if (!ndev) {
+                ERROR("Failed to bind SPI bus %d, cs %d, mode %2.2x\n",
+                      spi->master->bus_num, spi->chip_select, spi->mode);
+                goto err1;
+        }
+
+        /* store net netdevice to driver data */
+        spi->dev.driver_data = (void*)ndev;
+        lp = netdev_priv(ndev);
+        lp->spi_dev = spi;
+
+        /* spi transfer data */
+        lp->spi_data = (struct pc2400m_spi_data*)
+                kzalloc(sizeof(struct pc2400m_spi_data), GFP_KERNEL);
+        if (!lp->spi_data)
+                goto err2;
+
+        spi_message_init(&(lp->spi_data->spi_msg));
+        lp->spi_data->spi_msg.is_dma_mapped = 1;
+
+        /* interrupt handler data */
+        lp->irq_data = NULL;
+
+        /* get device instance GPIO configuration */
+        config = omap_get_config(
+                OMAP_TAG_PC2400M + config_cnt, struct omap_pc2400m_config);
+        if (!config) {
+                ERROR("Cannot get GPIO configuration for device\n");
+                goto err3;
+        } else
+                config_cnt++;
+
+        lp->power_gpio = config->enable_gpio;
+        lp->reset_gpio = config->reset_gpio;
+        lp->irq_gpio = config->irq_gpio;
+        lp->chip_type = (u8)config->chip_type;
+
+        /* create a workqueue for rx and tx usage */
+#define PC2400M_SPI_RXTX_WORKQUEUE_NAME "pc2400m_xmit"
+        lp->wq = create_workqueue(PC2400M_SPI_RXTX_WORKQUEUE_NAME);
+        if (!lp->wq) {
+                ERROR("Cannot create transfer workqueue\n");
+                goto err3;
+        }
+
+        /* request the GPIOs */
+        if (omap_request_gpio(lp->irq_gpio)) {
+                ERROR("Cannot request IRQ GPIO %d\n", lp->irq_gpio);
+                goto err4;
+        }
+        omap_set_gpio_direction(lp->irq_gpio, 1);
+
+
+        if (omap_request_gpio(lp->power_gpio)) {
+                ERROR("Cannot request Power GPIO %d\n", lp->power_gpio);
+                goto err5;
+        }
+        omap_set_gpio_direction(lp->power_gpio, 0);
+
+        if (omap_request_gpio(lp->reset_gpio)) {
+                ERROR("Cannot request Reset GPIO %d\n", lp->reset_gpio);
+                goto err6;
+        }
+        omap_set_gpio_direction(lp->reset_gpio, 0);
+
+        /* COVERAGE: as of currently, the pc2400m_if_init_device is a linear
+           function always returning 0. */
+        if (pc2400m_if_init_device(ndev)) {
+                ERROR("Device init failed (%s)\n", ndev->name);
+                goto err7;
+        }
+
+        INFO("Bound %s to SPI bus %d, cs %d, mode %2.2x, irq %2.2x\n",
+             ndev->name, spi->master->bus_num, spi->chip_select, spi->mode,
+             lp->irq_gpio);
+        goto out;
+
+ err7:
+        omap_free_gpio(lp->reset_gpio);
+ err6:
+        omap_free_gpio(lp->power_gpio);
+ err5:
+        omap_free_gpio(lp->irq_gpio);
+ err4:
+        destroy_workqueue(lp->wq);
+        lp->wq = NULL;
+ err3:
+        kfree(lp->spi_data);
+ err2:
+        pc2400m_if_free_device(ndev);
+ err1:
+        return -ENOMEM;
+
+ out:
+        list_add(&(lp->listelem), &pc2400m_spi_wimax_device);
+        return 0;
+}
+
+/** Remove a SPI device. This function is invoked by the kernel when it wants
+ *  to remove an existing device. This function will clean up the associated
+ *  driver instance and all associated resources.
+ *
+ *  @param spi pointer to SPI device structure identifying the device
+ *  @return always returns 0.
+ */
+static int pc2400m_spi_remove(struct spi_device *spi)
+{
+
+        struct net_local *pos;
+        struct workqueue_struct *wq;
+        int irq, power, reset;
+        void *dev_id;
+        void *spi_data;
+
+        /* need to get rid of the corresponding network device */
+        list_for_each_entry(pos, &pc2400m_spi_wimax_device, listelem) {
+                if (pos->spi_dev == spi)
+                        break;
+        }
+
+        BUG_ON(!pos);
+
+        list_del(&(pos->listelem));
+
+        INFO("Unbinding %s\n", pos->net_dev->name);
+
+        irq = pos->irq_gpio;
+        power = pos->power_gpio;
+        reset = pos->reset_gpio;
+        dev_id = (void*)pos->net_dev;
+        wq = pos->wq;
+        spi_data = pos->spi_data;
+
+        /* this should take care of possible ongoing
+           transactions too */
+        pc2400m_if_free_device(pos->net_dev);
+
+        /* remove memory associated for SPI transactions */
+        kfree(spi_data);
+
+        /* remove the rx and tx workqueue */
+        destroy_workqueue(wq);
+
+        /* this is used as identifier only, needs not be allocated*/
+        omap_free_gpio(irq);
+        omap_free_gpio(power);
+        omap_free_gpio(reset);
+
+        return 0;
+}
+
+/** Fast-shutdown a SPI device. This function is invoked by the kernel when it
+ *  wants to perform a quick and dirty shutdown. Only a power down will be
+ *  executed on all devices.
+ *
+ *  @param spi pointer to SPI device structure identifying the device
+ *  @return none
+ */
+static void pc2400m_spi_shutdown(struct spi_device *spi)
+{
+
+        struct net_local *pos;
+
+        /* get a pointer to the corresponding network device */
+        list_for_each_entry(pos, &pc2400m_spi_wimax_device, listelem) {
+                if (pos->spi_dev == spi)
+                        break;
+        }
+
+        BUG_ON(!pos);
+
+        INFO("Dirty shutdown of %s\n", pos->net_dev->name);
+        omap_set_gpio_dataout(pos->reset_gpio, 0);
+        omap_set_gpio_dataout(pos->power_gpio, 0);
+
+        return;
+
+}
+
+/** Suspend a SPI device. This function is invoked by the kernel when it wants
+ *  to suspend. This function suspends all traffic by this driver instance
+ *  prior to returning.
+ *
+ *  @param spi pointer to SPI device structure identifying the device
+ *  @param mesg associated parameters
+ *  @return always returns 0.
+ */
+static int pc2400m_spi_suspend(struct spi_device *spi, pm_message_t mesg)
+{
+
+        struct net_local *pos;
+
+        PC2400M_UNWARN(mesg);
+
+        list_for_each_entry(pos, &pc2400m_spi_wimax_device, listelem) {
+                if (pos->spi_dev == spi) break;
+        }
+
+        BUG_ON(!pos);
+        INFO("Suspending %s...\n", pos->net_dev->name);
+
+        pc2400m_if_suspend_device(pos->net_dev);
+
+        return 0;
+
+}
+
+/** Resume a SPI device. This function is invoked by the kernel when it wants
+ *  to resume. This function resumes all traffic by this driver instance
+ *  prior to returning.
+ *
+ *  @param spi pointer to SPI device structure identifying the device
+ *  @return always returns 0.
+ */
+static int pc2400m_spi_resume(struct spi_device *spi)
+{
+
+        struct net_local *pos;
+
+        list_for_each_entry(pos, &pc2400m_spi_wimax_device, listelem) {
+                if (pos->spi_dev == spi) break;
+        }
+
+        BUG_ON(!pos);
+        INFO("Resuming %s...\n", pos->net_dev->name);
+
+        pc2400m_if_resume_device(pos->net_dev);
+
+        return 0;
+
+}
+
+
+/** Load driver module. This function is called by the kernel upon
+ *  initialziation of the driver kernel module. This funcion prepares
+ *  driver main data structures, but does not initiate any driver instances -
+ *  the "probe" function will perform that.
+ *
+ *  @return always returns 0.
+ */
+static int __init pc2400m_spi_init_module(void)
+{
+
+        INFO("Intel PC2400M driver (c) Nokia 2007, 2008 loaded (%s).\n",
+             RELEASE_VAL);
+
+        memset(&pc2400m_spi_wihal_adapt, 0, sizeof(pc2400m_spi_wihal_adapt));
+        init_MUTEX(&pc2400m_com_mutex);
+        pc2400m_spi_wihal_adapt.h2d = pc2400m_spi_h2d;
+        pc2400m_spi_wihal_adapt.d2h = pc2400m_spi_d2h;
+        pc2400m_spi_wihal_adapt.commit = pc2400m_spi_commit;
+        pc2400m_spi_wihal_adapt.enable_irq = pc2400m_spi_enable_irq;
+        pc2400m_spi_wihal_adapt.configure = pc2400m_spi_configure;
+        pc2400m_spi_wihal_adapt.set_power = pc2400m_spi_set_power;
+        pc2400m_spi_wihal_adapt.irq_pending = pc2400m_spi_irq_pending;
+
+        /* initialize the SPI driver */
+        if (spi_register_driver(&pc2400m_driver))
+                return -ENODEV;
+
+        return 0;
+
+}
+
+/** Remove driver module. This function is called by the kernel upon
+ *  removal of the driver kernel module. This function unregisters the
+ *  SPI driver and then trusts, that the kernel will remove all associated
+ *  SPI driver instances.
+ *
+ *  @return none
+ */
+static void __exit pc2400m_spi_cleanup_module(void)
+{
+
+        /* the SPI framework will call .remove for each SPI device
+           connected to this driver */
+        spi_unregister_driver(&pc2400m_driver);
+
+}
+
+/* register module initialization and finalization functions */
+module_init(pc2400m_spi_init_module);
+module_exit(pc2400m_spi_cleanup_module);
+
+MODULE_LICENSE("GPL v2");
+
+/*****************************************************************************
+ * Exported functions
+ */
+
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_spi.h maemo_src/drivers/net/wireless/pc2400m/pc2400m_spi.h
--- linux-omap-2.6/drivers/net/wireless/pc2400m/pc2400m_spi.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/net/wireless/pc2400m/pc2400m_spi.h	2011-02-06 20:12:11.713333274 -0500
@@ -0,0 +1,56 @@
+/*
+ * pc2400m_spi.h
+ *
+ * This file is part of the pc2400m driver.
+ *
+ * Copyright (C) 2007-2008 Nokia Corporation.
+ *
+ * Contact: Juuso Oikarinen <juuso.oikarinen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+/* VERSION:         9       APPROVED 21-Feb-2008 Jouni Lappi
+*/
+
+/** @file pc2400m_spi.h
+ *
+ * This function declares the SPI adaptation module.
+ *
+ */
+
+#ifndef PC2400M_SPI_H
+#define PC2400M_SPI_H
+
+/*****************************************************************************
+ * Include files
+ */
+
+/*****************************************************************************
+ * Constants and macros
+ */
+
+/*****************************************************************************
+ * Data types
+ */
+
+/*****************************************************************************
+ * Function prototypes
+ */
+
+#endif /* PC2400M_SPI_H */
+
+/* End of File */
diff -ruN linux-omap-2.6/drivers/serial/Kconfig maemo_src/drivers/serial/Kconfig
--- linux-omap-2.6/drivers/serial/Kconfig	2011-02-06 19:45:01.136666606 -0500
+++ maemo_src/drivers/serial/Kconfig	2007-10-02 03:09:32.000000000 -0400
@@ -474,6 +474,29 @@
 	  your boot loader (lilo or loadlin) about how to pass options to the
 	  kernel at boot time.)
 
+config SERIAL_OMAP
+	bool "OMAP serial port support"
+	depends on ARM && ARCH_OMAP
+	select SERIAL_CORE
+	help
+	  If you have a machine based on an Texas Instruments OMAP CPU you
+	  can enable its onboard serial ports by enabling this option.
+
+config SERIAL_OMAP_CONSOLE
+	bool "Console on OMAP serial port"
+	depends on SERIAL_OMAP
+	select SERIAL_CORE_CONSOLE
+	help
+	  If you have enabled the serial port on the Intel XScale PXA
+	  CPU you can make it the console by answering Y to this option.
+
+	  Even if you say Y here, the currently visible virtual console
+	  (/dev/tty0) will still be used as the system console by default, but
+	  you can alter that using a kernel command line option such as
+	  "console=ttyS0". (Try "man bootparam" or see the documentation of
+	  your boot loader (lilo or loadlin) about how to pass options to the
+	  kernel at boot time.)
+
 config SERIAL_SA1100
 	bool "SA1100 serial port support"
 	depends on ARM && ARCH_SA1100
diff -ruN linux-omap-2.6/drivers/serial/Makefile maemo_src/drivers/serial/Makefile
--- linux-omap-2.6/drivers/serial/Makefile	2011-02-06 19:45:01.136666606 -0500
+++ maemo_src/drivers/serial/Makefile	2007-10-02 03:09:32.000000000 -0400
@@ -25,6 +25,7 @@
 obj-$(CONFIG_SERIAL_AMBA_PL011) += amba-pl011.o
 obj-$(CONFIG_SERIAL_CLPS711X) += clps711x.o
 obj-$(CONFIG_SERIAL_PXA) += pxa.o
+obj-$(CONFIG_SERIAL_OMAP) += omap.o
 obj-$(CONFIG_SERIAL_PNX8XXX) += pnx8xxx_uart.o
 obj-$(CONFIG_SERIAL_SA1100) += sa1100.o
 obj-$(CONFIG_SERIAL_S3C2410) += s3c2410.o
diff -ruN linux-omap-2.6/drivers/serial/omap.c maemo_src/drivers/serial/omap.c
--- linux-omap-2.6/drivers/serial/omap.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/serial/omap.c	2011-02-06 20:12:12.986666607 -0500
@@ -0,0 +1,913 @@
+/*
+ *  linux/drivers/serial/omap.c
+ *
+ *
+ *  Copyright (C) 2007 Nokia Corporation
+ *  Author:	Juha Yrjola
+ *
+ *  Based on drivers/serial/pxa.c by Nicolas Pitre.
+ *  Copyright (C) 2003 Monta Vista Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#if defined(CONFIG_SERIAL_OMAP_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+#define SUPPORT_SYSRQ
+#endif
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/serial_reg.h>
+#include <linux/circ_buf.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/clk.h>
+
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+
+#define OMAP_UART_CLOCK_ON	(1 << 0)
+#define OMAP_UART_RESUME_CLOCK	(1 << 1)
+
+struct uart_omap_port {
+	struct uart_port	port;
+	int			shift;
+	struct clk		*iclk, *fclk;
+
+	struct platform_device	*pdev;
+
+	unsigned char		status;
+	unsigned char		ier;
+	unsigned char		lcr;
+	unsigned char		mcr;
+	unsigned int		lsr_break_flag;
+	char			name[12];
+};
+
+static inline unsigned int serial_in(struct uart_omap_port *up, int offset)
+{
+	offset <<= up->shift;
+	return readb(up->port.membase + offset);
+}
+
+static inline void serial_out(struct uart_omap_port *up, int offset, int value)
+{
+	offset <<= up->shift;
+	writeb(value, up->port.membase + offset);
+}
+
+static void enable_uart_clocks(struct uart_omap_port *up)
+{
+	clk_enable(up->fclk);
+	if (up->iclk != NULL)
+		clk_enable(up->iclk);
+	up->status |= OMAP_UART_CLOCK_ON;
+}
+
+static void disable_uart_clocks(struct uart_omap_port *up)
+{
+	clk_disable(up->fclk);
+	if (up->iclk != NULL)
+		clk_disable(up->iclk);
+	up->status &= ~OMAP_UART_CLOCK_ON;
+}
+
+static void serial_omap_enable_ms(struct uart_port *port)
+{
+	struct uart_omap_port *up = (struct uart_omap_port *)port;
+
+	up->ier |= UART_IER_MSI;
+	serial_out(up, UART_IER, up->ier);
+}
+
+static void serial_omap_stop_tx(struct uart_port *port)
+{
+	struct uart_omap_port *up = (struct uart_omap_port *)port;
+
+	if (up->ier & UART_IER_THRI) {
+		up->ier &= ~UART_IER_THRI;
+		serial_out(up, UART_IER, up->ier);
+	}
+}
+
+static void serial_omap_stop_rx(struct uart_port *port)
+{
+	struct uart_omap_port *up = (struct uart_omap_port *)port;
+
+	up->ier &= ~UART_IER_RLSI;
+	up->port.read_status_mask &= ~UART_LSR_DR;
+	serial_out(up, UART_IER, up->ier);
+}
+
+static inline void
+receive_chars(struct uart_omap_port *up, int *status)
+{
+	struct tty_struct *tty = up->port.info->tty;
+	unsigned int ch, flag;
+	int max_count = 256;
+
+	do {
+		ch = serial_in(up, UART_RX);
+		flag = TTY_NORMAL;
+		up->port.icount.rx++;
+
+		if (unlikely(*status & (UART_LSR_BI | UART_LSR_PE |
+				       UART_LSR_FE | UART_LSR_OE))) {
+			/*
+			 * For statistics only
+			 */
+			if (*status & UART_LSR_BI) {
+				*status &= ~(UART_LSR_FE | UART_LSR_PE);
+				up->port.icount.brk++;
+				/*
+				 * We do the SysRQ and SAK checking
+				 * here because otherwise the break
+				 * may get masked by ignore_status_mask
+				 * or read_status_mask.
+				 */
+				if (uart_handle_break(&up->port))
+					goto ignore_char;
+			} else if (*status & UART_LSR_PE)
+				up->port.icount.parity++;
+			else if (*status & UART_LSR_FE)
+				up->port.icount.frame++;
+			if (*status & UART_LSR_OE)
+				up->port.icount.overrun++;
+
+			/*
+			 * Mask off conditions which should be ignored.
+			 */
+			*status &= up->port.read_status_mask;
+
+#ifdef CONFIG_SERIAL_OMAP_CONSOLE
+			if (up->port.line == up->port.cons->index) {
+				/* Recover the break flag from console xmit */
+				*status |= up->lsr_break_flag;
+				up->lsr_break_flag = 0;
+			}
+#endif
+			if (*status & UART_LSR_BI) {
+				flag = TTY_BREAK;
+			} else if (*status & UART_LSR_PE)
+				flag = TTY_PARITY;
+			else if (*status & UART_LSR_FE)
+				flag = TTY_FRAME;
+		}
+
+		if (uart_handle_sysrq_char(&up->port, ch))
+			goto ignore_char;
+
+		uart_insert_char(&up->port, *status, UART_LSR_OE, ch, flag);
+
+	ignore_char:
+		*status = serial_in(up, UART_LSR);
+	} while ((*status & UART_LSR_DR) && (max_count-- > 0));
+	tty_flip_buffer_push(tty);
+}
+
+static void transmit_chars(struct uart_omap_port *up)
+{
+	struct circ_buf *xmit = &up->port.info->xmit;
+	int count;
+
+	if (up->port.x_char) {
+		serial_out(up, UART_TX, up->port.x_char);
+		up->port.icount.tx++;
+		up->port.x_char = 0;
+		return;
+	}
+	if (uart_circ_empty(xmit) || uart_tx_stopped(&up->port)) {
+		serial_omap_stop_tx(&up->port);
+		return;
+	}
+
+	count = 16;
+	do {
+		serial_out(up, UART_TX, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		up->port.icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	} while (--count > 0);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(&up->port);
+
+	if (uart_circ_empty(xmit))
+		serial_omap_stop_tx(&up->port);
+}
+
+static void serial_omap_start_tx(struct uart_port *port)
+{
+	struct uart_omap_port *up = (struct uart_omap_port *)port;
+
+	if (!(up->ier & UART_IER_THRI)) {
+		up->ier |= UART_IER_THRI;
+		serial_out(up, UART_IER, up->ier);
+	}
+}
+
+static inline void check_modem_status(struct uart_omap_port *up)
+{
+	int status;
+
+	status = serial_in(up, UART_MSR);
+
+	if ((status & UART_MSR_ANY_DELTA) == 0)
+		return;
+
+	if (status & UART_MSR_TERI)
+		up->port.icount.rng++;
+	if (status & UART_MSR_DDSR)
+		up->port.icount.dsr++;
+	if (status & UART_MSR_DDCD)
+		uart_handle_dcd_change(&up->port, status & UART_MSR_DCD);
+	if (status & UART_MSR_DCTS)
+		uart_handle_cts_change(&up->port, status & UART_MSR_CTS);
+
+	wake_up_interruptible(&up->port.info->delta_msr_wait);
+}
+
+/*
+ * This handles the interrupt from one port.
+ */
+static inline irqreturn_t
+serial_omap_irq(int irq, void *dev_id)
+{
+	struct uart_omap_port *up = (struct uart_omap_port *)dev_id;
+	unsigned int iir, lsr;
+
+	iir = serial_in(up, UART_IIR);
+	if (iir & UART_IIR_NO_INT)
+		return IRQ_NONE;
+	lsr = serial_in(up, UART_LSR);
+	if (lsr & UART_LSR_DR)
+		receive_chars(up, &lsr);
+	check_modem_status(up);
+	if (lsr & UART_LSR_THRE)
+		transmit_chars(up);
+	return IRQ_HANDLED;
+}
+
+static unsigned int serial_omap_tx_empty(struct uart_port *port)
+{
+	struct uart_omap_port *up = (struct uart_omap_port *)port;
+	unsigned long flags;
+	unsigned int ret;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	ret = serial_in(up, UART_LSR) & UART_LSR_TEMT ? TIOCSER_TEMT : 0;
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	return ret;
+}
+
+static unsigned int serial_omap_get_mctrl(struct uart_port *port)
+{
+	struct uart_omap_port *up = (struct uart_omap_port *)port;
+	unsigned char status;
+	unsigned int ret;
+
+	status = serial_in(up, UART_MSR);
+
+	ret = 0;
+	if (status & UART_MSR_DCD)
+		ret |= TIOCM_CAR;
+	if (status & UART_MSR_RI)
+		ret |= TIOCM_RNG;
+	if (status & UART_MSR_DSR)
+		ret |= TIOCM_DSR;
+	if (status & UART_MSR_CTS)
+		ret |= TIOCM_CTS;
+	return ret;
+}
+
+static void serial_omap_set_mctrl(struct uart_port *port, unsigned int mctrl)
+{
+	struct uart_omap_port *up = (struct uart_omap_port *)port;
+	unsigned char mcr = 0;
+
+	if (mctrl & TIOCM_RTS)
+		mcr |= UART_MCR_RTS;
+	if (mctrl & TIOCM_DTR)
+		mcr |= UART_MCR_DTR;
+	if (mctrl & TIOCM_OUT1)
+		mcr |= UART_MCR_OUT1;
+	if (mctrl & TIOCM_OUT2)
+		mcr |= UART_MCR_OUT2;
+	if (mctrl & TIOCM_LOOP)
+		mcr |= UART_MCR_LOOP;
+
+	mcr |= up->mcr;
+
+	serial_out(up, UART_MCR, mcr);
+}
+
+static void serial_omap_break_ctl(struct uart_port *port, int break_state)
+{
+	struct uart_omap_port *up = (struct uart_omap_port *)port;
+	unsigned long flags;
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	if (break_state == -1)
+		up->lcr |= UART_LCR_SBC;
+	else
+		up->lcr &= ~UART_LCR_SBC;
+	serial_out(up, UART_LCR, up->lcr);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static int serial_omap_startup(struct uart_port *port)
+{
+	struct uart_omap_port *up = (struct uart_omap_port *)port;
+	unsigned long flags;
+	int retval;
+
+	if (!(up->status & OMAP_UART_CLOCK_ON))
+		enable_uart_clocks(up);
+
+	/*
+	 * Allocate the IRQ
+	 */
+	retval = request_irq(up->port.irq, serial_omap_irq, 0, up->name, up);
+	if (retval) {
+		disable_uart_clocks(up);
+		return retval;
+	}
+
+	/* Stop the baud clock */
+	serial_out(up, UART_LCR, 1 << 7);
+	serial_out(up, UART_DLL, 0);
+	serial_out(up, UART_DLM, 0);
+	serial_out(up, UART_LCR, 0);
+
+	/* Reset the UART */
+	serial_out(up, UART_OMAP_SYSC, 0x02);
+	udelay(50);
+	serial_out(up, UART_OMAP_SYSC, 0x1<<0);
+	serial_out(up, UART_OMAP_MDR1, 0x00);
+
+	/* Enable access to EFR */
+	serial_out(up, UART_LCR, 0xbf);
+	/* Enable access to extra features */
+	serial_out(up, UART_EFR, 1 << 4);
+	/* Enable sleep mode */
+	serial_out(up, UART_IER, 1 << 4);
+
+	/* Set FIFO triggering */
+	serial_out(up, UART_SCR, 0x00);
+	serial_out(up, UART_FCR, (0x01 << 6) | (0x01 << 4) |
+		   UART_FCR_ENABLE_FIFO);
+	serial_out(up, UART_FCR, (0x01 << 6) | (0x01 << 4) |
+		   UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT |
+		   UART_FCR_ENABLE_FIFO);
+	udelay(50);
+
+	/* Disable access to extra features */
+	serial_out(up, UART_EFR, 0);
+
+	serial_out(up, UART_FCR, 0);
+	serial_out(up, UART_LCR, 0x00);
+
+	/*
+	 * Clear the interrupt registers.
+	 */
+	(void) serial_in(up, UART_LSR);
+	(void) serial_in(up, UART_RX);
+	(void) serial_in(up, UART_IIR);
+	(void) serial_in(up, UART_MSR);
+
+	/*
+	 * Now, initialize the UART
+	 */
+	serial_out(up, UART_LCR, UART_LCR_WLEN8);
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	up->port.mctrl |= TIOCM_OUT2;
+	serial_omap_set_mctrl(&up->port, up->port.mctrl);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	/*
+	 * Finally, enable interrupts.  Note: Modem status interrupts
+	 * are set via set_termios(), which will be occurring imminently
+	 * anyway, so we don't enable them here.
+	 */
+	up->ier = UART_IER_RLSI | UART_IER_RDI | UART_IER_RTOIE;
+	serial_out(up, UART_IER, up->ier);
+
+	/*
+	 * And clear the interrupt registers again for luck.
+	 */
+	(void) serial_in(up, UART_LSR);
+	(void) serial_in(up, UART_RX);
+	(void) serial_in(up, UART_IIR);
+	(void) serial_in(up, UART_MSR);
+
+	return 0;
+}
+
+static void serial_omap_shutdown(struct uart_port *port)
+{
+	struct uart_omap_port *up = (struct uart_omap_port *)port;
+	unsigned long flags;
+
+	free_irq(up->port.irq, up);
+
+	/*
+	 * Disable interrupts from this port
+	 */
+	up->ier = 0;
+	serial_out(up, UART_IER, 0);
+
+	spin_lock_irqsave(&up->port.lock, flags);
+	up->port.mctrl &= ~TIOCM_OUT2;
+	serial_omap_set_mctrl(&up->port, up->port.mctrl);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+
+	/*
+	 * Disable break condition and FIFOs
+	 */
+	serial_out(up, UART_LCR, serial_in(up, UART_LCR) & ~UART_LCR_SBC);
+	serial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO |
+				  UART_FCR_CLEAR_RCVR |
+				  UART_FCR_CLEAR_XMIT);
+	serial_out(up, UART_FCR, 0);
+
+	disable_uart_clocks(up);
+
+	clk_put(up->fclk);
+	if (up->iclk != NULL)
+		clk_put(up->iclk);
+}
+
+static void
+serial_omap_set_termios(struct uart_port *port, struct ktermios *termios,
+			struct ktermios *old)
+{
+	struct uart_omap_port *up = (struct uart_omap_port *)port;
+	unsigned char cval, fcr = 0;
+	unsigned long flags;
+	unsigned int baud, quot;
+
+	switch (termios->c_cflag & CSIZE) {
+	case CS5:
+		cval = UART_LCR_WLEN5;
+		break;
+	case CS6:
+		cval = UART_LCR_WLEN6;
+		break;
+	case CS7:
+		cval = UART_LCR_WLEN7;
+		break;
+	default:
+	case CS8:
+		cval = UART_LCR_WLEN8;
+		break;
+	}
+
+	if (termios->c_cflag & CSTOPB)
+		cval |= UART_LCR_STOP;
+	if (termios->c_cflag & PARENB)
+		cval |= UART_LCR_PARITY;
+	if (!(termios->c_cflag & PARODD))
+		cval |= UART_LCR_EPAR;
+
+	/*
+	 * Ask the core to calculate the divisor for us.
+	 */
+	baud = uart_get_baud_rate(port, termios, old, 0, port->uartclk/16);
+	quot = uart_get_divisor(port, baud);
+
+	fcr = (0x01 << 6) | (0x01 << 4) | UART_FCR_ENABLE_FIFO;
+
+	/*
+	 * Ok, we're now changing the port state.  Do it with
+	 * interrupts disabled.
+	 */
+	spin_lock_irqsave(&up->port.lock, flags);
+
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	up->port.read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;
+	if (termios->c_iflag & INPCK)
+		up->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;
+	if (termios->c_iflag & (BRKINT | PARMRK))
+		up->port.read_status_mask |= UART_LSR_BI;
+
+	/*
+	 * Characters to ignore
+	 */
+	up->port.ignore_status_mask = 0;
+	if (termios->c_iflag & IGNPAR)
+		up->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;
+	if (termios->c_iflag & IGNBRK) {
+		up->port.ignore_status_mask |= UART_LSR_BI;
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
+		 */
+		if (termios->c_iflag & IGNPAR)
+			up->port.ignore_status_mask |= UART_LSR_OE;
+	}
+
+	/*
+	 * ignore all characters if CREAD is not set
+	 */
+	if ((termios->c_cflag & CREAD) == 0)
+		up->port.ignore_status_mask |= UART_LSR_DR;
+
+	/*
+	 * CTS flow control flag and modem status interrupts
+	 */
+	up->ier &= ~UART_IER_MSI;
+	if (UART_ENABLE_MS(&up->port, termios->c_cflag))
+		up->ier |= UART_IER_MSI;
+
+	serial_out(up, UART_IER, up->ier);
+
+	serial_out(up, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */
+	serial_out(up, UART_DLL, quot & 0xff);		/* LS of divisor */
+	serial_out(up, UART_DLM, quot >> 8);		/* MS of divisor */
+	serial_out(up, UART_LCR, cval);		/* reset DLAB */
+	up->lcr = cval;					/* Save LCR */
+	serial_omap_set_mctrl(&up->port, up->port.mctrl);
+	serial_out(up, UART_FCR, fcr);
+	spin_unlock_irqrestore(&up->port.lock, flags);
+}
+
+static void
+serial_omap_pm(struct uart_port *port, unsigned int state,
+	       unsigned int oldstate)
+{
+}
+
+static void serial_omap_release_port(struct uart_port *port)
+{
+}
+
+static int serial_omap_request_port(struct uart_port *port)
+{
+	return 0;
+}
+
+static void serial_omap_config_port(struct uart_port *port, int flags)
+{
+	struct uart_omap_port *up = (struct uart_omap_port *)port;
+	up->port.type = PORT_OMAP;
+}
+
+static int
+serial_omap_verify_port(struct uart_port *port, struct serial_struct *ser)
+{
+	/* we don't want the core code to modify any port params */
+	return -EINVAL;
+}
+
+static const char *
+serial_omap_type(struct uart_port *port)
+{
+	struct uart_omap_port *up = (struct uart_omap_port *)port;
+	return up->name;
+}
+
+#ifdef CONFIG_SERIAL_OMAP_CONSOLE
+
+static struct uart_omap_port *serial_omap_console_ports[3];
+
+static struct uart_driver serial_omap_reg;
+
+#define BOTH_EMPTY (UART_LSR_TEMT | UART_LSR_THRE)
+
+/*
+ *	Wait for transmitter & holding register to empty
+ */
+static inline void wait_for_xmitr(struct uart_omap_port *up)
+{
+	unsigned int status, tmout = 10000;
+
+	/* Wait up to 10ms for the character(s) to be sent. */
+	do {
+		status = serial_in(up, UART_LSR);
+
+		if (status & UART_LSR_BI)
+			up->lsr_break_flag = UART_LSR_BI;
+
+		if (--tmout == 0)
+			break;
+		udelay(1);
+	} while ((status & BOTH_EMPTY) != BOTH_EMPTY);
+
+	/* Wait up to 1s for flow control if necessary */
+	if (up->port.flags & UPF_CONS_FLOW) {
+		tmout = 1000000;
+		while (--tmout &&
+		       ((serial_in(up, UART_MSR) & UART_MSR_CTS) == 0))
+			udelay(1);
+	}
+}
+
+static void serial_omap_console_putchar(struct uart_port *port, int ch)
+{
+	struct uart_omap_port *up = (struct uart_omap_port *)port;
+
+	wait_for_xmitr(up);
+	serial_out(up, UART_TX, ch);
+}
+
+/*
+ * Print a string to the serial port trying not to disturb
+ * any possible real use of the port...
+ *
+ *	The console_lock must be held when we get here.
+ */
+static void
+serial_omap_console_write(struct console *co, const char *s, unsigned int count)
+{
+	struct uart_omap_port *up = serial_omap_console_ports[co->index];
+	unsigned int ier;
+
+	/*
+	 *	First save the IER then disable the interrupts
+	 */
+	ier = serial_in(up, UART_IER);
+	serial_out(up, UART_IER, 0);
+
+	uart_console_write(&up->port, s, count, serial_omap_console_putchar);
+
+	/*
+	 *	Finally, wait for transmitter to become empty
+	 *	and restore the IER
+	 */
+	wait_for_xmitr(up);
+	serial_out(up, UART_IER, ier);
+}
+
+static int __init
+serial_omap_console_setup(struct console *co, char *options)
+{
+	struct uart_omap_port *up;
+	int baud = 9600;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+	int r;
+
+	if (serial_omap_console_ports[co->index] == NULL)
+		return -ENODEV;
+        up = serial_omap_console_ports[co->index];
+
+	enable_uart_clocks(up);
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	r = uart_set_options(&up->port, co, baud, parity, bits, flow);
+
+	return r;
+}
+
+static struct console serial_omap_console = {
+	.name		= "ttyS",
+	.write		= serial_omap_console_write,
+	.device		= uart_console_device,
+	.setup		= serial_omap_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &serial_omap_reg,
+};
+
+static void serial_omap_add_console_port(struct uart_omap_port *up)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(serial_omap_console_ports); i++)
+		if (serial_omap_console_ports[i] == NULL) {
+			serial_omap_console_ports[i] = up;
+			break;
+		}
+}
+
+#if 0
+static int __init
+serial_omap_console_init(void)
+{
+	register_console(&serial_omap_console);
+	return 0;
+}
+
+device_initcall(serial_omap_console_init);
+#endif
+
+#define OMAP_CONSOLE	&serial_omap_console
+
+#else
+
+#define OMAP_CONSOLE	NULL
+
+static inline void serial_omap_add_console_port(struct uart_omap_port *up) {}
+
+#endif
+
+struct uart_ops serial_omap_pops = {
+	.tx_empty	= serial_omap_tx_empty,
+	.set_mctrl	= serial_omap_set_mctrl,
+	.get_mctrl	= serial_omap_get_mctrl,
+	.stop_tx	= serial_omap_stop_tx,
+	.start_tx	= serial_omap_start_tx,
+	.stop_rx	= serial_omap_stop_rx,
+	.enable_ms	= serial_omap_enable_ms,
+	.break_ctl	= serial_omap_break_ctl,
+	.startup	= serial_omap_startup,
+	.shutdown	= serial_omap_shutdown,
+	.set_termios	= serial_omap_set_termios,
+	.pm		= serial_omap_pm,
+	.type		= serial_omap_type,
+	.release_port	= serial_omap_release_port,
+	.request_port	= serial_omap_request_port,
+	.config_port	= serial_omap_config_port,
+	.verify_port	= serial_omap_verify_port,
+};
+
+static struct uart_driver serial_omap_reg = {
+	.owner		= THIS_MODULE,
+	.driver_name	= "OMAP serial",
+	.dev_name	= "ttyS",
+	.major		= TTY_MAJOR,
+	.minor		= 64,
+	.nr		= 3,
+	.cons		= OMAP_CONSOLE,
+};
+
+static int serial_omap_suspend(struct platform_device *dev, pm_message_t state)
+{
+	struct uart_omap_port *sport = platform_get_drvdata(dev);
+
+	if (!sport)
+		return 0;
+
+	uart_suspend_port(&serial_omap_reg, &sport->port);
+
+	if ((sport->status & OMAP_UART_CLOCK_ON)&& (sport->fclk != NULL)) {
+		sport->status |= OMAP_UART_RESUME_CLOCK;
+		disable_uart_clocks(sport);
+	}
+
+	return 0;
+}
+
+static int serial_omap_resume(struct platform_device *dev)
+{
+	struct uart_omap_port *sport = platform_get_drvdata(dev);
+
+	if (!sport)
+		return 0;
+
+	if ((sport->status & OMAP_UART_RESUME_CLOCK) && (sport->fclk != NULL)) {
+		sport->status &= ~OMAP_UART_RESUME_CLOCK;
+		enable_uart_clocks(sport);
+	}
+
+	uart_resume_port(&serial_omap_reg, &sport->port);
+
+	return 0;
+}
+
+static int line = 0;
+
+static int serial_omap_probe(struct platform_device *pdev)
+{
+	struct uart_omap_port	*up;
+	struct resource		*mem, *irq;
+	char			buf[16];
+	int r;
+
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem) {
+		dev_err(&pdev->dev, "no mem resource?\n");
+		return -ENODEV;
+	}
+	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!irq) {
+		dev_err(&pdev->dev, "no irq resource?\n");
+		return -ENODEV;
+	}
+
+	r = (int) request_mem_region(mem->start, (mem->end - mem->start) + 1,
+				     pdev->dev.driver->name);
+	if (!r) {
+		dev_err(&pdev->dev, "memory region already claimed\n");
+		return -EBUSY;
+	}
+
+	up = kzalloc(sizeof(*up), GFP_KERNEL);
+	if (up == NULL) {
+		r = -ENOMEM;
+		goto do_release_region;
+	}
+	sprintf(up->name, "OMAP UART%d", pdev->id);
+
+	platform_set_drvdata(pdev, up);
+	up->pdev = pdev;
+
+	if (!cpu_class_is_omap1()) {
+		sprintf(buf, "uart%d_fck", pdev->id);
+		up->fclk = clk_get(&pdev->dev, buf);
+		if (IS_ERR(up->fclk)) {
+			dev_err(&pdev->dev, "could not get fclk\n");
+			return PTR_ERR(up->fclk);
+		}
+		sprintf(buf, "uart%d_ick", pdev->id);
+		up->iclk = clk_get(&pdev->dev, buf);
+		if (IS_ERR(up->iclk)) {
+			dev_err(&pdev->dev, "could not get iclk\n");
+			clk_put(up->fclk);
+			return PTR_ERR(up->iclk);
+		}
+	}
+
+	up->port.type = PORT_OMAP;
+	up->port.iotype = UPIO_MEM;
+	up->port.membase = (void *) io_p2v(mem->start);
+	up->port.mapbase = mem->start;
+	up->port.irq = irq->start;
+	up->port.fifosize = 64;
+	up->port.ops = &serial_omap_pops;
+	up->port.line = line++;
+
+	up->port.uartclk = 2995200 * 16;
+	up->shift = 2;
+
+	serial_omap_add_console_port(up);
+
+	uart_add_one_port(&serial_omap_reg, &up->port);
+	platform_set_drvdata(pdev, up);
+
+	return 0;
+
+do_release_region:
+	release_mem_region(mem->start, (mem->end - mem->start) + 1);
+	return r;
+}
+
+static int serial_omap_remove(struct platform_device *dev)
+{
+	struct uart_omap_port *sport = platform_get_drvdata(dev);
+
+	platform_set_drvdata(dev, NULL);
+
+	if (sport)
+		uart_remove_one_port(&serial_omap_reg, &sport->port);
+
+	return 0;
+}
+
+static struct platform_driver serial_omap_driver = {
+	.probe          = serial_omap_probe,
+	.remove         = serial_omap_remove,
+
+	.suspend	= serial_omap_suspend,
+	.resume		= serial_omap_resume,
+	.driver		= {
+	        .name	= "omap-uart",
+	},
+};
+
+int __init serial_omap_init(void)
+{
+	int ret;
+
+	ret = uart_register_driver(&serial_omap_reg);
+	if (ret != 0)
+		return ret;
+
+	ret = platform_driver_register(&serial_omap_driver);
+	if (ret != 0)
+		uart_unregister_driver(&serial_omap_reg);
+
+	return ret;
+}
+
+void __exit serial_omap_exit(void)
+{
+	platform_driver_unregister(&serial_omap_driver);
+	uart_unregister_driver(&serial_omap_reg);
+}
+
+subsys_initcall(serial_omap_init);
+module_exit(serial_omap_exit);
+
+MODULE_LICENSE("GPL");
diff -ruN linux-omap-2.6/drivers/spi/Kconfig maemo_src/drivers/spi/Kconfig
--- linux-omap-2.6/drivers/spi/Kconfig	2011-02-06 20:17:25.799999940 -0500
+++ maemo_src/drivers/spi/Kconfig	2011-02-06 20:12:13.023333273 -0500
@@ -114,6 +114,12 @@
 	help
 	  SPI master controller for OMAP24xx McSPI modules.
 
+config SPI_OMAP_PAUSING
+	bool "Pausing support for SPI DMA transfers"
+	depends on SPI_OMAP24XX
+	help
+	  This introduces functions to pause/unpause transfers over DMA
+
 config SPI_PXA2XX
 	tristate "PXA2xx SSP SPI master"
 	depends on SPI_MASTER && ARCH_PXA && EXPERIMENTAL
@@ -158,6 +164,19 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called at25.
 
+config SPI_TSC2005
+	tristate "TSC2005 driver"
+	depends on SPI_MASTER
+	help
+	  Say Y here if you have a TSC2005 chip connected to an SPI
+	  bus on your board.
+
+	  The TSC2005 is a 12-bit A/D resistive touch screen
+	  converter (ADC).
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called tsc2005.
+
 config SPI_TSC2101
        depends on SPI_MASTER
        tristate "TSC2101 chip support"
diff -ruN linux-omap-2.6/drivers/spi/Makefile maemo_src/drivers/spi/Makefile
--- linux-omap-2.6/drivers/spi/Makefile	2011-02-06 20:17:25.799999941 -0500
+++ maemo_src/drivers/spi/Makefile	2007-10-02 03:09:32.000000000 -0400
@@ -25,6 +25,7 @@
 
 # SPI protocol drivers (device/link on bus)
 obj-$(CONFIG_SPI_AT25)		+= at25.o
+obj-$(CONFIG_SPI_TSC2005)	+= tsc2005.o
 obj-$(CONFIG_SPI_TSC2101)	+= tsc2101.o
 obj-$(CONFIG_SPI_TSC2102)	+= tsc2102.o
 obj-$(CONFIG_SPI_TSC2301)	+= tsc2301.o
diff -ruN linux-omap-2.6/drivers/spi/omap2_mcspi.c maemo_src/drivers/spi/omap2_mcspi.c
--- linux-omap-2.6/drivers/spi/omap2_mcspi.c	2011-02-06 20:17:25.813333272 -0500
+++ maemo_src/drivers/spi/omap2_mcspi.c	2011-02-06 20:12:13.003333273 -0500
@@ -203,16 +203,69 @@
 	mcspi_write_reg(spi->master, OMAP2_MCSPI_MODULCTRL, l);
 }
 
+static int mcspi_wait_for_reg_bit(unsigned long reg, unsigned long bit)
+{
+	unsigned long timeout;
+
+	timeout = jiffies + msecs_to_jiffies(1000);
+	while (!(__raw_readl(reg) & bit)) {
+		if (time_after(jiffies, timeout))
+			return -1;
+	}
+	return 0;
+}
+
+#ifdef CONFIG_SPI_OMAP_PAUSING
+static struct mutex pause_mutex;
+
+static inline void spi_pause_mutex_init(void)
+{
+	mutex_init(&pause_mutex);
+}
+
+static inline void spi_pause_mutex_lock(void)
+{
+	mutex_lock(&pause_mutex);
+}
+
+static inline void spi_pause_mutex_unlock(void)
+{
+	mutex_unlock(&pause_mutex);
+}
+
+void omap2_spi_pause(void)
+{
+	spi_pause_mutex_lock();
+}
+
+void omap2_spi_continue(void)
+{
+	spi_pause_mutex_unlock();
+}
+
+#else
+
+static inline void spi_pause_mutex_init(void);
+static inline void spi_pause_mutex_lock(void);
+static inline void spi_pause_mutex_unlock(void);
+void omap2_spi_pause(void);
+void omap2_spi_continue(void);
+
+#endif
+
 static void omap2_mcspi_txrx_dma(struct spi_device *spi,
 				 struct spi_transfer *xfer)
 {
 	struct omap2_mcspi      * mcspi;
 	struct omap2_mcspi_cs   * cs = spi->controller_state;
 	struct omap2_mcspi_dma  * mcspi_dma;
-	unsigned int		count, c;
+	unsigned int		count, c, turbo = 0;
 	unsigned long		base, tx_reg, rx_reg;
+	unsigned long		base_virt, rx_reg_virt, chstat_reg_virt;
 	int			word_len, data_type, element_count;
 	u8			* rx;
+	u16			* rx16;
+	u32			* rx32;
 	const u8		* tx;
 	u32			l;
 
@@ -229,14 +282,21 @@
 		l |= OMAP2_MCSPI_CHCONF_TRM_RX_ONLY;
 	else if (xfer->rx_buf == NULL)
 		l |= OMAP2_MCSPI_CHCONF_TRM_TX_ONLY;
+	if (l & OMAP2_MCSPI_CHCONF_TURBO)
+		turbo = 1;
 	mcspi_write_cs_reg(spi, OMAP2_MCSPI_CHCONF0, l);
 
 	omap2_mcspi_set_enable(spi, 1);
 
 	base = io_v2p(mcspi->base) + spi->chip_select * 0x14;
+	base_virt = mcspi->base + spi->chip_select * 0x14;
 	tx_reg = base + OMAP2_MCSPI_TX0;
 	rx_reg = base + OMAP2_MCSPI_RX0;
+	rx_reg_virt = base_virt + OMAP2_MCSPI_RX0;
+	chstat_reg_virt = base_virt + OMAP2_MCSPI_CHSTAT0;
 	rx = xfer->rx_buf;
+	rx16 = xfer->rx_buf;
+	rx32 = xfer->rx_buf;
 	tx = xfer->tx_buf;
 
 	if (word_len <= 8) {
@@ -252,9 +312,15 @@
 		goto out;
 
 	/* RX_ONLY mode needs dummy data in TX reg */
-	if (tx == NULL)
-		__raw_writel(0, mcspi->base +
+	if (tx == NULL) {
+		if (spi->mode & SPI_MOSI_HIGH) {
+			__raw_writel(0xffffffff, mcspi->base +
 			     spi->chip_select * 0x14 + OMAP2_MCSPI_TX0);
+		} else {
+			__raw_writel(0, mcspi->base +
+			     spi->chip_select * 0x14 + OMAP2_MCSPI_TX0);
+		}
+	}
 
 	if (tx != NULL) {
 		xfer->tx_dma = dma_map_single(&spi->dev, (void *) tx, count,
@@ -291,6 +357,12 @@
 			goto out;
 		}
 
+		if (turbo) {
+			element_count -= 1;
+			if (element_count <= 0)
+				printk("report Turbo bug#1!\n");
+		}
+
 		omap_set_dma_transfer_params(mcspi_dma->dma_rx_channel,
 					     data_type, element_count, 1,
 					     OMAP_DMA_SYNC_ELEMENT,
@@ -305,6 +377,7 @@
 					 xfer->rx_dma, 0, 0);
 	}
 
+	spi_pause_mutex_lock();
 	if (tx != NULL) {
 		omap_start_dma(mcspi_dma->dma_tx_channel);
 		omap2_mcspi_set_dma_req(spi, 0, 1);
@@ -324,20 +397,30 @@
 		wait_for_completion(&mcspi_dma->dma_rx_completion);
 		dma_unmap_single(NULL, xfer->rx_dma, count, DMA_FROM_DEVICE);
 	}
-out:
-	omap2_mcspi_set_enable(spi, 0);
-}
-
-static int mcspi_wait_for_reg_bit(unsigned long reg, unsigned long bit)
-{
-	unsigned long timeout;
 
-	timeout = jiffies + msecs_to_jiffies(1000);
-	while (!(__raw_readl(reg) & bit)) {
-		if (time_after(jiffies, timeout))
-			return -1;
+	if (turbo) {
+		if (rx != NULL) {
+			omap2_mcspi_set_enable(spi, 0);
+			mcspi_wait_for_reg_bit(chstat_reg_virt, OMAP2_MCSPI_CHSTAT_RXS);
+			switch(word_len) {
+			case 8:
+				rx[element_count] = (u8) __raw_readl(rx_reg_virt);
+				break;
+			case 16:
+				rx16[element_count] = (u16) __raw_readl(rx_reg_virt);
+				break;
+			case 32:
+				rx32[element_count] = (u32) __raw_readl(rx_reg_virt);
+				break;
+			default:
+				printk("report Turbo bug#2!\n");
+				break;
+			}
+		}
 	}
-	return 0;
+	spi_pause_mutex_unlock();
+out:
+	omap2_mcspi_set_enable(spi, 0);
 }
 
 static void omap2_mcspi_txrx_pio(struct spi_device *spi, struct spi_transfer *xfer)
@@ -347,7 +430,7 @@
 	unsigned int		count, c;
 	u32                     l;
 	unsigned long		base, tx_reg, rx_reg, chstat_reg;
-	int			word_len;
+	int			word_len, turbo = 0, turbo_switch = 0;
 
 	mcspi = class_get_devdata(&spi->master->cdev);
 	count = xfer->len;
@@ -360,6 +443,14 @@
 		l |= OMAP2_MCSPI_CHCONF_TRM_RX_ONLY;
 	else if (xfer->rx_buf == NULL)
 		l |= OMAP2_MCSPI_CHCONF_TRM_TX_ONLY;
+	if (l & OMAP2_MCSPI_CHCONF_TURBO) {
+		turbo_switch = 1;
+		/* Need to disable turbo if rx len < 2 */
+		if (((count >> (word_len >> 4)) <= 1) || word_len < 8)
+			l &= ~OMAP2_MCSPI_CHCONF_TURBO;
+		else 
+			turbo = 1;
+	}
 	mcspi_write_cs_reg(spi, OMAP2_MCSPI_CHCONF0, l);
 
 	omap2_mcspi_set_enable(spi, 1);
@@ -372,8 +463,13 @@
 	chstat_reg	= base + OMAP2_MCSPI_CHSTAT0;
 
 	/* RX_ONLY mode needs dummy data in TX reg */
-	if (xfer->tx_buf == NULL)
-		__raw_writel(0, tx_reg);
+	if (xfer->tx_buf == NULL) {
+		if (spi->mode & SPI_MOSI_HIGH) {
+			__raw_writel(0xffffffff, tx_reg);
+		} else {
+			__raw_writel(0, tx_reg);
+		}
+	}
 
 	if (word_len <= 8) {
 		u8		*rx;
@@ -392,15 +488,20 @@
 				dev_dbg(&spi->dev, "write-%d %02x\n",
 						word_len, *tx);
 #endif
-				__raw_writel(*tx, tx_reg);
+				__raw_writel(*tx++, tx_reg);
 			}
 			if (rx != NULL) {
 				if (mcspi_wait_for_reg_bit(chstat_reg, OMAP2_MCSPI_CHSTAT_RXS) < 0) {
 					dev_err(&spi->dev, "RXS timed out\n");
 					goto out;
 				}
-				if (c == 0 && tx == NULL)
+				if (turbo) {
+					if (c == 1 && tx == NULL) {
+						omap2_mcspi_set_enable(spi, 0);
+					}
+				} else if (c == 0 && tx == NULL) {
 					omap2_mcspi_set_enable(spi, 0);
+				}
 				*rx++ = __raw_readl(rx_reg);
 #ifdef VERBOSE
 				dev_dbg(&spi->dev, "read-%d %02x\n",
@@ -432,8 +533,13 @@
 					dev_err(&spi->dev, "RXS timed out\n");
 					goto out;
 				}
-				if (c == 0 && tx == NULL)
+				if (turbo) {
+					if (c == 1 && tx == NULL) {
+						omap2_mcspi_set_enable(spi, 0);
+					}
+				} else if (c == 0 && tx == NULL) {
 					omap2_mcspi_set_enable(spi, 0);
+				}
 				*rx++ = __raw_readl(rx_reg);
 #ifdef VERBOSE
 				dev_dbg(&spi->dev, "read-%d %04x\n",
@@ -465,8 +571,13 @@
 					dev_err(&spi->dev, "RXS timed out\n");
 					goto out;
 				}
-				if (c == 0 && tx == NULL)
+				if (turbo) {
+					if (c == 1 && tx == NULL) {
+						omap2_mcspi_set_enable(spi, 0);
+					}
+				} else if (c == 0 && tx == NULL) {
 					omap2_mcspi_set_enable(spi, 0);
+				}
 				*rx++ = __raw_readl(rx_reg);
 #ifdef VERBOSE
 				dev_dbg(&spi->dev, "read-%d %04x\n",
@@ -486,6 +597,13 @@
 out:
 		omap2_mcspi_set_enable(spi, 0);
 	}
+
+	if (turbo_switch) {
+		if (!(l & OMAP2_MCSPI_CHCONF_TURBO)) {
+			l |= OMAP2_MCSPI_CHCONF_TURBO;
+			mcspi_write_cs_reg(spi, OMAP2_MCSPI_CHCONF0, l);
+		}
+	}
 }
 
 static int omap2_mcspi_setup_transfer(struct spi_device *spi,
@@ -553,8 +671,15 @@
 		l &= ~OMAP2_MCSPI_CHCONF_PHA;
 	else
 		l |= OMAP2_MCSPI_CHCONF_PHA;
+	if (conf->turbo_mode)
+		l |= OMAP2_MCSPI_CHCONF_TURBO;
 	mcspi_write_cs_reg(spi, OMAP2_MCSPI_CHCONF0, l);
 
+	if (spi->master->bus_num == 2) {
+		omap2_mcspi_force_cs(spi, 1);
+		omap2_mcspi_force_cs(spi, 0);
+	}
+
 	dev_dbg(&spi->dev, "setup: speed %d, sample %s edge, clk %s inverted\n",
 			OMAP2_MCSPI_MAX_FREQ / (1 << div),
 			(spi->mode & SPI_CPHA) ? "odd" : "even",
@@ -644,7 +769,6 @@
 	} else
 		return -EINVAL;
 
-
 	if (omap_request_dma(rx_dev_id, "McSPI RX",
 			     omap2_mcspi_dma_rx_callback, spi,
 			     &mcspi_dma->dma_rx_channel)) {
@@ -909,6 +1033,9 @@
 	if (omap2_mcspi_reset(master) < 0)
                 goto err4;
 
+	mcspi_write_reg(master, OMAP2_MCSPI_SYSCONFIG,
+			((0x2<<3) | (1<<0)));
+
 	status = spi_register_master(master);
 	if (status < 0)
 		goto err4;
@@ -958,6 +1085,7 @@
 static int __init omap2_mcspi_init(void)
 {
 	printk(KERN_INFO "OMAP24xx McSPI driver initializing\n");
+	spi_pause_mutex_init();
 	omap2_mcspi_wq = create_workqueue("OMAP McSPI");
 	if (omap2_mcspi_wq == NULL)
 		return -1;
diff -ruN linux-omap-2.6/drivers/spi/tsc2005.c maemo_src/drivers/spi/tsc2005.c
--- linux-omap-2.6/drivers/spi/tsc2005.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/spi/tsc2005.c	2011-02-06 20:12:13.039999939 -0500
@@ -0,0 +1,784 @@
+/*
+ * TSC2005 touchscreen driver
+ *
+ * Copyright (C) 2006-2007 Nokia Corporation
+ *
+ * Written by Timo O. Karjalainen <timo.o.karjalainen@nokia.com>
+ * based on TSC2301 driver by Jarkko Oikarinen, Imre Deak and Juha Yrjola
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+
+#ifdef CONFIG_ARCH_OMAP
+#include <asm/arch/gpio.h>
+#endif
+
+#include <linux/spi/tsc2005.h>
+
+/**
+ * The touchscreen interface operates as follows:
+ *
+ * Initialize:
+ *    Request access to GPIO103 (DAV)
+ *    tsc2005_dav_irq_handler will trigger when DAV line goes down
+ *
+ *  1) Pen is pressed against touchscreeen
+ *  2) TSC2005 performs AD conversion
+ *  3) After the conversion is done TSC2005 drives DAV line down
+ *  4) GPIO IRQ is received and tsc2005_dav_irq_handler is called
+ *  5) If gpio irq is enabled, irq is disabld and handler calls spi_async()
+ *  6) SPI framework calls tsc2005_ts_rx after the coordinates are read
+ *  7) tsc2005_ts_rx() reports coordinates to input layer and
+ *     sets up tsc2005_ts_timer() to be called after TSC2005_TS_SCAN_TIME
+ *  8) If the pen is down, tsc2005_tx_timer() calls spi_async(), causing
+ *     steps 6 to 8 to repeat.
+ *  9) if tsc2005_tx_timer() notices that the pen has been lifted, the lift
+ *     event is sent, and irq is again enabled.
+ */
+
+#define TSC2005_HZ	(14000000)
+
+#define TSC2005_CMD	(0x80)
+#define TSC2005_REG	(0x00)
+
+#define TSC2005_CMD_STOP	(1)
+#define TSC2005_CMD_10BIT	(0 << 2)
+#define TSC2005_CMD_12BIT	(1 << 2)
+
+#define TSC2005_CMD_SCAN_XYZZ	(0 << 3)
+#define TSC2005_CMD_SCAN_XY	(1 << 3)
+#define TSC2005_CMD_SCAN_X	(2 << 3)
+#define TSC2005_CMD_SCAN_Y	(3 << 3)
+#define TSC2005_CMD_SCAN_ZZ	(4 << 3)
+#define TSC2005_CMD_AUX_SINGLE	(5 << 3)
+#define TSC2005_CMD_TEMP1	(6 << 3)
+#define TSC2005_CMD_TEMP2	(7 << 3)
+#define TSC2005_CMD_AUX_CONT	(8 << 3)
+#define TSC2005_CMD_TEST_X_CONN	(9 << 3)
+#define TSC2005_CMD_TEST_Y_CONN	(10 << 3)
+/* command 11 reserved */
+#define TSC2005_CMD_TEST_SHORT	(12 << 3)
+#define TSC2005_CMD_DRIVE_XX	(13 << 3)
+#define TSC2005_CMD_DRIVE_YY	(14 << 3)
+#define TSC2005_CMD_DRIVE_YX	(15 << 3)
+
+#define TSC2005_REG_X		(0 << 3)
+#define TSC2005_REG_Y		(1 << 3)
+#define TSC2005_REG_Z1		(2 << 3)
+#define TSC2005_REG_Z2		(3 << 3)
+#define TSC2005_REG_AUX		(4 << 3)
+#define TSC2005_REG_TEMP1	(5 << 3)
+#define TSC2005_REG_TEMP2	(6 << 3)
+#define TSC2005_REG_STATUS	(7 << 3)
+#define TSC2005_REG_AUX_HIGH	(8 << 3)
+#define TSC2005_REG_AUX_LOW	(9 << 3)
+#define TSC2005_REG_TEMP_HIGH	(10 << 3)
+#define TSC2005_REG_TEMP_LOW	(11 << 3)
+#define TSC2005_REG_CFR0	(12 << 3)
+#define TSC2005_REG_CFR1	(13 << 3)
+#define TSC2005_REG_CFR2	(14 << 3)
+#define TSC2005_REG_FUNCTION	(15 << 3)
+
+#define TSC2005_REG_READ	(0x01)
+#define TSC2005_REG_WRITE	(0x00)
+
+
+#define TSC2005_CFR0_LONGSAMPLING	(0x0001)
+#define TSC2005_CFR0_DETECTINWAIT	(0x0002)
+#define TSC2005_CFR0_SENSETIME_32US	(0x0000)
+#define TSC2005_CFR0_SENSETIME_96US	(0x0004)
+#define TSC2005_CFR0_SENSETIME_544US	(0x0008)
+#define TSC2005_CFR0_SENSETIME_2080US	(0x0010)
+#define TSC2005_CFR0_SENSETIME_2656US	(0x001C)
+#define TSC2005_CFR0_PRECHARGE_20US	(0x0000)
+#define TSC2005_CFR0_PRECHARGE_84US	(0x0020)
+#define TSC2005_CFR0_PRECHARGE_276US	(0x0040)
+#define TSC2005_CFR0_PRECHARGE_1044US	(0x0080)
+#define TSC2005_CFR0_PRECHARGE_1364US	(0x00E0)
+#define TSC2005_CFR0_STABTIME_0US	(0x0000)
+#define TSC2005_CFR0_STABTIME_100US	(0x0100)
+#define TSC2005_CFR0_STABTIME_500US	(0x0200)
+#define TSC2005_CFR0_STABTIME_1MS	(0x0300)
+#define TSC2005_CFR0_STABTIME_5MS	(0x0400)
+#define TSC2005_CFR0_STABTIME_100MS	(0x0700)
+#define TSC2005_CFR0_CLOCK_4MHZ		(0x0000)
+#define TSC2005_CFR0_CLOCK_2MHZ		(0x0800)
+#define TSC2005_CFR0_CLOCK_1MHZ		(0x1000)
+#define TSC2005_CFR0_RESOLUTION12	(0x2000)
+#define TSC2005_CFR0_STATUS		(0x4000)
+#define TSC2005_CFR0_PENMODE		(0x8000)
+
+#define TSC2005_CFR0_INITVALUE	(TSC2005_CFR0_DETECTINWAIT |	\
+				 TSC2005_CFR0_STABTIME_1MS  |	\
+				 TSC2005_CFR0_CLOCK_1MHZ    |	\
+				 TSC2005_CFR0_RESOLUTION12  |	\
+				 TSC2005_CFR0_PENMODE)
+
+#define TSC2005_CFR1_BATCHDELAY_0MS	(0x0000)
+#define TSC2005_CFR1_BATCHDELAY_1MS	(0x0001)
+#define TSC2005_CFR1_BATCHDELAY_2MS	(0x0002)
+#define TSC2005_CFR1_BATCHDELAY_4MS	(0x0003)
+#define TSC2005_CFR1_BATCHDELAY_10MS	(0x0004)
+#define TSC2005_CFR1_BATCHDELAY_20MS	(0x0005)
+#define TSC2005_CFR1_BATCHDELAY_40MS	(0x0006)
+#define TSC2005_CFR1_BATCHDELAY_100MS	(0x0007)
+
+#define TSC2005_CFR1_INITVALUE	(TSC2005_CFR1_BATCHDELAY_1MS)
+
+#define TSC2005_CFR2_MAVE_TEMP	(0x0001)
+#define TSC2005_CFR2_MAVE_AUX	(0x0002)
+#define TSC2005_CFR2_MAVE_Z	(0x0004)
+#define TSC2005_CFR2_MAVE_Y	(0x0008)
+#define TSC2005_CFR2_MAVE_X	(0x0010)
+#define TSC2005_CFR2_AVG_1	(0x0000)
+#define TSC2005_CFR2_AVG_3	(0x0400)
+#define TSC2005_CFR2_AVG_7	(0x0800)
+#define TSC2005_CFR2_MEDIUM_1	(0x0000)
+#define TSC2005_CFR2_MEDIUM_3	(0x1000)
+#define TSC2005_CFR2_MEDIUM_7	(0x2000)
+#define TSC2005_CFR2_MEDIUM_15	(0x3000)
+
+#define TSC2005_CFR2_IRQ_DAV	(0x4000)
+#define TSC2005_CFR2_IRQ_PEN	(0x8000)
+#define TSC2005_CFR2_IRQ_PENDAV	(0x0000)
+
+#define TSC2005_CFR2_INITVALUE	(TSC2005_CFR2_IRQ_DAV  |	\
+				 TSC2005_CFR2_MAVE_X    |	\
+				 TSC2005_CFR2_MAVE_Y    |	\
+				 TSC2005_CFR2_MAVE_Z    |	\
+				 TSC2005_CFR2_MEDIUM_15 |	\
+				 TSC2005_CFR2_AVG_7)
+
+/*
+  #define TSC2301_TOUCHSCREEN_PRODUCT_ID      		0x0052
+  #define TSC2301_TOUCHSCREEN_PRODUCT_VERSION 		0x0001
+*/
+
+#define TSC2005_TS_SCAN_TIME		     		6
+
+#define MAX_12BIT					((1 << 12) - 1)
+
+
+static const u32 tsc2005_read_reg[] = {
+	(0x100 | TSC2005_REG | TSC2005_REG_X | TSC2005_REG_READ) << 16,
+	(0x100 | TSC2005_REG | TSC2005_REG_Y | TSC2005_REG_READ) << 16,
+	(0x100 | TSC2005_REG | TSC2005_REG_Z1 | TSC2005_REG_READ) << 16,
+	(0x100 | TSC2005_REG | TSC2005_REG_Z2 | TSC2005_REG_READ) << 16,
+	(0x100 | TSC2005_REG | TSC2005_REG_STATUS | TSC2005_REG_READ) << 16
+};
+#define NUM_READ_REGS	(sizeof(tsc2005_read_reg)/sizeof(tsc2005_read_reg[0]))
+
+struct tsc2005 {
+	struct spi_device	*spi;
+
+	s16			reset_gpio;
+	u16			config2_shadow;
+
+	struct input_dev	*idev;
+	char			phys[32];
+	struct timer_list	timer;
+	spinlock_t		lock;
+
+	struct spi_message	read_msg;
+	struct spi_transfer	read_xfer[NUM_READ_REGS];
+	u32                     data[NUM_READ_REGS];
+
+	int			hw_avg_max;
+	u16			x;
+	u16			y;
+	u16			p;
+	int			sample_cnt;
+
+	int			ignore_last : 1;
+	u16			x_plate_ohm;
+	int			stab_time;
+	int			max_pressure;
+	int			touch_pressure;
+	int			pressure_limit;
+
+	u16			irq_enabled:1;
+	u16			pen_down:1;
+	u16			disabled:1;
+	u16			pending:1;
+	u16			pnd:1;	/* power not down */
+
+	int			hw_flags;
+
+	s16			dav_gpio;
+	int			irq;
+};
+
+/* TSC2005 needs a 1-bit followed by 8 bits of command. */
+static void tsc2005_cmd(struct tsc2005 *ts, u8 cmd)
+{
+	u16 data = (1 << 8) | TSC2005_CMD | TSC2005_CMD_12BIT | cmd;
+	struct spi_message msg;
+	struct spi_transfer xfer = { 0 };
+
+	spi_message_init(&msg);
+	msg.spi = ts->spi;
+	xfer.tx_buf = &data;
+	xfer.rx_buf = NULL;
+	xfer.len = 2;
+	xfer.bits_per_word = 9;
+
+	spi_message_add_tail(&xfer, &msg);
+	spi_sync(ts->spi, &msg);
+}
+
+/*
+ *  To write a register, we send a 1-bit + 8 bit command + 16 bits of new
+ * register value.
+ */
+static void tsc2005_write(struct tsc2005 *ts, u8 reg, u16 value)
+{
+	u32 tx;
+	struct spi_message msg;
+	struct spi_transfer xfer = { 0 };
+
+	tx = 1 << (3 * 8);
+	tx |= (TSC2005_REG | reg | (ts->pnd << 1) |
+	       TSC2005_REG_WRITE) << (2 * 8);
+	tx |= value;
+
+	spi_message_init(&msg);
+	msg.spi = ts->spi;
+	xfer.tx_buf = &tx;
+	xfer.rx_buf = NULL;
+	xfer.len = 4;
+	xfer.bits_per_word = 1 + 3 * 8;
+
+	spi_message_add_tail(&xfer, &msg);
+	spi_sync(ts->spi, &msg);
+}
+
+static int tsc2005_ts_check_config(struct tsc2005 *ts, int *hw_flags)
+{
+	int flags;
+
+	flags = TSC2005_CMD_SCAN_XYZZ;
+
+	*hw_flags = flags;
+	return 0;
+}
+
+static int device_suspended(struct device *dev)
+{
+	struct tsc2005 *tsc = dev_get_drvdata(dev);
+	return dev->power.power_state.event != PM_EVENT_ON || tsc->disabled;
+}
+
+static void update_pen_state(struct tsc2005 *ts, int x, int y, int pressure)
+{
+	int sync = 0;
+
+	if (pressure) {
+		input_report_abs(ts->idev, ABS_X, x);
+		input_report_abs(ts->idev, ABS_Y, y);
+		input_report_abs(ts->idev, ABS_PRESSURE, pressure);
+		if (!ts->pen_down)
+			input_report_key(ts->idev, BTN_TOUCH, 1);
+		sync = 1;
+	} else if (ts->pen_down) {
+		input_report_abs(ts->idev, ABS_PRESSURE, 0);
+		input_report_key(ts->idev, BTN_TOUCH, 0);
+		sync = 1;
+	}
+
+	if (sync)
+		input_sync(ts->idev);
+
+	ts->pen_down = pressure ? 1 : 0;
+
+#ifdef VERBOSE
+	dev_dbg(&tsc->spi->dev, "x %4d y %4d p %4d\n", x, y, pressure);
+#endif
+}
+
+/*
+ * This procedure is called by the SPI framework after the coordinates
+ * have been read from TSC2005
+ */
+static void tsc2005_ts_rx(void *arg)
+{
+	struct tsc2005 *ts = arg;
+	unsigned int x, y, z1, z2, pressure;
+
+	x  = ts->data[0];
+	y  = ts->data[1];
+	z1 = ts->data[2];
+	z2 = ts->data[3];
+
+	if (z1) {
+		pressure = ts->x_plate_ohm * x;
+		pressure /= 4096;
+		pressure *= z2 - z1;
+		pressure /= z1;
+	} else
+		pressure = 0;
+
+	/*
+	 * If pressure value is above a preset limit (pen is barely
+	 * touching the screen) we can't trust the coordinate values.
+	 */
+	if (pressure < ts->pressure_limit && x < MAX_12BIT && y < MAX_12BIT) {
+		ts->pressure_limit = ts->max_pressure;
+		if (ts->ignore_last) {
+			if (ts->sample_cnt)
+				update_pen_state(ts, ts->x, ts->y, ts->p);
+			ts->x = x;
+			ts->y = y;
+			ts->p = pressure;
+		} else
+			update_pen_state(ts, x, y, pressure);
+		ts->sample_cnt++;
+	}
+
+	mod_timer(&ts->timer, jiffies +
+		  msecs_to_jiffies(TSC2005_TS_SCAN_TIME));
+}
+
+static int is_pen_down(struct tsc2005 *ts)
+{
+	return ts->pen_down;
+}
+
+/*
+ * Timer is called every TSC2005_TS_SCAN_TIME when the pen is down
+ */
+static void tsc2005_ts_timer(unsigned long arg)
+{
+	struct tsc2005 *ts = (void *) arg;
+	unsigned long flags;
+	int ndav;
+	int r;
+
+	spin_lock_irqsave(&ts->lock, flags);
+	ndav = omap_get_gpio_datain(ts->dav_gpio);
+	if (ndav || device_suspended(&ts->spi->dev)) {
+		/* Pen has been lifted */
+		if (!device_suspended(&ts->spi->dev)) {
+			ts->irq_enabled = 1;
+			enable_irq(ts->irq);
+		}
+		update_pen_state(ts, 0, 0, 0);
+		ts->pending = 0;
+		spin_unlock_irqrestore(&ts->lock, flags);
+	} else {
+		ts->pen_down = 1;
+		spin_unlock_irqrestore(&ts->lock, flags);
+		r = spi_async(ts->spi, &ts->read_msg);
+		if (r)
+			dev_err(&ts->spi->dev, "ts: spi_async() failed");
+	}
+}
+
+/*
+ * This interrupt is called when pen is down and first coordinates are
+ * available. That is indicated by a falling edge on DEV line.  IRQ is
+ * disabled here because while the pen is down the coordinates are
+ * read by a timer.
+ */
+static irqreturn_t tsc2005_ts_irq_handler(int irq, void *dev_id)
+{
+	struct tsc2005 *ts = dev_id;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ts->lock, flags);
+
+	if (ts->irq_enabled) {
+		ts->irq_enabled = 0;
+		disable_irq(ts->irq);
+		ts->pending = 1;
+		ts->pressure_limit = ts->touch_pressure;
+		ts->sample_cnt = 0;
+		spi_async(ts->spi, &ts->read_msg);
+	}
+	spin_unlock_irqrestore(&ts->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+
+void tsc2005_ts_prep_for_clk_stop(struct tsc2005 *tsc)
+{
+}
+
+void tsc2005_ts_cont_after_clk_stop(struct tsc2005 *tsc)
+{
+}
+
+static void tsc2005_ts_setup_spi_xfer(struct tsc2005 *ts)
+{
+	struct spi_message *m = &ts->read_msg;
+	struct spi_transfer *x = &ts->read_xfer[0];
+	int i;
+
+	spi_message_init(m);
+	m->spi = ts->spi;
+
+	for (i = 0; i < NUM_READ_REGS; i++, x++ ) {
+		x->tx_buf = &tsc2005_read_reg[i];
+		x->rx_buf = &ts->data[i];
+		x->len = 4;
+		x->bits_per_word = 25;
+		x->cs_change = i < (NUM_READ_REGS - 1);
+		spi_message_add_tail(x, m);
+	}
+
+	m->complete = tsc2005_ts_rx;
+	m->context = ts;
+}
+
+static ssize_t tsc2005_ts_pen_down_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct tsc2005 *tsc = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", is_pen_down(tsc));
+}
+
+static DEVICE_ATTR(pen_down, S_IRUGO, tsc2005_ts_pen_down_show, NULL);
+
+static int tsc2005_configure(struct tsc2005 *tsc, int flags)
+{
+	tsc2005_write(tsc, TSC2005_REG_CFR0, TSC2005_CFR0_INITVALUE);
+	tsc2005_write(tsc, TSC2005_REG_CFR1, TSC2005_CFR1_INITVALUE);
+	tsc2005_write(tsc, TSC2005_REG_CFR2, TSC2005_CFR2_INITVALUE);
+	tsc2005_cmd(tsc, flags);
+
+	return 0;
+}
+
+static void tsc2005_start_scan(struct tsc2005 *tsc)
+{
+	tsc2005_configure(tsc, tsc->hw_flags);
+}
+
+static void tsc2005_stop_scan(struct tsc2005 *tsc)
+{
+	tsc2005_configure(tsc, TSC2005_CMD_STOP);
+}
+
+/* Must be called with ts->lock held */
+static void tsc2005_disable(struct tsc2005 *ts)
+{
+	if (ts->disabled)
+		return;
+
+	ts->disabled = 1;
+	if (!ts->pending) {
+		ts->irq_enabled = 0;
+		disable_irq(ts->irq);
+	} else {
+		while (ts->pending) {
+			spin_unlock_irq(&ts->lock);
+			msleep(1);
+			spin_lock_irq(&ts->lock);
+		}
+	}
+
+	spin_unlock_irq(&ts->lock);
+	tsc2005_stop_scan(ts);
+	spin_lock_irq(&ts->lock);
+}
+
+static void tsc2005_enable(struct tsc2005 *ts)
+{
+	if (!ts->disabled)
+		return;
+
+	ts->disabled = 0;
+	ts->irq_enabled = 1;
+	enable_irq(ts->irq);
+
+	spin_unlock_irq(&ts->lock);
+	tsc2005_start_scan(ts);
+	spin_lock_irq(&ts->lock);
+}
+
+static ssize_t tsc2005_disable_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct tsc2005 *ts = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", ts->disabled);
+}
+
+static ssize_t tsc2005_disable_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct tsc2005		*tsc = dev_get_drvdata(dev);
+	char *endp;
+	int i;
+
+	i = simple_strtoul(buf, &endp, 10);
+	spin_lock_irq(&tsc->lock);
+
+	if (i)
+		tsc2005_disable(tsc);
+	else
+		tsc2005_enable(tsc);
+
+	spin_unlock_irq(&tsc->lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(disable_ts, 0664, tsc2005_disable_show,
+		   tsc2005_disable_store);
+
+
+static int __devinit tsc2005_ts_init(struct tsc2005 *ts,
+				     struct tsc2005_platform_data *pdata)
+{
+	struct input_dev *idev;
+	int dav_gpio, r;
+
+	if (pdata->dav_gpio < 0) {
+		dev_err(&ts->spi->dev, "need DAV GPIO");
+		return -EINVAL;
+	}
+	dav_gpio = pdata->dav_gpio;
+	ts->dav_gpio = dav_gpio;
+	dev_dbg(&ts->spi->dev, "TSC2005: DAV GPIO = %d\n", dav_gpio);
+
+#ifdef CONFIG_ARCH_OMAP
+	r = omap_request_gpio(dav_gpio);
+	if (r < 0) {
+		dev_err(&ts->spi->dev, "unable to get DAV GPIO");
+		goto err1;
+	}
+	omap_set_gpio_direction(dav_gpio, 1);
+	ts->irq = OMAP_GPIO_IRQ(dav_gpio);
+	dev_dbg(&ts->spi->dev, "TSC2005: DAV IRQ = %d\n", ts->irq);
+#endif
+	init_timer(&ts->timer);
+	ts->timer.data = (unsigned long) ts;
+	ts->timer.function = tsc2005_ts_timer;
+
+	spin_lock_init(&ts->lock);
+
+	ts->x_plate_ohm	= pdata->ts_x_plate_ohm ? : 280;
+	ts->hw_avg_max	= pdata->ts_hw_avg;
+	ts->max_pressure= pdata->ts_max_pressure ? : MAX_12BIT;
+	ts->touch_pressure = pdata->ts_touch_pressure ? : ts->max_pressure;
+	ts->ignore_last	= pdata->ts_ignore_last;
+	ts->stab_time	= pdata->ts_stab_time;
+
+	if ((r = tsc2005_ts_check_config(ts, &ts->hw_flags))) {
+		dev_err(&ts->spi->dev, "invalid configuration\n");
+		goto err2;
+	}
+
+	idev = input_allocate_device();
+	if (idev == NULL) {
+		r = -ENOMEM;
+		goto err2;
+	}
+
+	/*
+	 * TODO: should be "TSC2005 touchscreen", but X has hardcoded these
+	 * strings and doesn't accept TSC2005 yet...
+	 */
+	idev->name = "TSC2301 touchscreen";
+	snprintf(ts->phys, sizeof(ts->phys), "%s/input-ts",
+		 ts->spi->dev.bus_id);
+	idev->phys = ts->phys;
+
+	idev->evbit[0] = BIT(EV_ABS) | BIT(EV_KEY);
+	idev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y) | BIT(ABS_PRESSURE);
+	ts->idev = idev;
+
+	tsc2005_ts_setup_spi_xfer(ts);
+
+	/* These parameters should perhaps be configurable? */
+	input_set_abs_params(idev, ABS_X, 0, 4096, 4, 0);
+	input_set_abs_params(idev, ABS_Y, 0, 4096, 7, 0);
+	input_set_abs_params(idev, ABS_PRESSURE, 0, 1024, 2, 0);
+
+	tsc2005_start_scan(ts);
+
+	ts->irq_enabled = 1;
+	r = request_irq(ts->irq, tsc2005_ts_irq_handler,
+			IRQF_TRIGGER_FALLING | IRQF_DISABLED |
+			IRQF_SAMPLE_RANDOM, "tsc2005", ts);
+	if (r < 0) {
+		dev_err(&ts->spi->dev, "unable to get DAV IRQ");
+		goto err3;
+	}
+
+	set_irq_wake(ts->irq, 1);
+
+	r = input_register_device(idev);
+	if (r < 0) {
+		dev_err(&ts->spi->dev, "can't register touchscreen device\n");
+		goto err4;
+	}
+
+	/* We can tolerate these failing */
+	if (device_create_file(&ts->spi->dev, &dev_attr_pen_down));
+	if (device_create_file(&ts->spi->dev, &dev_attr_disable_ts));
+
+	return 0;
+err4:
+	free_irq(ts->irq, ts);
+err3:
+	tsc2005_stop_scan(ts);
+	input_free_device(idev);
+err2:
+#ifdef CONFIG_ARCH_OMAP
+	omap_free_gpio(dav_gpio);
+#endif
+err1:
+	return r;
+}
+
+static int __devinit tsc2005_probe(struct spi_device *spi)
+{
+	struct tsc2005			*tsc;
+	struct tsc2005_platform_data	*pdata = spi->dev.platform_data;
+	int r;
+
+	if (!pdata) {
+		dev_dbg(&spi->dev, "no platform data?\n");
+		return -ENODEV;
+	}
+
+	tsc = kzalloc(sizeof(*tsc), GFP_KERNEL);
+	if (tsc == NULL)
+		return -ENOMEM;
+
+	dev_set_drvdata(&spi->dev, tsc);
+	tsc->spi = spi;
+	spi->dev.power.power_state = PMSG_ON;
+
+	if (pdata->reset_gpio >= 0) {
+		tsc->reset_gpio = pdata->reset_gpio;
+#ifdef CONFIG_ARCH_OMAP
+		r = omap_request_gpio(tsc->reset_gpio);
+		if (r < 0)
+			goto err1;
+#endif
+	} else
+		tsc->reset_gpio = -1;
+
+	spi->mode = SPI_MODE_3;
+	spi->bits_per_word = 8;
+	/* The max speed might've been defined by the board-specific
+	 * struct */
+	if (!spi->max_speed_hz)
+		spi->max_speed_hz = TSC2005_HZ;
+
+	spi_setup(spi);
+
+	r = tsc2005_ts_init(tsc, pdata);
+	if (r)
+		goto err1;
+
+	return 0;
+
+err1:
+	kfree(tsc);
+	return r;
+}
+
+static int __devexit tsc2005_remove(struct spi_device *spi)
+{
+	struct tsc2005 *ts = dev_get_drvdata(&spi->dev);
+	unsigned long flags;
+
+	spin_lock_irqsave(&ts->lock, flags);
+	tsc2005_disable(ts);
+	spin_unlock_irqrestore(&ts->lock, flags);
+
+	device_remove_file(&ts->spi->dev, &dev_attr_disable_ts);
+	device_remove_file(&ts->spi->dev, &dev_attr_pen_down);
+
+	free_irq(ts->irq, ts);
+	input_unregister_device(ts->idev);
+
+#ifdef CONFIG_ARCH_OMAP
+	omap_free_gpio(ts->dav_gpio);
+#endif
+	kfree(ts);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int tsc2005_suspend(struct spi_device *spi, pm_message_t mesg)
+{
+	struct tsc2005 *ts = dev_get_drvdata(&spi->dev);
+
+	spin_lock_irq(&ts->lock);
+	tsc2005_disable(ts);
+	spin_unlock_irq(&ts->lock);
+
+	return 0;
+}
+
+static int tsc2005_resume(struct spi_device *spi)
+{
+	struct tsc2005 *ts = dev_get_drvdata(&spi->dev);
+
+	spin_lock_irq(&ts->lock);
+	tsc2005_enable(ts);
+	spin_unlock_irq(&ts->lock);
+
+	return 0;
+}
+#endif
+
+static struct spi_driver tsc2005_driver = {
+	.driver = {
+		.name = "tsc2005",
+		.bus = &spi_bus_type,
+		.owner = THIS_MODULE,
+	},
+#ifdef CONFIG_PM
+	.suspend = tsc2005_suspend,
+	.resume = tsc2005_resume,
+#endif
+	.probe = tsc2005_probe,
+	.remove = __devexit_p(tsc2005_remove),
+};
+
+static int __init tsc2005_init(void)
+{
+	printk("TSC2005 driver initializing\n");
+
+	return spi_register_driver(&tsc2005_driver);
+}
+module_init(tsc2005_init);
+
+static void __exit tsc2005_exit(void)
+{
+	spi_unregister_driver(&tsc2005_driver);
+}
+module_exit(tsc2005_exit);
+
+MODULE_AUTHOR("Timo O. Karjalainen <timo.o.karjalainen@nokia.com>");
+MODULE_LICENSE("GPL");
diff -ruN linux-omap-2.6/drivers/spi/tsc2301-kp.c maemo_src/drivers/spi/tsc2301-kp.c
--- linux-omap-2.6/drivers/spi/tsc2301-kp.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/spi/tsc2301-kp.c	2007-10-02 03:09:32.000000000 -0400
@@ -0,0 +1,559 @@
+/*
+ * TSC2301 keypad driver
+ *
+ * Copyright (C) 2005-2006 Nokia Corporation
+ *
+ * Written by Jarkko Oikarinen
+ * Rewritten by Juha Yrjola <juha.yrjola@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+
+#ifdef CONFIG_ARCH_OMAP
+#include <asm/arch/gpio.h>
+#endif
+
+#include <linux/spi/tsc2301.h>
+
+#define TSC2301_KEYBOARD_PRODUCT_ID      0x0051
+#define TSC2301_KEYBOARD_PRODUCT_VERSION 0x0001
+#define TSC2301_DEBOUNCE_TIME_2MS        0x0000
+#define TSC2301_DEBOUNCE_TIME_10MS       0x0800
+#define TSC2301_DEBOUNCE_TIME_20MS       0x1000
+#define TSC2301_DEBOUNCE_TIME_50MS       0x1800
+#define TSC2301_DEBOUNCE_TIME_60MS       0x2000
+#define TSC2301_DEBOUNCE_TIME_80MS       0x2800
+#define TSC2301_DEBOUNCE_TIME_100MS      0x3000
+#define TSC2301_DEBOUNCE_TIME_120MS      0x3800
+
+#define TSC2301_DEBOUNCE_TIME		TSC2301_DEBOUNCE_TIME_20MS
+
+#define TSC2301_POLL_TIME		30
+
+struct tsc2301_kp {
+	struct input_dev	*idev;
+	char			phys[32];
+	spinlock_t		lock;
+	struct mutex		mutex;
+	struct timer_list	timer;
+	u16			keys_pressed;
+	unsigned		pending:1;
+	unsigned		user_disabled:1;
+	unsigned		disable_depth;
+
+	struct spi_transfer	read_xfer[4];
+	struct spi_message	read_msg;
+	u16			state;
+	u16			data;
+	u16			mask;
+
+	int			irq;
+	s16			keymap[16];
+
+	int			(*get_keyb_irq_state)(struct device *dev);
+};
+
+static inline int tsc2301_kp_disabled(struct tsc2301 *tsc)
+{
+	return tsc->kp->disable_depth != 0;
+}
+
+static inline void tsc2301_kp_set_keypressed_state(struct tsc2301 *tsc)
+{
+	struct tsc2301_kp *kp = tsc->kp;
+
+	/* kp->state is updated only if we don't have the callback */
+	if (kp->get_keyb_irq_state != NULL) {
+		if (kp->get_keyb_irq_state(&tsc->spi->dev))
+			kp->state = 1 << 15;
+		else
+			kp->state = 0;
+	}
+}
+
+static inline int tsc2301_kp_key_is_pressed(struct tsc2301 *tsc)
+{
+	return tsc->kp->state & (1 << 15);
+}
+
+static void tsc2301_kp_send_key_events(struct tsc2301 *tsc,
+				       u16 prev_state,
+				       u16 new_state)
+{
+	struct tsc2301_kp *kp = tsc->kp;
+	u16 common, released, pressed;
+	int i;
+
+	common = prev_state & new_state;
+	released = common ^ prev_state;
+	pressed = common ^ new_state;
+	if (!released && !pressed)
+		return;
+	for (i = 0; i < 16 && (released || pressed); i++) {
+		if (released & 1) {
+			dev_dbg(&tsc->spi->dev, "key %d released\n", i);
+			input_report_key(kp->idev, kp->keymap[i], 0);
+		}
+		released >>= 1;
+		if (pressed & 1) {
+			dev_dbg(&tsc->spi->dev, "key %d pressed\n", i);
+			input_report_key(kp->idev, kp->keymap[i], 1);
+		}
+		pressed >>= 1;
+	}
+	input_sync(kp->idev);
+}
+
+static inline void tsc2301_kp_release_all_keys(struct tsc2301 *tsc)
+{
+	struct tsc2301_kp *kp = tsc->kp;
+	unsigned long flags;
+	int keys_pressed;
+
+	spin_lock_irqsave(&kp->lock, flags);
+	keys_pressed = kp->keys_pressed;
+	kp->keys_pressed = 0;
+	spin_unlock_irqrestore(&kp->lock, flags);
+	if (keys_pressed)
+		tsc2301_kp_send_key_events(tsc, keys_pressed, 0);
+}
+
+static inline void _filter_out(struct tsc2301 *tsc, u16 prev_state,
+			       u16 *new_state, int row1, int row2, u8 rect_pat)
+{
+	u16 mask;
+
+	mask = (rect_pat << (row1 * 4)) | (rect_pat << (row2 * 4));
+	mask &= ~prev_state;
+	*new_state &= ~mask;
+	dev_dbg(&tsc->spi->dev, "filtering ghost keys %02x\n", mask);
+}
+
+static void tsc2301_filter_ghost_keys(struct tsc2301 *tsc, u16 prev_state,
+				      u16 *new_state)
+{
+	int row1, row2;
+	u16 key_map;
+	u16 row1_map;
+	static const u8 rect_pat[] = {
+		0x3, 0x5, 0x9, 0x6, 0xa, 0xc, 0,
+	};
+
+	key_map = *new_state;
+	for (row1 = 0; row1 < 4; row1++) {
+		row1_map = (key_map >> (row1 * 4)) & 0xf;
+		if (!row1_map)
+			continue;
+		for (row2 = row1 + 1; row2 < 4; row2++) {
+			u16 rect_map = (key_map >> (row2 * 4)) & 0xf;
+			const u8 *rp;
+
+			rect_map &= row1_map;
+			if (!rect_map)
+				continue;
+			for (rp = rect_pat; *rp; rp++)
+				if ((rect_map & *rp) == *rp)
+					_filter_out(tsc, prev_state, new_state,
+						    row1, row2, *rp);
+		}
+	}
+}
+
+static void tsc2301_kp_timer(unsigned long arg)
+{
+	struct tsc2301 *tsc = (void *) arg;
+	int r;
+
+	/* This needs to be done early enough, since reading the key data
+	 * register clears the IRQ line, which may be used to determine
+	 * the key pressed state.
+	 */
+	tsc2301_kp_set_keypressed_state(tsc);
+	r = spi_async(tsc->spi, &tsc->kp->read_msg);
+	if (unlikely(r < 0 && printk_ratelimit()))
+		dev_err(&tsc->spi->dev, "kp: spi_async() failed");
+}
+
+static void tsc2301_kp_rx(void *arg)
+{
+	struct tsc2301 *tsc = arg;
+	struct tsc2301_kp *kp = tsc->kp;
+	unsigned long flags;
+	int key_pressed;
+	u16 kp_data;
+
+	kp_data = kp->data;
+	key_pressed = tsc2301_kp_key_is_pressed(tsc);
+	dev_dbg(&tsc->spi->dev, "KP data %04x (%s)\n",
+		kp_data, key_pressed ? "pressed" : "not pressed");
+	if (!key_pressed)
+		kp_data = 0;
+	else
+		tsc2301_filter_ghost_keys(tsc, kp->keys_pressed, &kp_data);
+	tsc2301_kp_send_key_events(tsc, kp->keys_pressed, kp_data);
+	kp->keys_pressed = kp_data;
+	spin_lock_irqsave(&kp->lock, flags);
+	if (likely(!tsc2301_kp_disabled(tsc))) {
+		if (likely(key_pressed))
+			mod_timer(&kp->timer,
+				 jiffies + msecs_to_jiffies(TSC2301_POLL_TIME));
+		else {
+			kp->pending = 0;
+			enable_irq(kp->irq);
+		}
+	} else
+		kp->pending = 0;
+	spin_unlock_irqrestore(&kp->lock, flags);
+}
+
+static irqreturn_t tsc2301_kp_irq_handler(int irq, void *dev_id)
+{
+	struct tsc2301 *tsc = dev_id;
+	struct tsc2301_kp *kp = tsc->kp;
+	unsigned long flags;
+
+	spin_lock_irqsave(&kp->lock, flags);
+	BUG_ON(kp->pending);
+	if (tsc2301_kp_disabled(tsc)) {
+		spin_unlock_irqrestore(&kp->lock, flags);
+		return IRQ_HANDLED;
+	}
+	kp->pending = 1;
+	disable_irq_nosync(irq);
+	spin_unlock_irqrestore(&kp->lock, flags);
+	tsc2301_kp_timer((unsigned long) tsc);
+	return IRQ_HANDLED;
+}
+
+static void tsc2301_kp_start_scan(struct tsc2301 *tsc)
+{
+	tsc2301_write_reg(tsc, TSC2301_REG_KPMASK, tsc->kp->mask);
+	tsc2301_write_reg(tsc, TSC2301_REG_KEY, TSC2301_DEBOUNCE_TIME);
+}
+
+static void tsc2301_kp_stop_scan(struct tsc2301 *tsc)
+{
+	tsc2301_write_reg(tsc, TSC2301_REG_KEY, 1 << 14);
+	tsc2301_write_reg(tsc, TSC2301_REG_KPMASK, 0xffff);
+}
+
+/* Must be called with the mutex held */
+static void tsc2301_kp_enable(struct tsc2301 *tsc)
+{
+	struct tsc2301_kp *kp = tsc->kp;
+	unsigned long flags;
+
+	spin_lock_irqsave(&kp->lock, flags);
+	BUG_ON(!tsc2301_kp_disabled(tsc));
+	if (--kp->disable_depth != 0) {
+		spin_unlock_irqrestore(&kp->lock, flags);
+		return;
+	}
+	if (kp->keys_pressed)
+		kp->pending = 1;
+	spin_unlock_irqrestore(&kp->lock, flags);
+
+	set_irq_type(kp->irq, IRQT_FALLING);
+	tsc2301_kp_start_scan(tsc);
+	if (kp->pending)
+		/* continue an interrupted polling */
+		mod_timer(&kp->timer,
+			  jiffies + msecs_to_jiffies(TSC2301_POLL_TIME));
+	else
+		enable_irq(kp->irq);
+}
+
+/* Must be called with the mutex held */
+static int tsc2301_kp_disable(struct tsc2301 *tsc, int release_keys)
+{
+	struct tsc2301_kp *kp = tsc->kp;
+	unsigned long flags;
+
+	spin_lock_irqsave(&kp->lock, flags);
+	if (kp->disable_depth++ != 0) {
+		spin_unlock_irqrestore(&kp->lock, flags);
+		goto out;
+	}
+	if (!kp->pending)
+		disable_irq_nosync(kp->irq);
+
+	while (kp->pending) {
+		spin_unlock_irqrestore(&kp->lock, flags);
+		msleep(1);
+		spin_lock_irqsave(&kp->lock, flags);
+	}
+	spin_unlock_irqrestore(&kp->lock, flags);
+
+	tsc2301_kp_stop_scan(tsc);
+	set_irq_type(kp->irq, IRQT_NOEDGE);
+out:
+	if (release_keys)
+		tsc2301_kp_release_all_keys(tsc);
+
+	return 0;
+}
+
+/* The following workaround is needed for a HW bug triggered by the
+ * following:
+ * 1. keep any key pressed
+ * 2. disable keypad
+ * 3. release all keys
+ * 4. reenable keypad
+ * 5. disable touch screen controller
+ *
+ * After this the keypad scanner will get stuck in busy state and won't
+ * report any interrupts for further keypresses. One way to recover is to
+ * restart the keypad scanner whenever we enable / disable the
+ * touchscreen controller.
+ */
+void tsc2301_kp_restart(struct tsc2301 *tsc)
+{
+	struct tsc2301_kp *kp = tsc->kp;
+
+	mutex_lock(&kp->mutex);
+	if (!kp->user_disabled) {
+		tsc2301_kp_disable(tsc, 0);
+		tsc2301_kp_enable(tsc);
+	}
+	mutex_unlock(&kp->mutex);
+}
+
+static ssize_t tsc2301_kp_disable_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct tsc2301		*tsc = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", tsc2301_kp_disabled(tsc) ? 1 : 0);
+}
+
+static ssize_t tsc2301_kp_disable_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct tsc2301		*tsc = dev_get_drvdata(dev);
+	struct tsc2301_kp	*kp = tsc->kp;
+	char *endp;
+	int i;
+
+	i = simple_strtoul(buf, &endp, 10);
+	i = i ? 1 : 0;
+
+	mutex_lock(&kp->mutex);
+	if (i == kp->user_disabled) {
+		mutex_unlock(&kp->mutex);
+		return count;
+	}
+	kp->user_disabled = i;
+
+	if (i)
+		tsc2301_kp_disable(tsc, 1);
+	else
+		tsc2301_kp_enable(tsc);
+	mutex_unlock(&kp->mutex);
+
+	return count;
+}
+
+static DEVICE_ATTR(disable_kp, 0664, tsc2301_kp_disable_show,
+		   tsc2301_kp_disable_store);
+
+static const u16 tsc2301_kp_read_data = 0x8000 | TSC2301_REG_KPDATA;
+static const u16 tsc2301_kp_read_state = 0x8000 | TSC2301_REG_KEY;
+
+static void tsc2301_kp_setup_spi_xfer(struct tsc2301 *tsc)
+{
+	struct tsc2301_kp *kp = tsc->kp;
+	struct spi_message *m = &kp->read_msg;
+	struct spi_transfer *x = &kp->read_xfer[0];
+
+	spi_message_init(&kp->read_msg);
+
+	if (kp->get_keyb_irq_state == NULL) {
+		/* No platform specific way for determining the keypress
+		 * state, so we'll need an extra status register read.
+		 */
+		x->tx_buf = &tsc2301_kp_read_state;
+		x->len = 2;
+		spi_message_add_tail(x, m);
+		x++;
+
+		x->rx_buf = &kp->state;
+		x->len = 2;
+		x->cs_change = 1;
+		spi_message_add_tail(x, m);
+		x++;
+	}
+
+	x->tx_buf = &tsc2301_kp_read_data;
+	x->len = 2;
+	spi_message_add_tail(x, m);
+	x++;
+
+	x->rx_buf = &kp->data;
+	x->len = 2;
+	spi_message_add_tail(x, m);
+
+	m->complete = tsc2301_kp_rx;
+	m->context = tsc;
+}
+
+#ifdef CONFIG_PM
+int tsc2301_kp_suspend(struct tsc2301 *tsc)
+{
+	struct tsc2301_kp *kp = tsc->kp;
+
+	mutex_lock(&kp->mutex);
+	tsc2301_kp_disable(tsc, 1);
+	mutex_unlock(&kp->mutex);
+	return 0;
+}
+
+void tsc2301_kp_resume(struct tsc2301 *tsc)
+{
+	struct tsc2301_kp *kp = tsc->kp;
+
+	mutex_lock(&kp->mutex);
+	tsc2301_kp_enable(tsc);
+	mutex_unlock(&kp->mutex);
+}
+#endif
+
+int __devinit tsc2301_kp_init(struct tsc2301 *tsc,
+			      struct tsc2301_platform_data *pdata)
+{
+	struct input_dev *idev;
+	struct tsc2301_kp *kp;
+	int r, i;
+	u16 mask;
+
+	if (pdata->keyb_int < 0) {
+		dev_err(&tsc->spi->dev, "need kbirq");
+		return -EINVAL;
+	}
+
+	kp = kzalloc(sizeof(*kp), GFP_KERNEL);
+	if (kp == NULL)
+		return -ENOMEM;
+	tsc->kp = kp;
+
+	kp->irq = pdata->keyb_int;
+	spin_lock_init(&kp->lock);
+	mutex_init(&kp->mutex);
+
+	init_timer(&kp->timer);
+	kp->timer.data = (unsigned long) tsc;
+	kp->timer.function = tsc2301_kp_timer;
+
+	kp->get_keyb_irq_state = pdata->get_keyb_irq_state;
+
+	idev = input_allocate_device();
+	if (idev == NULL) {
+		r = -ENOMEM;
+		goto err1;
+	}
+	idev->name = "TSC2301 keypad";
+	snprintf(kp->phys, sizeof(kp->phys), "%s/input-kp", tsc->spi->dev.bus_id);
+	idev->phys = kp->phys;
+
+	mask = 0;
+	idev->evbit[0] = BIT(EV_KEY);
+	for (i = 0; i < 16; i++) {
+		if (pdata->keymap[i] > 0) {
+			set_bit(pdata->keymap[i], idev->keybit);
+			kp->keymap[i] = pdata->keymap[i];
+		} else {
+			kp->keymap[i] = -1;
+			mask |= 1 << i;
+		}
+	}
+
+	if (pdata->kp_rep)
+		set_bit(EV_REP, idev->evbit);
+
+	kp->idev = idev;
+
+	tsc2301_kp_setup_spi_xfer(tsc);
+
+	r = device_create_file(&tsc->spi->dev, &dev_attr_disable_kp);
+	if (r < 0)
+		goto err2;
+
+	tsc2301_kp_start_scan(tsc);
+
+	/* IRQ mode 0 is faulty, it can cause the KBIRQ to get stuck.
+	 * Mode 2 deasserts the IRQ at:
+	 * - HW or SW reset
+	 * - Setting SCS flag in REG_KEY register
+	 * - Releasing all keys
+	 * - Reading the REG_KPDATA
+	 */
+	tsc2301_write_kbc(tsc, 2);
+
+	tsc2301_write_reg(tsc, TSC2301_REG_KPMASK, mask);
+	kp->mask = mask;
+
+	set_irq_type(kp->irq, IRQT_FALLING);
+
+	r = request_irq(kp->irq, tsc2301_kp_irq_handler, SA_SAMPLE_RANDOM,
+			"tsc2301-kp", tsc);
+	if (r < 0) {
+		dev_err(&tsc->spi->dev, "unable to get kbirq IRQ");
+		goto err3;
+	}
+	set_irq_wake(kp->irq, 1);
+
+	/* We need to read the register once..? */
+	tsc2301_read_reg(tsc, TSC2301_REG_KPDATA);
+
+	r = input_register_device(idev);
+	if (r < 0) {
+		dev_err(&tsc->spi->dev, "can't register keypad device\n");
+		goto err4;
+	}
+
+	return 0;
+
+err4:
+	free_irq(kp->irq, tsc);
+err3:
+	tsc2301_kp_stop_scan(tsc);
+	device_remove_file(&tsc->spi->dev, &dev_attr_disable_kp);
+err2:
+	input_free_device(kp->idev);
+err1:
+	kfree(kp);
+	return r;
+}
+
+void __devexit tsc2301_kp_exit(struct tsc2301 *tsc)
+{
+	struct tsc2301_kp *kp = tsc->kp;
+
+	tsc2301_kp_disable(tsc, 1);
+	input_unregister_device(kp->idev);
+	free_irq(kp->irq, tsc);
+	device_remove_file(&tsc->spi->dev, &dev_attr_disable_kp);
+
+	kfree(kp);
+}
diff -ruN linux-omap-2.6/drivers/spi/tsc2301-mixer.c maemo_src/drivers/spi/tsc2301-mixer.c
--- linux-omap-2.6/drivers/spi/tsc2301-mixer.c	2011-02-06 20:17:25.813333272 -0500
+++ maemo_src/drivers/spi/tsc2301-mixer.c	2007-10-02 03:09:32.000000000 -0400
@@ -236,7 +236,7 @@
 	struct tsc2301_mixer *mix = tsc->mixer;
 	u16 pd_ctrl, pd_ctrl_old, w;
 	unsigned long timeout;
-	int power_up = 0;
+	int power_up = 0, gpio_restore = 0;
 
 	if (mix->delayed_pd_active) {
 		mix->delayed_pd_active = 0;
@@ -373,12 +373,8 @@
 	tsc2301_write_reg(tsc, TSC2301_REG_PD_MISC, pd_ctrl);
 	if (power_up)
 		mix->pu_jiffies = jiffies;
-	if (!poll_pdsts) {
-		if (power_up)
-			tsc2301_write_reg(tsc, TSC2301_REG_GPIO,
-					  mix->shadow_regs[GPIO_INDEX]);
-		return;
-	}
+	if (!poll_pdsts)
+		goto out;
 
 	/* wait until power-up/-down is completed */
 	timeout = jiffies + msecs_to_jiffies(100);
@@ -414,15 +410,19 @@
 		timeout = mix->pu_jiffies + TSC2301_DAC_DELAY - jiffies;
 		if (timeout <= TSC2301_DAC_DELAY)
 			schedule_timeout_interruptible(timeout);
-		/* FIXME: This is lazy. We restore GPIOs only after activating
-		 * the DAC. It would be better to do some kind of delayed GPIO
-		 * restore. That ensures that we restore them also if only ADC
-		 * path is activated. But this is required only if there is
-		 * some input amplifier, bias control, etc. and their power
-		 * state is under TSC GPIO control */
+		gpio_restore = 1;
+	}
+	if (((pd_ctrl ^ pd_ctrl_old) & TSC2301_REG_PD_MISC_ABPD) &&
+	    !(pd_ctrl & TSC2301_REG_PD_MISC_ABPD))
+		/* line bypass path powered up now */
+		gpio_restore = 1;
+	/* FIXME: Delayed GPIO restore if only ADC is activated. This is
+	 * required only if there are some input amplifier, bias control, etc.
+	 * and their power state is under TSC GPIO control */
+
+	if (gpio_restore)
 		tsc2301_write_reg(tsc, TSC2301_REG_GPIO,
 				  mix->shadow_regs[GPIO_INDEX]);
-	}
 }
 
 static int snd_tsc2301_info_single(struct snd_kcontrol *kcontrol,
diff -ruN linux-omap-2.6/drivers/spi/tsc2301-ts.c maemo_src/drivers/spi/tsc2301-ts.c
--- linux-omap-2.6/drivers/spi/tsc2301-ts.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/spi/tsc2301-ts.c	2007-10-02 03:09:32.000000000 -0400
@@ -0,0 +1,679 @@
+/*
+ * TSC2301 touchscreen driver
+ *
+ * Copyright (C) 2005-2006 Nokia Corporation
+ *
+ * Written by Jarkko Oikarinen, Imre Deak and Juha Yrjola
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+
+#ifdef CONFIG_ARCH_OMAP
+#include <asm/arch/gpio.h>
+#endif
+
+#include <linux/spi/tsc2301.h>
+
+/**
+ * The touchscreen interface operates as follows:
+ *
+ * Initialize:
+ *    Request access to GPIO103 (DAV)
+ *    tsc2301_dav_irq_handler will trigger when DAV line goes down
+ *
+ *  1) Pen is pressed against touchscreeen
+ *  2) TSC2301 performs AD conversion
+ *  3) After the conversion is done TSC2301 drives DAV line down
+ *  4) GPIO IRQ is received and tsc2301_dav_irq_handler is called
+ *  5) tsc2301_dav_irq_handler sets up tsc2301_ts_timer in TSC2301_TS_SCAN_TIME
+ *  6) tsc2301_ts_timer disables the irq and requests spi driver
+ *     to read X, Y, Z1 and Z2
+ *  7) SPI framework calls tsc2301_ts_rx after the coordinates are read
+ *  8) tsc2301_ts_rx reports coordinates to input layer and
+ *     sets up tsc2301_ts_timer to be called after TSC2301_TS_SCAN_TIME
+ *  9) if tsc2301_tx_timer notices that the pen has been lifted, the lift event
+ *     is sent, and irq is again enabled.
+ */
+
+
+#define TSC2301_TOUCHSCREEN_PRODUCT_ID      		0x0052
+#define TSC2301_TOUCHSCREEN_PRODUCT_VERSION 		0x0001
+
+#define TSC2301_TS_SCAN_TIME		     		1
+
+#define TSC2301_ADCREG_CONVERSION_CTRL_BY_TSC2301	0x8000
+#define TSC2301_ADCREG_CONVERSION_CTRL_BY_HOST		0x0000
+
+#define TSC2301_ADCREG_FUNCTION_NONE			0x0000
+#define TSC2301_ADCREG_FUNCTION_XY			0x0400
+#define TSC2301_ADCREG_FUNCTION_XYZ			0x0800
+#define TSC2301_ADCREG_FUNCTION_X			0x0C00
+#define TSC2301_ADCREG_FUNCTION_Y			0x1000
+#define TSC2301_ADCREG_FUNCTION_Z			0x1400
+#define TSC2301_ADCREG_FUNCTION_DAT1			0x1800
+#define TSC2301_ADCREG_FUNCTION_DAT2			0x1C00
+#define TSC2301_ADCREG_FUNCTION_AUX1			0x2000
+#define TSC2301_ADCREG_FUNCTION_AUX2			0x2400
+#define TSC2301_ADCREG_FUNCTION_TEMP			0x2800
+
+#define TSC2301_ADCREG_RESOLUTION_8BIT			0x0100
+#define TSC2301_ADCREG_RESOLUTION_10BIT			0x0200
+#define TSC2301_ADCREG_RESOLUTION_12BIT			0x0300
+
+#define TSC2301_ADCREG_AVERAGING_NONE			0x0000
+#define TSC2301_ADCREG_AVERAGING_4AVG			0x0040
+#define TSC2301_ADCREG_AVERAGING_8AVG			0x0080
+#define TSC2301_ADCREG_AVERAGING_16AVG			0x00C0
+
+#define TSC2301_ADCREG_CLOCK_8MHZ			0x0000
+#define TSC2301_ADCREG_CLOCK_4MHZ			0x0010
+#define TSC2301_ADCREG_CLOCK_2MHZ			0x0020
+#define TSC2301_ADCREG_CLOCK_1MHZ			0x0030
+
+#define TSC2301_ADCREG_VOLTAGE_STAB_0US			0x0000
+#define TSC2301_ADCREG_VOLTAGE_STAB_100US		0x0002
+#define TSC2301_ADCREG_VOLTAGE_STAB_500US		0x0004
+#define TSC2301_ADCREG_VOLTAGE_STAB_1MS			0x0006
+#define TSC2301_ADCREG_VOLTAGE_STAB_5MS			0x0008
+#define TSC2301_ADCREG_VOLTAGE_STAB_10MS		0x000A
+#define TSC2301_ADCREG_VOLTAGE_STAB_50MS		0x000C
+#define TSC2301_ADCREG_VOLTAGE_STAB_100MS		0x000E
+
+#define TSC2301_ADCREG_STOP_CONVERSION			0x4000
+
+#define MAX_12BIT					((1 << 12) - 1)
+
+struct tsc2301_ts {
+	struct input_dev	*idev;
+	char			phys[32];
+	struct timer_list	timer;
+	spinlock_t		lock;
+
+	struct spi_transfer	read_xfer[2];
+	struct spi_message	read_msg;
+	u16                     data[4];
+
+	int			hw_avg_max;
+	u16			x;
+	u16			y;
+	u16			p;
+	int			sample_cnt;
+
+	int			ignore_last : 1;
+	u16			x_plate_ohm;
+	int			stab_time;
+	int			max_pressure;
+	int			touch_pressure;
+	int			pressure_limit;
+
+	u16			irq_enabled:1;
+	u16			pen_down:1;
+	u16			disabled:1;
+	u16			pending:1;
+
+	int			hw_flags;
+
+	s16			dav_gpio;
+	int			irq;
+};
+
+
+static const u16 tsc2301_ts_read_data = 0x8000 | TSC2301_REG_X;
+
+static int tsc2301_ts_check_config(struct tsc2301_ts *ts, int *hw_flags)
+{
+	int flags;
+
+	flags = 0;
+	switch (ts->hw_avg_max) {
+	case 0:
+		flags |= TSC2301_ADCREG_AVERAGING_NONE;
+		break;
+	case 4:
+		flags |= TSC2301_ADCREG_AVERAGING_4AVG;
+		break;
+	case 8:
+		flags |= TSC2301_ADCREG_AVERAGING_8AVG;
+		break;
+	case 16:
+		flags |= TSC2301_ADCREG_AVERAGING_16AVG;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	switch (ts->stab_time) {
+	case 0:
+		flags |= TSC2301_ADCREG_VOLTAGE_STAB_0US;
+		break;
+	case 100:
+		flags |= TSC2301_ADCREG_VOLTAGE_STAB_100US;
+		break;
+	case 500:
+		flags |= TSC2301_ADCREG_VOLTAGE_STAB_500US;
+		break;
+	case 1000:
+		flags |= TSC2301_ADCREG_VOLTAGE_STAB_1MS;
+		break;
+	case 5000:
+		flags |= TSC2301_ADCREG_VOLTAGE_STAB_5MS;
+		break;
+	case 10000:
+		flags |= TSC2301_ADCREG_VOLTAGE_STAB_10MS;
+		break;
+	case 50000:
+		flags |= TSC2301_ADCREG_VOLTAGE_STAB_50MS;
+		break;
+	case 100000:
+		flags |= TSC2301_ADCREG_VOLTAGE_STAB_100MS;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	*hw_flags = flags;
+	return 0;
+}
+
+/*
+ * This odd three-time initialization is to work around a bug in TSC2301.
+ * See TSC2301 errata for details.
+ */
+static int tsc2301_ts_configure(struct tsc2301 *tsc, int flags)
+{
+	struct spi_transfer xfer[3];
+	struct spi_transfer *x;
+	struct spi_message m;
+	int reg = TSC2301_REG_ADC;
+	u16 val1, val2, val3;
+	u16 data[6];
+
+	val1 = TSC2301_ADCREG_CONVERSION_CTRL_BY_HOST |
+		TSC2301_ADCREG_STOP_CONVERSION |
+		TSC2301_ADCREG_FUNCTION_NONE |
+		TSC2301_ADCREG_RESOLUTION_12BIT |
+		TSC2301_ADCREG_AVERAGING_NONE |
+		TSC2301_ADCREG_CLOCK_2MHZ |
+		TSC2301_ADCREG_VOLTAGE_STAB_100MS;
+
+	val2 = TSC2301_ADCREG_CONVERSION_CTRL_BY_HOST |
+		TSC2301_ADCREG_FUNCTION_XYZ |
+		TSC2301_ADCREG_RESOLUTION_12BIT |
+		TSC2301_ADCREG_AVERAGING_16AVG |
+		TSC2301_ADCREG_CLOCK_1MHZ |
+		TSC2301_ADCREG_VOLTAGE_STAB_100MS;
+
+	/* Averaging and voltage stabilization settings in flags */
+	val3 = TSC2301_ADCREG_CONVERSION_CTRL_BY_TSC2301 |
+		TSC2301_ADCREG_FUNCTION_XYZ |
+		TSC2301_ADCREG_RESOLUTION_12BIT |
+		TSC2301_ADCREG_CLOCK_1MHZ |
+		flags;
+
+	/* Now we prepare the command for transferring */
+	data[0] = reg;
+	data[1] = val1;
+	data[2] = reg;
+	data[3] = val2;
+	data[4] = reg;
+	data[5] = val3;
+
+	spi_message_init(&m);
+	m.spi = tsc->spi;
+
+	memset(xfer, 0, sizeof(xfer));
+	x = &xfer[0];
+
+	x->tx_buf = &data[0];
+	x->len = 4;
+	x->cs_change = 1;
+	spi_message_add_tail(x, &m);
+
+	x++;
+	x->tx_buf = &data[2];
+	x->len = 4;
+	x->cs_change = 1;
+	spi_message_add_tail(x, &m);
+
+	x++;
+	x->tx_buf = &data[4];
+	x->len = 4;
+	spi_message_add_tail(x, &m);
+
+	spi_sync(m.spi, &m);
+
+	return 0;
+}
+
+static void tsc2301_ts_start_scan(struct tsc2301 *tsc)
+{
+	tsc2301_ts_configure(tsc, tsc->ts->hw_flags);
+}
+
+static void tsc2301_ts_stop_scan(struct tsc2301 *tsc)
+{
+	tsc2301_ts_configure(tsc, TSC2301_ADCREG_STOP_CONVERSION);
+}
+
+static int device_suspended(struct device *dev)
+{
+	struct tsc2301 *tsc = dev_get_drvdata(dev);
+	return dev->power.power_state.event != PM_EVENT_ON || tsc->ts->disabled;
+}
+
+static void update_pen_state(struct tsc2301_ts *ts, int x, int y, int pressure)
+{
+	int sync = 0;
+
+	if (pressure) {
+		input_report_abs(ts->idev, ABS_X, x);
+		input_report_abs(ts->idev, ABS_Y, y);
+		input_report_abs(ts->idev, ABS_PRESSURE, pressure);
+		if (!ts->pen_down)
+			input_report_key(ts->idev, BTN_TOUCH, 1);
+		sync = 1;
+	} else if (ts->pen_down) {
+		input_report_abs(ts->idev, ABS_PRESSURE, 0);
+		input_report_key(ts->idev, BTN_TOUCH, 0);
+		sync = 1;
+	}
+
+	if (sync)
+		input_sync(ts->idev);
+
+	ts->pen_down = pressure ? 1 : 0;
+#ifdef VERBOSE
+	dev_dbg(&tsc->spi->dev, "x %4d y %4d p %4d\n", x, y, pressure);
+#endif
+}
+
+/*
+ * This procedure is called by the SPI framework after the coordinates
+ * have been read from TSC2301
+ */
+static void tsc2301_ts_rx(void *arg)
+{
+	struct tsc2301 *tsc = arg;
+	struct tsc2301_ts *ts = tsc->ts;
+	unsigned int x, y, z1, z2, pressure;
+
+	x  = ts->data[0];
+	y  = ts->data[1];
+	z1 = ts->data[2];
+	z2 = ts->data[3];
+
+	if (z1) {
+		pressure = ts->x_plate_ohm * x;
+		pressure /= 4096;
+		pressure *= z2 - z1;
+		pressure /= z1;
+	} else
+		pressure = 0;
+
+	/* If pressure value is above a preset limit (pen is barely
+	 * touching the screen) we can't trust the coordinate values.
+	 */
+	if (pressure < ts->pressure_limit && x < MAX_12BIT && y < MAX_12BIT) {
+		ts->pressure_limit = ts->max_pressure;
+		if (ts->ignore_last) {
+			if (ts->sample_cnt)
+				update_pen_state(ts, ts->x, ts->y, ts->p);
+			ts->x = x;
+			ts->y = y;
+			ts->p = pressure;
+		} else
+			update_pen_state(ts, x, y, pressure);
+		ts->sample_cnt++;
+	}
+
+	mod_timer(&ts->timer,
+		  jiffies + msecs_to_jiffies(TSC2301_TS_SCAN_TIME));
+}
+
+static int is_pen_down(struct tsc2301_ts *ts)
+{
+	return ts->pen_down;
+}
+
+/*
+ * Timer is called every TSC2301_TS_SCAN_TIME when the pen is down
+ */
+static void tsc2301_ts_timer(unsigned long arg)
+{
+	struct tsc2301 *tsc = (void *) arg;
+	struct tsc2301_ts *ts = tsc->ts;
+	unsigned long flags;
+	int ndav;
+	int r;
+
+	spin_lock_irqsave(&ts->lock, flags);
+	ndav = omap_get_gpio_datain(ts->dav_gpio);
+	if (ndav || device_suspended(&tsc->spi->dev)) {
+		/* Pen has been lifted */
+		if (!device_suspended(&tsc->spi->dev)) {
+			ts->irq_enabled = 1;
+			enable_irq(ts->irq);
+		}
+		update_pen_state(ts, 0, 0, 0);
+		ts->pending = 0;
+		spin_unlock_irqrestore(&ts->lock, flags);
+
+	} else {
+		ts->pen_down = 1;
+		spin_unlock_irqrestore(&ts->lock, flags);
+
+		r = spi_async(tsc->spi, &ts->read_msg);
+		if (r)
+			dev_err(&tsc->spi->dev, "ts: spi_async() failed");
+	}
+}
+
+/*
+ * This interrupt is called when pen is down and first coordinates are
+ * available. That is indicated by a falling edge on DEV line.  IRQ is
+ * disabled here because while the pen is down the coordinates are
+ * read by a timer.
+ */
+static irqreturn_t tsc2301_ts_irq_handler(int irq, void *dev_id)
+{
+	struct tsc2301 *tsc = dev_id;
+	struct tsc2301_ts *ts = tsc->ts;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ts->lock, flags);
+	if (ts->irq_enabled) {
+		ts->irq_enabled = 0;
+		disable_irq(ts->irq);
+		ts->pending = 1;
+		ts->pressure_limit = ts->touch_pressure;
+		ts->sample_cnt = 0;
+		mod_timer(&ts->timer,
+			  jiffies + msecs_to_jiffies(TSC2301_TS_SCAN_TIME));
+	}
+	spin_unlock_irqrestore(&ts->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+/* Must be called with ts->lock held */
+static void tsc2301_ts_disable(struct tsc2301 *tsc)
+{
+	struct tsc2301_ts *ts = tsc->ts;
+
+	if (ts->disabled)
+		return;
+
+	ts->disabled = 1;
+	if (!ts->pending) {
+		ts->irq_enabled = 0;
+		disable_irq(ts->irq);
+	} else {
+		while (ts->pending) {
+			spin_unlock_irq(&ts->lock);
+			msleep(1);
+			spin_lock_irq(&ts->lock);
+		}
+	}
+
+	spin_unlock_irq(&ts->lock);
+	tsc2301_ts_stop_scan(tsc);
+	/* Workaround a bug where turning on / off touchscreen scanner
+	 * can get the keypad scanner stuck.
+	 */
+	tsc2301_kp_restart(tsc);
+	spin_lock_irq(&ts->lock);
+}
+
+static void tsc2301_ts_enable(struct tsc2301 *tsc)
+{
+	struct tsc2301_ts *ts = tsc->ts;
+
+	if (!ts->disabled)
+		return;
+
+	ts->disabled = 0;
+	ts->irq_enabled = 1;
+	enable_irq(ts->irq);
+
+	spin_unlock_irq(&ts->lock);
+	tsc2301_ts_start_scan(tsc);
+	/* Same workaround as above. */
+	tsc2301_kp_restart(tsc);
+	spin_lock_irq(&ts->lock);
+}
+
+#ifdef CONFIG_PM
+int tsc2301_ts_suspend(struct tsc2301 *tsc)
+{
+	struct tsc2301_ts *ts = tsc->ts;
+
+	spin_lock_irq(&ts->lock);
+	tsc2301_ts_disable(tsc);
+	spin_unlock_irq(&ts->lock);
+
+	return 0;
+}
+
+void tsc2301_ts_resume(struct tsc2301 *tsc)
+{
+	struct tsc2301_ts *ts = tsc->ts;
+
+	spin_lock_irq(&ts->lock);
+	tsc2301_ts_enable(tsc);
+	spin_unlock_irq(&ts->lock);
+}
+#endif
+
+static void tsc2301_ts_setup_spi_xfer(struct tsc2301 *tsc)
+{
+	struct tsc2301_ts *ts = tsc->ts;
+	struct spi_message *m = &ts->read_msg;
+	struct spi_transfer *x = &ts->read_xfer[0];
+
+	spi_message_init(m);
+
+	x->tx_buf = &tsc2301_ts_read_data;
+	x->len = 2;
+	spi_message_add_tail(x, m);
+
+	x++;
+	x->rx_buf = &ts->data;
+	x->len = 8;
+	spi_message_add_tail(x, m);
+
+	m->complete = tsc2301_ts_rx;
+	m->context = tsc;
+}
+
+static ssize_t tsc2301_ts_pen_down_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct tsc2301 *tsc = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", is_pen_down(tsc->ts));
+}
+
+static DEVICE_ATTR(pen_down, S_IRUGO, tsc2301_ts_pen_down_show, NULL);
+
+static ssize_t tsc2301_ts_disable_show(struct device *dev,
+				       struct device_attribute *attr, char *buf)
+{
+	struct tsc2301		*tsc = dev_get_drvdata(dev);
+	struct tsc2301_ts	*ts = tsc->ts;
+
+	return sprintf(buf, "%u\n", ts->disabled);
+}
+
+static ssize_t tsc2301_ts_disable_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct tsc2301		*tsc = dev_get_drvdata(dev);
+	struct tsc2301_ts	*ts = tsc->ts;
+	char *endp;
+	int i;
+
+	i = simple_strtoul(buf, &endp, 10);
+	spin_lock_irq(&ts->lock);
+
+	if (i)
+		tsc2301_ts_disable(tsc);
+	else
+		tsc2301_ts_enable(tsc);
+
+	spin_unlock_irq(&ts->lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(disable_ts, 0664, tsc2301_ts_disable_show,
+		   tsc2301_ts_disable_store);
+
+int __devinit tsc2301_ts_init(struct tsc2301 *tsc,
+			      struct tsc2301_platform_data *pdata)
+{
+	struct tsc2301_ts *ts;
+	struct input_dev *idev;
+	int dav_gpio, r;
+
+	if (pdata->dav_gpio < 0) {
+		dev_err(&tsc->spi->dev, "need DAV GPIO");
+		return -EINVAL;
+	}
+	dav_gpio = pdata->dav_gpio;
+
+	ts = kzalloc(sizeof(*ts), GFP_KERNEL);
+	if (ts == NULL)
+		return -ENOMEM;
+	tsc->ts = ts;
+
+	ts->dav_gpio = dav_gpio;
+#ifdef CONFIG_ARCH_OMAP
+	r = omap_request_gpio(dav_gpio);
+	if (r < 0) {
+		dev_err(&tsc->spi->dev, "unable to get DAV GPIO");
+		goto err1;
+	}
+	omap_set_gpio_direction(dav_gpio, 1);
+	ts->irq = OMAP_GPIO_IRQ(dav_gpio);
+#endif
+	init_timer(&ts->timer);
+	ts->timer.data = (unsigned long) tsc;
+	ts->timer.function = tsc2301_ts_timer;
+
+	spin_lock_init(&ts->lock);
+
+	ts->x_plate_ohm	= pdata->ts_x_plate_ohm ? : 280;
+	ts->hw_avg_max	= pdata->ts_hw_avg;
+	ts->max_pressure= pdata->ts_max_pressure ? : MAX_12BIT;
+	ts->touch_pressure = pdata->ts_touch_pressure ? : ts->max_pressure;
+	ts->ignore_last	= pdata->ts_ignore_last;
+	ts->stab_time	= pdata->ts_stab_time;
+
+	if ((r = tsc2301_ts_check_config(ts, &ts->hw_flags))) {
+		dev_err(&tsc->spi->dev, "invalid configuration\n");
+		goto err2;
+	}
+
+	idev = input_allocate_device();
+	if (idev == NULL) {
+		r = -ENOMEM;
+		goto err2;
+	}
+	idev->name = "TSC2301 touchscreen";
+	snprintf(ts->phys, sizeof(ts->phys),
+		 "%s/input-ts", tsc->spi->dev.bus_id);
+	idev->phys = ts->phys;
+
+	idev->evbit[0] = BIT(EV_ABS) | BIT(EV_KEY);
+	idev->absbit[0] = BIT(ABS_X) | BIT(ABS_Y) | BIT(ABS_PRESSURE);
+	ts->idev = idev;
+
+	tsc2301_ts_setup_spi_xfer(tsc);
+
+	/* These parameters should perhaps be configurable? */
+	input_set_abs_params(idev, ABS_X, 0, 4096, 0, 0);
+	input_set_abs_params(idev, ABS_Y, 0, 4096, 0, 0);
+	input_set_abs_params(idev, ABS_PRESSURE, 0, 1024, 0, 0);
+
+	tsc2301_ts_start_scan(tsc);
+
+	ts->irq_enabled = 1;
+	r = request_irq(ts->irq, tsc2301_ts_irq_handler,
+			SA_SAMPLE_RANDOM | SA_TRIGGER_FALLING,
+			"tsc2301-ts", tsc);
+	if (r < 0) {
+		dev_err(&tsc->spi->dev, "unable to get DAV IRQ");
+		goto err3;
+	}
+	set_irq_wake(ts->irq, 1);
+
+	device_create_file(&tsc->spi->dev, &dev_attr_pen_down);
+	device_create_file(&tsc->spi->dev, &dev_attr_disable_ts);
+
+	r = input_register_device(idev);
+	if (r < 0) {
+		dev_err(&tsc->spi->dev, "can't register touchscreen device\n");
+		goto err4;
+	}
+
+	return 0;
+err4:
+	device_remove_file(&tsc->spi->dev, &dev_attr_disable_ts);
+	device_remove_file(&tsc->spi->dev, &dev_attr_pen_down);
+	free_irq(ts->irq, tsc);
+err3:
+	tsc2301_ts_stop_scan(tsc);
+	input_free_device(idev);
+err2:
+#ifdef CONFIG_ARCH_OMAP
+	omap_free_gpio(dav_gpio);
+#endif
+err1:
+	kfree(ts);
+	return r;
+}
+
+void __devexit tsc2301_ts_exit(struct tsc2301 *tsc)
+{
+	struct tsc2301_ts *ts = tsc->ts;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ts->lock, flags);
+	tsc2301_ts_disable(tsc);
+	spin_unlock_irqrestore(&ts->lock, flags);
+
+	device_remove_file(&tsc->spi->dev, &dev_attr_disable_ts);
+	device_remove_file(&tsc->spi->dev, &dev_attr_pen_down);
+
+	free_irq(ts->irq, tsc);
+	input_unregister_device(ts->idev);
+
+#ifdef CONFIG_ARCH_OMAP
+	omap_free_gpio(ts->dav_gpio);
+#endif
+	kfree(ts);
+}
+MODULE_AUTHOR("Jarkko Oikarinen <jarkko.oikarinen@nokia.com>");
+MODULE_LICENSE("GPL");
diff -ruN linux-omap-2.6/drivers/usb/core/generic.c maemo_src/drivers/usb/core/generic.c
--- linux-omap-2.6/drivers/usb/core/generic.c	2011-02-06 19:45:01.299999939 -0500
+++ maemo_src/drivers/usb/core/generic.c	2011-02-06 20:12:11.213333272 -0500
@@ -18,6 +18,7 @@
  */
 
 #include <linux/usb.h>
+#include <linux/usb/otg.h>
 #include "usb.h"
 
 static inline const char *plural(int n)
@@ -45,6 +46,7 @@
 	int num_configs;
 	int insufficient_power = 0;
 	struct usb_host_config *c, *best;
+	struct otg_transceiver	*xceiv = otg_get_transceiver();
 
 	best = NULL;
 	c = udev->config;
@@ -131,10 +133,15 @@
 			best = c;
 	}
 
-	if (insufficient_power > 0)
+	if (insufficient_power > 0) {
 		dev_info(&udev->dev, "rejected %d configuration%s "
 			"due to insufficient available bus power\n",
 			insufficient_power, plural(insufficient_power));
+#ifdef CONFIG_USB_OTG
+		if (!best)
+			otg_set_error(xceiv, OTG_ERR_DEVICE_NOT_SUPPORTED);
+#endif
+	}
 
 	if (best) {
 		i = best->desc.bConfigurationValue;
diff -ruN linux-omap-2.6/drivers/usb/core/hub.c maemo_src/drivers/usb/core/hub.c
--- linux-omap-2.6/drivers/usb/core/hub.c	2011-02-06 19:45:01.309999938 -0500
+++ maemo_src/drivers/usb/core/hub.c	2011-02-06 20:12:11.209999939 -0500
@@ -24,6 +24,8 @@
 #include <linux/mutex.h>
 #include <linux/freezer.h>
 
+#include <linux/usb/otg.h>
+
 #include <asm/semaphore.h>
 #include <asm/uaccess.h>
 #include <asm/byteorder.h>
@@ -1253,7 +1255,6 @@
 
 
 #ifdef	CONFIG_USB_OTG
-#include "otg_whitelist.h"
 static int __usb_port_suspend(struct usb_device *, int port1);
 #endif
 
@@ -1279,7 +1280,8 @@
  */
 int usb_new_device(struct usb_device *udev)
 {
-	int err;
+	struct otg_transceiver *xceiv = otg_get_transceiver();
+	int tpl_enabled = 0, err;
 
 	/* Determine quirks */
 	usb_detect_quirks(udev);
@@ -1324,7 +1326,7 @@
 					le16_to_cpu(udev->config[0].desc.wTotalLength),
 					USB_DT_OTG, (void **) &desc) == 0) {
 			if (desc->bmAttributes & USB_OTG_HNP) {
-				unsigned		port1 = udev->portnum;
+				unsigned	port1 = udev->portnum;
 
 				dev_info(&udev->dev,
 					"Dual-Role OTG device on %sHNP port\n",
@@ -1342,9 +1344,8 @@
 						: USB_DEVICE_A_ALT_HNP_SUPPORT,
 					0, NULL, 0, USB_CTRL_SET_TIMEOUT);
 				if (err < 0) {
-					/* OTG MESSAGE: report errors here,
-					 * customize to match your product.
-					 */
+					err = OTG_ERR_DEVICE_NOT_RESPONDING;
+					otg_set_error(xceiv, err);
 					dev_info(&udev->dev,
 						"can't set HNP mode; %d\n",
 						err);
@@ -1354,7 +1355,15 @@
 		}
 	}
 
-	if (!is_targeted(udev)) {
+	if (xceiv) {
+		tpl_enabled = xceiv->tpl_enabled;
+		put_device(xceiv->dev);
+	}
+
+	if (err != OTG_ERR_DEVICE_NOT_RESPONDING)
+		err = otg_targeted(udev);
+
+	if (tpl_enabled && err != OTG_ERR_DEVICE_SUPPORTED) {
 
 		/* Maybe it can talk to us, though we can't talk to it.
 		 * (Includes HNP test device.)
@@ -1363,9 +1372,16 @@
 			err = __usb_port_suspend(udev, udev->bus->otg_port);
 			if (err < 0)
 				dev_dbg(&udev->dev, "HNP fail, %d\n", err);
+			else {
+				/* HNP got started */
+				msleep(150);
+				err = -ENOTSUPP;
+				goto fail;
+			}
 		}
-		err = -ENODEV;
-		goto fail;
+
+		/* OK to try to use as unsupported device */
+		err = 0;
 	}
 #endif
 
@@ -2247,15 +2263,19 @@
 					buf->bMaxPacketSize0;
 			kfree(buf);
 
-			retval = hub_port_reset(hub, port1, udev, delay);
-			if (retval < 0)		/* error or disconnect */
-				goto fail;
-			if (oldspeed != udev->speed) {
-				dev_dbg(&udev->dev,
-					"device reset changed speed!\n");
-				retval = -ENODEV;
-				goto fail;
-			}
+			/* Reset makes most OPT A tests fail */
+			if (port1 != udev->bus->otg_port) {
+				retval = hub_port_reset(hub, port1, udev, delay);
+				if (retval < 0)		/* error or disconnect */
+					goto fail;
+				if (oldspeed != udev->speed) {
+					dev_dbg(&udev->dev,
+						"device reset changed speed!\n");
+					retval = -ENODEV;
+					goto fail;
+				}
+			} else
+				msleep(100);	/* Needed for OPT A tests */
 			if (r) {
 				dev_err(&udev->dev, "device descriptor "
 						"read/%s, error %d\n",
diff -ruN linux-omap-2.6/drivers/usb/core/Makefile maemo_src/drivers/usb/core/Makefile
--- linux-omap-2.6/drivers/usb/core/Makefile	2011-02-06 19:45:01.269999939 -0500
+++ maemo_src/drivers/usb/core/Makefile	2007-10-02 03:09:32.000000000 -0400
@@ -6,6 +6,10 @@
 			config.o file.o buffer.o sysfs.o endpoint.o \
 			devio.o notify.o generic.o quirks.o
 
+ifeq ($(CONFIG_USB_OTG),y)
+	usbcore-objs	+= otg.o
+endif
+
 ifeq ($(CONFIG_PCI),y)
 	usbcore-objs	+= hcd-pci.o
 endif
diff -ruN linux-omap-2.6/drivers/usb/core/message.c maemo_src/drivers/usb/core/message.c
--- linux-omap-2.6/drivers/usb/core/message.c	2011-02-06 20:17:25.816666605 -0500
+++ maemo_src/drivers/usb/core/message.c	2007-10-02 03:09:32.000000000 -0400
@@ -1597,6 +1597,7 @@
 
 // synchronous control message convenience routines
 EXPORT_SYMBOL(usb_get_descriptor);
+EXPORT_SYMBOL(usb_get_device_descriptor);
 EXPORT_SYMBOL(usb_get_status);
 EXPORT_SYMBOL(usb_string);
 
diff -ruN linux-omap-2.6/drivers/usb/core/otg.c maemo_src/drivers/usb/core/otg.c
--- linux-omap-2.6/drivers/usb/core/otg.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/usb/core/otg.c	2011-02-06 20:12:11.203333273 -0500
@@ -0,0 +1,241 @@
+/*
+ * drivers/usb/core/otg.c
+ *
+ * Copyright (C) 2004 Texas Instruments
+ * Copyright (C) 2007 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/usb.h>
+#include <linux/usb/otg.h>
+
+static struct otg_transceiver *xceiv;
+
+int otg_set_transceiver(struct otg_transceiver *x)
+{
+	if (xceiv && x)
+		return -EBUSY;
+	xceiv = x;
+	return 0;
+}
+EXPORT_SYMBOL(otg_set_transceiver);
+
+struct otg_transceiver *otg_get_transceiver(void)
+{
+	if (xceiv)
+		get_device(xceiv->dev);
+	return xceiv;
+}
+EXPORT_SYMBOL(otg_get_transceiver);
+
+/*
+ * OTG MESSAGE: report errors here, customize to match your product
+ * See also otg_last_error_show().
+ */
+void otg_set_error(struct otg_transceiver *x, enum usb_otg_error errno)
+{
+	if (!x)
+		return;
+
+	if (!x->tpl_enabled)
+		x->last_error = OTG_ERR_DEVICE_SUPPORTED;
+	else
+		x->last_error = errno;
+
+	if (!x->host->root_hub) {
+		printk(KERN_WARNING "OTG: root hub not yet initialized\n");
+		return;
+	}
+
+	sysfs_notify(&x->host->root_hub->dev.kobj, NULL, "otg_last_error");
+}
+EXPORT_SYMBOL(otg_set_error);
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef	CONFIG_USB_OTG_WHITELIST
+
+/*
+ * This OTG Whitelist is the OTG "Targeted Peripheral List".  It should
+ * mostly use of USB_DEVICE() or USB_DEVICE_VER() entries..
+ *
+ * YOU _SHOULD_ CHANGE THIS LIST TO MATCH YOUR PRODUCT AND ITS TESTING!
+ */
+
+static struct usb_device_id whitelist_table [] __initdata = {
+
+/* USB OPT HS A electrical test devices are always targeted */
+{ USB_DEVICE(0x1a0a, 0x0101), },
+{ USB_DEVICE(0x1a0a, 0x0102), },
+{ USB_DEVICE(0x1a0a, 0x0103), },
+{ USB_DEVICE(0x1a0a, 0x0104), },
+{ USB_DEVICE(0x1a0a, 0x0105), },
+{ USB_DEVICE(0x1a0a, 0x0106), },
+{ USB_DEVICE(0x1a0a, 0x0107), },
+{ USB_DEVICE(0x1a0a, 0x0108), },
+
+/*
+ * Support known mass storage devices
+ * REVISIT: Get this data from platform data
+ */
+{ USB_DEVICE(0x0421, 0x0431), }, /* N770 */
+{ USB_DEVICE(0x0421, 0x04c3), }, /* N800 */
+{ USB_DEVICE(0x0421, 0x0096), }, /* RX44 */
+{ USB_DEVICE(0x0421, 0x0189), }, /* RX48 */
+
+{ USB_DEVICE(0x0711, 0x0550), }, /* USB-VGA */
+
+{ }	/* Terminating entry */
+};
+
+struct otg_device {
+	struct list_head	list;
+	struct usb_device_id	id;
+};
+
+static struct list_head	tpl_devices;
+
+static void tpl_add_device(struct usb_device_id *id)
+{
+	struct otg_device	*otg;
+
+	otg = kzalloc(sizeof(*otg), GFP_KERNEL);
+	if (!otg)
+		return;
+	INIT_LIST_HEAD(&otg->list);
+	memcpy(&otg->id, id, sizeof(struct usb_device_id));
+	list_add_tail(&otg->list, &tpl_devices);
+}
+
+static void tpl_add_devices(struct usb_device_id *whitelist_table)
+{
+	struct usb_device_id	*id;
+
+	for (id = whitelist_table; id->match_flags; id++)
+		tpl_add_device(id);
+}
+
+ssize_t otg_print_whitelist(char *buf)
+{
+	struct otg_device	*otg;
+	ssize_t			len = 0;
+
+	list_for_each_entry(otg, &tpl_devices, list)
+		len += sprintf(buf + len, "%04x:%04x\t%02x %02x %02x\n",
+				le16_to_cpu(otg->id.idVendor),
+				le16_to_cpu(otg->id.idProduct),
+				otg->id.bDeviceClass,
+				otg->id.bDeviceSubClass,
+				otg->id.bDeviceProtocol);
+	return len;
+}
+
+int otg_targeted(struct usb_device *dev)
+{
+	struct otg_device	*otg;
+
+	if (!xceiv || !xceiv->tpl_enabled)
+		return OTG_ERR_DEVICE_SUPPORTED;
+
+	/* possible in developer configs only! */
+	if (!dev->bus->otg_port)
+		goto targeted;
+
+	/* HNP test device is _never_ targeted (see OTG spec 6.6.6) */
+	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x1a0a &&
+	     le16_to_cpu(dev->descriptor.idProduct) == 0xbadd))
+		goto err;
+
+
+	/* our roothub is always targeted */
+	if (!dev->parent)
+		goto targeted;
+
+	/* NOTE: can't use usb_match_id() since interface caches
+	 * aren't set up yet. this is cut/paste from that code.
+	 */
+	list_for_each_entry(otg, &tpl_devices, list) {
+		struct usb_device_id	*id = &otg->id;
+
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_VENDOR) &&
+		    id->idVendor != le16_to_cpu(dev->descriptor.idVendor))
+			continue;
+
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_PRODUCT) &&
+		    id->idProduct != le16_to_cpu(dev->descriptor.idProduct))
+			continue;
+
+		/* No need to test id->bcdDevice_lo != 0, since 0 is never
+		   greater than any unsigned number. */
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_LO) &&
+		    (id->bcdDevice_lo > le16_to_cpu(dev->descriptor.bcdDevice)))
+			continue;
+
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_HI) &&
+		    (id->bcdDevice_hi < le16_to_cpu(dev->descriptor.bcdDevice)))
+			continue;
+
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_CLASS) &&
+		    (id->bDeviceClass != dev->descriptor.bDeviceClass))
+			continue;
+
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_SUBCLASS) &&
+		    (id->bDeviceSubClass!= dev->descriptor.bDeviceSubClass))
+			continue;
+
+		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_PROTOCOL) &&
+		    (id->bDeviceProtocol != dev->descriptor.bDeviceProtocol))
+			continue;
+
+		goto targeted;
+	}
+
+	/* add other match criteria here ... */
+
+err:
+	dev_err(&dev->dev, "%s v%04x p%04x is not supported\n",
+		dev->descriptor.bDeviceClass == USB_CLASS_HUB ? "hub" : "device",
+		le16_to_cpu(dev->descriptor.idVendor),
+		le16_to_cpu(dev->descriptor.idProduct));
+	if (dev->descriptor.bDeviceClass == USB_CLASS_HUB)
+		otg_set_error(xceiv, OTG_ERR_HUB_NOT_SUPPORTED);
+	else
+		otg_set_error(xceiv, OTG_ERR_DEVICE_NOT_SUPPORTED);
+
+	return xceiv->last_error;
+
+targeted:
+	xceiv->last_error = OTG_ERR_DEVICE_SUPPORTED;
+	return xceiv->last_error;
+}
+
+static int __init tpl_init(void)
+{
+	INIT_LIST_HEAD(&tpl_devices);
+	tpl_add_devices(whitelist_table);
+	if (xceiv)
+		xceiv->tpl_enabled = 1;
+
+	return 0;
+}
+
+static void __exit tpl_exit(void)
+{
+	struct otg_device	*otg;
+
+	if (xceiv)
+		xceiv->tpl_enabled = 0;
+
+	list_for_each_entry(otg, &tpl_devices, list)
+		kfree(otg);
+}
+
+module_init(tpl_init);
+module_exit(tpl_exit);
+
+#endif	/* CONFIG_USB_OTG_WHITELIST */
diff -ruN linux-omap-2.6/drivers/usb/core/otg_whitelist.h maemo_src/drivers/usb/core/otg_whitelist.h
--- linux-omap-2.6/drivers/usb/core/otg_whitelist.h	2011-02-06 19:45:01.313333272 -0500
+++ maemo_src/drivers/usb/core/otg_whitelist.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,112 +0,0 @@
-/*
- * drivers/usb/core/otg_whitelist.h
- *
- * Copyright (C) 2004 Texas Instruments
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-/*
- * This OTG Whitelist is the OTG "Targeted Peripheral List".  It should
- * mostly use of USB_DEVICE() or USB_DEVICE_VER() entries..
- *
- * YOU _SHOULD_ CHANGE THIS LIST TO MATCH YOUR PRODUCT AND ITS TESTING!
- */ 
-
-static struct usb_device_id whitelist_table [] = {
-
-/* hubs are optional in OTG, but very handy ... */
-{ USB_DEVICE_INFO(USB_CLASS_HUB, 0, 0), },
-{ USB_DEVICE_INFO(USB_CLASS_HUB, 0, 1), },
-
-#ifdef	CONFIG_USB_PRINTER		/* ignoring nonstatic linkage! */
-/* FIXME actually, printers are NOT supposed to use device classes;
- * they're supposed to use interface classes...
- */
-{ USB_DEVICE_INFO(7, 1, 1) },
-{ USB_DEVICE_INFO(7, 1, 2) },
-{ USB_DEVICE_INFO(7, 1, 3) },
-#endif
-
-#ifdef	CONFIG_USB_NET_CDCETHER
-/* Linux-USB CDC Ethernet gadget */
-{ USB_DEVICE(0x0525, 0xa4a1), },
-/* Linux-USB CDC Ethernet + RNDIS gadget */
-{ USB_DEVICE(0x0525, 0xa4a2), },
-#endif
-
-#if	defined(CONFIG_USB_TEST) || defined(CONFIG_USB_TEST_MODULE)
-/* gadget zero, for testing */
-{ USB_DEVICE(0x0525, 0xa4a0), },
-#endif
-
-{ }	/* Terminating entry */
-};
-
-static int is_targeted(struct usb_device *dev)
-{
-	struct usb_device_id	*id = whitelist_table;
-
-	/* possible in developer configs only! */
-	if (!dev->bus->otg_port)
-		return 1;
-
-	/* HNP test device is _never_ targeted (see OTG spec 6.6.6) */
-	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x1a0a && 
-	     le16_to_cpu(dev->descriptor.idProduct) == 0xbadd))
-		return 0;
-
-	/* NOTE: can't use usb_match_id() since interface caches
-	 * aren't set up yet. this is cut/paste from that code.
-	 */
-	for (id = whitelist_table; id->match_flags; id++) {
-		if ((id->match_flags & USB_DEVICE_ID_MATCH_VENDOR) &&
-		    id->idVendor != le16_to_cpu(dev->descriptor.idVendor))
-			continue;
-
-		if ((id->match_flags & USB_DEVICE_ID_MATCH_PRODUCT) &&
-		    id->idProduct != le16_to_cpu(dev->descriptor.idProduct))
-			continue;
-
-		/* No need to test id->bcdDevice_lo != 0, since 0 is never
-		   greater than any unsigned number. */
-		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_LO) &&
-		    (id->bcdDevice_lo > le16_to_cpu(dev->descriptor.bcdDevice)))
-			continue;
-
-		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_HI) &&
-		    (id->bcdDevice_hi < le16_to_cpu(dev->descriptor.bcdDevice)))
-			continue;
-
-		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_CLASS) &&
-		    (id->bDeviceClass != dev->descriptor.bDeviceClass))
-			continue;
-
-		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_SUBCLASS) &&
-		    (id->bDeviceSubClass!= dev->descriptor.bDeviceSubClass))
-			continue;
-
-		if ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_PROTOCOL) &&
-		    (id->bDeviceProtocol != dev->descriptor.bDeviceProtocol))
-			continue;
-
-		return 1;
-	}
-
-	/* add other match criteria here ... */
-
-
-	/* OTG MESSAGE: report errors here, customize to match your product */
-	dev_err(&dev->dev, "device v%04x p%04x is not supported\n",
-		le16_to_cpu(dev->descriptor.idVendor),
-		le16_to_cpu(dev->descriptor.idProduct));
-#ifdef	CONFIG_USB_OTG_WHITELIST
-	return 0;
-#else
-	return 1;
-#endif
-}
-
diff -ruN linux-omap-2.6/drivers/usb/core/quirks.c maemo_src/drivers/usb/core/quirks.c
--- linux-omap-2.6/drivers/usb/core/quirks.c	2011-02-06 19:45:01.313333272 -0500
+++ maemo_src/drivers/usb/core/quirks.c	2011-02-06 20:12:11.196666607 -0500
@@ -34,6 +34,12 @@
 	{ USB_DEVICE(0x04b8, 0x011f), .driver_info = USB_QUIRK_NO_AUTOSUSPEND },
 	/* Elsa MicroLink 56k (V.250) */
 	{ USB_DEVICE(0x05cc, 0x2267), .driver_info = USB_QUIRK_NO_AUTOSUSPEND },
+	/* Nokia N810 Internet Tablet */
+	{ USB_DEVICE(0x0421, 0x0096), .driver_info = USB_QUIRK_NO_AUTOSUSPEND },
+	/* Nokia N800 Internet Tablet */
+	{ USB_DEVICE(0x0421, 0x04c3), .driver_info = USB_QUIRK_NO_AUTOSUSPEND },
+	/* Nokia 770 Internet Tablet */
+	{ USB_DEVICE(0x0421, 0x0431), .driver_info = USB_QUIRK_NO_AUTOSUSPEND },
 
 	{ }  /* terminating entry must be last */
 };
@@ -75,4 +81,16 @@
 	/* do any special quirk handling here if needed */
 	if (udev->quirks & USB_QUIRK_NO_AUTOSUSPEND)
 		usb_autosuspend_quirk(udev);
+
+#ifdef	CONFIG_USB_SUSPEND
+#ifdef	CONFIG_USB_OTG
+	/* By default, disable autosuspend for all mass storage devices */
+	if (udev->descriptor.bDeviceClass == USB_CLASS_MASS_STORAGE)
+		udev->autosuspend_delay = -1;
+#else
+	/* By default, disable autosuspend for all non-hubs */
+	if (udev->descriptor.bDeviceClass != USB_CLASS_HUB)
+		udev->autosuspend_delay = -1;
+#endif
+#endif
 }
diff -ruN linux-omap-2.6/drivers/usb/core/sysfs.c maemo_src/drivers/usb/core/sysfs.c
--- linux-omap-2.6/drivers/usb/core/sysfs.c	2011-02-06 19:45:01.316666606 -0500
+++ maemo_src/drivers/usb/core/sysfs.c	2011-02-06 20:12:11.176666605 -0500
@@ -12,6 +12,7 @@
 
 #include <linux/kernel.h>
 #include <linux/usb.h>
+#include <linux/usb/otg.h>
 #include "usb.h"
 
 /* Active configuration fields */
@@ -90,6 +91,135 @@
 usb_string_attr(manufacturer);
 usb_string_attr(serial);
 
+#ifdef CONFIG_USB_OTG
+
+static ssize_t
+otg_last_error_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct otg_transceiver	*xceiv = otg_get_transceiver();
+	char			*msg;
+	ssize_t			ret;
+
+	if (!xceiv)
+		return -ENODEV;
+
+	switch (xceiv->last_error) {
+	case OTG_ERR_DEVICE_SUPPORTED:
+		msg = "Device is supported";
+		break;
+	case OTG_ERR_DEVICE_NOT_SUPPORTED:
+		msg = "Device is not supported";
+		break;
+	case OTG_ERR_DEVICE_NOT_RESPONDING:
+		msg = "Device is not responding";
+		break;
+	case OTG_ERR_HUB_NOT_SUPPORTED:
+		msg = "Hub is not supported";
+		break;
+	default:
+		msg = "Unknown error";
+	}
+
+	ret = sprintf(buf, "OTG%02d: %s\n", xceiv->last_error, msg);
+	put_device(xceiv->dev);
+
+	return ret;
+}
+static DEVICE_ATTR(otg_last_error, 0444, otg_last_error_show, NULL);
+
+#ifdef CONFIG_USB_OTG_WHITELIST
+
+static ssize_t
+otg_whitelist_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return otg_print_whitelist(buf);
+}
+static DEVICE_ATTR(otg_whitelist, 0644, otg_whitelist_show, NULL);
+
+static ssize_t
+otg_whitelist_status_store(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t n)
+{
+	struct otg_transceiver	*xceiv = otg_get_transceiver();
+	int			enable;
+
+	sscanf(buf, "%d", &enable);
+	if (!xceiv)
+		return 0;
+	if (enable)
+		xceiv->tpl_enabled = 1;
+	else
+		xceiv->tpl_enabled = 0;
+	put_device(xceiv->dev);
+
+	return n;
+}
+
+static ssize_t
+otg_whitelist_status_show(struct device *dev, struct device_attribute *attr,
+				char *buf)
+{
+	struct otg_transceiver	*xceiv = otg_get_transceiver();
+	int			ret;
+
+	if (!xceiv)
+		return -ENODEV;
+
+	if (xceiv->tpl_enabled)
+		ret = sprintf(buf, "enabled\n");
+	else
+		ret = sprintf(buf, "disabled\n");
+	put_device(xceiv->dev);
+
+	return ret;
+}
+static DEVICE_ATTR(otg_whitelist_status, 0644, otg_whitelist_status_show,
+			otg_whitelist_status_store);
+
+#endif	/* CONFIG_USB_OTG_WHITELIST */
+
+static struct attribute *otg_dev_attrs[] = {
+	&dev_attr_otg_last_error.attr,
+
+#ifdef	CONFIG_USB_OTG_WHITELIST
+	&dev_attr_otg_whitelist.attr,
+	&dev_attr_otg_whitelist_status.attr,
+#endif
+
+};
+
+static int add_otg_attributes(struct device *dev)
+{
+	struct usb_device	*udev = to_usb_device(dev);
+	struct usb_bus		*bus = udev->bus;
+	int			ret = 0, i;
+
+	if (is_usb_device(dev) && !udev->parent && bus->otg_port)
+		for (i = 0; i < ARRAY_SIZE(otg_dev_attrs); i++) {
+			ret = sysfs_create_file(&dev->kobj, otg_dev_attrs[i]);
+			if (ret != 0)
+				return ret;
+		}
+
+	return ret;
+}
+
+static void remove_otg_attributes(struct device *dev)
+{
+	struct usb_device	*udev = to_usb_device(dev);
+	struct usb_bus		*bus = udev->bus;
+	int			i;
+
+	if (is_usb_device(dev) && !udev->parent && bus->otg_port)
+		for (i = 0; i < ARRAY_SIZE(otg_dev_attrs); i++)
+			sysfs_remove_file(&dev->kobj, otg_dev_attrs[i]);
+}
+
+#else
+#define add_otg_attributes(x)		0
+#define remove_otg_attributes(x)	do {} while (0)
+#endif /* CONFIG_USB_OTG */
+
 static ssize_t
 show_speed(struct device *dev, struct device_attribute *attr, char *buf)
 {
@@ -308,6 +438,9 @@
 		if (retval)
 			goto error;
 	}
+	retval = add_otg_attributes(dev);
+	if (retval)
+		goto error;
 	retval = usb_create_ep_files(dev, &udev->ep0, udev);
 	if (retval)
 		goto error;
@@ -326,6 +459,7 @@
 	device_remove_file(dev, &dev_attr_product);
 	device_remove_file(dev, &dev_attr_serial);
 	remove_power_attributes(dev);
+	remove_otg_attributes(dev);
 	sysfs_remove_group(&dev->kobj, &dev_attr_grp);
 }
 
diff -ruN linux-omap-2.6/drivers/usb/gadget/ether.c maemo_src/drivers/usb/gadget/ether.c
--- linux-omap-2.6/drivers/usb/gadget/ether.c	2011-02-06 19:45:01.326666606 -0500
+++ maemo_src/drivers/usb/gadget/ether.c	2007-10-02 03:09:32.000000000 -0400
@@ -23,6 +23,8 @@
 // #define DEBUG 1
 // #define VERBOSE
 
+#define NET_IP_ALIGN 0
+
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/delay.h>
diff -ruN linux-omap-2.6/drivers/usb/gadget/file_storage.c maemo_src/drivers/usb/gadget/file_storage.c
--- linux-omap-2.6/drivers/usb/gadget/file_storage.c	2011-02-06 19:45:01.329999939 -0500
+++ maemo_src/drivers/usb/gadget/file_storage.c	2011-02-06 20:12:11.223333274 -0500
@@ -258,6 +258,9 @@
 
 #include "gadget_chips.h"
 
+#ifdef CONFIG_ARM
+#include <asm/mach-types.h>
+#endif
 
 /*-------------------------------------------------------------------------*/
 
@@ -268,6 +271,12 @@
 static const char longname[] = DRIVER_DESC;
 static const char shortname[] = DRIVER_NAME;
 
+static const char manufacturer_nokia[] = "Nokia";
+static const char longname_770[] = "Nokia 770";
+static const char longname_n800[] = "Nokia N800 Internet Tablet";
+static const char longname_n810[] = "Nokia N810 Internet Tablet";
+static const char longname_n810_wimax[] = "Nokia N810 Internet Tablet WiMAX Edition";
+
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_AUTHOR("Alan Stern");
 MODULE_LICENSE("Dual BSD/GPL");
@@ -1074,7 +1083,7 @@
 		function = fs_function;
 
 	/* for now, don't advertise srp-only devices */
-	if (!gadget->is_otg)
+	if (machine_is_nokia_n800() || !gadget->is_otg)
 		function++;
 
 	len = usb_gadget_config_buf(&config_desc, buf, EP0_BUFSIZE, function);
@@ -1443,7 +1452,9 @@
 			/* Raise an exception to wipe out previous transaction
 			 * state (queued bufs, etc) and set the new config. */
 			raise_exception(fsg, FSG_STATE_CONFIG_CHANGE);
-			value = DELAYED_STATUS;
+
+			/* OPT FS/HS B tests can fail if using DELAYED_STATUS */
+			value = 1;
 		}
 		break;
 	case USB_REQ_GET_CONFIGURATION:
@@ -2062,6 +2073,17 @@
 	static char vendor_id[] = "Linux   ";
 	static char product_id[] = "File-Stor Gadget";
 
+#if defined(CONFIG_MACH_NOKIA770) || defined(CONFIG_MACH_NOKIA_N800)	\
+		|| defined(CONFIG_MACH_NOKIA_RX44)
+	sprintf(vendor_id, "Nokia   ");
+	if (machine_is_nokia770())
+		sprintf(product_id, "770             ");
+	else if (machine_is_nokia_n800())
+		sprintf(product_id, "N800             ");
+	else
+		sprintf(product_id, "N810             ");
+#endif
+
 	if (!fsg->curlun) {		// Unsupported LUNs are okay
 		fsg->bad_lun_okay = 1;
 		memset(buf, 0, 36);
@@ -3940,10 +3962,38 @@
 		fsg->intr_in = ep;
 	}
 
-	/* Fix up the descriptors */
-	device_desc.bMaxPacketSize0 = fsg->ep0->maxpacket;
+#if defined(CONFIG_MACH_NOKIA770) || defined(CONFIG_MACH_NOKIA_N800)	\
+		|| defined(CONFIG_MACH_NOKIA_RX44)
+	/* REVISIT: Get configuration from platform_data in board-*.c files */
+	strings[0].s		= manufacturer_nokia;
+	if (machine_is_nokia770()) {
+		strings[1].s		= longname_770;
+		device_desc.idVendor	= 0x0421;	/* Nokia */
+		device_desc.idProduct	= 0x0431;	/* 770 */
+		config_desc.bMaxPower	= 1;		/* Self powered */
+	} else if (machine_is_nokia_n800()) {
+		strings[1].s		= longname_n800;
+		device_desc.idVendor	= 0x0421;	/* Nokia */
+		device_desc.idProduct	= 0x04c3;	/* N800 */
+		config_desc.bMaxPower	= 25;
+	} else if (machine_is_nokia_rx44()) {
+		strings[1].s		= longname_n810;
+		device_desc.idVendor	= 0x0421;	/* Nokia */
+		device_desc.idProduct	= 0x0096;	/* RX-44 */
+		config_desc.bMaxPower	= 25;
+	} else {
+		strings[1].s		= longname_n810_wimax;
+		device_desc.idVendor	= 0x0421;	/* Nokia */
+		device_desc.idProduct	= 0x0189;	/* RX-48 */
+		config_desc.bMaxPower	= 25;
+	}
+#else
+
 	device_desc.idVendor = cpu_to_le16(mod_data.vendor);
 	device_desc.idProduct = cpu_to_le16(mod_data.product);
+#endif
+	/* Fix up the descriptors */
+	device_desc.bMaxPacketSize0 = fsg->ep0->maxpacket;
 	device_desc.bcdDevice = cpu_to_le16(mod_data.release);
 
 	i = (transport_is_cbi() ? 3 : 2);	// Number of endpoints
@@ -3965,8 +4015,7 @@
 #endif
 
 	if (gadget->is_otg) {
-		otg_desc.bmAttributes |= USB_OTG_HNP,
-		config_desc.bmAttributes |= USB_CONFIG_ATT_WAKEUP;
+		otg_desc.bmAttributes |= USB_OTG_HNP;
 	}
 
 	rc = -ENOMEM;
diff -ruN linux-omap-2.6/drivers/usb/gadget/inode.c maemo_src/drivers/usb/gadget/inode.c
--- linux-omap-2.6/drivers/usb/gadget/inode.c	2011-02-06 19:45:01.336666605 -0500
+++ maemo_src/drivers/usb/gadget/inode.c	2007-10-02 03:09:32.000000000 -0400
@@ -118,25 +118,32 @@
 /* enough for the whole queue: most events invalidate others */
 #define	N_EVENT			5
 
+struct kusb_gadgetfs_event {
+	struct usb_gadgetfs_event	event;
+	struct usb_request		*req;
+	struct list_head		list;
+	unsigned			setup_in : 1,
+					setup_out_ready : 1,
+					setup_out_error : 1;
+	unsigned			setup_wLength;
+};
+
 struct dev_data {
 	spinlock_t			lock;
 	atomic_t			count;
 	enum ep0_state			state;		/* P: lock */
-	struct usb_gadgetfs_event	event [N_EVENT];
 	unsigned			ev_next;
 	struct fasync_struct		*fasync;
 	u8				current_config;
 
+	struct list_head		events;
+
 	/* drivers reading ep0 MUST handle control requests (SETUP)
 	 * reported that way; else the host will time out.
 	 */
 	unsigned			usermode_setup : 1,
-					setup_in : 1,
 					setup_can_stall : 1,
-					setup_out_ready : 1,
-					setup_out_error : 1,
 					setup_abort : 1;
-	unsigned			setup_wLength;
 
 	/* the rest is basically write-once */
 	struct usb_config_descriptor	*config, *hs_config;
@@ -178,6 +185,7 @@
 	atomic_set (&dev->count, 1);
 	spin_lock_init (&dev->lock);
 	INIT_LIST_HEAD (&dev->epfiles);
+	INIT_LIST_HEAD (&dev->events);
 	init_waitqueue_head (&dev->wait);
 	return dev;
 }
@@ -912,62 +920,177 @@
  * use this facility may be too simple-minded for real applications.
  */
 
+static struct kusb_gadgetfs_event *
+get_event (struct dev_data *dev, enum usb_gadgetfs_event_type type)
+{
+	struct kusb_gadgetfs_event	*event;
+
+	event = kmalloc (sizeof (*event), GFP_KERNEL);
+	if (!event)
+		return NULL;
+	memset (event, 0, sizeof *event);
+	/* preallocate control response and buffer */
+	event->req = usb_ep_alloc_request (dev->gadget->ep0, GFP_KERNEL);
+	if (!event->req) {
+		kfree (event);
+		return NULL;
+	}
+	event->req->context = NULL;
+	event->req->complete = epio_complete;
+	INIT_LIST_HEAD (&event->list);
+	event->event.type = type;
+	return event;
+}
+
+static int put_event (struct dev_data *dev, struct kusb_gadgetfs_event *event)
+{
+	struct usb_request	*req = event->req;
+	
+	if (event->req->buf && event->req->buf != dev->rbuf)
+		usb_ep_free_buffer (dev->gadget->ep0,
+				    req->buf,
+				    req->dma,
+				    req->length);
+	usb_ep_free_request (dev->gadget->ep0, event->req);
+	kfree (event);
+	return 0;
+}
+
+static struct kusb_gadgetfs_event *
+fetch_event (struct dev_data *dev)
+{
+	if (!list_empty (&dev->events))
+		return list_entry (dev->events.next,
+				   struct kusb_gadgetfs_event,
+				   list);
+	return NULL;
+}
+
+static int push_event (struct dev_data *dev, struct kusb_gadgetfs_event *event)
+{
+	list_add_tail (&event->list, &dev->events);
+	dev->ev_next = 1;
+	return 0;
+}
+
+static struct kusb_gadgetfs_event *
+pop_event (struct dev_data *dev)
+{
+	struct kusb_gadgetfs_event *event = fetch_event (dev);
+
+	if (!event)
+		return NULL;
+	if (list_is_last (&event->list, &dev->events))
+		dev->ev_next = 0;
+	list_del (&event->list);
+	return event;
+}
+
+static int clear_events (struct dev_data *dev)
+{
+	struct kusb_gadgetfs_event	*event;
+
+	while ((event = pop_event (dev)) != NULL)
+		put_event (dev, event);
+	return 0;
+}
+
+static struct kusb_gadgetfs_event *
+next_event (struct dev_data *dev, enum usb_gadgetfs_event_type type)
+{
+	struct kusb_gadgetfs_event	*event;
+
+	switch (type) {
+	/* these events purge the queue */
+	case GADGETFS_DISCONNECT:
+		if (dev->state == STATE_DEV_SETUP)
+			dev->setup_abort = 1;
+		// FALL THROUGH
+	case GADGETFS_CONNECT:
+		clear_events (dev);
+		break;
+	case GADGETFS_SETUP:
+	case GADGETFS_SUSPEND:
+		break;
+	default:
+		BUG ();
+	}
+	VDEBUG(dev, "event = %d\n", type);
+	event = get_event (dev, type);
+
+	if (event == NULL) {
+		DBG (dev, "%s enomem\n", __FUNCTION__);
+	} else {
+		push_event (dev, event);
+	}
+
+	return event;
+}
+
 static inline void ep0_readable (struct dev_data *dev)
 {
 	wake_up (&dev->wait);
 	kill_fasync (&dev->fasync, SIGIO, POLL_IN);
 }
 
-static void clean_req (struct usb_ep *ep, struct usb_request *req)
+static void clean_req (struct usb_ep *ep, struct kusb_gadgetfs_event *event)
 {
 	struct dev_data		*dev = ep->driver_data;
+	struct usb_request	*req = event->req;
 
-	if (req->buf != dev->rbuf) {
+	if (req->buf && req->buf != dev->rbuf) {
 		usb_ep_free_buffer (ep, req->buf, req->dma, req->length);
-		req->buf = dev->rbuf;
+		req->buf = NULL;
 		req->dma = DMA_ADDR_INVALID;
 	}
-	req->complete = epio_complete;
-	dev->setup_out_ready = 0;
+
+	event->req->context = NULL;
+	event->req->complete = epio_complete;
+
+	event->setup_out_ready = 0;
 }
 
 static void ep0_complete (struct usb_ep *ep, struct usb_request *req)
 {
-	struct dev_data		*dev = ep->driver_data;
-	unsigned long		flags;
-	int			free = 1;
+	struct dev_data			*dev = ep->driver_data;
+	unsigned long			flags;
+	int				free = 1;
+	struct kusb_gadgetfs_event	*event;
 
 	/* for control OUT, data must still get to userspace */
 	spin_lock_irqsave(&dev->lock, flags);
-	if (!dev->setup_in) {
-		dev->setup_out_error = (req->status != 0);
-		if (!dev->setup_out_error)
+	event = (struct kusb_gadgetfs_event *)req->context;
+	if (!event->setup_in) {
+		event->setup_out_error = (req->status != 0);
+		if (!event->setup_out_error)
 			free = 0;
-		dev->setup_out_ready = 1;
+		event->setup_out_ready = 1;
 		ep0_readable (dev);
 	}
 
 	/* clean up as appropriate */
-	if (free && req->buf != &dev->rbuf)
-		clean_req (ep, req);
+	if (free && event)
+		put_event (dev, event);
 	req->complete = epio_complete;
 	spin_unlock_irqrestore(&dev->lock, flags);
 }
 
-static int setup_req (struct usb_ep *ep, struct usb_request *req, u16 len)
+static int
+setup_req (struct usb_ep *ep, struct kusb_gadgetfs_event *event, u16 len)
 {
-	struct dev_data	*dev = ep->driver_data;
+	struct usb_request *req = event->req;
 
-	if (dev->setup_out_ready) {
+	if (event->setup_out_ready) {
 		DBG (dev, "ep0 request busy!\n");
 		return -EBUSY;
 	}
-	if (len > sizeof (dev->rbuf))
-		req->buf = usb_ep_alloc_buffer (ep, len, &req->dma, GFP_ATOMIC);
+
+	req->buf = usb_ep_alloc_buffer (ep, len, &req->dma, GFP_ATOMIC);
 	if (req->buf == 0) {
-		req->buf = dev->rbuf;
+		usb_ep_free_request (ep, req);
 		return -ENOMEM;
 	}
+	req->context = event;
 	req->complete = ep0_complete;
 	req->length = len;
 	req->zero = 0;
@@ -980,31 +1103,42 @@
 	struct dev_data			*dev = fd->private_data;
 	ssize_t				retval;
 	enum ep0_state			state;
+	struct kusb_gadgetfs_event	*event;
 
 	spin_lock_irq (&dev->lock);
 
 	/* report fd mode change before acting on it */
+	event = fetch_event (dev);
 	if (dev->setup_abort) {
 		dev->setup_abort = 0;
+		if (event)
+			clear_events (dev);
 		retval = -EIDRM;
 		goto done;
 	}
 
-	/* control DATA stage */
-	if ((state = dev->state) == STATE_DEV_SETUP) {
+	state = dev->state;
+	if (event == NULL)
+		BUG();
 
-		if (dev->setup_in) {		/* stall IN */
+	/* control DATA stage */
+	if (state == STATE_DEV_SETUP) {
+		event = pop_event (dev);
+		if (event->setup_in) {		/* stall IN */
 			VDEBUG(dev, "ep0in stall\n");
 			(void) usb_ep_set_halt (dev->gadget->ep0);
 			retval = -EL2HLT;
 			dev->state = STATE_DEV_CONNECTED;
-
+			put_event (dev, event);
 		} else if (len == 0) {		/* ack SET_CONFIGURATION etc */
 			struct usb_ep		*ep = dev->gadget->ep0;
-			struct usb_request	*req = dev->req;
 
-			if ((retval = setup_req (ep, req, 0)) == 0)
-				retval = usb_ep_queue (ep, req, GFP_ATOMIC);
+			clean_req (dev->gadget->ep0, event);
+			retval = setup_req (ep, event, 0);
+			if (retval == 0)
+				retval = usb_ep_queue (ep,
+						       event->req,
+						       GFP_ATOMIC);
 			dev->state = STATE_DEV_CONNECTED;
 
 			/* assume that was SET_CONFIGURATION */
@@ -1020,42 +1154,48 @@
 			}
 
 		} else {			/* collect OUT data */
+			struct usb_request	*req = event->req;
+
 			if ((fd->f_flags & O_NONBLOCK) != 0
-					&& !dev->setup_out_ready) {
+					&& !event->setup_out_ready) {
 				retval = -EAGAIN;
 				goto done;
 			}
 			spin_unlock_irq (&dev->lock);
 			retval = wait_event_interruptible (dev->wait,
-					dev->setup_out_ready != 0);
+					event->setup_out_ready != 0);
 
 			/* FIXME state could change from under us */
 			spin_lock_irq (&dev->lock);
 			if (retval)
-				goto done;
+				goto out_done;
 
 			if (dev->state != STATE_DEV_SETUP) {
 				retval = -ECANCELED;
-				goto done;
+				goto out_done;
 			}
 			dev->state = STATE_DEV_CONNECTED;
 
-			if (dev->setup_out_error)
+			if (event->setup_out_error)
 				retval = -EIO;
 			else {
-				len = min (len, (size_t)dev->req->actual);
+				len = min (len, (size_t)req->actual);
 // FIXME don't call this with the spinlock held ...
-				if (copy_to_user (buf, dev->req->buf, len))
+				if (copy_to_user (buf, req->buf, len))
 					retval = -EFAULT;
-				clean_req (dev->gadget->ep0, dev->req);
+				else
+					retval = len;
 				/* NOTE userspace can't yet choose to stall */
 			}
+out_done:
+			put_event (dev, event);
+			goto done;
 		}
 		goto done;
 	}
 
 	/* else normal: return event data */
-	if (len < sizeof dev->event [0]) {
+	if (len < sizeof (struct usb_gadgetfs_event)) {
 		retval = -EINVAL;
 		goto done;
 	}
@@ -1064,40 +1204,25 @@
 
 scan:
 	/* return queued events right away */
-	if (dev->ev_next != 0) {
-		unsigned		i, n;
-
-		n = len / sizeof (struct usb_gadgetfs_event);
-		if (dev->ev_next < n)
-			n = dev->ev_next;
-
+	if (dev->ev_next != 0 && event != NULL) {
 		/* ep0 i/o has special semantics during STATE_DEV_SETUP */
-		for (i = 0; i < n; i++) {
-			if (dev->event [i].type == GADGETFS_SETUP) {
-				dev->state = STATE_DEV_SETUP;
-				n = i + 1;
-				break;
-			}
-		}
+		if (event->event.type == GADGETFS_SETUP)
+			dev->state = STATE_DEV_SETUP;
+
 		spin_unlock_irq (&dev->lock);
-		len = n * sizeof (struct usb_gadgetfs_event);
-		if (copy_to_user (buf, &dev->event, len))
+		len = sizeof (struct usb_gadgetfs_event);
+
+
+		if (copy_to_user (buf, event, len))
 			retval = -EFAULT;
 		else
 			retval = len;
-		if (len > 0) {
-			/* NOTE this doesn't guard against broken drivers;
-			 * concurrent ep0 readers may lose events.
-			 */
-			spin_lock_irq (&dev->lock);
-			if (dev->ev_next > n) {
-				memmove(&dev->event[0], &dev->event[n],
-					sizeof (struct usb_gadgetfs_event)
-						* (dev->ev_next - n));
-			}
-			dev->ev_next -= n;
-			spin_unlock_irq (&dev->lock);
+
+		if (event->event.type != GADGETFS_SETUP || retval < 0) {
+			event = pop_event (dev);
+			put_event (dev, event);
 		}
+
 		return retval;
 	}
 	if (fd->f_flags & O_NONBLOCK) {
@@ -1127,48 +1252,7 @@
 done:
 	spin_unlock_irq (&dev->lock);
 	return retval;
-}
 
-static struct usb_gadgetfs_event *
-next_event (struct dev_data *dev, enum usb_gadgetfs_event_type type)
-{
-	struct usb_gadgetfs_event	*event;
-	unsigned			i;
-
-	switch (type) {
-	/* these events purge the queue */
-	case GADGETFS_DISCONNECT:
-		if (dev->state == STATE_DEV_SETUP)
-			dev->setup_abort = 1;
-		// FALL THROUGH
-	case GADGETFS_CONNECT:
-		dev->ev_next = 0;
-		break;
-	case GADGETFS_SETUP:		/* previous request timed out */
-	case GADGETFS_SUSPEND:		/* same effect */
-		/* these events can't be repeated */
-		for (i = 0; i != dev->ev_next; i++) {
-			if (dev->event [i].type != type)
-				continue;
-			DBG(dev, "discard old event[%d] %d\n", i, type);
-			dev->ev_next--;
-			if (i == dev->ev_next)
-				break;
-			/* indices start at zero, for simplicity */
-			memmove (&dev->event [i], &dev->event [i + 1],
-				sizeof (struct usb_gadgetfs_event)
-					* (dev->ev_next - i));
-		}
-		break;
-	default:
-		BUG ();
-	}
-	VDEBUG(dev, "event[%d] = %d\n", dev->ev_next, type);
-	event = &dev->event [dev->ev_next++];
-	BUG_ON (dev->ev_next > N_EVENT);
-	memset (event, 0, sizeof *event);
-	event->type = type;
-	return event;
 }
 
 static ssize_t
@@ -1176,35 +1260,42 @@
 {
 	struct dev_data		*dev = fd->private_data;
 	ssize_t			retval = -ESRCH;
+	struct kusb_gadgetfs_event	*event;
+	struct usb_request *req = NULL;
 
 	spin_lock_irq (&dev->lock);
 
 	/* report fd mode change before acting on it */
+
+	event = fetch_event (dev);
 	if (dev->setup_abort) {
 		dev->setup_abort = 0;
+		if (event)
+			clear_events (dev);
 		retval = -EIDRM;
-
 	/* data and/or status stage for control request */
 	} else if (dev->state == STATE_DEV_SETUP) {
-
+		event = pop_event (dev);
 		/* IN DATA+STATUS caller makes len <= wLength */
-		if (dev->setup_in) {
-			retval = setup_req (dev->gadget->ep0, dev->req, len);
+		if (event->setup_in) {
+			retval = setup_req (dev->gadget->ep0, event, len);
 			if (retval == 0) {
+				req = event->req;
+
 				dev->state = STATE_DEV_CONNECTED;
 				spin_unlock_irq (&dev->lock);
-				if (copy_from_user (dev->req->buf, buf, len))
+				if (copy_from_user (req->buf, buf, len))
 					retval = -EFAULT;
 				else {
-					if (len < dev->setup_wLength)
-						dev->req->zero = 1;
+					if (len < event->setup_wLength)
+						req->zero = 1;
 					retval = usb_ep_queue (
-						dev->gadget->ep0, dev->req,
+						dev->gadget->ep0, req,
 						GFP_KERNEL);
 				}
 				if (retval < 0) {
 					spin_lock_irq (&dev->lock);
-					clean_req (dev->gadget->ep0, dev->req);
+					put_event (dev, event);
 					spin_unlock_irq (&dev->lock);
 				} else
 					retval = len;
@@ -1218,8 +1309,11 @@
 			(void) usb_ep_set_halt (dev->gadget->ep0);
 			retval = -EL2HLT;
 			dev->state = STATE_DEV_CONNECTED;
+			put_event (dev, event);
 		} else {
 			DBG(dev, "bogus ep0out stall!\n");
+			dev->state = STATE_DEV_CONNECTED;
+			put_event (dev, event);
 		}
 	} else
 		DBG (dev, "fail %s, state %d\n", __FUNCTION__, dev->state);
@@ -1259,17 +1353,18 @@
 	put_dev (dev);
 
 	/* other endpoints were all decoupled from this device */
-	spin_lock_irq(&dev->lock);
+	spin_lock_irq (&dev->lock);
 	dev->state = STATE_DEV_DISABLED;
-	spin_unlock_irq(&dev->lock);
+	spin_unlock_irq (&dev->lock);
 	return 0;
 }
 
 static unsigned int
 ep0_poll (struct file *fd, poll_table *wait)
 {
-       struct dev_data         *dev = fd->private_data;
-       int                     mask = 0;
+       struct dev_data			*dev = fd->private_data;
+       int				mask = 0;
+       struct kusb_gadgetfs_event	*event;
 
        poll_wait(fd, &dev->wait, wait);
 
@@ -1283,7 +1378,8 @@
        }
 
        if (dev->state == STATE_DEV_SETUP) {
-               if (dev->setup_in || dev->setup_can_stall)
+	       event = fetch_event (dev);
+               if (event->setup_in || dev->setup_can_stall)
                        mask = POLLOUT;
        } else {
                if (dev->ev_next != 0)
@@ -1386,7 +1482,7 @@
 	struct dev_data			*dev = get_gadget_data (gadget);
 	struct usb_request		*req = dev->req;
 	int				value = -EOPNOTSUPP;
-	struct usb_gadgetfs_event	*event;
+	struct kusb_gadgetfs_event	*event;
 	u16				w_value = le16_to_cpu(ctrl->wValue);
 	u16				w_length = le16_to_cpu(ctrl->wLength);
 
@@ -1406,7 +1502,7 @@
 
 		INFO (dev, "connected\n");
 		event = next_event (dev, GADGETFS_CONNECT);
-		event->u.speed = gadget->speed;
+		event->event.u.speed = gadget->speed;
 		ep0_readable (dev);
 
 	/* host may have given up waiting for response.  we can miss control
@@ -1414,8 +1510,7 @@
 	 * then ep0_{read,write} will report the wrong status. controller
 	 * driver will have aborted pending i/o.
 	 */
-	} else if (dev->state == STATE_DEV_SETUP)
-		dev->setup_abort = 1;
+	}
 
 	req->buf = dev->rbuf;
 	req->dma = DMA_ADDR_INVALID;
@@ -1526,23 +1621,27 @@
 		if (dev->usermode_setup) {
 			dev->setup_can_stall = 1;
 delegate:
-			dev->setup_in = (ctrl->bRequestType & USB_DIR_IN)
+			event = get_event (dev, GADGETFS_SETUP);
+			if (!event)
+				return -ENOMEM;
+
+			event->setup_in = (ctrl->bRequestType & USB_DIR_IN)
 						? 1 : 0;
-			dev->setup_wLength = w_length;
-			dev->setup_out_ready = 0;
-			dev->setup_out_error = 0;
+			event->setup_wLength = w_length;
+			event->setup_out_ready = 0;
+			event->setup_out_error = 0;
 			value = 0;
 
 			/* read DATA stage for OUT right away */
-			if (unlikely (!dev->setup_in && w_length)) {
-				value = setup_req (gadget->ep0, dev->req,
+			if (unlikely (!event->setup_in && w_length)) {
+				value = setup_req (gadget->ep0, event,
 							w_length);
 				if (value < 0)
 					break;
-				value = usb_ep_queue (gadget->ep0, dev->req,
+				value = usb_ep_queue (gadget->ep0, event->req,
 							GFP_ATOMIC);
 				if (value < 0) {
-					clean_req (gadget->ep0, dev->req);
+					put_event (dev, event);
 					break;
 				}
 
@@ -1551,8 +1650,8 @@
 			}
 
 			/* state changes when reader collects event */
-			event = next_event (dev, GADGETFS_SETUP);
-			event->u.setup = *ctrl;
+			event->event.u.setup = *ctrl;
+			push_event (dev, event);
 			ep0_readable (dev);
 			spin_unlock (&dev->lock);
 			return 0;
@@ -1739,6 +1838,7 @@
 gadgetfs_disconnect (struct usb_gadget *gadget)
 {
 	struct dev_data		*dev = get_gadget_data (gadget);
+	struct kusb_gadgetfs_event *event;
 
 	spin_lock (&dev->lock);
 	if (dev->state == STATE_DEV_UNCONNECTED)
@@ -1746,7 +1846,7 @@
 	dev->state = STATE_DEV_UNCONNECTED;
 
 	INFO (dev, "disconnected\n");
-	next_event (dev, GADGETFS_DISCONNECT);
+	event = next_event (dev, GADGETFS_DISCONNECT);
 	ep0_readable (dev);
 exit:
 	spin_unlock (&dev->lock);
@@ -1952,6 +2052,7 @@
 	spin_lock_irq(&dev->lock);
 	if (dev->state == STATE_DEV_DISABLED) {
 		dev->ev_next = 0;
+		clear_events (dev);
 		dev->state = STATE_DEV_OPENED;
 		fd->private_data = dev;
 		get_dev (dev);
diff -ruN linux-omap-2.6/drivers/usb/misc/sisusbvga/Kconfig maemo_src/drivers/usb/misc/sisusbvga/Kconfig
--- linux-omap-2.6/drivers/usb/misc/sisusbvga/Kconfig	2011-02-06 19:45:01.909999939 -0500
+++ maemo_src/drivers/usb/misc/sisusbvga/Kconfig	2011-02-06 20:12:11.216666606 -0500
@@ -1,7 +1,7 @@
 
 config USB_SISUSBVGA
 	tristate "USB 2.0 SVGA dongle support (Net2280/SiS315)"
-	depends on USB && USB_EHCI_HCD
+	depends on USB
         ---help---
 	  Say Y here if you intend to attach a USB2VGA dongle based on a
 	  Net2280 and a SiS315 chip.
diff -ruN linux-omap-2.6/drivers/usb/misc/sisusbvga/sisusb.c maemo_src/drivers/usb/misc/sisusbvga/sisusb.c
--- linux-omap-2.6/drivers/usb/misc/sisusbvga/sisusb.c	2011-02-06 19:45:01.909999939 -0500
+++ maemo_src/drivers/usb/misc/sisusbvga/sisusb.c	2011-02-06 20:12:11.216666606 -0500
@@ -3432,6 +3432,7 @@
 }
 
 static struct usb_device_id sisusb_table [] = {
+	{ USB_DEVICE(0x0711, 0x0550) },
 	{ USB_DEVICE(0x0711, 0x0900) },
 	{ USB_DEVICE(0x0711, 0x0901) },
 	{ USB_DEVICE(0x0711, 0x0902) },
diff -ruN linux-omap-2.6/drivers/usb/musb/cppi_dma.c maemo_src/drivers/usb/musb/cppi_dma.c
--- linux-omap-2.6/drivers/usb/musb/cppi_dma.c	2011-02-06 20:17:25.833333273 -0500
+++ maemo_src/drivers/usb/musb/cppi_dma.c	2011-02-06 20:12:11.259999940 -0500
@@ -3,23 +3,23 @@
  *
  * This file implements a DMA  interface using TI's CPPI DMA.
  * For now it's DaVinci-only, but CPPI isn't specific to DaVinci or USB.
- * TUSB 6010 over VLYNQ has CPPI that looks much like DaVinci.
+ * The TUSB6020, using VLYNQ, has CPPI that looks much like DaVinci.
  */
 
 #include <linux/usb.h>
 
-#include "musbdefs.h"
+#include "musb_core.h"
 #include "cppi_dma.h"
 
 
-/* CPPI DMA status 7-mar:
+/* CPPI DMA status 7-mar-2006:
  *
  * - See musb_{host,gadget}.c for more info
  *
  * - Correct RX DMA generally forces the engine into irq-per-packet mode,
  *   which can easily saturate the CPU under non-mass-storage loads.
  *
- * NOTES 24-aug (2.6.18-rc4):
+ * NOTES 24-aug-2006 (2.6.18-rc4):
  *
  * - peripheral RXDMA wedged in a test with packets of length 512/512/1.
  *   evidently after the 1 byte packet was received and acked, the queue
@@ -52,13 +52,12 @@
 #endif
 }
 
-static inline struct cppi_descriptor *
-cppi_bd_alloc(struct cppi_channel *c)
+static inline struct cppi_descriptor *cppi_bd_alloc(struct cppi_channel *c)
 {
-	struct cppi_descriptor	*bd = c->bdPoolHead;
+	struct cppi_descriptor	*bd = c->freelist;
 
 	if (bd)
-		c->bdPoolHead = bd->next;
+		c->freelist = bd->next;
 	return bd;
 }
 
@@ -67,28 +66,39 @@
 {
 	if (!bd)
 		return;
-	bd->next = c->bdPoolHead;
-	c->bdPoolHead = bd;
+	bd->next = c->freelist;
+	c->freelist = bd;
 }
 
 /*
- *  Start Dma controller
+ *  Start DMA controller
  *
- *  Initialize the Dma Controller as necessary.
+ *  Initialize the DMA controller as necessary.
  */
 
-#define	CAST (void *__force __iomem)
-
 /* zero out entire rx state RAM entry for the channel */
-static void cppi_reset_rx(struct cppi_rx_stateram *__iomem rx)
+static void cppi_reset_rx(struct cppi_rx_stateram __iomem *rx)
 {
-	musb_writel(CAST &rx->buffOffset, 0, 0);
-	musb_writel(CAST &rx->headPtr, 0, 0);
-	musb_writel(CAST &rx->sopDescPtr, 0, 0);
-	musb_writel(CAST &rx->currDescPtr, 0, 0);
-	musb_writel(CAST &rx->currBuffPtr, 0, 0);
-	musb_writel(CAST &rx->pktLength, 0, 0);
-	musb_writel(CAST &rx->byteCount, 0, 0);
+	musb_writel(&rx->rx_skipbytes, 0, 0);
+	musb_writel(&rx->rx_head, 0, 0);
+	musb_writel(&rx->rx_sop, 0, 0);
+	musb_writel(&rx->rx_current, 0, 0);
+	musb_writel(&rx->rx_buf_current, 0, 0);
+	musb_writel(&rx->rx_len_len, 0, 0);
+	musb_writel(&rx->rx_cnt_cnt, 0, 0);
+}
+
+/* zero out entire tx state RAM entry for the channel */
+static void cppi_reset_tx(struct cppi_tx_stateram __iomem *tx, u32 ptr)
+{
+	musb_writel(&tx->tx_head, 0, 0);
+	musb_writel(&tx->tx_buf, 0, 0);
+	musb_writel(&tx->tx_current, 0, 0);
+	musb_writel(&tx->tx_buf_current, 0, 0);
+	musb_writel(&tx->tx_info, 0, 0);
+	musb_writel(&tx->tx_rem_len, 0, 0);
+	/* musb_writel(&tx->tx_dummy, 0, 0); */
+	musb_writel(&tx->tx_complete, 0, ptr);
 }
 
 static void __init cppi_pool_init(struct cppi *cppi, struct cppi_channel *c)
@@ -96,14 +106,13 @@
 	int	j;
 
 	/* initialize channel fields */
-	c->activeQueueHead = NULL;
-	c->activeQueueTail = NULL;
-	c->lastHwBDProcessed = NULL;
-	c->Channel.bStatus = MGC_DMA_STATUS_UNKNOWN;
-	c->pController = cppi;
-	c->bLastModeRndis = 0;
-	c->Channel.pPrivateData = c;
-	c->bdPoolHead = NULL;
+	c->head = NULL;
+	c->tail = NULL;
+	c->last_processed = NULL;
+	c->channel.status = MUSB_DMA_STATUS_UNKNOWN;
+	c->controller = cppi;
+	c->is_rndis = 0;
+	c->freelist = NULL;
 
 	/* build the BD Free list for the channel */
 	for (j = 0; j < NUM_TXCHAN_BD + 1; j++) {
@@ -120,137 +129,126 @@
 
 static void cppi_pool_free(struct cppi_channel *c)
 {
-	struct cppi		*cppi = c->pController;
+	struct cppi		*cppi = c->controller;
 	struct cppi_descriptor	*bd;
 
-	(void) cppi_channel_abort(&c->Channel);
-	c->Channel.bStatus = MGC_DMA_STATUS_UNKNOWN;
-	c->pController = NULL;
+	(void) cppi_channel_abort(&c->channel);
+	c->channel.status = MUSB_DMA_STATUS_UNKNOWN;
+	c->controller = NULL;
 
 	/* free all its bds */
-	bd = c->lastHwBDProcessed;
+	bd = c->last_processed;
 	do {
 		if (bd)
 			dma_pool_free(cppi->pool, bd, bd->dma);
 		bd = cppi_bd_alloc(c);
 	} while (bd);
-	c->lastHwBDProcessed = NULL;
+	c->last_processed = NULL;
 }
 
 static int __init cppi_controller_start(struct dma_controller *c)
 {
-	struct cppi	*pController;
-	void		*__iomem regBase;
+	struct cppi	*controller;
+	void __iomem	*tibase;
 	int		i;
 
-	pController = container_of(c, struct cppi, Controller);
+	controller = container_of(c, struct cppi, controller);
 
 	/* do whatever is necessary to start controller */
-	for (i = 0; i < ARRAY_SIZE(pController->txCppi); i++) {
-		pController->txCppi[i].bTransmit = TRUE;
-		pController->txCppi[i].chNo = i;
-	}
-	for (i = 0; i < ARRAY_SIZE(pController->rxCppi); i++) {
-		pController->rxCppi[i].bTransmit = FALSE;
-		pController->rxCppi[i].chNo = i;
+	for (i = 0; i < ARRAY_SIZE(controller->tx); i++) {
+		controller->tx[i].transmit = true;
+		controller->tx[i].index = i;
+	}
+	for (i = 0; i < ARRAY_SIZE(controller->rx); i++) {
+		controller->rx[i].transmit = false;
+		controller->rx[i].index = i;
 	}
 
 	/* setup BD list on a per channel basis */
-	for (i = 0; i < ARRAY_SIZE(pController->txCppi); i++)
-		cppi_pool_init(pController, pController->txCppi + i);
-	for (i = 0; i < ARRAY_SIZE(pController->rxCppi); i++)
-		cppi_pool_init(pController, pController->rxCppi + i);
-
-	/* Do Necessary configuartion in H/w to get started */
-	regBase =  pController->pCoreBase - DAVINCI_BASE_OFFSET;
+	for (i = 0; i < ARRAY_SIZE(controller->tx); i++)
+		cppi_pool_init(controller, controller->tx + i);
+	for (i = 0; i < ARRAY_SIZE(controller->rx); i++)
+		cppi_pool_init(controller, controller->rx + i);
 
-	INIT_LIST_HEAD(&pController->tx_complete);
+	tibase =  controller->tibase;
+	INIT_LIST_HEAD(&controller->tx_complete);
 
 	/* initialise tx/rx channel head pointers to zero */
-	for (i = 0; i < ARRAY_SIZE(pController->txCppi); i++) {
-		struct cppi_channel	*txChannel = pController->txCppi + i;
-		struct cppi_tx_stateram *__iomem txState;
-
-		INIT_LIST_HEAD(&txChannel->tx_complete);
-
-		txState = regBase + DAVINCI_TXCPPI_STATERAM_OFFSET(i);
-		txChannel->stateRam = txState;
-		/* zero out entire state RAM entry for the channel */
-		txState->headPtr = 0;
-		txState->sopDescPtr = 0;
-		txState->currDescPtr = 0;
-		txState->currBuffPtr = 0;
-		txState->flags = 0;
-		txState->remLength = 0;
-		/*txState->dummy = 0; */
-		txState->completionPtr = 0;
-
-	}
-	for (i = 0; i < ARRAY_SIZE(pController->rxCppi); i++) {
-		struct cppi_channel	*rxChannel = pController->rxCppi + i;
-		struct cppi_rx_stateram *__iomem rxState;
-
-		INIT_LIST_HEAD(&rxChannel->tx_complete);
-
-		rxState = regBase + DAVINCI_RXCPPI_STATERAM_OFFSET(i);
-		rxChannel->stateRam = rxState;
-		cppi_reset_rx(rxChannel->stateRam);
+	for (i = 0; i < ARRAY_SIZE(controller->tx); i++) {
+		struct cppi_channel	*tx_ch = controller->tx + i;
+		struct cppi_tx_stateram __iomem *tx;
+
+		INIT_LIST_HEAD(&tx_ch->tx_complete);
+
+		tx = tibase + DAVINCI_TXCPPI_STATERAM_OFFSET(i);
+		tx_ch->state_ram = tx;
+		cppi_reset_tx(tx, 0);
+	}
+	for (i = 0; i < ARRAY_SIZE(controller->rx); i++) {
+		struct cppi_channel	*rx_ch = controller->rx + i;
+		struct cppi_rx_stateram __iomem *rx;
+
+		INIT_LIST_HEAD(&rx_ch->tx_complete);
+
+		rx = tibase + DAVINCI_RXCPPI_STATERAM_OFFSET(i);
+		rx_ch->state_ram = rx;
+		cppi_reset_rx(rx);
 	}
 
 	/* enable individual cppi channels */
-	musb_writel(regBase, DAVINCI_TXCPPI_INTENAB_REG,
+	musb_writel(tibase, DAVINCI_TXCPPI_INTENAB_REG,
 			DAVINCI_DMA_ALL_CHANNELS_ENABLE);
-	musb_writel(regBase, DAVINCI_RXCPPI_INTENAB_REG,
+	musb_writel(tibase, DAVINCI_RXCPPI_INTENAB_REG,
 			DAVINCI_DMA_ALL_CHANNELS_ENABLE);
 
 	/* enable tx/rx CPPI control */
-	musb_writel(regBase, DAVINCI_TXCPPI_CTRL_REG, DAVINCI_DMA_CTRL_ENABLE);
-	musb_writel(regBase, DAVINCI_RXCPPI_CTRL_REG, DAVINCI_DMA_CTRL_ENABLE);
+	musb_writel(tibase, DAVINCI_TXCPPI_CTRL_REG, DAVINCI_DMA_CTRL_ENABLE);
+	musb_writel(tibase, DAVINCI_RXCPPI_CTRL_REG, DAVINCI_DMA_CTRL_ENABLE);
 
 	/* disable RNDIS mode, also host rx RNDIS autorequest */
-	musb_writel(regBase, DAVINCI_RNDIS_REG, 0);
-	musb_writel(regBase, DAVINCI_AUTOREQ_REG, 0);
+	musb_writel(tibase, DAVINCI_RNDIS_REG, 0);
+	musb_writel(tibase, DAVINCI_AUTOREQ_REG, 0);
 
 	return 0;
 }
 
 /*
- *  Stop Dma controller
+ *  Stop DMA controller
  *
- *  De-Init the Dma Controller as necessary.
+ *  De-Init the DMA controller as necessary.
  */
 
 static int cppi_controller_stop(struct dma_controller *c)
 {
-	struct cppi		*pController;
-	void __iomem		*regBase;
+	struct cppi		*controller;
+	void __iomem		*tibase;
 	int			i;
 
-	pController = container_of(c, struct cppi, Controller);
+	controller = container_of(c, struct cppi, controller);
 
-	regBase = pController->pCoreBase - DAVINCI_BASE_OFFSET;
+	tibase = controller->tibase;
 	/* DISABLE INDIVIDUAL CHANNEL Interrupts */
-	musb_writel(regBase, DAVINCI_TXCPPI_INTCLR_REG,
+	musb_writel(tibase, DAVINCI_TXCPPI_INTCLR_REG,
 			DAVINCI_DMA_ALL_CHANNELS_ENABLE);
-	musb_writel(regBase, DAVINCI_RXCPPI_INTCLR_REG,
+	musb_writel(tibase, DAVINCI_RXCPPI_INTCLR_REG,
 			DAVINCI_DMA_ALL_CHANNELS_ENABLE);
 
 	DBG(1, "Tearing down RX and TX Channels\n");
-	for (i = 0; i < ARRAY_SIZE(pController->txCppi); i++) {
+	for (i = 0; i < ARRAY_SIZE(controller->tx); i++) {
 		/* FIXME restructure of txdma to use bds like rxdma */
-		pController->txCppi[i].lastHwBDProcessed = NULL;
-		cppi_pool_free(pController->txCppi + i);
+		controller->tx[i].last_processed = NULL;
+		cppi_pool_free(controller->tx + i);
 	}
-	for (i = 0; i < ARRAY_SIZE(pController->rxCppi); i++)
-		cppi_pool_free(pController->rxCppi + i);
+	for (i = 0; i < ARRAY_SIZE(controller->rx); i++)
+		cppi_pool_free(controller->rx + i);
 
 	/* in Tx Case proper teardown is supported. We resort to disabling
 	 * Tx/Rx CPPI after cleanup of Tx channels. Before TX teardown is
 	 * complete TX CPPI cannot be disabled.
 	 */
 	/*disable tx/rx cppi */
-	musb_writel(regBase, DAVINCI_TXCPPI_CTRL_REG, DAVINCI_DMA_CTRL_DISABLE);
-	musb_writel(regBase, DAVINCI_RXCPPI_CTRL_REG, DAVINCI_DMA_CTRL_DISABLE);
+	musb_writel(tibase, DAVINCI_TXCPPI_CTRL_REG, DAVINCI_DMA_CTRL_DISABLE);
+	musb_writel(tibase, DAVINCI_RXCPPI_CTRL_REG, DAVINCI_DMA_CTRL_DISABLE);
 
 	return 0;
 }
@@ -282,51 +280,48 @@
  */
 static struct dma_channel *
 cppi_channel_allocate(struct dma_controller *c,
-		struct musb_hw_ep *ep,
-		u8 bTransmit)
+		struct musb_hw_ep *ep, u8 transmit)
 {
-	struct cppi		*pController;
-	u8			chNum;
-	struct cppi_channel	*otgCh;
+	struct cppi		*controller;
+	u8			index;
+	struct cppi_channel	*cppi_ch;
 	void __iomem		*tibase;
-	int			local_end = ep->bLocalEnd;
 
-	pController = container_of(c, struct cppi, Controller);
-	tibase = pController->pCoreBase - DAVINCI_BASE_OFFSET;
+	controller = container_of(c, struct cppi, controller);
+	tibase = controller->tibase;
 
-	/* remember local_end: 1..Max_EndPt, and cppi ChNum:0..Max_EndPt-1 */
-	chNum = local_end - 1;
+	/* ep0 doesn't use DMA; remember cppi indices are 0..N-1 */
+	index = ep->epnum - 1;
 
 	/* return the corresponding CPPI Channel Handle, and
 	 * probably disable the non-CPPI irq until we need it.
 	 */
-	if (bTransmit) {
-		if (local_end > ARRAY_SIZE(pController->txCppi)) {
-			DBG(1, "no %cX DMA channel for ep%d\n", 'T', local_end);
+	if (transmit) {
+		if (index >= ARRAY_SIZE(controller->tx)) {
+			DBG(1, "no %cX%d CPPI channel\n", 'T', index);
 			return NULL;
 		}
-		otgCh = pController->txCppi + chNum;
+		cppi_ch = controller->tx + index;
 	} else {
-		if (local_end > ARRAY_SIZE(pController->rxCppi)) {
-			DBG(1, "no %cX DMA channel for ep%d\n", 'R', local_end);
+		if (index >= ARRAY_SIZE(controller->rx)) {
+			DBG(1, "no %cX%d CPPI channel\n", 'R', index);
 			return NULL;
 		}
-		otgCh = pController->rxCppi + chNum;
-		core_rxirq_disable(tibase, local_end);
+		cppi_ch = controller->rx + index;
+		core_rxirq_disable(tibase, ep->epnum);
 	}
 
 	/* REVISIT make this an error later once the same driver code works
-	 * with the Mentor DMA engine too
+	 * with the other DMA engine too
 	 */
-	if (otgCh->pEndPt)
+	if (cppi_ch->hw_ep)
 		DBG(1, "re-allocating DMA%d %cX channel %p\n",
-				chNum, bTransmit ? 'T' : 'R', otgCh);
-	otgCh->pEndPt = ep;
-	otgCh->Channel.bStatus = MGC_DMA_STATUS_FREE;
-
-	DBG(4, "Allocate CPPI%d %cX\n", chNum, bTransmit ? 'T' : 'R');
-	otgCh->Channel.pPrivateData = otgCh;
-	return &otgCh->Channel;
+				index, transmit ? 'T' : 'R', cppi_ch);
+	cppi_ch->hw_ep = ep;
+	cppi_ch->channel.status = MUSB_DMA_STATUS_FREE;
+
+	DBG(4, "Allocate CPPI%d %cX\n", index, transmit ? 'T' : 'R');
+	return &cppi_ch->channel;
 }
 
 /* Release a CPPI Channel.  */
@@ -334,49 +329,48 @@
 {
 	struct cppi_channel	*c;
 	void __iomem		*tibase;
-	unsigned		epnum;
 
 	/* REVISIT:  for paranoia, check state and abort if needed... */
 
-	c = container_of(channel, struct cppi_channel, Channel);
-	epnum = c->chNo + 1;
-	tibase = c->pController->pCoreBase - DAVINCI_BASE_OFFSET;
-	if (!c->pEndPt)
+	c = container_of(channel, struct cppi_channel, channel);
+	tibase = c->controller->tibase;
+	if (!c->hw_ep)
 		DBG(1, "releasing idle DMA channel %p\n", c);
-	else if (!c->bTransmit)
-		core_rxirq_enable(tibase, epnum);
+	else if (!c->transmit)
+		core_rxirq_enable(tibase, c->index + 1);
 
 	/* for now, leave its cppi IRQ enabled (we won't trigger it) */
-	c->pEndPt = NULL;
-	channel->bStatus = MGC_DMA_STATUS_UNKNOWN;
+	c->hw_ep = NULL;
+	channel->status = MUSB_DMA_STATUS_UNKNOWN;
 }
 
 /* Context: controller irqlocked */
 static void
 cppi_dump_rx(int level, struct cppi_channel *c, const char *tag)
 {
-	void	*__iomem base = c->pController->pCoreBase;
+	void __iomem			*base = c->controller->mregs;
+	struct cppi_rx_stateram __iomem	*rx = c->state_ram;
 
-	MGC_SelectEnd(base, c->chNo + 1);
+	musb_ep_select(base, c->index + 1);
 
 	DBG(level, "RX DMA%d%s: %d left, csr %04x, "
 			"%08x H%08x S%08x C%08x, "
 			"B%08x L%08x %08x .. %08x"
 			"\n",
-		c->chNo, tag,
-		musb_readl(base - DAVINCI_BASE_OFFSET,
-			DAVINCI_RXCPPI_BUFCNT0_REG + 4 *c->chNo),
-		musb_readw(c->pEndPt->regs, MGC_O_HDRC_RXCSR),
-
-		musb_readl(c->stateRam, 0 * 4),	/* buf offset */
-		musb_readl(c->stateRam, 1 * 4),	/* head ptr */
-		musb_readl(c->stateRam, 2 * 4),	/* sop bd */
-		musb_readl(c->stateRam, 3 * 4),	/* current bd */
-
-		musb_readl(c->stateRam, 4 * 4),	/* current buf */
-		musb_readl(c->stateRam, 5 * 4),	/* pkt len */
-		musb_readl(c->stateRam, 6 * 4),	/* byte cnt */
-		musb_readl(c->stateRam, 7 * 4)	/* completion */
+		c->index, tag,
+		musb_readl(c->controller->tibase,
+			DAVINCI_RXCPPI_BUFCNT0_REG + 4 * c->index),
+		musb_readw(c->hw_ep->regs, MUSB_RXCSR),
+
+		musb_readl(&rx->rx_skipbytes, 0),
+		musb_readl(&rx->rx_head, 0),
+		musb_readl(&rx->rx_sop, 0),
+		musb_readl(&rx->rx_current, 0),
+
+		musb_readl(&rx->rx_buf_current, 0),
+		musb_readl(&rx->rx_len_len, 0),
+		musb_readl(&rx->rx_cnt_cnt, 0),
+		musb_readl(&rx->rx_complete, 0)
 		);
 }
 
@@ -384,47 +378,48 @@
 static void
 cppi_dump_tx(int level, struct cppi_channel *c, const char *tag)
 {
-	void	*__iomem base = c->pController->pCoreBase;
+	void __iomem			*base = c->controller->mregs;
+	struct cppi_tx_stateram __iomem	*tx = c->state_ram;
 
-	MGC_SelectEnd(base, c->chNo + 1);
+	musb_ep_select(base, c->index + 1);
 
 	DBG(level, "TX DMA%d%s: csr %04x, "
 			"H%08x S%08x C%08x %08x, "
 			"F%08x L%08x .. %08x"
 			"\n",
-		c->chNo, tag,
-		musb_readw(c->pEndPt->regs, MGC_O_HDRC_TXCSR),
+		c->index, tag,
+		musb_readw(c->hw_ep->regs, MUSB_TXCSR),
 
-		musb_readl(c->stateRam, 0 * 4),	/* head ptr */
-		musb_readl(c->stateRam, 1 * 4),	/* sop bd */
-		musb_readl(c->stateRam, 2 * 4),	/* current bd */
-		musb_readl(c->stateRam, 3 * 4),	/* buf offset */
-
-		musb_readl(c->stateRam, 4 * 4),	/* flags */
-		musb_readl(c->stateRam, 5 * 4),	/* len */
-		// dummy/unused word 6
-		musb_readl(c->stateRam, 7 * 4)	/* completion */
+		musb_readl(&tx->tx_head, 0),
+		musb_readl(&tx->tx_buf, 0),
+		musb_readl(&tx->tx_current, 0),
+		musb_readl(&tx->tx_buf_current, 0),
+
+		musb_readl(&tx->tx_info, 0),
+		musb_readl(&tx->tx_rem_len, 0),
+		/* dummy/unused word 6 */
+		musb_readl(&tx->tx_complete, 0)
 		);
 }
 
 /* Context: controller irqlocked */
 static inline void
 cppi_rndis_update(struct cppi_channel *c, int is_rx,
-		void *__iomem tibase, int is_rndis)
+		void __iomem *tibase, int is_rndis)
 {
 	/* we may need to change the rndis flag for this cppi channel */
-	if (c->bLastModeRndis != is_rndis) {
-		u32	regVal = musb_readl(tibase, DAVINCI_RNDIS_REG);
-		u32	temp = 1 << (c->chNo);
+	if (c->is_rndis != is_rndis) {
+		u32	value = musb_readl(tibase, DAVINCI_RNDIS_REG);
+		u32	temp = 1 << (c->index);
 
 		if (is_rx)
 			temp <<= 16;
 		if (is_rndis)
-			regVal |= temp;
+			value |= temp;
 		else
-			regVal &= ~temp;
-		musb_writel(tibase, DAVINCI_RNDIS_REG, regVal);
-		c->bLastModeRndis = is_rndis;
+			value &= ~temp;
+		musb_writel(tibase, DAVINCI_RNDIS_REG, value);
+		c->is_rndis = is_rndis;
 	}
 }
 
@@ -433,7 +428,8 @@
 	pr_debug("RXBD/%s %08x: "
 			"nxt %08x buf %08x off.blen %08x opt.plen %08x\n",
 			tag, bd->dma,
-			bd->hNext, bd->buffPtr, bd->bOffBLen, bd->hOptions);
+			bd->hw_next, bd->hw_bufp, bd->hw_off_len,
+			bd->hw_options);
 }
 
 static void cppi_dump_rxq(int level, const char *tag, struct cppi_channel *rx)
@@ -444,9 +440,9 @@
 	if (!_dbg_level(level))
 		return;
 	cppi_dump_rx(level, rx, tag);
-	if (rx->lastHwBDProcessed)
-		cppi_dump_rxbd("last", rx->lastHwBDProcessed);
-	for (bd = rx->activeQueueHead; bd; bd = bd->next)
+	if (rx->last_processed)
+		cppi_dump_rxbd("last", rx->last_processed);
+	for (bd = rx->head; bd; bd = bd->next)
 		cppi_dump_rxbd("active", bd);
 #endif
 }
@@ -456,7 +452,7 @@
  * so we won't ever use it (see "CPPI RX Woes" below).
  */
 static inline int cppi_autoreq_update(struct cppi_channel *rx,
-		void *__iomem tibase, int onepacket, unsigned n_bds)
+		void __iomem *tibase, int onepacket, unsigned n_bds)
 {
 	u32	val;
 
@@ -466,7 +462,7 @@
 
 	/* start from "AutoReq never" */
 	tmp = musb_readl(tibase, DAVINCI_AUTOREQ_REG);
-	val = tmp & ~((0x3) << (rx->chNo * 2));
+	val = tmp & ~((0x3) << (rx->index * 2));
 
 	/* HCD arranged reqpkt for packet #1.  we arrange int
 	 * for all but the last one, maybe in two segments.
@@ -474,11 +470,11 @@
 	if (!onepacket) {
 #if 0
 		/* use two segments, autoreq "all" then the last "never" */
-		val |= ((0x3) << (rx->chNo * 2));
+		val |= ((0x3) << (rx->index * 2));
 		n_bds--;
 #else
 		/* one segment, autoreq "all-but-last" */
-		val |= ((0x1) << (rx->chNo * 2));
+		val |= ((0x1) << (rx->index * 2));
 #endif
 	}
 
@@ -497,15 +493,15 @@
 #endif
 
 	/* REQPKT is turned off after each segment */
-	if (n_bds && rx->actualLen) {
-		void		*__iomem regs = rx->pEndPt->regs;
+	if (n_bds && rx->channel.actual_len) {
+		void __iomem	*regs = rx->hw_ep->regs;
 
-		val = musb_readw(regs, MGC_O_HDRC_RXCSR);
-		if (!(val & MGC_M_RXCSR_H_REQPKT)) {
-			val |= MGC_M_RXCSR_H_REQPKT | MGC_M_RXCSR_H_WZC_BITS;
-			musb_writew(regs, MGC_O_HDRC_RXCSR, val);
+		val = musb_readw(regs, MUSB_RXCSR);
+		if (!(val & MUSB_RXCSR_H_REQPKT)) {
+			val |= MUSB_RXCSR_H_REQPKT | MUSB_RXCSR_H_WZC_BITS;
+			musb_writew(regs, MUSB_RXCSR, val);
 			/* flush writebufer */
-			val = musb_readw(regs, MGC_O_HDRC_RXCSR);
+			val = musb_readw(regs, MUSB_RXCSR);
 		}
 	}
 	return n_bds;
@@ -540,7 +536,7 @@
  * ========
  * TX is a lot more reasonable than RX; it doesn't need to run in
  * irq-per-packet mode very often.  RNDIS mode seems to behave too
- * (other how it handles the exactly-N-packets case).  Building a
+ * (except how it handles the exactly-N-packets case).  Building a
  * txdma queue with multiple requests (urb or usb_request) looks
  * like it would work ... but fault handling would need much testing.
  *
@@ -565,13 +561,13 @@
 static void
 cppi_next_tx_segment(struct musb *musb, struct cppi_channel *tx)
 {
-	unsigned		maxpacket = tx->pktSize;
-	dma_addr_t		addr = tx->startAddr + tx->currOffset;
-	size_t			length = tx->transferSize - tx->currOffset;
+	unsigned		maxpacket = tx->maxpacket;
+	dma_addr_t		addr = tx->buf_dma + tx->offset;
+	size_t			length = tx->buf_len - tx->offset;
 	struct cppi_descriptor	*bd;
 	unsigned		n_bds;
 	unsigned		i;
-	struct cppi_tx_stateram	*txState = tx->stateRam;
+	struct cppi_tx_stateram	__iomem *tx_ram = tx->state_ram;
 	int			rndis;
 
 	/* TX can use the CPPI "rndis" mode, where we can probably fit this
@@ -595,7 +591,7 @@
 	}
 
 	DBG(4, "TX DMA%d, pktSz %d %s bds %d dma 0x%x len %u\n",
-			tx->chNo,
+			tx->index,
 			maxpacket,
 			rndis ? "rndis" : "transparent",
 			n_bds,
@@ -609,10 +605,13 @@
 	 * the implicit ones of an iso urb).
 	 */
 
-	bd = tx->bdPoolHead;
-	tx->activeQueueHead = tx->bdPoolHead;
-	tx->lastHwBDProcessed = NULL;
+	bd = tx->freelist;
+	tx->head = bd;
+	tx->last_processed = NULL;
 
+	/* FIXME use BD pool like RX side does, and just queue
+	 * the minimum number for this request.
+	 */
 
 	/* Prepare queue of BDs first, then hand it to hardware.
 	 * All BDs except maybe the last should be of full packet
@@ -620,50 +619,48 @@
 	 */
 	for (i = 0; i < n_bds; ) {
 		if (++i < n_bds && bd->next)
-			bd->hNext = bd->next->dma;
+			bd->hw_next = bd->next->dma;
 		else
-			bd->hNext = 0;
+			bd->hw_next = 0;
 
-		bd->buffPtr = tx->startAddr
-			+ tx->currOffset;
+		bd->hw_bufp = tx->buf_dma + tx->offset;
 
 		/* FIXME set EOP only on the last packet,
 		 * SOP only on the first ... avoid IRQs
 		 */
-		if ((tx->currOffset + maxpacket)
-				<= tx->transferSize) {
-			tx->currOffset += maxpacket;
-			bd->bOffBLen = maxpacket;
-			bd->hOptions = CPPI_SOP_SET | CPPI_EOP_SET
+		if ((tx->offset + maxpacket) <= tx->buf_len) {
+			tx->offset += maxpacket;
+			bd->hw_off_len = maxpacket;
+			bd->hw_options = CPPI_SOP_SET | CPPI_EOP_SET
 				| CPPI_OWN_SET | maxpacket;
 		} else {
 			/* only this one may be a partial USB Packet */
-			u32 buffSz;
+			u32		partial_len;
 
-			buffSz = tx->transferSize - tx->currOffset;
-			tx->currOffset = tx->transferSize;
-			bd->bOffBLen = buffSz;
-
-			bd->hOptions = CPPI_SOP_SET | CPPI_EOP_SET
-				| CPPI_OWN_SET | buffSz;
-			if (buffSz == 0)
-				bd->hOptions |= CPPI_ZERO_SET;
+			partial_len = tx->buf_len - tx->offset;
+			tx->offset = tx->buf_len;
+			bd->hw_off_len = partial_len;
+
+			bd->hw_options = CPPI_SOP_SET | CPPI_EOP_SET
+				| CPPI_OWN_SET | partial_len;
+			if (partial_len == 0)
+				bd->hw_options |= CPPI_ZERO_SET;
 		}
 
 		DBG(5, "TXBD %p: nxt %08x buf %08x len %04x opt %08x\n",
-				bd, bd->hNext, bd->buffPtr,
-				bd->bOffBLen, bd->hOptions);
+				bd, bd->hw_next, bd->hw_bufp,
+				bd->hw_off_len, bd->hw_options);
 
 		/* update the last BD enqueued to the list */
-		tx->activeQueueTail = bd;
+		tx->tail = bd;
 		bd = bd->next;
 	}
 
 	/* BDs live in DMA-coherent memory, but writes might be pending */
 	cpu_drain_writebuffer();
 
-	/* Write to the HeadPtr in StateRam to trigger */
-	txState->headPtr = (u32)tx->bdPoolHead->dma;
+	/* Write to the HeadPtr in state RAM to trigger */
+	musb_writel(&tx_ram->tx_head, 0, (u32)tx->freelist->dma);
 
 	cppi_dump_tx(5, tx, "/S");
 }
@@ -763,14 +760,15 @@
 static void
 cppi_next_rx_segment(struct musb *musb, struct cppi_channel *rx, int onepacket)
 {
-	unsigned		maxpacket = rx->pktSize;
-	dma_addr_t		addr = rx->startAddr + rx->currOffset;
-	size_t			length = rx->transferSize - rx->currOffset;
+	unsigned		maxpacket = rx->maxpacket;
+	dma_addr_t		addr = rx->buf_dma + rx->offset;
+	size_t			length = rx->buf_len - rx->offset;
 	struct cppi_descriptor	*bd, *tail;
 	unsigned		n_bds;
 	unsigned		i;
-	void			*__iomem tibase = musb->ctrl_base;
+	void __iomem		*tibase = musb->ctrl_base;
 	int			is_rndis = 0;
+	struct cppi_rx_stateram	__iomem *rx_ram = rx->state_ram;
 
 	if (onepacket) {
 		/* almost every USB driver, host or peripheral side */
@@ -816,88 +814,88 @@
 
 	DBG(4, "RX DMA%d seg, maxp %d %s bds %d (cnt %d) "
 			"dma 0x%x len %u %u/%u\n",
-			rx->chNo, maxpacket,
+			rx->index, maxpacket,
 			onepacket
 				? (is_rndis ? "rndis" : "onepacket")
 				: "multipacket",
 			n_bds,
 			musb_readl(tibase,
-				DAVINCI_RXCPPI_BUFCNT0_REG + (rx->chNo * 4))
+				DAVINCI_RXCPPI_BUFCNT0_REG + (rx->index * 4))
 					& 0xffff,
-			addr, length, rx->actualLen, rx->transferSize);
+			addr, length, rx->channel.actual_len, rx->buf_len);
 
 	/* only queue one segment at a time, since the hardware prevents
 	 * correct queue shutdown after unexpected short packets
 	 */
 	bd = cppi_bd_alloc(rx);
-	rx->activeQueueHead = bd;
+	rx->head = bd;
 
 	/* Build BDs for all packets in this segment */
 	for (i = 0, tail = NULL; bd && i < n_bds; i++, tail = bd) {
-		u32	buffSz;
+		u32	bd_len;
 
 		if (i) {
 			bd = cppi_bd_alloc(rx);
 			if (!bd)
 				break;
 			tail->next = bd;
-			tail->hNext = bd->dma;
+			tail->hw_next = bd->dma;
 		}
-		bd->hNext = 0;
+		bd->hw_next = 0;
 
 		/* all but the last packet will be maxpacket size */
 		if (maxpacket < length)
-			buffSz = maxpacket;
+			bd_len = maxpacket;
 		else
-			buffSz = length;
+			bd_len = length;
 
-		bd->buffPtr = addr;
-		addr += buffSz;
-		rx->currOffset += buffSz;
+		bd->hw_bufp = addr;
+		addr += bd_len;
+		rx->offset += bd_len;
 
-		bd->bOffBLen = (0 /*offset*/ << 16) + buffSz;
-		bd->enqBuffLen = buffSz;
+		bd->hw_off_len = (0 /*offset*/ << 16) + bd_len;
+		bd->buflen = bd_len;
 
-		bd->hOptions = CPPI_OWN_SET | (i == 0 ? length : 0);
-		length -= buffSz;
+		bd->hw_options = CPPI_OWN_SET | (i == 0 ? length : 0);
+		length -= bd_len;
 	}
 
 	/* we always expect at least one reusable BD! */
 	if (!tail) {
-		WARN("rx dma%d -- no BDs? need %d\n", rx->chNo, n_bds);
+		WARN("rx dma%d -- no BDs? need %d\n", rx->index, n_bds);
 		return;
 	} else if (i < n_bds)
-		WARN("rx dma%d -- only %d of %d BDs\n", rx->chNo, i, n_bds);
+		WARN("rx dma%d -- only %d of %d BDs\n", rx->index, i, n_bds);
 
 	tail->next = NULL;
-	tail->hNext = 0;
+	tail->hw_next = 0;
 
-	bd = rx->activeQueueHead;
-	rx->activeQueueTail = tail;
+	bd = rx->head;
+	rx->tail = tail;
 
 	/* short reads and other faults should terminate this entire
 	 * dma segment.  we want one "dma packet" per dma segment, not
 	 * one per USB packet, terminating the whole queue at once...
 	 * NOTE that current hardware seems to ignore SOP and EOP.
 	 */
-	bd->hOptions |= CPPI_SOP_SET;
-	tail->hOptions |= CPPI_EOP_SET;
+	bd->hw_options |= CPPI_SOP_SET;
+	tail->hw_options |= CPPI_EOP_SET;
 
 	if (debug >= 5) {
 		struct cppi_descriptor	*d;
 
-		for (d = rx->activeQueueHead; d; d = d->next)
+		for (d = rx->head; d; d = d->next)
 			cppi_dump_rxbd("S", d);
 	}
 
 	/* in case the preceding transfer left some state... */
-	tail = rx->lastHwBDProcessed;
+	tail = rx->last_processed;
 	if (tail) {
 		tail->next = bd;
-		tail->hNext = bd->dma;
+		tail->hw_next = bd->dma;
 	}
 
-	core_rxirq_enable(tibase, rx->chNo + 1);
+	core_rxirq_enable(tibase, rx->index + 1);
 
 	/* BDs live in DMA-coherent memory, but writes might be pending */
 	cpu_drain_writebuffer();
@@ -905,33 +903,33 @@
 	/* REVISIT specs say to write this AFTER the BUFCNT register
 	 * below ... but that loses badly.
 	 */
-	musb_writel(rx->stateRam, 4, bd->dma);
+	musb_writel(&rx_ram->rx_head, 0, bd->dma);
 
 	/* bufferCount must be at least 3, and zeroes on completion
 	 * unless it underflows below zero, or stops at two, or keeps
 	 * growing ... grr.
 	 */
 	i = musb_readl(tibase,
-			DAVINCI_RXCPPI_BUFCNT0_REG + (rx->chNo * 4))
+			DAVINCI_RXCPPI_BUFCNT0_REG + (rx->index * 4))
 			& 0xffff;
 
 	if (!i)
 		musb_writel(tibase,
-			DAVINCI_RXCPPI_BUFCNT0_REG + (rx->chNo * 4),
+			DAVINCI_RXCPPI_BUFCNT0_REG + (rx->index * 4),
 			n_bds + 2);
 	else if (n_bds > (i - 3))
 		musb_writel(tibase,
-			DAVINCI_RXCPPI_BUFCNT0_REG + (rx->chNo * 4),
+			DAVINCI_RXCPPI_BUFCNT0_REG + (rx->index * 4),
 			n_bds - (i - 3));
 
 	i = musb_readl(tibase,
-			DAVINCI_RXCPPI_BUFCNT0_REG + (rx->chNo * 4))
+			DAVINCI_RXCPPI_BUFCNT0_REG + (rx->index * 4))
 			& 0xffff;
 	if (i < (2 + n_bds)) {
 		DBG(2, "bufcnt%d underrun - %d (for %d)\n",
-					rx->chNo, i, n_bds);
+					rx->index, i, n_bds);
 		musb_writel(tibase,
-			DAVINCI_RXCPPI_BUFCNT0_REG + (rx->chNo * 4),
+			DAVINCI_RXCPPI_BUFCNT0_REG + (rx->index * 4),
 			n_bds + 2);
 	}
 
@@ -940,116 +938,121 @@
 
 /**
  * cppi_channel_program - program channel for data transfer
- * @pChannel: the channel
- * @wPacketSz: max packet size
+ * @ch: the channel
+ * @maxpacket: max packet size
  * @mode: For RX, 1 unless the usb protocol driver promised to treat
  *	all short reads as errors and kick in high level fault recovery.
  *	For TX, ignored because of RNDIS mode races/glitches.
  * @dma_addr: dma address of buffer
- * @dwLength: length of buffer
+ * @len: length of buffer
  * Context: controller irqlocked
  */
-static int cppi_channel_program(struct dma_channel *pChannel,
-		u16 wPacketSz, u8 mode,
-		dma_addr_t dma_addr, u32 dwLength)
-{
-	struct cppi_channel	*otgChannel = pChannel->pPrivateData;
-	struct cppi		*pController = otgChannel->pController;
-	struct musb		*musb = pController->musb;
-
-	switch (pChannel->bStatus) {
-	case MGC_DMA_STATUS_BUS_ABORT:
-	case MGC_DMA_STATUS_CORE_ABORT:
+static int cppi_channel_program(struct dma_channel *ch,
+		u16 maxpacket, u8 mode,
+		dma_addr_t dma_addr, u32 len)
+{
+	struct cppi_channel	*cppi_ch;
+	struct cppi		*controller;
+	struct musb		*musb;
+
+	cppi_ch = container_of(ch, struct cppi_channel, channel);
+	controller = cppi_ch->controller;
+	musb = controller->musb;
+
+	switch (ch->status) {
+	case MUSB_DMA_STATUS_BUS_ABORT:
+	case MUSB_DMA_STATUS_CORE_ABORT:
 		/* fault irq handler should have handled cleanup */
 		WARN("%cX DMA%d not cleaned up after abort!\n",
-				otgChannel->bTransmit ? 'T' : 'R',
-				otgChannel->chNo);
-		//WARN_ON(1);
+				cppi_ch->transmit ? 'T' : 'R',
+				cppi_ch->index);
+		/* WARN_ON(1); */
 		break;
-	case MGC_DMA_STATUS_BUSY:
+	case MUSB_DMA_STATUS_BUSY:
 		WARN("program active channel?  %cX DMA%d\n",
-				otgChannel->bTransmit ? 'T' : 'R',
-				otgChannel->chNo);
-		//WARN_ON(1);
+				cppi_ch->transmit ? 'T' : 'R',
+				cppi_ch->index);
+		/* WARN_ON(1); */
 		break;
-	case MGC_DMA_STATUS_UNKNOWN:
+	case MUSB_DMA_STATUS_UNKNOWN:
 		DBG(1, "%cX DMA%d not allocated!\n",
-				otgChannel->bTransmit ? 'T' : 'R',
-				otgChannel->chNo);
+				cppi_ch->transmit ? 'T' : 'R',
+				cppi_ch->index);
 		/* FALLTHROUGH */
-	case MGC_DMA_STATUS_FREE:
+	case MUSB_DMA_STATUS_FREE:
 		break;
 	}
 
-	pChannel->bStatus = MGC_DMA_STATUS_BUSY;
+	ch->status = MUSB_DMA_STATUS_BUSY;
 
 	/* set transfer parameters, then queue up its first segment */
-	otgChannel->startAddr = dma_addr;
-	otgChannel->currOffset = 0;
-	otgChannel->pktSize = wPacketSz;
-	otgChannel->actualLen = 0;
-	otgChannel->transferSize = dwLength;
+	cppi_ch->buf_dma = dma_addr;
+	cppi_ch->offset = 0;
+	cppi_ch->maxpacket = maxpacket;
+	cppi_ch->buf_len = len;
 
 	/* TX channel? or RX? */
-	if (otgChannel->bTransmit)
-		cppi_next_tx_segment(musb, otgChannel);
+	if (cppi_ch->transmit)
+		cppi_next_tx_segment(musb, cppi_ch);
 	else
-		cppi_next_rx_segment(musb, otgChannel, mode);
+		cppi_next_rx_segment(musb, cppi_ch, mode);
 
-	return TRUE;
+	return true;
 }
 
-static int cppi_rx_scan(struct cppi *cppi, unsigned ch)
+static bool cppi_rx_scan(struct cppi *cppi, unsigned ch)
 {
-	struct cppi_channel		*rx = &cppi->rxCppi[ch];
-	struct cppi_rx_stateram		*state = rx->stateRam;
+	struct cppi_channel		*rx = &cppi->rx[ch];
+	struct cppi_rx_stateram __iomem	*state = rx->state_ram;
 	struct cppi_descriptor		*bd;
-	struct cppi_descriptor		*last = rx->lastHwBDProcessed;
-	int				completed = 0, acked = 0;
+	struct cppi_descriptor		*last = rx->last_processed;
+	bool				completed = false;
+	bool				acked = false;
 	int				i;
 	dma_addr_t			safe2ack;
-	void				*__iomem regs = rx->pEndPt->regs;
+	void __iomem			*regs = rx->hw_ep->regs;
 
 	cppi_dump_rx(6, rx, "/K");
 
-	bd = last ? last->next : rx->activeQueueHead;
+	bd = last ? last->next : rx->head;
 	if (!bd)
-		return 0;
+		return false;
 
 	/* run through all completed BDs */
-	for (i = 0, safe2ack = musb_readl(CAST &state->completionPtr, 0);
+	for (i = 0, safe2ack = musb_readl(&state->rx_complete, 0);
 			(safe2ack || completed) && bd && i < NUM_RXCHAN_BD;
 			i++, bd = bd->next) {
 		u16	len;
 
 		rmb();
-		if (!completed && (bd->hOptions & CPPI_OWN_SET))
+		if (!completed && (bd->hw_options & CPPI_OWN_SET))
 			break;
 
 		DBG(5, "C/RXBD %08x: nxt %08x buf %08x "
 			"off.len %08x opt.len %08x (%d)\n",
-			bd->dma, bd->hNext, bd->buffPtr,
-			bd->bOffBLen, bd->hOptions,
-			rx->actualLen);
+			bd->dma, bd->hw_next, bd->hw_bufp,
+			bd->hw_off_len, bd->hw_options,
+			rx->channel.actual_len);
 
 		/* actual packet received length */
-		if ((bd->hOptions & CPPI_SOP_SET) && !completed)
-			len = bd->bOffBLen & CPPI_RECV_PKTLEN_MASK;
+		if ((bd->hw_options & CPPI_SOP_SET) && !completed)
+			len = bd->hw_off_len & CPPI_RECV_PKTLEN_MASK;
 		else
 			len = 0;
 
-		if (bd->hOptions & CPPI_EOQ_MASK)
-			completed = 1;
+		if (bd->hw_options & CPPI_EOQ_MASK)
+			completed = true;
 
-		if (!completed && len < bd->enqBuffLen) {
+		if (!completed && len < bd->buflen) {
 			/* NOTE:  when we get a short packet, RXCSR_H_REQPKT
 			 * must have been cleared, and no more DMA packets may
 			 * active be in the queue... TI docs didn't say, but
 			 * CPPI ignores those BDs even though OWN is still set.
 			 */
-			completed = 1;
+			completed = true;
 			DBG(3, "rx short %d/%d (%d)\n",
-					len, bd->enqBuffLen, rx->actualLen);
+					len, bd->buflen,
+					rx->channel.actual_len);
 		}
 
 		/* If we got here, we expect to ack at least one BD; meanwhile
@@ -1061,47 +1064,47 @@
 		 * lost acks and states where BD ownership is unclear.
 		 */
 		if (bd->dma == safe2ack) {
-			musb_writel(CAST &state->completionPtr, 0, safe2ack);
-			safe2ack = musb_readl(CAST &state->completionPtr, 0);
-			acked = 1;
+			musb_writel(&state->rx_complete, 0, safe2ack);
+			safe2ack = musb_readl(&state->rx_complete, 0);
+			acked = true;
 			if (bd->dma == safe2ack)
 				safe2ack = 0;
 		}
 
-		rx->actualLen += len;
+		rx->channel.actual_len += len;
 
 		cppi_bd_free(rx, last);
 		last = bd;
 
 		/* stop scanning on end-of-segment */
-		if (bd->hNext == 0)
-			completed = 1;
+		if (bd->hw_next == 0)
+			completed = true;
 	}
-	rx->lastHwBDProcessed = last;
+	rx->last_processed = last;
 
 	/* dma abort, lost ack, or ... */
 	if (!acked && last) {
 		int	csr;
 
-		if (safe2ack == 0 || safe2ack == rx->lastHwBDProcessed->dma)
-			musb_writel(CAST &state->completionPtr, 0, safe2ack);
+		if (safe2ack == 0 || safe2ack == rx->last_processed->dma)
+			musb_writel(&state->rx_complete, 0, safe2ack);
 		if (safe2ack == 0) {
 			cppi_bd_free(rx, last);
-			rx->lastHwBDProcessed = NULL;
+			rx->last_processed = NULL;
 
 			/* if we land here on the host side, H_REQPKT will
 			 * be clear and we need to restart the queue...
 			 */
-			WARN_ON(rx->activeQueueHead);
+			WARN_ON(rx->head);
 		}
-		MGC_SelectEnd(cppi->pCoreBase, rx->chNo + 1);
-		csr = musb_readw(regs, MGC_O_HDRC_RXCSR);
-		if (csr & MGC_M_RXCSR_DMAENAB) {
+		musb_ep_select(cppi->mregs, rx->index + 1);
+		csr = musb_readw(regs, MUSB_RXCSR);
+		if (csr & MUSB_RXCSR_DMAENAB) {
 			DBG(4, "list%d %p/%p, last %08x%s, csr %04x\n",
-				rx->chNo,
-				rx->activeQueueHead, rx->activeQueueTail,
-				rx->lastHwBDProcessed
-					? rx->lastHwBDProcessed->dma
+				rx->index,
+				rx->head, rx->tail,
+				rx->last_processed
+					? rx->last_processed->dma
 					: 0,
 				completed ? ", completed" : "",
 				csr);
@@ -1111,234 +1114,214 @@
 	if (!completed) {
 		int	csr;
 
-		rx->activeQueueHead = bd;
+		rx->head = bd;
 
 		/* REVISIT seems like "autoreq all but EOP" doesn't...
 		 * setting it here "should" be racey, but seems to work
 		 */
-		csr = musb_readw(rx->pEndPt->regs, MGC_O_HDRC_RXCSR);
+		csr = musb_readw(rx->hw_ep->regs, MUSB_RXCSR);
 		if (is_host_active(cppi->musb)
 				&& bd
-				&& !(csr & MGC_M_RXCSR_H_REQPKT)) {
-			csr |= MGC_M_RXCSR_H_REQPKT;
-			musb_writew(regs, MGC_O_HDRC_RXCSR,
-					MGC_M_RXCSR_H_WZC_BITS | csr);
-			csr = musb_readw(rx->pEndPt->regs, MGC_O_HDRC_RXCSR);
+				&& !(csr & MUSB_RXCSR_H_REQPKT)) {
+			csr |= MUSB_RXCSR_H_REQPKT;
+			musb_writew(regs, MUSB_RXCSR,
+					MUSB_RXCSR_H_WZC_BITS | csr);
+			csr = musb_readw(rx->hw_ep->regs, MUSB_RXCSR);
 		}
 	} else {
-		rx->activeQueueHead = NULL;
-		rx->activeQueueTail = NULL;
+		rx->head = NULL;
+		rx->tail = NULL;
 	}
 
 	cppi_dump_rx(6, rx, completed ? "/completed" : "/cleaned");
 	return completed;
 }
 
-void cppi_completion(struct musb *pThis, u32 rx, u32 tx)
+void cppi_completion(struct musb *musb, u32 rx, u32 tx)
 {
-	void			*__iomem regBase;
-	int			i, chanNum, numCompleted;
-	u8			bReqComplete;
+	void __iomem		*tibase;
+	int			i, index;
 	struct cppi		*cppi;
-	struct cppi_descriptor	*bdPtr;
-	struct musb_hw_ep	*pEnd = NULL;
+	struct musb_hw_ep	*hw_ep = NULL;
 
-	cppi = container_of(pThis->pDmaController, struct cppi, Controller);
+	cppi = container_of(musb->dma_controller, struct cppi, controller);
 
-	regBase = pThis->ctrl_base;
+	tibase = musb->ctrl_base;
 
-	chanNum = 0;
 	/* process TX channels */
-	for (chanNum = 0; tx; tx = tx >> 1, chanNum++) {
-		if (tx & 1) {
-			struct cppi_channel		*txChannel;
-			struct cppi_tx_stateram		*txState;
+	for (index = 0; tx; tx = tx >> 1, index++) {
+		struct cppi_channel		*tx_ch;
+		struct cppi_tx_stateram __iomem	*tx_ram;
+		bool				completed = false;
+		struct cppi_descriptor		*bd;
 
-			txChannel = cppi->txCppi + chanNum;
-			txState = txChannel->stateRam;
+		if (!(tx & 1))
+			continue;
 
-			/* FIXME  need a cppi_tx_scan() routine, which
-			 * can also be called from abort code
-			 */
+		tx_ch = cppi->tx + index;
+		tx_ram = tx_ch->state_ram;
 
-			cppi_dump_tx(5, txChannel, "/E");
+		/* FIXME  need a cppi_tx_scan() routine, which
+		 * can also be called from abort code
+		 */
 
-			bdPtr = txChannel->activeQueueHead;
+		cppi_dump_tx(5, tx_ch, "/E");
 
-			if (NULL == bdPtr) {
-				DBG(1, "null BD\n");
-				continue;
-			}
+		bd = tx_ch->head;
 
-			i = 0;
-			bReqComplete = 0;
+		if (NULL == bd) {
+			DBG(1, "null BD\n");
+			continue;
+		}
 
-			numCompleted = 0;
+		/* run through all completed BDs */
+		for (i = 0; !completed && bd && i < NUM_TXCHAN_BD;
+				i++, bd = bd->next) {
+			u16	len;
 
-			/* run through all completed BDs */
-			for (i = 0;
-					!bReqComplete
-						&& bdPtr
-						&& i < NUM_TXCHAN_BD;
-					i++, bdPtr = bdPtr->next) {
-				u16	len;
-
-				rmb();
-				if (bdPtr->hOptions & CPPI_OWN_SET)
-					break;
-
-				DBG(5, "C/TXBD %p n %x b %x off %x opt %x\n",
-						bdPtr, bdPtr->hNext,
-						bdPtr->buffPtr,
-						bdPtr->bOffBLen,
-						bdPtr->hOptions);
-
-				len = bdPtr->bOffBLen & CPPI_BUFFER_LEN_MASK;
-				txChannel->actualLen += len;
-
-				numCompleted++;
-				txChannel->lastHwBDProcessed = bdPtr;
-
-				/* write completion register to acknowledge
-				 * processing of completed BDs, and possibly
-				 * release the IRQ; EOQ might not be set ...
-				 *
-				 * REVISIT use the same ack strategy as rx
-				 *
-				 * REVISIT have observed bit 18 set; huh??
-				 */
-//				if ((bdPtr->hOptions & CPPI_EOQ_MASK))
-					txState->completionPtr = bdPtr->dma;
+			rmb();
+			if (bd->hw_options & CPPI_OWN_SET)
+				break;
 
-				/* stop scanning on end-of-segment */
-				if (bdPtr->hNext == 0)
-					bReqComplete = 1;
-			}
+			DBG(5, "C/TXBD %p n %x b %x off %x opt %x\n",
+					bd, bd->hw_next, bd->hw_bufp,
+					bd->hw_off_len, bd->hw_options);
+
+			len = bd->hw_off_len & CPPI_BUFFER_LEN_MASK;
+			tx_ch->channel.actual_len += len;
+
+			tx_ch->last_processed = bd;
+
+			/* write completion register to acknowledge
+			 * processing of completed BDs, and possibly
+			 * release the IRQ; EOQ might not be set ...
+			 *
+			 * REVISIT use the same ack strategy as rx
+			 *
+			 * REVISIT have observed bit 18 set; huh??
+			 */
+			/* if ((bd->hw_options & CPPI_EOQ_MASK)) */
+				musb_writel(&tx_ram->tx_complete, 0, bd->dma);
 
-			/* on end of segment, maybe go to next one */
-			if (bReqComplete) {
-				//cppi_dump_tx(4, txChannel, "/complete");
-
-				/* transfer more, or report completion */
-				if (txChannel->currOffset
-						>= txChannel->transferSize) {
-					txChannel->activeQueueHead = NULL;
-					txChannel->activeQueueTail = NULL;
-					txChannel->Channel.bStatus =
-							MGC_DMA_STATUS_FREE;
-
-					pEnd = txChannel->pEndPt;
-
-					txChannel->Channel.dwActualLength =
-						txChannel->actualLen;
-
-					/* Peripheral role never repurposes the
-					 * endpoint, so immediate completion is
-					 * safe.  Host role waits for the fifo
-					 * to empty (TXPKTRDY irq) before going
-					 * to the next queued bulk transfer.
-					 */
-					if (is_host_active(cppi->musb)) {
+			/* stop scanning on end-of-segment */
+			if (bd->hw_next == 0)
+				completed = true;
+		}
+
+		/* on end of segment, maybe go to next one */
+		if (completed) {
+			/* cppi_dump_tx(4, tx_ch, "/complete"); */
+
+			/* transfer more, or report completion */
+			if (tx_ch->offset >= tx_ch->buf_len) {
+				tx_ch->head = NULL;
+				tx_ch->tail = NULL;
+				tx_ch->channel.status = MUSB_DMA_STATUS_FREE;
+
+				hw_ep = tx_ch->hw_ep;
+
+				/* Peripheral role never repurposes the
+				 * endpoint, so immediate completion is
+				 * safe.  Host role waits for the fifo
+				 * to empty (TXPKTRDY irq) before going
+				 * to the next queued bulk transfer.
+				 */
+				if (is_host_active(cppi->musb)) {
 #if 0
-						/* WORKAROUND because we may
-						 * not always get TXKPTRDY ...
-						 */
-						int	csr;
-
-						csr = musb_readw(pEnd->regs,
-							MGC_O_HDRC_TXCSR);
-						if (csr & MGC_M_TXCSR_TXPKTRDY)
-#endif
-							bReqComplete = 0;
-					}
-					if (bReqComplete)
-						musb_dma_completion(
-							pThis, chanNum + 1, 1);
-
-				} else {
-					/* Bigger transfer than we could fit in
-					 * that first batch of descriptors...
+					/* WORKAROUND because we may
+					 * not always get TXKPTRDY ...
 					 */
-					cppi_next_tx_segment(pThis, txChannel);
+					int	csr;
+
+					csr = musb_readw(hw_ep->regs,
+						MUSB_TXCSR);
+					if (csr & MUSB_TXCSR_TXPKTRDY)
+#endif
+						completed = false;
 				}
-			} else
-				txChannel->activeQueueHead = bdPtr;
-		}
+				if (completed)
+					musb_dma_completion(musb, index + 1, 1);
+
+			} else {
+				/* Bigger transfer than we could fit in
+				 * that first batch of descriptors...
+				 */
+				cppi_next_tx_segment(musb, tx_ch);
+			}
+		} else
+			tx_ch->head = bd;
 	}
 
 	/* Start processing the RX block */
-	for (chanNum = 0; rx; rx = rx >> 1, chanNum++) {
+	for (index = 0; rx; rx = rx >> 1, index++) {
 
 		if (rx & 1) {
-			struct cppi_channel		*rxChannel;
+			struct cppi_channel		*rx_ch;
 
-			rxChannel = cppi->rxCppi + chanNum;
-			bReqComplete = cppi_rx_scan(cppi, chanNum);
+			rx_ch = cppi->rx + index;
 
 			/* let incomplete dma segments finish */
-			if (!bReqComplete)
+			if (!cppi_rx_scan(cppi, index))
 				continue;
 
 			/* start another dma segment if needed */
-			if (rxChannel->actualLen != rxChannel->transferSize
-					&& rxChannel->actualLen
-						== rxChannel->currOffset) {
-				cppi_next_rx_segment(pThis, rxChannel, 1);
+			if (rx_ch->channel.actual_len != rx_ch->buf_len
+					&& rx_ch->channel.actual_len
+						== rx_ch->offset) {
+				cppi_next_rx_segment(musb, rx_ch, 1);
 				continue;
 			}
 
 			/* all segments completed! */
-			rxChannel->Channel.bStatus = MGC_DMA_STATUS_FREE;
+			rx_ch->channel.status = MUSB_DMA_STATUS_FREE;
 
-			pEnd = rxChannel->pEndPt;
+			hw_ep = rx_ch->hw_ep;
 
-			rxChannel->Channel.dwActualLength =
-					rxChannel->actualLen;
-			core_rxirq_disable(regBase, chanNum + 1);
-			musb_dma_completion(pThis, chanNum + 1, 0);
+			core_rxirq_disable(tibase, index + 1);
+			musb_dma_completion(musb, index + 1, 0);
 		}
 	}
 
 	/* write to CPPI EOI register to re-enable interrupts */
-	musb_writel(regBase, DAVINCI_CPPI_EOI_REG, 0);
+	musb_writel(tibase, DAVINCI_CPPI_EOI_REG, 0);
 }
 
 /* Instantiate a software object representing a DMA controller. */
 struct dma_controller *__init
-dma_controller_create(struct musb *musb, void __iomem *pCoreBase)
+dma_controller_create(struct musb *musb, void __iomem *mregs)
 {
-	struct cppi		*pController;
+	struct cppi		*controller;
 
-	pController = kzalloc(sizeof *pController, GFP_KERNEL);
-	if (!pController)
+	controller = kzalloc(sizeof *controller, GFP_KERNEL);
+	if (!controller)
 		return NULL;
 
-	/* Initialize the Cppi DmaController  structure */
-	pController->pCoreBase = pCoreBase;
-	pController->musb = musb;
-	pController->Controller.pPrivateData = pController;
-	pController->Controller.start = cppi_controller_start;
-	pController->Controller.stop = cppi_controller_stop;
-	pController->Controller.channel_alloc = cppi_channel_allocate;
-	pController->Controller.channel_release = cppi_channel_release;
-	pController->Controller.channel_program = cppi_channel_program;
-	pController->Controller.channel_abort = cppi_channel_abort;
+	controller->mregs = mregs;
+	controller->tibase = mregs - DAVINCI_BASE_OFFSET;
+
+	controller->musb = musb;
+	controller->controller.start = cppi_controller_start;
+	controller->controller.stop = cppi_controller_stop;
+	controller->controller.channel_alloc = cppi_channel_allocate;
+	controller->controller.channel_release = cppi_channel_release;
+	controller->controller.channel_program = cppi_channel_program;
+	controller->controller.channel_abort = cppi_channel_abort;
 
 	/* NOTE: allocating from on-chip SRAM would give the least
 	 * contention for memory access, if that ever matters here.
 	 */
 
 	/* setup BufferPool */
-	pController->pool = dma_pool_create("cppi",
-			pController->musb->controller,
+	controller->pool = dma_pool_create("cppi",
+			controller->musb->controller,
 			sizeof(struct cppi_descriptor),
 			CPPI_DESCRIPTOR_ALIGN, 0);
-	if (!pController->pool) {
-		kfree(pController);
+	if (!controller->pool) {
+		kfree(controller);
 		return NULL;
 	}
 
-	return &pController->Controller;
+	return &controller->controller;
 }
 
 /*
@@ -1348,7 +1331,7 @@
 {
 	struct cppi	*cppi;
 
-	cppi = container_of(c, struct cppi, Controller);
+	cppi = container_of(c, struct cppi, controller);
 
 	/* assert:  caller stopped the controller first */
 	dma_pool_destroy(cppi->pool);
@@ -1361,118 +1344,105 @@
  */
 static int cppi_channel_abort(struct dma_channel *channel)
 {
-	struct cppi_channel	*otgCh;
-	struct cppi		*pController;
-	int			chNum;
-	void			*__iomem mbase;
-	void			*__iomem regBase;
-	void			*__iomem regs;
-	u32			regVal;
+	struct cppi_channel	*cppi_ch;
+	struct cppi		*controller;
+	void __iomem		*mbase;
+	void __iomem		*tibase;
+	void __iomem		*regs;
+	u32			value;
 	struct cppi_descriptor	*queue;
 
-	otgCh = container_of(channel, struct cppi_channel, Channel);
+	cppi_ch = container_of(channel, struct cppi_channel, channel);
 
-	pController = otgCh->pController;
-	chNum = otgCh->chNo;
+	controller = cppi_ch->controller;
 
-	switch (channel->bStatus) {
-	case MGC_DMA_STATUS_BUS_ABORT:
-	case MGC_DMA_STATUS_CORE_ABORT:
+	switch (channel->status) {
+	case MUSB_DMA_STATUS_BUS_ABORT:
+	case MUSB_DMA_STATUS_CORE_ABORT:
 		/* from RX or TX fault irq handler */
-	case MGC_DMA_STATUS_BUSY:
+	case MUSB_DMA_STATUS_BUSY:
 		/* the hardware needs shutting down */
-		regs = otgCh->pEndPt->regs;
+		regs = cppi_ch->hw_ep->regs;
 		break;
-	case MGC_DMA_STATUS_UNKNOWN:
-	case MGC_DMA_STATUS_FREE:
+	case MUSB_DMA_STATUS_UNKNOWN:
+	case MUSB_DMA_STATUS_FREE:
 		return 0;
 	default:
 		return -EINVAL;
 	}
 
-	if (!otgCh->bTransmit && otgCh->activeQueueHead)
-		cppi_dump_rxq(3, "/abort", otgCh);
+	if (!cppi_ch->transmit && cppi_ch->head)
+		cppi_dump_rxq(3, "/abort", cppi_ch);
 
-	mbase = pController->pCoreBase;
-	regBase = mbase - DAVINCI_BASE_OFFSET;
+	mbase = controller->mregs;
+	tibase = controller->tibase;
 
-	queue = otgCh->activeQueueHead;
-	otgCh->activeQueueHead = NULL;
-	otgCh->activeQueueTail = NULL;
+	queue = cppi_ch->head;
+	cppi_ch->head = NULL;
+	cppi_ch->tail = NULL;
 
 	/* REVISIT should rely on caller having done this,
 	 * and caller should rely on us not changing it.
 	 * peripheral code is safe ... check host too.
 	 */
-	MGC_SelectEnd(mbase, chNum + 1);
+	musb_ep_select(mbase, cppi_ch->index + 1);
 
-	if (otgCh->bTransmit) {
-		struct cppi_tx_stateram	*__iomem txState;
+	if (cppi_ch->transmit) {
+		struct cppi_tx_stateram __iomem *tx_ram;
 		int			enabled;
 
 		/* mask interrupts raised to signal teardown complete.  */
-		enabled = musb_readl(regBase, DAVINCI_TXCPPI_INTENAB_REG)
-				& (1 << otgCh->chNo);
+		enabled = musb_readl(tibase, DAVINCI_TXCPPI_INTENAB_REG)
+				& (1 << cppi_ch->index);
 		if (enabled)
-			musb_writel(regBase, DAVINCI_TXCPPI_INTCLR_REG,
-					(1 << otgCh->chNo));
+			musb_writel(tibase, DAVINCI_TXCPPI_INTCLR_REG,
+					(1 << cppi_ch->index));
 
-		// REVISIT put timeouts on these controller handshakes
+		/* REVISIT put timeouts on these controller handshakes */
 
-		cppi_dump_tx(6, otgCh, " (teardown)");
+		cppi_dump_tx(6, cppi_ch, " (teardown)");
 
 		/* teardown DMA engine then usb core */
 		do {
-			regVal = musb_readl(regBase, DAVINCI_TXCPPI_TEAR_REG);
-		} while (!(regVal & CPPI_TEAR_READY));
-		musb_writel(regBase, DAVINCI_TXCPPI_TEAR_REG, chNum);
+			value = musb_readl(tibase, DAVINCI_TXCPPI_TEAR_REG);
+		} while (!(value & CPPI_TEAR_READY));
+		musb_writel(tibase, DAVINCI_TXCPPI_TEAR_REG, cppi_ch->index);
 
-		txState = otgCh->stateRam;
+		tx_ram = cppi_ch->state_ram;
 		do {
-			regVal = txState->completionPtr;
-		} while (0xFFFFFFFC != regVal);
-		txState->completionPtr = 0xFFFFFFFC;
+			value = musb_readl(&tx_ram->tx_complete, 0);
+		} while (0xFFFFFFFC != value);
+		musb_writel(&tx_ram->tx_complete, 0, 0xFFFFFFFC);
 
 		/* FIXME clean up the transfer state ... here?
 		 * the completion routine should get called with
 		 * an appropriate status code.
 		 */
 
-		regVal = musb_readw(regs, MGC_O_HDRC_TXCSR);
-		regVal &= ~MGC_M_TXCSR_DMAENAB;
-		regVal |= MGC_M_TXCSR_FLUSHFIFO;
-		musb_writew(regs, MGC_O_HDRC_TXCSR, regVal);
-		musb_writew(regs, MGC_O_HDRC_TXCSR, regVal);
+		value = musb_readw(regs, MUSB_TXCSR);
+		value &= ~MUSB_TXCSR_DMAENAB;
+		value |= MUSB_TXCSR_FLUSHFIFO;
+		musb_writew(regs, MUSB_TXCSR, value);
+		musb_writew(regs, MUSB_TXCSR, value);
 
 		/* re-enable interrupt */
 		if (enabled)
-			musb_writel(regBase, DAVINCI_TXCPPI_INTENAB_REG,
-					(1 << otgCh->chNo));
+			musb_writel(tibase, DAVINCI_TXCPPI_INTENAB_REG,
+					(1 << cppi_ch->index));
 
-		txState->headPtr = 0;
-		txState->sopDescPtr = 0;
-		txState->currBuffPtr = 0;
-		txState->currDescPtr = 0;
-		txState->flags = 0;
-		txState->remLength = 0;
-
-		/* Ensure that we clean up any Interrupt asserted
+		/* While we scrub the TX state RAM, ensure that we clean
+		 * up any interrupt that's currently asserted:
 		 * 1. Write to completion Ptr value 0x1(bit 0 set)
 		 *    (write back mode)
 		 * 2. Write to completion Ptr value 0x0(bit 0 cleared)
 		 *    (compare mode)
-		 * Value written is compared(for bits 31:2) and being
-		 * equal interrupt deasserted?
-		 */
-
-		/* write back mode, bit 0 set, hence completion Ptr
-		 * must be updated
+		 * Value written is compared(for bits 31:2) and when
+		 * equal, interrupt is deasserted.
 		 */
-		txState->completionPtr = 0x1;
-		/* compare mode, write back zero now */
-		txState->completionPtr = 0;
+		cppi_reset_tx(tx_ram, 1);
+		musb_writel(&tx_ram->tx_complete, 0, 0);
 
-		cppi_dump_tx(5, otgCh, " (done teardown)");
+		cppi_dump_tx(5, cppi_ch, " (done teardown)");
 
 		/* REVISIT tx side _should_ clean up the same way
 		 * as the RX side ... this does no cleanup at all!
@@ -1487,41 +1457,41 @@
 		 * current RX DMA state iff any pending fifo transfer is done.
 		 */
 
-		core_rxirq_disable(regBase, otgCh->chNo + 1);
+		core_rxirq_disable(tibase, cppi_ch->index + 1);
 
 		/* for host, ensure ReqPkt is never set again */
-		if (is_host_active(otgCh->pController->musb)) {
-			regVal = musb_readl(regBase, DAVINCI_AUTOREQ_REG);
-			regVal &= ~((0x3) << (otgCh->chNo * 2));
-			musb_writel(regBase, DAVINCI_AUTOREQ_REG, regVal);
+		if (is_host_active(cppi_ch->controller->musb)) {
+			value = musb_readl(tibase, DAVINCI_AUTOREQ_REG);
+			value &= ~((0x3) << (cppi_ch->index * 2));
+			musb_writel(tibase, DAVINCI_AUTOREQ_REG, value);
 		}
 
-		csr = musb_readw(regs, MGC_O_HDRC_RXCSR);
+		csr = musb_readw(regs, MUSB_RXCSR);
 
 		/* for host, clear (just) ReqPkt at end of current packet(s) */
-		if (is_host_active(otgCh->pController->musb)) {
-			csr |= MGC_M_RXCSR_H_WZC_BITS;
-			csr &= ~MGC_M_RXCSR_H_REQPKT;
+		if (is_host_active(cppi_ch->controller->musb)) {
+			csr |= MUSB_RXCSR_H_WZC_BITS;
+			csr &= ~MUSB_RXCSR_H_REQPKT;
 		} else
-			csr |= MGC_M_RXCSR_P_WZC_BITS;
+			csr |= MUSB_RXCSR_P_WZC_BITS;
 
 		/* clear dma enable */
-		csr &= ~(MGC_M_RXCSR_DMAENAB);
-		musb_writew(regs, MGC_O_HDRC_RXCSR, csr);
-		csr = musb_readw(regs, MGC_O_HDRC_RXCSR);
+		csr &= ~(MUSB_RXCSR_DMAENAB);
+		musb_writew(regs, MUSB_RXCSR, csr);
+		csr = musb_readw(regs, MUSB_RXCSR);
 
-		/* quiesce: wait for current dma to finish (if not cleanup)
-		 * we can't use bit zero of stateram->sopDescPtr since that
+		/* Quiesce: wait for current dma to finish (if not cleanup).
+		 * We can't use bit zero of stateram->rx_sop, since that
 		 * refers to an entire "DMA packet" not just emptying the
-		 * current fifo; most segments need multiple usb packets.
+		 * current fifo.  Most segments need multiple usb packets.
 		 */
-		if (channel->bStatus == MGC_DMA_STATUS_BUSY)
+		if (channel->status == MUSB_DMA_STATUS_BUSY)
 			udelay(50);
 
 		/* scan the current list, reporting any data that was
 		 * transferred and acking any IRQ
 		 */
-		cppi_rx_scan(pController, chNum);
+		cppi_rx_scan(controller, cppi_ch->index);
 
 		/* clobber the existing state once it's idle
 		 *
@@ -1534,29 +1504,30 @@
 		 *
 		 * REVISIT does using rndis mode change that?
 		 */
-		cppi_reset_rx(otgCh->stateRam);
+		cppi_reset_rx(cppi_ch->state_ram);
 
 		/* next DMA request _should_ load cppi head ptr */
 
 		/* ... we don't "free" that list, only mutate it in place.  */
-		cppi_dump_rx(5, otgCh, " (done abort)");
+		cppi_dump_rx(5, cppi_ch, " (done abort)");
 
 		/* clean up previously pending bds */
-		cppi_bd_free(otgCh, otgCh->lastHwBDProcessed);
-		otgCh->lastHwBDProcessed = NULL;
+		cppi_bd_free(cppi_ch, cppi_ch->last_processed);
+		cppi_ch->last_processed = NULL;
 
 		while (queue) {
 			struct cppi_descriptor	*tmp = queue->next;
-			cppi_bd_free(otgCh, queue);
+
+			cppi_bd_free(cppi_ch, queue);
 			queue = tmp;
 		}
 	}
 
-	channel->bStatus = MGC_DMA_STATUS_FREE;
-	otgCh->startAddr = 0;
-	otgCh->currOffset = 0;
-	otgCh->transferSize = 0;
-	otgCh->pktSize = 0;
+	channel->status = MUSB_DMA_STATUS_FREE;
+	cppi_ch->buf_dma = 0;
+	cppi_ch->offset = 0;
+	cppi_ch->buf_len = 0;
+	cppi_ch->maxpacket = 0;
 	return 0;
 }
 
diff -ruN linux-omap-2.6/drivers/usb/musb/cppi_dma.h maemo_src/drivers/usb/musb/cppi_dma.h
--- linux-omap-2.6/drivers/usb/musb/cppi_dma.h	2011-02-06 20:17:25.833333273 -0500
+++ maemo_src/drivers/usb/musb/cppi_dma.h	2007-10-02 03:09:32.000000000 -0400
@@ -9,12 +9,42 @@
 #include <linux/errno.h>
 #include <linux/dmapool.h>
 
-#include "dma.h"
-#include "musbdefs.h"
+#include "musb_dma.h"
+#include "musb_core.h"
+
+
+/* FIXME fully isolate CPPI from DaVinci ... the "CPPI generic" registers
+ * would seem to be shared with the TUSB6020 (over VLYNQ).
+ */
+
 #include "davinci.h"
 
 
-/* hOptions bit masks for CPPI BDs */
+/* CPPI RX/TX state RAM */
+
+struct cppi_tx_stateram {
+	u32 tx_head;			/* "DMA packet" head descriptor */
+	u32 tx_buf;
+	u32 tx_current;			/* current descriptor */
+	u32 tx_buf_current;
+	u32 tx_info;			/* flags, remaining buflen */
+	u32 tx_rem_len;
+	u32 tx_dummy;			/* unused */
+	u32 tx_complete;
+};
+
+struct cppi_rx_stateram {
+	u32 rx_skipbytes;
+	u32 rx_head;
+	u32 rx_sop;			/* "DMA packet" head descriptor */
+	u32 rx_current;			/* current descriptor */
+	u32 rx_buf_current;
+	u32 rx_len_len;
+	u32 rx_cnt_cnt;
+	u32 rx_complete;
+};
+
+/* hw_options bits in CPPI buffer descriptors */
 #define CPPI_SOP_SET	((u32)(1 << 31))
 #define CPPI_EOP_SET	((u32)(1 << 30))
 #define CPPI_OWN_SET	((u32)(1 << 29))	/* owned by cppi */
@@ -29,63 +59,52 @@
 
 /* CPPI data structure definitions */
 
-#define	CPPI_DESCRIPTOR_ALIGN	16	// bytes; 5-dec docs say 4-byte align
+#define	CPPI_DESCRIPTOR_ALIGN	16	/* bytes; 5-dec docs say 4-byte align */
 
 struct cppi_descriptor {
-	/* Hardware Overlay */
-	u32 hNext;     /**< Next(hardware) Buffer Descriptor Pointer */
-	u32 buffPtr;	   /**<Buffer Pointer (dma_addr_t) */
-	u32 bOffBLen;	    /**<Buffer_offset16,buffer_length16 */
-	u32 hOptions;	    /**<Option fields for SOP,EOP etc*/
+	/* hardware overlay */
+	u32		hw_next;	/* next buffer descriptor Pointer */
+	u32		hw_bufp;	/* i/o buffer pointer */
+	u32		hw_off_len;	/* buffer_offset16, buffer_length16 */
+	u32		hw_options;	/* flags:  SOP, EOP etc*/
 
 	struct cppi_descriptor *next;
-	dma_addr_t dma;		/* address of this descriptor */
-
-	/* for Rx Desc, track original Buffer len to detect short packets */
-	u32 enqBuffLen;
+	dma_addr_t	dma;		/* address of this descriptor */
+	u32		buflen;		/* for RX: original buffer length */
 } __attribute__ ((aligned(CPPI_DESCRIPTOR_ALIGN)));
 
 
-/* forward declaration for CppiDmaController structure */
 struct cppi;
 
-/**
- *  Channel Control Structure
- *
- * CPPI  Channel Control structure. Using he same for Tx/Rx. If need be
- * derive out of this later.
- */
+/* CPPI  Channel Control structure */
 struct cppi_channel {
-	/* First field must be dma_channel for easy type casting
-	 * FIXME just use container_of() and be typesafe instead!
-	 */
-	struct dma_channel Channel;
+	struct dma_channel	channel;
 
-	/* back pointer to the Dma Controller structure */
-	struct cppi		*pController;
+	/* back pointer to the DMA controller structure */
+	struct cppi		*controller;
 
 	/* which direction of which endpoint? */
-	struct musb_hw_ep	*pEndPt;
-	u8			bTransmit;
-	u8			chNo;
+	struct musb_hw_ep	*hw_ep;
+	bool			transmit;
+	u8			index;
 
 	/* DMA modes:  RNDIS or "transparent" */
-	u8			bLastModeRndis;
+	u8			is_rndis;
 
 	/* book keeping for current transfer request */
-	dma_addr_t		startAddr;
-	u32			transferSize;
-	u32			pktSize;
-	u32			currOffset;	/* requested segments */
-	u32			actualLen;	/* completed (Channel.actual) */
+	dma_addr_t		buf_dma;
+	u32			buf_len;
+	u32			maxpacket;
+	u32			offset;		/* dma requested */
+
+	void __iomem		*state_ram;	/* CPPI state */
 
-	void __iomem		*stateRam;	/* CPPI state */
+	struct cppi_descriptor	*freelist;
 
 	/* BD management fields */
-	struct cppi_descriptor	*bdPoolHead;
-	struct cppi_descriptor	*activeQueueHead;
-	struct cppi_descriptor	*activeQueueTail;
-	struct cppi_descriptor	*lastHwBDProcessed;
+	struct cppi_descriptor	*head;
+	struct cppi_descriptor	*tail;
+	struct cppi_descriptor	*last_processed;
 
 	/* use tx_complete in host role to track endpoints waiting for
 	 * FIFONOTEMPTY to clear.
@@ -93,19 +112,15 @@
 	struct list_head	tx_complete;
 };
 
-/**
- *  CPPI Dma Controller Object
- *
- *  CPPI Dma controller object.Encapsulates all bookeeping and Data
- *  structures pertaining to the CPPI Dma Controller.
- */
+/* CPPI DMA controller object */
 struct cppi {
-	struct dma_controller		Controller;
+	struct dma_controller		controller;
 	struct musb			*musb;
-	void __iomem			*pCoreBase;
+	void __iomem			*mregs;		/* Mentor regs */
+	void __iomem			*tibase;	/* TI/CPPI regs */
 
-	struct cppi_channel		txCppi[MUSB_C_NUM_EPT - 1];
-	struct cppi_channel		rxCppi[MUSB_C_NUM_EPR - 1];
+	struct cppi_channel		tx[MUSB_C_NUM_EPT - 1];
+	struct cppi_channel		rx[MUSB_C_NUM_EPR - 1];
 
 	struct dma_pool			*pool;
 
diff -ruN linux-omap-2.6/drivers/usb/musb/davinci.c maemo_src/drivers/usb/musb/davinci.c
--- linux-omap-2.6/drivers/usb/musb/davinci.c	2011-02-06 20:17:25.853333274 -0500
+++ maemo_src/drivers/usb/musb/davinci.c	2011-02-06 20:12:11.343333272 -0500
@@ -29,15 +29,14 @@
 #include <linux/list.h>
 #include <linux/delay.h>
 #include <linux/clk.h>
+#include <linux/io.h>
 
-#include <asm/io.h>
 #include <asm/arch/hardware.h>
 #include <asm/arch/memory.h>
 #include <asm/arch/gpio.h>
 #include <asm/mach-types.h>
 
-#include "musbdefs.h"
-
+#include "musb_core.h"
 
 #ifdef CONFIG_MACH_DAVINCI_EVM
 #include <asm/arch/i2c-client.h>
@@ -57,8 +56,9 @@
 {
 	/* start the on-chip PHY and its PLL */
 	__raw_writel(USBPHY_SESNDEN | USBPHY_VBDTCTEN | USBPHY_PHYPLLON,
-			IO_ADDRESS(USBPHY_CTL_PADDR));
-	while ((__raw_readl(IO_ADDRESS(USBPHY_CTL_PADDR))
+			(void __force __iomem *) IO_ADDRESS(USBPHY_CTL_PADDR));
+	while ((__raw_readl((void __force __iomem *)
+				IO_ADDRESS(USBPHY_CTL_PADDR))
 			& USBPHY_PHYCLKGD) == 0)
 		cpu_relax();
 }
@@ -66,7 +66,7 @@
 static inline void phy_off(void)
 {
 	/* powerdown the on-chip PHY and its oscillator */
-	__raw_writel(USBPHY_OSCPDWN | USBPHY_PHYPDWN,
+	__raw_writel(USBPHY_OSCPDWN | USBPHY_PHYPDWN, (void __force __iomem *)
 			IO_ADDRESS(USBPHY_CTL_PADDR));
 }
 
@@ -77,22 +77,22 @@
 	u32	tmp, old, val;
 
 	/* workaround:  setup irqs through both register sets */
-	tmp = (musb->wEndMask & DAVINCI_USB_TX_ENDPTS_MASK)
+	tmp = (musb->epmask & DAVINCI_USB_TX_ENDPTS_MASK)
 			<< DAVINCI_USB_TXINT_SHIFT;
 	musb_writel(musb->ctrl_base, DAVINCI_USB_INT_MASK_SET_REG, tmp);
 	old = tmp;
-	tmp = (musb->wEndMask & (0xfffe & DAVINCI_USB_RX_ENDPTS_MASK))
+	tmp = (musb->epmask & (0xfffe & DAVINCI_USB_RX_ENDPTS_MASK))
 			<< DAVINCI_USB_RXINT_SHIFT;
 	musb_writel(musb->ctrl_base, DAVINCI_USB_INT_MASK_SET_REG, tmp);
 	tmp |= old;
 
-	val = ~MGC_M_INTR_SOF;
+	val = ~MUSB_INTR_SOF;
 	tmp |= ((val & 0x01ff) << DAVINCI_USB_USBINT_SHIFT);
 	musb_writel(musb->ctrl_base, DAVINCI_USB_INT_MASK_SET_REG, tmp);
 
 	if (is_dma_capable() && !dma_off)
 		printk(KERN_WARNING "%s %s: dma not reactivated\n",
-				__FILE__, __FUNCTION__);
+				__FILE__, __func__);
 	else
 		dma_off = 0;
 
@@ -116,7 +116,7 @@
 			  DAVINCI_USB_USBINT_MASK
 			| DAVINCI_USB_TXINT_MASK
 			| DAVINCI_USB_RXINT_MASK);
-	musb_writeb(musb->pRegs, MGC_O_HDRC_DEVCTL, 0);
+	musb_writeb(musb->mregs, MUSB_DEVCTL, 0);
 	musb_writel(musb->ctrl_base, DAVINCI_USB_EOI_REG, 0);
 
 	if (is_dma_capable() && !dma_off)
@@ -149,7 +149,7 @@
 	davinci_i2c_expander_op(0x3a, USB_DRVVBUS, vbus_state);
 	vbus_state = !vbus_state;
 }
-DECLARE_WORK(evm_vbus_work, evm_deferred_drvvbus);
+static DECLARE_WORK(evm_vbus_work, evm_deferred_drvvbus);
 
 #endif	/* modified board */
 #endif	/* EVM */
@@ -189,7 +189,7 @@
 static void davinci_set_vbus(struct musb *musb, int is_on)
 {
 	WARN_ON(is_on && is_peripheral_active(musb));
-	return davinci_source_power(musb, is_on, 0);
+	davinci_source_power(musb, is_on, 0);
 }
 
 
@@ -200,17 +200,17 @@
 static void otg_timer(unsigned long _musb)
 {
 	struct musb		*musb = (void *)_musb;
-	void	*__iomem	mregs = musb->pRegs;
+	void __iomem		*mregs = musb->mregs;
 	u8			devctl;
 	unsigned long		flags;
 
 	/* We poll because DaVinci's won't expose several OTG-critical
 	* status change events (from the transceiver) otherwise.
 	 */
-	devctl = musb_readb(mregs, MGC_O_HDRC_DEVCTL);
+	devctl = musb_readb(mregs, MUSB_DEVCTL);
 	DBG(7, "poll devctl %02x (%s)\n", devctl, otg_state_string(musb));
 
-	spin_lock_irqsave(&musb->Lock, flags);
+	spin_lock_irqsave(&musb->lock, flags);
 	switch (musb->xceiv.state) {
 	case OTG_STATE_A_WAIT_VFALL:
 		/* Wait till VBUS falls below SessionEnd (~0.2V); the 1.3 RTL
@@ -218,13 +218,13 @@
 		 * case "recover"), in routine "VBUS was valid by the time
 		 * VBUSERR got reported during enumeration" cases.
 		 */
-		if (devctl & MGC_M_DEVCTL_VBUS) {
+		if (devctl & MUSB_DEVCTL_VBUS) {
 			mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 			break;
 		}
 		musb->xceiv.state = OTG_STATE_A_WAIT_VRISE;
 		musb_writel(musb->ctrl_base, DAVINCI_USB_INT_SET_REG,
-			MGC_M_INTR_VBUSERROR << DAVINCI_USB_USBINT_SHIFT);
+			MUSB_INTR_VBUSERROR << DAVINCI_USB_USBINT_SHIFT);
 		break;
 	case OTG_STATE_B_IDLE:
 		if (!is_peripheral_enabled(musb))
@@ -241,10 +241,10 @@
 		 * NOTE setting the session flag is _supposed_ to trigger
 		 * SRP, but clearly it doesn't.
 		 */
-		musb_writeb(mregs, MGC_O_HDRC_DEVCTL,
-				devctl | MGC_M_DEVCTL_SESSION);
-		devctl = musb_readb(mregs, MGC_O_HDRC_DEVCTL);
-		if (devctl & MGC_M_DEVCTL_BDEVICE)
+		musb_writeb(mregs, MUSB_DEVCTL,
+				devctl | MUSB_DEVCTL_SESSION);
+		devctl = musb_readb(mregs, MUSB_DEVCTL);
+		if (devctl & MUSB_DEVCTL_BDEVICE)
 			mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 		else
 			musb->xceiv.state = OTG_STATE_A_IDLE;
@@ -252,7 +252,7 @@
 	default:
 		break;
 	}
-	spin_unlock_irqrestore(&musb->Lock, flags);
+	spin_unlock_irqrestore(&musb->lock, flags);
 }
 
 static irqreturn_t davinci_interrupt(int irq, void *__hci)
@@ -260,10 +260,10 @@
 	unsigned long	flags;
 	irqreturn_t	retval = IRQ_NONE;
 	struct musb	*musb = __hci;
-	void		*__iomem tibase = musb->ctrl_base;
+	void __iomem	*tibase = musb->ctrl_base;
 	u32		tmp;
 
-	spin_lock_irqsave(&musb->Lock, flags);
+	spin_lock_irqsave(&musb->lock, flags);
 
 	/* NOTE: DaVinci shadows the Mentor IRQs.  Don't manage them through
 	 * the Mentor registers (except for setup), use the TI ones and EOI.
@@ -309,12 +309,12 @@
 	 */
 	if (tmp & (DAVINCI_INTR_DRVVBUS << DAVINCI_USB_USBINT_SHIFT)) {
 		int	drvvbus = musb_readl(tibase, DAVINCI_USB_STAT_REG);
-		void	*__iomem mregs = musb->pRegs;
-		u8	devctl = musb_readb(mregs, MGC_O_HDRC_DEVCTL);
-		int	err = musb->int_usb & MGC_M_INTR_VBUSERROR;
+		void __iomem *mregs = musb->mregs;
+		u8	devctl = musb_readb(mregs, MUSB_DEVCTL);
+		int	err = musb->int_usb & MUSB_INTR_VBUSERROR;
 
 		err = is_host_enabled(musb)
-				&& (musb->int_usb & MGC_M_INTR_VBUSERROR);
+				&& (musb->int_usb & MUSB_INTR_VBUSERROR);
 		if (err) {
 			/* The Mentor core doesn't debounce VBUS as needed
 			 * to cope with device connect current spikes. This
@@ -322,11 +322,11 @@
 			 * to get VBUS errors during enumeration.
 			 *
 			 * This is a workaround, but newer RTL from Mentor
-			 * seems to lalow a better one: "re"starting sessions
+			 * seems to allow a better one: "re"starting sessions
 			 * without waiting (on EVM, a **long** time) for VBUS
 			 * to stop registering in devctl.
 			 */
-			musb->int_usb &= ~MGC_M_INTR_VBUSERROR;
+			musb->int_usb &= ~MUSB_INTR_VBUSERROR;
 			musb->xceiv.state = OTG_STATE_A_WAIT_VFALL;
 			mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 			WARN("VBUS error workaround (delay coming)\n");
@@ -366,7 +366,7 @@
 			&& musb->xceiv.state == OTG_STATE_B_IDLE)
 		mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 
-	spin_unlock_irqrestore(&musb->Lock, flags);
+	spin_unlock_irqrestore(&musb->lock, flags);
 
 	/* REVISIT we sometimes get unhandled IRQs
 	 * (e.g. ep0).  not clear why...
@@ -378,10 +378,10 @@
 
 int __init musb_platform_init(struct musb *musb)
 {
-	void	*__iomem tibase = musb->ctrl_base;
-	u32	revision;
+	void __iomem	*tibase = musb->ctrl_base;
+	u32		revision;
 
-	musb->pRegs += DAVINCI_BASE_OFFSET;
+	musb->mregs += DAVINCI_BASE_OFFSET;
 #if 0
 	/* REVISIT there's something odd about clocking, this
 	 * didn't appear do the job ...
@@ -416,8 +416,8 @@
 
 	/* NOTE:  irqs are in mixed mode, not bypass to pure-musb */
 	pr_debug("DaVinci OTG revision %08x phy %03x control %02x\n",
-		revision,
-		__raw_readl((void *__iomem) IO_ADDRESS(USBPHY_CTL_PADDR)),
+		revision, __raw_readl((void __force __iomem *)
+				IO_ADDRESS(USBPHY_CTL_PADDR)),
 		musb_readb(tibase, DAVINCI_USB_CTRL_REG));
 
 	musb->isr = davinci_interrupt;
@@ -440,19 +440,20 @@
 		 * long time to fall, especially on EVM with huge C133.
 		 */
 		do {
-			devctl = musb_readb(musb->pRegs, MGC_O_HDRC_DEVCTL);
-			if (!(devctl & MGC_M_DEVCTL_VBUS))
+			devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+			if (!(devctl & MUSB_DEVCTL_VBUS))
 				break;
-			if ((devctl & MGC_M_DEVCTL_VBUS) != warn) {
-				warn = devctl & MGC_M_DEVCTL_VBUS;
-				DBG(1, "VBUS %d\n", warn >> MGC_S_DEVCTL_VBUS);
+			if ((devctl & MUSB_DEVCTL_VBUS) != warn) {
+				warn = devctl & MUSB_DEVCTL_VBUS;
+				DBG(1, "VBUS %d\n",
+					warn >> MUSB_DEVCTL_VBUS_SHIFT);
 			}
 			msleep(1000);
 			maxdelay--;
 		} while (maxdelay > 0);
 
 		/* in OTG mode, another host might be connected */
-		if (devctl & MGC_M_DEVCTL_VBUS)
+		if (devctl & MUSB_DEVCTL_VBUS)
 			DBG(1, "VBUS off timeout (devctl %02x)\n", devctl);
 	}
 
diff -ruN linux-omap-2.6/drivers/usb/musb/davinci.h maemo_src/drivers/usb/musb/davinci.h
--- linux-omap-2.6/drivers/usb/musb/davinci.h	2011-02-06 20:17:25.853333274 -0500
+++ maemo_src/drivers/usb/musb/davinci.h	2011-02-06 20:12:11.316666607 -0500
@@ -40,6 +40,8 @@
 #define DAVINCI_USB_EOI_REG		0x3c
 #define DAVINCI_USB_EOI_INTVEC		0x40
 
+/* BEGIN CPPI-generic (?) */
+
 /* CPPI related registers */
 #define DAVINCI_TXCPPI_CTRL_REG		0x80
 #define DAVINCI_TXCPPI_TEAR_REG		0x84
@@ -64,10 +66,10 @@
 /* CPPI state RAM entries */
 #define DAVINCI_CPPI_STATERAM_BASE_OFFSET   0x100
 
-#define DAVINCI_TXCPPI_STATERAM_OFFSET(channelNum) \
-	(DAVINCI_CPPI_STATERAM_BASE_OFFSET +       ((channelNum)* 0x40))
-#define DAVINCI_RXCPPI_STATERAM_OFFSET(channelNum) \
-	(DAVINCI_CPPI_STATERAM_BASE_OFFSET + 0x20 +((channelNum)* 0x40))
+#define DAVINCI_TXCPPI_STATERAM_OFFSET(chnum) \
+	(DAVINCI_CPPI_STATERAM_BASE_OFFSET +       ((chnum) * 0x40))
+#define DAVINCI_RXCPPI_STATERAM_OFFSET(chnum) \
+	(DAVINCI_CPPI_STATERAM_BASE_OFFSET + 0x20 + ((chnum) * 0x40))
 
 /* CPPI masks */
 #define DAVINCI_DMA_CTRL_ENABLE		1
@@ -76,30 +78,7 @@
 #define DAVINCI_DMA_ALL_CHANNELS_ENABLE	0xF
 #define DAVINCI_DMA_ALL_CHANNELS_DISABLE 0xF
 
-/* REVISIT relying on "volatile" here is wrong ... */
-
-/* define structures of Rx/Tx stateRam entries */
-struct cppi_tx_stateram {
-	volatile u32 headPtr;
-	volatile u32 sopDescPtr;
-	volatile u32 currDescPtr;
-	volatile u32 currBuffPtr;
-	volatile u32 flags;
-	volatile u32 remLength;
-	volatile u32 dummy;
-	volatile u32 completionPtr;
-};
-
-struct cppi_rx_stateram {
-	volatile u32 buffOffset;
-	volatile u32 headPtr;
-	volatile u32 sopDescPtr;
-	volatile u32 currDescPtr;
-	volatile u32 currBuffPtr;
-	volatile u32 pktLength;
-	volatile u32 byteCount;
-	volatile u32 completionPtr;
-};
+/* END CPPI-generic (?) */
 
 #define DAVINCI_USB_TX_ENDPTS_MASK	0x1f		/* ep0 + 4 tx */
 #define DAVINCI_USB_RX_ENDPTS_MASK	0x1e		/* 4 rx */
diff -ruN linux-omap-2.6/drivers/usb/musb/debug.h maemo_src/drivers/usb/musb/debug.h
--- linux-omap-2.6/drivers/usb/musb/debug.h	2011-02-06 20:17:25.863333273 -0500
+++ maemo_src/drivers/usb/musb/debug.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,65 +0,0 @@
-/******************************************************************
- * Copyright 2005 Mentor Graphics Corporation
- * Copyright (C) 2005-2006 by Texas Instruments
- *
- * This file is part of the Inventra Controller Driver for Linux.
- *
- * The Inventra Controller Driver for Linux is free software; you
- * can redistribute it and/or modify it under the terms of the GNU
- * General Public License version 2 as published by the Free Software
- * Foundation.
- *
- * The Inventra Controller Driver for Linux is distributed in
- * the hope that it will be useful, but WITHOUT ANY WARRANTY;
- * without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
- * License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with The Inventra Controller Driver for Linux ; if not,
- * write to the Free Software Foundation, Inc., 59 Temple Place,
- * Suite 330, Boston, MA  02111-1307  USA
- *
- * ANY DOWNLOAD, USE, REPRODUCTION, MODIFICATION OR DISTRIBUTION
- * OF THIS DRIVER INDICATES YOUR COMPLETE AND UNCONDITIONAL ACCEPTANCE
- * OF THOSE TERMS.THIS DRIVER IS PROVIDED "AS IS" AND MENTOR GRAPHICS
- * MAKES NO WARRANTIES, EXPRESS OR IMPLIED, RELATED TO THIS DRIVER.
- * MENTOR GRAPHICS SPECIFICALLY DISCLAIMS ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY; FITNESS FOR A PARTICULAR PURPOSE AND
- * NON-INFRINGEMENT.  MENTOR GRAPHICS DOES NOT PROVIDE SUPPORT
- * SERVICES OR UPDATES FOR THIS DRIVER, EVEN IF YOU ARE A MENTOR
- * GRAPHICS SUPPORT CUSTOMER.
- ******************************************************************/
-
-#ifndef __MUSB_LINUX_DEBUG_H__
-#define __MUSB_LINUX_DEBUG_H__
-
-#define yprintk(facility, format, args...) \
-	do { printk(facility "%s %d: " format , \
-	__FUNCTION__, __LINE__ , ## args); } while (0)
-#define WARN(fmt, args...) yprintk(KERN_WARNING,fmt, ## args)
-#define INFO(fmt,args...) yprintk(KERN_INFO,fmt, ## args)
-#define ERR(fmt,args...) yprintk(KERN_ERR,fmt, ## args)
-
-#define xprintk(level, facility, format, args...) do { \
-	if ( _dbg_level(level) ) { \
-		printk(facility "%s %d: " format , \
-				__FUNCTION__, __LINE__ , ## args); \
-	} } while (0)
-
-#if MUSB_DEBUG > 0
-extern unsigned debug;
-#else
-#define debug	0
-#endif
-
-static inline int _dbg_level(unsigned l)
-{
-	return debug >= l;
-}
-
-#define DBG(level,fmt,args...) xprintk(level,KERN_DEBUG,fmt, ## args)
-
-extern const char *otg_state_string(struct musb *);
-
-#endif				//  __MUSB_LINUX_DEBUG_H__
diff -ruN linux-omap-2.6/drivers/usb/musb/dma.h maemo_src/drivers/usb/musb/dma.h
--- linux-omap-2.6/drivers/usb/musb/dma.h	2011-02-06 20:17:25.873333272 -0500
+++ maemo_src/drivers/usb/musb/dma.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,191 +0,0 @@
-/******************************************************************
- * Copyright 2005 Mentor Graphics Corporation
- * Copyright (C) 2005-2006 by Texas Instruments
- *
- * This file is part of the Inventra Controller Driver for Linux.
- *
- * The Inventra Controller Driver for Linux is free software; you
- * can redistribute it and/or modify it under the terms of the GNU
- * General Public License version 2 as published by the Free Software
- * Foundation.
- *
- * The Inventra Controller Driver for Linux is distributed in
- * the hope that it will be useful, but WITHOUT ANY WARRANTY;
- * without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
- * License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with The Inventra Controller Driver for Linux ; if not,
- * write to the Free Software Foundation, Inc., 59 Temple Place,
- * Suite 330, Boston, MA  02111-1307  USA
- *
- * ANY DOWNLOAD, USE, REPRODUCTION, MODIFICATION OR DISTRIBUTION
- * OF THIS DRIVER INDICATES YOUR COMPLETE AND UNCONDITIONAL ACCEPTANCE
- * OF THOSE TERMS.THIS DRIVER IS PROVIDED "AS IS" AND MENTOR GRAPHICS
- * MAKES NO WARRANTIES, EXPRESS OR IMPLIED, RELATED TO THIS DRIVER.
- * MENTOR GRAPHICS SPECIFICALLY DISCLAIMS ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY; FITNESS FOR A PARTICULAR PURPOSE AND
- * NON-INFRINGEMENT.  MENTOR GRAPHICS DOES NOT PROVIDE SUPPORT
- * SERVICES OR UPDATES FOR THIS DRIVER, EVEN IF YOU ARE A MENTOR
- * GRAPHICS SUPPORT CUSTOMER.
- ******************************************************************/
-
-#ifndef __MUSB_DMA_H__
-#define __MUSB_DMA_H__
-
-struct musb_hw_ep;
-
-/*
- * DMA Controller Abstraction
- *
- * DMA Controllers are abstracted to allow use of a variety of different
- * implementations of DMA, as allowed by the Inventra USB cores.  On the
- * host side, usbcore sets up the DMA mappings and flushes caches; on the
- * peripheral side, the gadget controller driver does.  Responsibilities
- * of a DMA controller driver include:
- *
- *  - Handling the details of moving multiple USB packets
- *    in cooperation with the Inventra USB core, including especially
- *    the correct RX side treatment of short packets and buffer-full
- *    states (both of which terminate transfers).
- *
- *  - Knowing the correlation between dma channels and the
- *    Inventra core's local endpoint resources and data direction.
- *
- *  - Maintaining a list of allocated/available channels.
- *
- *  - Updating channel status on interrupts,
- *    whether shared with the Inventra core or separate.
- */
-
-#define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
-
-#ifndef CONFIG_USB_INVENTRA_FIFO
-#define	is_dma_capable()	(1)
-#else
-#define	is_dma_capable()	(0)
-#endif
-
-#ifdef CONFIG_USB_TI_CPPI_DMA
-#define	is_cppi_enabled()	1
-#else
-#define	is_cppi_enabled()	0
-#endif
-
-#ifdef CONFIG_USB_TUSB_OMAP_DMA
-#define tusb_dma_omap()			1
-#else
-#define tusb_dma_omap()			0
-#endif
-
-/*
- * DMA channel status ... updated by the dma controller driver whenever that
- * status changes, and protected by the overall controller spinlock.
- */
-enum dma_channel_status {
-	/* unallocated */
-	MGC_DMA_STATUS_UNKNOWN,
-	/* allocated ... but not busy, no errors */
-	MGC_DMA_STATUS_FREE,
-	/* busy ... transactions are active */
-	MGC_DMA_STATUS_BUSY,
-	/* transaction(s) aborted due to ... dma or memory bus error */
-	MGC_DMA_STATUS_BUS_ABORT,
-	/* transaction(s) aborted due to ... core error or USB fault */
-	MGC_DMA_STATUS_CORE_ABORT
-};
-
-struct dma_controller;
-
-/**
- * struct dma_channel - A DMA channel.
- * @pPrivateData: channel-private data
- * @wMaxLength: the maximum number of bytes the channel can move in one
- *	transaction (typically representing many USB maximum-sized packets)
- * @dwActualLength: how many bytes have been transferred
- * @bStatus: current channel status (updated e.g. on interrupt)
- * @bDesiredMode: TRUE if mode 1 is desired; FALSE if mode 0 is desired
- *
- * channels are associated with an endpoint for the duration of at least
- * one usb transfer.
- */
-struct dma_channel {
-	void			*pPrivateData;
-	// FIXME not void* private_data, but a dma_controller *
-	size_t			dwMaxLength;
-	size_t			dwActualLength;
-	enum dma_channel_status	bStatus;
-	u8			bDesiredMode;
-};
-
-/*
- * Program a DMA channel to move data at the core's request.
- * The local core endpoint and direction should already be known,
- * since they are specified in the channel_alloc call.
- *
- * @channel: pointer to a channel obtained by channel_alloc
- * @maxpacket: the maximum packet size
- * @bMode: TRUE if mode 1; FALSE if mode 0
- * @dma_addr: base address of data (in DMA space)
- * @length: the number of bytes to transfer; no larger than the channel's
- *	reported dwMaxLength
- *
- * Returns TRUE on success, else FALSE
- */
-typedef int (*MGC_pfDmaProgramChannel) (
-		struct dma_channel	*channel,
-		u16			maxpacket,
-		u8			bMode,
-		dma_addr_t		dma_addr,
-		u32			length);
-
-/*
- * dma_channel_status - return status of dma channel
- * @c: the channel
- *
- * Returns the software's view of the channel status.  If that status is BUSY
- * then it's possible that the hardware has completed (or aborted) a transfer,
- * so the driver needs to update that status.
- */
-static inline enum dma_channel_status
-dma_channel_status(struct dma_channel *c)
-{
-	return (is_dma_capable() && c) ? c->bStatus : MGC_DMA_STATUS_UNKNOWN;
-}
-
-/**
- * struct dma_controller - A DMA Controller.
- * @pPrivateData: controller-private data;
- * @start: call this to start a DMA controller;
- *	return 0 on success, else negative errno
- * @stop: call this to stop a DMA controller
- *	return 0 on success, else negative errno
- * @channel_alloc: call this to allocate a DMA channel
- * @channel_release: call this to release a DMA channel
- * @channel_abort: call this to abort a pending DMA transaction,
- *	returning it to FREE (but allocated) state
- *
- * Controllers manage dma channels.
- */
-struct dma_controller {
-	void			*pPrivateData;
-	int			(*start)(struct dma_controller *);
-	int			(*stop)(struct dma_controller *);
-	struct dma_channel	*(*channel_alloc)(struct dma_controller *,
-					struct musb_hw_ep *, u8 is_tx);
-	void			(*channel_release)(struct dma_channel *);
-	MGC_pfDmaProgramChannel	channel_program;
-	int			(*channel_abort)(struct dma_channel *);
-};
-
-/* called after channel_program(), may indicate a fault */
-extern void musb_dma_completion(struct musb *musb, u8 bLocalEnd, u8 bTransmit);
-
-
-extern struct dma_controller *__init
-dma_controller_create(struct musb *, void __iomem *);
-
-extern void dma_controller_destroy(struct dma_controller *);
-
-#endif	/* __MUSB_DMA_H__ */
diff -ruN linux-omap-2.6/drivers/usb/musb/g_ep0.c maemo_src/drivers/usb/musb/g_ep0.c
--- linux-omap-2.6/drivers/usb/musb/g_ep0.c	2011-02-06 20:17:25.876666606 -0500
+++ maemo_src/drivers/usb/musb/g_ep0.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,973 +0,0 @@
-/******************************************************************
- * Copyright 2005 Mentor Graphics Corporation
- * Copyright (C) 2005-2006 by Texas Instruments
- *
- * This file is part of the Inventra Controller Driver for Linux.
- *
- * The Inventra Controller Driver for Linux is free software; you
- * can redistribute it and/or modify it under the terms of the GNU
- * General Public License version 2 as published by the Free Software
- * Foundation.
- *
- * The Inventra Controller Driver for Linux is distributed in
- * the hope that it will be useful, but WITHOUT ANY WARRANTY;
- * without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
- * License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with The Inventra Controller Driver for Linux ; if not,
- * write to the Free Software Foundation, Inc., 59 Temple Place,
- * Suite 330, Boston, MA  02111-1307  USA
- *
- * ANY DOWNLOAD, USE, REPRODUCTION, MODIFICATION OR DISTRIBUTION
- * OF THIS DRIVER INDICATES YOUR COMPLETE AND UNCONDITIONAL ACCEPTANCE
- * OF THOSE TERMS.THIS DRIVER IS PROVIDED "AS IS" AND MENTOR GRAPHICS
- * MAKES NO WARRANTIES, EXPRESS OR IMPLIED, RELATED TO THIS DRIVER.
- * MENTOR GRAPHICS SPECIFICALLY DISCLAIMS ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY; FITNESS FOR A PARTICULAR PURPOSE AND
- * NON-INFRINGEMENT.  MENTOR GRAPHICS DOES NOT PROVIDE SUPPORT
- * SERVICES OR UPDATES FOR THIS DRIVER, EVEN IF YOU ARE A MENTOR
- * GRAPHICS SUPPORT CUSTOMER.
- ******************************************************************/
-
-#include <linux/kernel.h>
-#include <linux/list.h>
-#include <linux/timer.h>
-#include <linux/spinlock.h>
-#include <linux/init.h>
-#include <linux/device.h>
-#include <linux/interrupt.h>
-
-#include "musbdefs.h"
-
-/* ep0 is always musb->aLocalEnd[0].ep_in */
-#define	next_ep0_request(musb)	next_in_request(&(musb)->aLocalEnd[0])
-
-/*
- * Locking note:  we use only the controller lock, for simpler correctness.
- * It's always held with IRQs blocked.
- *
- * It protects the ep0 request queue as well as ep0_state, not just the
- * controller and indexed registers.  And that lock stays held unless it
- * needs to be dropped to allow reentering this driver ... like upcalls to
- * the gadget driver, or adjusting endpoint halt status.
- */
-
-static char *decode_ep0stage(u8 stage)
-{
-	switch(stage) {
-	case MGC_END0_STAGE_SETUP:	return "idle";
-	case MGC_END0_STAGE_TX:		return "in";
-	case MGC_END0_STAGE_RX:		return "out";
-	case MGC_END0_STAGE_ACKWAIT:	return "wait";
-	case MGC_END0_STAGE_STATUSIN:	return "in/status";
-	case MGC_END0_STAGE_STATUSOUT:	return "out/status";
-	default:			return "?";
-	}
-}
-
-/* handle a standard GET_STATUS request
- * Context:  caller holds controller lock
- */
-static int service_tx_status_request(
-	struct musb *musb,
-	const struct usb_ctrlrequest *pControlRequest)
-{
-	void __iomem	*pBase = musb->pRegs;
-	int handled = 1;
-	u8 bResult[2], bEnd = 0;
-	const u8 bRecip = pControlRequest->bRequestType & USB_RECIP_MASK;
-
-	bResult[1] = 0;
-
-	switch (bRecip) {
-	case USB_RECIP_DEVICE:
-		bResult[0] = musb->is_self_powered << USB_DEVICE_SELF_POWERED;
-		bResult[0] |= musb->may_wakeup << USB_DEVICE_REMOTE_WAKEUP;
-#ifdef CONFIG_USB_MUSB_OTG
-		if (musb->g.is_otg) {
-			bResult[0] |= musb->g.b_hnp_enable
-				<< USB_DEVICE_B_HNP_ENABLE;
-			bResult[0] |= musb->g.a_alt_hnp_support
-				<< USB_DEVICE_A_ALT_HNP_SUPPORT;
-			bResult[0] |= musb->g.a_hnp_support
-				<< USB_DEVICE_A_HNP_SUPPORT;
-		}
-#endif
-		break;
-
-	case USB_RECIP_INTERFACE:
-		bResult[0] = 0;
-		break;
-
-	case USB_RECIP_ENDPOINT: {
-		int		is_in;
-		struct musb_ep	*ep;
-		u16		tmp;
-		void __iomem	*regs;
-
-		bEnd = (u8) pControlRequest->wIndex;
-		if (!bEnd) {
-			bResult[0] = 0;
-			break;
-		}
-
-		is_in = bEnd & USB_DIR_IN;
-		if (is_in) {
-			bEnd &= 0x0f;
-			ep = &musb->aLocalEnd[bEnd].ep_in;
-		} else {
-			ep = &musb->aLocalEnd[bEnd].ep_out;
-		}
-		regs = musb->aLocalEnd[bEnd].regs;
-
-		if (bEnd >= MUSB_C_NUM_EPS || !ep->desc) {
-			handled = -EINVAL;
-			break;
-		}
-
-		MGC_SelectEnd(pBase, bEnd);
-		if (is_in)
-			tmp = musb_readw(regs, MGC_O_HDRC_TXCSR)
-						& MGC_M_TXCSR_P_SENDSTALL;
-		else
-			tmp = musb_readw(regs, MGC_O_HDRC_RXCSR)
-						& MGC_M_RXCSR_P_SENDSTALL;
-		MGC_SelectEnd(pBase, 0);
-
-		bResult[0] = tmp ? 1 : 0;
-		} break;
-
-	default:
-		/* class, vendor, etc ... delegate */
-		handled = 0;
-		break;
-	}
-
-	/* fill up the fifo; caller updates csr0 */
-	if (handled > 0) {
-		u16	len = le16_to_cpu(pControlRequest->wLength);
-
-		if (len > 2)
-			len = 2;
-		musb_write_fifo(&musb->aLocalEnd[0], len, bResult);
-	}
-
-	return handled;
-}
-
-/*
- * handle a control-IN request, the end0 buffer contains the current request
- * that is supposed to be a standard control request. Assumes the fifo to
- * be at least 2 bytes long.
- *
- * @return 0 if the request was NOT HANDLED,
- * < 0 when error
- * > 0 when the request is processed
- *
- * Context:  caller holds controller lock
- */
-static int
-service_in_request(struct musb *musb,
-		const struct usb_ctrlrequest *pControlRequest)
-{
-	int handled = 0;	/* not handled */
-
-	if ((pControlRequest->bRequestType & USB_TYPE_MASK)
-			== USB_TYPE_STANDARD) {
-		switch (pControlRequest->bRequest) {
-		case USB_REQ_GET_STATUS:
-			handled = service_tx_status_request(musb,
-					pControlRequest);
-			break;
-
-		/* case USB_REQ_SYNC_FRAME: */
-
-		default:
-			break;
-		}
-	}
-	return handled;
-}
-
-/*
- * Context:  caller holds controller lock
- */
-static void musb_g_ep0_giveback(struct musb *musb, struct usb_request *req)
-{
-	musb->ep0_state = MGC_END0_STAGE_SETUP;
-	musb_g_giveback(&musb->aLocalEnd[0].ep_in, req, 0);
-}
-
-/*
- * Handle all control requests with no DATA stage, including standard
- * requests such as:
- * USB_REQ_SET_CONFIGURATION, USB_REQ_SET_INTERFACE, unrecognized
- *	always delegated to the gadget driver
- * USB_REQ_SET_ADDRESS, USB_REQ_CLEAR_FEATURE, USB_REQ_SET_FEATURE
- *	always handled here, except for class/vendor/... features
- *
- * Context:  caller holds controller lock
- */
-static int
-service_zero_data_request(struct musb *musb,
-		struct usb_ctrlrequest *pControlRequest)
-__releases(musb->Lock)
-__acquires(musb->Lock)
-{
-	int handled = -EINVAL;
-	void __iomem *pBase = musb->pRegs;
-	const u8 bRecip = pControlRequest->bRequestType & USB_RECIP_MASK;
-
-	/* the gadget driver handles everything except what we MUST handle */
-	if ((pControlRequest->bRequestType & USB_TYPE_MASK)
-			== USB_TYPE_STANDARD) {
-		switch (pControlRequest->bRequest) {
-		case USB_REQ_SET_ADDRESS:
-			/* change it after the status stage */
-			musb->bSetAddress = TRUE;
-			musb->bAddress = (u8) (pControlRequest->wValue & 0x7f);
-			handled = 1;
-			break;
-
-		case USB_REQ_CLEAR_FEATURE:
-			switch (bRecip) {
-			case USB_RECIP_DEVICE:
-				if (pControlRequest->wValue
-						!= USB_DEVICE_REMOTE_WAKEUP)
-					break;
-				musb->may_wakeup = 0;
-				handled = 1;
-				break;
-			case USB_RECIP_INTERFACE:
-				break;
-			case USB_RECIP_ENDPOINT:{
-				const u8 bEnd = pControlRequest->wIndex & 0x0f;
-				struct musb_ep *pEnd;
-
-				if (bEnd == 0
-						|| bEnd >= MUSB_C_NUM_EPS
-						|| pControlRequest->wValue
-							!= USB_ENDPOINT_HALT)
-					break;
-
-				if (pControlRequest->wIndex & USB_DIR_IN)
-					pEnd = &musb->aLocalEnd[bEnd].ep_in;
-				else
-					pEnd = &musb->aLocalEnd[bEnd].ep_out;
-				if (!pEnd->desc)
-					break;
-
-				/* REVISIT do it directly, no locking games */
-				spin_unlock(&musb->Lock);
-				musb_gadget_set_halt(&pEnd->end_point, 0);
-				spin_lock(&musb->Lock);
-
-				/* select ep0 again */
-				MGC_SelectEnd(pBase, 0);
-				handled = 1;
-				} break;
-			default:
-				/* class, vendor, etc ... delegate */
-				handled = 0;
-				break;
-			}
-			break;
-
-		case USB_REQ_SET_FEATURE:
-			switch (bRecip) {
-			case USB_RECIP_DEVICE:
-				handled = 1;
-				switch (pControlRequest->wValue) {
-				case USB_DEVICE_REMOTE_WAKEUP:
-					musb->may_wakeup = 1;
-					break;
-				case USB_DEVICE_TEST_MODE:
-					if (musb->g.speed != USB_SPEED_HIGH)
-						goto stall;
-					if (pControlRequest->wIndex & 0xff)
-						goto stall;
-
-					switch (pControlRequest->wIndex >> 8) {
-					case 1:
-						pr_debug("TEST_J\n");
-						/* TEST_J */
-						musb->bTestModeValue =
-							MGC_M_TEST_J;
-						break;
-					case 2:
-						/* TEST_K */
-						pr_debug("TEST_K\n");
-						musb->bTestModeValue =
-							MGC_M_TEST_K;
-						break;
-					case 3:
-						/* TEST_SE0_NAK */
-						pr_debug("TEST_SE0_NAK\n");
-						musb->bTestModeValue =
-							MGC_M_TEST_SE0_NAK;
-						break;
-					case 4:
-						/* TEST_PACKET */
-						pr_debug("TEST_PACKET\n");
-						musb->bTestModeValue =
-							MGC_M_TEST_PACKET;
-						break;
-					default:
-						goto stall;
-					}
-
-					/* enter test mode after irq */
-					if (handled > 0)
-						musb->bTestMode = TRUE;
-					break;
-#ifdef CONFIG_USB_MUSB_OTG
-				case USB_DEVICE_B_HNP_ENABLE:
-					if (!musb->g.is_otg)
-						goto stall;
-					{ u8 devctl;
-					musb->g.b_hnp_enable = 1;
-					devctl = musb_readb(pBase,
-							MGC_O_HDRC_DEVCTL);
-					/* NOTE:  at least DaVinci doesn't
-					 * like to set HR ...
-					 */
-					DBG(1, "set HR\n");
-					musb_writeb(pBase, MGC_O_HDRC_DEVCTL,
-						devctl | MGC_M_DEVCTL_HR);
-					}
-					break;
-				case USB_DEVICE_A_HNP_SUPPORT:
-					if (!musb->g.is_otg)
-						goto stall;
-					musb->g.a_hnp_support = 1;
-					break;
-				case USB_DEVICE_A_ALT_HNP_SUPPORT:
-					if (!musb->g.is_otg)
-						goto stall;
-					musb->g.a_alt_hnp_support = 1;
-					break;
-#endif
-stall:
-				default:
-					handled = -EINVAL;
-					break;
-				}
-				break;
-
-			case USB_RECIP_INTERFACE:
-				break;
-
-			case USB_RECIP_ENDPOINT:{
-				const u8		bEnd =
-					pControlRequest->wIndex & 0x0f;
-				struct musb_ep		*pEnd;
-				struct musb_hw_ep	*ep;
-				void __iomem		*regs;
-				int			is_in;
-				u16			csr;
-
-				if (bEnd == 0
-						|| bEnd >= MUSB_C_NUM_EPS
-						|| pControlRequest->wValue
-							!= USB_ENDPOINT_HALT)
-					break;
-
-				ep = musb->aLocalEnd + bEnd;
-				regs = ep->regs;
-				is_in = pControlRequest->wIndex & USB_DIR_IN;
-				if (is_in)
-					pEnd = &ep->ep_in;
-				else
-					pEnd = &ep->ep_out;
-				if (!pEnd->desc)
-					break;
-
-				MGC_SelectEnd(pBase, bEnd);
-				if (is_in) {
-					csr = musb_readw(regs,
-							MGC_O_HDRC_TXCSR);
-					if (csr & MGC_M_TXCSR_FIFONOTEMPTY)
-						csr |= MGC_M_TXCSR_FLUSHFIFO;
-					csr |= MGC_M_TXCSR_P_SENDSTALL
-						| MGC_M_TXCSR_CLRDATATOG
-						| MGC_M_TXCSR_P_WZC_BITS;
-					musb_writew(regs, MGC_O_HDRC_TXCSR,
-							csr);
-				} else {
-					csr = musb_readw(regs,
-							MGC_O_HDRC_RXCSR);
-					csr |= MGC_M_RXCSR_P_SENDSTALL
-						| MGC_M_RXCSR_FLUSHFIFO
-						| MGC_M_RXCSR_CLRDATATOG
-						| MGC_M_TXCSR_P_WZC_BITS;
-					musb_writew(regs, MGC_O_HDRC_RXCSR,
-							csr);
-				}
-
-				/* select ep0 again */
-				MGC_SelectEnd(pBase, 0);
-				handled = 1;
-				} break;
-
-			default:
-				/* class, vendor, etc ... delegate */
-				handled = 0;
-				break;
-			}
-			break;
-		default:
-			/* delegate SET_CONFIGURATION, etc */
-			handled = 0;
-		}
-	} else
-		handled = 0;
-	return handled;
-}
-
-/* we have an ep0out data packet
- * Context:  caller holds controller lock
- */
-static void ep0_rxstate(struct musb *this)
-{
-	void __iomem		*regs = this->control_ep->regs;
-	struct usb_request	*req;
-	u16			tmp;
-
-	req = next_ep0_request(this);
-
-	/* read packet and ack; or stall because of gadget driver bug:
-	 * should have provided the rx buffer before setup() returned.
-	 */
-	if (req) {
-		void		*buf = req->buf + req->actual;
-		unsigned	len = req->length - req->actual;
-
-		/* read the buffer */
-		tmp = musb_readb(regs, MGC_O_HDRC_COUNT0);
-		if (tmp > len) {
-			req->status = -EOVERFLOW;
-			tmp = len;
-		}
-		musb_read_fifo(&this->aLocalEnd[0], tmp, buf);
-		req->actual += tmp;
-		tmp = MGC_M_CSR0_P_SVDRXPKTRDY;
-		if (tmp < 64 || req->actual == req->length) {
-			this->ep0_state = MGC_END0_STAGE_STATUSIN;
-			tmp |= MGC_M_CSR0_P_DATAEND;
-		} else
-			req = NULL;
-	} else
-		tmp = MGC_M_CSR0_P_SVDRXPKTRDY | MGC_M_CSR0_P_SENDSTALL;
-	musb_writew(regs, MGC_O_HDRC_CSR0, tmp);
-
-
-	/* NOTE:  we "should" hold off reporting DATAEND and going to
-	 * STATUSIN until after the completion handler decides whether
-	 * to issue a stall instead, since this hardware can do that.
-	 */
-	if (req)
-		musb_g_ep0_giveback(this, req);
-}
-
-/*
- * transmitting to the host (IN), this code might be called from IRQ
- * and from kernel thread.
- *
- * Context:  caller holds controller lock
- */
-static void ep0_txstate(struct musb *musb)
-{
-	void __iomem		*regs = musb->control_ep->regs;
-	struct usb_request	*pRequest = next_ep0_request(musb);
-	u16			wCsrVal = MGC_M_CSR0_TXPKTRDY;
-	u8			*pFifoSource;
-	u8			wFifoCount;
-
-	if (!pRequest) {
-		// WARN_ON(1);
-		DBG(2, "odd; csr0 %04x\n", musb_readw(regs, MGC_O_HDRC_CSR0));
-		return;
-	}
-
-	/* load the data */
-	pFifoSource = (u8 *) pRequest->buf + pRequest->actual;
-	wFifoCount = min((unsigned) MGC_END0_FIFOSIZE,
-		pRequest->length - pRequest->actual);
-	musb_write_fifo(&musb->aLocalEnd[0], wFifoCount, pFifoSource);
-	pRequest->actual += wFifoCount;
-
-	/* update the flags */
-	if (wFifoCount < MUSB_MAX_END0_PACKET
-			|| pRequest->actual == pRequest->length) {
-		musb->ep0_state = MGC_END0_STAGE_STATUSOUT;
-		wCsrVal |= MGC_M_CSR0_P_DATAEND;
-	} else
-		pRequest = NULL;
-
-	/* send it out, triggering a "txpktrdy cleared" irq */
-	musb_writew(regs, MGC_O_HDRC_CSR0, wCsrVal);
-
-	/* report completions as soon as the fifo's loaded; there's no
-	 * win in waiting till this last packet gets acked.  (other than
-	 * very precise fault reporting, needed by USB TMC; possible with
-	 * this hardware, but not usable from portable gadget drivers.)
-	 */
-	if (pRequest)
-		musb_g_ep0_giveback(musb, pRequest);
-}
-
-/*
- * Read a SETUP packet (struct usb_ctrlrequest) from the hardware.
- * Fields are left in USB byte-order.
- *
- * Context:  caller holds controller lock.
- */
-static void
-musb_read_setup(struct musb *musb, struct usb_ctrlrequest *req)
-{
-	struct usb_request	*r;
-	void __iomem		*regs = musb->control_ep->regs;
-
-	musb_read_fifo(&musb->aLocalEnd[0], sizeof *req, (u8 *)req);
-
-	/* NOTE:  earlier 2.6 versions changed setup packets to host
-	 * order, but now USB packets always stay in USB byte order.
-	 */
-	DBG(3, "SETUP req%02x.%02x v%04x i%04x l%d\n",
-		req->bRequestType,
-		req->bRequest,
-		le16_to_cpu(req->wValue),
-		le16_to_cpu(req->wIndex),
-		le16_to_cpu(req->wLength));
-
-	/* clean up any leftover transfers */
-	r = next_ep0_request(musb);
-	if (r)
-		musb_g_ep0_giveback(musb, r);
-
-	/* For zero-data requests we want to delay the STATUS stage to
-	 * avoid SETUPEND errors.  If we read data (OUT), delay accepting
-	 * packets until there's a buffer to store them in.
-	 *
-	 * If we write data, the controller acts happier if we enable
-	 * the TX FIFO right away, and give the controller a moment
-	 * to switch modes...
-	 */
-	musb->bSetAddress = FALSE;
-	musb->ackpend = MGC_M_CSR0_P_SVDRXPKTRDY;
-	if (req->wLength == 0) {
-		if (req->bRequestType & USB_DIR_IN)
-			musb->ackpend |= MGC_M_CSR0_TXPKTRDY;
-		musb->ep0_state = MGC_END0_STAGE_ACKWAIT;
-	} else if (req->bRequestType & USB_DIR_IN) {
-		musb->ep0_state = MGC_END0_STAGE_TX;
-		musb_writew(regs, MGC_O_HDRC_CSR0, MGC_M_CSR0_P_SVDRXPKTRDY);
-		while ((musb_readw(regs, MGC_O_HDRC_CSR0)
-				& MGC_M_CSR0_RXPKTRDY) != 0)
-			cpu_relax();
-		musb->ackpend = 0;
-	} else
-		musb->ep0_state = MGC_END0_STAGE_RX;
-}
-
-static int
-forward_to_driver(struct musb *musb,
-		const struct usb_ctrlrequest *pControlRequest)
-__releases(musb->Lock)
-__acquires(musb->Lock)
-{
-	int retval;
-	if (!musb->pGadgetDriver)
-		return -EOPNOTSUPP;
-	spin_unlock(&musb->Lock);
-	retval = musb->pGadgetDriver->setup(&musb->g, pControlRequest);
-	spin_lock(&musb->Lock);
-	return retval;
-}
-
-/*
- * Handle peripheral ep0 interrupt
- *
- * Context: irq handler; we won't re-enter the driver that way.
- */
-irqreturn_t musb_g_ep0_irq(struct musb *musb)
-{
-	u16		wCsrVal;
-	u16		wCount;
-	void __iomem	*pBase = musb->pRegs;
-	void __iomem	*regs = musb->aLocalEnd[0].regs;
-	irqreturn_t	retval = IRQ_NONE;
-
-	MGC_SelectEnd(pBase, 0);	/* select ep0 */
-	wCsrVal = musb_readw(regs, MGC_O_HDRC_CSR0);
-	wCount = musb_readb(regs, MGC_O_HDRC_COUNT0);
-
-	DBG(4, "csr %04x, count %d, myaddr %d, ep0stage %s\n",
-			wCsrVal, wCount,
-			musb_readb(pBase, MGC_O_HDRC_FADDR),
-			decode_ep0stage(musb->ep0_state));
-
-	/* I sent a stall.. need to acknowledge it now.. */
-	if (wCsrVal & MGC_M_CSR0_P_SENTSTALL) {
-		musb_writew(regs, MGC_O_HDRC_CSR0,
-				wCsrVal & ~MGC_M_CSR0_P_SENTSTALL);
-		retval = IRQ_HANDLED;
-		musb->ep0_state = MGC_END0_STAGE_SETUP;
-		wCsrVal = musb_readw(regs, MGC_O_HDRC_CSR0);
-	}
-
-	/* request ended "early" */
-	if (wCsrVal & MGC_M_CSR0_P_SETUPEND) {
-		musb_writew(regs, MGC_O_HDRC_CSR0, MGC_M_CSR0_P_SVDSETUPEND);
-		retval = IRQ_HANDLED;
-		musb->ep0_state = MGC_END0_STAGE_SETUP;
-		wCsrVal = musb_readw(regs, MGC_O_HDRC_CSR0);
-		/* NOTE:  request may need completion */
-	}
-
-	/* docs from Mentor only describe tx, rx, and idle/setup states.
-	 * we need to handle nuances around status stages, and also the
-	 * case where status and setup stages come back-to-back ...
-	 */
-	switch (musb->ep0_state) {
-
-	case MGC_END0_STAGE_TX:
-		/* irq on clearing txpktrdy */
-		if ((wCsrVal & MGC_M_CSR0_TXPKTRDY) == 0) {
-			ep0_txstate(musb);
-			retval = IRQ_HANDLED;
-		}
-		break;
-
-	case MGC_END0_STAGE_RX:
-		/* irq on set rxpktrdy */
-		if (wCsrVal & MGC_M_CSR0_RXPKTRDY) {
-			ep0_rxstate(musb);
-			retval = IRQ_HANDLED;
-		}
-		break;
-
-	case MGC_END0_STAGE_STATUSIN:
-		/* end of sequence #2 (OUT/RX state) or #3 (no data) */
-
-		/* update address (if needed) only @ the end of the
-		 * status phase per usb spec, which also guarantees
-		 * we get 10 msec to receive this irq... until this
-		 * is done we won't see the next packet.
-		 */
-		if (musb->bSetAddress) {
-			musb->bSetAddress = FALSE;
-			musb_writeb(pBase, MGC_O_HDRC_FADDR, musb->bAddress);
-		}
-
-		/* enter test mode if needed (exit by reset) */
-		else if (musb->bTestMode) {
-			DBG(1, "entering TESTMODE\n");
-
-			if (MGC_M_TEST_PACKET == musb->bTestModeValue)
-				musb_load_testpacket(musb);
-
-			musb_writeb(pBase, MGC_O_HDRC_TESTMODE,
-					musb->bTestModeValue);
-		}
-		/* FALLTHROUGH */
-
-	case MGC_END0_STAGE_STATUSOUT:
-		/* end of sequence #1: write to host (TX state) */
-		{
-			struct usb_request	*req;
-
-			req = next_ep0_request(musb);
-			if (req)
-				musb_g_ep0_giveback(musb, req);
-		}
-		retval = IRQ_HANDLED;
-		musb->ep0_state = MGC_END0_STAGE_SETUP;
-		/* FALLTHROUGH */
-
-	case MGC_END0_STAGE_SETUP:
-		if (wCsrVal & MGC_M_CSR0_RXPKTRDY) {
-			struct usb_ctrlrequest	setup;
-			int			handled = 0;
-
-			if (wCount != 8) {
-				ERR("SETUP packet len %d != 8 ?\n", wCount);
-				break;
-			}
-			musb_read_setup(musb, &setup);
-			retval = IRQ_HANDLED;
-
-			/* sometimes the RESET won't be reported */
-			if (unlikely(musb->g.speed == USB_SPEED_UNKNOWN)) {
-				u8	power;
-
-				printk(KERN_NOTICE "%s: peripheral reset "
-						"irq lost!\n",
-						musb_driver_name);
-				power = musb_readb(pBase, MGC_O_HDRC_POWER);
-				musb->g.speed = (power & MGC_M_POWER_HSMODE)
-					? USB_SPEED_HIGH : USB_SPEED_FULL;
-
-			}
-
-			switch (musb->ep0_state) {
-
-			/* sequence #3 (no data stage), includes requests
-			 * we can't forward (notably SET_ADDRESS and the
-			 * device/endpoint feature set/clear operations)
-			 * plus SET_CONFIGURATION and others we must
-			 */
-			case MGC_END0_STAGE_ACKWAIT:
-				handled = service_zero_data_request(
-						musb, &setup);
-
-				/* status stage might be immediate */
-				if (handled > 0) {
-					musb->ackpend |= MGC_M_CSR0_P_DATAEND;
-					musb->ep0_state =
-						MGC_END0_STAGE_STATUSIN;
-				}
-				break;
-
-			/* sequence #1 (IN to host), includes GET_STATUS
-			 * requests that we can't forward, GET_DESCRIPTOR
-			 * and others that we must
-			 */
-			case MGC_END0_STAGE_TX:
-				handled = service_in_request(musb, &setup);
-				if (handled > 0) {
-					musb->ackpend = MGC_M_CSR0_TXPKTRDY
-						| MGC_M_CSR0_P_DATAEND;
-					musb->ep0_state =
-						MGC_END0_STAGE_STATUSOUT;
-				}
-				break;
-
-			/* sequence #2 (OUT from host), always forward */
-			default:		/* MGC_END0_STAGE_RX */
-				break;
-			}
-
-			DBG(3, "handled %d, csr %04x, ep0stage %s\n",
-				handled, wCsrVal,
-				decode_ep0stage(musb->ep0_state));
-
-			/* unless we need to delegate this to the gadget
-			 * driver, we know how to wrap this up:  csr0 has
-			 * not yet been written.
-			 */
-			if (handled < 0)
-				goto stall;
-			else if (handled > 0)
-				goto finish;
-
-			handled = forward_to_driver(musb, &setup);
-			if (handled < 0) {
-				MGC_SelectEnd(pBase, 0);
-stall:
-				DBG(3, "stall (%d)\n", handled);
-				musb->ackpend |= MGC_M_CSR0_P_SENDSTALL;
-				musb->ep0_state = MGC_END0_STAGE_SETUP;
-finish:
-				musb_writew(regs, MGC_O_HDRC_CSR0,
-						musb->ackpend);
-				musb->ackpend = 0;
-			}
-		}
-		break;
-
-	case MGC_END0_STAGE_ACKWAIT:
-		/* This should not happen. But happens with tusb6010 with
-		 * g_file_storage and high speed. Do nothing.
-		 */
-		retval = IRQ_HANDLED;
-		break;
-
-	default:
-		/* "can't happen" */
-		WARN_ON(1);
-		musb_writew(regs, MGC_O_HDRC_CSR0, MGC_M_CSR0_P_SENDSTALL);
-		musb->ep0_state = MGC_END0_STAGE_SETUP;
-		break;
-	}
-
-	return retval;
-}
-
-
-static int
-musb_g_ep0_enable(struct usb_ep *ep, const struct usb_endpoint_descriptor *desc)
-{
-	/* always enabled */
-	return -EINVAL;
-}
-
-static int musb_g_ep0_disable(struct usb_ep *e)
-{
-	/* always enabled */
-	return -EINVAL;
-}
-
-static void *musb_g_ep0_alloc_buffer(struct usb_ep *ep, unsigned bytes,
-			dma_addr_t * dma, gfp_t gfp_flags)
-{
-	*dma = DMA_ADDR_INVALID;
-	return kmalloc(bytes, gfp_flags);
-}
-
-static void musb_g_ep0_free_buffer(struct usb_ep *ep, void *address,
-			dma_addr_t dma, unsigned bytes)
-{
-	kfree(address);
-}
-
-static int
-musb_g_ep0_queue(struct usb_ep *e, struct usb_request *r, gfp_t gfp_flags)
-{
-	struct musb_ep		*ep;
-	struct musb_request	*req;
-	struct musb		*musb;
-	int			status;
-	unsigned long		lockflags;
-	void __iomem		*regs;
-
-	if (!e || !r)
-		return -EINVAL;
-
-	ep = to_musb_ep(e);
-	musb = ep->pThis;
-	regs = musb->control_ep->regs;
-
-	req = to_musb_request(r);
-	req->musb = musb;
-	req->request.actual = 0;
-	req->request.status = -EINPROGRESS;
-	req->bTx = ep->is_in;
-
-	spin_lock_irqsave(&musb->Lock, lockflags);
-
-	if (!list_empty(&ep->req_list)) {
-		status = -EBUSY;
-		goto cleanup;
-	}
-
-	switch (musb->ep0_state) {
-	case MGC_END0_STAGE_RX:		/* control-OUT data */
-	case MGC_END0_STAGE_TX:		/* control-IN data */
-	case MGC_END0_STAGE_ACKWAIT:	/* zero-length data */
-		status = 0;
-		break;
-	default:
-		DBG(1, "ep0 request queued in state %d\n",
-				musb->ep0_state);
-		status = -EINVAL;
-		goto cleanup;
-	}
-
-	/* add request to the list */
-	list_add_tail(&(req->request.list), &(ep->req_list));
-
-	DBG(3, "queue to %s (%s), length=%d\n",
-			ep->name, ep->is_in ? "IN/TX" : "OUT/RX",
-			req->request.length);
-
-	MGC_SelectEnd(musb->pRegs, 0);
-
-	/* sequence #1, IN ... start writing the data */
-	if (musb->ep0_state == MGC_END0_STAGE_TX)
-		ep0_txstate(musb);
-
-	/* sequence #3, no-data ... issue IN status */
-	else if (musb->ep0_state == MGC_END0_STAGE_ACKWAIT) {
-		if (req->request.length)
-			status = -EINVAL;
-		else {
-			musb->ep0_state = MGC_END0_STAGE_STATUSIN;
-			musb_writew(regs, MGC_O_HDRC_CSR0,
-					musb->ackpend | MGC_M_CSR0_P_DATAEND);
-			musb->ackpend = 0;
-			musb_g_ep0_giveback(ep->pThis, r);
-		}
-
-	/* else for sequence #2 (OUT), caller provides a buffer
-	 * before the next packet arrives.  deferred responses
-	 * (after SETUP is acked) are racey.
-	 */
-	} else if (musb->ackpend) {
-		musb_writew(regs, MGC_O_HDRC_CSR0, musb->ackpend);
-		musb->ackpend = 0;
-	}
-
-cleanup:
-	spin_unlock_irqrestore(&musb->Lock, lockflags);
-	return status;
-}
-
-static int
-musb_g_ep0_dequeue(struct usb_ep *ep, struct usb_request *req)
-{
-	/* we just won't support this */
-	return -EINVAL;
-}
-
-static int musb_g_ep0_halt(struct usb_ep *e, int value)
-{
-	struct musb_ep		*ep;
-	struct musb		*musb;
-	void __iomem		*base, *regs;
-	unsigned long		flags;
-	int			status;
-	u16			csr;
-
-	if (!e || !value)
-		return -EINVAL;
-
-	ep = to_musb_ep(e);
-	musb = ep->pThis;
-	base = musb->pRegs;
-	regs = musb->control_ep->regs;
-
-	spin_lock_irqsave(&musb->Lock, flags);
-
-	if (!list_empty(&ep->req_list)) {
-		status = -EBUSY;
-		goto cleanup;
-	}
-
-	switch (musb->ep0_state) {
-	case MGC_END0_STAGE_TX:		/* control-IN data */
-	case MGC_END0_STAGE_ACKWAIT:	/* STALL for zero-length data */
-	case MGC_END0_STAGE_RX:		/* control-OUT data */
-		status = 0;
-
-		MGC_SelectEnd(base, 0);
-		csr = musb_readw(regs, MGC_O_HDRC_CSR0);
-		csr |= MGC_M_CSR0_P_SENDSTALL;
-		musb_writew(regs, MGC_O_HDRC_CSR0, csr);
-		musb->ep0_state = MGC_END0_STAGE_SETUP;
-		break;
-	default:
-		DBG(1, "ep0 can't halt in state %d\n", musb->ep0_state);
-		status = -EINVAL;
-	}
-
-cleanup:
-	spin_unlock_irqrestore(&musb->Lock, flags);
-	return status;
-}
-
-const struct usb_ep_ops musb_g_ep0_ops = {
-	.enable		= musb_g_ep0_enable,
-	.disable	= musb_g_ep0_disable,
-	.alloc_request	= musb_alloc_request,
-	.free_request	= musb_free_request,
-	.alloc_buffer	= musb_g_ep0_alloc_buffer,
-	.free_buffer	= musb_g_ep0_free_buffer,
-	.queue		= musb_g_ep0_queue,
-	.dequeue	= musb_g_ep0_dequeue,
-	.set_halt	= musb_g_ep0_halt,
-	.fifo_status	= NULL,
-	.fifo_flush	= NULL,
-};
diff -ruN linux-omap-2.6/drivers/usb/musb/Kconfig maemo_src/drivers/usb/musb/Kconfig
--- linux-omap-2.6/drivers/usb/musb/Kconfig	2011-02-06 20:17:25.833333273 -0500
+++ maemo_src/drivers/usb/musb/Kconfig	2007-10-02 03:09:32.000000000 -0400
@@ -55,6 +55,26 @@
 	  (a high speed serial link).  It can use system-specific external
 	  DMA controllers.
 
+config USB_TUSB6010_TEST
+	boolean "TUSB 6010 loopback test support"
+	depends on SYSFS
+	depends on USB_TUSB6010
+	help
+	  This option allows you to test the functionality of the
+	  TUSB 6010 chip using a loopback dongle.
+
+	  In order for the test to work, the dongle musb connect DM to DP
+	  over a 1k resitor when VBUS is enabled. By using direct OTG PHY
+	  register access DM line is raised by the test function, which
+	  then also raises DP line if the dongle is connected.
+
+	  To run the test, connect the loopback dongle to the USB
+	  interface on the board and type the following on the board:
+
+	  # cat /sys/devices/platform/musb_hdrc/looptest
+
+	  If unsure, say N here.
+
 choice
 	prompt "Driver Mode"
 	depends on USB_MUSB_HDRC
@@ -128,8 +148,14 @@
 	select USB_OTG if USB_GADGET_MUSB_HDRC
 	default y
 
+config USB_MUSB_HSET
+	bool 'High Speed Electrical Test support for MUSB'
+	depends on USB_MUSB_HDRC
+	default y
+	help
+	  High Speed Electrical Test support for MUSB
 
-config USB_INVENTRA_FIFO
+config MUSB_PIO_ONLY
 	bool 'Disable DMA (always use PIO)'
 	depends on USB_MUSB_HDRC
 	default y if USB_TUSB6010
@@ -144,28 +170,28 @@
 
 config USB_INVENTRA_DMA
 	bool
-	depends on USB_MUSB_HDRC && !USB_INVENTRA_FIFO
+	depends on USB_MUSB_HDRC && !MUSB_PIO_ONLY
 	default ARCH_OMAP2430 || ARCH_OMAP343X
 	help
 	  Enable DMA transfers using Mentor's engine.
 
 config USB_TI_CPPI_DMA
 	bool
-	depends on USB_MUSB_HDRC && !USB_INVENTRA_FIFO
+	depends on USB_MUSB_HDRC && !MUSB_PIO_ONLY
 	default ARCH_DAVINCI
 	help
 	  Enable DMA transfers when TI CPPI DMA is available.
 
 config USB_TUSB_OMAP_DMA
 	bool
-	depends on USB_MUSB_HDRC && !USB_INVENTRA_FIFO
+	depends on USB_MUSB_HDRC && !MUSB_PIO_ONLY
 	depends on USB_TUSB6010
 	depends on ARCH_OMAP
 	default y
 	help
 	  Enable DMA transfers on TUSB 6010 when OMAP DMA is available.
 
-config	USB_INVENTRA_HCD_LOGGING
+config	USB_MUSB_LOGLEVEL
 	depends on USB_MUSB_HDRC
 	int  'Logging Level (0 - none / 3 - annoying / ... )'
 	default 0
diff -ruN linux-omap-2.6/drivers/usb/musb/Makefile maemo_src/drivers/usb/musb/Makefile
--- linux-omap-2.6/drivers/usb/musb/Makefile	2011-02-06 20:17:25.833333273 -0500
+++ maemo_src/drivers/usb/musb/Makefile	2007-10-02 03:09:32.000000000 -0400
@@ -2,7 +2,7 @@
 # for USB OTG silicon based on Mentor Graphics INVENTRA designs
 #
 
-musb_hdrc-objs := plat_uds.o
+musb_hdrc-objs := musb_core.o
 
 obj-$(CONFIG_USB_MUSB_HDRC)	+= musb_hdrc.o
 
@@ -14,24 +14,32 @@
 	musb_hdrc-objs	+= tusb6010.o
 endif
 
+ifeq ($(CONFIG_USB_TUSB6010_TEST),y)
+	musb_hdrc-objs	+= tusb6010_test.o
+endif
+
+ifeq ($(CONFIG_USB_MUSB_HSET),y)
+	musb_hdrc-objs	+= musb_hset.o
+endif
+
 ifeq ($(CONFIG_ARCH_OMAP2430),y)
 	musb_hdrc-objs	+= omap2430.o
 endif
 
 ifeq ($(CONFIG_USB_GADGET_MUSB_HDRC),y)
-	musb_hdrc-objs		+= g_ep0.o musb_gadget.o
+	musb_hdrc-objs		+= musb_gadget_ep0.o musb_gadget.o
 endif
 
 ifeq ($(CONFIG_USB_MUSB_HDRC_HCD),y)
-	musb_hdrc-objs		+= virthub.o musb_host.o
+	musb_hdrc-objs		+= musb_virthub.o musb_host.o
 endif
 
 # the kconfig must guarantee that only one of the
 # possible I/O schemes will be enabled at a time ...
-# PIO (INVENTRA_FIFO), or DMA (several potential schemes).
+# PIO only, or DMA (several potential schemes).
 # though PIO is always there to back up DMA, and for ep0
 
-ifneq ($(CONFIG_USB_INVENTRA_FIFO),y)
+ifneq ($(CONFIG_MUSB_PIO_ONLY),y)
 
   ifeq ($(CONFIG_USB_INVENTRA_DMA),y)
     musb_hdrc-objs		+= musbhsdma.o
@@ -60,7 +68,7 @@
 
 # Debugging
 
-MUSB_DEBUG:=$(CONFIG_USB_INVENTRA_HCD_LOGGING)
+MUSB_DEBUG:=$(CONFIG_USB_MUSB_LOGLEVEL)
 
 ifeq ("$(strip $(MUSB_DEBUG))","")
     ifdef CONFIG_USB_DEBUG
diff -ruN linux-omap-2.6/drivers/usb/musb/musb_core.c maemo_src/drivers/usb/musb/musb_core.c
--- linux-omap-2.6/drivers/usb/musb/musb_core.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/usb/musb/musb_core.c	2011-02-06 20:12:11.269999939 -0500
@@ -0,0 +1,2277 @@
+/*
+ * MUSB OTG driver core code
+ *
+ * Copyright 2005 Mentor Graphics Corporation
+ * Copyright (C) 2005-2006 by Texas Instruments
+ * Copyright (C) 2006-2007 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+/*
+ * Inventra (Multipoint) Dual-Role Controller Driver for Linux.
+ *
+ * This consists of a Host Controller Driver (HCD) and a peripheral
+ * controller driver implementing the "Gadget" API; OTG support is
+ * in the works.  These are normal Linux-USB controller drivers which
+ * use IRQs and have no dedicated thread.
+ *
+ * This version of the driver has only been used with products from
+ * Texas Instruments.  Those products integrate the Inventra logic
+ * with other DMA, IRQ, and bus modules, as well as other logic that
+ * needs to be reflected in this driver.
+ *
+ *
+ * NOTE:  the original Mentor code here was pretty much a collection
+ * of mechanisms that don't seem to have been fully integrated/working
+ * for *any* Linux kernel version.  This version aims at Linux 2.6.now,
+ * Key open issues include:
+ *
+ *  - Lack of host-side transaction scheduling, for all transfer types.
+ *    The hardware doesn't do it; instead, software must.
+ *
+ *    This is not an issue for OTG devices that don't support external
+ *    hubs, but for more "normal" USB hosts it's a user issue that the
+ *    "multipoint" support doesn't scale in the expected ways.  That
+ *    includes DaVinci EVM in a common non-OTG mode.
+ *
+ *      * Control and bulk use dedicated endpoints, and there's as
+ *        yet no mechanism to either (a) reclaim the hardware when
+ *        peripherals are NAKing, which gets complicated with bulk
+ *        endpoints, or (b) use more than a single bulk endpoint in
+ *        each direction.
+ *
+ *        RESULT:  one device may be perceived as blocking another one.
+ *
+ *      * Interrupt and isochronous will dynamically allocate endpoint
+ *        hardware, but (a) there's no record keeping for bandwidth;
+ *        (b) in the common case that few endpoints are available, there
+ *        is no mechanism to reuse endpoints to talk to multiple devices.
+ *
+ *        RESULT:  At one extreme, bandwidth can be overcommitted in
+ *        some hardware configurations, no faults will be reported.
+ *        At the other extreme, the bandwidth capabilities which do
+ *        exist tend to be severely undercommitted.  You can't yet hook
+ *        up both a keyboard and a mouse to an external USB hub.
+ */
+
+/*
+ * This gets many kinds of configuration information:
+ *	- Kconfig for everything user-configurable
+ *	- <asm/arch/hdrc_cnf.h> for SOC or family details
+ *	- platform_device for addressing, irq, and platform_data
+ *	- platform_data is mostly for board-specific informarion
+ *
+ * Most of the conditional compilation will (someday) vanish.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/kobject.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+
+#ifdef	CONFIG_ARM
+#include <asm/arch/hardware.h>
+#include <asm/arch/memory.h>
+#include <asm/mach-types.h>
+#endif
+
+#include "musb_core.h"
+
+
+#ifdef CONFIG_ARCH_DAVINCI
+#include "davinci.h"
+#endif
+
+
+
+#if MUSB_DEBUG > 0
+unsigned debug = MUSB_DEBUG;
+module_param(debug, uint, 0);
+MODULE_PARM_DESC(debug, "initial debug message level");
+
+#define MUSB_VERSION_SUFFIX	"/dbg"
+#endif
+
+#define DRIVER_AUTHOR "Mentor Graphics, Texas Instruments, Nokia"
+#define DRIVER_DESC "Inventra Dual-Role USB Controller Driver"
+
+#define MUSB_VERSION_BASE "6.0"
+
+#ifndef MUSB_VERSION_SUFFIX
+#define MUSB_VERSION_SUFFIX	""
+#endif
+#define MUSB_VERSION	MUSB_VERSION_BASE MUSB_VERSION_SUFFIX
+
+#define DRIVER_INFO DRIVER_DESC ", v" MUSB_VERSION
+
+const char musb_driver_name[] = "musb_hdrc";
+
+MODULE_DESCRIPTION(DRIVER_INFO);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_LICENSE("GPL");
+
+
+/*-------------------------------------------------------------------------*/
+
+static inline struct musb *dev_to_musb(struct device *dev)
+{
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+	/* usbcore insists dev->driver_data is a "struct hcd *" */
+	return hcd_to_musb(dev_get_drvdata(dev));
+#else
+	return dev_get_drvdata(dev);
+#endif
+}
+
+/*-------------------------------------------------------------------------*/
+
+#ifndef CONFIG_USB_TUSB6010
+/*
+ * Load an endpoint's FIFO
+ */
+void musb_write_fifo(struct musb_hw_ep *hw_ep, u16 len, const u8 *src)
+{
+	void __iomem *fifo = hw_ep->fifo;
+
+	prefetch((u8 *)src);
+
+	DBG(4, "%cX ep%d fifo %p count %d buf %p\n",
+			'T', hw_ep->epnum, fifo, len, src);
+
+	/* we can't assume unaligned reads work */
+	if (likely((0x01 & (unsigned long) src) == 0)) {
+		u16	index = 0;
+
+		/* best case is 32bit-aligned source address */
+		if ((0x02 & (unsigned long) src) == 0) {
+			if (len >= 4) {
+				writesl(fifo, src + index, len >> 2);
+				index += len & ~0x03;
+			}
+			if (len & 0x02) {
+				musb_writew(fifo, 0, *(u16 *)&src[index]);
+				index += 2;
+			}
+		} else {
+			if (len >= 2) {
+				writesw(fifo, src + index, len >> 1);
+				index += len & ~0x01;
+			}
+		}
+		if (len & 0x01)
+			musb_writeb(fifo, 0, src[index]);
+	} else  {
+		/* byte aligned */
+		writesb(fifo, src, len);
+	}
+}
+
+/*
+ * Unload an endpoint's FIFO
+ */
+void musb_read_fifo(struct musb_hw_ep *hw_ep, u16 len, u8 *dst)
+{
+	void __iomem *fifo = hw_ep->fifo;
+
+	DBG(4, "%cX ep%d fifo %p count %d buf %p\n",
+			'R', hw_ep->epnum, fifo, len, dst);
+
+	/* we can't assume unaligned writes work */
+	if (likely((0x01 & (unsigned long) dst) == 0)) {
+		u16	index = 0;
+
+		/* best case is 32bit-aligned destination address */
+		if ((0x02 & (unsigned long) dst) == 0) {
+			if (len >= 4) {
+				readsl(fifo, dst, len >> 2);
+				index = len & ~0x03;
+			}
+			if (len & 0x02) {
+				*(u16 *)&dst[index] = musb_readw(fifo, 0);
+				index += 2;
+			}
+		} else {
+			if (len >= 2) {
+				readsw(fifo, dst, len >> 1);
+				index = len & ~0x01;
+			}
+		}
+		if (len & 0x01)
+			dst[index] = musb_readb(fifo, 0);
+	} else  {
+		/* byte aligned */
+		readsb(fifo, dst, len);
+	}
+}
+
+#endif	/* normal PIO */
+
+
+/*-------------------------------------------------------------------------*/
+
+/* for high speed test mode; see USB 2.0 spec 7.1.20 */
+static const u8 musb_test_packet[53] = {
+	/* implicit SYNC then DATA0 to start */
+
+	/* JKJKJKJK x9 */
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	/* JJKKJJKK x8 */
+	0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+	/* JJJJKKKK x8 */
+	0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee,
+	/* JJJJJJJKKKKKKK x8 */
+	0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+	/* JJJJJJJK x8 */
+	0x7f, 0xbf, 0xdf, 0xef, 0xf7, 0xfb, 0xfd,
+	/* JKKKKKKK x10, JK */
+	0xfc, 0x7e, 0xbf, 0xdf, 0xef, 0xf7, 0xfb, 0xfd, 0x7e
+
+	/* implicit CRC16 then EOP to end */
+};
+
+void musb_load_testpacket(struct musb *musb)
+{
+	void __iomem	*regs = musb->endpoints[0].regs;
+
+	musb_ep_select(musb->mregs, 0);
+	musb_write_fifo(musb->control_ep,
+			sizeof(musb_test_packet), musb_test_packet);
+	musb_writew(regs, MUSB_CSR0, MUSB_CSR0_TXPKTRDY);
+}
+EXPORT_SYMBOL(musb_load_testpacket);
+
+/*-------------------------------------------------------------------------*/
+
+const char *otg_state_string(struct musb *musb)
+{
+	switch (musb->xceiv.state) {
+	case OTG_STATE_A_IDLE:		return "a_idle";
+	case OTG_STATE_A_WAIT_VRISE:	return "a_wait_vrise";
+	case OTG_STATE_A_WAIT_BCON:	return "a_wait_bcon";
+	case OTG_STATE_A_HOST:		return "a_host";
+	case OTG_STATE_A_SUSPEND:	return "a_suspend";
+	case OTG_STATE_A_PERIPHERAL:	return "a_peripheral";
+	case OTG_STATE_A_WAIT_VFALL:	return "a_wait_vfall";
+	case OTG_STATE_A_VBUS_ERR:	return "a_vbus_err";
+	case OTG_STATE_B_IDLE:		return "b_idle";
+	case OTG_STATE_B_SRP_INIT:	return "b_srp_init";
+	case OTG_STATE_B_PERIPHERAL:	return "b_peripheral";
+	case OTG_STATE_B_WAIT_ACON:	return "b_wait_acon";
+	case OTG_STATE_B_HOST:		return "b_host";
+	default:			return "UNDEFINED";
+	}
+}
+
+#ifdef	CONFIG_USB_MUSB_OTG
+
+/*
+ * See also USB_OTG_1-3.pdf 6.6.5 Timers
+ * REVISIT: Are the other timers done in the hardware?
+ */
+#define TB_ASE0_BRST		100	/* Min 3.125 ms */
+
+/*
+ * Handles OTG hnp timeouts, such as b_ase0_brst
+ */
+void musb_otg_timer_func(unsigned long data)
+{
+	struct musb	*musb = (struct musb *)data;
+	unsigned long	flags;
+
+	spin_lock_irqsave(&musb->lock, flags);
+	switch (musb->xceiv.state) {
+	case OTG_STATE_B_HOST:
+		break;
+	case OTG_STATE_B_WAIT_ACON:
+		DBG(1, "HNP: b_wait_acon timeout; back to b_peripheral\n");
+		musb_g_disconnect(musb);
+		musb->xceiv.state = OTG_STATE_B_PERIPHERAL;
+		musb->is_active = 0;
+		break;
+	case OTG_STATE_A_WAIT_BCON:
+		DBG(1, "HNP: a_wait_bcon timeout; back to a_host\n");
+		musb_hnp_stop(musb);
+		break;
+	default:
+		DBG(1, "HNP: Unhandled mode %s\n", otg_state_string(musb));
+	}
+	musb->ignore_disconnect = 0;
+	spin_unlock_irqrestore(&musb->lock, flags);
+}
+
+static DEFINE_TIMER(musb_otg_timer, musb_otg_timer_func, 0, 0);
+
+/*
+ * Stops the B-device HNP state. Caller must take care of locking.
+ */
+void musb_hnp_stop(struct musb *musb)
+{
+	struct usb_hcd	*hcd = musb_to_hcd(musb);
+	void __iomem	*mbase = musb->mregs;
+	u8	reg;
+
+	switch (musb->xceiv.state) {
+	case OTG_STATE_A_PERIPHERAL:
+	case OTG_STATE_A_WAIT_VFALL:
+	case OTG_STATE_A_WAIT_BCON:
+		DBG(1, "HNP: Switching back to A-host\n");
+		musb_g_disconnect(musb);
+		musb->xceiv.state = OTG_STATE_A_IDLE;
+		MUSB_HST_MODE(musb);
+		musb->is_active = 0;
+		break;
+	case OTG_STATE_B_HOST:
+		DBG(1, "HNP: Disabling HR\n");
+		hcd->self.is_b_host = 0;
+		musb->xceiv.state = OTG_STATE_B_PERIPHERAL;
+		MUSB_DEV_MODE(musb);
+		reg = musb_readb(mbase, MUSB_POWER);
+		reg |= MUSB_POWER_SUSPENDM;
+		musb_writeb(mbase, MUSB_POWER, reg);
+		/* REVISIT: Start SESSION_REQUEST here? */
+		break;
+	default:
+		DBG(1, "HNP: Stopping in unknown state %s\n",
+			otg_state_string(musb));
+	}
+
+	/*
+	 * When returning to A state after HNP, avoid hub_port_rebounce(),
+	 * which cause occasional OPT A "Did not receive reset after connect"
+	 * errors.
+	 */
+	musb->port1_status &=
+		~(1 << USB_PORT_FEAT_C_CONNECTION);
+}
+
+#endif
+
+/*
+ * Interrupt Service Routine to record USB "global" interrupts.
+ * Since these do not happen often and signify things of
+ * paramount importance, it seems OK to check them individually;
+ * the order of the tests is specified in the manual
+ *
+ * @param musb instance pointer
+ * @param int_usb register contents
+ * @param devctl
+ * @param power
+ */
+
+#define STAGE0_MASK (MUSB_INTR_RESUME | MUSB_INTR_SESSREQ \
+		| MUSB_INTR_VBUSERROR | MUSB_INTR_CONNECT \
+		| MUSB_INTR_RESET)
+
+static irqreturn_t musb_stage0_irq(struct musb *musb, u8 int_usb,
+				u8 devctl, u8 power)
+{
+	irqreturn_t handled = IRQ_NONE;
+	void __iomem *mbase = musb->mregs;
+
+	DBG(3, "<== Power=%02x, DevCtl=%02x, int_usb=0x%x\n", power, devctl,
+		int_usb);
+
+	/* in host mode, the peripheral may issue remote wakeup.
+	 * in peripheral mode, the host may resume the link.
+	 * spurious RESUME irqs happen too, paired with SUSPEND.
+	 */
+	if (int_usb & MUSB_INTR_RESUME) {
+		handled = IRQ_HANDLED;
+		DBG(3, "RESUME (%s)\n", otg_state_string(musb));
+
+		if (devctl & MUSB_DEVCTL_HM) {
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+			switch (musb->xceiv.state) {
+			case OTG_STATE_A_SUSPEND:
+				/* remote wakeup?  later, GetPortStatus
+				 * will stop RESUME signaling
+				 */
+
+				if (power & MUSB_POWER_SUSPENDM) {
+					/* spurious */
+					musb->int_usb &= ~MUSB_INTR_SUSPEND;
+					DBG(2, "Spurious SUSPENDM\n");
+					break;
+				}
+
+				power &= ~MUSB_POWER_SUSPENDM;
+				musb_writeb(mbase, MUSB_POWER,
+						power | MUSB_POWER_RESUME);
+
+				musb->port1_status |=
+						(USB_PORT_STAT_C_SUSPEND << 16)
+						| MUSB_PORT_STAT_RESUME;
+				musb->rh_timer = jiffies
+						+ msecs_to_jiffies(20);
+
+				musb->xceiv.state = OTG_STATE_A_HOST;
+				musb->is_active = 1;
+				usb_hcd_resume_root_hub(musb_to_hcd(musb));
+				break;
+			case OTG_STATE_B_WAIT_ACON:
+				musb->xceiv.state = OTG_STATE_B_PERIPHERAL;
+				musb->is_active = 1;
+				MUSB_DEV_MODE(musb);
+				break;
+			default:
+				WARN("bogus %s RESUME (%s)\n",
+					"host",
+					otg_state_string(musb));
+			}
+#endif
+		} else {
+			switch (musb->xceiv.state) {
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+			case OTG_STATE_A_SUSPEND:
+				/* possibly DISCONNECT is upcoming */
+				musb->xceiv.state = OTG_STATE_A_HOST;
+				usb_hcd_resume_root_hub(musb_to_hcd(musb));
+				break;
+#endif
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+			case OTG_STATE_B_WAIT_ACON:
+			case OTG_STATE_B_PERIPHERAL:
+				/* disconnect while suspended?  we may
+				 * not get a disconnect irq...
+				 */
+				if ((devctl & MUSB_DEVCTL_VBUS)
+						!= (3 << MUSB_DEVCTL_VBUS_SHIFT)
+						) {
+					musb->int_usb |= MUSB_INTR_DISCONNECT;
+					musb->int_usb &= ~MUSB_INTR_SUSPEND;
+					break;
+				}
+				musb_g_resume(musb);
+				break;
+			case OTG_STATE_B_IDLE:
+				musb->int_usb &= ~MUSB_INTR_SUSPEND;
+				break;
+#endif
+			default:
+				WARN("bogus %s RESUME (%s)\n",
+					"peripheral",
+					otg_state_string(musb));
+			}
+		}
+	}
+
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+	/* see manual for the order of the tests */
+	if (int_usb & MUSB_INTR_SESSREQ) {
+		DBG(1, "SESSION_REQUEST (%s)\n", otg_state_string(musb));
+
+		/* IRQ arrives from ID pin sense or (later, if VBUS power
+		 * is removed) SRP.  responses are time critical:
+		 *  - turn on VBUS (with silicon-specific mechanism)
+		 *  - go through A_WAIT_VRISE
+		 *  - ... to A_WAIT_BCON.
+		 * a_wait_vrise_tmout triggers VBUS_ERROR transitions
+		 */
+		musb_writeb(mbase, MUSB_DEVCTL, MUSB_DEVCTL_SESSION);
+		musb->ep0_stage = MUSB_EP0_START;
+		musb->xceiv.state = OTG_STATE_A_IDLE;
+		MUSB_HST_MODE(musb);
+		musb_set_vbus(musb, 1);
+
+		handled = IRQ_HANDLED;
+	}
+
+	if (int_usb & MUSB_INTR_VBUSERROR) {
+		int	ignore = 0;
+
+		/* During connection as an A-Device, we may see a short
+		 * current spikes causing voltage drop, because of cable
+		 * and peripheral capacitance combined with vbus draw.
+		 * (So: less common with truly self-powered devices, where
+		 * vbus doesn't act like a power supply.)
+		 *
+		 * Such spikes are short; usually less than ~500 usec, max
+		 * of ~2 msec.  That is, they're not sustained overcurrent
+		 * errors, though they're reported using VBUSERROR irqs.
+		 *
+		 * Workarounds:  (a) hardware: use self powered devices.
+		 * (b) software:  ignore non-repeated VBUS errors.
+		 *
+		 * REVISIT:  do delays from lots of DEBUG_KERNEL checks
+		 * make trouble here, keeping VBUS < 4.4V ?
+		 */
+		switch (musb->xceiv.state) {
+		case OTG_STATE_A_HOST:
+			/* recovery is dicey once we've gotten past the
+			 * initial stages of enumeration, but if VBUS
+			 * stayed ok at the other end of the link, and
+			 * another reset is due (at least for high speed,
+			 * to redo the chirp etc), it might work OK...
+			 */
+		case OTG_STATE_A_WAIT_BCON:
+		case OTG_STATE_A_WAIT_VRISE:
+			if (musb->vbuserr_retry) {
+				musb->vbuserr_retry--;
+				ignore = 1;
+				devctl |= MUSB_DEVCTL_SESSION;
+				musb_writeb(mbase, MUSB_DEVCTL, devctl);
+			} else {
+				musb->port1_status |=
+					  (1 << USB_PORT_FEAT_OVER_CURRENT)
+					| (1 << USB_PORT_FEAT_C_OVER_CURRENT);
+			}
+			break;
+		default:
+			break;
+		}
+
+		DBG(1, "VBUS_ERROR in %s (%02x, %s), retry #%d, port1 %08x\n",
+				otg_state_string(musb),
+				devctl,
+				({ char *s;
+				switch (devctl & MUSB_DEVCTL_VBUS) {
+				case 0 << MUSB_DEVCTL_VBUS_SHIFT:
+					s = "<SessEnd"; break;
+				case 1 << MUSB_DEVCTL_VBUS_SHIFT:
+					s = "<AValid"; break;
+				case 2 << MUSB_DEVCTL_VBUS_SHIFT:
+					s = "<VBusValid"; break;
+				/* case 3 << MUSB_DEVCTL_VBUS_SHIFT: */
+				default:
+					s = "VALID"; break;
+				}; s; }),
+				VBUSERR_RETRY_COUNT - musb->vbuserr_retry,
+				musb->port1_status);
+
+#ifdef CONFIG_USB_MUSB_OTG
+		if (musb->vbuserr_retry >= 3)
+			otg_set_error(&musb->xceiv, OTG_ERR_DEVICE_NOT_SUPPORTED);
+#endif
+
+		/* go through A_WAIT_VFALL then start a new session */
+		if (!ignore)
+			musb_set_vbus(musb, 0);
+		handled = IRQ_HANDLED;
+	}
+
+	if (int_usb & MUSB_INTR_CONNECT) {
+		struct usb_hcd *hcd = musb_to_hcd(musb);
+
+		handled = IRQ_HANDLED;
+		musb->is_active = 1;
+		set_bit(HCD_FLAG_SAW_IRQ, &hcd->flags);
+
+		musb->ep0_stage = MUSB_EP0_START;
+
+#ifdef CONFIG_USB_MUSB_OTG
+		/* flush endpoints when transitioning from Device Mode */
+		if (is_peripheral_active(musb)) {
+			/* REVISIT HNP; just force disconnect */
+		}
+		musb_writew(mbase, MUSB_INTRTXE, musb->epmask);
+		musb_writew(mbase, MUSB_INTRRXE, musb->epmask & 0xfffe);
+		musb_writeb(mbase, MUSB_INTRUSBE, 0xf7);
+
+		musb->srp_sent = 0;	/* SRP worked */
+#endif
+		musb->port1_status &= ~(USB_PORT_STAT_LOW_SPEED
+					|USB_PORT_STAT_HIGH_SPEED
+					|USB_PORT_STAT_ENABLE
+					);
+		musb->port1_status |= USB_PORT_STAT_CONNECTION
+					|(USB_PORT_STAT_C_CONNECTION << 16);
+
+		/* high vs full speed is just a guess until after reset */
+		if (devctl & MUSB_DEVCTL_LSDEV)
+			musb->port1_status |= USB_PORT_STAT_LOW_SPEED;
+
+		if (hcd->status_urb)
+			usb_hcd_poll_rh_status(hcd);
+		else
+			usb_hcd_resume_root_hub(hcd);
+
+		MUSB_HST_MODE(musb);
+
+		/* indicate new connection to OTG machine */
+		switch (musb->xceiv.state) {
+		case OTG_STATE_B_PERIPHERAL:
+			if (int_usb & MUSB_INTR_SUSPEND) {
+				DBG(1, "HNP: SUSPEND+CONNECT, now b_host\n");
+				musb->xceiv.state = OTG_STATE_B_HOST;
+				hcd->self.is_b_host = 1;
+				int_usb &= ~MUSB_INTR_SUSPEND;
+			} else
+				DBG(1, "CONNECT as b_peripheral???\n");
+			break;
+		case OTG_STATE_B_WAIT_ACON:
+			DBG(1, "HNP: Waiting to switch to b_host state\n");
+			musb->xceiv.state = OTG_STATE_B_HOST;
+			hcd->self.is_b_host = 1;
+			break;
+		default:
+			if ((devctl & MUSB_DEVCTL_VBUS)
+					== (3 << MUSB_DEVCTL_VBUS_SHIFT)) {
+				musb->xceiv.state = OTG_STATE_A_HOST;
+				hcd->self.is_b_host = 0;
+			}
+			break;
+		}
+		DBG(1, "CONNECT (%s) devctl %02x\n",
+				otg_state_string(musb), devctl);
+	}
+#endif	/* CONFIG_USB_MUSB_HDRC_HCD */
+
+	/* mentor saves a bit: bus reset and babble share the same irq.
+	 * only host sees babble; only peripheral sees bus reset.
+	 */
+	if (int_usb & MUSB_INTR_RESET) {
+		if (is_host_capable() && (devctl & MUSB_DEVCTL_HM) != 0) {
+			/*
+			 * Looks like non-HS BABBLE can be ignored, but
+			 * HS BABBLE is an error condition. For HS the solution
+			 * is to avoid babble in the first place and fix what
+			 * caused BABBLE. When HS BABBLE happens we can only
+			 * stop the session.
+			 */
+			if (devctl & (MUSB_DEVCTL_FSDEV | MUSB_DEVCTL_LSDEV))
+				DBG(1, "BABBLE devctl: %02x\n", devctl);
+			else {
+				ERR("Stopping host session -- babble\n");
+				musb_writeb(mbase, MUSB_DEVCTL, 0);
+			}
+		} else if (is_peripheral_capable()) {
+			DBG(1, "BUS RESET as %s\n", otg_state_string(musb));
+			switch (musb->xceiv.state) {
+#ifdef CONFIG_USB_OTG
+			case OTG_STATE_A_SUSPEND:
+				/* We need to ignore disconnect on suspend
+				 * otherwise tusb 2.0 won't reconnect after a
+				 * power cycle, which breaks otg compliance.
+				 */
+				musb->ignore_disconnect = 1;
+				musb_g_reset(musb);
+				/* FALLTHROUGH */
+			case OTG_STATE_A_WAIT_BCON:	/* OPT TD.4.7-900ms */
+				DBG(1, "HNP: Setting timer as %s\n",
+						otg_state_string(musb));
+				musb_otg_timer.data = (unsigned long)musb;
+				mod_timer(&musb_otg_timer, jiffies
+					+ msecs_to_jiffies(2000));
+				break;
+			case OTG_STATE_A_PERIPHERAL:
+				musb_hnp_stop(musb);
+				break;
+			case OTG_STATE_B_WAIT_ACON:
+				DBG(1, "HNP: RESET (%s), back to b_peripheral\n",
+					otg_state_string(musb));
+				musb->xceiv.state = OTG_STATE_B_PERIPHERAL;
+				musb_g_reset(musb);
+				break;
+#endif
+			case OTG_STATE_B_IDLE:
+				musb->xceiv.state = OTG_STATE_B_PERIPHERAL;
+				/* FALLTHROUGH */
+			case OTG_STATE_B_PERIPHERAL:
+				musb_g_reset(musb);
+				break;
+			default:
+				DBG(1, "Unhandled BUS RESET as %s\n",
+					otg_state_string(musb));
+			}
+		}
+
+		handled = IRQ_HANDLED;
+	}
+	schedule_work(&musb->irq_work);
+
+	return handled;
+}
+
+/*
+ * Interrupt Service Routine to record USB "global" interrupts.
+ * Since these do not happen often and signify things of
+ * paramount importance, it seems OK to check them individually;
+ * the order of the tests is specified in the manual
+ *
+ * @param musb instance pointer
+ * @param int_usb register contents
+ * @param devctl
+ * @param power
+ */
+static irqreturn_t musb_stage2_irq(struct musb *musb, u8 int_usb,
+				u8 devctl, u8 power)
+{
+	irqreturn_t handled = IRQ_NONE;
+
+#if 0
+/* REVISIT ... this would be for multiplexing periodic endpoints, or
+ * supporting transfer phasing to prevent exceeding ISO bandwidth
+ * limits of a given frame or microframe.
+ *
+ * It's not needed for peripheral side, which dedicates endpoints;
+ * though it _might_ use SOF irqs for other purposes.
+ *
+ * And it's not currently needed for host side, which also dedicates
+ * endpoints, relies on TX/RX interval registers, and isn't claimed
+ * to support ISO transfers yet.
+ */
+	if (int_usb & MUSB_INTR_SOF) {
+		void __iomem *mbase = musb->mregs;
+		struct musb_hw_ep	*ep;
+		u8 epnum;
+		u16 frame;
+
+		DBG(6, "START_OF_FRAME\n");
+		handled = IRQ_HANDLED;
+
+		/* start any periodic Tx transfers waiting for current frame */
+		frame = musb_readw(mbase, MUSB_FRAME);
+		ep = musb->endpoints;
+		for (epnum = 1; (epnum < musb->nr_endpoints)
+					&& (musb->epmask >= (1 << epnum));
+				epnum++, ep++) {
+			/*
+			 * FIXME handle framecounter wraps (12 bits)
+			 * eliminate duplicated StartUrb logic
+			 */
+			if (ep->dwWaitFrame >= frame) {
+				ep->dwWaitFrame = 0;
+				printk("SOF --> periodic TX%s on %d\n",
+					ep->tx_channel ? " DMA" : "",
+					epnum);
+				if (!ep->tx_channel)
+					musb_h_tx_start(musb, epnum);
+				else
+					cppi_hostdma_start(musb, epnum);
+			}
+		}		/* end of for loop */
+	}
+#endif
+
+	if ((int_usb & MUSB_INTR_DISCONNECT) && !musb->ignore_disconnect) {
+		DBG(1, "DISCONNECT (%s) as %s, devctl %02x\n",
+				otg_state_string(musb),
+				MUSB_MODE(musb), devctl);
+		handled = IRQ_HANDLED;
+
+		switch (musb->xceiv.state) {
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+		case OTG_STATE_A_HOST:
+		case OTG_STATE_A_SUSPEND:
+			musb_root_disconnect(musb);
+			if (musb->a_wait_bcon != 0)
+				musb_platform_try_idle(musb, jiffies
+					+ msecs_to_jiffies(musb->a_wait_bcon));
+			break;
+#endif	/* HOST */
+#ifdef CONFIG_USB_MUSB_OTG
+		case OTG_STATE_B_HOST:
+			musb_hnp_stop(musb);
+			break;
+		case OTG_STATE_A_PERIPHERAL:
+			musb_hnp_stop(musb);
+			musb_root_disconnect(musb);
+			/* FALLTHROUGH */
+		case OTG_STATE_B_WAIT_ACON:
+			/* FALLTHROUGH */
+#endif	/* OTG */
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+		case OTG_STATE_B_PERIPHERAL:
+		case OTG_STATE_B_IDLE:
+			musb_g_disconnect(musb);
+			break;
+#endif	/* GADGET */
+		default:
+			WARN("unhandled DISCONNECT transition (%s)\n",
+				otg_state_string(musb));
+			break;
+		}
+
+		schedule_work(&musb->irq_work);
+	}
+
+	if (int_usb & MUSB_INTR_SUSPEND) {
+		DBG(1, "SUSPEND (%s) devctl %02x power %02x\n",
+				otg_state_string(musb), devctl, power);
+		handled = IRQ_HANDLED;
+
+		switch (musb->xceiv.state) {
+#ifdef	CONFIG_USB_MUSB_OTG
+		case OTG_STATE_A_PERIPHERAL:
+			/*
+			 * We cannot stop HNP here, devctl BDEVICE might be
+			 * still set.
+			 */
+			break;
+#endif
+		case OTG_STATE_B_PERIPHERAL:
+			musb_g_suspend(musb);
+			musb->is_active = is_otg_enabled(musb)
+					&& musb->xceiv.gadget->b_hnp_enable;
+			if (musb->is_active) {
+#ifdef	CONFIG_USB_MUSB_OTG
+				musb->xceiv.state = OTG_STATE_B_WAIT_ACON;
+				DBG(1, "HNP: Setting timer for b_ase0_brst\n");
+				musb_otg_timer.data = (unsigned long)musb;
+				mod_timer(&musb_otg_timer, jiffies
+					+ msecs_to_jiffies(TB_ASE0_BRST));
+#endif
+			}
+			break;
+		case OTG_STATE_A_WAIT_BCON:
+			if (musb->a_wait_bcon != 0)
+				musb_platform_try_idle(musb, jiffies
+					+ msecs_to_jiffies(musb->a_wait_bcon));
+			break;
+		case OTG_STATE_A_HOST:
+			musb->xceiv.state = OTG_STATE_A_SUSPEND;
+			musb->is_active = is_otg_enabled(musb)
+					&& musb->xceiv.host->b_hnp_enable;
+			break;
+		case OTG_STATE_B_HOST:
+			/* Transition to B_PERIPHERAL, see 6.8.2.6 p 44 */
+			DBG(1, "REVISIT: SUSPEND as B_HOST\n");
+			break;
+		default:
+			/* "should not happen" */
+			musb->is_active = 0;
+			break;
+		}
+		schedule_work(&musb->irq_work);
+	}
+
+
+	return handled;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/*
+* Program the HDRC to start (enable interrupts, dma, etc.).
+*/
+void musb_start(struct musb *musb)
+{
+	void __iomem	*regs = musb->mregs;
+	u8		devctl = musb_readb(regs, MUSB_DEVCTL);
+
+	DBG(2, "<== devctl %02x\n", devctl);
+
+	/*  Set INT enable registers, enable interrupts */
+	musb_writew(regs, MUSB_INTRTXE, musb->epmask);
+	musb_writew(regs, MUSB_INTRRXE, musb->epmask & 0xfffe);
+	musb_writeb(regs, MUSB_INTRUSBE, 0xf7);
+
+	musb_writeb(regs, MUSB_TESTMODE, 0);
+
+	/* put into basic highspeed mode and start session */
+	musb_writeb(regs, MUSB_POWER, MUSB_POWER_ISOUPDATE
+						| MUSB_POWER_SOFTCONN
+						| MUSB_POWER_HSENAB
+						/* ENSUSPEND wedges tusb */
+						/* | MUSB_POWER_ENSUSPEND */
+						);
+
+	musb->is_active = 0;
+	devctl = musb_readb(regs, MUSB_DEVCTL);
+	devctl &= ~MUSB_DEVCTL_SESSION;
+
+	if (is_otg_enabled(musb)) {
+		/* session started after:
+		 * (a) ID-grounded irq, host mode;
+		 * (b) vbus present/connect IRQ, peripheral mode;
+		 * (c) peripheral initiates, using SRP
+		 */
+		if ((devctl & MUSB_DEVCTL_VBUS) == MUSB_DEVCTL_VBUS)
+			musb->is_active = 1;
+		else
+			devctl |= MUSB_DEVCTL_SESSION;
+
+	} else if (is_host_enabled(musb)) {
+		/* assume ID pin is hard-wired to ground */
+		devctl |= MUSB_DEVCTL_SESSION;
+
+	} else /* peripheral is enabled */ {
+		if ((devctl & MUSB_DEVCTL_VBUS) == MUSB_DEVCTL_VBUS)
+			musb->is_active = 1;
+	}
+	musb_platform_enable(musb);
+	musb_writeb(regs, MUSB_DEVCTL, devctl);
+}
+
+
+static void musb_generic_disable(struct musb *musb)
+{
+	void __iomem	*mbase = musb->mregs;
+	u16	temp;
+
+	/* disable interrupts */
+	musb_writeb(mbase, MUSB_INTRUSBE, 0);
+	musb_writew(mbase, MUSB_INTRTXE, 0);
+	musb_writew(mbase, MUSB_INTRRXE, 0);
+
+	/* off */
+	musb_writeb(mbase, MUSB_DEVCTL, 0);
+
+	/*  flush pending interrupts */
+	temp = musb_readb(mbase, MUSB_INTRUSB);
+	temp = musb_readw(mbase, MUSB_INTRTX);
+	temp = musb_readw(mbase, MUSB_INTRRX);
+
+}
+
+/*
+ * Make the HDRC stop (disable interrupts, etc.);
+ * reversible by musb_start
+ * called on gadget driver unregister
+ * with controller locked, irqs blocked
+ * acts as a NOP unless some role activated the hardware
+ */
+void musb_stop(struct musb *musb)
+{
+	/* stop IRQs, timers, ... */
+	musb_platform_disable(musb);
+	musb_generic_disable(musb);
+	DBG(3, "HDRC disabled\n");
+
+	/* FIXME
+	 *  - mark host and/or peripheral drivers unusable/inactive
+	 *  - disable DMA (and enable it in HdrcStart)
+	 *  - make sure we can musb_start() after musb_stop(); with
+	 *    OTG mode, gadget driver module rmmod/modprobe cycles that
+	 *  - ...
+	 */
+	musb_platform_try_idle(musb, 0);
+}
+
+static void musb_shutdown(struct platform_device *pdev)
+{
+	struct musb	*musb = dev_to_musb(&pdev->dev);
+	unsigned long	flags;
+
+	spin_lock_irqsave(&musb->lock, flags);
+	musb_platform_disable(musb);
+	musb_generic_disable(musb);
+	if (musb->clock) {
+		clk_put(musb->clock);
+		musb->clock = NULL;
+	}
+	spin_unlock_irqrestore(&musb->lock, flags);
+
+	/* FIXME power down */
+}
+
+
+/*-------------------------------------------------------------------------*/
+
+/*
+ * The silicon either has hard-wired endpoint configurations, or else
+ * "dynamic fifo" sizing.  The driver has support for both, though at this
+ * writing only the dynamic sizing is very well tested.   We use normal
+ * idioms to so both modes are compile-tested, but dead code elimination
+ * leaves only the relevant one in the object file.
+ *
+ * We don't currently use dynamic fifo setup capability to do anything
+ * more than selecting one of a bunch of predefined configurations.
+ */
+#ifdef MUSB_C_DYNFIFO_DEF
+#define	can_dynfifo()	1
+#else
+#define	can_dynfifo()	0
+#endif
+
+#ifdef CONFIG_USB_TUSB6010
+static ushort __initdata fifo_mode = 4;
+#else
+static ushort __initdata fifo_mode = 2;
+#endif
+
+/* "modprobe ... fifo_mode=1" etc */
+module_param(fifo_mode, ushort, 0);
+MODULE_PARM_DESC(fifo_mode, "initial endpoint configuration");
+
+
+#define DYN_FIFO_SIZE (1<<(MUSB_C_RAM_BITS+2))
+
+enum fifo_style { FIFO_RXTX, FIFO_TX, FIFO_RX } __attribute__ ((packed));
+enum buf_mode { BUF_SINGLE, BUF_DOUBLE } __attribute__ ((packed));
+
+struct fifo_cfg {
+	u8		hw_ep_num;
+	enum fifo_style	style;
+	enum buf_mode	mode;
+	u16		maxpacket;
+};
+
+/*
+ * tables defining fifo_mode values.  define more if you like.
+ * for host side, make sure both halves of ep1 are set up.
+ */
+
+/* mode 0 - fits in 2KB */
+static struct fifo_cfg __initdata mode_0_cfg[] = {
+{ .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, },
+{ .hw_ep_num = 1, .style = FIFO_RX,   .maxpacket = 512, },
+{ .hw_ep_num = 2, .style = FIFO_RXTX, .maxpacket = 512, },
+{ .hw_ep_num = 3, .style = FIFO_RXTX, .maxpacket = 256, },
+{ .hw_ep_num = 4, .style = FIFO_RXTX, .maxpacket = 256, },
+};
+
+/* mode 1 - fits in 4KB */
+static struct fifo_cfg __initdata mode_1_cfg[] = {
+{ .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
+{ .hw_ep_num = 1, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
+{ .hw_ep_num = 2, .style = FIFO_RXTX, .maxpacket = 512, .mode = BUF_DOUBLE, },
+{ .hw_ep_num = 3, .style = FIFO_RXTX, .maxpacket = 256, },
+{ .hw_ep_num = 4, .style = FIFO_RXTX, .maxpacket = 256, },
+};
+
+/* mode 2 - fits in 4KB */
+static struct fifo_cfg __initdata mode_2_cfg[] = {
+{ .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, },
+{ .hw_ep_num = 1, .style = FIFO_RX,   .maxpacket = 512, },
+{ .hw_ep_num = 2, .style = FIFO_TX,   .maxpacket = 512, },
+{ .hw_ep_num = 2, .style = FIFO_RX,   .maxpacket = 512, },
+{ .hw_ep_num = 3, .style = FIFO_RXTX, .maxpacket = 256, },
+{ .hw_ep_num = 4, .style = FIFO_RXTX, .maxpacket = 256, },
+};
+
+/* mode 3 - fits in 4KB */
+static struct fifo_cfg __initdata mode_3_cfg[] = {
+{ .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
+{ .hw_ep_num = 1, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
+{ .hw_ep_num = 2, .style = FIFO_TX,   .maxpacket = 512, },
+{ .hw_ep_num = 2, .style = FIFO_RX,   .maxpacket = 512, },
+{ .hw_ep_num = 3, .style = FIFO_RXTX, .maxpacket = 256, },
+{ .hw_ep_num = 4, .style = FIFO_RXTX, .maxpacket = 256, },
+};
+
+/* mode 4 - fits in 16KB */
+static struct fifo_cfg __initdata mode_4_cfg[] = {
+{ .hw_ep_num =  1, .style = FIFO_TX,   .maxpacket = 512, },
+{ .hw_ep_num =  1, .style = FIFO_RX,   .maxpacket = 512, },
+{ .hw_ep_num =  2, .style = FIFO_TX,   .maxpacket = 512, },
+{ .hw_ep_num =  2, .style = FIFO_RX,   .maxpacket = 512, },
+{ .hw_ep_num =  3, .style = FIFO_TX,   .maxpacket = 512, },
+{ .hw_ep_num =  3, .style = FIFO_RX,   .maxpacket = 512, },
+{ .hw_ep_num =  4, .style = FIFO_TX,   .maxpacket = 512, },
+{ .hw_ep_num =  4, .style = FIFO_RX,   .maxpacket = 512, },
+{ .hw_ep_num =  5, .style = FIFO_TX,   .maxpacket = 512, },
+{ .hw_ep_num =  5, .style = FIFO_RX,   .maxpacket = 512, },
+{ .hw_ep_num =  6, .style = FIFO_TX,   .maxpacket = 512, },
+{ .hw_ep_num =  6, .style = FIFO_RX,   .maxpacket = 512, },
+{ .hw_ep_num =  7, .style = FIFO_TX,   .maxpacket = 512, },
+{ .hw_ep_num =  7, .style = FIFO_RX,   .maxpacket = 512, },
+{ .hw_ep_num =  8, .style = FIFO_TX,   .maxpacket = 512, },
+{ .hw_ep_num =  8, .style = FIFO_RX,   .maxpacket = 512, },
+{ .hw_ep_num =  9, .style = FIFO_TX,   .maxpacket = 512, },
+{ .hw_ep_num =  9, .style = FIFO_RX,   .maxpacket = 512, },
+{ .hw_ep_num = 10, .style = FIFO_TX,   .maxpacket = 512, },
+{ .hw_ep_num = 10, .style = FIFO_RX,   .maxpacket = 512, },
+{ .hw_ep_num = 11, .style = FIFO_TX,   .maxpacket = 512, },
+{ .hw_ep_num = 11, .style = FIFO_RX,   .maxpacket = 512, },
+{ .hw_ep_num = 12, .style = FIFO_TX,   .maxpacket = 512, },
+{ .hw_ep_num = 12, .style = FIFO_RX,   .maxpacket = 512, },
+{ .hw_ep_num = 13, .style = FIFO_TX,   .maxpacket = 512, },
+{ .hw_ep_num = 13, .style = FIFO_RX,   .maxpacket = 512, },
+{ .hw_ep_num = 14, .style = FIFO_RXTX, .maxpacket = 1024, },
+{ .hw_ep_num = 15, .style = FIFO_RXTX, .maxpacket = 1024, },
+};
+
+
+/*
+ * configure a fifo; for non-shared endpoints, this may be called
+ * once for a tx fifo and once for an rx fifo.
+ *
+ * returns negative errno or offset for next fifo.
+ */
+static int __init
+fifo_setup(struct musb *musb, struct musb_hw_ep  *hw_ep,
+		const struct fifo_cfg *cfg, u16 offset)
+{
+	void __iomem	*mbase = musb->mregs;
+	int	size = 0;
+	u16	maxpacket = cfg->maxpacket;
+	u16	c_off = offset >> 3;
+	u8	c_size;
+
+	/* expect hw_ep has already been zero-initialized */
+
+	size = ffs(max(maxpacket, (u16) 8)) - 1;
+	maxpacket = 1 << size;
+
+	c_size = size - 3;
+	if (cfg->mode == BUF_DOUBLE) {
+		if ((offset + (maxpacket << 1)) > DYN_FIFO_SIZE)
+			return -EMSGSIZE;
+		c_size |= MUSB_FIFOSZ_DPB;
+	} else {
+		if ((offset + maxpacket) > DYN_FIFO_SIZE)
+			return -EMSGSIZE;
+	}
+
+	/* configure the FIFO */
+	musb_writeb(mbase, MUSB_INDEX, hw_ep->epnum);
+
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+	/* EP0 reserved endpoint for control, bidirectional;
+	 * EP1 reserved for bulk, two unidirection halves.
+	 */
+	if (hw_ep->epnum == 1)
+		musb->bulk_ep = hw_ep;
+	/* REVISIT error check:  be sure ep0 can both rx and tx ... */
+#endif
+	switch (cfg->style) {
+	case FIFO_TX:
+		musb_writeb(mbase, MUSB_TXFIFOSZ, c_size);
+		musb_writew(mbase, MUSB_TXFIFOADD, c_off);
+		hw_ep->tx_double_buffered = !!(c_size & MUSB_FIFOSZ_DPB);
+		hw_ep->max_packet_sz_tx = maxpacket;
+		break;
+	case FIFO_RX:
+		musb_writeb(mbase, MUSB_RXFIFOSZ, c_size);
+		musb_writew(mbase, MUSB_RXFIFOADD, c_off);
+		hw_ep->rx_double_buffered = !!(c_size & MUSB_FIFOSZ_DPB);
+		hw_ep->max_packet_sz_rx = maxpacket;
+		break;
+	case FIFO_RXTX:
+		musb_writeb(mbase, MUSB_TXFIFOSZ, c_size);
+		musb_writew(mbase, MUSB_TXFIFOADD, c_off);
+		hw_ep->rx_double_buffered = !!(c_size & MUSB_FIFOSZ_DPB);
+		hw_ep->max_packet_sz_rx = maxpacket;
+
+		musb_writeb(mbase, MUSB_RXFIFOSZ, c_size);
+		musb_writew(mbase, MUSB_RXFIFOADD, c_off);
+		hw_ep->tx_double_buffered = hw_ep->rx_double_buffered;
+		hw_ep->max_packet_sz_tx = maxpacket;
+
+		hw_ep->is_shared_fifo = true;
+		break;
+	}
+
+	/* NOTE rx and tx endpoint irqs aren't managed separately,
+	 * which happens to be ok
+	 */
+	musb->epmask |= (1 << hw_ep->epnum);
+
+	return offset + (maxpacket << ((c_size & MUSB_FIFOSZ_DPB) ? 1 : 0));
+}
+
+static struct fifo_cfg __initdata ep0_cfg = {
+	.style = FIFO_RXTX, .maxpacket = 64,
+};
+
+static int __init ep_config_from_table(struct musb *musb)
+{
+	const struct fifo_cfg	*cfg;
+	unsigned		i, n;
+	int			offset;
+	struct musb_hw_ep	*hw_ep = musb->endpoints;
+
+	switch (fifo_mode) {
+	default:
+		fifo_mode = 0;
+		/* FALLTHROUGH */
+	case 0:
+		cfg = mode_0_cfg;
+		n = ARRAY_SIZE(mode_0_cfg);
+		break;
+	case 1:
+		cfg = mode_1_cfg;
+		n = ARRAY_SIZE(mode_1_cfg);
+		break;
+	case 2:
+		cfg = mode_2_cfg;
+		n = ARRAY_SIZE(mode_2_cfg);
+		break;
+	case 3:
+		cfg = mode_3_cfg;
+		n = ARRAY_SIZE(mode_3_cfg);
+		break;
+	case 4:
+		cfg = mode_4_cfg;
+		n = ARRAY_SIZE(mode_4_cfg);
+		break;
+	}
+
+	printk(KERN_DEBUG "%s: setup fifo_mode %d\n",
+			musb_driver_name, fifo_mode);
+
+
+	offset = fifo_setup(musb, hw_ep, &ep0_cfg, 0);
+	/* assert(offset > 0) */
+
+	/* NOTE:  for RTL versions >= 1.400 EPINFO and RAMINFO would
+	 * be better than static MUSB_C_NUM_EPS and DYN_FIFO_SIZE...
+	 */
+
+	for (i = 0; i < n; i++) {
+		u8	epn = cfg->hw_ep_num;
+
+		if (epn >= MUSB_C_NUM_EPS) {
+			pr_debug("%s: invalid ep %d\n",
+					musb_driver_name, epn);
+			continue;
+		}
+		offset = fifo_setup(musb, hw_ep + epn, cfg++, offset);
+		if (offset < 0) {
+			pr_debug("%s: mem overrun, ep %d\n",
+					musb_driver_name, epn);
+			return -EINVAL;
+		}
+		epn++;
+		musb->nr_endpoints = max(epn, musb->nr_endpoints);
+	}
+
+	printk(KERN_DEBUG "%s: %d/%d max ep, %d/%d memory\n",
+			musb_driver_name,
+			n + 1, MUSB_C_NUM_EPS * 2 - 1,
+			offset, DYN_FIFO_SIZE);
+
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+	if (!musb->bulk_ep) {
+		pr_debug("%s: missing bulk\n", musb_driver_name);
+		return -EINVAL;
+	}
+#endif
+
+	return 0;
+}
+
+
+/*
+ * ep_config_from_hw - when MUSB_C_DYNFIFO_DEF is false
+ * @param musb the controller
+ */
+static int __init ep_config_from_hw(struct musb *musb)
+{
+	u8 epnum = 0, reg;
+	struct musb_hw_ep *hw_ep;
+	void *mbase = musb->mregs;
+
+	DBG(2, "<== static silicon ep config\n");
+
+	/* FIXME pick up ep0 maxpacket size */
+
+	for (epnum = 1; epnum < MUSB_C_NUM_EPS; epnum++) {
+		musb_ep_select(mbase, epnum);
+		hw_ep = musb->endpoints + epnum;
+
+		/* read from core using indexed model */
+		reg = musb_readb(hw_ep->regs, 0x10 + MUSB_FIFOSIZE);
+		if (!reg) {
+			/* 0's returned when no more endpoints */
+			break;
+		}
+		musb->nr_endpoints++;
+		musb->epmask |= (1 << epnum);
+
+		hw_ep->max_packet_sz_tx = 1 << (reg & 0x0f);
+
+		/* shared TX/RX FIFO? */
+		if ((reg & 0xf0) == 0xf0) {
+			hw_ep->max_packet_sz_rx = hw_ep->max_packet_sz_tx;
+			hw_ep->is_shared_fifo = true;
+			continue;
+		} else {
+			hw_ep->max_packet_sz_rx = 1 << ((reg & 0xf0) >> 4);
+			hw_ep->is_shared_fifo = false;
+		}
+
+		/* FIXME set up hw_ep->{rx,tx}_double_buffered */
+
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+		/* pick an RX/TX endpoint for bulk */
+		if (hw_ep->max_packet_sz_tx < 512
+				|| hw_ep->max_packet_sz_rx < 512)
+			continue;
+
+		/* REVISIT:  this algorithm is lazy, we should at least
+		 * try to pick a double buffered endpoint.
+		 */
+		if (musb->bulk_ep)
+			continue;
+		musb->bulk_ep = hw_ep;
+#endif
+	}
+
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+	if (!musb->bulk_ep) {
+		pr_debug("%s: missing bulk\n", musb_driver_name);
+		return -EINVAL;
+	}
+#endif
+
+	return 0;
+}
+
+enum { MUSB_CONTROLLER_MHDRC, MUSB_CONTROLLER_HDRC, };
+
+/* Initialize MUSB (M)HDRC part of the USB hardware subsystem;
+ * configure endpoints, or take their config from silicon
+ */
+static int __init musb_core_init(u16 musb_type, struct musb *musb)
+{
+#ifdef MUSB_AHB_ID
+	u32 data;
+#endif
+	u8 reg;
+	char *type;
+	u16 hwvers, rev_major, rev_minor;
+	char aInfo[78], aRevision[32], aDate[12];
+	void __iomem	*mbase = musb->mregs;
+	int		status = 0;
+	int		i;
+
+	/* log core options (read using indexed model) */
+	musb_ep_select(mbase, 0);
+	reg = musb_readb(mbase, 0x10 + MUSB_CONFIGDATA);
+
+	strcpy(aInfo, (reg & MUSB_CONFIGDATA_UTMIDW) ? "UTMI-16" : "UTMI-8");
+	if (reg & MUSB_CONFIGDATA_DYNFIFO)
+		strcat(aInfo, ", dyn FIFOs");
+	if (reg & MUSB_CONFIGDATA_MPRXE) {
+		strcat(aInfo, ", bulk combine");
+#ifdef C_MP_RX
+		musb->bulk_combine = true;
+#else
+		strcat(aInfo, " (X)");		/* no driver support */
+#endif
+	}
+	if (reg & MUSB_CONFIGDATA_MPTXE) {
+		strcat(aInfo, ", bulk split");
+#ifdef C_MP_TX
+		musb->bulk_split = true;
+#else
+		strcat(aInfo, " (X)");		/* no driver support */
+#endif
+	}
+	if (reg & MUSB_CONFIGDATA_HBRXE) {
+		strcat(aInfo, ", HB-ISO Rx");
+		strcat(aInfo, " (X)");		/* no driver support */
+	}
+	if (reg & MUSB_CONFIGDATA_HBTXE) {
+		strcat(aInfo, ", HB-ISO Tx");
+		strcat(aInfo, " (X)");		/* no driver support */
+	}
+	if (reg & MUSB_CONFIGDATA_SOFTCONE)
+		strcat(aInfo, ", SoftConn");
+
+	printk(KERN_DEBUG "%s: ConfigData=0x%02x (%s)\n",
+			musb_driver_name, reg, aInfo);
+
+#ifdef MUSB_AHB_ID
+	data = musb_readl(mbase, 0x404);
+	sprintf(aDate, "%04d-%02x-%02x", (data & 0xffff),
+		(data >> 16) & 0xff, (data >> 24) & 0xff);
+	/* FIXME ID2 and ID3 are unused */
+	data = musb_readl(mbase, 0x408);
+	printk("ID2=%lx\n", (long unsigned)data);
+	data = musb_readl(mbase, 0x40c);
+	printk("ID3=%lx\n", (long unsigned)data);
+	reg = musb_readb(mbase, 0x400);
+	musb_type = ('M' == reg) ? MUSB_CONTROLLER_MHDRC : MUSB_CONTROLLER_HDRC;
+#else
+	aDate[0] = 0;
+#endif
+	if (MUSB_CONTROLLER_MHDRC == musb_type) {
+		musb->is_multipoint = 1;
+		type = "M";
+	} else {
+		musb->is_multipoint = 0;
+		type = "";
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+#ifndef	CONFIG_USB_OTG_BLACKLIST_HUB
+		printk(KERN_ERR
+			"%s: kernel must blacklist external hubs\n",
+			musb_driver_name);
+#endif
+#endif
+	}
+
+	/* log release info */
+	hwvers = musb_readw(mbase, MUSB_HWVERS);
+	rev_major = (hwvers >> 10) & 0x1f;
+	rev_minor = hwvers & 0x3ff;
+	snprintf(aRevision, 32, "%d.%d%s", rev_major,
+		rev_minor, (hwvers & 0x8000) ? "RC" : "");
+	printk(KERN_DEBUG "%s: %sHDRC RTL version %s %s\n",
+			musb_driver_name, type, aRevision, aDate);
+
+	/* configure ep0 */
+	musb->endpoints[0].max_packet_sz_tx = MUSB_EP0_FIFOSIZE;
+	musb->endpoints[0].max_packet_sz_rx = MUSB_EP0_FIFOSIZE;
+
+	/* discover endpoint configuration */
+	musb->nr_endpoints = 1;
+	musb->epmask = 1;
+
+	if (reg & MUSB_CONFIGDATA_DYNFIFO) {
+		if (can_dynfifo())
+			status = ep_config_from_table(musb);
+		else {
+			ERR("reconfigure software for Dynamic FIFOs\n");
+			status = -ENODEV;
+		}
+	} else {
+		if (!can_dynfifo())
+			status = ep_config_from_hw(musb);
+		else {
+			ERR("reconfigure software for static FIFOs\n");
+			return -ENODEV;
+		}
+	}
+
+	if (status < 0)
+		return status;
+
+	/* finish init, and print endpoint config */
+	for (i = 0; i < musb->nr_endpoints; i++) {
+		struct musb_hw_ep	*hw_ep = musb->endpoints + i;
+
+		hw_ep->fifo = MUSB_FIFO_OFFSET(i) + mbase;
+#ifdef CONFIG_USB_TUSB6010
+		hw_ep->fifo_async = musb->async + 0x400 + MUSB_FIFO_OFFSET(i);
+		hw_ep->fifo_sync = musb->sync + 0x400 + MUSB_FIFO_OFFSET(i);
+		hw_ep->fifo_sync_va =
+			musb->sync_va + 0x400 + MUSB_FIFO_OFFSET(i);
+
+		if (i == 0)
+			hw_ep->conf = mbase - 0x400 + TUSB_EP0_CONF;
+		else
+			hw_ep->conf = mbase + 0x400 + (((i - 1) & 0xf) << 2);
+#endif
+
+		hw_ep->regs = MUSB_EP_OFFSET(i, 0) + mbase;
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+		hw_ep->target_regs = MUSB_BUSCTL_OFFSET(i, 0) + mbase;
+		hw_ep->rx_reinit = 1;
+		hw_ep->tx_reinit = 1;
+#endif
+
+		if (hw_ep->max_packet_sz_tx) {
+			printk(KERN_DEBUG
+				"%s: hw_ep %d%s, %smax %d\n",
+				musb_driver_name, i,
+				hw_ep->is_shared_fifo ? "shared" : "tx",
+				hw_ep->tx_double_buffered
+					? "doublebuffer, " : "",
+				hw_ep->max_packet_sz_tx);
+		}
+		if (hw_ep->max_packet_sz_rx && !hw_ep->is_shared_fifo) {
+			printk(KERN_DEBUG
+				"%s: hw_ep %d%s, %smax %d\n",
+				musb_driver_name, i,
+				"rx",
+				hw_ep->rx_double_buffered
+					? "doublebuffer, " : "",
+				hw_ep->max_packet_sz_rx);
+		}
+		if (!(hw_ep->max_packet_sz_tx || hw_ep->max_packet_sz_rx))
+			DBG(1, "hw_ep %d not configured\n", i);
+	}
+
+	return 0;
+}
+
+/*-------------------------------------------------------------------------*/
+
+#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3430)
+
+static irqreturn_t generic_interrupt(int irq, void *__hci)
+{
+	unsigned long	flags;
+	irqreturn_t	retval = IRQ_NONE;
+	struct musb	*musb = __hci;
+
+	spin_lock_irqsave(&musb->lock, flags);
+
+	musb->int_usb = musb_readb(musb->mregs, MUSB_INTRUSB);
+	musb->int_tx = musb_readw(musb->mregs, MUSB_INTRTX);
+	musb->int_rx = musb_readw(musb->mregs, MUSB_INTRRX);
+
+	if (musb->int_usb || musb->int_tx || musb->int_rx)
+		retval = musb_interrupt(musb);
+
+	spin_unlock_irqrestore(&musb->lock, flags);
+
+	/* REVISIT we sometimes get spurious IRQs on g_ep0
+	 * not clear why...
+	 */
+	if (retval != IRQ_HANDLED)
+		DBG(5, "spurious?\n");
+
+	return IRQ_HANDLED;
+}
+
+#else
+#define generic_interrupt	NULL
+#endif
+
+/*
+ * handle all the irqs defined by the HDRC core. for now we expect:  other
+ * irq sources (phy, dma, etc) will be handled first, musb->int_* values
+ * will be assigned, and the irq will already have been acked.
+ *
+ * called in irq context with spinlock held, irqs blocked
+ */
+irqreturn_t musb_interrupt(struct musb *musb)
+{
+	irqreturn_t	retval = IRQ_NONE;
+	u8		devctl, power;
+	int		ep_num;
+	u32		reg;
+
+	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+	power = musb_readb(musb->mregs, MUSB_POWER);
+
+	DBG(4, "** IRQ %s usb%04x tx%04x rx%04x\n",
+		(devctl & MUSB_DEVCTL_HM) ? "host" : "peripheral",
+		musb->int_usb, musb->int_tx, musb->int_rx);
+
+	/* the core can interrupt us for multiple reasons; docs have
+	 * a generic interrupt flowchart to follow
+	 */
+	if (musb->int_usb & STAGE0_MASK)
+		retval |= musb_stage0_irq(musb, musb->int_usb,
+				devctl, power);
+
+	/* "stage 1" is handling endpoint irqs */
+
+	/* handle endpoint 0 first */
+	if (musb->int_tx & 1) {
+		if (devctl & MUSB_DEVCTL_HM)
+			retval |= musb_h_ep0_irq(musb);
+		else
+			retval |= musb_g_ep0_irq(musb);
+	}
+
+	/* RX on endpoints 1-15 */
+	reg = musb->int_rx >> 1;
+	ep_num = 1;
+	while (reg) {
+		if (reg & 1) {
+			/* musb_ep_select(musb->mregs, ep_num); */
+			/* REVISIT just retval = ep->rx_irq(...) */
+			retval = IRQ_HANDLED;
+			if (devctl & MUSB_DEVCTL_HM) {
+				if (is_host_capable())
+					musb_host_rx(musb, ep_num);
+			} else {
+				if (is_peripheral_capable())
+					musb_g_rx(musb, ep_num);
+			}
+		}
+
+		reg >>= 1;
+		ep_num++;
+	}
+
+	/* TX on endpoints 1-15 */
+	reg = musb->int_tx >> 1;
+	ep_num = 1;
+	while (reg) {
+		if (reg & 1) {
+			/* musb_ep_select(musb->mregs, ep_num); */
+			/* REVISIT just retval |= ep->tx_irq(...) */
+			retval = IRQ_HANDLED;
+			if (devctl & MUSB_DEVCTL_HM) {
+				if (is_host_capable())
+					musb_host_tx(musb, ep_num);
+			} else {
+				if (is_peripheral_capable())
+					musb_g_tx(musb, ep_num);
+			}
+		}
+		reg >>= 1;
+		ep_num++;
+	}
+
+	/* finish handling "global" interrupts after handling fifos */
+	if (musb->int_usb)
+		retval |= musb_stage2_irq(musb,
+				musb->int_usb, devctl, power);
+
+	return retval;
+}
+
+
+#ifndef CONFIG_MUSB_PIO_ONLY
+static int __initdata use_dma = 1;
+
+/* "modprobe ... use_dma=0" etc */
+module_param(use_dma, bool, 0);
+MODULE_PARM_DESC(use_dma, "enable/disable use of DMA");
+
+void musb_dma_completion(struct musb *musb, u8 epnum, u8 transmit)
+{
+	u8	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+
+	/* called with controller lock already held */
+
+	if (!epnum) {
+#ifndef CONFIG_USB_TUSB_OMAP_DMA
+		if (!is_cppi_enabled()) {
+			/* endpoint 0 */
+			if (devctl & MUSB_DEVCTL_HM)
+				musb_h_ep0_irq(musb);
+			else
+				musb_g_ep0_irq(musb);
+		}
+#endif
+	} else {
+		/* endpoints 1..15 */
+		if (transmit) {
+			if (devctl & MUSB_DEVCTL_HM) {
+				if (is_host_capable())
+					musb_host_tx(musb, epnum);
+			} else {
+				if (is_peripheral_capable())
+					musb_g_tx(musb, epnum);
+			}
+		} else {
+			/* receive */
+			if (devctl & MUSB_DEVCTL_HM) {
+				if (is_host_capable())
+					musb_host_rx(musb, epnum);
+			} else {
+				if (is_peripheral_capable())
+					musb_g_rx(musb, epnum);
+			}
+		}
+	}
+}
+
+#else
+#define use_dma			0
+#endif
+
+/*-------------------------------------------------------------------------*/
+
+#ifdef CONFIG_SYSFS
+
+static ssize_t
+musb_mode_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct musb *musb = dev_to_musb(dev);
+	unsigned long flags;
+	int ret = -EINVAL;
+
+	spin_lock_irqsave(&musb->lock, flags);
+	ret = sprintf(buf, "%s\n", otg_state_string(musb));
+	spin_unlock_irqrestore(&musb->lock, flags);
+
+	return ret;
+}
+
+static ssize_t
+musb_mode_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t n)
+{
+	struct musb	*musb = dev_to_musb(dev);
+	unsigned long	flags;
+
+	spin_lock_irqsave(&musb->lock, flags);
+	if (!strncmp(buf, "host", 4))
+		musb_platform_set_mode(musb, MUSB_HOST);
+	if (!strncmp(buf, "peripheral", 10))
+		musb_platform_set_mode(musb, MUSB_PERIPHERAL);
+	if (!strncmp(buf, "otg", 3))
+		musb_platform_set_mode(musb, MUSB_OTG);
+	spin_unlock_irqrestore(&musb->lock, flags);
+
+	return n;
+}
+static DEVICE_ATTR(mode, 0644, musb_mode_show, musb_mode_store);
+
+static ssize_t
+musb_vbus_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t n)
+{
+	struct musb	*musb = dev_to_musb(dev);
+	unsigned long	flags;
+	unsigned long	val;
+
+	if (sscanf(buf, "%lu", &val) < 1) {
+		printk(KERN_ERR "Invalid VBUS timeout ms value\n");
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&musb->lock, flags);
+	musb->a_wait_bcon = val;
+	if (musb->xceiv.state == OTG_STATE_A_WAIT_BCON)
+		musb->is_active = 0;
+	musb_platform_try_idle(musb, jiffies + msecs_to_jiffies(val));
+	spin_unlock_irqrestore(&musb->lock, flags);
+
+	return n;
+}
+
+static ssize_t
+musb_vbus_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct musb	*musb = dev_to_musb(dev);
+	unsigned long	flags;
+	unsigned long	val;
+	int		vbus;
+
+	spin_lock_irqsave(&musb->lock, flags);
+	val = musb->a_wait_bcon;
+	vbus = musb_platform_get_vbus_status(musb);
+	spin_unlock_irqrestore(&musb->lock, flags);
+
+	return sprintf(buf, "Vbus %s, timeout %lu\n",
+			vbus ? "on" : "off", val);
+}
+static DEVICE_ATTR(vbus, 0644, musb_vbus_show, musb_vbus_store);
+
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+
+/* Gadget drivers can't know that a host is connected so they might want
+ * to start SRP, but users can.  This allows userspace to trigger SRP.
+ */
+static ssize_t
+musb_srp_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t n)
+{
+	struct musb	*musb = dev_to_musb(dev);
+	unsigned short	srp;
+
+	if (sscanf(buf, "%hu", &srp) != 1
+			|| (srp != 1)) {
+		printk(KERN_ERR "SRP: Value must be 1\n");
+		return -EINVAL;
+	}
+
+	if (srp == 1)
+		musb_g_wakeup(musb);
+
+	return n;
+}
+static DEVICE_ATTR(srp, 0666, NULL, musb_srp_store);
+
+#endif /* CONFIG_USB_GADGET_MUSB_HDRC */
+
+#endif	/* sysfs */
+
+/* Only used to provide driver mode change events */
+static void musb_irq_work(struct work_struct *data)
+{
+	struct musb *musb = container_of(data, struct musb, irq_work);
+	static int old_state;
+
+	if (musb->xceiv.state != old_state) {
+		old_state = musb->xceiv.state;
+		sysfs_notify(&musb->controller->kobj, NULL, "mode");
+	}
+}
+
+/* --------------------------------------------------------------------------
+ * Init support
+ */
+
+static struct musb *__init
+allocate_instance(struct device *dev, void __iomem *mbase)
+{
+	struct musb		*musb;
+	struct musb_hw_ep	*ep;
+	int			epnum;
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+	struct usb_hcd	*hcd;
+
+	hcd = usb_create_hcd(&musb_hc_driver, dev, dev->bus_id);
+	if (!hcd)
+		return NULL;
+	/* usbcore sets dev->driver_data to hcd, and sometimes uses that... */
+
+	musb = hcd_to_musb(hcd);
+	INIT_LIST_HEAD(&musb->control);
+	INIT_LIST_HEAD(&musb->in_bulk);
+	INIT_LIST_HEAD(&musb->out_bulk);
+
+	hcd->uses_new_polling = 1;
+
+	musb->vbuserr_retry = VBUSERR_RETRY_COUNT;
+#else
+	musb = kzalloc(sizeof *musb, GFP_KERNEL);
+	if (!musb)
+		return NULL;
+	dev_set_drvdata(dev, musb);
+
+#endif
+
+	musb->mregs = mbase;
+	musb->ctrl_base = mbase;
+	musb->nIrq = -ENODEV;
+	for (epnum = 0, ep = musb->endpoints;
+			epnum < MUSB_C_NUM_EPS;
+			epnum++, ep++) {
+
+		ep->musb = musb;
+		ep->epnum = epnum;
+	}
+
+#ifdef CONFIG_USB_MUSB_OTG
+	otg_set_transceiver(&musb->xceiv);
+#endif
+	musb->controller = dev;
+	return musb;
+}
+
+static void musb_free(struct musb *musb)
+{
+	/* this has multiple entry modes. it handles fault cleanup after
+	 * probe(), where things may be partially set up, as well as rmmod
+	 * cleanup after everything's been de-activated.
+	 */
+
+#ifdef CONFIG_SYSFS
+	device_remove_file(musb->controller, &dev_attr_mode);
+	device_remove_file(musb->controller, &dev_attr_vbus);
+#ifdef CONFIG_USB_MUSB_OTG
+	device_remove_file(musb->controller, &dev_attr_srp);
+#endif
+#endif
+
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+	musb_gadget_cleanup(musb);
+#endif
+
+	if (musb->nIrq >= 0) {
+		disable_irq_wake(musb->nIrq);
+		free_irq(musb->nIrq, musb);
+	}
+	if (is_dma_capable() && musb->dma_controller) {
+		struct dma_controller	*c = musb->dma_controller;
+
+		(void) c->stop(c->private_data);
+		dma_controller_destroy(c);
+	}
+
+	musb_writeb(musb->mregs, MUSB_DEVCTL, 0);
+	musb_platform_exit(musb);
+	musb_writeb(musb->mregs, MUSB_DEVCTL, 0);
+
+	if (musb->clock) {
+		clk_disable(musb->clock);
+		clk_put(musb->clock);
+	}
+
+#ifdef CONFIG_USB_MUSB_OTG
+	put_device(musb->xceiv.dev);
+#endif
+
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+	usb_put_hcd(musb_to_hcd(musb));
+#else
+	kfree(musb);
+#endif
+}
+
+/*
+ * Perform generic per-controller initialization.
+ *
+ * @pDevice: the controller (already clocked, etc)
+ * @nIrq: irq
+ * @mregs: virtual address of controller registers,
+ *	not yet corrected for platform-specific offsets
+ */
+static int __init
+musb_init_controller(struct device *dev, int nIrq, void __iomem *ctrl)
+{
+	int			status;
+	struct musb		*musb;
+	struct musb_hdrc_platform_data *plat = dev->platform_data;
+
+	/* The driver might handle more features than the board; OK.
+	 * Fail when the board needs a feature that's not enabled.
+	 */
+	if (!plat) {
+		dev_dbg(dev, "no platform_data?\n");
+		return -ENODEV;
+	}
+	switch (plat->mode) {
+	case MUSB_HOST:
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+		break;
+#else
+		goto bad_config;
+#endif
+	case MUSB_PERIPHERAL:
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+		break;
+#else
+		goto bad_config;
+#endif
+	case MUSB_OTG:
+#ifdef CONFIG_USB_MUSB_OTG
+		break;
+#else
+bad_config:
+#endif
+	default:
+		dev_err(dev, "incompatible Kconfig role setting\n");
+		return -EINVAL;
+	}
+
+	/* allocate */
+	musb = allocate_instance(dev, ctrl);
+	if (!musb)
+		return -ENOMEM;
+
+	spin_lock_init(&musb->lock);
+	musb->board_mode = plat->mode;
+	musb->board_set_power = plat->set_power;
+	musb->set_clock = plat->set_clock;
+	musb->min_power = plat->min_power;
+
+	/* Clock usage is chip-specific ... functional clock (DaVinci,
+	 * OMAP2430), or PHY ref (some TUSB6010 boards).  All this core
+	 * code does is make sure a clock handle is available; platform
+	 * code manages it during start/stop and suspend/resume.
+	 */
+	if (plat->clock) {
+		musb->clock = clk_get(dev, plat->clock);
+		if (IS_ERR(musb->clock)) {
+			status = PTR_ERR(musb->clock);
+			musb->clock = NULL;
+			goto fail;
+		}
+	}
+
+	/* assume vbus is off */
+
+	/* platform adjusts musb->mregs and musb->isr if needed,
+	 * and activates clocks
+	 */
+	musb->isr = generic_interrupt;
+	status = musb_platform_init(musb);
+
+	if (status < 0)
+		goto fail;
+	if (!musb->isr) {
+		status = -ENODEV;
+		goto fail2;
+	}
+
+#ifndef CONFIG_MUSB_PIO_ONLY
+	if (use_dma && dev->dma_mask) {
+		struct dma_controller	*c;
+
+		c = dma_controller_create(musb, musb->mregs);
+		musb->dma_controller = c;
+		if (c)
+			(void) c->start(c->private_data);
+	}
+#endif
+	/* ideally this would be abstracted in platform setup */
+	if (!is_dma_capable() || !musb->dma_controller)
+		dev->dma_mask = NULL;
+
+	/* be sure interrupts are disabled before connecting ISR */
+	musb_platform_disable(musb);
+	musb_generic_disable(musb);
+
+	/* setup musb parts of the core (especially endpoints) */
+	status = musb_core_init(plat->multipoint
+			? MUSB_CONTROLLER_MHDRC
+			: MUSB_CONTROLLER_HDRC, musb);
+	if (status < 0)
+		goto fail2;
+
+	/* attach to the IRQ */
+	if (request_irq(nIrq, musb->isr, 0, dev->bus_id, musb)) {
+		dev_err(dev, "request_irq %d failed!\n", nIrq);
+		status = -ENODEV;
+		goto fail2;
+	}
+	musb->nIrq = nIrq;
+/* FIXME this handles wakeup irqs wrong */
+	if (enable_irq_wake(nIrq) == 0)
+		device_init_wakeup(dev, 1);
+
+	pr_info("%s: USB %s mode controller at %p using %s, IRQ %d\n",
+			musb_driver_name,
+			({char *s;
+			switch (musb->board_mode) {
+			case MUSB_HOST:		s = "Host"; break;
+			case MUSB_PERIPHERAL:	s = "Peripheral"; break;
+			default:		s = "OTG"; break;
+			}; s; }),
+			ctrl,
+			(is_dma_capable() && musb->dma_controller)
+				? "DMA" : "PIO",
+			musb->nIrq);
+
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+	/* host side needs more setup, except for no-host modes */
+	if (musb->board_mode != MUSB_PERIPHERAL) {
+		struct usb_hcd	*hcd = musb_to_hcd(musb);
+
+		if (musb->board_mode == MUSB_OTG)
+			hcd->self.otg_port = 1;
+		musb->xceiv.host = &hcd->self;
+		hcd->power_budget = 2 * (plat->power ? : 250);
+	}
+#endif				/* CONFIG_USB_MUSB_HDRC_HCD */
+
+	/* For the host-only role, we can activate right away.
+	 * (We expect the ID pin to be forcibly grounded!!)
+	 * Otherwise, wait till the gadget driver hooks up.
+	 */
+	if (!is_otg_enabled(musb) && is_host_enabled(musb)) {
+		MUSB_HST_MODE(musb);
+		musb->xceiv.default_a = 1;
+		musb->xceiv.state = OTG_STATE_A_IDLE;
+
+		status = usb_add_hcd(musb_to_hcd(musb), -1, 0);
+
+		DBG(1, "%s mode, status %d, devctl %02x %c\n",
+			"HOST", status,
+			musb_readb(musb->mregs, MUSB_DEVCTL),
+			(musb_readb(musb->mregs, MUSB_DEVCTL)
+					& MUSB_DEVCTL_BDEVICE
+				? 'B' : 'A'));
+
+	} else /* peripheral is enabled */ {
+		MUSB_DEV_MODE(musb);
+		musb->xceiv.default_a = 0;
+		musb->xceiv.state = OTG_STATE_B_IDLE;
+
+		status = musb_gadget_setup(musb);
+
+		DBG(1, "%s mode, status %d, dev%02x\n",
+			is_otg_enabled(musb) ? "OTG" : "PERIPHERAL",
+			status,
+			musb_readb(musb->mregs, MUSB_DEVCTL));
+
+	}
+
+	if (status == 0) {
+		musb_debug_create("driver/musb_hdrc", musb);
+		musb_init_hset(musb);
+	} else {
+fail:
+		if (musb->clock)
+			clk_put(musb->clock);
+		device_init_wakeup(dev, 0);
+		musb_free(musb);
+		return status;
+	}
+
+	INIT_WORK(&musb->irq_work, musb_irq_work);
+
+#ifdef CONFIG_SYSFS
+	status = device_create_file(dev, &dev_attr_mode);
+	status = device_create_file(dev, &dev_attr_vbus);
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+	status = device_create_file(dev, &dev_attr_srp);
+#endif /* CONFIG_USB_GADGET_MUSB_HDRC */
+	status = 0;
+#endif
+
+	return status;
+
+fail2:
+	musb_platform_exit(musb);
+	goto fail;
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* all implementations (PCI bridge to FPGA, VLYNQ, etc) should just
+ * bridge to a platform device; this driver then suffices.
+ */
+
+#ifndef CONFIG_MUSB_PIO_ONLY
+static u64	*orig_dma_mask;
+#endif
+
+static int __init musb_probe(struct platform_device *pdev)
+{
+	struct device	*dev = &pdev->dev;
+	int		irq = platform_get_irq(pdev, 0);
+	struct resource	*iomem;
+	void __iomem	*base;
+
+	iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!iomem || irq == 0)
+		return -ENODEV;
+
+	base = ioremap(iomem->start, iomem->end - iomem->start + 1);
+	if (!base) {
+		dev_err(dev, "ioremap failed\n");
+		return -ENOMEM;
+	}
+
+#ifndef CONFIG_MUSB_PIO_ONLY
+	/* clobbered by use_dma=n */
+	orig_dma_mask = dev->dma_mask;
+#endif
+	return musb_init_controller(dev, irq, base);
+}
+
+static int __devexit musb_remove(struct platform_device *pdev)
+{
+	struct musb	*musb = dev_to_musb(&pdev->dev);
+	void __iomem	*ctrl_base = musb->ctrl_base;
+
+	/* this gets called on rmmod.
+	 *  - Host mode: host may still be active
+	 *  - Peripheral mode: peripheral is deactivated (or never-activated)
+	 *  - OTG mode: both roles are deactivated (or never-activated)
+	 */
+	musb_shutdown(pdev);
+	musb_exit_hset(musb);
+	musb_debug_delete("driver/musb_hdrc", musb);
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+	if (musb->board_mode == MUSB_HOST)
+		usb_remove_hcd(musb_to_hcd(musb));
+#endif
+	musb_free(musb);
+	iounmap(ctrl_base);
+	device_init_wakeup(&pdev->dev, 0);
+#ifndef CONFIG_MUSB_PIO_ONLY
+	pdev->dev.dma_mask = orig_dma_mask;
+#endif
+	return 0;
+}
+
+#ifdef	CONFIG_PM
+
+static int musb_suspend(struct platform_device *pdev, pm_message_t message)
+{
+	unsigned long	flags;
+	struct musb	*musb = dev_to_musb(&pdev->dev);
+
+	if (!musb->clock)
+		return 0;
+
+	spin_lock_irqsave(&musb->lock, flags);
+
+	if (is_peripheral_active(musb)) {
+		/* FIXME force disconnect unless we know USB will wake
+		 * the system up quickly enough to respond ...
+		 */
+	} else if (is_host_active(musb)) {
+		/* we know all the children are suspended; sometimes
+		 * they will even be wakeup-enabled.
+		 */
+	}
+
+	if (musb->set_clock)
+		musb->set_clock(musb->clock, 0);
+	else
+		clk_disable(musb->clock);
+	spin_unlock_irqrestore(&musb->lock, flags);
+	return 0;
+}
+
+static int musb_resume(struct platform_device *pdev)
+{
+	unsigned long	flags;
+	struct musb	*musb = dev_to_musb(&pdev->dev);
+
+	if (!musb->clock)
+		return 0;
+
+	spin_lock_irqsave(&musb->lock, flags);
+
+	if (musb->set_clock)
+		musb->set_clock(musb->clock, 1);
+	else
+		clk_enable(musb->clock);
+
+	/* for static cmos like DaVinci, register values were preserved
+	 * unless for some reason the whole soc powered down and we're
+	 * not treating that as a whole-system restart (e.g. swsusp)
+	 */
+	spin_unlock_irqrestore(&musb->lock, flags);
+	return 0;
+}
+
+#else
+#define	musb_suspend	NULL
+#define	musb_resume	NULL
+#endif
+
+static struct platform_driver musb_driver = {
+	.driver = {
+		.name		= (char *)musb_driver_name,
+		.bus		= &platform_bus_type,
+		.owner		= THIS_MODULE,
+	},
+	.remove		= __devexit_p(musb_remove),
+	.shutdown	= musb_shutdown,
+	.suspend	= musb_suspend,
+	.resume		= musb_resume,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int __init musb_init(void)
+{
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+	if (usb_disabled())
+		return 0;
+#endif
+
+	pr_info("%s: version " MUSB_VERSION ", "
+#ifdef CONFIG_MUSB_PIO_ONLY
+		"pio"
+#elif defined(CONFIG_USB_TI_CPPI_DMA)
+		"cppi-dma"
+#elif defined(CONFIG_USB_INVENTRA_DMA)
+		"musb-dma"
+#elif defined(CONFIG_USB_TUSB_OMAP_DMA)
+		"tusb-omap-dma"
+#else
+		"?dma?"
+#endif
+		", "
+#ifdef CONFIG_USB_MUSB_OTG
+		"otg (peripheral+host)"
+#elif defined(CONFIG_USB_GADGET_MUSB_HDRC)
+		"peripheral"
+#elif defined(CONFIG_USB_MUSB_HDRC_HCD)
+		"host"
+#endif
+		", debug=%d\n",
+		musb_driver_name, debug);
+	return platform_driver_probe(&musb_driver, musb_probe);
+}
+
+/* make us init after usbcore and before usb
+ * gadget and host-side drivers start to register
+ */
+subsys_initcall(musb_init);
+
+static void __exit musb_cleanup(void)
+{
+	platform_driver_unregister(&musb_driver);
+}
+module_exit(musb_cleanup);
diff -ruN linux-omap-2.6/drivers/usb/musb/musb_core.h maemo_src/drivers/usb/musb/musb_core.h
--- linux-omap-2.6/drivers/usb/musb/musb_core.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/usb/musb/musb_core.h	2011-02-06 20:12:11.263333273 -0500
@@ -0,0 +1,524 @@
+/*
+ * MUSB OTG driver defines
+ *
+ * Copyright 2005 Mentor Graphics Corporation
+ * Copyright (C) 2005-2006 by Texas Instruments
+ * Copyright (C) 2006-2007 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __MUSB_CORE_H__
+#define __MUSB_CORE_H__
+
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/smp_lock.h>
+#include <linux/errno.h>
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb_gadget.h>
+#include <linux/usb.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/musb.h>
+
+struct musb;
+struct musb_hw_ep;
+struct musb_ep;
+
+
+#include "musb_debug.h"
+#include "musb_dma.h"
+
+#ifdef CONFIG_USB_MUSB_SOC
+/*
+ * Get core configuration from a header converted (by cfg_conv)
+ * from the Verilog config file generated by the core config utility
+ *
+ * For now we assume that header is provided along with other
+ * arch-specific files.  Discrete chips will need a build tweak.
+ * So will using AHB IDs from silicon that provides them.
+ */
+#include <asm/arch/hdrc_cnf.h>
+#endif
+
+#include "musb_io.h"
+#include "musb_regs.h"
+
+#include "musb_gadget.h"
+#include "../core/hcd.h"
+#include "musb_host.h"
+
+
+
+#ifdef CONFIG_USB_MUSB_OTG
+
+#define	is_peripheral_enabled(musb)	((musb)->board_mode != MUSB_HOST)
+#define	is_host_enabled(musb)		((musb)->board_mode != MUSB_PERIPHERAL)
+#define	is_otg_enabled(musb)		((musb)->board_mode == MUSB_OTG)
+
+/* NOTE:  otg and peripheral-only state machines start at B_IDLE.
+ * OTG or host-only go to A_IDLE when ID is sensed.
+ */
+#define is_peripheral_active(m)		(!(m)->is_host)
+#define is_host_active(m)		((m)->is_host)
+
+#else
+#define	is_peripheral_enabled(musb)	is_peripheral_capable()
+#define	is_host_enabled(musb)		is_host_capable()
+#define	is_otg_enabled(musb)		0
+
+#define	is_peripheral_active(musb)	is_peripheral_capable()
+#define	is_host_active(musb)		is_host_capable()
+#endif
+
+#if defined(CONFIG_USB_MUSB_OTG) || defined(CONFIG_USB_MUSB_PERIPHERAL)
+/* for some reason, the "select USB_GADGET_MUSB_HDRC" doesn't always
+ * override that choice selection (often USB_GADGET_DUMMY_HCD).
+ */
+#ifndef CONFIG_USB_GADGET_MUSB_HDRC
+#error bogus Kconfig output ... select CONFIG_USB_GADGET_MUSB_HDRC
+#endif
+#endif	/* need MUSB gadget selection */
+
+
+#ifdef CONFIG_PROC_FS
+#include <linux/fs.h>
+#define MUSB_CONFIG_PROC_FS
+#endif
+
+/****************************** PERIPHERAL ROLE *****************************/
+
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+
+#define	is_peripheral_capable()	(1)
+
+extern irqreturn_t musb_g_ep0_irq(struct musb *);
+extern void musb_g_tx(struct musb *, u8);
+extern void musb_g_rx(struct musb *, u8);
+extern void musb_g_reset(struct musb *);
+extern void musb_g_suspend(struct musb *);
+extern void musb_g_resume(struct musb *);
+extern void musb_g_wakeup(struct musb *);
+extern void musb_g_disconnect(struct musb *);
+
+#else
+
+#define	is_peripheral_capable()	(0)
+
+static inline irqreturn_t musb_g_ep0_irq(struct musb *m) { return IRQ_NONE; }
+static inline void musb_g_reset(struct musb *m) {}
+static inline void musb_g_suspend(struct musb *m) {}
+static inline void musb_g_resume(struct musb *m) {}
+static inline void musb_g_wakeup(struct musb *m) {}
+static inline void musb_g_disconnect(struct musb *m) {}
+
+#endif
+
+/****************************** HOST ROLE ***********************************/
+
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+
+#define	is_host_capable()	(1)
+
+extern irqreturn_t musb_h_ep0_irq(struct musb *);
+extern void musb_host_tx(struct musb *, u8);
+extern void musb_host_rx(struct musb *, u8);
+
+#else
+
+#define	is_host_capable()	(0)
+
+static inline irqreturn_t musb_h_ep0_irq(struct musb *m) { return IRQ_NONE; }
+static inline void musb_host_tx(struct musb *m, u8 e) {}
+static inline void musb_host_rx(struct musb *m, u8 e) {}
+
+#endif
+
+
+/****************************** CONSTANTS ********************************/
+
+#ifndef MUSB_C_NUM_EPS
+#define MUSB_C_NUM_EPS ((u8)16)
+#endif
+
+#ifndef MUSB_MAX_END0_PACKET
+#define MUSB_MAX_END0_PACKET ((u16)MUSB_EP0_FIFOSIZE)
+#endif
+
+/* host side ep0 states */
+enum musb_h_ep0_state {
+	MUSB_EP0_IDLE,
+	MUSB_EP0_START,			/* expect ack of setup */
+	MUSB_EP0_IN,			/* expect IN DATA */
+	MUSB_EP0_OUT,			/* expect ack of OUT DATA */
+	MUSB_EP0_STATUS,		/* expect ack of STATUS */
+} __attribute__ ((packed));
+
+/* peripheral side ep0 states */
+enum musb_g_ep0_state {
+	MUSB_EP0_STAGE_SETUP,		/* idle, waiting for setup */
+	MUSB_EP0_STAGE_TX,		/* IN data */
+	MUSB_EP0_STAGE_RX,		/* OUT data */
+	MUSB_EP0_STAGE_STATUSIN,	/* (after OUT data) */
+	MUSB_EP0_STAGE_STATUSOUT,	/* (after IN data) */
+	MUSB_EP0_STAGE_ACKWAIT,		/* after zlp, before statusin */
+} __attribute__ ((packed));
+
+/* OTG protocol constants */
+#define OTG_TIME_A_WAIT_VRISE	100		/* msec (max) */
+#define OTG_TIME_A_WAIT_BCON	0		/* 0=infinite; min 1000 msec */
+#define OTG_TIME_A_IDLE_BDIS	200		/* msec (min) */
+
+/*************************** REGISTER ACCESS ********************************/
+
+/* Endpoint registers (other than dynfifo setup) can be accessed either
+ * directly with the "flat" model, or after setting up an index register.
+ */
+
+#if defined(CONFIG_ARCH_DAVINCI) || defined(CONFIG_ARCH_OMAP2430) \
+		|| defined(CONFIG_ARCH_OMAP3430)
+/* REVISIT indexed access seemed to
+ * misbehave (on DaVinci) for at least peripheral IN ...
+ */
+#define	MUSB_FLAT_REG
+#endif
+
+/* TUSB mapping: "flat" plus ep0 special cases */
+#if	defined(CONFIG_USB_TUSB6010)
+#define musb_ep_select(_mbase, _epnum) \
+	musb_writeb((_mbase), MUSB_INDEX, (_epnum))
+#define	MUSB_EP_OFFSET			MUSB_TUSB_OFFSET
+
+/* "flat" mapping: each endpoint has its own i/o address */
+#elif	defined(MUSB_FLAT_REG)
+#define musb_ep_select(_mbase, _epnum)	(((void)(_mbase)), ((void)(_epnum)))
+#define	MUSB_EP_OFFSET			MUSB_FLAT_OFFSET
+
+/* "indexed" mapping: INDEX register controls register bank select */
+#else
+#define musb_ep_select(_mbase, _epnum) \
+	musb_writeb((_mbase), MUSB_INDEX, (_epnum))
+#define	MUSB_EP_OFFSET			MUSB_INDEXED_OFFSET
+#endif
+
+/****************************** FUNCTIONS ********************************/
+
+#define MUSB_HST_MODE(_musb)\
+	{ (_musb)->is_host = true; }
+#define MUSB_DEV_MODE(_musb) \
+	{ (_musb)->is_host = false; }
+
+#define test_devctl_hst_mode(_x) \
+	(musb_readb((_x)->mregs, MUSB_DEVCTL)&MUSB_DEVCTL_HM)
+
+#define MUSB_MODE(musb) ((musb)->is_host ? "Host" : "Peripheral")
+
+/******************************** TYPES *************************************/
+
+/*
+ * struct musb_hw_ep - endpoint hardware (bidirectional)
+ *
+ * Ordered slightly for better cacheline locality.
+ */
+struct musb_hw_ep {
+	struct musb		*musb;
+	void __iomem		*fifo;
+	void __iomem		*regs;
+
+#ifdef CONFIG_USB_TUSB6010
+	void __iomem		*conf;
+#endif
+
+	/* index in musb->endpoints[]  */
+	u8			epnum;
+
+	/* hardware configuration, possibly dynamic */
+	bool			is_shared_fifo;
+	bool			tx_double_buffered;
+	bool			rx_double_buffered;
+	u16			max_packet_sz_tx;
+	u16			max_packet_sz_rx;
+
+	struct dma_channel	*tx_channel;
+	struct dma_channel	*rx_channel;
+
+#ifdef CONFIG_USB_TUSB6010
+	/* TUSB has "asynchronous" and "synchronous" dma modes */
+	dma_addr_t		fifo_async;
+	dma_addr_t		fifo_sync;
+	void __iomem		*fifo_sync_va;
+#endif
+
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+	void __iomem		*target_regs;
+
+	/* currently scheduled peripheral endpoint */
+	struct musb_qh		*in_qh;
+	struct musb_qh		*out_qh;
+
+	u8			rx_reinit;
+	u8			tx_reinit;
+#endif
+
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+	/* peripheral side */
+	struct musb_ep		ep_in;			/* TX */
+	struct musb_ep		ep_out;			/* RX */
+#endif
+};
+
+static inline struct usb_request *next_in_request(struct musb_hw_ep *hw_ep)
+{
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+	return next_request(&hw_ep->ep_in);
+#else
+	return NULL;
+#endif
+}
+
+static inline struct usb_request *next_out_request(struct musb_hw_ep *hw_ep)
+{
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+	return next_request(&hw_ep->ep_out);
+#else
+	return NULL;
+#endif
+}
+
+/*
+ * struct musb - Driver instance data.
+ */
+struct musb {
+	spinlock_t		lock;
+	struct clk		*clock;
+	irqreturn_t		(*isr)(int, void *);
+	struct work_struct	irq_work;
+
+/* this hub status bit is reserved by USB 2.0 and not seen by usbcore */
+#define MUSB_PORT_STAT_RESUME	(1 << 31)
+
+	u32			port1_status;
+
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+	unsigned long		rh_timer;
+
+	enum musb_h_ep0_state	ep0_stage;
+
+	/* bulk traffic normally dedicates endpoint hardware, and each
+	 * direction has its own ring of host side endpoints.
+	 * we try to progress the transfer at the head of each endpoint's
+	 * queue until it completes or NAKs too much; then we try the next
+	 * endpoint.
+	 */
+	struct musb_hw_ep	*bulk_ep;
+
+	struct list_head	control;	/* of musb_qh */
+	struct list_head	in_bulk;	/* of musb_qh */
+	struct list_head	out_bulk;	/* of musb_qh */
+	struct musb_qh		*periodic[32];	/* tree of interrupt+iso */
+#endif
+
+	/* called with IRQs blocked; ON/nonzero implies starting a session,
+	 * and waiting at least a_wait_vrise_tmout.
+	 */
+	void			(*board_set_vbus)(struct musb *, int is_on);
+
+	struct dma_controller	*dma_controller;
+
+	struct device		*controller;
+	void __iomem		*ctrl_base;
+	void __iomem		*mregs;
+
+#ifdef CONFIG_USB_TUSB6010
+	dma_addr_t		async;
+	dma_addr_t		sync;
+	void __iomem		*sync_va;
+#endif
+
+	/* passed down from chip/board specific irq handlers */
+	u8			int_usb;
+	u16			int_rx;
+	u16			int_tx;
+
+	struct otg_transceiver	xceiv;
+
+	int nIrq;
+
+	struct musb_hw_ep	 endpoints[MUSB_C_NUM_EPS];
+#define control_ep		endpoints
+
+#define VBUSERR_RETRY_COUNT	3
+	u16			vbuserr_retry;
+	u16 epmask;
+	u8 nr_endpoints;
+
+	u8 board_mode;		/* enum musb_mode */
+	int			(*board_set_power)(int state);
+
+	int			(*set_clock)(struct clk *clk, int is_active);
+
+	u8			min_power;	/* vbus for periph, in mA/2 */
+
+	bool			is_host;
+
+	int			a_wait_bcon;	/* VBUS timeout in msecs */
+	unsigned long		idle_timeout;	/* Next timeout in jiffies */
+	unsigned		srp_sent:1;	/* Check for SRP timeout */
+
+	/* active means connected and not suspended */
+	unsigned		is_active:1;
+
+	unsigned is_multipoint:1;
+	unsigned ignore_disconnect:1;	/* during bus resets */
+
+#ifdef C_MP_TX
+	unsigned bulk_split:1;
+#define	can_bulk_split(musb,type) \
+		(((type) == USB_ENDPOINT_XFER_BULK) && (musb)->bulk_split)
+#else
+#define	can_bulk_split(musb, type)	0
+#endif
+
+#ifdef C_MP_RX
+	unsigned bulk_combine:1;
+#define	can_bulk_combine(musb,type) \
+		(((type) == USB_ENDPOINT_XFER_BULK) && (musb)->bulk_combine)
+#else
+#define	can_bulk_combine(musb, type)	0
+#endif
+
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+	/* is_suspended means USB B_PERIPHERAL suspend */
+	unsigned		is_suspended:1;
+
+	/* may_wakeup means remote wakeup is enabled */
+	unsigned		may_wakeup:1;
+
+	/* is_self_powered is reported in device status and the
+	 * config descriptor.  is_bus_powered means B_PERIPHERAL
+	 * draws some VBUS current; both can be true.
+	 */
+	unsigned		is_self_powered:1;
+	unsigned		is_bus_powered:1;
+
+	unsigned		set_address:1;
+	unsigned		test_mode:1;
+	unsigned		softconnect:1;
+
+	u8			address;
+	u8			test_mode_nr;
+	u16			ackpend;		/* ep0 */
+	enum musb_g_ep0_state	ep0_state;
+	struct usb_gadget	g;			/* the gadget */
+	struct usb_gadget_driver *gadget_driver;	/* its driver */
+#endif
+
+#ifdef MUSB_CONFIG_PROC_FS
+	struct proc_dir_entry *proc_entry;
+#endif
+};
+
+static inline void musb_set_vbus(struct musb *musb, int is_on)
+{
+	musb->board_set_vbus(musb, is_on);
+}
+
+#ifdef CONFIG_USB_GADGET_MUSB_HDRC
+static inline struct musb *gadget_to_musb(struct usb_gadget *g)
+{
+	return container_of(g, struct musb, g);
+}
+#endif
+
+
+/***************************** Glue it together *****************************/
+
+extern const char musb_driver_name[];
+
+extern void musb_start(struct musb *musb);
+extern void musb_stop(struct musb *musb);
+
+extern void musb_write_fifo(struct musb_hw_ep *ep, u16 len, const u8 *src);
+extern void musb_read_fifo(struct musb_hw_ep *ep, u16 len, u8 *dst);
+
+extern void musb_load_testpacket(struct musb *);
+
+extern irqreturn_t musb_interrupt(struct musb *);
+
+extern void musb_platform_enable(struct musb *musb);
+extern void musb_platform_disable(struct musb *musb);
+
+extern void musb_hnp_stop(struct musb *musb);
+
+#ifdef CONFIG_USB_TUSB6010
+extern void musb_platform_wakeup(struct musb *musb);
+extern void musb_platform_try_idle(struct musb *musb, unsigned long timeout);
+extern int musb_platform_get_vbus_status(struct musb *musb);
+extern void musb_platform_set_mode(struct musb *musb, u8 musb_mode);
+#else
+#define musb_platform_wakeup(x)			do {} while (0)
+#define musb_platform_try_idle(x, y)		do {} while (0)
+#define musb_platform_get_vbus_status(x)	0
+#define musb_platform_set_mode(x, y)		do {} while (0)
+#endif
+
+extern int __init musb_platform_init(struct musb *musb);
+extern int musb_platform_exit(struct musb *musb);
+
+/*-------------------------- ProcFS definitions ---------------------*/
+
+struct proc_dir_entry;
+
+#if (MUSB_DEBUG > 0) && defined(MUSB_CONFIG_PROC_FS)
+extern struct proc_dir_entry *musb_debug_create(char *name, struct musb *data);
+extern void musb_debug_delete(char *name, struct musb *data);
+#else
+static inline struct proc_dir_entry *
+musb_debug_create(char *name, struct musb *data)
+{
+	return NULL;
+}
+static inline void musb_debug_delete(char *name, struct musb *data)
+{
+}
+#endif
+#if defined(CONFIG_USB_MUSB_HSET) || defined(CONFIG_USB_MUSB_HSET_MODULE)
+extern void musb_init_hset(struct musb *musb);
+extern void musb_exit_hset(struct musb *musb);
+#else
+static inline void musb_init_hset(struct musb *musb)
+{
+}
+static inline void musb_exit_hset(struct musb *musb)
+{
+}
+#endif
+
+#endif	/* __MUSB_CORE_H__ */
diff -ruN linux-omap-2.6/drivers/usb/musb/musb_debug.h maemo_src/drivers/usb/musb/musb_debug.h
--- linux-omap-2.6/drivers/usb/musb/musb_debug.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/usb/musb/musb_debug.h	2011-02-06 20:12:11.316666607 -0500
@@ -0,0 +1,66 @@
+/*
+ * MUSB OTG driver debug defines
+ *
+ * Copyright 2005 Mentor Graphics Corporation
+ * Copyright (C) 2005-2006 by Texas Instruments
+ * Copyright (C) 2006-2007 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __MUSB_LINUX_DEBUG_H__
+#define __MUSB_LINUX_DEBUG_H__
+
+#define yprintk(facility, format, args...) \
+	do { printk(facility "%s %d: " format , \
+	__func__, __LINE__ , ## args); } while (0)
+#define WARN(fmt, args...) yprintk(KERN_WARNING, fmt, ## args)
+#define INFO(fmt, args...) yprintk(KERN_INFO, fmt, ## args)
+#define ERR(fmt, args...) yprintk(KERN_ERR, fmt, ## args)
+
+#define xprintk(level, facility, format, args...) do { \
+	if (_dbg_level(level)) { \
+		printk(facility "%s %d: " format , \
+				__func__, __LINE__ , ## args); \
+	} } while (0)
+
+#if MUSB_DEBUG > 0
+extern unsigned debug;
+#else
+#define debug	0
+#endif
+
+static inline int _dbg_level(unsigned l)
+{
+	return debug >= l;
+}
+
+#define DBG(level, fmt, args...) xprintk(level, KERN_DEBUG, fmt, ## args)
+
+extern const char *otg_state_string(struct musb *);
+
+#endif				/*  __MUSB_LINUX_DEBUG_H__ */
diff -ruN linux-omap-2.6/drivers/usb/musb/musbdefs.h maemo_src/drivers/usb/musb/musbdefs.h
--- linux-omap-2.6/drivers/usb/musb/musbdefs.h	2011-02-06 20:17:25.889999940 -0500
+++ maemo_src/drivers/usb/musb/musbdefs.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,541 +0,0 @@
-/******************************************************************
- * Copyright 2005 Mentor Graphics Corporation
- * Copyright (C) 2005-2006 by Texas Instruments
- *
- * This file is part of the Inventra Controller Driver for Linux.
- *
- * The Inventra Controller Driver for Linux is free software; you
- * can redistribute it and/or modify it under the terms of the GNU
- * General Public License version 2 as published by the Free Software
- * Foundation.
- *
- * The Inventra Controller Driver for Linux is distributed in
- * the hope that it will be useful, but WITHOUT ANY WARRANTY;
- * without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
- * License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with The Inventra Controller Driver for Linux ; if not,
- * write to the Free Software Foundation, Inc., 59 Temple Place,
- * Suite 330, Boston, MA  02111-1307  USA
- *
- * ANY DOWNLOAD, USE, REPRODUCTION, MODIFICATION OR DISTRIBUTION
- * OF THIS DRIVER INDICATES YOUR COMPLETE AND UNCONDITIONAL ACCEPTANCE
- * OF THOSE TERMS.THIS DRIVER IS PROVIDED "AS IS" AND MENTOR GRAPHICS
- * MAKES NO WARRANTIES, EXPRESS OR IMPLIED, RELATED TO THIS DRIVER.
- * MENTOR GRAPHICS SPECIFICALLY DISCLAIMS ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY; FITNESS FOR A PARTICULAR PURPOSE AND
- * NON-INFRINGEMENT.  MENTOR GRAPHICS DOES NOT PROVIDE SUPPORT
- * SERVICES OR UPDATES FOR THIS DRIVER, EVEN IF YOU ARE A MENTOR
- * GRAPHICS SUPPORT CUSTOMER.
- ******************************************************************/
-
-#ifndef __MUSB_MUSBDEFS_H__
-#define __MUSB_MUSBDEFS_H__
-
-#include <linux/slab.h>
-#include <linux/list.h>
-#include <linux/interrupt.h>
-#include <linux/smp_lock.h>
-#include <linux/errno.h>
-#include <linux/clk.h>
-#include <linux/device.h>
-#include <linux/usb/ch9.h>
-#include <linux/usb_gadget.h>
-#include <linux/usb.h>
-#include <linux/usb/otg.h>
-#include <linux/usb/musb.h>
-
-struct musb;
-struct musb_hw_ep;
-struct musb_ep;
-
-
-#include "debug.h"
-#include "dma.h"
-
-#ifdef CONFIG_USB_MUSB_SOC
-/*
- * Get core configuration from a header converted (by cfg_conv)
- * from the Verilog config file generated by the core config utility
- *
- * For now we assume that header is provided along with other
- * arch-specific files.  Discrete chips will need a build tweak.
- * So will using AHB IDs from silicon that provides them.
- */
-#include <asm/arch/hdrc_cnf.h>
-#endif
-
-#include "plat_arc.h"
-#include "musbhdrc.h"
-
-#include "musb_gadget.h"
-#include "../core/hcd.h"
-#include "musb_host.h"
-
-
-
-#ifdef CONFIG_USB_MUSB_OTG
-
-#define	is_peripheral_enabled(musb)	((musb)->board_mode != MUSB_HOST)
-#define	is_host_enabled(musb)		((musb)->board_mode != MUSB_PERIPHERAL)
-#define	is_otg_enabled(musb)		((musb)->board_mode == MUSB_OTG)
-
-/* NOTE:  otg and peripheral-only state machines start at B_IDLE.
- * OTG or host-only go to A_IDLE when ID is sensed.
- */
-#define is_peripheral_active(m)		(!(m)->bIsHost)
-#define is_host_active(m)		((m)->bIsHost)
-
-#else
-#define	is_peripheral_enabled(musb)	is_peripheral_capable()
-#define	is_host_enabled(musb)		is_host_capable()
-#define	is_otg_enabled(musb)		0
-
-#define	is_peripheral_active(musb)	is_peripheral_capable()
-#define	is_host_active(musb)		is_host_capable()
-#endif
-
-#if defined(CONFIG_USB_MUSB_OTG) || defined(CONFIG_USB_MUSB_PERIPHERAL)
-/* for some reason, the "select USB_GADGET_MUSB_HDRC" doesn't always
- * override that choice selection (often USB_GADGET_DUMMY_HCD).
- */
-#ifndef CONFIG_USB_GADGET_MUSB_HDRC
-#error bogus Kconfig output ... select CONFIG_USB_GADGET_MUSB_HDRC
-#endif
-#endif	/* need MUSB gadget selection */
-
-
-#ifdef CONFIG_PROC_FS
-#include <linux/fs.h>
-#define MUSB_CONFIG_PROC_FS
-#endif
-
-/****************************** PERIPHERAL ROLE *****************************/
-
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
-
-#define	is_peripheral_capable()	(1)
-
-extern irqreturn_t musb_g_ep0_irq(struct musb *);
-extern void musb_g_tx(struct musb *, u8);
-extern void musb_g_rx(struct musb *, u8);
-extern void musb_g_reset(struct musb *);
-extern void musb_g_suspend(struct musb *);
-extern void musb_g_resume(struct musb *);
-extern void musb_g_disconnect(struct musb *);
-
-#else
-
-#define	is_peripheral_capable()	(0)
-
-static inline irqreturn_t musb_g_ep0_irq(struct musb *m) { return IRQ_NONE; }
-static inline void musb_g_reset(struct musb *m) {}
-static inline void musb_g_suspend(struct musb *m) {}
-static inline void musb_g_resume(struct musb *m) {}
-static inline void musb_g_disconnect(struct musb *m) {}
-
-#endif
-
-/****************************** HOST ROLE ***********************************/
-
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-
-#define	is_host_capable()	(1)
-
-extern irqreturn_t musb_h_ep0_irq(struct musb *);
-extern void musb_host_tx(struct musb *, u8);
-extern void musb_host_rx(struct musb *, u8);
-
-#else
-
-#define	is_host_capable()	(0)
-
-static inline irqreturn_t musb_h_ep0_irq(struct musb *m) { return IRQ_NONE; }
-static inline void musb_host_tx(struct musb *m, u8 e) {}
-static inline void musb_host_rx(struct musb *m, u8 e) {}
-
-#endif
-
-
-/****************************** CONSTANTS ********************************/
-
-#ifndef TRUE
-#define TRUE 1
-#endif
-#ifndef FALSE
-#define FALSE 0
-#endif
-
-#ifndef MUSB_C_NUM_EPS
-#define MUSB_C_NUM_EPS ((u8)16)
-#endif
-
-#ifndef MUSB_MAX_END0_PACKET
-#define MUSB_MAX_END0_PACKET ((u16)MGC_END0_FIFOSIZE)
-#endif
-
-/* host side ep0 states */
-enum musb_h_ep0_state {
-	MGC_END0_IDLE,
-	MGC_END0_START,			/* expect ack of setup */
-	MGC_END0_IN,			/* expect IN DATA */
-	MGC_END0_OUT,			/* expect ack of OUT DATA */
-	MGC_END0_STATUS,		/* expect ack of STATUS */
-} __attribute__ ((packed));
-
-/* peripheral side ep0 states */
-enum musb_g_ep0_state {
-	MGC_END0_STAGE_SETUP,		/* idle, waiting for setup */
-	MGC_END0_STAGE_TX,		/* IN data */
-	MGC_END0_STAGE_RX,		/* OUT data */
-	MGC_END0_STAGE_STATUSIN,	/* (after OUT data) */
-	MGC_END0_STAGE_STATUSOUT,	/* (after IN data) */
-	MGC_END0_STAGE_ACKWAIT,		/* after zlp, before statusin */
-} __attribute__ ((packed));
-
-/* OTG protocol constants */
-#define OTG_TIME_A_WAIT_VRISE	100		/* msec (max) */
-#define OTG_TIME_A_WAIT_BCON	0		/* 0=infinite; min 1000 msec */
-#define OTG_TIME_A_IDLE_BDIS	200		/* msec (min) */
-
-/*************************** REGISTER ACCESS ********************************/
-
-/* Endpoint registers (other than dynfifo setup) can be accessed either
- * directly with the "flat" model, or after setting up an index register.
- */
-
-#if defined(CONFIG_ARCH_DAVINCI) || defined(CONFIG_ARCH_OMAP2430)
-/* REVISIT indexed access seemed to
- * misbehave (on DaVinci) for at least peripheral IN ...
- */
-#define	MUSB_FLAT_REG
-#endif
-
-/* TUSB mapping: "flat" plus ep0 special cases */
-#if	defined(CONFIG_USB_TUSB6010)
-#define MGC_SelectEnd(_pBase, _bEnd) \
-	musb_writeb((_pBase), MGC_O_HDRC_INDEX, (_bEnd))
-#define	MGC_END_OFFSET			MGC_TUSB_OFFSET
-
-/* "flat" mapping: each endpoint has its own i/o address */
-#elif	defined(MUSB_FLAT_REG)
-#define MGC_SelectEnd(_pBase, _bEnd)	(((void)(_pBase)),((void)(_bEnd)))
-#define	MGC_END_OFFSET			MGC_FLAT_OFFSET
-
-/* "indexed" mapping: INDEX register controls register bank select */
-#else
-#define MGC_SelectEnd(_pBase, _bEnd) \
-	musb_writeb((_pBase), MGC_O_HDRC_INDEX, (_bEnd))
-#define	MGC_END_OFFSET			MGC_INDEXED_OFFSET
-#endif
-
-/****************************** FUNCTIONS ********************************/
-
-#define MUSB_HST_MODE(_pthis)\
-	{ (_pthis)->bIsHost=TRUE; }
-#define MUSB_DEV_MODE(_pthis) \
-	{ (_pthis)->bIsHost=FALSE; }
-
-#define test_devctl_hst_mode(_x) \
-	(musb_readb((_x)->pRegs, MGC_O_HDRC_DEVCTL)&MGC_M_DEVCTL_HM)
-
-#define MUSB_MODE(musb) ((musb)->bIsHost ? "Host" : "Peripheral")
-
-/************************** Ep Configuration ********************************/
-
-/** The End point descriptor */
-struct MUSB_EpFifoDescriptor {
-	u8 bType;		/* 0 for autoconfig, CNTR, ISOC, BULK, INTR */
-	u8 bDir;		/* 0 for autoconfig, INOUT, IN, OUT */
-	int wSize;		/* 0 for autoconfig, or the size */
-};
-
-#define MUSB_EPD_AUTOCONFIG	0
-
-#define MUSB_EPD_T_CNTRL	1
-#define MUSB_EPD_T_ISOC		2
-#define MUSB_EPD_T_BULK		3
-#define MUSB_EPD_T_INTR		4
-
-#define MUSB_EPD_D_INOUT	0
-#define MUSB_EPD_D_TX		1
-#define MUSB_EPD_D_RX		2
-
-/******************************** TYPES *************************************/
-
-/*
- * struct musb_hw_ep - endpoint hardware (bidirectional)
- *
- * Ordered slightly for better cacheline locality.
- */
-struct musb_hw_ep {
-	struct musb		*musb;
-	void __iomem		*fifo;
-	void __iomem		*regs;
-
-#ifdef CONFIG_USB_TUSB6010
-	void __iomem		*conf;
-#endif
-
-	/* index in musb->aLocalEnd[]  */
-	u8			bLocalEnd;
-
-	/* hardware configuration, possibly dynamic */
-	u8			bIsSharedFifo;
-	u8			tx_double_buffered;
-	u8			rx_double_buffered;
-	u16			wMaxPacketSizeTx;
-	u16			wMaxPacketSizeRx;
-
-	struct dma_channel	*tx_channel;
-	struct dma_channel	*rx_channel;
-
-#ifdef CONFIG_USB_TUSB6010
-	/* TUSB has "asynchronous" and "synchronous" dma modes */
-	dma_addr_t		fifo_async;
-	dma_addr_t		fifo_sync;
-	void __iomem		*fifo_sync_va;
-#endif
-
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-	void __iomem		*target_regs;
-
-	/* currently scheduled peripheral endpoint */
-	struct musb_qh		*in_qh;
-	struct musb_qh		*out_qh;
-
-	u8			rx_reinit;
-	u8			tx_reinit;
-#endif
-
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
-	/* peripheral side */
-	struct musb_ep		ep_in;			/* TX */
-	struct musb_ep		ep_out;			/* RX */
-#endif
-};
-
-static inline struct usb_request *next_in_request(struct musb_hw_ep *hw_ep)
-{
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
-	return next_request(&hw_ep->ep_in);
-#else
-	return NULL;
-#endif
-}
-
-static inline struct usb_request *next_out_request(struct musb_hw_ep *hw_ep)
-{
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
-	return next_request(&hw_ep->ep_out);
-#else
-	return NULL;
-#endif
-}
-
-/*
- * struct musb - Driver instance data.
- */
-struct musb {
-	spinlock_t		Lock;
-	struct clk		*clock;
-	irqreturn_t		(*isr)(int, void *);
-	struct work_struct	irq_work;
-
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-
-/* this hub status bit is reserved by USB 2.0 and not seen by usbcore */
-#define MUSB_PORT_STAT_RESUME	(1 << 31)
-
-	u32			port1_status;
-	unsigned long		rh_timer;
-
-	enum musb_h_ep0_state	bEnd0Stage;
-
-	/* bulk traffic normally dedicates endpoint hardware, and each
-	 * direction has its own ring of host side endpoints.
-	 * we try to progress the transfer at the head of each endpoint's
-	 * queue until it completes or NAKs too much; then we try the next
-	 * endpoint.
-	 */
-	struct musb_hw_ep	*bulk_ep;
-
-	struct list_head	control;	/* of musb_qh */
-	struct list_head	in_bulk;	/* of musb_qh */
-	struct list_head	out_bulk;	/* of musb_qh */
-	struct musb_qh		*periodic[32];	/* tree of interrupt+iso */
-#endif
-
-	/* called with IRQs blocked; ON/nonzero implies starting a session,
-	 * and waiting at least a_wait_vrise_tmout.
-	 */
-	void			(*board_set_vbus)(struct musb *, int is_on);
-
-	struct dma_controller	*pDmaController;
-
-	struct device		*controller;
-	void __iomem		*ctrl_base;
-	void __iomem		*pRegs;
-
-#ifdef CONFIG_USB_TUSB6010
-	dma_addr_t		async;
-	dma_addr_t		sync;
-	void __iomem		*sync_va;
-#endif
-
-	/* passed down from chip/board specific irq handlers */
-	u8			int_usb;
-	u16			int_rx;
-	u16			int_tx;
-
-	struct otg_transceiver	xceiv;
-
-	int nIrq;
-
-	struct musb_hw_ep	 aLocalEnd[MUSB_C_NUM_EPS];
-#define control_ep		aLocalEnd
-
-#define VBUSERR_RETRY_COUNT	3
-	u16			vbuserr_retry;
-	u16 wEndMask;
-	u8 bEndCount;
-
-	u8 board_mode;		/* enum musb_mode */
-	int			(*board_set_power)(int state);
-
-	int			(*set_clock)(struct clk *clk, int is_active);
-
-	u8			min_power;	/* vbus for periph, in mA/2 */
-
-	/* active means connected and not suspended */
-	unsigned		is_active:1;
-
-	unsigned bIsMultipoint:1;
-	unsigned bIsHost:1;
-	unsigned bIgnoreDisconnect:1;	/* during bus resets */
-
-#ifdef C_MP_TX
-	unsigned bBulkSplit:1;
-#define	can_bulk_split(musb,type) \
-		(((type) == USB_ENDPOINT_XFER_BULK) && (musb)->bBulkSplit)
-#else
-#define	can_bulk_split(musb,type)	0
-#endif
-
-#ifdef C_MP_RX
-	unsigned bBulkCombine:1;
-	/* REVISIT allegedly doesn't work reliably */
-#if 0
-#define	can_bulk_combine(musb,type) \
-		(((type) == USB_ENDPOINT_XFER_BULK) && (musb)->bBulkCombine)
-#else
-#define	can_bulk_combine(musb,type)	0
-#endif
-#else
-#define	can_bulk_combine(musb,type)	0
-#endif
-
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
-	/* is_suspended means USB B_PERIPHERAL suspend */
-	unsigned		is_suspended:1;
-
-	/* may_wakeup means remote wakeup is enabled */
-	unsigned		may_wakeup:1;
-
-	/* is_self_powered is reported in device status and the
-	 * config descriptor.  is_bus_powered means B_PERIPHERAL
-	 * draws some VBUS current; both can be true.
-	 */
-	unsigned		is_self_powered:1;
-	unsigned		is_bus_powered:1;
-
-	unsigned bSetAddress:1;
-	unsigned bTestMode:1;
-	unsigned softconnect:1;
-
-	enum musb_g_ep0_state	ep0_state;
-	u8			bAddress;
-	u8			bTestModeValue;
-	u16			ackpend;		/* ep0 */
-	struct usb_gadget	g;			/* the gadget */
-	struct usb_gadget_driver *pGadgetDriver;	/* its driver */
-#endif
-
-#ifdef CONFIG_USB_MUSB_OTG
-	/* FIXME this can't be OTG-specific ... ? */
-	u8 bDelayPortPowerOff;
-#endif
-
-#ifdef MUSB_CONFIG_PROC_FS
-	struct proc_dir_entry *pProcEntry;
-#endif
-};
-
-static inline void musb_set_vbus(struct musb *musb, int is_on)
-{
-	musb->board_set_vbus(musb, is_on);
-}
-
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
-static inline struct musb *gadget_to_musb(struct usb_gadget *g)
-{
-	return container_of(g, struct musb, g);
-}
-#endif
-
-
-/***************************** Glue it together *****************************/
-
-extern const char musb_driver_name[];
-
-extern void musb_start(struct musb *pThis);
-extern void musb_stop(struct musb *pThis);
-
-extern void musb_write_fifo(struct musb_hw_ep *ep,
-			     u16 wCount, const u8 * pSource);
-extern void musb_read_fifo(struct musb_hw_ep *ep,
-			       u16 wCount, u8 * pDest);
-
-extern void musb_load_testpacket(struct musb *);
-
-extern irqreturn_t musb_interrupt(struct musb *);
-
-extern void musb_platform_enable(struct musb *musb);
-extern void musb_platform_disable(struct musb *musb);
-
-#ifdef CONFIG_USB_TUSB6010
-extern void musb_platform_try_idle(struct musb *musb);
-extern int musb_platform_get_vbus_status(struct musb *musb);
-extern void musb_platform_set_mode(struct musb *musb, u8 musb_mode);
-#else
-#define musb_platform_try_idle(x)		do {} while (0)
-#define musb_platform_get_vbus_status(x)	0
-#define musb_platform_set_mode(x, y)		do {} while (0)
-#endif
-
-extern int __init musb_platform_init(struct musb *musb);
-extern int musb_platform_exit(struct musb *musb);
-
-/*-------------------------- ProcFS definitions ---------------------*/
-
-struct proc_dir_entry;
-
-#if (MUSB_DEBUG > 0) && defined(MUSB_CONFIG_PROC_FS)
-extern struct proc_dir_entry *musb_debug_create(char *name,
-						    struct musb *data);
-extern void musb_debug_delete(char *name, struct musb *data);
-
-#else
-static inline struct proc_dir_entry *musb_debug_create(char *name,
-							   struct musb *data)
-{
-	return NULL;
-}
-static inline void musb_debug_delete(char *name, struct musb *data)
-{
-}
-#endif
-
-#endif	/* __MUSB_MUSBDEFS_H__ */
diff -ruN linux-omap-2.6/drivers/usb/musb/musb_dma.h maemo_src/drivers/usb/musb/musb_dma.h
--- linux-omap-2.6/drivers/usb/musb/musb_dma.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/usb/musb/musb_dma.h	2007-10-02 03:09:32.000000000 -0400
@@ -0,0 +1,174 @@
+/*
+ * MUSB OTG driver DMA controller abstraction
+ *
+ * Copyright 2005 Mentor Graphics Corporation
+ * Copyright (C) 2005-2006 by Texas Instruments
+ * Copyright (C) 2006-2007 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __MUSB_DMA_H__
+#define __MUSB_DMA_H__
+
+struct musb_hw_ep;
+
+/*
+ * DMA Controller Abstraction
+ *
+ * DMA Controllers are abstracted to allow use of a variety of different
+ * implementations of DMA, as allowed by the Inventra USB cores.  On the
+ * host side, usbcore sets up the DMA mappings and flushes caches; on the
+ * peripheral side, the gadget controller driver does.  Responsibilities
+ * of a DMA controller driver include:
+ *
+ *  - Handling the details of moving multiple USB packets
+ *    in cooperation with the Inventra USB core, including especially
+ *    the correct RX side treatment of short packets and buffer-full
+ *    states (both of which terminate transfers).
+ *
+ *  - Knowing the correlation between dma channels and the
+ *    Inventra core's local endpoint resources and data direction.
+ *
+ *  - Maintaining a list of allocated/available channels.
+ *
+ *  - Updating channel status on interrupts,
+ *    whether shared with the Inventra core or separate.
+ */
+
+#define	DMA_ADDR_INVALID	(~(dma_addr_t)0)
+
+#ifndef CONFIG_MUSB_PIO_ONLY
+#define	is_dma_capable()	(1)
+#else
+#define	is_dma_capable()	(0)
+#endif
+
+#ifdef CONFIG_USB_TI_CPPI_DMA
+#define	is_cppi_enabled()	1
+#else
+#define	is_cppi_enabled()	0
+#endif
+
+#ifdef CONFIG_USB_TUSB_OMAP_DMA
+#define tusb_dma_omap()			1
+#else
+#define tusb_dma_omap()			0
+#endif
+
+/*
+ * DMA channel status ... updated by the dma controller driver whenever that
+ * status changes, and protected by the overall controller spinlock.
+ */
+enum dma_channel_status {
+	/* unallocated */
+	MUSB_DMA_STATUS_UNKNOWN,
+	/* allocated ... but not busy, no errors */
+	MUSB_DMA_STATUS_FREE,
+	/* busy ... transactions are active */
+	MUSB_DMA_STATUS_BUSY,
+	/* transaction(s) aborted due to ... dma or memory bus error */
+	MUSB_DMA_STATUS_BUS_ABORT,
+	/* transaction(s) aborted due to ... core error or USB fault */
+	MUSB_DMA_STATUS_CORE_ABORT
+};
+
+struct dma_controller;
+
+/**
+ * struct dma_channel - A DMA channel.
+ * @private_data: channel-private data
+ * @max_len: the maximum number of bytes the channel can move in one
+ *	transaction (typically representing many USB maximum-sized packets)
+ * @actual_len: how many bytes have been transferred
+ * @status: current channel status (updated e.g. on interrupt)
+ * @desired_mode: true if mode 1 is desired; false if mode 0 is desired
+ *
+ * channels are associated with an endpoint for the duration of at least
+ * one usb transfer.
+ */
+struct dma_channel {
+	void			*private_data;
+	/* FIXME not void* private_data, but a dma_controller * */
+	size_t			max_len;
+	size_t			actual_len;
+	enum dma_channel_status	status;
+	bool			desired_mode;
+};
+
+/*
+ * dma_channel_status - return status of dma channel
+ * @c: the channel
+ *
+ * Returns the software's view of the channel status.  If that status is BUSY
+ * then it's possible that the hardware has completed (or aborted) a transfer,
+ * so the driver needs to update that status.
+ */
+static inline enum dma_channel_status
+dma_channel_status(struct dma_channel *c)
+{
+	return (is_dma_capable() && c) ? c->status : MUSB_DMA_STATUS_UNKNOWN;
+}
+
+/**
+ * struct dma_controller - A DMA Controller.
+ * @private_data: controller-private data;
+ * @start: call this to start a DMA controller;
+ *	return 0 on success, else negative errno
+ * @stop: call this to stop a DMA controller
+ *	return 0 on success, else negative errno
+ * @channel_alloc: call this to allocate a DMA channel
+ * @channel_release: call this to release a DMA channel
+ * @channel_abort: call this to abort a pending DMA transaction,
+ *	returning it to FREE (but allocated) state
+ *
+ * Controllers manage dma channels.
+ */
+struct dma_controller {
+	void			*private_data;
+	int			(*start)(struct dma_controller *);
+	int			(*stop)(struct dma_controller *);
+	struct dma_channel	*(*channel_alloc)(struct dma_controller *,
+					struct musb_hw_ep *, u8 is_tx);
+	void			(*channel_release)(struct dma_channel *);
+	int			(*channel_program)(struct dma_channel *channel,
+							u16 maxpacket, u8 mode,
+							dma_addr_t dma_addr,
+							u32 length);
+	int			(*channel_abort)(struct dma_channel *);
+};
+
+/* called after channel_program(), may indicate a fault */
+extern void musb_dma_completion(struct musb *musb, u8 epnum, u8 transmit);
+
+
+extern struct dma_controller *__init
+dma_controller_create(struct musb *, void __iomem *);
+
+extern void dma_controller_destroy(struct dma_controller *);
+
+#endif	/* __MUSB_DMA_H__ */
diff -ruN linux-omap-2.6/drivers/usb/musb/musb_gadget.c maemo_src/drivers/usb/musb/musb_gadget.c
--- linux-omap-2.6/drivers/usb/musb/musb_gadget.c	2011-02-06 20:17:25.876666606 -0500
+++ maemo_src/drivers/usb/musb/musb_gadget.c	2011-02-06 20:12:11.263333273 -0500
@@ -1,35 +1,36 @@
-/******************************************************************
+/*
+ * MUSB OTG driver peripheral support
+ *
  * Copyright 2005 Mentor Graphics Corporation
  * Copyright (C) 2005-2006 by Texas Instruments
+ * Copyright (C) 2006-2007 Nokia Corporation
  *
- * This file is part of the Inventra Controller Driver for Linux.
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
  *
- * The Inventra Controller Driver for Linux is free software; you
- * can redistribute it and/or modify it under the terms of the GNU
- * General Public License version 2 as published by the Free Software
- * Foundation.
- *
- * The Inventra Controller Driver for Linux is distributed in
- * the hope that it will be useful, but WITHOUT ANY WARRANTY;
- * without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
- * License for more details.
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with The Inventra Controller Driver for Linux ; if not,
- * write to the Free Software Foundation, Inc., 59 Temple Place,
- * Suite 330, Boston, MA  02111-1307  USA
- *
- * ANY DOWNLOAD, USE, REPRODUCTION, MODIFICATION OR DISTRIBUTION
- * OF THIS DRIVER INDICATES YOUR COMPLETE AND UNCONDITIONAL ACCEPTANCE
- * OF THOSE TERMS.THIS DRIVER IS PROVIDED "AS IS" AND MENTOR GRAPHICS
- * MAKES NO WARRANTIES, EXPRESS OR IMPLIED, RELATED TO THIS DRIVER.
- * MENTOR GRAPHICS SPECIFICALLY DISCLAIMS ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY; FITNESS FOR A PARTICULAR PURPOSE AND
- * NON-INFRINGEMENT.  MENTOR GRAPHICS DOES NOT PROVIDE SUPPORT
- * SERVICES OR UPDATES FOR THIS DRIVER, EVEN IF YOU ARE A MENTOR
- * GRAPHICS SUPPORT CUSTOMER.
- ******************************************************************/
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <linux/kernel.h>
 #include <linux/list.h>
@@ -41,11 +42,13 @@
 #include <linux/moduleparam.h>
 #include <linux/stat.h>
 #include <linux/dma-mapping.h>
+#include <linux/version.h>
+#include <asm/mach-types.h>
 
-#include "musbdefs.h"
+#include "musb_core.h"
 
 
-/* MUSB PERIPHERAL status 3-mar:
+/* MUSB PERIPHERAL status 3-mar-2006:
  *
  * - EP0 seems solid.  It passes both USBCV and usbtest control cases.
  *   Minor glitches:
@@ -87,43 +90,41 @@
  *     + TUSB 6010, platform-specific dma in the works
  */
 
-/**************************************************************************
-Handling completion
-**************************************************************************/
+/* ----------------------------------------------------------------------- */
 
 /*
  * Immediately complete a request.
  *
- * @param pRequest the request to complete
+ * @param request the request to complete
  * @param status the status to complete the request with
  * Context: controller locked, IRQs blocked.
  */
 void musb_g_giveback(
 	struct musb_ep		*ep,
-	struct usb_request	*pRequest,
-	int status)
-__releases(ep->musb->Lock)
-__acquires(ep->musb->Lock)
+	struct usb_request	*request,
+	int			status)
+__releases(ep->musb->lock)
+__acquires(ep->musb->lock)
 {
 	struct musb_request	*req;
 	struct musb		*musb;
 	int			busy = ep->busy;
 
-	req = to_musb_request(pRequest);
+	req = to_musb_request(request);
 
-	list_del(&pRequest->list);
+	list_del(&request->list);
 	if (req->request.status == -EINPROGRESS)
 		req->request.status = status;
 	musb = req->musb;
 
 	ep->busy = 1;
-	spin_unlock(&musb->Lock);
+	spin_unlock(&musb->lock);
 	if (is_dma_capable()) {
 		if (req->mapped) {
 			dma_unmap_single(musb->controller,
 					req->request.dma,
 					req->request.length,
-					req->bTx
+					req->tx
 						? DMA_TO_DEVICE
 						: DMA_FROM_DEVICE);
 			req->request.dma = DMA_ADDR_INVALID;
@@ -132,21 +133,21 @@
 			dma_sync_single_for_cpu(musb->controller,
 					req->request.dma,
 					req->request.length,
-					req->bTx
+					req->tx
 						? DMA_TO_DEVICE
 						: DMA_FROM_DEVICE);
 	}
-	if (pRequest->status == 0)
+	if (request->status == 0)
 		DBG(5, "%s done request %p,  %d/%d\n",
-				ep->end_point.name, pRequest,
+				ep->end_point.name, request,
 				req->request.actual, req->request.length);
 	else
 		DBG(2, "%s request %p, %d/%d fault %d\n",
-				ep->end_point.name, pRequest,
+				ep->end_point.name, request,
 				req->request.actual, req->request.length,
-				pRequest->status);
+				request->status);
 	req->request.complete(&req->ep->end_point, &req->request);
-	spin_lock(&musb->Lock);
+	spin_lock(&musb->lock);
 	ep->busy = busy;
 }
 
@@ -159,12 +160,24 @@
 static void nuke(struct musb_ep *ep, const int status)
 {
 	struct musb_request	*req = NULL;
+	void __iomem *epio = ep->musb->endpoints[ep->current_epnum].regs;
 
 	ep->busy = 1;
 
 	if (is_dma_capable() && ep->dma) {
-		struct dma_controller	*c = ep->pThis->pDmaController;
+		struct dma_controller	*c = ep->musb->dma_controller;
 		int value;
+		if (ep->is_in) {
+			musb_writew(epio, MUSB_TXCSR,
+					0 | MUSB_TXCSR_FLUSHFIFO);
+			musb_writew(epio, MUSB_TXCSR,
+					0 | MUSB_TXCSR_FLUSHFIFO);
+		} else {
+			musb_writew(epio, MUSB_RXCSR,
+					0 | MUSB_RXCSR_FLUSHFIFO);
+			musb_writew(epio, MUSB_RXCSR,
+					0 | MUSB_RXCSR_FLUSHFIFO);
+		}
 
 		value = c->channel_abort(ep->dma);
 		DBG(value ? 1 : 6, "%s: abort DMA --> %d\n", ep->name, value);
@@ -179,9 +192,9 @@
 	}
 }
 
-/**************************************************************************
- * TX/IN and RX/OUT Data transfers
- **************************************************************************/
+/* ----------------------------------------------------------------------- */
+
+/* Data transfers - pure PIO, pure DMA, or mixed mode */
 
 /*
  * This assumes the separate CPPI engine is responding to DMA requests
@@ -191,9 +204,9 @@
 static inline int max_ep_writesize(struct musb *musb, struct musb_ep *ep)
 {
 	if (can_bulk_split(musb, ep->type))
-		return ep->hw_ep->wMaxPacketSizeTx;
+		return ep->hw_ep->max_packet_sz_tx;
 	else
-		return ep->wPacketSize;
+		return ep->packet_sz;
 }
 
 
@@ -240,101 +253,100 @@
  */
 static void txstate(struct musb *musb, struct musb_request *req)
 {
-	u8			bEnd = req->bEnd;
-	struct musb_ep		*pEnd;
-	void __iomem		*epio = musb->aLocalEnd[bEnd].regs;
-	struct usb_request	*pRequest;
-	u16			wFifoCount = 0, wCsrVal;
+	u8			epnum = req->epnum;
+	struct musb_ep		*musb_ep;
+	void __iomem		*epio = musb->endpoints[epnum].regs;
+	struct usb_request	*request;
+	u16			fifo_count = 0, csr;
 	int			use_dma = 0;
 
-	pEnd = req->ep;
+	musb_ep = req->ep;
 
 	/* we shouldn't get here while DMA is active ... but we do ... */
-	if (dma_channel_status(pEnd->dma) == MGC_DMA_STATUS_BUSY) {
+	if (dma_channel_status(musb_ep->dma) == MUSB_DMA_STATUS_BUSY) {
 		DBG(4, "dma pending...\n");
 		return;
 	}
 
 	/* read TXCSR before */
-	wCsrVal = musb_readw(epio, MGC_O_HDRC_TXCSR);
+	csr = musb_readw(epio, MUSB_TXCSR);
 
-	pRequest = &req->request;
-	wFifoCount = min(max_ep_writesize(musb, pEnd),
-			(int)(pRequest->length - pRequest->actual));
+	request = &req->request;
+	fifo_count = min(max_ep_writesize(musb, musb_ep),
+			(int)(request->length - request->actual));
 
-	if (wCsrVal & MGC_M_TXCSR_TXPKTRDY) {
+	if (csr & MUSB_TXCSR_TXPKTRDY) {
 		DBG(5, "%s old packet still ready , txcsr %03x\n",
-				pEnd->end_point.name, wCsrVal);
+				musb_ep->end_point.name, csr);
 		return;
 	}
 
-	if (wCsrVal & MGC_M_TXCSR_P_SENDSTALL) {
+	if (csr & MUSB_TXCSR_P_SENDSTALL) {
 		DBG(5, "%s stalling, txcsr %03x\n",
-				pEnd->end_point.name, wCsrVal);
+				musb_ep->end_point.name, csr);
 		return;
 	}
 
 	DBG(4, "hw_ep%d, maxpacket %d, fifo count %d, txcsr %03x\n",
-			bEnd, pEnd->wPacketSize, wFifoCount,
-			wCsrVal);
+			epnum, musb_ep->packet_sz, fifo_count,
+			csr);
 
-#ifndef	CONFIG_USB_INVENTRA_FIFO
-	if (is_dma_capable() && pEnd->dma) {
-		struct dma_controller	*c = musb->pDmaController;
+#ifndef	CONFIG_MUSB_PIO_ONLY
+	if (is_dma_capable() && musb_ep->dma) {
+		struct dma_controller	*c = musb->dma_controller;
 
-		use_dma = (pRequest->dma != DMA_ADDR_INVALID);
+		use_dma = (request->dma != DMA_ADDR_INVALID);
 
-		/* MGC_M_TXCSR_P_ISO is still set correctly */
+		/* MUSB_TXCSR_P_ISO is still set correctly */
 
 #ifdef CONFIG_USB_INVENTRA_DMA
 		{
 			size_t request_size;
 
 			/* setup DMA, then program endpoint CSR */
-			request_size = min(pRequest->length,
-						pEnd->dma->dwMaxLength);
-			if (request_size <= pEnd->wPacketSize)
-				pEnd->dma->bDesiredMode = 0;
+			request_size = min(request->length,
+						musb_ep->dma->max_len);
+			if (request_size <= musb_ep->packet_sz)
+				musb_ep->dma->desired_mode = 0;
 			else
-				pEnd->dma->bDesiredMode = 1;
+				musb_ep->dma->desired_mode = 1;
 
 			use_dma = use_dma && c->channel_program(
-					pEnd->dma, pEnd->wPacketSize,
-					pEnd->dma->bDesiredMode,
-					pRequest->dma, request_size);
+					musb_ep->dma, musb_ep->packet_sz,
+					musb_ep->dma->desired_mode,
+					request->dma, request_size);
 			if (use_dma) {
-				if (pEnd->dma->bDesiredMode == 0) {
+				if (musb_ep->dma->desired_mode == 0) {
 					/* ASSERT: DMAENAB is clear */
-					wCsrVal &= ~(MGC_M_TXCSR_AUTOSET |
-							MGC_M_TXCSR_DMAMODE);
-					wCsrVal |= (MGC_M_TXCSR_DMAENAB |
-							MGC_M_TXCSR_MODE);
-					// against programming guide
-				}
-				else
-					wCsrVal |= (MGC_M_TXCSR_AUTOSET
-							| MGC_M_TXCSR_DMAENAB
-							| MGC_M_TXCSR_DMAMODE
-							| MGC_M_TXCSR_MODE);
+					csr &= ~(MUSB_TXCSR_AUTOSET |
+							MUSB_TXCSR_DMAMODE);
+					csr |= (MUSB_TXCSR_DMAENAB |
+							MUSB_TXCSR_MODE);
+					/* against programming guide */
+				} else
+					csr |= (MUSB_TXCSR_AUTOSET
+							| MUSB_TXCSR_DMAENAB
+							| MUSB_TXCSR_DMAMODE
+							| MUSB_TXCSR_MODE);
 
-				wCsrVal &= ~MGC_M_TXCSR_P_UNDERRUN;
-				musb_writew(epio, MGC_O_HDRC_TXCSR, wCsrVal);
+				csr &= ~MUSB_TXCSR_P_UNDERRUN;
+				musb_writew(epio, MUSB_TXCSR, csr);
 			}
 		}
 
 #elif defined(CONFIG_USB_TI_CPPI_DMA)
 		/* program endpoint CSR first, then setup DMA */
-		wCsrVal &= ~(MGC_M_TXCSR_AUTOSET
-				| MGC_M_TXCSR_DMAMODE
-				| MGC_M_TXCSR_P_UNDERRUN
-				| MGC_M_TXCSR_TXPKTRDY);
-		wCsrVal |= MGC_M_TXCSR_MODE | MGC_M_TXCSR_DMAENAB;
-		musb_writew(epio, MGC_O_HDRC_TXCSR,
-			(MGC_M_TXCSR_P_WZC_BITS & ~MGC_M_TXCSR_P_UNDERRUN)
-				| wCsrVal);
+		csr &= ~(MUSB_TXCSR_AUTOSET
+				| MUSB_TXCSR_DMAMODE
+				| MUSB_TXCSR_P_UNDERRUN
+				| MUSB_TXCSR_TXPKTRDY);
+		csr |= MUSB_TXCSR_MODE | MUSB_TXCSR_DMAENAB;
+		musb_writew(epio, MUSB_TXCSR,
+			(MUSB_TXCSR_P_WZC_BITS & ~MUSB_TXCSR_P_UNDERRUN)
+				| csr);
 
 		/* ensure writebuffer is empty */
-		wCsrVal = musb_readw(epio, MGC_O_HDRC_TXCSR);
+		csr = musb_readw(epio, MUSB_TXCSR);
 
 		/* NOTE host side sets DMAENAB later than this; both are
 		 * OK since the transfer dma glue (between CPPI and Mentor
@@ -347,152 +359,154 @@
 		 * except for the last-packet-is-already-short case.
 		 */
 		use_dma = use_dma && c->channel_program(
-				pEnd->dma, pEnd->wPacketSize,
+				musb_ep->dma, musb_ep->packet_sz,
 				0,
-				pRequest->dma,
-				pRequest->length);
+				request->dma,
+				request->length);
 		if (!use_dma) {
-			c->channel_release(pEnd->dma);
-			pEnd->dma = NULL;
+			c->channel_release(musb_ep->dma);
+			musb_ep->dma = NULL;
 			/* ASSERT: DMAENAB clear */
-			wCsrVal &= ~(MGC_M_TXCSR_DMAMODE | MGC_M_TXCSR_MODE);
+			csr &= ~(MUSB_TXCSR_DMAMODE | MUSB_TXCSR_MODE);
 			/* invariant: prequest->buf is non-null */
 		}
 #elif defined(CONFIG_USB_TUSB_OMAP_DMA)
 		use_dma = use_dma && c->channel_program(
-				pEnd->dma, pEnd->wPacketSize,
-				pRequest->zero,
-				pRequest->dma,
-				pRequest->length);
+				musb_ep->dma, musb_ep->packet_sz,
+				request->zero,
+				request->dma,
+				request->length);
 #endif
 	}
 #endif
 
 	if (!use_dma) {
-		musb_write_fifo(pEnd->hw_ep, wFifoCount,
-				(u8 *) (pRequest->buf + pRequest->actual));
-		pRequest->actual += wFifoCount;
-		wCsrVal |= MGC_M_TXCSR_TXPKTRDY;
-		wCsrVal &= ~MGC_M_TXCSR_P_UNDERRUN;
-		musb_writew(epio, MGC_O_HDRC_TXCSR, wCsrVal);
+		musb_write_fifo(musb_ep->hw_ep, fifo_count,
+				(u8 *) (request->buf + request->actual));
+		request->actual += fifo_count;
+		csr |= MUSB_TXCSR_TXPKTRDY;
+		csr &= ~MUSB_TXCSR_P_UNDERRUN;
+		musb_writew(epio, MUSB_TXCSR, csr);
 	}
 
 	/* host may already have the data when this message shows... */
 	DBG(3, "%s TX/IN %s len %d/%d, txcsr %04x, fifo %d/%d\n",
-			pEnd->end_point.name, use_dma ? "dma" : "pio",
-			pRequest->actual, pRequest->length,
-			musb_readw(epio, MGC_O_HDRC_TXCSR),
-			wFifoCount,
-			musb_readw(epio, MGC_O_HDRC_TXMAXP));
+			musb_ep->end_point.name, use_dma ? "dma" : "pio",
+			request->actual, request->length,
+			musb_readw(epio, MUSB_TXCSR),
+			fifo_count,
+			musb_readw(epio, MUSB_TXMAXP));
 }
 
 /*
  * FIFO state update (e.g. data ready).
  * Called from IRQ,  with controller locked.
  */
-void musb_g_tx(struct musb *musb, u8 bEnd)
+void musb_g_tx(struct musb *musb, u8 epnum)
 {
-	u16			wCsrVal;
-	struct usb_request	*pRequest;
-	u8 __iomem		*pBase = musb->pRegs;
-	struct musb_ep		*pEnd = &musb->aLocalEnd[bEnd].ep_in;
-	void __iomem		*epio = musb->aLocalEnd[bEnd].regs;
+	u16			csr;
+	struct usb_request	*request;
+	u8 __iomem		*mbase = musb->mregs;
+	struct musb_ep		*musb_ep = &musb->endpoints[epnum].ep_in;
+	void __iomem		*epio = musb->endpoints[epnum].regs;
 	struct dma_channel	*dma;
 
-	MGC_SelectEnd(pBase, bEnd);
-	pRequest = next_request(pEnd);
+	musb_ep_select(mbase, epnum);
+	request = next_request(musb_ep);
 
-	wCsrVal = musb_readw(epio, MGC_O_HDRC_TXCSR);
-	DBG(4, "<== %s, txcsr %04x\n", pEnd->end_point.name, wCsrVal);
+	csr = musb_readw(epio, MUSB_TXCSR);
+	DBG(4, "<== %s, txcsr %04x\n", musb_ep->end_point.name, csr);
 
-	dma = is_dma_capable() ? pEnd->dma : NULL;
+	dma = is_dma_capable() ? musb_ep->dma : NULL;
 	do {
-		/* REVISIT for high bandwidth, MGC_M_TXCSR_P_INCOMPTX
+		/* REVISIT for high bandwidth, MUSB_TXCSR_P_INCOMPTX
 		 * probably rates reporting as a host error
 		 */
-		if (wCsrVal & MGC_M_TXCSR_P_SENTSTALL) {
-			wCsrVal |= MGC_M_TXCSR_P_WZC_BITS;
-			wCsrVal &= ~MGC_M_TXCSR_P_SENTSTALL;
-			musb_writew(epio, MGC_O_HDRC_TXCSR, wCsrVal);
-			if (dma_channel_status(dma) == MGC_DMA_STATUS_BUSY) {
-				dma->bStatus = MGC_DMA_STATUS_CORE_ABORT;
-				musb->pDmaController->channel_abort(dma);
+		if (csr & MUSB_TXCSR_P_SENTSTALL) {
+			csr |= MUSB_TXCSR_P_WZC_BITS;
+			csr &= ~MUSB_TXCSR_P_SENTSTALL;
+			musb_writew(epio, MUSB_TXCSR, csr);
+			if (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {
+				dma->status = MUSB_DMA_STATUS_CORE_ABORT;
+				musb->dma_controller->channel_abort(dma);
 			}
 
-			if (pRequest)
-				musb_g_giveback(pEnd, pRequest, -EPIPE);
+			if (request)
+				musb_g_giveback(musb_ep, request, -EPIPE);
 
 			break;
 		}
 
-		if (wCsrVal & MGC_M_TXCSR_P_UNDERRUN) {
+		if (csr & MUSB_TXCSR_P_UNDERRUN) {
 			/* we NAKed, no big deal ... little reason to care */
-			wCsrVal |= MGC_M_TXCSR_P_WZC_BITS;
-			wCsrVal &= ~(MGC_M_TXCSR_P_UNDERRUN
-					| MGC_M_TXCSR_TXPKTRDY);
-			musb_writew(epio, MGC_O_HDRC_TXCSR, wCsrVal);
-			DBG(20, "underrun on ep%d, req %p\n", bEnd, pRequest);
+			csr |= MUSB_TXCSR_P_WZC_BITS;
+			csr &= ~(MUSB_TXCSR_P_UNDERRUN
+					| MUSB_TXCSR_TXPKTRDY);
+			musb_writew(epio, MUSB_TXCSR, csr);
+			DBG(20, "underrun on ep%d, req %p\n", epnum, request);
 		}
 
-		if (dma_channel_status(dma) == MGC_DMA_STATUS_BUSY) {
+		if (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {
 			/* SHOULD NOT HAPPEN ... has with cppi though, after
 			 * changing SENDSTALL (and other cases); harmless?
 			 */
-			DBG(5, "%s dma still busy?\n", pEnd->end_point.name);
+			DBG(5, "%s dma still busy?\n", musb_ep->end_point.name);
 			break;
 		}
 
-		if (pRequest) {
+		if (request) {
 			u8	is_dma = 0;
 
-			if (dma && (wCsrVal & MGC_M_TXCSR_DMAENAB)) {
+			if (dma && (csr & MUSB_TXCSR_DMAENAB)) {
 				is_dma = 1;
-				wCsrVal |= MGC_M_TXCSR_P_WZC_BITS;
-				wCsrVal &= ~(MGC_M_TXCSR_DMAENAB
-						| MGC_M_TXCSR_P_UNDERRUN
-						| MGC_M_TXCSR_TXPKTRDY);
-				musb_writew(epio, MGC_O_HDRC_TXCSR, wCsrVal);
+				csr |= MUSB_TXCSR_P_WZC_BITS;
+				csr &= ~(MUSB_TXCSR_DMAENAB
+						| MUSB_TXCSR_P_UNDERRUN
+						| MUSB_TXCSR_TXPKTRDY);
+				musb_writew(epio, MUSB_TXCSR, csr);
 				/* ensure writebuffer is empty */
-				wCsrVal = musb_readw(epio, MGC_O_HDRC_TXCSR);
+				csr = musb_readw(epio, MUSB_TXCSR);
+				request->actual += musb_ep->dma->actual_len;
 				DBG(4, "TXCSR%d %04x, dma off, "
 						"len %Zd, req %p\n",
-					bEnd, wCsrVal,
-					pEnd->dma->dwActualLength,
-					pRequest);
-				pRequest->actual += pEnd->dma->dwActualLength;
+					epnum, csr,
+					musb_ep->dma->actual_len,
+					request);
 			}
 
-			if (is_dma || pRequest->actual == pRequest->length) {
+			if (is_dma || request->actual == request->length) {
 
 				/* First, maybe a terminating short packet.
 				 * Some DMA engines might handle this by
 				 * themselves.
 				 */
-				if ((pRequest->zero
-						&& pRequest->length
-						&& (pRequest->length
-							% pEnd->wPacketSize)
+				if ((request->zero
+						&& request->length
+						&& (request->length
+							% musb_ep->packet_sz)
 							== 0)
 #ifdef CONFIG_USB_INVENTRA_DMA
 					|| (is_dma &&
-						(pRequest->actual
-							< pEnd->wPacketSize))
+						((!dma->desired_mode) ||
+						    (request->actual &
+						    (musb_ep->packet_sz - 1))))
 #endif
 				) {
 					/* on dma completion, fifo may not
 					 * be available yet ...
 					 */
-					if (wCsrVal & MGC_M_TXCSR_TXPKTRDY)
+					if (csr & MUSB_TXCSR_TXPKTRDY)
 						break;
 
 					DBG(4, "sending zero pkt\n");
-					musb_writew(epio, MGC_O_HDRC_TXCSR,
-							MGC_M_TXCSR_MODE
-							| MGC_M_TXCSR_TXPKTRDY);
+					musb_writew(epio, MUSB_TXCSR,
+							MUSB_TXCSR_MODE
+							| MUSB_TXCSR_TXPKTRDY);
+					request->zero = 0;
 				}
 
 				/* ... or if not, then complete it */
-				musb_g_giveback(pEnd, pRequest, 0);
+				musb_g_giveback(musb_ep, request, 0);
 
 				/* kickstart next transfer if appropriate;
 				 * the packet that just completed might not
@@ -500,21 +514,21 @@
 				 * REVISIT for double buffering...
 				 * FIXME revisit for stalls too...
 				 */
-				MGC_SelectEnd(pBase, bEnd);
-				wCsrVal = musb_readw(epio, MGC_O_HDRC_TXCSR);
-				if (wCsrVal & MGC_M_TXCSR_FIFONOTEMPTY)
+				musb_ep_select(mbase, epnum);
+				csr = musb_readw(epio, MUSB_TXCSR);
+				if (csr & MUSB_TXCSR_FIFONOTEMPTY)
 					break;
-				pRequest = pEnd->desc
-						? next_request(pEnd)
+				request = musb_ep->desc
+						? next_request(musb_ep)
 						: NULL;
-				if (!pRequest) {
+				if (!request) {
 					DBG(4, "%s idle now\n",
-							pEnd->end_point.name);
+						musb_ep->end_point.name);
 					break;
 				}
 			}
 
-			txstate(musb, to_musb_request(pRequest));
+			txstate(musb, to_musb_request(request));
 		}
 
 	} while (0);
@@ -558,19 +572,19 @@
  */
 static void rxstate(struct musb *musb, struct musb_request *req)
 {
-	u16			wCsrVal = 0;
-	const u8		bEnd = req->bEnd;
-	struct usb_request	*pRequest = &req->request;
-	struct musb_ep		*pEnd = &musb->aLocalEnd[bEnd].ep_out;
-	void __iomem		*epio = musb->aLocalEnd[bEnd].regs;
-	u16			wFifoCount = 0;
-	u16			wCount = pEnd->wPacketSize;
-
-	wCsrVal = musb_readw(epio, MGC_O_HDRC_RXCSR);
-
-	if (is_cppi_enabled() && pEnd->dma) {
-		struct dma_controller	*c = musb->pDmaController;
-		struct dma_channel	*channel = pEnd->dma;
+	u16			csr = 0;
+	const u8		epnum = req->epnum;
+	struct usb_request	*request = &req->request;
+	struct musb_ep		*musb_ep = &musb->endpoints[epnum].ep_out;
+	void __iomem		*epio = musb->endpoints[epnum].regs;
+	u16			fifo_count = 0;
+	u16			len = musb_ep->packet_sz;
+
+	csr = musb_readw(epio, MUSB_RXCSR);
+
+	if (is_cppi_enabled() && musb_ep->dma) {
+		struct dma_controller	*c = musb->dma_controller;
+		struct dma_channel	*channel = musb_ep->dma;
 
 		/* NOTE:  CPPI won't actually stop advancing the DMA
 		 * queue after short packet transfers, so this is almost
@@ -578,36 +592,36 @@
 		 * faults will be handled correctly.
 		 */
 		if (c->channel_program(channel,
-				pEnd->wPacketSize,
-				!pRequest->short_not_ok,
-				pRequest->dma + pRequest->actual,
-				pRequest->length - pRequest->actual)) {
+				musb_ep->packet_sz,
+				!request->short_not_ok,
+				request->dma + request->actual,
+				request->length - request->actual)) {
 
 			/* make sure that if an rxpkt arrived after the irq,
 			 * the cppi engine will be ready to take it as soon
 			 * as DMA is enabled
 			 */
-			wCsrVal &= ~(MGC_M_RXCSR_AUTOCLEAR
-					| MGC_M_RXCSR_DMAMODE);
-			wCsrVal |= MGC_M_RXCSR_DMAENAB | MGC_M_RXCSR_P_WZC_BITS;
-			musb_writew(epio, MGC_O_HDRC_RXCSR, wCsrVal);
+			csr &= ~(MUSB_RXCSR_AUTOCLEAR
+					| MUSB_RXCSR_DMAMODE);
+			csr |= MUSB_RXCSR_DMAENAB | MUSB_RXCSR_P_WZC_BITS;
+			musb_writew(epio, MUSB_RXCSR, csr);
 			return;
 		}
 	}
 
-	if (wCsrVal & MGC_M_RXCSR_RXPKTRDY) {
-		wCount = musb_readw(epio, MGC_O_HDRC_RXCOUNT);
-		if (pRequest->actual < pRequest->length) {
+	if (csr & MUSB_RXCSR_RXPKTRDY) {
+		len = musb_readw(epio, MUSB_RXCOUNT);
+		if (request->actual < request->length) {
 #ifdef CONFIG_USB_INVENTRA_DMA
-			if (is_dma_capable() && pEnd->dma) {
+			if (is_dma_capable() && musb_ep->dma) {
 				struct dma_controller	*c;
 				struct dma_channel	*channel;
 				int			use_dma = 0;
 
-				c = musb->pDmaController;
-				channel = pEnd->dma;
+				c = musb->dma_controller;
+				channel = musb_ep->dma;
 
-	/* We use DMA Req mode 0 in RxCsr, and DMA controller operates in
+	/* We use DMA Req mode 0 in rx_csr, and DMA controller operates in
 	 * mode 0 only. So we do not get endpoint interrupts due to DMA
 	 * completion. We only get interrupts from DMA controller.
 	 *
@@ -620,7 +634,7 @@
 	 * that last pckate should trigger an overflow fault.)  But in mode 1,
 	 * we don't get DMA completion interrrupt for short packets.
 	 *
-	 * Theoretically, we could enable DMAReq interrupt (RxCsr_DMAMODE = 1),
+	 * Theoretically, we could enable DMAReq irq (MUSB_RXCSR_DMAMODE = 1),
 	 * to get endpoint interrupt on every DMA req, but that didn't seem
 	 * to work reliably.
 	 *
@@ -628,204 +642,203 @@
 	 * then becomes usable as a runtime "use mode 1" hint...
 	 */
 
-				wCsrVal |= MGC_M_RXCSR_DMAENAB;
+				csr |= MUSB_RXCSR_DMAENAB;
 #ifdef USE_MODE1
-				wCsrVal |= MGC_M_RXCSR_AUTOCLEAR;
-//				wCsrVal |= MGC_M_RXCSR_DMAMODE;
+				csr |= MUSB_RXCSR_AUTOCLEAR;
+				/* csr |= MUSB_RXCSR_DMAMODE; */
 
 				/* this special sequence (enabling and then
-				   disabling MGC_M_RXCSR_DMAMODE) is required
-				   to get DMAReq to activate
+				 * disabling MUSB_RXCSR_DMAMODE) is required
+				 * to get DMAReq to activate
 				 */
-				musb_writew(epio, MGC_O_HDRC_RXCSR,
-					wCsrVal | MGC_M_RXCSR_DMAMODE);
+				musb_writew(epio, MUSB_RXCSR,
+					csr | MUSB_RXCSR_DMAMODE);
 #endif
-				musb_writew(epio, MGC_O_HDRC_RXCSR,
-						wCsrVal);
+				musb_writew(epio, MUSB_RXCSR, csr);
 
-				if (pRequest->actual < pRequest->length) {
+				if (request->actual < request->length) {
 					int transfer_size = 0;
 #ifdef USE_MODE1
-					transfer_size = min(pRequest->length,
-							channel->dwMaxLength);
+					transfer_size = min(request->length,
+							channel->max_len);
 #else
-					transfer_size = wCount;
+					transfer_size = len;
 #endif
-					if (transfer_size <= pEnd->wPacketSize)
-						pEnd->dma->bDesiredMode = 0;
+					if (transfer_size <= musb_ep->packet_sz)
+						musb_ep->dma->desired_mode = 0;
 					else
-						pEnd->dma->bDesiredMode = 1;
+						musb_ep->dma->desired_mode = 1;
 
 					use_dma = c->channel_program(
 							channel,
-							pEnd->wPacketSize,
-							channel->bDesiredMode,
-							pRequest->dma
-							+ pRequest->actual,
+							musb_ep->packet_sz,
+							channel->desired_mode,
+							request->dma
+							+ request->actual,
 							transfer_size);
 				}
 
 				if (use_dma)
 					return;
 			}
-#endif	/* Mentor's USB */
+#endif	/* Mentor's DMA */
 
-			wFifoCount = pRequest->length - pRequest->actual;
+			fifo_count = request->length - request->actual;
 			DBG(3, "%s OUT/RX pio fifo %d/%d, maxpacket %d\n",
-					pEnd->end_point.name,
-					wCount, wFifoCount,
-					pEnd->wPacketSize);
+					musb_ep->end_point.name,
+					len, fifo_count,
+					musb_ep->packet_sz);
 
-			wFifoCount = min(wCount, wFifoCount);
+			fifo_count = min(len, fifo_count);
 
 #ifdef	CONFIG_USB_TUSB_OMAP_DMA
-			if (tusb_dma_omap() && pEnd->dma) {
-				struct dma_controller *c = musb->pDmaController;
-				struct dma_channel *channel = pEnd->dma;
-				u32 dma_addr = pRequest->dma + pRequest->actual;
+			if (tusb_dma_omap() && musb_ep->dma) {
+				struct dma_controller *c = musb->dma_controller;
+				struct dma_channel *channel = musb_ep->dma;
+				u32 dma_addr = request->dma + request->actual;
 				int ret;
 
 				ret = c->channel_program(channel,
-						pEnd->wPacketSize,
-						channel->bDesiredMode,
+						musb_ep->packet_sz,
+						channel->desired_mode,
 						dma_addr,
-						wFifoCount);
-				if (ret == TRUE)
+						fifo_count);
+				if (ret)
 					return;
 			}
 #endif
 
-			musb_read_fifo(pEnd->hw_ep, wFifoCount, (u8 *)
-					(pRequest->buf + pRequest->actual));
-			pRequest->actual += wFifoCount;
+			musb_read_fifo(musb_ep->hw_ep, fifo_count, (u8 *)
+					(request->buf + request->actual));
+			request->actual += fifo_count;
 
 			/* REVISIT if we left anything in the fifo, flush
 			 * it and report -EOVERFLOW
 			 */
 
 			/* ack the read! */
-			wCsrVal |= MGC_M_RXCSR_P_WZC_BITS;
-			wCsrVal &= ~MGC_M_RXCSR_RXPKTRDY;
-			musb_writew(epio, MGC_O_HDRC_RXCSR, wCsrVal);
+			csr |= MUSB_RXCSR_P_WZC_BITS;
+			csr &= ~MUSB_RXCSR_RXPKTRDY;
+			musb_writew(epio, MUSB_RXCSR, csr);
 		}
 	}
 
 	/* reach the end or short packet detected */
-	if (pRequest->actual == pRequest->length || wCount < pEnd->wPacketSize)
-		musb_g_giveback(pEnd, pRequest, 0);
+	if (request->actual == request->length || len < musb_ep->packet_sz)
+		musb_g_giveback(musb_ep, request, 0);
 }
 
 /*
  * Data ready for a request; called from IRQ
  */
-void musb_g_rx(struct musb *musb, u8 bEnd)
+void musb_g_rx(struct musb *musb, u8 epnum)
 {
-	u16			wCsrVal;
-	struct usb_request	*pRequest;
-	void __iomem		*pBase = musb->pRegs;
-	struct musb_ep		*pEnd = &musb->aLocalEnd[bEnd].ep_out;
-	void __iomem		*epio = musb->aLocalEnd[bEnd].regs;
+	u16			csr;
+	struct usb_request	*request;
+	void __iomem		*mbase = musb->mregs;
+	struct musb_ep		*musb_ep = &musb->endpoints[epnum].ep_out;
+	void __iomem		*epio = musb->endpoints[epnum].regs;
 	struct dma_channel	*dma;
 
-	MGC_SelectEnd(pBase, bEnd);
+	musb_ep_select(mbase, epnum);
 
-	pRequest = next_request(pEnd);
+	request = next_request(musb_ep);
 
-	wCsrVal = musb_readw(epio, MGC_O_HDRC_RXCSR);
-	dma = is_dma_capable() ? pEnd->dma : NULL;
+	csr = musb_readw(epio, MUSB_RXCSR);
+	dma = is_dma_capable() ? musb_ep->dma : NULL;
 
-	DBG(4, "<== %s, rxcsr %04x%s %p\n", pEnd->end_point.name,
-			wCsrVal, dma ? " (dma)" : "", pRequest);
+	DBG(4, "<== %s, rxcsr %04x%s %p\n", musb_ep->end_point.name,
+			csr, dma ? " (dma)" : "", request);
 
-	if (wCsrVal & MGC_M_RXCSR_P_SENTSTALL) {
-		if (dma_channel_status(dma) == MGC_DMA_STATUS_BUSY) {
-			dma->bStatus = MGC_DMA_STATUS_CORE_ABORT;
-			(void) musb->pDmaController->channel_abort(dma);
-			pRequest->actual += pEnd->dma->dwActualLength;
+	if (csr & MUSB_RXCSR_P_SENTSTALL) {
+		if (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {
+			dma->status = MUSB_DMA_STATUS_CORE_ABORT;
+			(void) musb->dma_controller->channel_abort(dma);
+			request->actual += musb_ep->dma->actual_len;
 		}
 
-		wCsrVal |= MGC_M_RXCSR_P_WZC_BITS;
-		wCsrVal &= ~MGC_M_RXCSR_P_SENTSTALL;
-		musb_writew(epio, MGC_O_HDRC_RXCSR, wCsrVal);
+		csr |= MUSB_RXCSR_P_WZC_BITS;
+		csr &= ~MUSB_RXCSR_P_SENTSTALL;
+		musb_writew(epio, MUSB_RXCSR, csr);
 
-		if (pRequest)
-			musb_g_giveback(pEnd, pRequest, -EPIPE);
+		if (request)
+			musb_g_giveback(musb_ep, request, -EPIPE);
 		goto done;
 	}
 
-	if (wCsrVal & MGC_M_RXCSR_P_OVERRUN) {
-		// wCsrVal |= MGC_M_RXCSR_P_WZC_BITS;
-		wCsrVal &= ~MGC_M_RXCSR_P_OVERRUN;
-		musb_writew(epio, MGC_O_HDRC_RXCSR, wCsrVal);
-
-		DBG(3, "%s iso overrun on %p\n", pEnd->name, pRequest);
-		if (pRequest && pRequest->status == -EINPROGRESS)
-			pRequest->status = -EOVERFLOW;
+	if (csr & MUSB_RXCSR_P_OVERRUN) {
+		/* csr |= MUSB_RXCSR_P_WZC_BITS; */
+		csr &= ~MUSB_RXCSR_P_OVERRUN;
+		musb_writew(epio, MUSB_RXCSR, csr);
+
+		DBG(3, "%s iso overrun on %p\n", musb_ep->name, request);
+		if (request && request->status == -EINPROGRESS)
+			request->status = -EOVERFLOW;
 	}
-	if (wCsrVal & MGC_M_RXCSR_INCOMPRX) {
+	if (csr & MUSB_RXCSR_INCOMPRX) {
 		/* REVISIT not necessarily an error */
-		DBG(4, "%s, incomprx\n", pEnd->end_point.name);
+		DBG(4, "%s, incomprx\n", musb_ep->end_point.name);
 	}
 
-	if (dma_channel_status(dma) == MGC_DMA_STATUS_BUSY) {
+	if (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {
 		/* "should not happen"; likely RXPKTRDY pending for DMA */
-		DBG((wCsrVal & MGC_M_RXCSR_DMAENAB) ? 4 : 1,
+		DBG((csr & MUSB_RXCSR_DMAENAB) ? 4 : 1,
 			"%s busy, csr %04x\n",
-			pEnd->end_point.name, wCsrVal);
+			musb_ep->end_point.name, csr);
 		goto done;
 	}
 
-	if (dma && (wCsrVal & MGC_M_RXCSR_DMAENAB)) {
-		wCsrVal &= ~(MGC_M_RXCSR_AUTOCLEAR
-				| MGC_M_RXCSR_DMAENAB
-				| MGC_M_RXCSR_DMAMODE);
-		musb_writew(epio, MGC_O_HDRC_RXCSR,
-			MGC_M_RXCSR_P_WZC_BITS | wCsrVal);
+	if (dma && (csr & MUSB_RXCSR_DMAENAB)) {
+		csr &= ~(MUSB_RXCSR_AUTOCLEAR
+				| MUSB_RXCSR_DMAENAB
+				| MUSB_RXCSR_DMAMODE);
+		musb_writew(epio, MUSB_RXCSR,
+			MUSB_RXCSR_P_WZC_BITS | csr);
 
-		pRequest->actual += pEnd->dma->dwActualLength;
+		request->actual += musb_ep->dma->actual_len;
 
 		DBG(4, "RXCSR%d %04x, dma off, %04x, len %Zd, req %p\n",
-			bEnd, wCsrVal,
-			musb_readw(epio, MGC_O_HDRC_RXCSR),
-			pEnd->dma->dwActualLength, pRequest);
+			epnum, csr,
+			musb_readw(epio, MUSB_RXCSR),
+			musb_ep->dma->actual_len, request);
 
 #if defined(CONFIG_USB_INVENTRA_DMA) || defined(CONFIG_USB_TUSB_OMAP_DMA)
 		/* Autoclear doesn't clear RxPktRdy for short packets */
-		if ((dma->bDesiredMode == 0)
-				|| (dma->dwActualLength
-					& (pEnd->wPacketSize - 1))) {
+		if ((dma->desired_mode == 0)
+				|| (dma->actual_len
+					& (musb_ep->packet_sz - 1))) {
 			/* ack the read! */
-			wCsrVal &= ~MGC_M_RXCSR_RXPKTRDY;
-			musb_writew(epio, MGC_O_HDRC_RXCSR, wCsrVal);
+			csr &= ~MUSB_RXCSR_RXPKTRDY;
+			musb_writew(epio, MUSB_RXCSR, csr);
 		}
 
 		/* incomplete, and not short? wait for next IN packet */
-                if ((pRequest->actual < pRequest->length)
-				&& (pEnd->dma->dwActualLength
-					== pEnd->wPacketSize))
+		if ((request->actual < request->length)
+				&& (musb_ep->dma->actual_len
+					== musb_ep->packet_sz))
 			goto done;
 #endif
-		musb_g_giveback(pEnd, pRequest, 0);
+		musb_g_giveback(musb_ep, request, 0);
 
-		pRequest = next_request(pEnd);
-		if (!pRequest)
+		request = next_request(musb_ep);
+		if (!request)
 			goto done;
 
 		/* don't start more i/o till the stall clears */
-		MGC_SelectEnd(pBase, bEnd);
-		wCsrVal = musb_readw(epio, MGC_O_HDRC_RXCSR);
-		if (wCsrVal & MGC_M_RXCSR_P_SENDSTALL)
+		musb_ep_select(mbase, epnum);
+		csr = musb_readw(epio, MUSB_RXCSR);
+		if (csr & MUSB_RXCSR_P_SENDSTALL)
 			goto done;
 	}
 
 
 	/* analyze request if the ep is hot */
-	if (pRequest)
-		rxstate(musb, to_musb_request(pRequest));
+	if (request)
+		rxstate(musb, to_musb_request(request));
 	else
 		DBG(3, "packet waiting for %s%s request\n",
-				pEnd->desc ? "" : "inactive ",
-				pEnd->end_point.name);
+				musb_ep->desc ? "" : "inactive ",
+				musb_ep->end_point.name);
 
 done:
 	return;
@@ -837,12 +850,12 @@
 			const struct usb_endpoint_descriptor *desc)
 {
 	unsigned long		flags;
-	struct musb_ep		*pEnd;
+	struct musb_ep		*musb_ep;
 	struct musb_hw_ep	*hw_ep;
 	void __iomem		*regs;
 	struct musb		*musb;
-	void __iomem	*pBase;
-	u8		bEnd;
+	void __iomem	*mbase;
+	u8		epnum;
 	u16		csr;
 	unsigned	tmp;
 	int		status = -EINVAL;
@@ -850,131 +863,131 @@
 	if (!ep || !desc)
 		return -EINVAL;
 
-	pEnd = to_musb_ep(ep);
-	hw_ep = pEnd->hw_ep;
+	musb_ep = to_musb_ep(ep);
+	hw_ep = musb_ep->hw_ep;
 	regs = hw_ep->regs;
-	musb = pEnd->pThis;
-	pBase = musb->pRegs;
-	bEnd = pEnd->bEndNumber;
+	musb = musb_ep->musb;
+	mbase = musb->mregs;
+	epnum = musb_ep->current_epnum;
 
-	spin_lock_irqsave(&musb->Lock, flags);
+	spin_lock_irqsave(&musb->lock, flags);
 
-	if (pEnd->desc) {
+	if (musb_ep->desc) {
 		status = -EBUSY;
 		goto fail;
 	}
-	pEnd->type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+	musb_ep->type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
 
 	/* check direction and (later) maxpacket size against endpoint */
-	if ((desc->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK) != bEnd)
+	if ((desc->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK) != epnum)
 		goto fail;
 
 	/* REVISIT this rules out high bandwidth periodic transfers */
 	tmp = le16_to_cpu(desc->wMaxPacketSize);
 	if (tmp & ~0x07ff)
 		goto fail;
-	pEnd->wPacketSize = tmp;
+	musb_ep->packet_sz = tmp;
 
 	/* enable the interrupts for the endpoint, set the endpoint
 	 * packet size (or fail), set the mode, clear the fifo
 	 */
-	MGC_SelectEnd(pBase, bEnd);
+	musb_ep_select(mbase, epnum);
 	if (desc->bEndpointAddress & USB_DIR_IN) {
-		u16 wIntrTxE = musb_readw(pBase, MGC_O_HDRC_INTRTXE);
+		u16 int_txe = musb_readw(mbase, MUSB_INTRTXE);
 
-		if (hw_ep->bIsSharedFifo)
-			pEnd->is_in = 1;
-		if (!pEnd->is_in)
+		if (hw_ep->is_shared_fifo)
+			musb_ep->is_in = 1;
+		if (!musb_ep->is_in)
 			goto fail;
-		if (tmp > hw_ep->wMaxPacketSizeTx)
+		if (tmp > hw_ep->max_packet_sz_tx)
 			goto fail;
 
-		wIntrTxE |= (1 << bEnd);
-		musb_writew(pBase, MGC_O_HDRC_INTRTXE, wIntrTxE);
+		int_txe |= (1 << epnum);
+		musb_writew(mbase, MUSB_INTRTXE, int_txe);
 
 		/* REVISIT if can_bulk_split(), use by updating "tmp";
 		 * likewise high bandwidth periodic tx
 		 */
-		musb_writew(regs, MGC_O_HDRC_TXMAXP, tmp);
+		musb_writew(regs, MUSB_TXMAXP, tmp);
 
-		csr = MGC_M_TXCSR_MODE | MGC_M_TXCSR_CLRDATATOG;
-		if (musb_readw(regs, MGC_O_HDRC_TXCSR)
-				& MGC_M_TXCSR_FIFONOTEMPTY)
-			csr |= MGC_M_TXCSR_FLUSHFIFO;
-		if (pEnd->type == USB_ENDPOINT_XFER_ISOC)
-			csr |= MGC_M_TXCSR_P_ISO;
+		csr = MUSB_TXCSR_MODE | MUSB_TXCSR_CLRDATATOG;
+		if (musb_readw(regs, MUSB_TXCSR)
+				& MUSB_TXCSR_FIFONOTEMPTY)
+			csr |= MUSB_TXCSR_FLUSHFIFO;
+		if (musb_ep->type == USB_ENDPOINT_XFER_ISOC)
+			csr |= MUSB_TXCSR_P_ISO;
 
 		/* set twice in case of double buffering */
-		musb_writew(regs, MGC_O_HDRC_TXCSR, csr);
+		musb_writew(regs, MUSB_TXCSR, csr);
 		/* REVISIT may be inappropriate w/o FIFONOTEMPTY ... */
-		musb_writew(regs, MGC_O_HDRC_TXCSR, csr);
+		musb_writew(regs, MUSB_TXCSR, csr);
 
 	} else {
-		u16 wIntrRxE = musb_readw(pBase, MGC_O_HDRC_INTRRXE);
+		u16 int_rxe = musb_readw(mbase, MUSB_INTRRXE);
 
-		if (hw_ep->bIsSharedFifo)
-			pEnd->is_in = 0;
-		if (pEnd->is_in)
+		if (hw_ep->is_shared_fifo)
+			musb_ep->is_in = 0;
+		if (musb_ep->is_in)
 			goto fail;
-		if (tmp > hw_ep->wMaxPacketSizeRx)
+		if (tmp > hw_ep->max_packet_sz_rx)
 			goto fail;
 
-		wIntrRxE |= (1 << bEnd);
-		musb_writew(pBase, MGC_O_HDRC_INTRRXE, wIntrRxE);
+		int_rxe |= (1 << epnum);
+		musb_writew(mbase, MUSB_INTRRXE, int_rxe);
 
 		/* REVISIT if can_bulk_combine() use by updating "tmp"
 		 * likewise high bandwidth periodic rx
 		 */
-		musb_writew(regs, MGC_O_HDRC_RXMAXP, tmp);
+		musb_writew(regs, MUSB_RXMAXP, tmp);
 
 		/* force shared fifo to OUT-only mode */
-		if (hw_ep->bIsSharedFifo) {
-			csr = musb_readw(regs, MGC_O_HDRC_TXCSR);
-			csr &= ~(MGC_M_TXCSR_MODE | MGC_M_TXCSR_TXPKTRDY);
-			musb_writew(regs, MGC_O_HDRC_TXCSR, csr);
+		if (hw_ep->is_shared_fifo) {
+			csr = musb_readw(regs, MUSB_TXCSR);
+			csr &= ~(MUSB_TXCSR_MODE | MUSB_TXCSR_TXPKTRDY);
+			musb_writew(regs, MUSB_TXCSR, csr);
 		}
 
-		csr = MGC_M_RXCSR_FLUSHFIFO | MGC_M_RXCSR_CLRDATATOG;
-		if (pEnd->type == USB_ENDPOINT_XFER_ISOC)
-			csr |= MGC_M_RXCSR_P_ISO;
-		else if (pEnd->type == USB_ENDPOINT_XFER_INT)
-			csr |= MGC_M_RXCSR_DISNYET;
+		csr = MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_CLRDATATOG;
+		if (musb_ep->type == USB_ENDPOINT_XFER_ISOC)
+			csr |= MUSB_RXCSR_P_ISO;
+		else if (musb_ep->type == USB_ENDPOINT_XFER_INT)
+			csr |= MUSB_RXCSR_DISNYET;
 
 		/* set twice in case of double buffering */
-		musb_writew(regs, MGC_O_HDRC_RXCSR, csr);
-		musb_writew(regs, MGC_O_HDRC_RXCSR, csr);
+		musb_writew(regs, MUSB_RXCSR, csr);
+		musb_writew(regs, MUSB_RXCSR, csr);
 	}
 
 	/* NOTE:  all the I/O code _should_ work fine without DMA, in case
 	 * for some reason you run out of channels here.
 	 */
-	if (is_dma_capable() && musb->pDmaController) {
-		struct dma_controller	*c = musb->pDmaController;
+	if (is_dma_capable() && musb->dma_controller) {
+		struct dma_controller	*c = musb->dma_controller;
 
-		pEnd->dma = c->channel_alloc(c, hw_ep,
+		musb_ep->dma = c->channel_alloc(c, hw_ep,
 				(desc->bEndpointAddress & USB_DIR_IN));
 	} else
-		pEnd->dma = NULL;
+		musb_ep->dma = NULL;
 
-	pEnd->desc = desc;
-	pEnd->busy = 0;
+	musb_ep->desc = desc;
+	musb_ep->busy = 0;
 	status = 0;
 
 	pr_debug("%s periph: enabled %s for %s %s, %smaxpacket %d\n",
-			musb_driver_name, pEnd->end_point.name,
-			({ char *s; switch (pEnd->type) {
+			musb_driver_name, musb_ep->end_point.name,
+			({ char *s; switch (musb_ep->type) {
 			case USB_ENDPOINT_XFER_BULK:	s = "bulk"; break;
 			case USB_ENDPOINT_XFER_INT:	s = "int"; break;
 			default:			s = "iso"; break;
 			}; s; }),
-			pEnd->is_in ? "IN" : "OUT",
-			pEnd->dma ? "dma, " : "",
-			pEnd->wPacketSize);
+			musb_ep->is_in ? "IN" : "OUT",
+			musb_ep->dma ? "dma, " : "",
+			musb_ep->packet_sz);
 
 	schedule_work(&musb->irq_work);
 
 fail:
-	spin_unlock_irqrestore(&musb->Lock, flags);
+	spin_unlock_irqrestore(&musb->lock, flags);
 	return status;
 }
 
@@ -985,42 +998,42 @@
 {
 	unsigned long	flags;
 	struct musb	*musb;
-	u8		bEnd;
-	struct musb_ep	*pEnd;
+	u8		epnum;
+	struct musb_ep	*musb_ep;
 	void __iomem	*epio;
 	int		status = 0;
 
-	pEnd = to_musb_ep(ep);
-	musb = pEnd->pThis;
-	bEnd = pEnd->bEndNumber;
-	epio = musb->aLocalEnd[bEnd].regs;
+	musb_ep = to_musb_ep(ep);
+	musb = musb_ep->musb;
+	epnum = musb_ep->current_epnum;
+	epio = musb->endpoints[epnum].regs;
 
-	spin_lock_irqsave(&musb->Lock, flags);
-	MGC_SelectEnd(musb->pRegs, bEnd);
+	spin_lock_irqsave(&musb->lock, flags);
+	musb_ep_select(musb->mregs, epnum);
 
 	/* zero the endpoint sizes */
-	if (pEnd->is_in) {
-		u16 wIntrTxE = musb_readw(musb->pRegs, MGC_O_HDRC_INTRTXE);
-		wIntrTxE &= ~(1 << bEnd);
-		musb_writew(musb->pRegs, MGC_O_HDRC_INTRTXE, wIntrTxE);
-		musb_writew(epio, MGC_O_HDRC_TXMAXP, 0);
+	if (musb_ep->is_in) {
+		u16 int_txe = musb_readw(musb->mregs, MUSB_INTRTXE);
+		int_txe &= ~(1 << epnum);
+		musb_writew(musb->mregs, MUSB_INTRTXE, int_txe);
+		musb_writew(epio, MUSB_TXMAXP, 0);
 	} else {
-		u16 wIntrRxE = musb_readw(musb->pRegs, MGC_O_HDRC_INTRRXE);
-		wIntrRxE &= ~(1 << bEnd);
-		musb_writew(musb->pRegs, MGC_O_HDRC_INTRRXE, wIntrRxE);
-		musb_writew(epio, MGC_O_HDRC_RXMAXP, 0);
+		u16 int_rxe = musb_readw(musb->mregs, MUSB_INTRRXE);
+		int_rxe &= ~(1 << epnum);
+		musb_writew(musb->mregs, MUSB_INTRRXE, int_rxe);
+		musb_writew(epio, MUSB_RXMAXP, 0);
 	}
 
-	pEnd->desc = NULL;
+	musb_ep->desc = NULL;
 
 	/* abort all pending DMA and requests */
-	nuke(pEnd, -ESHUTDOWN);
+	nuke(musb_ep, -ESHUTDOWN);
 
 	schedule_work(&musb->irq_work);
 
-	spin_unlock_irqrestore(&(musb->Lock), flags);
+	spin_unlock_irqrestore(&(musb->lock), flags);
 
-	DBG(2, "%s\n", pEnd->end_point.name);
+	DBG(2, "%s\n", musb_ep->end_point.name);
 
 	return status;
 }
@@ -1032,17 +1045,17 @@
 struct usb_request *musb_alloc_request(struct usb_ep *ep, gfp_t gfp_flags)
 {
 	struct musb_ep		*musb_ep = to_musb_ep(ep);
-	struct musb_request	*pRequest = NULL;
+	struct musb_request	*request = NULL;
 
-	pRequest = kzalloc(sizeof *pRequest, gfp_flags);
-	if (pRequest) {
-		INIT_LIST_HEAD(&pRequest->request.list);
-		pRequest->request.dma = DMA_ADDR_INVALID;
-		pRequest->bEnd = musb_ep->bEndNumber;
-		pRequest->ep = musb_ep;
+	request = kzalloc(sizeof *request, gfp_flags);
+	if (request) {
+		INIT_LIST_HEAD(&request->request.list);
+		request->request.dma = DMA_ADDR_INVALID;
+		request->epnum = musb_ep->current_epnum;
+		request->ep = musb_ep;
 	}
 
-	return &pRequest->request;
+	return &request->request;
 }
 
 /*
@@ -1054,6 +1067,8 @@
 	kfree(to_musb_request(req));
 }
 
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22)
+
 /*
  * dma-coherent memory allocation (for dma-capable endpoints)
  *
@@ -1066,11 +1081,14 @@
 {
 	struct musb_ep *musb_ep = to_musb_ep(ep);
 
-	return dma_alloc_coherent(musb_ep->pThis->controller,
+	return dma_alloc_coherent(musb_ep->musb->controller,
 			bytes, dma, gfp_flags);
 }
 
 static DEFINE_SPINLOCK(buflock);
+
+#endif
+
 static LIST_HEAD(buffers);
 
 struct free_record {
@@ -1080,6 +1098,8 @@
 	dma_addr_t		dma;
 };
 
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22)
+
 static void do_free(unsigned long ignored)
 {
 	spin_lock_irq(&buflock);
@@ -1106,7 +1126,7 @@
 	struct free_record	*buf = address;
 	unsigned long		flags;
 
-	buf->dev = musb_ep->pThis->controller;
+	buf->dev = musb_ep->musb->controller;
 	buf->bytes = bytes;
 	buf->dma = dma;
 
@@ -1116,17 +1136,19 @@
 	spin_unlock_irqrestore(&buflock, flags);
 }
 
+#endif
+
 /*
  * Context: controller locked, IRQs blocked.
  */
 static void musb_ep_restart(struct musb *musb, struct musb_request *req)
 {
 	DBG(3, "<== %s request %p len %u on hw_ep%d\n",
-		req->bTx ? "TX/IN" : "RX/OUT",
-		&req->request, req->request.length, req->bEnd);
+		req->tx ? "TX/IN" : "RX/OUT",
+		&req->request, req->request.length, req->epnum);
 
-	MGC_SelectEnd(musb->pRegs, req->bEnd);
-	if (req->bTx)
+	musb_ep_select(musb->mregs, req->epnum);
+	if (req->tx)
 		txstate(musb, req);
 	else
 		rxstate(musb, req);
@@ -1135,125 +1157,127 @@
 static int musb_gadget_queue(struct usb_ep *ep, struct usb_request *req,
 			gfp_t gfp_flags)
 {
-	struct musb_ep		*pEnd;
-	struct musb_request	*pRequest;
+	struct musb_ep		*musb_ep;
+	struct musb_request	*request;
 	struct musb		*musb;
 	int			status = 0;
 	unsigned long		lockflags;
 
 	if (!ep || !req)
 		return -EINVAL;
+	if (!req->buf)
+		return -ENODATA;
 
-	pEnd = to_musb_ep(ep);
-	musb = pEnd->pThis;
+	musb_ep = to_musb_ep(ep);
+	musb = musb_ep->musb;
 
-	pRequest = to_musb_request(req);
-	pRequest->musb = musb;
+	request = to_musb_request(req);
+	request->musb = musb;
 
-	if (pRequest->ep != pEnd)
+	if (request->ep != musb_ep)
 		return -EINVAL;
 
 	DBG(4, "<== to %s request=%p\n", ep->name, req);
 
 	/* request is mine now... */
-	pRequest->request.actual = 0;
-	pRequest->request.status = -EINPROGRESS;
-	pRequest->bEnd = pEnd->bEndNumber;
-	pRequest->bTx = pEnd->is_in;
-
-	if (is_dma_capable() && pEnd->dma) {
-		if (pRequest->request.dma == DMA_ADDR_INVALID) {
-			pRequest->request.dma = dma_map_single(
+	request->request.actual = 0;
+	request->request.status = -EINPROGRESS;
+	request->epnum = musb_ep->current_epnum;
+	request->tx = musb_ep->is_in;
+
+	if (is_dma_capable() && musb_ep->dma) {
+		if (request->request.dma == DMA_ADDR_INVALID) {
+			request->request.dma = dma_map_single(
 					musb->controller,
-					pRequest->request.buf,
-					pRequest->request.length,
-					pRequest->bTx
+					request->request.buf,
+					request->request.length,
+					request->tx
 						? DMA_TO_DEVICE
 						: DMA_FROM_DEVICE);
-			pRequest->mapped = 1;
+			request->mapped = 1;
 		} else {
 			dma_sync_single_for_device(musb->controller,
-					pRequest->request.dma,
-					pRequest->request.length,
-					pRequest->bTx
+					request->request.dma,
+					request->request.length,
+					request->tx
 						? DMA_TO_DEVICE
 						: DMA_FROM_DEVICE);
-			pRequest->mapped = 0;
+			request->mapped = 0;
 		}
 	} else if (!req->buf) {
 		return -ENODATA;
 	} else
-		pRequest->mapped = 0;
+		request->mapped = 0;
 
-	spin_lock_irqsave(&musb->Lock, lockflags);
+	spin_lock_irqsave(&musb->lock, lockflags);
 
 	/* don't queue if the ep is down */
-	if (!pEnd->desc) {
+	if (!musb_ep->desc) {
 		DBG(4, "req %p queued to %s while ep %s\n",
 				req, ep->name, "disabled");
 		status = -ESHUTDOWN;
 		goto cleanup;
 	}
 
-	/* add pRequest to the list */
-	list_add_tail(&(pRequest->request.list), &(pEnd->req_list));
+	/* add request to the list */
+	list_add_tail(&(request->request.list), &(musb_ep->req_list));
 
 	/* it this is the head of the queue, start i/o ... */
-	if (!pEnd->busy && &pRequest->request.list == pEnd->req_list.next)
-		musb_ep_restart(musb, pRequest);
+	if (!musb_ep->busy && &request->request.list == musb_ep->req_list.next)
+		musb_ep_restart(musb, request);
 
 cleanup:
-	spin_unlock_irqrestore(&musb->Lock, lockflags);
+	spin_unlock_irqrestore(&musb->lock, lockflags);
 	return status;
 }
 
-static int musb_gadget_dequeue(struct usb_ep *ep, struct usb_request *pRequest)
+static int musb_gadget_dequeue(struct usb_ep *ep, struct usb_request *request)
 {
-	struct musb_ep		*pEnd = to_musb_ep(ep);
+	struct musb_ep		*musb_ep = to_musb_ep(ep);
 	struct usb_request	*r;
 	unsigned long		flags;
 	int			status = 0;
-	struct musb		*musb = pEnd->pThis;
+	struct musb		*musb = musb_ep->musb;
 
-	if (!ep || !pRequest || to_musb_request(pRequest)->ep != pEnd)
+	if (!ep || !request || to_musb_request(request)->ep != musb_ep)
 		return -EINVAL;
 
-	spin_lock_irqsave(&musb->Lock, flags);
+	spin_lock_irqsave(&musb->lock, flags);
 
-	list_for_each_entry(r, &pEnd->req_list, list) {
-		if (r == pRequest)
+	list_for_each_entry(r, &musb_ep->req_list, list) {
+		if (r == request)
 			break;
 	}
-	if (r != pRequest) {
-		DBG(3, "request %p not queued to %s\n", pRequest, ep->name);
+	if (r != request) {
+		DBG(3, "request %p not queued to %s\n", request, ep->name);
 		status = -EINVAL;
 		goto done;
 	}
 
 	/* if the hardware doesn't have the request, easy ... */
-	if (pEnd->req_list.next != &pRequest->list || pEnd->busy)
-		musb_g_giveback(pEnd, pRequest, -ECONNRESET);
+	if (musb_ep->req_list.next != &request->list || musb_ep->busy)
+		musb_g_giveback(musb_ep, request, -ECONNRESET);
 
 	/* ... else abort the dma transfer ... */
-	else if (is_dma_capable() && pEnd->dma) {
-		struct dma_controller	*c = musb->pDmaController;
+	else if (is_dma_capable() && musb_ep->dma) {
+		struct dma_controller	*c = musb->dma_controller;
 
-		MGC_SelectEnd(musb->pRegs, pEnd->bEndNumber);
+		musb_ep_select(musb->mregs, musb_ep->current_epnum);
 		if (c->channel_abort)
-			status = c->channel_abort(pEnd->dma);
+			status = c->channel_abort(musb_ep->dma);
 		else
 			status = -EBUSY;
 		if (status == 0)
-			musb_g_giveback(pEnd, pRequest, -ECONNRESET);
+			musb_g_giveback(musb_ep, request, -ECONNRESET);
 	} else {
 		/* NOTE: by sticking to easily tested hardware/driver states,
 		 * we leave counting of in-flight packets imprecise.
 		 */
-		musb_g_giveback(pEnd, pRequest, -ECONNRESET);
+		musb_g_giveback(musb_ep, request, -ECONNRESET);
 	}
 
 done:
-	spin_unlock_irqrestore(&musb->Lock, flags);
+	spin_unlock_irqrestore(&musb->lock, flags);
 	return status;
 }
 
@@ -1265,34 +1289,36 @@
  */
 int musb_gadget_set_halt(struct usb_ep *ep, int value)
 {
-	struct musb_ep		*pEnd = to_musb_ep(ep);
-	u8			bEnd = pEnd->bEndNumber;
-	struct musb		*musb = pEnd->pThis;
-	void __iomem		*epio = musb->aLocalEnd[bEnd].regs;
-	void __iomem		*pBase;
+	struct musb_ep		*musb_ep = to_musb_ep(ep);
+	u8			epnum = musb_ep->current_epnum;
+	struct musb		*musb = musb_ep->musb;
+	void __iomem		*epio = musb->endpoints[epnum].regs;
+	void __iomem		*mbase;
 	unsigned long		flags;
-	u16			wCsr;
-	struct musb_request	*pRequest = NULL;
+	u16			csr;
+	struct musb_request	*request = NULL;
 	int			status = 0;
 
-	pBase = musb->pRegs;
+	if (!ep)
+		return -EINVAL;
+	mbase = musb->mregs;
 
-	spin_lock_irqsave(&musb->Lock, flags);
+	spin_lock_irqsave(&musb->lock, flags);
 
-	if ((USB_ENDPOINT_XFER_ISOC == pEnd->type)) {
+	if ((USB_ENDPOINT_XFER_ISOC == musb_ep->type)) {
 		status = -EINVAL;
 		goto done;
 	}
 
-	MGC_SelectEnd(pBase, bEnd);
+	musb_ep_select(mbase, epnum);
 
 	/* cannot portably stall with non-empty FIFO */
-	pRequest = to_musb_request(next_request(pEnd));
-	if (value && pEnd->is_in) {
-		wCsr = musb_readw(epio, MGC_O_HDRC_TXCSR);
-		if (wCsr & MGC_M_TXCSR_FIFONOTEMPTY) {
+	request = to_musb_request(next_request(musb_ep));
+	if (value && musb_ep->is_in) {
+		csr = musb_readw(epio, MUSB_TXCSR);
+		if (csr & MUSB_TXCSR_FIFONOTEMPTY) {
 			DBG(3, "%s fifo busy, cannot halt\n", ep->name);
-			spin_unlock_irqrestore(&musb->Lock, flags);
+			spin_unlock_irqrestore(&musb->lock, flags);
 			return -EAGAIN;
 		}
 
@@ -1300,41 +1326,41 @@
 
 	/* set/clear the stall and toggle bits */
 	DBG(2, "%s: %s stall\n", ep->name, value ? "set" : "clear");
-	if (pEnd->is_in) {
-		wCsr = musb_readw(epio, MGC_O_HDRC_TXCSR);
-		if (wCsr & MGC_M_TXCSR_FIFONOTEMPTY)
-			wCsr |= MGC_M_TXCSR_FLUSHFIFO;
-		wCsr |= MGC_M_TXCSR_P_WZC_BITS
-			| MGC_M_TXCSR_CLRDATATOG;
+	if (musb_ep->is_in) {
+		csr = musb_readw(epio, MUSB_TXCSR);
+		if (csr & MUSB_TXCSR_FIFONOTEMPTY)
+			csr |= MUSB_TXCSR_FLUSHFIFO;
+		csr |= MUSB_TXCSR_P_WZC_BITS
+			| MUSB_TXCSR_CLRDATATOG;
 		if (value)
-			wCsr |= MGC_M_TXCSR_P_SENDSTALL;
+			csr |= MUSB_TXCSR_P_SENDSTALL;
 		else
-			wCsr &= ~(MGC_M_TXCSR_P_SENDSTALL
-				| MGC_M_TXCSR_P_SENTSTALL);
-		wCsr &= ~MGC_M_TXCSR_TXPKTRDY;
-		musb_writew(epio, MGC_O_HDRC_TXCSR, wCsr);
+			csr &= ~(MUSB_TXCSR_P_SENDSTALL
+				| MUSB_TXCSR_P_SENTSTALL);
+		csr &= ~MUSB_TXCSR_TXPKTRDY;
+		musb_writew(epio, MUSB_TXCSR, csr);
 	} else {
-		wCsr = musb_readw(epio, MGC_O_HDRC_RXCSR);
-		wCsr |= MGC_M_RXCSR_P_WZC_BITS
-			| MGC_M_RXCSR_FLUSHFIFO
-			| MGC_M_RXCSR_CLRDATATOG;
+		csr = musb_readw(epio, MUSB_RXCSR);
+		csr |= MUSB_RXCSR_P_WZC_BITS
+			| MUSB_RXCSR_FLUSHFIFO
+			| MUSB_RXCSR_CLRDATATOG;
 		if (value)
-			wCsr |= MGC_M_RXCSR_P_SENDSTALL;
+			csr |= MUSB_RXCSR_P_SENDSTALL;
 		else
-			wCsr &= ~(MGC_M_RXCSR_P_SENDSTALL
-				| MGC_M_RXCSR_P_SENTSTALL);
-		musb_writew(epio, MGC_O_HDRC_RXCSR, wCsr);
+			csr &= ~(MUSB_RXCSR_P_SENDSTALL
+				| MUSB_RXCSR_P_SENTSTALL);
+		musb_writew(epio, MUSB_RXCSR, csr);
 	}
 
 done:
 
 	/* maybe start the first request in the queue */
-	if (!pEnd->busy && !value && pRequest) {
+	if (!musb_ep->busy && !value && request) {
 		DBG(3, "restarting the request\n");
-		musb_ep_restart(musb, pRequest);
+		musb_ep_restart(musb, request);
 	}
 
-	spin_unlock_irqrestore(&musb->Lock, flags);
+	spin_unlock_irqrestore(&musb->lock, flags);
 	return status;
 }
 
@@ -1345,18 +1371,18 @@
 	int			retval = -EINVAL;
 
 	if (musb_ep->desc && !musb_ep->is_in) {
-		struct musb		*musb = musb_ep->pThis;
-		int			bEnd = musb_ep->bEndNumber;
-		void __iomem		*mbase = musb->pRegs;
+		struct musb		*musb = musb_ep->musb;
+		int			epnum = musb_ep->current_epnum;
+		void __iomem		*mbase = musb->mregs;
 		unsigned long		flags;
 
-		spin_lock_irqsave(&musb->Lock, flags);
+		spin_lock_irqsave(&musb->lock, flags);
 
-		MGC_SelectEnd(mbase, bEnd);
+		musb_ep_select(mbase, epnum);
 		/* FIXME return zero unless RXPKTRDY is set */
-		retval = musb_readw(epio, MGC_O_HDRC_RXCOUNT);
+		retval = musb_readw(epio, MUSB_RXCOUNT);
 
-		spin_unlock_irqrestore(&musb->Lock, flags);
+		spin_unlock_irqrestore(&musb->lock, flags);
 	}
 	return retval;
 }
@@ -1364,40 +1390,40 @@
 static void musb_gadget_fifo_flush(struct usb_ep *ep)
 {
 	struct musb_ep	*musb_ep = to_musb_ep(ep);
-	struct musb	*musb = musb_ep->pThis;
-	u8		nEnd = musb_ep->bEndNumber;
-	void __iomem	*epio = musb->aLocalEnd[nEnd].regs;
+	struct musb	*musb = musb_ep->musb;
+	u8		epnum = musb_ep->current_epnum;
+	void __iomem	*epio = musb->endpoints[epnum].regs;
 	void __iomem	*mbase;
 	unsigned long	flags;
-	u16		wCsr, wIntrTxE;
+	u16		csr, int_txe;
 
-	mbase = musb->pRegs;
+	mbase = musb->mregs;
 
-	spin_lock_irqsave(&musb->Lock, flags);
-	MGC_SelectEnd(mbase, (u8) nEnd);
+	spin_lock_irqsave(&musb->lock, flags);
+	musb_ep_select(mbase, (u8) epnum);
 
 	/* disable interrupts */
-	wIntrTxE = musb_readw(mbase, MGC_O_HDRC_INTRTXE);
-	musb_writew(mbase, MGC_O_HDRC_INTRTXE, wIntrTxE & ~(1 << nEnd));
+	int_txe = musb_readw(mbase, MUSB_INTRTXE);
+	musb_writew(mbase, MUSB_INTRTXE, int_txe & ~(1 << epnum));
 
 	if (musb_ep->is_in) {
-		wCsr = musb_readw(epio, MGC_O_HDRC_TXCSR);
-		if (wCsr & MGC_M_TXCSR_FIFONOTEMPTY) {
-			wCsr |= MGC_M_TXCSR_FLUSHFIFO | MGC_M_TXCSR_P_WZC_BITS;
-			musb_writew(epio, MGC_O_HDRC_TXCSR, wCsr);
+		csr = musb_readw(epio, MUSB_TXCSR);
+		if (csr & MUSB_TXCSR_FIFONOTEMPTY) {
+			csr |= MUSB_TXCSR_FLUSHFIFO | MUSB_TXCSR_P_WZC_BITS;
+			musb_writew(epio, MUSB_TXCSR, csr);
 			/* REVISIT may be inappropriate w/o FIFONOTEMPTY ... */
-			musb_writew(epio, MGC_O_HDRC_TXCSR, wCsr);
+			musb_writew(epio, MUSB_TXCSR, csr);
 		}
 	} else {
-		wCsr = musb_readw(epio, MGC_O_HDRC_RXCSR);
-		wCsr |= MGC_M_RXCSR_FLUSHFIFO | MGC_M_RXCSR_P_WZC_BITS;
-		musb_writew(epio, MGC_O_HDRC_RXCSR, wCsr);
-		musb_writew(epio, MGC_O_HDRC_RXCSR, wCsr);
+		csr = musb_readw(epio, MUSB_RXCSR);
+		csr |= MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_P_WZC_BITS;
+		musb_writew(epio, MUSB_RXCSR, csr);
+		musb_writew(epio, MUSB_RXCSR, csr);
 	}
 
 	/* re-enable interrupt */
-	musb_writew(mbase, MGC_O_HDRC_INTRTXE, wIntrTxE);
-	spin_unlock_irqrestore(&musb->Lock, flags);
+	musb_writew(mbase, MUSB_INTRTXE, int_txe);
+	spin_unlock_irqrestore(&musb->lock, flags);
 }
 
 static const struct usb_ep_ops musb_ep_ops = {
@@ -1405,8 +1431,12 @@
 	.disable	= musb_gadget_disable,
 	.alloc_request	= musb_alloc_request,
 	.free_request	= musb_free_request,
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22)
 	.alloc_buffer	= musb_gadget_alloc_buffer,
 	.free_buffer	= musb_gadget_free_buffer,
+#endif
+
 	.queue		= musb_gadget_queue,
 	.dequeue	= musb_gadget_dequeue,
 	.set_halt	= musb_gadget_set_halt,
@@ -1414,25 +1444,26 @@
 	.fifo_flush	= musb_gadget_fifo_flush
 };
 
-/***********************************************************************/
+/* ----------------------------------------------------------------------- */
 
 static int musb_gadget_get_frame(struct usb_gadget *gadget)
 {
 	struct musb	*musb = gadget_to_musb(gadget);
 
-	return (int)musb_readw(musb->pRegs, MGC_O_HDRC_FRAME);
+	return (int)musb_readw(musb->mregs, MUSB_FRAME);
 }
 
 static int musb_gadget_wakeup(struct usb_gadget *gadget)
 {
 	struct musb	*musb = gadget_to_musb(gadget);
-	void __iomem	*mregs = musb->pRegs;
+	void __iomem	*mregs = musb->mregs;
 	unsigned long	flags;
 	int		status = -EINVAL;
 	u8		power, devctl;
+	int		retries;
 
-	spin_lock_irqsave(&musb->Lock, flags);
-
+	spin_lock_irqsave(&musb->lock, flags);
+	musb_platform_wakeup(musb);
 	switch (musb->xceiv.state) {
 	case OTG_STATE_B_PERIPHERAL:
 		/* NOTE:  OTG state machine doesn't include B_SUSPENDED;
@@ -1444,31 +1475,52 @@
 		goto done;
 	case OTG_STATE_B_IDLE:
 		/* Start SRP ... OTG not required. */
-		devctl = musb_readb(mregs, MGC_O_HDRC_DEVCTL);
-		devctl |= MGC_M_DEVCTL_SESSION;
-		musb_writeb(mregs, MGC_O_HDRC_DEVCTL, devctl);
-		DBG(2, "SRP\n");
+		devctl = musb_readb(mregs, MUSB_DEVCTL);
+		DBG(2, "Sending SRP: devctl: %02x\n", devctl);
+		devctl |= MUSB_DEVCTL_SESSION;
+		musb_writeb(mregs, MUSB_DEVCTL, devctl);
+		devctl = musb_readb(mregs, MUSB_DEVCTL);
+		retries = 100;
+		while (!(devctl & MUSB_DEVCTL_SESSION)) {
+			devctl = musb_readb(mregs, MUSB_DEVCTL);
+			if (retries-- < 1)
+				break;
+		}
+		retries = 10000;
+		while (devctl & MUSB_DEVCTL_SESSION) {
+			devctl = musb_readb(mregs, MUSB_DEVCTL);
+			if (retries-- < 1)
+				break;
+		}
+
+		musb->srp_sent = 1;
+
+		/* Block idling for at least 1s */
+		musb_platform_try_idle(musb,
+			jiffies + msecs_to_jiffies(1 * HZ));
+
 		status = 0;
 		goto done;
 	default:
+		DBG(2, "Unhandled wake: %s\n", otg_state_string(musb));
 		goto done;
 	}
 
 	status = 0;
 
-	power = musb_readb(mregs, MGC_O_HDRC_POWER);
-	power |= MGC_M_POWER_RESUME;
-	musb_writeb(mregs, MGC_O_HDRC_POWER, power);
+	power = musb_readb(mregs, MUSB_POWER);
+	power |= MUSB_POWER_RESUME;
+	musb_writeb(mregs, MUSB_POWER, power);
 	DBG(2, "issue wakeup\n");
 
 	/* FIXME do this next chunk in a timer callback, no udelay */
 	mdelay(2);
 
-	power = musb_readb(mregs, MGC_O_HDRC_POWER);
-	power &= ~MGC_M_POWER_RESUME;
-	musb_writeb(mregs, MGC_O_HDRC_POWER, power);
+	power = musb_readb(mregs, MUSB_POWER);
+	power &= ~MUSB_POWER_RESUME;
+	musb_writeb(mregs, MUSB_POWER, power);
 done:
-	spin_unlock_irqrestore(&musb->Lock, flags);
+	spin_unlock_irqrestore(&musb->lock, flags);
 	return status;
 }
 
@@ -1485,37 +1537,31 @@
 {
 	u8 power;
 
-	power = musb_readb(musb->pRegs, MGC_O_HDRC_POWER);
+	power = musb_readb(musb->mregs, MUSB_POWER);
 	if (is_on)
-		power |= MGC_M_POWER_SOFTCONN;
+		power |= MUSB_POWER_SOFTCONN;
 	else
-		power &= ~MGC_M_POWER_SOFTCONN;
+		power &= ~MUSB_POWER_SOFTCONN;
 
 	/* FIXME if on, HdrcStart; if off, HdrcStop */
 
 	DBG(3, "gadget %s D+ pullup %s\n",
-		musb->pGadgetDriver->function, is_on ? "on" : "off");
-	musb_writeb(musb->pRegs, MGC_O_HDRC_POWER, power);
+		musb->gadget_driver->function, is_on ? "on" : "off");
+	musb_writeb(musb->mregs, MUSB_POWER, power);
 }
 
 #if 0
 static int musb_gadget_vbus_session(struct usb_gadget *gadget, int is_active)
 {
-	DBG(2, "<= %s =>\n", __FUNCTION__);
+	DBG(2, "<= %s =>\n", __func__);
 
-	// FIXME iff driver's softconnect flag is set (as it is during probe,
-	// though that can clear it), just musb_pullup().
+	/*
+	 * FIXME iff driver's softconnect flag is set (as it is during probe,
+	 * though that can clear it), just musb_pullup().
+	 */
 
 	return -EINVAL;
 }
-
-static int musb_gadget_vbus_draw(struct usb_gadget *gadget, unsigned mA)
-{
-	/* FIXME -- delegate to otg_transciever logic */
-
-	DBG(2, "<= vbus_draw %u =>\n", mA);
-	return 0;
-}
 #endif
 
 static int musb_gadget_vbus_draw(struct usb_gadget *gadget, unsigned mA)
@@ -1537,12 +1583,12 @@
 	/* NOTE: this assumes we are sensing vbus; we'd rather
 	 * not pullup unless the B-session is active.
 	 */
-	spin_lock_irqsave(&musb->Lock, flags);
+	spin_lock_irqsave(&musb->lock, flags);
 	if (is_on != musb->softconnect) {
 		musb->softconnect = is_on;
 		musb_pullup(musb, is_on);
 	}
-	spin_unlock_irqrestore(&musb->Lock, flags);
+	spin_unlock_irqrestore(&musb->lock, flags);
 	return 0;
 }
 
@@ -1550,14 +1596,14 @@
 	.get_frame		= musb_gadget_get_frame,
 	.wakeup			= musb_gadget_wakeup,
 	.set_selfpowered	= musb_gadget_set_self_powered,
-	//.vbus_session		= musb_gadget_vbus_session,
+	/* .vbus_session		= musb_gadget_vbus_session, */
 	.vbus_draw		= musb_gadget_vbus_draw,
 	.pullup			= musb_gadget_pullup,
 };
 
-/****************************************************************
- * Registration operations
- ****************************************************************/
+/* ----------------------------------------------------------------------- */
+
+/* Registration */
 
 /* Only this registration code "knows" the rule (from USB standards)
  * about there being only one external upstream port.  It assumes
@@ -1567,39 +1613,39 @@
 
 static void musb_gadget_release(struct device *dev)
 {
-	// kref_put(WHAT)
-	dev_dbg(dev, "%s\n", __FUNCTION__);
+	/* kref_put(WHAT) */
+	dev_dbg(dev, "%s\n", __func__);
 }
 
 
 static void __init
-init_peripheral_ep(struct musb *musb, struct musb_ep *ep, u8 bEnd, int is_in)
+init_peripheral_ep(struct musb *musb, struct musb_ep *ep, u8 epnum, int is_in)
 {
-	struct musb_hw_ep	*hw_ep = musb->aLocalEnd + bEnd;
+	struct musb_hw_ep	*hw_ep = musb->endpoints + epnum;
 
 	memset(ep, 0, sizeof *ep);
 
-	ep->bEndNumber = bEnd;
-	ep->pThis = musb;
+	ep->current_epnum = epnum;
+	ep->musb = musb;
 	ep->hw_ep = hw_ep;
 	ep->is_in = is_in;
 
 	INIT_LIST_HEAD(&ep->req_list);
 
-	sprintf(ep->name, "ep%d%s", bEnd,
-			(!bEnd || hw_ep->bIsSharedFifo) ? "" : (
+	sprintf(ep->name, "ep%d%s", epnum,
+			(!epnum || hw_ep->is_shared_fifo) ? "" : (
 				is_in ? "in" : "out"));
 	ep->end_point.name = ep->name;
 	INIT_LIST_HEAD(&ep->end_point.ep_list);
-	if (!bEnd) {
+	if (!epnum) {
 		ep->end_point.maxpacket = 64;
 		ep->end_point.ops = &musb_g_ep0_ops;
 		musb->g.ep0 = &ep->end_point;
 	} else {
 		if (is_in)
-			ep->end_point.maxpacket = hw_ep->wMaxPacketSizeTx;
+			ep->end_point.maxpacket = hw_ep->max_packet_sz_tx;
 		else
-			ep->end_point.maxpacket = hw_ep->wMaxPacketSizeRx;
+			ep->end_point.maxpacket = hw_ep->max_packet_sz_rx;
 		ep->end_point.ops = &musb_ep_ops;
 		list_add_tail(&ep->end_point.ep_list, &musb->g.ep_list);
 	}
@@ -1611,28 +1657,28 @@
  */
 static inline void __init musb_g_init_endpoints(struct musb *musb)
 {
-	u8			bEnd;
+	u8			epnum;
 	struct musb_hw_ep	*hw_ep;
 	unsigned		count = 0;
 
 	/* intialize endpoint list just once */
 	INIT_LIST_HEAD(&(musb->g.ep_list));
 
-	for (bEnd = 0, hw_ep = musb->aLocalEnd;
-			bEnd < musb->bEndCount;
-			bEnd++, hw_ep++) {
-		if (hw_ep->bIsSharedFifo /* || !bEnd */) {
-			init_peripheral_ep(musb, &hw_ep->ep_in, bEnd, 0);
+	for (epnum = 0, hw_ep = musb->endpoints;
+			epnum < musb->nr_endpoints;
+			epnum++, hw_ep++) {
+		if (hw_ep->is_shared_fifo /* || !epnum */) {
+			init_peripheral_ep(musb, &hw_ep->ep_in, epnum, 0);
 			count++;
 		} else {
-			if (hw_ep->wMaxPacketSizeTx) {
+			if (hw_ep->max_packet_sz_tx) {
 				init_peripheral_ep(musb, &hw_ep->ep_in,
-							bEnd, 1);
+							epnum, 1);
 				count++;
 			}
-			if (hw_ep->wMaxPacketSizeRx) {
+			if (hw_ep->max_packet_sz_rx) {
 				init_peripheral_ep(musb, &hw_ep->ep_out,
-							bEnd, 0);
+							epnum, 0);
 				count++;
 			}
 		}
@@ -1665,13 +1711,13 @@
 	musb->g.dev.release = musb_gadget_release;
 	musb->g.name = musb_driver_name;
 
-	if (is_otg_enabled(musb))
+	if (is_otg_enabled(musb) && !machine_is_nokia_n800())
 		musb->g.is_otg = 1;
 
 	musb_g_init_endpoints(musb);
 
 	musb->is_active = 0;
-	musb_platform_try_idle(musb);
+	musb_platform_try_idle(musb, 0);
 
 	status = device_register(&musb->g.dev);
 	if (status != 0)
@@ -1714,40 +1760,40 @@
 	/* driver must be initialized to support peripheral mode */
 	if (!musb || !(musb->board_mode == MUSB_OTG
 				|| musb->board_mode != MUSB_OTG)) {
-		DBG(1,"%s, no dev??\n", __FUNCTION__);
+		DBG(1, "%s, no dev??\n", __func__);
 		return -ENODEV;
 	}
 
 	DBG(3, "registering driver %s\n", driver->function);
-	spin_lock_irqsave(&musb->Lock, flags);
+	spin_lock_irqsave(&musb->lock, flags);
 
-	if (musb->pGadgetDriver) {
+	if (musb->gadget_driver) {
 		DBG(1, "%s is already bound to %s\n",
 				musb_driver_name,
-				musb->pGadgetDriver->driver.name);
+				musb->gadget_driver->driver.name);
 		retval = -EBUSY;
 	} else {
-		musb->pGadgetDriver = driver;
+		musb->gadget_driver = driver;
 		musb->g.dev.driver = &driver->driver;
 		driver->driver.bus = NULL;
 		musb->softconnect = 1;
 		retval = 0;
 	}
 
-	spin_unlock_irqrestore(&musb->Lock, flags);
+	spin_unlock_irqrestore(&musb->lock, flags);
 
 	if (retval == 0)
 		retval = driver->bind(&musb->g);
 	if (retval != 0) {
 		DBG(3, "bind to driver %s failed --> %d\n",
 			driver->driver.name, retval);
-		musb->pGadgetDriver = NULL;
+		musb->gadget_driver = NULL;
 		musb->g.dev.driver = NULL;
 	}
 
 	/* start peripheral and/or OTG engines */
 	if (retval == 0) {
-		spin_lock_irqsave(&musb->Lock, flags);
+		spin_lock_irqsave(&musb->lock, flags);
 
 		/* REVISIT always use otg_set_peripheral(), handling
 		 * issues including the root hub one below ...
@@ -1765,7 +1811,7 @@
 		if (!is_otg_enabled(musb))
 			musb_start(musb);
 
-		spin_unlock_irqrestore(&musb->Lock, flags);
+		spin_unlock_irqrestore(&musb->lock, flags);
 
 		if (is_otg_enabled(musb)) {
 			DBG(3, "OTG startup...\n");
@@ -1777,12 +1823,12 @@
 			retval = usb_add_hcd(musb_to_hcd(musb), -1, 0);
 			if (retval < 0) {
 				DBG(1, "add_hcd failed, %d\n", retval);
-				spin_lock_irqsave(&musb->Lock, flags);
+				spin_lock_irqsave(&musb->lock, flags);
 				musb->xceiv.gadget = NULL;
 				musb->xceiv.state = OTG_STATE_UNDEFINED;
-				musb->pGadgetDriver = NULL;
+				musb->gadget_driver = NULL;
 				musb->g.dev.driver = NULL;
-				spin_unlock_irqrestore(&musb->Lock, flags);
+				spin_unlock_irqrestore(&musb->lock, flags);
 			}
 		}
 	}
@@ -1791,8 +1837,7 @@
 }
 EXPORT_SYMBOL(usb_gadget_register_driver);
 
-static void
-stop_activity(struct musb *musb, struct usb_gadget_driver *driver)
+static void stop_activity(struct musb *musb, struct usb_gadget_driver *driver)
 {
 	int			i;
 	struct musb_hw_ep	*hw_ep;
@@ -1814,23 +1859,23 @@
 	 * then report disconnect
 	 */
 	if (driver) {
-		for (i = 0, hw_ep = musb->aLocalEnd;
-				i < musb->bEndCount;
+		for (i = 0, hw_ep = musb->endpoints;
+				i < musb->nr_endpoints;
 				i++, hw_ep++) {
-			MGC_SelectEnd(musb->pRegs, i);
-			if (hw_ep->bIsSharedFifo /* || !bEnd */) {
+			musb_ep_select(musb->mregs, i);
+			if (hw_ep->is_shared_fifo /* || !epnum */) {
 				nuke(&hw_ep->ep_in, -ESHUTDOWN);
 			} else {
-				if (hw_ep->wMaxPacketSizeTx)
+				if (hw_ep->max_packet_sz_tx)
 					nuke(&hw_ep->ep_in, -ESHUTDOWN);
-				if (hw_ep->wMaxPacketSizeRx)
+				if (hw_ep->max_packet_sz_rx)
 					nuke(&hw_ep->ep_out, -ESHUTDOWN);
 			}
 		}
 
-		spin_unlock(&musb->Lock);
-		driver->disconnect (&musb->g);
-		spin_lock(&musb->Lock);
+		spin_unlock(&musb->lock);
+		driver->disconnect(&musb->g);
+		spin_lock(&musb->lock);
 	}
 }
 
@@ -1853,24 +1898,32 @@
 	 * this needs to shut down the OTG engine.
 	 */
 
-	spin_lock_irqsave(&musb->Lock, flags);
-	if (musb->pGadgetDriver == driver) {
+	spin_lock_irqsave(&musb->lock, flags);
+
+#ifdef	CONFIG_USB_MUSB_OTG
+	musb_hnp_stop(musb);
+#endif
+
+	if (musb->gadget_driver == driver) {
+
+		(void) musb_gadget_vbus_draw(&musb->g, 0);
+
 		musb->xceiv.state = OTG_STATE_UNDEFINED;
 		stop_activity(musb, driver);
 
 		DBG(3, "unregistering driver %s\n", driver->function);
-		spin_unlock_irqrestore(&musb->Lock, flags);
+		spin_unlock_irqrestore(&musb->lock, flags);
 		driver->unbind(&musb->g);
-		spin_lock_irqsave(&musb->Lock, flags);
+		spin_lock_irqsave(&musb->lock, flags);
 
-		musb->pGadgetDriver = NULL;
+		musb->gadget_driver = NULL;
 		musb->g.dev.driver = NULL;
 
 		musb->is_active = 0;
-		musb_platform_try_idle(musb);
+		musb_platform_try_idle(musb, 0);
 	} else
 		retval = -EINVAL;
-	spin_unlock_irqrestore(&musb->Lock, flags);
+	spin_unlock_irqrestore(&musb->lock, flags);
 
 	if (is_otg_enabled(musb) && retval == 0) {
 		usb_remove_hcd(musb_to_hcd(musb));
@@ -1885,7 +1938,7 @@
 EXPORT_SYMBOL(usb_gadget_unregister_driver);
 
 
-/***********************************************************************/
+/* ----------------------------------------------------------------------- */
 
 /* lifecycle operations called through plat_uds.c */
 
@@ -1898,10 +1951,10 @@
 	case OTG_STATE_B_WAIT_ACON:
 	case OTG_STATE_B_PERIPHERAL:
 		musb->is_active = 1;
-		if (musb->pGadgetDriver && musb->pGadgetDriver->resume) {
-			spin_unlock(&musb->Lock);
-			musb->pGadgetDriver->resume(&musb->g);
-			spin_lock(&musb->Lock);
+		if (musb->gadget_driver && musb->gadget_driver->resume) {
+			spin_unlock(&musb->lock);
+			musb->gadget_driver->resume(&musb->g);
+			spin_lock(&musb->lock);
 		}
 		break;
 	default:
@@ -1915,20 +1968,20 @@
 {
 	u8	devctl;
 
-	devctl = musb_readb(musb->pRegs, MGC_O_HDRC_DEVCTL);
+	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 	DBG(3, "devctl %02x\n", devctl);
 
 	switch (musb->xceiv.state) {
 	case OTG_STATE_B_IDLE:
-		if ((devctl & MGC_M_DEVCTL_VBUS) == MGC_M_DEVCTL_VBUS)
+		if ((devctl & MUSB_DEVCTL_VBUS) == MUSB_DEVCTL_VBUS)
 			musb->xceiv.state = OTG_STATE_B_PERIPHERAL;
 		break;
 	case OTG_STATE_B_PERIPHERAL:
 		musb->is_suspended = 1;
-		if (musb->pGadgetDriver && musb->pGadgetDriver->suspend) {
-			spin_unlock(&musb->Lock);
-			musb->pGadgetDriver->suspend(&musb->g);
-			spin_lock(&musb->Lock);
+		if (musb->gadget_driver && musb->gadget_driver->suspend) {
+			spin_unlock(&musb->lock);
+			musb->gadget_driver->suspend(&musb->g);
+			spin_lock(&musb->lock);
 		}
 		break;
 	default:
@@ -1940,36 +1993,48 @@
 	}
 }
 
+/* Called during SRP */
+void musb_g_wakeup(struct musb *musb)
+{
+	musb_gadget_wakeup(&musb->g);
+}
+
 /* called when VBUS drops below session threshold, and in other cases */
 void musb_g_disconnect(struct musb *musb)
 {
-	void __iomem	*mregs = musb->pRegs;
-	u8	devctl = musb_readb(mregs, MGC_O_HDRC_DEVCTL);
+	void __iomem	*mregs = musb->mregs;
+	u8	devctl = musb_readb(mregs, MUSB_DEVCTL);
 
 	DBG(3, "devctl %02x\n", devctl);
 
 	/* clear HR */
-	musb_writeb(mregs, MGC_O_HDRC_DEVCTL, devctl & MGC_M_DEVCTL_SESSION);
+	musb_writeb(mregs, MUSB_DEVCTL, devctl & MUSB_DEVCTL_SESSION);
 
 	/* don't draw vbus until new b-default session */
 	(void) musb_gadget_vbus_draw(&musb->g, 0);
 
 	musb->g.speed = USB_SPEED_UNKNOWN;
-	if (musb->pGadgetDriver && musb->pGadgetDriver->disconnect) {
-		spin_unlock(&musb->Lock);
-		musb->pGadgetDriver->disconnect(&musb->g);
-		spin_lock(&musb->Lock);
+	if (musb->gadget_driver && musb->gadget_driver->disconnect) {
+		spin_unlock(&musb->lock);
+		musb->gadget_driver->disconnect(&musb->g);
+		spin_lock(&musb->lock);
 	}
 
 	switch (musb->xceiv.state) {
 	default:
 #ifdef	CONFIG_USB_MUSB_OTG
+		DBG(2, "Unhandled disconnect %s, setting a_idle\n",
+			otg_state_string(musb));
 		musb->xceiv.state = OTG_STATE_A_IDLE;
 		break;
+	case OTG_STATE_A_PERIPHERAL:
+		musb->xceiv.state = OTG_STATE_A_WAIT_VFALL;
+		break;
 	case OTG_STATE_B_WAIT_ACON:
 	case OTG_STATE_B_HOST:
 #endif
 	case OTG_STATE_B_PERIPHERAL:
+	case OTG_STATE_B_IDLE:
 		musb->xceiv.state = OTG_STATE_B_IDLE;
 		break;
 	case OTG_STATE_B_SRP_INIT:
@@ -1980,19 +2045,19 @@
 }
 
 void musb_g_reset(struct musb *musb)
-__releases(musb->Lock)
-__acquires(musb->Lock)
+__releases(musb->lock)
+__acquires(musb->lock)
 {
-	void __iomem	*pBase = musb->pRegs;
-	u8		devctl = musb_readb(pBase, MGC_O_HDRC_DEVCTL);
+	void __iomem	*mbase = musb->mregs;
+	u8		devctl = musb_readb(mbase, MUSB_DEVCTL);
 	u8		power;
 
 	DBG(3, "<== %s addr=%x driver '%s'\n",
-			(devctl & MGC_M_DEVCTL_BDEVICE)
+			(devctl & MUSB_DEVCTL_BDEVICE)
 				? "B-Device" : "A-Device",
-			musb_readb(pBase, MGC_O_HDRC_FADDR),
-			musb->pGadgetDriver
-				? musb->pGadgetDriver->driver.name
+			musb_readb(mbase, MUSB_FADDR),
+			musb->gadget_driver
+				? musb->gadget_driver->driver.name
 				: NULL
 			);
 
@@ -2001,21 +2066,21 @@
 		musb_g_disconnect(musb);
 
 	/* clear HR */
-	else if (devctl & MGC_M_DEVCTL_HR)
-		musb_writeb(pBase, MGC_O_HDRC_DEVCTL, MGC_M_DEVCTL_SESSION);
+	else if (devctl & MUSB_DEVCTL_HR)
+		musb_writeb(mbase, MUSB_DEVCTL, MUSB_DEVCTL_SESSION);
 
 
 	/* what speed did we negotiate? */
-	power = musb_readb(pBase, MGC_O_HDRC_POWER);
-	musb->g.speed = (power & MGC_M_POWER_HSMODE)
+	power = musb_readb(mbase, MUSB_POWER);
+	musb->g.speed = (power & MUSB_POWER_HSMODE)
 			? USB_SPEED_HIGH : USB_SPEED_FULL;
 
 	/* start in USB_STATE_DEFAULT */
 	musb->is_active = 1;
 	musb->is_suspended = 0;
 	MUSB_DEV_MODE(musb);
-	musb->bAddress = 0;
-	musb->ep0_state = MGC_END0_STAGE_SETUP;
+	musb->address = 0;
+	musb->ep0_state = MUSB_EP0_STAGE_SETUP;
 
 	musb->may_wakeup = 0;
 	musb->g.b_hnp_enable = 0;
@@ -2025,7 +2090,7 @@
 	/* Normal reset, as B-Device;
 	 * or else after HNP, as A-Device
 	 */
-	if (devctl & MGC_M_DEVCTL_BDEVICE) {
+	if (devctl & MUSB_DEVCTL_BDEVICE) {
 		musb->xceiv.state = OTG_STATE_B_PERIPHERAL;
 		musb->g.is_a_peripheral = 0;
 	} else if (is_otg_enabled(musb)) {
diff -ruN linux-omap-2.6/drivers/usb/musb/musb_gadget_ep0.c maemo_src/drivers/usb/musb/musb_gadget_ep0.c
--- linux-omap-2.6/drivers/usb/musb/musb_gadget_ep0.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/usb/musb/musb_gadget_ep0.c	2011-02-06 20:12:11.293333273 -0500
@@ -0,0 +1,1004 @@
+/*
+ * MUSB OTG peripheral driver ep0 handling
+ *
+ * Copyright 2005 Mentor Graphics Corporation
+ * Copyright (C) 2005-2006 by Texas Instruments
+ * Copyright (C) 2006-2007 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/timer.h>
+#include <linux/spinlock.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/version.h>
+
+#include "musb_core.h"
+
+/* ep0 is always musb->endpoints[0].ep_in */
+#define	next_ep0_request(musb)	next_in_request(&(musb)->endpoints[0])
+
+/*
+ * locking note:  we use only the controller lock, for simpler correctness.
+ * It's always held with IRQs blocked.
+ *
+ * It protects the ep0 request queue as well as ep0_state, not just the
+ * controller and indexed registers.  And that lock stays held unless it
+ * needs to be dropped to allow reentering this driver ... like upcalls to
+ * the gadget driver, or adjusting endpoint halt status.
+ */
+
+static char *decode_ep0stage(u8 stage)
+{
+	switch (stage) {
+	case MUSB_EP0_STAGE_SETUP:	return "idle";
+	case MUSB_EP0_STAGE_TX:		return "in";
+	case MUSB_EP0_STAGE_RX:		return "out";
+	case MUSB_EP0_STAGE_ACKWAIT:	return "wait";
+	case MUSB_EP0_STAGE_STATUSIN:	return "in/status";
+	case MUSB_EP0_STAGE_STATUSOUT:	return "out/status";
+	default:			return "?";
+	}
+}
+
+/* handle a standard GET_STATUS request
+ * Context:  caller holds controller lock
+ */
+static int service_tx_status_request(
+	struct musb *musb,
+	const struct usb_ctrlrequest *ctrlrequest)
+{
+	void __iomem	*mbase = musb->mregs;
+	int handled = 1;
+	u8 result[2], epnum = 0;
+	const u8 recip = ctrlrequest->bRequestType & USB_RECIP_MASK;
+
+	result[1] = 0;
+
+	switch (recip) {
+	case USB_RECIP_DEVICE:
+		result[0] = musb->is_self_powered << USB_DEVICE_SELF_POWERED;
+		result[0] |= musb->may_wakeup << USB_DEVICE_REMOTE_WAKEUP;
+#ifdef CONFIG_USB_MUSB_OTG
+		if (musb->g.is_otg) {
+			result[0] |= musb->g.b_hnp_enable
+				<< USB_DEVICE_B_HNP_ENABLE;
+			result[0] |= musb->g.a_alt_hnp_support
+				<< USB_DEVICE_A_ALT_HNP_SUPPORT;
+			result[0] |= musb->g.a_hnp_support
+				<< USB_DEVICE_A_HNP_SUPPORT;
+		}
+#endif
+		break;
+
+	case USB_RECIP_INTERFACE:
+		result[0] = 0;
+		break;
+
+	case USB_RECIP_ENDPOINT: {
+		int		is_in;
+		struct musb_ep	*ep;
+		u16		tmp;
+		void __iomem	*regs;
+
+		epnum = (u8) ctrlrequest->wIndex;
+		if (!epnum) {
+			result[0] = 0;
+			break;
+		}
+
+		is_in = epnum & USB_DIR_IN;
+		if (is_in) {
+			epnum &= 0x0f;
+			ep = &musb->endpoints[epnum].ep_in;
+		} else {
+			ep = &musb->endpoints[epnum].ep_out;
+		}
+		regs = musb->endpoints[epnum].regs;
+
+		if (epnum >= MUSB_C_NUM_EPS || !ep->desc) {
+			handled = -EINVAL;
+			break;
+		}
+
+		musb_ep_select(mbase, epnum);
+		if (is_in)
+			tmp = musb_readw(regs, MUSB_TXCSR)
+						& MUSB_TXCSR_P_SENDSTALL;
+		else
+			tmp = musb_readw(regs, MUSB_RXCSR)
+						& MUSB_RXCSR_P_SENDSTALL;
+		musb_ep_select(mbase, 0);
+
+		result[0] = tmp ? 1 : 0;
+		} break;
+
+	default:
+		/* class, vendor, etc ... delegate */
+		handled = 0;
+		break;
+	}
+
+	/* fill up the fifo; caller updates csr0 */
+	if (handled > 0) {
+		u16	len = le16_to_cpu(ctrlrequest->wLength);
+
+		if (len > 2)
+			len = 2;
+		musb_write_fifo(&musb->endpoints[0], len, result);
+	}
+
+	return handled;
+}
+
+/*
+ * handle a control-IN request, the end0 buffer contains the current request
+ * that is supposed to be a standard control request. Assumes the fifo to
+ * be at least 2 bytes long.
+ *
+ * @return 0 if the request was NOT HANDLED,
+ * < 0 when error
+ * > 0 when the request is processed
+ *
+ * Context:  caller holds controller lock
+ */
+static int
+service_in_request(struct musb *musb, const struct usb_ctrlrequest *ctrlrequest)
+{
+	int handled = 0;	/* not handled */
+
+	if ((ctrlrequest->bRequestType & USB_TYPE_MASK)
+			== USB_TYPE_STANDARD) {
+		switch (ctrlrequest->bRequest) {
+		case USB_REQ_GET_STATUS:
+			handled = service_tx_status_request(musb,
+					ctrlrequest);
+			break;
+
+		/* case USB_REQ_SYNC_FRAME: */
+
+		default:
+			break;
+		}
+	}
+	return handled;
+}
+
+/*
+ * Context:  caller holds controller lock
+ */
+static void musb_g_ep0_giveback(struct musb *musb, struct usb_request *req)
+{
+	musb_g_giveback(&musb->endpoints[0].ep_in, req, 0);
+	musb->ep0_state = MUSB_EP0_STAGE_SETUP;
+}
+
+/*
+ * Tries to start B-device HNP negotiation if enabled via sysfs
+ */
+static inline void musb_try_b_hnp_enable(struct musb *musb)
+{
+	void __iomem	*mbase = musb->mregs;
+	u8		devctl;
+
+	DBG(1, "HNP: Setting HR\n");
+	devctl = musb_readb(mbase, MUSB_DEVCTL);
+	musb_writeb(mbase, MUSB_DEVCTL, devctl | MUSB_DEVCTL_HR);
+}
+
+/*
+ * Handle all control requests with no DATA stage, including standard
+ * requests such as:
+ * USB_REQ_SET_CONFIGURATION, USB_REQ_SET_INTERFACE, unrecognized
+ *	always delegated to the gadget driver
+ * USB_REQ_SET_ADDRESS, USB_REQ_CLEAR_FEATURE, USB_REQ_SET_FEATURE
+ *	always handled here, except for class/vendor/... features
+ *
+ * Context:  caller holds controller lock
+ */
+static int
+service_zero_data_request(struct musb *musb,
+		struct usb_ctrlrequest *ctrlrequest)
+__releases(musb->lock)
+__acquires(musb->lock)
+{
+	int handled = -EINVAL;
+	void __iomem *mbase = musb->mregs;
+	const u8 recip = ctrlrequest->bRequestType & USB_RECIP_MASK;
+
+	/* the gadget driver handles everything except what we MUST handle */
+	if ((ctrlrequest->bRequestType & USB_TYPE_MASK)
+			== USB_TYPE_STANDARD) {
+		switch (ctrlrequest->bRequest) {
+		case USB_REQ_SET_ADDRESS:
+			/* change it after the status stage */
+			musb->set_address = true;
+			musb->address = (u8) (ctrlrequest->wValue & 0x7f);
+			handled = 1;
+			break;
+
+		case USB_REQ_CLEAR_FEATURE:
+			switch (recip) {
+			case USB_RECIP_DEVICE:
+				if (ctrlrequest->wValue
+						!= USB_DEVICE_REMOTE_WAKEUP)
+					break;
+				musb->may_wakeup = 0;
+				handled = 1;
+				break;
+			case USB_RECIP_INTERFACE:
+				break;
+			case USB_RECIP_ENDPOINT:{
+				const u8 epnum = ctrlrequest->wIndex & 0x0f;
+				struct musb_ep *musb_ep;
+
+				if (epnum == 0
+						|| epnum >= MUSB_C_NUM_EPS
+						|| ctrlrequest->wValue
+							!= USB_ENDPOINT_HALT)
+					break;
+
+				if (ctrlrequest->wIndex & USB_DIR_IN)
+					musb_ep = &musb->endpoints[epnum].ep_in;
+				else
+					musb_ep = &musb->endpoints[epnum].ep_out;
+				if (!musb_ep->desc)
+					break;
+
+				/* REVISIT do it directly, no locking games */
+				spin_unlock(&musb->lock);
+				musb_gadget_set_halt(&musb_ep->end_point, 0);
+				spin_lock(&musb->lock);
+
+				/* select ep0 again */
+				musb_ep_select(mbase, 0);
+				handled = 1;
+				} break;
+			default:
+				/* class, vendor, etc ... delegate */
+				handled = 0;
+				break;
+			}
+			break;
+
+		case USB_REQ_SET_FEATURE:
+			switch (recip) {
+			case USB_RECIP_DEVICE:
+				handled = 1;
+				switch (ctrlrequest->wValue) {
+				case USB_DEVICE_REMOTE_WAKEUP:
+					musb->may_wakeup = 1;
+					break;
+				case USB_DEVICE_TEST_MODE:
+					if (musb->g.speed != USB_SPEED_HIGH)
+						goto stall;
+					if (ctrlrequest->wIndex & 0xff)
+						goto stall;
+
+					switch (ctrlrequest->wIndex >> 8) {
+					case 1:
+						pr_debug("TEST_J\n");
+						/* TEST_J */
+						musb->test_mode_nr =
+							MUSB_TEST_J;
+						break;
+					case 2:
+						/* TEST_K */
+						pr_debug("TEST_K\n");
+						musb->test_mode_nr =
+							MUSB_TEST_K;
+						break;
+					case 3:
+						/* TEST_SE0_NAK */
+						pr_debug("TEST_SE0_NAK\n");
+						musb->test_mode_nr =
+							MUSB_TEST_SE0_NAK;
+						break;
+					case 4:
+						/* TEST_PACKET */
+						pr_debug("TEST_PACKET\n");
+						musb->test_mode_nr =
+							MUSB_TEST_PACKET;
+						break;
+					default:
+						goto stall;
+					}
+
+					/* enter test mode after irq */
+					if (handled > 0)
+						musb->test_mode = true;
+					break;
+#ifdef CONFIG_USB_MUSB_OTG
+				case USB_DEVICE_B_HNP_ENABLE:
+					if (!musb->g.is_otg)
+						goto stall;
+					musb->g.b_hnp_enable = 1;
+					musb_try_b_hnp_enable(musb);
+					break;
+				case USB_DEVICE_A_HNP_SUPPORT:
+					if (!musb->g.is_otg)
+						goto stall;
+					musb->g.a_hnp_support = 1;
+					break;
+				case USB_DEVICE_A_ALT_HNP_SUPPORT:
+					if (!musb->g.is_otg)
+						goto stall;
+					musb->g.a_alt_hnp_support = 1;
+					break;
+#endif
+stall:
+				default:
+					handled = -EINVAL;
+					break;
+				}
+				break;
+
+			case USB_RECIP_INTERFACE:
+				break;
+
+			case USB_RECIP_ENDPOINT:{
+				const u8		epnum =
+					ctrlrequest->wIndex & 0x0f;
+				struct musb_ep		*musb_ep;
+				struct musb_hw_ep	*ep;
+				void __iomem		*regs;
+				int			is_in;
+				u16			csr;
+
+				if (epnum == 0
+						|| epnum >= MUSB_C_NUM_EPS
+						|| ctrlrequest->wValue
+							!= USB_ENDPOINT_HALT)
+					break;
+
+				ep = musb->endpoints + epnum;
+				regs = ep->regs;
+				is_in = ctrlrequest->wIndex & USB_DIR_IN;
+				if (is_in)
+					musb_ep = &ep->ep_in;
+				else
+					musb_ep = &ep->ep_out;
+				if (!musb_ep->desc)
+					break;
+
+				musb_ep_select(mbase, epnum);
+				if (is_in) {
+					csr = musb_readw(regs,
+							MUSB_TXCSR);
+					if (csr & MUSB_TXCSR_FIFONOTEMPTY)
+						csr |= MUSB_TXCSR_FLUSHFIFO;
+					csr |= MUSB_TXCSR_P_SENDSTALL
+						| MUSB_TXCSR_CLRDATATOG
+						| MUSB_TXCSR_P_WZC_BITS;
+					musb_writew(regs, MUSB_TXCSR,
+							csr);
+				} else {
+					csr = musb_readw(regs,
+							MUSB_RXCSR);
+					csr |= MUSB_RXCSR_P_SENDSTALL
+						| MUSB_RXCSR_FLUSHFIFO
+						| MUSB_RXCSR_CLRDATATOG
+						| MUSB_TXCSR_P_WZC_BITS;
+					musb_writew(regs, MUSB_RXCSR,
+							csr);
+				}
+
+				/* select ep0 again */
+				musb_ep_select(mbase, 0);
+				handled = 1;
+				} break;
+
+			default:
+				/* class, vendor, etc ... delegate */
+				handled = 0;
+				break;
+			}
+			break;
+		default:
+			/* delegate SET_CONFIGURATION, etc */
+			handled = 0;
+		}
+	} else
+		handled = 0;
+	return handled;
+}
+
+/* we have an ep0out data packet
+ * Context:  caller holds controller lock
+ */
+static void ep0_rxstate(struct musb *musb)
+{
+	void __iomem		*regs = musb->control_ep->regs;
+	struct usb_request	*req;
+	u16			tmp;
+
+	req = next_ep0_request(musb);
+
+	/* read packet and ack; or stall because of gadget driver bug:
+	 * should have provided the rx buffer before setup() returned.
+	 */
+	if (req) {
+		void		*buf = req->buf + req->actual;
+		unsigned	len = req->length - req->actual;
+
+		/* read the buffer */
+		tmp = musb_readb(regs, MUSB_COUNT0);
+		if (tmp > len) {
+			req->status = -EOVERFLOW;
+			tmp = len;
+		}
+		musb_read_fifo(&musb->endpoints[0], tmp, buf);
+		req->actual += tmp;
+		tmp = MUSB_CSR0_P_SVDRXPKTRDY;
+		if (tmp < 64 || req->actual == req->length) {
+			musb->ep0_state = MUSB_EP0_STAGE_STATUSIN;
+			tmp |= MUSB_CSR0_P_DATAEND;
+		} else
+			req = NULL;
+	} else
+		tmp = MUSB_CSR0_P_SVDRXPKTRDY | MUSB_CSR0_P_SENDSTALL;
+
+
+	/* Completion handler may choose to stall, e.g. because the
+	 * message just received holds invalid data.
+	 */
+	if (req) {
+		musb->ackpend = tmp;
+		musb_g_ep0_giveback(musb, req);
+		if (!musb->ackpend)
+			return;
+		musb->ackpend = 0;
+	}
+	musb_writew(regs, MUSB_CSR0, tmp);
+}
+
+/*
+ * transmitting to the host (IN), this code might be called from IRQ
+ * and from kernel thread.
+ *
+ * Context:  caller holds controller lock
+ */
+static void ep0_txstate(struct musb *musb)
+{
+	void __iomem		*regs = musb->control_ep->regs;
+	struct usb_request	*request = next_ep0_request(musb);
+	u16			csr = MUSB_CSR0_TXPKTRDY;
+	u8			*fifo_src;
+	u8			fifo_count;
+
+	if (!request) {
+		/* WARN_ON(1); */
+		DBG(2, "odd; csr0 %04x\n", musb_readw(regs, MUSB_CSR0));
+		return;
+	}
+
+	/* load the data */
+	fifo_src = (u8 *) request->buf + request->actual;
+	fifo_count = min((unsigned) MUSB_EP0_FIFOSIZE,
+		request->length - request->actual);
+	musb_write_fifo(&musb->endpoints[0], fifo_count, fifo_src);
+	request->actual += fifo_count;
+
+	/* update the flags */
+	if (fifo_count < MUSB_MAX_END0_PACKET
+			|| request->actual == request->length) {
+		musb->ep0_state = MUSB_EP0_STAGE_STATUSOUT;
+		csr |= MUSB_CSR0_P_DATAEND;
+	} else
+		request = NULL;
+
+	/* report completions as soon as the fifo's loaded; there's no
+	 * win in waiting till this last packet gets acked.  (other than
+	 * very precise fault reporting, needed by USB TMC; possible with
+	 * this hardware, but not usable from portable gadget drivers.)
+	 */
+	if (request) {
+		musb->ackpend = csr;
+		musb_g_ep0_giveback(musb, request);
+		if (!musb->ackpend)
+			return;
+		musb->ackpend = 0;
+	}
+
+	/* send it out, triggering a "txpktrdy cleared" irq */
+	musb_writew(regs, MUSB_CSR0, csr);
+}
+
+/*
+ * Read a SETUP packet (struct usb_ctrlrequest) from the hardware.
+ * Fields are left in USB byte-order.
+ *
+ * Context:  caller holds controller lock.
+ */
+static void
+musb_read_setup(struct musb *musb, struct usb_ctrlrequest *req)
+{
+	struct usb_request	*r;
+	void __iomem		*regs = musb->control_ep->regs;
+
+	musb_read_fifo(&musb->endpoints[0], sizeof *req, (u8 *)req);
+
+	/* NOTE:  earlier 2.6 versions changed setup packets to host
+	 * order, but now USB packets always stay in USB byte order.
+	 */
+	DBG(3, "SETUP req%02x.%02x v%04x i%04x l%d\n",
+		req->bRequestType,
+		req->bRequest,
+		le16_to_cpu(req->wValue),
+		le16_to_cpu(req->wIndex),
+		le16_to_cpu(req->wLength));
+
+	/* clean up any leftover transfers */
+	r = next_ep0_request(musb);
+	if (r)
+		musb_g_ep0_giveback(musb, r);
+
+	/* For zero-data requests we want to delay the STATUS stage to
+	 * avoid SETUPEND errors.  If we read data (OUT), delay accepting
+	 * packets until there's a buffer to store them in.
+	 *
+	 * If we write data, the controller acts happier if we enable
+	 * the TX FIFO right away, and give the controller a moment
+	 * to switch modes...
+	 */
+	musb->set_address = false;
+	musb->ackpend = MUSB_CSR0_P_SVDRXPKTRDY;
+	if (req->wLength == 0) {
+		if (req->bRequestType & USB_DIR_IN)
+			musb->ackpend |= MUSB_CSR0_TXPKTRDY;
+		musb->ep0_state = MUSB_EP0_STAGE_ACKWAIT;
+	} else if (req->bRequestType & USB_DIR_IN) {
+		musb->ep0_state = MUSB_EP0_STAGE_TX;
+		musb_writew(regs, MUSB_CSR0, MUSB_CSR0_P_SVDRXPKTRDY);
+		while ((musb_readw(regs, MUSB_CSR0)
+				& MUSB_CSR0_RXPKTRDY) != 0)
+			cpu_relax();
+		musb->ackpend = 0;
+	} else
+		musb->ep0_state = MUSB_EP0_STAGE_RX;
+}
+
+static int
+forward_to_driver(struct musb *musb, const struct usb_ctrlrequest *ctrlrequest)
+__releases(musb->lock)
+__acquires(musb->lock)
+{
+	int retval;
+	if (!musb->gadget_driver)
+		return -EOPNOTSUPP;
+	spin_unlock(&musb->lock);
+	retval = musb->gadget_driver->setup(&musb->g, ctrlrequest);
+	spin_lock(&musb->lock);
+	return retval;
+}
+
+/*
+ * Handle peripheral ep0 interrupt
+ *
+ * Context: irq handler; we won't re-enter the driver that way.
+ */
+irqreturn_t musb_g_ep0_irq(struct musb *musb)
+{
+	u16		csr;
+	u16		len;
+	void __iomem	*mbase = musb->mregs;
+	void __iomem	*regs = musb->endpoints[0].regs;
+	irqreturn_t	retval = IRQ_NONE;
+
+	musb_ep_select(mbase, 0);	/* select ep0 */
+	csr = musb_readw(regs, MUSB_CSR0);
+	len = musb_readb(regs, MUSB_COUNT0);
+
+	DBG(4, "csr %04x, count %d, myaddr %d, ep0stage %s\n",
+			csr, len,
+			musb_readb(mbase, MUSB_FADDR),
+			decode_ep0stage(musb->ep0_state));
+
+	/* I sent a stall.. need to acknowledge it now.. */
+	if (csr & MUSB_CSR0_P_SENTSTALL) {
+		musb_writew(regs, MUSB_CSR0,
+				csr & ~MUSB_CSR0_P_SENTSTALL);
+		retval = IRQ_HANDLED;
+		musb->ep0_state = MUSB_EP0_STAGE_SETUP;
+		csr = musb_readw(regs, MUSB_CSR0);
+	}
+
+	/* request ended "early" */
+	if (csr & MUSB_CSR0_P_SETUPEND) {
+		musb_writew(regs, MUSB_CSR0, MUSB_CSR0_P_SVDSETUPEND);
+		retval = IRQ_HANDLED;
+		musb->ep0_state = MUSB_EP0_STAGE_SETUP;
+		csr = musb_readw(regs, MUSB_CSR0);
+		/* NOTE:  request may need completion */
+	}
+
+	/* docs from Mentor only describe tx, rx, and idle/setup states.
+	 * we need to handle nuances around status stages, and also the
+	 * case where status and setup stages come back-to-back ...
+	 */
+	switch (musb->ep0_state) {
+
+	case MUSB_EP0_STAGE_TX:
+		/* irq on clearing txpktrdy */
+		if ((csr & MUSB_CSR0_TXPKTRDY) == 0) {
+			ep0_txstate(musb);
+			retval = IRQ_HANDLED;
+		}
+		break;
+
+	case MUSB_EP0_STAGE_RX:
+		/* irq on set rxpktrdy */
+		if (csr & MUSB_CSR0_RXPKTRDY) {
+			ep0_rxstate(musb);
+			retval = IRQ_HANDLED;
+		}
+		break;
+
+	case MUSB_EP0_STAGE_STATUSIN:
+		/* end of sequence #2 (OUT/RX state) or #3 (no data) */
+
+		/* update address (if needed) only @ the end of the
+		 * status phase per usb spec, which also guarantees
+		 * we get 10 msec to receive this irq... until this
+		 * is done we won't see the next packet.
+		 */
+		if (musb->set_address) {
+			musb->set_address = false;
+			musb_writeb(mbase, MUSB_FADDR, musb->address);
+		}
+
+		/* enter test mode if needed (exit by reset) */
+		else if (musb->test_mode) {
+			DBG(1, "entering TESTMODE\n");
+
+			if (MUSB_TEST_PACKET == musb->test_mode_nr)
+				musb_load_testpacket(musb);
+
+			musb_writeb(mbase, MUSB_TESTMODE,
+					musb->test_mode_nr);
+		}
+		/* FALLTHROUGH */
+
+	case MUSB_EP0_STAGE_STATUSOUT:
+		/* end of sequence #1: write to host (TX state) */
+		{
+			struct usb_request	*req;
+
+			req = next_ep0_request(musb);
+			if (req)
+				musb_g_ep0_giveback(musb, req);
+		}
+		retval = IRQ_HANDLED;
+		musb->ep0_state = MUSB_EP0_STAGE_SETUP;
+		/* FALLTHROUGH */
+
+	case MUSB_EP0_STAGE_SETUP:
+		if (csr & MUSB_CSR0_RXPKTRDY) {
+			struct usb_ctrlrequest	setup;
+			int			handled = 0;
+
+			if (len != 8) {
+				ERR("SETUP packet len %d != 8 ?\n", len);
+				break;
+			}
+			musb_read_setup(musb, &setup);
+			retval = IRQ_HANDLED;
+
+			/* sometimes the RESET won't be reported */
+			if (unlikely(musb->g.speed == USB_SPEED_UNKNOWN)) {
+				u8	power;
+
+				printk(KERN_NOTICE "%s: peripheral reset "
+						"irq lost!\n",
+						musb_driver_name);
+				power = musb_readb(mbase, MUSB_POWER);
+				musb->g.speed = (power & MUSB_POWER_HSMODE)
+					? USB_SPEED_HIGH : USB_SPEED_FULL;
+
+			}
+
+			switch (musb->ep0_state) {
+
+			/* sequence #3 (no data stage), includes requests
+			 * we can't forward (notably SET_ADDRESS and the
+			 * device/endpoint feature set/clear operations)
+			 * plus SET_CONFIGURATION and others we must
+			 */
+			case MUSB_EP0_STAGE_ACKWAIT:
+				handled = service_zero_data_request(
+						musb, &setup);
+
+				/* status stage might be immediate */
+				if (handled > 0) {
+					musb->ackpend |= MUSB_CSR0_P_DATAEND;
+					musb->ep0_state =
+						MUSB_EP0_STAGE_STATUSIN;
+				}
+				break;
+
+			/* sequence #1 (IN to host), includes GET_STATUS
+			 * requests that we can't forward, GET_DESCRIPTOR
+			 * and others that we must
+			 */
+			case MUSB_EP0_STAGE_TX:
+				handled = service_in_request(musb, &setup);
+				if (handled > 0) {
+					musb->ackpend = MUSB_CSR0_TXPKTRDY
+						| MUSB_CSR0_P_DATAEND;
+					musb->ep0_state =
+						MUSB_EP0_STAGE_STATUSOUT;
+				}
+				break;
+
+			/* sequence #2 (OUT from host), always forward */
+			default:		/* MUSB_EP0_STAGE_RX */
+				break;
+			}
+
+			DBG(3, "handled %d, csr %04x, ep0stage %s\n",
+				handled, csr,
+				decode_ep0stage(musb->ep0_state));
+
+			/* unless we need to delegate this to the gadget
+			 * driver, we know how to wrap this up:  csr0 has
+			 * not yet been written.
+			 */
+			if (handled < 0)
+				goto stall;
+			else if (handled > 0)
+				goto finish;
+
+			handled = forward_to_driver(musb, &setup);
+			if (handled < 0) {
+				musb_ep_select(mbase, 0);
+stall:
+				DBG(3, "stall (%d)\n", handled);
+				musb->ackpend |= MUSB_CSR0_P_SENDSTALL;
+				musb->ep0_state = MUSB_EP0_STAGE_SETUP;
+finish:
+				musb_writew(regs, MUSB_CSR0,
+						musb->ackpend);
+				musb->ackpend = 0;
+			}
+		}
+		break;
+
+	case MUSB_EP0_STAGE_ACKWAIT:
+		/* This should not happen. But happens with tusb6010 with
+		 * g_file_storage and high speed. Do nothing.
+		 */
+		retval = IRQ_HANDLED;
+		break;
+
+	default:
+		/* "can't happen" */
+		WARN_ON(1);
+		musb_writew(regs, MUSB_CSR0, MUSB_CSR0_P_SENDSTALL);
+		musb->ep0_state = MUSB_EP0_STAGE_SETUP;
+		break;
+	}
+
+	return retval;
+}
+
+
+static int
+musb_g_ep0_enable(struct usb_ep *ep, const struct usb_endpoint_descriptor *desc)
+{
+	/* always enabled */
+	return -EINVAL;
+}
+
+static int musb_g_ep0_disable(struct usb_ep *e)
+{
+	/* always enabled */
+	return -EINVAL;
+}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22)
+
+static void *musb_g_ep0_alloc_buffer(struct usb_ep *ep, unsigned bytes,
+			dma_addr_t * dma, gfp_t gfp_flags)
+{
+	*dma = DMA_ADDR_INVALID;
+	return kmalloc(bytes, gfp_flags);
+}
+
+static void musb_g_ep0_free_buffer(struct usb_ep *ep, void *address,
+			dma_addr_t dma, unsigned bytes)
+{
+	kfree(address);
+}
+
+#endif
+
+static int
+musb_g_ep0_queue(struct usb_ep *e, struct usb_request *r, gfp_t gfp_flags)
+{
+	struct musb_ep		*ep;
+	struct musb_request	*req;
+	struct musb		*musb;
+	int			status;
+	unsigned long		lockflags;
+	void __iomem		*regs;
+
+	if (!e || !r)
+		return -EINVAL;
+
+	ep = to_musb_ep(e);
+	musb = ep->musb;
+	regs = musb->control_ep->regs;
+
+	req = to_musb_request(r);
+	req->musb = musb;
+	req->request.actual = 0;
+	req->request.status = -EINPROGRESS;
+	req->tx = ep->is_in;
+
+	spin_lock_irqsave(&musb->lock, lockflags);
+
+	if (!list_empty(&ep->req_list)) {
+		status = -EBUSY;
+		goto cleanup;
+	}
+
+	switch (musb->ep0_state) {
+	case MUSB_EP0_STAGE_RX:		/* control-OUT data */
+	case MUSB_EP0_STAGE_TX:		/* control-IN data */
+	case MUSB_EP0_STAGE_ACKWAIT:	/* zero-length data */
+		status = 0;
+		break;
+	default:
+		DBG(1, "ep0 request queued in state %d\n",
+				musb->ep0_state);
+		status = -EINVAL;
+		goto cleanup;
+	}
+
+	/* add request to the list */
+	list_add_tail(&(req->request.list), &(ep->req_list));
+
+	DBG(3, "queue to %s (%s), length=%d\n",
+			ep->name, ep->is_in ? "IN/TX" : "OUT/RX",
+			req->request.length);
+
+	musb_ep_select(musb->mregs, 0);
+
+	/* sequence #1, IN ... start writing the data */
+	if (musb->ep0_state == MUSB_EP0_STAGE_TX)
+		ep0_txstate(musb);
+
+	/* sequence #3, no-data ... issue IN status */
+	else if (musb->ep0_state == MUSB_EP0_STAGE_ACKWAIT) {
+		if (req->request.length)
+			status = -EINVAL;
+		else {
+			musb->ep0_state = MUSB_EP0_STAGE_STATUSIN;
+			musb_writew(regs, MUSB_CSR0,
+					musb->ackpend | MUSB_CSR0_P_DATAEND);
+			musb->ackpend = 0;
+			musb_g_ep0_giveback(ep->musb, r);
+		}
+
+	/* else for sequence #2 (OUT), caller provides a buffer
+	 * before the next packet arrives.  deferred responses
+	 * (after SETUP is acked) are racey.
+	 */
+	} else if (musb->ackpend) {
+		musb_writew(regs, MUSB_CSR0, musb->ackpend);
+		musb->ackpend = 0;
+	}
+
+cleanup:
+	spin_unlock_irqrestore(&musb->lock, lockflags);
+	return status;
+}
+
+static int musb_g_ep0_dequeue(struct usb_ep *ep, struct usb_request *req)
+{
+	/* we just won't support this */
+	return -EINVAL;
+}
+
+static int musb_g_ep0_halt(struct usb_ep *e, int value)
+{
+	struct musb_ep		*ep;
+	struct musb		*musb;
+	void __iomem		*base, *regs;
+	unsigned long		flags;
+	int			status;
+	u16			csr;
+
+	if (!e || !value)
+		return -EINVAL;
+
+	ep = to_musb_ep(e);
+	musb = ep->musb;
+	base = musb->mregs;
+	regs = musb->control_ep->regs;
+	status = 0;
+
+	spin_lock_irqsave(&musb->lock, flags);
+
+	if (!list_empty(&ep->req_list)) {
+		status = -EBUSY;
+		goto cleanup;
+	}
+
+	musb_ep_select(base, 0);
+	csr = musb->ackpend;
+
+	switch (musb->ep0_state) {
+
+	/* Stalls are usually issued after parsing SETUP packet, either
+	 * directly in irq context from setup() or else later.
+	 */
+	case MUSB_EP0_STAGE_TX:		/* control-IN data */
+	case MUSB_EP0_STAGE_ACKWAIT:	/* STALL for zero-length data */
+	case MUSB_EP0_STAGE_RX:		/* control-OUT data */
+		csr = musb_readw(regs, MUSB_CSR0);
+		/* FALLTHROUGH */
+
+	/* It's also OK to issue stalls during callbacks when a non-empty
+	 * DATA stage buffer has been read (or even written).
+	 */
+	case MUSB_EP0_STAGE_STATUSIN:	/* control-OUT status */
+	case MUSB_EP0_STAGE_STATUSOUT:	/* control-IN status */
+
+		csr |= MUSB_CSR0_P_SENDSTALL;
+		musb_writew(regs, MUSB_CSR0, csr);
+		musb->ep0_state = MUSB_EP0_STAGE_SETUP;
+		musb->ackpend = 0;
+		break;
+	default:
+		DBG(1, "ep0 can't halt in state %d\n", musb->ep0_state);
+		status = -EINVAL;
+	}
+
+cleanup:
+	spin_unlock_irqrestore(&musb->lock, flags);
+	return status;
+}
+
+const struct usb_ep_ops musb_g_ep0_ops = {
+	.enable		= musb_g_ep0_enable,
+	.disable	= musb_g_ep0_disable,
+	.alloc_request	= musb_alloc_request,
+	.free_request	= musb_free_request,
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,22)
+	.alloc_buffer	= musb_g_ep0_alloc_buffer,
+	.free_buffer	= musb_g_ep0_free_buffer,
+#endif
+	.queue		= musb_g_ep0_queue,
+	.dequeue	= musb_g_ep0_dequeue,
+	.set_halt	= musb_g_ep0_halt,
+};
diff -ruN linux-omap-2.6/drivers/usb/musb/musb_gadget.h maemo_src/drivers/usb/musb/musb_gadget.h
--- linux-omap-2.6/drivers/usb/musb/musb_gadget.h	2011-02-06 20:17:25.876666606 -0500
+++ maemo_src/drivers/usb/musb/musb_gadget.h	2007-10-02 03:09:32.000000000 -0400
@@ -1,35 +1,36 @@
-/******************************************************************
+/*
+ * MUSB OTG driver peripheral defines
+ *
  * Copyright 2005 Mentor Graphics Corporation
  * Copyright (C) 2005-2006 by Texas Instruments
+ * Copyright (C) 2006-2007 Nokia Corporation
  *
- * This file is part of the Inventra Controller Driver for Linux.
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
  *
- * The Inventra Controller Driver for Linux is free software; you
- * can redistribute it and/or modify it under the terms of the GNU
- * General Public License version 2 as published by the Free Software
- * Foundation.
- *
- * The Inventra Controller Driver for Linux is distributed in
- * the hope that it will be useful, but WITHOUT ANY WARRANTY;
- * without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
- * License for more details.
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with The Inventra Controller Driver for Linux ; if not,
- * write to the Free Software Foundation, Inc., 59 Temple Place,
- * Suite 330, Boston, MA  02111-1307  USA
- *
- * ANY DOWNLOAD, USE, REPRODUCTION, MODIFICATION OR DISTRIBUTION
- * OF THIS DRIVER INDICATES YOUR COMPLETE AND UNCONDITIONAL ACCEPTANCE
- * OF THOSE TERMS.THIS DRIVER IS PROVIDED "AS IS" AND MENTOR GRAPHICS
- * MAKES NO WARRANTIES, EXPRESS OR IMPLIED, RELATED TO THIS DRIVER.
- * MENTOR GRAPHICS SPECIFICALLY DISCLAIMS ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY; FITNESS FOR A PARTICULAR PURPOSE AND
- * NON-INFRINGEMENT.  MENTOR GRAPHICS DOES NOT PROVIDE SUPPORT
- * SERVICES OR UPDATES FOR THIS DRIVER, EVEN IF YOU ARE A MENTOR
- * GRAPHICS SUPPORT CUSTOMER.
- ******************************************************************/
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #ifndef __MUSB_GADGET_H
 #define __MUSB_GADGET_H
@@ -38,8 +39,8 @@
 	struct usb_request	request;
 	struct musb_ep		*ep;
 	struct musb		*musb;
-	u8 bTx;			/* endpoint direction */
-	u8 bEnd;
+	u8 tx;			/* endpoint direction */
+	u8 epnum;
 	u8 mapped;
 };
 
@@ -61,13 +62,13 @@
 	struct usb_ep			end_point;
 	char				name[12];
 	struct musb_hw_ep		*hw_ep;
-	struct musb			*pThis;
-	u8				bEndNumber;
+	struct musb			*musb;
+	u8				current_epnum;
 
 	/* ... when enabled/disabled ... */
 	u8				type;
 	u8				is_in;
-	u16				wPacketSize;
+	u16				packet_sz;
 	const struct usb_endpoint_descriptor	*desc;
 	struct dma_channel		*dma;
 
@@ -92,8 +93,8 @@
 	return container_of(queue->next, struct usb_request, list);
 }
 
-extern void musb_g_tx(struct musb *pThis, u8 bEnd);
-extern void musb_g_rx(struct musb *pThis, u8 bEnd);
+extern void musb_g_tx(struct musb *musb, u8 epnum);
+extern void musb_g_rx(struct musb *musb, u8 epnum);
 
 extern const struct usb_ep_ops musb_g_ep0_ops;
 
diff -ruN linux-omap-2.6/drivers/usb/musb/musbhdrc.h maemo_src/drivers/usb/musb/musbhdrc.h
--- linux-omap-2.6/drivers/usb/musb/musbhdrc.h	2011-02-06 20:17:25.889999940 -0500
+++ maemo_src/drivers/usb/musb/musbhdrc.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,321 +0,0 @@
-/******************************************************************
- * Copyright 2005 Mentor Graphics Corporation
- * Copyright (C) 2005-2006 by Texas Instruments
- *
- * This file is part of the Inventra Controller Driver for Linux.
- *
- * The Inventra Controller Driver for Linux is free software; you
- * can redistribute it and/or modify it under the terms of the GNU
- * General Public License version 2 as published by the Free Software
- * Foundation.
- *
- * The Inventra Controller Driver for Linux is distributed in
- * the hope that it will be useful, but WITHOUT ANY WARRANTY;
- * without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
- * License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with The Inventra Controller Driver for Linux ; if not,
- * write to the Free Software Foundation, Inc., 59 Temple Place,
- * Suite 330, Boston, MA  02111-1307  USA
- *
- * ANY DOWNLOAD, USE, REPRODUCTION, MODIFICATION OR DISTRIBUTION
- * OF THIS DRIVER INDICATES YOUR COMPLETE AND UNCONDITIONAL ACCEPTANCE
- * OF THOSE TERMS.THIS DRIVER IS PROVIDED "AS IS" AND MENTOR GRAPHICS
- * MAKES NO WARRANTIES, EXPRESS OR IMPLIED, RELATED TO THIS DRIVER.
- * MENTOR GRAPHICS SPECIFICALLY DISCLAIMS ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY; FITNESS FOR A PARTICULAR PURPOSE AND
- * NON-INFRINGEMENT.  MENTOR GRAPHICS DOES NOT PROVIDE SUPPORT
- * SERVICES OR UPDATES FOR THIS DRIVER, EVEN IF YOU ARE A MENTOR
- * GRAPHICS SUPPORT CUSTOMER.
- ******************************************************************/
-
-#ifndef __MUSB_HDRC_DEFS_H__
-#define __MUSB_HDRC_DEFS_H__
-
-/*
- * HDRC-specific definitions
- */
-
-#define MGC_MAX_USB_ENDS       16
-
-#define MGC_END0_FIFOSIZE      64	/* this is non-configurable */
-
-/*
- *     MUSBMHDRC Register map
- */
-
-/* Common USB registers */
-
-#define MGC_O_HDRC_FADDR	0x00	/* 8-bit */
-#define MGC_O_HDRC_POWER	0x01	/* 8-bit */
-
-#define MGC_O_HDRC_INTRTX	0x02	/* 16-bit */
-#define MGC_O_HDRC_INTRRX       0x04
-#define MGC_O_HDRC_INTRTXE      0x06
-#define MGC_O_HDRC_INTRRXE      0x08
-#define MGC_O_HDRC_INTRUSB      0x0A	/* 8 bit */
-#define MGC_O_HDRC_INTRUSBE     0x0B	/* 8 bit */
-#define MGC_O_HDRC_FRAME        0x0C
-#define MGC_O_HDRC_INDEX        0x0E	/* 8 bit */
-#define MGC_O_HDRC_TESTMODE     0x0F	/* 8 bit */
-
-/* Get offset for a given FIFO from musb->pRegs */
-#ifdef	CONFIG_USB_TUSB6010
-#define MUSB_FIFO_OFFSET(epnum)	(0x200 + ((epnum) * 0x20))
-#else
-#define MUSB_FIFO_OFFSET(epnum)	(0x20 + ((epnum) * 4))
-#endif
-
-/* Additional Control Registers */
-
-#define MGC_O_HDRC_DEVCTL	0x60	/* 8 bit */
-
-/* These are always controlled through the INDEX register */
-#define MGC_O_HDRC_TXFIFOSZ	0x62	/* 8-bit (see masks) */
-#define MGC_O_HDRC_RXFIFOSZ	0x63	/* 8-bit (see masks) */
-#define MGC_O_HDRC_TXFIFOADD	0x64	/* 16-bit offset shifted right 3 */
-#define MGC_O_HDRC_RXFIFOADD	0x66	/* 16-bit offset shifted right 3 */
-
-// vctrl/vstatus:  optional vendor utmi+phy register at 0x68
-#define MGC_O_HDRC_HWVERS	0x6C	/* 8 bit */
-
-#define MGC_O_HDRC_EPINFO	0x78	/* 8 bit */
-#define MGC_O_HDRC_RAMINFO	0x79	/* 8 bit */
-#define MGC_O_HDRC_LINKINFO	0x7a	/* 8 bit */
-#define MGC_O_HDRC_VPLEN	0x7b	/* 8 bit */
-#define MGC_O_HDRC_HS_EOF1	0x7c	/* 8 bit */
-#define MGC_O_HDRC_FS_EOF1	0x7d	/* 8 bit */
-#define MGC_O_HDRC_LS_EOF1	0x7e	/* 8 bit */
-
-/* offsets to endpoint registers */
-#define MGC_O_HDRC_TXMAXP	0x00
-#define MGC_O_HDRC_TXCSR	0x02
-#define MGC_O_HDRC_CSR0		MGC_O_HDRC_TXCSR	/* re-used for EP0 */
-#define MGC_O_HDRC_RXMAXP	0x04
-#define MGC_O_HDRC_RXCSR	0x06
-#define MGC_O_HDRC_RXCOUNT	0x08
-#define MGC_O_HDRC_COUNT0	MGC_O_HDRC_RXCOUNT	/* re-used for EP0 */
-#define MGC_O_HDRC_TXTYPE	0x0A
-#define MGC_O_HDRC_TYPE0	MGC_O_HDRC_TXTYPE	/* re-used for EP0 */
-#define MGC_O_HDRC_TXINTERVAL	0x0B
-#define MGC_O_HDRC_NAKLIMIT0	MGC_O_HDRC_TXINTERVAL	/* re-used for EP0 */
-#define MGC_O_HDRC_RXTYPE	0x0C
-#define MGC_O_HDRC_RXINTERVAL	0x0D
-#define MGC_O_HDRC_FIFOSIZE	0x0F
-#define MGC_O_HDRC_CONFIGDATA	MGC_O_HDRC_FIFOSIZE	/* re-used for EP0 */
-
-/* offsets to endpoint registers in indexed model (using INDEX register) */
-#define MGC_INDEXED_OFFSET(_bEnd, _bOffset)	\
-	(0x10                   + (_bOffset))
-
-/* offsets to endpoint registers in flat models */
-#define MGC_FLAT_OFFSET(_bEnd, _bOffset)	\
-	(0x100 + (0x10*(_bEnd)) + (_bOffset))
-
-#ifdef CONFIG_USB_TUSB6010
-/* TUSB6010 EP0 configuration register is special */
-#define MGC_TUSB_OFFSET(_bEnd, _bOffset)	\
-	(0x10 + _bOffset)
-#include "tusb6010.h"		/* needed "only" for TUSB_EP0_CONF */
-#endif
-
-/* "bus control"/target registers, for host side multipoint (external hubs) */
-#define MGC_O_HDRC_TXFUNCADDR	0x00
-#define MGC_O_HDRC_TXHUBADDR	0x02
-#define MGC_O_HDRC_TXHUBPORT	0x03
-
-#define MGC_O_HDRC_RXFUNCADDR	0x04
-#define MGC_O_HDRC_RXHUBADDR	0x06
-#define MGC_O_HDRC_RXHUBPORT	0x07
-
-#define MGC_BUSCTL_OFFSET(_bEnd, _bOffset) \
-	(0x80 + (8*(_bEnd)) + (_bOffset))
-
-/*
- *     MUSBHDRC Register bit masks
- */
-
-/* POWER */
-
-#define MGC_M_POWER_ISOUPDATE   0x80
-#define MGC_M_POWER_SOFTCONN    0x40
-#define MGC_M_POWER_HSENAB	0x20
-#define MGC_M_POWER_HSMODE	0x10
-#define MGC_M_POWER_RESET       0x08
-#define MGC_M_POWER_RESUME      0x04
-#define MGC_M_POWER_SUSPENDM    0x02
-#define MGC_M_POWER_ENSUSPEND   0x01
-
-/* INTRUSB */
-#define MGC_M_INTR_SUSPEND    0x01
-#define MGC_M_INTR_RESUME     0x02
-#define MGC_M_INTR_RESET      0x04
-#define MGC_M_INTR_BABBLE     0x04
-#define MGC_M_INTR_SOF        0x08
-#define MGC_M_INTR_CONNECT    0x10
-#define MGC_M_INTR_DISCONNECT 0x20
-#define MGC_M_INTR_SESSREQ    0x40
-#define MGC_M_INTR_VBUSERROR  0x80	/* FOR SESSION END */
-
-/* DEVCTL */
-#define MGC_M_DEVCTL_BDEVICE    0x80
-#define MGC_M_DEVCTL_FSDEV      0x40
-#define MGC_M_DEVCTL_LSDEV      0x20
-#define MGC_M_DEVCTL_VBUS       0x18
-#define MGC_S_DEVCTL_VBUS       3
-#define MGC_M_DEVCTL_HM         0x04
-#define MGC_M_DEVCTL_HR         0x02
-#define MGC_M_DEVCTL_SESSION    0x01
-
-/* TESTMODE */
-
-#define MGC_M_TEST_FORCE_HOST   0x80
-#define MGC_M_TEST_FIFO_ACCESS  0x40
-#define MGC_M_TEST_FORCE_FS     0x20
-#define MGC_M_TEST_FORCE_HS     0x10
-#define MGC_M_TEST_PACKET       0x08
-#define MGC_M_TEST_K            0x04
-#define MGC_M_TEST_J            0x02
-#define MGC_M_TEST_SE0_NAK      0x01
-
-/* allocate for double-packet buffering (effectively doubles assigned _SIZE) */
-#define MGC_M_FIFOSZ_DPB	0x10
-/* allocation size (8, 16, 32, ... 4096) */
-#define MGC_M_FIFOSZ_SIZE	0x0f
-
-/* CSR0 */
-#define MGC_M_CSR0_FLUSHFIFO      0x0100
-#define MGC_M_CSR0_TXPKTRDY       0x0002
-#define MGC_M_CSR0_RXPKTRDY       0x0001
-
-/* CSR0 in Peripheral mode */
-#define MGC_M_CSR0_P_SVDSETUPEND  0x0080
-#define MGC_M_CSR0_P_SVDRXPKTRDY  0x0040
-#define MGC_M_CSR0_P_SENDSTALL    0x0020
-#define MGC_M_CSR0_P_SETUPEND     0x0010
-#define MGC_M_CSR0_P_DATAEND      0x0008
-#define MGC_M_CSR0_P_SENTSTALL    0x0004
-
-/* CSR0 in Host mode */
-#define MGC_M_CSR0_H_DIS_PING	0x0800
-#define MGC_M_CSR0_H_WR_DATATOGGLE   0x0400	/* set to allow setting: */
-#define MGC_M_CSR0_H_DATATOGGLE	    0x0200	/* data toggle control */
-#define MGC_M_CSR0_H_NAKTIMEOUT   0x0080
-#define MGC_M_CSR0_H_STATUSPKT    0x0040
-#define MGC_M_CSR0_H_REQPKT       0x0020
-#define MGC_M_CSR0_H_ERROR        0x0010
-#define MGC_M_CSR0_H_SETUPPKT     0x0008
-#define MGC_M_CSR0_H_RXSTALL      0x0004
-
-/* CSR0 bits to avoid zeroing (write zero clears, write 1 ignored) */
-#define MGC_M_CSR0_P_WZC_BITS	\
-	( MGC_M_CSR0_P_SENTSTALL )
-#define MGC_M_CSR0_H_WZC_BITS	\
-	( MGC_M_CSR0_H_NAKTIMEOUT | MGC_M_CSR0_H_RXSTALL \
-	| MGC_M_CSR0_RXPKTRDY )
-
-
-/* TxType/RxType */
-#define MGC_M_TYPE_SPEED	0xc0
-#define MGC_S_TYPE_SPEED	6
-#define MGC_TYPE_SPEED_HIGH	1
-#define MGC_TYPE_SPEED_FULL	2
-#define MGC_TYPE_SPEED_LOW	3
-#define MGC_M_TYPE_PROTO	0x30	/* implicitly zero for ep0 */
-#define MGC_S_TYPE_PROTO	4
-#define MGC_M_TYPE_REMOTE_END	0xf	/* implicitly zero for ep0 */
-
-/* CONFIGDATA */
-
-#define MGC_M_CONFIGDATA_MPRXE      0x80	/* auto bulk pkt combining */
-#define MGC_M_CONFIGDATA_MPTXE      0x40	/* auto bulk pkt splitting */
-#define MGC_M_CONFIGDATA_BIGENDIAN  0x20
-#define MGC_M_CONFIGDATA_HBRXE      0x10	/* HB-ISO for RX */
-#define MGC_M_CONFIGDATA_HBTXE      0x08	/* HB-ISO for TX */
-#define MGC_M_CONFIGDATA_DYNFIFO    0x04	/* dynamic FIFO sizing */
-#define MGC_M_CONFIGDATA_SOFTCONE   0x02	/* SoftConnect */
-#define MGC_M_CONFIGDATA_UTMIDW     0x01	/* data width 0/1 => 8/16bits */
-
-/* TXCSR in Peripheral and Host mode */
-
-#define MGC_M_TXCSR_AUTOSET       0x8000
-#define MGC_M_TXCSR_MODE          0x2000
-#define MGC_M_TXCSR_DMAENAB       0x1000
-#define MGC_M_TXCSR_FRCDATATOG    0x0800
-#define MGC_M_TXCSR_DMAMODE       0x0400
-#define MGC_M_TXCSR_CLRDATATOG    0x0040
-#define MGC_M_TXCSR_FLUSHFIFO     0x0008
-#define MGC_M_TXCSR_FIFONOTEMPTY  0x0002
-#define MGC_M_TXCSR_TXPKTRDY      0x0001
-
-/* TXCSR in Peripheral mode */
-
-#define MGC_M_TXCSR_P_ISO         0x4000
-#define MGC_M_TXCSR_P_INCOMPTX    0x0080
-#define MGC_M_TXCSR_P_SENTSTALL   0x0020
-#define MGC_M_TXCSR_P_SENDSTALL   0x0010
-#define MGC_M_TXCSR_P_UNDERRUN    0x0004
-
-/* TXCSR in Host mode */
-
-#define MGC_M_TXCSR_H_WR_DATATOGGLE   0x0200
-#define MGC_M_TXCSR_H_DATATOGGLE      0x0100
-#define MGC_M_TXCSR_H_NAKTIMEOUT  0x0080
-#define MGC_M_TXCSR_H_RXSTALL     0x0020
-#define MGC_M_TXCSR_H_ERROR       0x0004
-
-/* TXCSR bits to avoid zeroing (write zero clears, write 1 ignored) */
-#define MGC_M_TXCSR_P_WZC_BITS	\
-	( MGC_M_TXCSR_P_INCOMPTX | MGC_M_TXCSR_P_SENTSTALL \
-	| MGC_M_TXCSR_P_UNDERRUN | MGC_M_TXCSR_FIFONOTEMPTY )
-#define MGC_M_TXCSR_H_WZC_BITS	\
-	( MGC_M_TXCSR_H_NAKTIMEOUT | MGC_M_TXCSR_H_RXSTALL \
-	| MGC_M_TXCSR_H_ERROR | MGC_M_TXCSR_FIFONOTEMPTY )
-
-
-/* RXCSR in Peripheral and Host mode */
-
-#define MGC_M_RXCSR_AUTOCLEAR     0x8000
-#define MGC_M_RXCSR_DMAENAB       0x2000
-#define MGC_M_RXCSR_DISNYET       0x1000
-#define MGC_M_RXCSR_PID_ERR       0x1000
-#define MGC_M_RXCSR_DMAMODE       0x0800
-#define MGC_M_RXCSR_INCOMPRX      0x0100
-#define MGC_M_RXCSR_CLRDATATOG    0x0080
-#define MGC_M_RXCSR_FLUSHFIFO     0x0010
-#define MGC_M_RXCSR_DATAERROR     0x0008
-#define MGC_M_RXCSR_FIFOFULL      0x0002
-#define MGC_M_RXCSR_RXPKTRDY      0x0001
-
-/* RXCSR in Peripheral mode */
-
-#define MGC_M_RXCSR_P_ISO         0x4000
-#define MGC_M_RXCSR_P_SENTSTALL   0x0040
-#define MGC_M_RXCSR_P_SENDSTALL   0x0020
-#define MGC_M_RXCSR_P_OVERRUN     0x0004
-
-/* RXCSR in Host mode */
-
-#define MGC_M_RXCSR_H_AUTOREQ     0x4000
-#define MGC_M_RXCSR_H_WR_DATATOGGLE   0x0400
-#define MGC_M_RXCSR_H_DATATOGGLE        0x0200
-#define MGC_M_RXCSR_H_RXSTALL     0x0040
-#define MGC_M_RXCSR_H_REQPKT      0x0020
-#define MGC_M_RXCSR_H_ERROR       0x0004
-
-/* RXCSR bits to avoid zeroing (write zero clears, write 1 ignored) */
-#define MGC_M_RXCSR_P_WZC_BITS	\
-	( MGC_M_RXCSR_P_SENTSTALL | MGC_M_RXCSR_P_OVERRUN \
-	| MGC_M_RXCSR_RXPKTRDY )
-#define MGC_M_RXCSR_H_WZC_BITS	\
-	( MGC_M_RXCSR_H_RXSTALL | MGC_M_RXCSR_H_ERROR \
-	| MGC_M_RXCSR_DATAERROR | MGC_M_RXCSR_RXPKTRDY )
-
-
-/* HUBADDR */
-#define MGC_M_HUBADDR_MULTI_TT		0x80
-
-
-#endif	/* __MUSB_HDRC_DEFS_H__ */
diff -ruN linux-omap-2.6/drivers/usb/musb/musb_host.c maemo_src/drivers/usb/musb/musb_host.c
--- linux-omap-2.6/drivers/usb/musb/musb_host.c	2011-02-06 20:17:25.889999940 -0500
+++ maemo_src/drivers/usb/musb/musb_host.c	2011-02-06 20:12:11.253333274 -0500
@@ -1,36 +1,36 @@
-/******************************************************************
+/*
+ * MUSB OTG driver host support
+ *
  * Copyright 2005 Mentor Graphics Corporation
  * Copyright (C) 2005-2006 by Texas Instruments
- * Copyright (C) 2006 by Nokia Corporation
+ * Copyright (C) 2006-2007 Nokia Corporation
  *
- * This file is part of the Inventra Controller Driver for Linux.
- *
- * The Inventra Controller Driver for Linux is free software; you
- * can redistribute it and/or modify it under the terms of the GNU
- * General Public License version 2 as published by the Free Software
- * Foundation.
- *
- * The Inventra Controller Driver for Linux is distributed in
- * the hope that it will be useful, but WITHOUT ANY WARRANTY;
- * without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
- * License for more details.
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with The Inventra Controller Driver for Linux ; if not,
- * write to the Free Software Foundation, Inc., 59 Temple Place,
- * Suite 330, Boston, MA  02111-1307  USA
- *
- * ANY DOWNLOAD, USE, REPRODUCTION, MODIFICATION OR DISTRIBUTION
- * OF THIS DRIVER INDICATES YOUR COMPLETE AND UNCONDITIONAL ACCEPTANCE
- * OF THOSE TERMS.THIS DRIVER IS PROVIDED "AS IS" AND MENTOR GRAPHICS
- * MAKES NO WARRANTIES, EXPRESS OR IMPLIED, RELATED TO THIS DRIVER.
- * MENTOR GRAPHICS SPECIFICALLY DISCLAIMS ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY; FITNESS FOR A PARTICULAR PURPOSE AND
- * NON-INFRINGEMENT.  MENTOR GRAPHICS DOES NOT PROVIDE SUPPORT
- * SERVICES OR UPDATES FOR THIS DRIVER, EVEN IF YOU ARE A MENTOR
- * GRAPHICS SUPPORT CUSTOMER.
- ******************************************************************/
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -41,7 +41,7 @@
 #include <linux/init.h>
 #include <linux/list.h>
 
-#include "musbdefs.h"
+#include "musb_core.h"
 #include "musb_host.h"
 
 
@@ -72,7 +72,7 @@
  *
  * - Not tested with HNP, but some SRP paths seem to behave.
  *
- * NOTE 24-August:
+ * NOTE 24-August-2006:
  *
  * - Bulk traffic finally uses both sides of hardware ep1, freeing up an
  *   extra endpoint for periodic use enabling hub + keybd + mouse.  That
@@ -101,11 +101,9 @@
  */
 
 
-/*************************** Forwards ***************************/
-
-static void musb_ep_program(struct musb *pThis, u8 bEnd,
-			struct urb *pUrb, unsigned int nOut,
-			u8 * pBuffer, u32 dwLength);
+static void musb_ep_program(struct musb *musb, u8 epnum,
+			struct urb *urb, unsigned int nOut,
+			u8 *buf, u32 len);
 
 /*
  * Clear TX fifo. Needed to avoid BABBLE errors.
@@ -116,12 +114,12 @@
 	u16		csr;
 	int		retries = 1000;
 
-	csr = musb_readw(epio, MGC_O_HDRC_TXCSR);
-	while (csr & MGC_M_TXCSR_FIFONOTEMPTY) {
+	csr = musb_readw(epio, MUSB_TXCSR);
+	while (csr & MUSB_TXCSR_FIFONOTEMPTY) {
 		DBG(5, "Host TX FIFONOTEMPTY csr: %02x\n", csr);
-		csr |= MGC_M_TXCSR_FLUSHFIFO;
-		musb_writew(epio, MGC_O_HDRC_TXCSR, csr);
-		csr = musb_readw(epio, MGC_O_HDRC_TXCSR);
+		csr |= MUSB_TXCSR_FLUSHFIFO;
+		musb_writew(epio, MUSB_TXCSR, csr);
+		csr = musb_readw(epio, MUSB_TXCSR);
 		if (retries-- < 1) {
 			ERR("Could not flush host TX fifo: csr: %04x\n", csr);
 			return;
@@ -132,20 +130,20 @@
 
 /*
  * Start transmit. Caller is responsible for locking shared resources.
- * pThis must be locked.
+ * musb must be locked.
  */
 static inline void musb_h_tx_start(struct musb_hw_ep *ep)
 {
 	u16	txcsr;
 
 	/* NOTE: no locks here; caller should lock and select EP */
-	if (ep->bLocalEnd) {
-		txcsr = musb_readw(ep->regs, MGC_O_HDRC_TXCSR);
-		txcsr |= MGC_M_TXCSR_TXPKTRDY | MGC_M_TXCSR_H_WZC_BITS;
-		musb_writew(ep->regs, MGC_O_HDRC_TXCSR, txcsr);
+	if (ep->epnum) {
+		txcsr = musb_readw(ep->regs, MUSB_TXCSR);
+		txcsr |= MUSB_TXCSR_TXPKTRDY | MUSB_TXCSR_H_WZC_BITS;
+		musb_writew(ep->regs, MUSB_TXCSR, txcsr);
 	} else {
-		txcsr = MGC_M_CSR0_H_SETUPPKT | MGC_M_CSR0_TXPKTRDY;
-		musb_writew(ep->regs, MGC_O_HDRC_CSR0, txcsr);
+		txcsr = MUSB_CSR0_H_SETUPPKT | MUSB_CSR0_TXPKTRDY;
+		musb_writew(ep->regs, MUSB_CSR0, txcsr);
 	}
 
 }
@@ -155,9 +153,9 @@
 	u16	txcsr;
 
 	/* NOTE: no locks here; caller should lock and select EP */
-	txcsr = musb_readw(ep->regs, MGC_O_HDRC_TXCSR);
-	txcsr |= MGC_M_TXCSR_DMAENAB | MGC_M_TXCSR_H_WZC_BITS;
-	musb_writew(ep->regs, MGC_O_HDRC_TXCSR, txcsr);
+	txcsr = musb_readw(ep->regs, MUSB_TXCSR);
+	txcsr |= MUSB_TXCSR_DMAENAB | MUSB_TXCSR_H_WZC_BITS;
+	musb_writew(ep->regs, MUSB_TXCSR, txcsr);
 }
 
 /*
@@ -169,15 +167,15 @@
 static void
 musb_start_urb(struct musb *musb, int is_in, struct musb_qh *qh)
 {
-	u16			wFrame;
-	u32			dwLength;
-	void			*pBuffer;
-	void __iomem		*pBase =  musb->pRegs;
+	u16			frame;
+	u32			len;
+	void			*buf;
+	void __iomem		*mbase =  musb->mregs;
 	struct urb		*urb = next_urb(qh);
-	struct musb_hw_ep	*pEnd = qh->hw_ep;
-	unsigned		nPipe = urb->pipe;
-	u8			bAddress = usb_pipedevice(nPipe);
-	int			bEnd = pEnd->bLocalEnd;
+	struct musb_hw_ep	*hw_ep = qh->hw_ep;
+	unsigned		pipe = urb->pipe;
+	u8			address = usb_pipedevice(pipe);
+	int			epnum = hw_ep->epnum;
 
 	/* initialize software qh state */
 	qh->offset = 0;
@@ -188,39 +186,39 @@
 	case USB_ENDPOINT_XFER_CONTROL:
 		/* control transfers always start with SETUP */
 		is_in = 0;
-		pEnd->out_qh = qh;
-		musb->bEnd0Stage = MGC_END0_START;
-		pBuffer = urb->setup_packet;
-		dwLength = 8;
+		hw_ep->out_qh = qh;
+		musb->ep0_stage = MUSB_EP0_START;
+		buf = urb->setup_packet;
+		len = 8;
 		break;
 	case USB_ENDPOINT_XFER_ISOC:
 		qh->iso_idx = 0;
 		qh->frame = 0;
-		pBuffer = urb->transfer_buffer + urb->iso_frame_desc[0].offset;
-		dwLength = urb->iso_frame_desc[0].length;
+		buf = urb->transfer_buffer + urb->iso_frame_desc[0].offset;
+		len = urb->iso_frame_desc[0].length;
 		break;
 	default:		/* bulk, interrupt */
-		pBuffer = urb->transfer_buffer;
-		dwLength = urb->transfer_buffer_length;
+		buf = urb->transfer_buffer;
+		len = urb->transfer_buffer_length;
 	}
 
 	DBG(4, "qh %p urb %p dev%d ep%d%s%s, hw_ep %d, %p/%d\n",
-			qh, urb, bAddress, qh->epnum,
+			qh, urb, address, qh->epnum,
 			is_in ? "in" : "out",
 			({char *s; switch (qh->type) {
 			case USB_ENDPOINT_XFER_CONTROL:	s = ""; break;
 			case USB_ENDPOINT_XFER_BULK:	s = "-bulk"; break;
 			case USB_ENDPOINT_XFER_ISOC:	s = "-iso"; break;
 			default:			s = "-intr"; break;
-			}; s;}),
-			bEnd, pBuffer, dwLength);
+			}; s; }),
+			epnum, buf, len);
 
 	/* Configure endpoint */
-	if (is_in || pEnd->bIsSharedFifo)
-		pEnd->in_qh = qh;
+	if (is_in || hw_ep->is_shared_fifo)
+		hw_ep->in_qh = qh;
 	else
-		pEnd->out_qh = qh;
-	musb_ep_program(musb, bEnd, urb, !is_in, pBuffer, dwLength);
+		hw_ep->out_qh = qh;
+	musb_ep_program(musb, epnum, urb, !is_in, buf, len);
 
 	/* transmit may have more work: start it when it is time */
 	if (is_in)
@@ -232,12 +230,12 @@
 	case USB_ENDPOINT_XFER_INT:
 		DBG(3, "check whether there's still time for periodic Tx\n");
 		qh->iso_idx = 0;
-		wFrame = musb_readw(pBase, MGC_O_HDRC_FRAME);
+		frame = musb_readw(mbase, MUSB_FRAME);
 		/* FIXME this doesn't implement that scheduling policy ...
 		 * or handle framecounter wrapping
 		 */
 		if ((urb->transfer_flags & URB_ISO_ASAP)
-				|| (wFrame >= urb->start_frame)) {
+				|| (frame >= urb->start_frame)) {
 			/* REVISIT the SOF irq handler shouldn't duplicate
 			 * this code; and we don't init urb->start_frame...
 			 */
@@ -246,29 +244,29 @@
 		} else {
 			qh->frame = urb->start_frame;
 			/* enable SOF interrupt so we can count down */
-DBG(1,"SOF for %d\n", bEnd);
-#if 1 // ifndef	CONFIG_ARCH_DAVINCI
-			musb_writeb(pBase, MGC_O_HDRC_INTRUSBE, 0xff);
+			DBG(1, "SOF for %d\n", epnum);
+#if 1 /* ifndef	CONFIG_ARCH_DAVINCI */
+			musb_writeb(mbase, MUSB_INTRUSBE, 0xff);
 #endif
 		}
 		break;
 	default:
 start:
-		DBG(4, "Start TX%d %s\n", bEnd,
-			pEnd->tx_channel ? "dma" : "pio");
+		DBG(4, "Start TX%d %s\n", epnum,
+			hw_ep->tx_channel ? "dma" : "pio");
 
-		if (!pEnd->tx_channel)
-			musb_h_tx_start(pEnd);
+		if (!hw_ep->tx_channel)
+			musb_h_tx_start(hw_ep);
 		else if (is_cppi_enabled() || tusb_dma_omap())
-			cppi_host_txdma_start(pEnd);
+			cppi_host_txdma_start(hw_ep);
 	}
 }
 
 /* caller owns controller lock, irqs are blocked */
 static void
 __musb_giveback(struct musb *musb, struct urb *urb, int status)
-__releases(musb->Lock)
-__acquires(musb->Lock)
+__releases(musb->lock)
+__acquires(musb->lock)
 {
 	if ((urb->transfer_flags & URB_SHORT_NOT_OK)
 			&& (urb->actual_length < urb->transfer_buffer_length)
@@ -305,13 +303,14 @@
 			urb->actual_length, urb->transfer_buffer_length
 			);
 
-	spin_unlock(&musb->Lock);
+	spin_unlock(&musb->lock);
 	usb_hcd_giveback_urb(musb_to_hcd(musb), urb);
-	spin_lock(&musb->Lock);
+	spin_lock(&musb->lock);
 }
 
 /* for bulk/interrupt endpoints only */
-static inline void musb_save_toggle(struct musb_hw_ep *ep, int is_in, struct urb *urb)
+static inline void
+musb_save_toggle(struct musb_hw_ep *ep, int is_in, struct urb *urb)
 {
 	struct usb_device	*udev = urb->dev;
 	u16			csr;
@@ -322,20 +321,20 @@
 	 * problems getting toggle correct.
 	 */
 
-	if (is_in || ep->bIsSharedFifo)
+	if (is_in || ep->is_shared_fifo)
 		qh = ep->in_qh;
 	else
 		qh = ep->out_qh;
 
 	if (!is_in) {
-		csr = musb_readw(epio, MGC_O_HDRC_TXCSR);
+		csr = musb_readw(epio, MUSB_TXCSR);
 		usb_settoggle(udev, qh->epnum, 1,
-			(csr & MGC_M_TXCSR_H_DATATOGGLE)
+			(csr & MUSB_TXCSR_H_DATATOGGLE)
 				? 1 : 0);
 	} else {
-		csr = musb_readw(epio, MGC_O_HDRC_RXCSR);
+		csr = musb_readw(epio, MUSB_RXCSR);
 		usb_settoggle(udev, qh->epnum, 0,
-			(csr & MGC_M_RXCSR_H_DATATOGGLE)
+			(csr & MUSB_RXCSR_H_DATATOGGLE)
 				? 1 : 0);
 	}
 }
@@ -349,7 +348,7 @@
 	struct musb		*musb = ep->musb;
 	int			ready = qh->is_ready;
 
-	if (ep->bIsSharedFifo)
+	if (ep->is_shared_fifo)
 		is_in = 1;
 	else
 		is_in = usb_pipein(urb->pipe);
@@ -382,7 +381,7 @@
 			ep->tx_reinit = 1;
 
 		/* clobber old pointers to this qh */
-		if (is_in || ep->bIsSharedFifo)
+		if (is_in || ep->is_shared_fifo)
 			ep->in_qh = NULL;
 		else
 			ep->out_qh = NULL;
@@ -396,7 +395,7 @@
 			 * de-allocated if it's tracked and allocated;
 			 * and where we'd update the schedule tree...
 			 */
-			musb->periodic[ep->bLocalEnd] = NULL;
+			musb->periodic[ep->epnum] = NULL;
 			kfree(qh);
 			qh = NULL;
 			break;
@@ -424,37 +423,22 @@
  * Context: caller owns controller lock, irqs are blocked
  */
 static void
-musb_advance_schedule(struct musb *pThis, struct urb *urb,
-		struct musb_hw_ep *pEnd, int is_in)
+musb_advance_schedule(struct musb *musb, struct urb *urb,
+		struct musb_hw_ep *hw_ep, int is_in)
 {
 	struct musb_qh	*qh;
 
-	if (is_in || pEnd->bIsSharedFifo)
-		qh = pEnd->in_qh;
+	if (is_in || hw_ep->is_shared_fifo)
+		qh = hw_ep->in_qh;
 	else
-		qh = pEnd->out_qh;
+		qh = hw_ep->out_qh;
 	qh = musb_giveback(qh, urb, 0);
 
-#ifdef CONFIG_USB_INVENTRA_DMA
-	/* REVISIT udelay reportedly works around issues in unmodified
-	 * Mentor RTL before v1.5, where it doesn't disable the pull-up
-	 * resisters in high speed mode.  That causes signal reflection
-	 * and errors because inter packet IDLE time vanishes.
-	 *
-	 * Yes, this delay makes DMA-OUT a bit slower than PIO.  But
-	 * without it, some devices are unusable.  But there seem to be
-	 * other issues too, at least on DaVinci; the delay improves
-	 * some full speed cases, and being DMA-coupled is strange...
-	 */
-	if (is_dma_capable() && !is_in && pEnd->tx_channel)
-		udelay(15);	/* 10 usec ~= 1x 512byte packet */
-#endif
-
 	if (qh && qh->is_ready && !list_empty(&qh->hep->urb_list)) {
 		DBG(4, "... next ep%d %cX urb %p\n",
-				pEnd->bLocalEnd, is_in ? 'R' : 'T',
+				hw_ep->epnum, is_in ? 'R' : 'T',
 				next_urb(qh));
-		musb_start_urb(pThis, is_in, qh);
+		musb_start_urb(musb, is_in, qh);
 	}
 }
 
@@ -464,111 +448,113 @@
 	 * ignore dma (various models),
 	 * leave toggle alone (may not have been saved yet)
 	 */
-	csr |= MGC_M_RXCSR_FLUSHFIFO | MGC_M_RXCSR_RXPKTRDY;
-	csr &= ~( MGC_M_RXCSR_H_REQPKT
-		| MGC_M_RXCSR_H_AUTOREQ
-		| MGC_M_RXCSR_AUTOCLEAR
-		);
+	csr |= MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_RXPKTRDY;
+	csr &= ~(MUSB_RXCSR_H_REQPKT
+		| MUSB_RXCSR_H_AUTOREQ
+		| MUSB_RXCSR_AUTOCLEAR);
 
 	/* write 2x to allow double buffering */
-	musb_writew(hw_ep->regs, MGC_O_HDRC_RXCSR, csr);
-	musb_writew(hw_ep->regs, MGC_O_HDRC_RXCSR, csr);
+	musb_writew(hw_ep->regs, MUSB_RXCSR, csr);
+	musb_writew(hw_ep->regs, MUSB_RXCSR, csr);
 
 	/* flush writebuffer */
-	return musb_readw(hw_ep->regs, MGC_O_HDRC_RXCSR);
+	return musb_readw(hw_ep->regs, MUSB_RXCSR);
 }
 
 /*
  * PIO RX for a packet (or part of it).
  */
-static u8 musb_host_packet_rx(struct musb *pThis, struct urb *pUrb,
-		u8 bEnd, u8 bIsochError)
+static bool
+musb_host_packet_rx(struct musb *musb, struct urb *urb, u8 epnum, u8 iso_err)
 {
-	u16 wRxCount;
-	u8 *pBuffer;
-	u16 wCsr;
-	u8 bDone = FALSE;
+	u16			rx_count;
+	u8			*buf;
+	u16			csr;
+	bool			done = false;
 	u32			length;
 	int			do_flush = 0;
-	struct musb_hw_ep	*pEnd = pThis->aLocalEnd + bEnd;
-	void __iomem		*epio = pEnd->regs;
-	struct musb_qh		*qh = pEnd->in_qh;
-	int			nPipe = pUrb->pipe;
-	void			*buffer = pUrb->transfer_buffer;
-
-	// MGC_SelectEnd(pBase, bEnd);
-	wRxCount = musb_readw(epio, MGC_O_HDRC_RXCOUNT);
+	struct musb_hw_ep	*hw_ep = musb->endpoints + epnum;
+	void __iomem		*epio = hw_ep->regs;
+	struct musb_qh		*qh = hw_ep->in_qh;
+	int			pipe = urb->pipe;
+	void			*buffer = urb->transfer_buffer;
+
+	/* musb_ep_select(mbase, epnum); */
+	rx_count = musb_readw(epio, MUSB_RXCOUNT);
+	DBG(3, "RX%d count %d, buffer %p len %d/%d\n", epnum, rx_count,
+			urb->transfer_buffer, qh->offset,
+			urb->transfer_buffer_length);
 
 	/* unload FIFO */
-	if (usb_pipeisoc(nPipe)) {
+	if (usb_pipeisoc(pipe)) {
 		int					status = 0;
 		struct usb_iso_packet_descriptor	*d;
 
-		if (bIsochError) {
+		if (iso_err) {
 			status = -EILSEQ;
-			pUrb->error_count++;
+			urb->error_count++;
 		}
 
-		d = pUrb->iso_frame_desc + qh->iso_idx;
-		pBuffer = buffer + d->offset;
+		d = urb->iso_frame_desc + qh->iso_idx;
+		buf = buffer + d->offset;
 		length = d->length;
-		if (wRxCount > length) {
+		if (rx_count > length) {
 			if (status == 0) {
 				status = -EOVERFLOW;
-				pUrb->error_count++;
+				urb->error_count++;
 			}
-			DBG(2, "** OVERFLOW %d into %d\n", wRxCount, length);
+			DBG(2, "** OVERFLOW %d into %d\n", rx_count, length);
 			do_flush = 1;
 		} else
-			length = wRxCount;
-		pUrb->actual_length += length;
+			length = rx_count;
+		urb->actual_length += length;
 		d->actual_length = length;
 
 		d->status = status;
 
 		/* see if we are done */
-		bDone = (++qh->iso_idx >= pUrb->number_of_packets);
+		done = (++qh->iso_idx >= urb->number_of_packets);
 	} else {
 		/* non-isoch */
-		pBuffer = buffer + qh->offset;
-		length = pUrb->transfer_buffer_length - qh->offset;
-		if (wRxCount > length) {
-			if (pUrb->status == -EINPROGRESS)
-				pUrb->status = -EOVERFLOW;
-			DBG(2, "** OVERFLOW %d into %d\n", wRxCount, length);
+		buf = buffer + qh->offset;
+		length = urb->transfer_buffer_length - qh->offset;
+		if (rx_count > length) {
+			if (urb->status == -EINPROGRESS)
+				urb->status = -EOVERFLOW;
+			DBG(2, "** OVERFLOW %d into %d\n", rx_count, length);
 			do_flush = 1;
 		} else
-			length = wRxCount;
-		pUrb->actual_length += length;
+			length = rx_count;
+		urb->actual_length += length;
 		qh->offset += length;
 
 		/* see if we are done */
-		bDone = (pUrb->actual_length == pUrb->transfer_buffer_length)
-			|| (wRxCount < qh->maxpacket)
-			|| (pUrb->status != -EINPROGRESS);
-		if (bDone
-				&& (pUrb->status == -EINPROGRESS)
-				&& (pUrb->transfer_flags & URB_SHORT_NOT_OK)
-				&& (pUrb->actual_length
-					< pUrb->transfer_buffer_length))
-			pUrb->status = -EREMOTEIO;
+		done = (urb->actual_length == urb->transfer_buffer_length)
+			|| (rx_count < qh->maxpacket)
+			|| (urb->status != -EINPROGRESS);
+		if (done
+				&& (urb->status == -EINPROGRESS)
+				&& (urb->transfer_flags & URB_SHORT_NOT_OK)
+				&& (urb->actual_length
+					< urb->transfer_buffer_length))
+			urb->status = -EREMOTEIO;
 	}
 
-	musb_read_fifo(pEnd, length, pBuffer);
+	musb_read_fifo(hw_ep, length, buf);
 
-	wCsr = musb_readw(epio, MGC_O_HDRC_RXCSR);
-	wCsr |= MGC_M_RXCSR_H_WZC_BITS;
+	csr = musb_readw(epio, MUSB_RXCSR);
+	csr |= MUSB_RXCSR_H_WZC_BITS;
 	if (unlikely(do_flush))
-		musb_h_flush_rxfifo(pEnd, wCsr);
+		musb_h_flush_rxfifo(hw_ep, csr);
 	else {
 		/* REVISIT this assumes AUTOCLEAR is never set */
-		wCsr &= ~(MGC_M_RXCSR_RXPKTRDY | MGC_M_RXCSR_H_REQPKT);
-		if (!bDone)
-			wCsr |= MGC_M_RXCSR_H_REQPKT;
-		musb_writew(epio, MGC_O_HDRC_RXCSR, wCsr);
+		csr &= ~(MUSB_RXCSR_RXPKTRDY | MUSB_RXCSR_H_REQPKT);
+		if (!done)
+			csr |= MUSB_RXCSR_H_REQPKT;
+		musb_writew(epio, MUSB_RXCSR, csr);
 	}
 
-	return bDone;
+	return done;
 }
 
 /* we don't always need to reinit a given side of an endpoint...
@@ -590,42 +576,42 @@
 	 */
 
 	/* if programmed for Tx, put it in RX mode */
-	if (ep->bIsSharedFifo) {
-		csr = musb_readw(ep->regs, MGC_O_HDRC_TXCSR);
-		if (csr & MGC_M_TXCSR_MODE) {
+	if (ep->is_shared_fifo) {
+		csr = musb_readw(ep->regs, MUSB_TXCSR);
+		if (csr & MUSB_TXCSR_MODE) {
 			musb_h_tx_flush_fifo(ep);
-			musb_writew(ep->regs, MGC_O_HDRC_TXCSR,
-					MGC_M_TXCSR_FRCDATATOG);
+			musb_writew(ep->regs, MUSB_TXCSR,
+					MUSB_TXCSR_FRCDATATOG);
 		}
 		/* clear mode (and everything else) to enable Rx */
-		musb_writew(ep->regs, MGC_O_HDRC_TXCSR, 0);
+		musb_writew(ep->regs, MUSB_TXCSR, 0);
 
 	/* scrub all previous state, clearing toggle */
 	} else {
-		csr = musb_readw(ep->regs, MGC_O_HDRC_RXCSR);
-		if (csr & MGC_M_RXCSR_RXPKTRDY)
-			WARN("rx%d, packet/%d ready?\n", ep->bLocalEnd,
-				musb_readw(ep->regs, MGC_O_HDRC_RXCOUNT));
+		csr = musb_readw(ep->regs, MUSB_RXCSR);
+		if (csr & MUSB_RXCSR_RXPKTRDY)
+			WARN("rx%d, packet/%d ready?\n", ep->epnum,
+				musb_readw(ep->regs, MUSB_RXCOUNT));
 
-		musb_h_flush_rxfifo(ep, MGC_M_RXCSR_CLRDATATOG);
+		musb_h_flush_rxfifo(ep, MUSB_RXCSR_CLRDATATOG);
 	}
 
 	/* target addr and (for multipoint) hub addr/port */
-	if (musb->bIsMultipoint) {
-		musb_writeb(ep->target_regs, MGC_O_HDRC_RXFUNCADDR,
+	if (musb->is_multipoint) {
+		musb_writeb(ep->target_regs, MUSB_RXFUNCADDR,
 			qh->addr_reg);
-		musb_writeb(ep->target_regs, MGC_O_HDRC_RXHUBADDR,
+		musb_writeb(ep->target_regs, MUSB_RXHUBADDR,
 			qh->h_addr_reg);
-		musb_writeb(ep->target_regs, MGC_O_HDRC_RXHUBPORT,
+		musb_writeb(ep->target_regs, MUSB_RXHUBPORT,
 			qh->h_port_reg);
 	} else
-		musb_writeb(musb->pRegs, MGC_O_HDRC_FADDR, qh->addr_reg);
+		musb_writeb(musb->mregs, MUSB_FADDR, qh->addr_reg);
 
 	/* protocol/endpoint, interval/NAKlimit, i/o size */
-	musb_writeb(ep->regs, MGC_O_HDRC_RXTYPE, qh->type_reg);
-	musb_writeb(ep->regs, MGC_O_HDRC_RXINTERVAL, qh->intv_reg);
+	musb_writeb(ep->regs, MUSB_RXTYPE, qh->type_reg);
+	musb_writeb(ep->regs, MUSB_RXINTERVAL, qh->intv_reg);
 	/* NOTE: bulk combining rewrites high bits of maxpacket */
-	musb_writew(ep->regs, MGC_O_HDRC_RXMAXP, qh->maxpacket);
+	musb_writew(ep->regs, MUSB_RXMAXP, qh->maxpacket);
 
 	ep->rx_reinit = 0;
 }
@@ -635,225 +621,223 @@
  * Program an HDRC endpoint as per the given URB
  * Context: irqs blocked, controller lock held
  */
-static void musb_ep_program(struct musb *pThis, u8 bEnd,
-			struct urb *pUrb, unsigned int is_out,
-			u8 * pBuffer, u32 dwLength)
-{
-	struct dma_controller	*pDmaController;
-	struct dma_channel	*pDmaChannel;
-	u8			bDmaOk;
-	void __iomem		*pBase = pThis->pRegs;
-	struct musb_hw_ep	*pEnd = pThis->aLocalEnd + bEnd;
-	void __iomem		*epio = pEnd->regs;
+static void musb_ep_program(struct musb *musb, u8 epnum,
+			struct urb *urb, unsigned int is_out,
+			u8 *buf, u32 len)
+{
+	struct dma_controller	*dma_controller;
+	struct dma_channel	*dma_channel;
+	u8			dma_ok;
+	void __iomem		*mbase = musb->mregs;
+	struct musb_hw_ep	*hw_ep = musb->endpoints + epnum;
+	void __iomem		*epio = hw_ep->regs;
 	struct musb_qh		*qh;
-	u16			wPacketSize;
+	u16			packet_sz;
 
-	if (!is_out || pEnd->bIsSharedFifo)
-		qh = pEnd->in_qh;
+	if (!is_out || hw_ep->is_shared_fifo)
+		qh = hw_ep->in_qh;
 	else
-		qh = pEnd->out_qh;
+		qh = hw_ep->out_qh;
 
-	wPacketSize = qh->maxpacket;
+	packet_sz = qh->maxpacket;
 
 	DBG(3, "%s hw%d urb %p spd%d dev%d ep%d%s "
 				"h_addr%02x h_port%02x bytes %d\n",
 			is_out ? "-->" : "<--",
-			bEnd, pUrb, pUrb->dev->speed,
+			epnum, urb, urb->dev->speed,
 			qh->addr_reg, qh->epnum, is_out ? "out" : "in",
 			qh->h_addr_reg, qh->h_port_reg,
-			dwLength);
+			len);
 
-	MGC_SelectEnd(pBase, bEnd);
+	musb_ep_select(mbase, epnum);
 
 	/* candidate for DMA? */
-	pDmaController = pThis->pDmaController;
-	if (is_dma_capable() && bEnd && pDmaController) {
-		pDmaChannel = is_out ? pEnd->tx_channel : pEnd->rx_channel;
-		if (!pDmaChannel) {
-			pDmaChannel = pDmaController->channel_alloc(
-					pDmaController, pEnd, is_out);
+	dma_controller = musb->dma_controller;
+	if (is_dma_capable() && epnum && dma_controller) {
+		dma_channel = is_out ? hw_ep->tx_channel : hw_ep->rx_channel;
+		if (!dma_channel) {
+			dma_channel = dma_controller->channel_alloc(
+					dma_controller, hw_ep, is_out);
 			if (is_out)
-				pEnd->tx_channel = pDmaChannel;
+				hw_ep->tx_channel = dma_channel;
 			else
-				pEnd->rx_channel = pDmaChannel;
+				hw_ep->rx_channel = dma_channel;
 		}
 	} else
-		pDmaChannel = NULL;
+		dma_channel = NULL;
 
 	/* make sure we clear DMAEnab, autoSet bits from previous run */
 
 	/* OUT/transmit/EP0 or IN/receive? */
 	if (is_out) {
-		u16	wCsr;
-		u16	wIntrTxE;
-		u16	wLoadCount;
+		u16	csr;
+		u16	int_txe;
+		u16	load_count;
 
-		wCsr = musb_readw(epio, MGC_O_HDRC_TXCSR);
+		csr = musb_readw(epio, MUSB_TXCSR);
 
 		/* disable interrupt in case we flush */
-		wIntrTxE = musb_readw(pBase, MGC_O_HDRC_INTRTXE);
-		musb_writew(pBase, MGC_O_HDRC_INTRTXE, wIntrTxE & ~(1 << bEnd));
+		int_txe = musb_readw(mbase, MUSB_INTRTXE);
+		musb_writew(mbase, MUSB_INTRTXE, int_txe & ~(1 << epnum));
 
 		/* general endpoint setup */
-		if (bEnd) {
-			u16	csr = wCsr;
-
+		if (epnum) {
 			/* ASSERT:  TXCSR_DMAENAB was already cleared */
 
 			/* flush all old state, set default */
-			musb_h_tx_flush_fifo(pEnd);
-			csr &= ~(MGC_M_TXCSR_H_NAKTIMEOUT
-					| MGC_M_TXCSR_DMAMODE
-					| MGC_M_TXCSR_FRCDATATOG
-					| MGC_M_TXCSR_H_RXSTALL
-					| MGC_M_TXCSR_H_ERROR
-					| MGC_M_TXCSR_TXPKTRDY
+			musb_h_tx_flush_fifo(hw_ep);
+			csr &= ~(MUSB_TXCSR_H_NAKTIMEOUT
+					| MUSB_TXCSR_DMAMODE
+					| MUSB_TXCSR_FRCDATATOG
+					| MUSB_TXCSR_H_RXSTALL
+					| MUSB_TXCSR_H_ERROR
+					| MUSB_TXCSR_TXPKTRDY
 					);
-			csr |= MGC_M_TXCSR_MODE;
+			csr |= MUSB_TXCSR_MODE;
 
-			if (usb_gettoggle(pUrb->dev,
+			if (usb_gettoggle(urb->dev,
 					qh->epnum, 1))
-				csr |= MGC_M_TXCSR_H_WR_DATATOGGLE
-					| MGC_M_TXCSR_H_DATATOGGLE;
+				csr |= MUSB_TXCSR_H_WR_DATATOGGLE
+					| MUSB_TXCSR_H_DATATOGGLE;
 			else
-				csr |= MGC_M_TXCSR_CLRDATATOG;
+				csr |= MUSB_TXCSR_CLRDATATOG;
 
 			/* twice in case of double packet buffering */
-			musb_writew(epio, MGC_O_HDRC_TXCSR, csr);
+			musb_writew(epio, MUSB_TXCSR, csr);
 			/* REVISIT may need to clear FLUSHFIFO ... */
-			musb_writew(epio, MGC_O_HDRC_TXCSR, csr);
-			wCsr = musb_readw(epio, MGC_O_HDRC_TXCSR);
+			musb_writew(epio, MUSB_TXCSR, csr);
+			csr = musb_readw(epio, MUSB_TXCSR);
 		} else {
 			/* endpoint 0: just flush */
-			musb_writew(epio, MGC_O_HDRC_CSR0,
-				wCsr | MGC_M_CSR0_FLUSHFIFO);
-			musb_writew(epio, MGC_O_HDRC_CSR0,
-				wCsr | MGC_M_CSR0_FLUSHFIFO);
+			musb_writew(epio, MUSB_CSR0,
+				csr | MUSB_CSR0_FLUSHFIFO);
+			musb_writew(epio, MUSB_CSR0,
+				csr | MUSB_CSR0_FLUSHFIFO);
 		}
 
 		/* target addr and (for multipoint) hub addr/port */
-		if (pThis->bIsMultipoint) {
-			musb_writeb(pBase,
-				MGC_BUSCTL_OFFSET(bEnd, MGC_O_HDRC_TXFUNCADDR),
+		if (musb->is_multipoint) {
+			musb_writeb(mbase,
+				MUSB_BUSCTL_OFFSET(epnum, MUSB_TXFUNCADDR),
 				qh->addr_reg);
-			musb_writeb(pBase,
-				MGC_BUSCTL_OFFSET(bEnd, MGC_O_HDRC_TXHUBADDR),
+			musb_writeb(mbase,
+				MUSB_BUSCTL_OFFSET(epnum, MUSB_TXHUBADDR),
 				qh->h_addr_reg);
-			musb_writeb(pBase,
-				MGC_BUSCTL_OFFSET(bEnd, MGC_O_HDRC_TXHUBPORT),
+			musb_writeb(mbase,
+				MUSB_BUSCTL_OFFSET(epnum, MUSB_TXHUBPORT),
 				qh->h_port_reg);
-/* FIXME if !bEnd, do the same for RX ... */
+/* FIXME if !epnum, do the same for RX ... */
 		} else
-			musb_writeb(pBase, MGC_O_HDRC_FADDR, qh->addr_reg);
+			musb_writeb(mbase, MUSB_FADDR, qh->addr_reg);
 
 		/* protocol/endpoint/interval/NAKlimit */
-		if (bEnd) {
-			musb_writeb(epio, MGC_O_HDRC_TXTYPE, qh->type_reg);
-			if (can_bulk_split(pThis, qh->type))
-				musb_writew(epio, MGC_O_HDRC_TXMAXP,
-					wPacketSize
-					| ((pEnd->wMaxPacketSizeTx /
-						wPacketSize) - 1) << 11);
+		if (epnum) {
+			musb_writeb(epio, MUSB_TXTYPE, qh->type_reg);
+			if (can_bulk_split(musb, qh->type))
+				musb_writew(epio, MUSB_TXMAXP,
+					packet_sz
+					| ((hw_ep->max_packet_sz_tx /
+						packet_sz) - 1) << 11);
 			else
-				musb_writew(epio, MGC_O_HDRC_TXMAXP,
-					wPacketSize);
-			musb_writeb(epio, MGC_O_HDRC_TXINTERVAL, qh->intv_reg);
+				musb_writew(epio, MUSB_TXMAXP,
+					packet_sz);
+			musb_writeb(epio, MUSB_TXINTERVAL, qh->intv_reg);
 		} else {
-			musb_writeb(epio, MGC_O_HDRC_NAKLIMIT0, qh->intv_reg);
-			if (pThis->bIsMultipoint)
-				musb_writeb(epio, MGC_O_HDRC_TYPE0,
+			musb_writeb(epio, MUSB_NAKLIMIT0, qh->intv_reg);
+			if (musb->is_multipoint)
+				musb_writeb(epio, MUSB_TYPE0,
 						qh->type_reg);
 		}
 
-		if (can_bulk_split(pThis, qh->type))
-			wLoadCount = min((u32) pEnd->wMaxPacketSizeTx,
-						dwLength);
+		if (can_bulk_split(musb, qh->type))
+			load_count = min((u32) hw_ep->max_packet_sz_tx,
+						len);
 		else
-			wLoadCount = min((u32) wPacketSize, dwLength);
+			load_count = min((u32) packet_sz, len);
 
 #ifdef CONFIG_USB_INVENTRA_DMA
-		if (pDmaChannel) {
+		if (dma_channel) {
 
 			/* clear previous state */
-			wCsr = musb_readw(epio, MGC_O_HDRC_TXCSR);
-			wCsr &= ~(MGC_M_TXCSR_AUTOSET
-				| MGC_M_TXCSR_DMAMODE
-				| MGC_M_TXCSR_DMAENAB);
-                        wCsr |= MGC_M_TXCSR_MODE;
-			musb_writew(epio, MGC_O_HDRC_TXCSR,
-				wCsr | MGC_M_TXCSR_MODE);
+			csr = musb_readw(epio, MUSB_TXCSR);
+			csr &= ~(MUSB_TXCSR_AUTOSET
+				| MUSB_TXCSR_DMAMODE
+				| MUSB_TXCSR_DMAENAB);
+			csr |= MUSB_TXCSR_MODE;
+			musb_writew(epio, MUSB_TXCSR,
+				csr | MUSB_TXCSR_MODE);
 
-			qh->segsize = min(dwLength, pDmaChannel->dwMaxLength);
+			qh->segsize = min(len, dma_channel->max_len);
 
-			if (qh->segsize <= wPacketSize)
-				pDmaChannel->bDesiredMode = 0;
+			if (qh->segsize <= packet_sz)
+				dma_channel->desired_mode = 0;
 			else
-				pDmaChannel->bDesiredMode = 1;
+				dma_channel->desired_mode = 1;
 
 
-			if (pDmaChannel->bDesiredMode == 0) {
-				wCsr &= ~(MGC_M_TXCSR_AUTOSET
-					| MGC_M_TXCSR_DMAMODE);
-				wCsr |= (MGC_M_TXCSR_DMAENAB);
-					// against programming guide
+			if (dma_channel->desired_mode == 0) {
+				csr &= ~(MUSB_TXCSR_AUTOSET
+					| MUSB_TXCSR_DMAMODE);
+				csr |= (MUSB_TXCSR_DMAENAB);
+					/* against programming guide */
 			} else
-				wCsr |= (MGC_M_TXCSR_AUTOSET
-					| MGC_M_TXCSR_DMAENAB
-					| MGC_M_TXCSR_DMAMODE);
-
-			musb_writew(epio, MGC_O_HDRC_TXCSR, wCsr);
-
-			bDmaOk = pDmaController->channel_program(
-					pDmaChannel, wPacketSize,
-					pDmaChannel->bDesiredMode,
-					pUrb->transfer_dma,
+				csr |= (MUSB_TXCSR_AUTOSET
+					| MUSB_TXCSR_DMAENAB
+					| MUSB_TXCSR_DMAMODE);
+
+			musb_writew(epio, MUSB_TXCSR, csr);
+
+			dma_ok = dma_controller->channel_program(
+					dma_channel, packet_sz,
+					dma_channel->desired_mode,
+					urb->transfer_dma,
 					qh->segsize);
-			if (bDmaOk) {
-				wLoadCount = 0;
+			if (dma_ok) {
+				load_count = 0;
 			} else {
-				pDmaController->channel_release(pDmaChannel);
+				dma_controller->channel_release(dma_channel);
 				if (is_out)
-					pEnd->tx_channel = NULL;
+					hw_ep->tx_channel = NULL;
 				else
-					pEnd->rx_channel = NULL;
-				pDmaChannel = NULL;
+					hw_ep->rx_channel = NULL;
+				dma_channel = NULL;
 			}
 		}
 #endif
 
 		/* candidate for DMA */
-		if ((is_cppi_enabled() || tusb_dma_omap()) && pDmaChannel) {
+		if ((is_cppi_enabled() || tusb_dma_omap()) && dma_channel) {
 
 			/* program endpoint CSRs first, then setup DMA.
 			 * assume CPPI setup succeeds.
 			 * defer enabling dma.
 			 */
-			wCsr = musb_readw(epio, MGC_O_HDRC_TXCSR);
-			wCsr &= ~(MGC_M_TXCSR_AUTOSET
-					| MGC_M_TXCSR_DMAMODE
-					| MGC_M_TXCSR_DMAENAB);
-			wCsr |= MGC_M_TXCSR_MODE;
-			musb_writew(epio, MGC_O_HDRC_TXCSR,
-				wCsr | MGC_M_TXCSR_MODE);
+			csr = musb_readw(epio, MUSB_TXCSR);
+			csr &= ~(MUSB_TXCSR_AUTOSET
+					| MUSB_TXCSR_DMAMODE
+					| MUSB_TXCSR_DMAENAB);
+			csr |= MUSB_TXCSR_MODE;
+			musb_writew(epio, MUSB_TXCSR,
+				csr | MUSB_TXCSR_MODE);
 
-			pDmaChannel->dwActualLength = 0L;
-			qh->segsize = dwLength;
+			dma_channel->actual_len = 0L;
+			qh->segsize = len;
 
 			/* TX uses "rndis" mode automatically, but needs help
 			 * to identify the zero-length-final-packet case.
 			 */
-			bDmaOk = pDmaController->channel_program(
-					pDmaChannel, wPacketSize,
-					(pUrb->transfer_flags
+			dma_ok = dma_controller->channel_program(
+					dma_channel, packet_sz,
+					(urb->transfer_flags
 							& URB_ZERO_PACKET)
 						== URB_ZERO_PACKET,
-					pUrb->transfer_dma,
+					urb->transfer_dma,
 					qh->segsize);
-			if (bDmaOk) {
-				wLoadCount = 0;
+			if (dma_ok) {
+				load_count = 0;
 			} else {
-				pDmaController->channel_release(pDmaChannel);
-				pDmaChannel = pEnd->tx_channel = NULL;
+				dma_controller->channel_release(dma_channel);
+				dma_channel = hw_ep->tx_channel = NULL;
 
 				/* REVISIT there's an error path here that
 				 * needs handling:  can't do dma, but
@@ -862,166 +846,165 @@
 			}
 		}
 
-		if (wLoadCount) {
+		if (load_count) {
 			/* ASSERT:  TXCSR_DMAENAB was already cleared */
 
 			/* PIO to load FIFO */
-			qh->segsize = wLoadCount;
-			musb_write_fifo(pEnd, wLoadCount, pBuffer);
-			wCsr = musb_readw(epio, MGC_O_HDRC_TXCSR);
-			wCsr &= ~(MGC_M_TXCSR_DMAENAB
-				| MGC_M_TXCSR_DMAMODE
-				| MGC_M_TXCSR_AUTOSET);
+			qh->segsize = load_count;
+			musb_write_fifo(hw_ep, load_count, buf);
+			csr = musb_readw(epio, MUSB_TXCSR);
+			csr &= ~(MUSB_TXCSR_DMAENAB
+				| MUSB_TXCSR_DMAMODE
+				| MUSB_TXCSR_AUTOSET);
 			/* write CSR */
-			wCsr |= MGC_M_TXCSR_MODE;
+			csr |= MUSB_TXCSR_MODE;
 
-			if (bEnd)
-				musb_writew(epio, MGC_O_HDRC_TXCSR, wCsr);
+			if (epnum)
+				musb_writew(epio, MUSB_TXCSR, csr);
 		}
 
 		/* re-enable interrupt */
-		musb_writew(pBase, MGC_O_HDRC_INTRTXE, wIntrTxE);
+		musb_writew(mbase, MUSB_INTRTXE, int_txe);
 
 	/* IN/receive */
 	} else {
 		u16	csr;
 
-		if (pEnd->rx_reinit) {
-			musb_rx_reinit(pThis, qh, pEnd);
+		if (hw_ep->rx_reinit) {
+			musb_rx_reinit(musb, qh, hw_ep);
 
 			/* init new state: toggle and NYET, maybe DMA later */
-			if (usb_gettoggle(pUrb->dev, qh->epnum, 0))
-				csr = MGC_M_RXCSR_H_WR_DATATOGGLE
-					| MGC_M_RXCSR_H_DATATOGGLE;
+			if (usb_gettoggle(urb->dev, qh->epnum, 0))
+				csr = MUSB_RXCSR_H_WR_DATATOGGLE
+					| MUSB_RXCSR_H_DATATOGGLE;
 			else
 				csr = 0;
 			if (qh->type == USB_ENDPOINT_XFER_INT)
-				csr |= MGC_M_RXCSR_DISNYET;
+				csr |= MUSB_RXCSR_DISNYET;
 
 		} else {
-			csr = musb_readw(pEnd->regs, MGC_O_HDRC_RXCSR);
+			csr = musb_readw(hw_ep->regs, MUSB_RXCSR);
 
-			if (csr & (MGC_M_RXCSR_RXPKTRDY
-					| MGC_M_RXCSR_DMAENAB
-					| MGC_M_RXCSR_H_REQPKT))
+			if (csr & (MUSB_RXCSR_RXPKTRDY
+					| MUSB_RXCSR_DMAENAB
+					| MUSB_RXCSR_H_REQPKT))
 				ERR("broken !rx_reinit, ep%d csr %04x\n",
-						pEnd->bLocalEnd, csr);
+						hw_ep->epnum, csr);
 
 			/* scrub any stale state, leaving toggle alone */
-			csr &= MGC_M_RXCSR_DISNYET;
+			csr &= MUSB_RXCSR_DISNYET;
 		}
 
 		/* kick things off */
 
-		if ((is_cppi_enabled() || tusb_dma_omap()) && pDmaChannel) {
+		if ((is_cppi_enabled() || tusb_dma_omap()) && dma_channel) {
 			/* candidate for DMA */
-			if (pDmaChannel) {
-				pDmaChannel->dwActualLength = 0L;
-				qh->segsize = dwLength;
+			if (dma_channel) {
+				dma_channel->actual_len = 0L;
+				qh->segsize = len;
 
 				/* AUTOREQ is in a DMA register */
-				musb_writew(pEnd->regs, MGC_O_HDRC_RXCSR, csr);
-				csr = musb_readw(pEnd->regs,
-						MGC_O_HDRC_RXCSR);
+				musb_writew(hw_ep->regs, MUSB_RXCSR, csr);
+				csr = musb_readw(hw_ep->regs,
+						MUSB_RXCSR);
 
 				/* unless caller treats short rx transfers as
 				 * errors, we dare not queue multiple transfers.
 				 */
-				bDmaOk = pDmaController->channel_program(
-						pDmaChannel, wPacketSize,
-						!(pUrb->transfer_flags
+				dma_ok = dma_controller->channel_program(
+						dma_channel, packet_sz,
+						!(urb->transfer_flags
 							& URB_SHORT_NOT_OK),
-						pUrb->transfer_dma,
+						urb->transfer_dma,
 						qh->segsize);
-				if (!bDmaOk) {
-					pDmaController->channel_release(
-							pDmaChannel);
-					pDmaChannel = pEnd->rx_channel = NULL;
+				if (!dma_ok) {
+					dma_controller->channel_release(
+							dma_channel);
+					dma_channel = hw_ep->rx_channel = NULL;
 				} else
-					csr |= MGC_M_RXCSR_DMAENAB;
+					csr |= MUSB_RXCSR_DMAENAB;
 			}
 		}
 
-		csr |= MGC_M_RXCSR_H_REQPKT;
-		DBG(7, "RXCSR%d := %04x\n", bEnd, csr);
-		musb_writew(pEnd->regs, MGC_O_HDRC_RXCSR, csr);
-		csr = musb_readw(pEnd->regs, MGC_O_HDRC_RXCSR);
+		csr |= MUSB_RXCSR_H_REQPKT;
+		DBG(7, "RXCSR%d := %04x\n", epnum, csr);
+		musb_writew(hw_ep->regs, MUSB_RXCSR, csr);
+		csr = musb_readw(hw_ep->regs, MUSB_RXCSR);
 	}
 }
 
 
 /*
  * Service the default endpoint (ep0) as host.
- * Return TRUE until it's time to start the status stage.
+ * Return true until it's time to start the status stage.
  */
-static int musb_h_ep0_continue(struct musb *pThis,
-				u16 wCount, struct urb *pUrb)
+static bool musb_h_ep0_continue(struct musb *musb, u16 len, struct urb *urb)
 {
-	int			 bMore = FALSE;
-	u8 *pFifoDest = NULL;
-	u16 wFifoCount = 0;
-	struct musb_hw_ep	*pEnd = pThis->control_ep;
-	struct musb_qh		*qh = pEnd->in_qh;
-	struct usb_ctrlrequest	*pRequest;
-
-	switch (pThis->bEnd0Stage) {
-	case MGC_END0_IN:
-		pFifoDest = pUrb->transfer_buffer + pUrb->actual_length;
-		wFifoCount = min(wCount, ((u16) (pUrb->transfer_buffer_length
-					- pUrb->actual_length)));
-		if (wFifoCount < wCount)
-			pUrb->status = -EOVERFLOW;
+	bool			 more = false;
+	u8			*fifo_dest = NULL;
+	u16			fifo_count = 0;
+	struct musb_hw_ep	*hw_ep = musb->control_ep;
+	struct musb_qh		*qh = hw_ep->in_qh;
+	struct usb_ctrlrequest	*request;
+
+	switch (musb->ep0_stage) {
+	case MUSB_EP0_IN:
+		fifo_dest = urb->transfer_buffer + urb->actual_length;
+		fifo_count = min(len, ((u16) (urb->transfer_buffer_length
+					- urb->actual_length)));
+		if (fifo_count < len)
+			urb->status = -EOVERFLOW;
 
-		musb_read_fifo(pEnd, wFifoCount, pFifoDest);
+		musb_read_fifo(hw_ep, fifo_count, fifo_dest);
 
-		pUrb->actual_length += wFifoCount;
-		if (wCount < qh->maxpacket) {
+		urb->actual_length += fifo_count;
+		if (len < qh->maxpacket) {
 			/* always terminate on short read; it's
 			 * rarely reported as an error.
 			 */
-		} else if (pUrb->actual_length <
-				pUrb->transfer_buffer_length)
-			bMore = TRUE;
+		} else if (urb->actual_length <
+				urb->transfer_buffer_length)
+			more = true;
 		break;
-	case MGC_END0_START:
-		pRequest = (struct usb_ctrlrequest *) pUrb->setup_packet;
+	case MUSB_EP0_START:
+		request = (struct usb_ctrlrequest *) urb->setup_packet;
 
-		if (!pRequest->wLength) {
+		if (!request->wLength) {
 			DBG(4, "start no-DATA\n");
 			break;
-		} else if (pRequest->bRequestType & USB_DIR_IN) {
+		} else if (request->bRequestType & USB_DIR_IN) {
 			DBG(4, "start IN-DATA\n");
-			pThis->bEnd0Stage = MGC_END0_IN;
-			bMore = TRUE;
+			musb->ep0_stage = MUSB_EP0_IN;
+			more = true;
 			break;
 		} else {
 			DBG(4, "start OUT-DATA\n");
-			pThis->bEnd0Stage = MGC_END0_OUT;
-			bMore = TRUE;
+			musb->ep0_stage = MUSB_EP0_OUT;
+			more = true;
 		}
 		/* FALLTHROUGH */
-	case MGC_END0_OUT:
-		wFifoCount = min(qh->maxpacket, ((u16)
-				(pUrb->transfer_buffer_length
-				- pUrb->actual_length)));
-
-		if (wFifoCount) {
-			pFifoDest = (u8 *) (pUrb->transfer_buffer
-					+ pUrb->actual_length);
+	case MUSB_EP0_OUT:
+		fifo_count = min(qh->maxpacket, ((u16)
+				(urb->transfer_buffer_length
+				- urb->actual_length)));
+
+		if (fifo_count) {
+			fifo_dest = (u8 *) (urb->transfer_buffer
+					+ urb->actual_length);
 			DBG(3, "Sending %d bytes to %p\n",
-					wFifoCount, pFifoDest);
-			musb_write_fifo(pEnd, wFifoCount, pFifoDest);
+					fifo_count, fifo_dest);
+			musb_write_fifo(hw_ep, fifo_count, fifo_dest);
 
-			pUrb->actual_length += wFifoCount;
-			bMore = TRUE;
+			urb->actual_length += fifo_count;
+			more = true;
 		}
 		break;
 	default:
-		ERR("bogus ep0 stage %d\n", pThis->bEnd0Stage);
+		ERR("bogus ep0 stage %d\n", musb->ep0_stage);
 		break;
 	}
 
-	return bMore;
+	return more;
 }
 
 /*
@@ -1030,46 +1013,46 @@
  *
  * called with controller irqlocked
  */
-irqreturn_t musb_h_ep0_irq(struct musb *pThis)
+irqreturn_t musb_h_ep0_irq(struct musb *musb)
 {
-	struct urb		*pUrb;
-	u16			wCsrVal, wCount;
+	struct urb		*urb;
+	u16			csr, len;
 	int			status = 0;
-	void __iomem		*pBase = pThis->pRegs;
-	struct musb_hw_ep	*pEnd = pThis->control_ep;
-	void __iomem		*epio = pEnd->regs;
-	struct musb_qh		*qh = pEnd->in_qh;
-	u8			bComplete = FALSE;
+	void __iomem		*mbase = musb->mregs;
+	struct musb_hw_ep	*hw_ep = musb->control_ep;
+	void __iomem		*epio = hw_ep->regs;
+	struct musb_qh		*qh = hw_ep->in_qh;
+	bool			complete = false;
 	irqreturn_t		retval = IRQ_NONE;
 
 	/* ep0 only has one queue, "in" */
-	pUrb = next_urb(qh);
+	urb = next_urb(qh);
 
-	MGC_SelectEnd(pBase, 0);
-	wCsrVal = musb_readw(epio, MGC_O_HDRC_CSR0);
-	wCount = (wCsrVal & MGC_M_CSR0_RXPKTRDY)
-			? musb_readb(epio, MGC_O_HDRC_COUNT0)
+	musb_ep_select(mbase, 0);
+	csr = musb_readw(epio, MUSB_CSR0);
+	len = (csr & MUSB_CSR0_RXPKTRDY)
+			? musb_readb(epio, MUSB_COUNT0)
 			: 0;
 
 	DBG(4, "<== csr0 %04x, qh %p, count %d, urb %p, stage %d\n",
-		wCsrVal, qh, wCount, pUrb, pThis->bEnd0Stage);
+		csr, qh, len, urb, musb->ep0_stage);
 
 	/* if we just did status stage, we are done */
-	if (MGC_END0_STATUS == pThis->bEnd0Stage) {
+	if (MUSB_EP0_STATUS == musb->ep0_stage) {
 		retval = IRQ_HANDLED;
-		bComplete = TRUE;
+		complete = true;
 	}
 
 	/* prepare status */
-	if (wCsrVal & MGC_M_CSR0_H_RXSTALL) {
+	if (csr & MUSB_CSR0_H_RXSTALL) {
 		DBG(6, "STALLING ENDPOINT\n");
 		status = -EPIPE;
 
-	} else if (wCsrVal & MGC_M_CSR0_H_ERROR) {
-		DBG(2, "no response, csr0 %04x\n", wCsrVal);
+	} else if (csr & MUSB_CSR0_H_ERROR) {
+		DBG(2, "no response, csr0 %04x\n", csr);
 		status = -EPROTO;
 
-	} else if (wCsrVal & MGC_M_CSR0_H_NAKTIMEOUT) {
+	} else if (csr & MUSB_CSR0_H_NAKTIMEOUT) {
 		DBG(2, "control NAK timeout\n");
 
 		/* NOTE:  this code path would be a good place to PAUSE a
@@ -1079,79 +1062,79 @@
 		 * if (qh->ring.next != &musb->control), then
 		 * we have a candidate... NAKing is *NOT* an error
 		 */
-		musb_writew(epio, MGC_O_HDRC_CSR0, 0);
+		musb_writew(epio, MUSB_CSR0, 0);
 		retval = IRQ_HANDLED;
 	}
 
 	if (status) {
 		DBG(6, "aborting\n");
 		retval = IRQ_HANDLED;
-		if (pUrb)
-			pUrb->status = status;
-		bComplete = TRUE;
+		if (urb)
+			urb->status = status;
+		complete = true;
 
 		/* use the proper sequence to abort the transfer */
-		if (wCsrVal & MGC_M_CSR0_H_REQPKT) {
-			wCsrVal &= ~MGC_M_CSR0_H_REQPKT;
-			musb_writew(epio, MGC_O_HDRC_CSR0, wCsrVal);
-			wCsrVal &= ~MGC_M_CSR0_H_NAKTIMEOUT;
-			musb_writew(epio, MGC_O_HDRC_CSR0, wCsrVal);
+		if (csr & MUSB_CSR0_H_REQPKT) {
+			csr &= ~MUSB_CSR0_H_REQPKT;
+			musb_writew(epio, MUSB_CSR0, csr);
+			csr &= ~MUSB_CSR0_H_NAKTIMEOUT;
+			musb_writew(epio, MUSB_CSR0, csr);
 		} else {
-			wCsrVal |= MGC_M_CSR0_FLUSHFIFO;
-			musb_writew(epio, MGC_O_HDRC_CSR0, wCsrVal);
-			musb_writew(epio, MGC_O_HDRC_CSR0, wCsrVal);
-			wCsrVal &= ~MGC_M_CSR0_H_NAKTIMEOUT;
-			musb_writew(epio, MGC_O_HDRC_CSR0, wCsrVal);
+			csr |= MUSB_CSR0_FLUSHFIFO;
+			musb_writew(epio, MUSB_CSR0, csr);
+			musb_writew(epio, MUSB_CSR0, csr);
+			csr &= ~MUSB_CSR0_H_NAKTIMEOUT;
+			musb_writew(epio, MUSB_CSR0, csr);
 		}
 
-		musb_writeb(epio, MGC_O_HDRC_NAKLIMIT0, 0);
+		musb_writeb(epio, MUSB_NAKLIMIT0, 0);
 
 		/* clear it */
-		musb_writew(epio, MGC_O_HDRC_CSR0, 0);
+		musb_writew(epio, MUSB_CSR0, 0);
 	}
 
-	if (unlikely(!pUrb)) {
+	if (unlikely(!urb)) {
 		/* stop endpoint since we have no place for its data, this
 		 * SHOULD NEVER HAPPEN! */
 		ERR("no URB for end 0\n");
 
-		musb_writew(epio, MGC_O_HDRC_CSR0, MGC_M_CSR0_FLUSHFIFO);
-		musb_writew(epio, MGC_O_HDRC_CSR0, MGC_M_CSR0_FLUSHFIFO);
-		musb_writew(epio, MGC_O_HDRC_CSR0, 0);
+		musb_writew(epio, MUSB_CSR0, MUSB_CSR0_FLUSHFIFO);
+		musb_writew(epio, MUSB_CSR0, MUSB_CSR0_FLUSHFIFO);
+		musb_writew(epio, MUSB_CSR0, 0);
 
 		goto done;
 	}
 
-	if (!bComplete) {
+	if (!complete) {
 		/* call common logic and prepare response */
-		if (musb_h_ep0_continue(pThis, wCount, pUrb)) {
+		if (musb_h_ep0_continue(musb, len, urb)) {
 			/* more packets required */
-			wCsrVal = (MGC_END0_IN == pThis->bEnd0Stage)
-				?  MGC_M_CSR0_H_REQPKT : MGC_M_CSR0_TXPKTRDY;
+			csr = (MUSB_EP0_IN == musb->ep0_stage)
+				?  MUSB_CSR0_H_REQPKT : MUSB_CSR0_TXPKTRDY;
 		} else {
 			/* data transfer complete; perform status phase */
-			if (usb_pipeout(pUrb->pipe)
-					|| !pUrb->transfer_buffer_length)
-				wCsrVal = MGC_M_CSR0_H_STATUSPKT
-					| MGC_M_CSR0_H_REQPKT;
+			if (usb_pipeout(urb->pipe)
+					|| !urb->transfer_buffer_length)
+				csr = MUSB_CSR0_H_STATUSPKT
+					| MUSB_CSR0_H_REQPKT;
 			else
-				wCsrVal = MGC_M_CSR0_H_STATUSPKT
-					| MGC_M_CSR0_TXPKTRDY;
+				csr = MUSB_CSR0_H_STATUSPKT
+					| MUSB_CSR0_TXPKTRDY;
 
 			/* flag status stage */
-			pThis->bEnd0Stage = MGC_END0_STATUS;
+			musb->ep0_stage = MUSB_EP0_STATUS;
 
-			DBG(5, "ep0 STATUS, csr %04x\n", wCsrVal);
+			DBG(5, "ep0 STATUS, csr %04x\n", csr);
 
 		}
-		musb_writew(epio, MGC_O_HDRC_CSR0, wCsrVal);
+		musb_writew(epio, MUSB_CSR0, csr);
 		retval = IRQ_HANDLED;
 	} else
-		pThis->bEnd0Stage = MGC_END0_IDLE;
+		musb->ep0_stage = MUSB_EP0_IDLE;
 
 	/* call completion handler if done */
-	if (bComplete)
-		musb_advance_schedule(pThis, pUrb, pEnd, 1);
+	if (complete)
+		musb_advance_schedule(musb, urb, hw_ep, 1);
 done:
 	return retval;
 }
@@ -1174,53 +1157,53 @@
 #endif
 
 /* Service a Tx-Available or dma completion irq for the endpoint */
-void musb_host_tx(struct musb *pThis, u8 bEnd)
+void musb_host_tx(struct musb *musb, u8 epnum)
 {
-	int			nPipe;
-	u8			bDone = FALSE;
-	u16			wTxCsrVal;
+	int			pipe;
+	bool			done = false;
+	u16			tx_csr;
 	size_t			wLength = 0;
-	u8			*pBuffer = NULL;
-	struct urb		*pUrb;
-	struct musb_hw_ep	*pEnd = pThis->aLocalEnd + bEnd;
-	void __iomem		*epio = pEnd->regs;
-	struct musb_qh		*qh = pEnd->out_qh;
+	u8			*buf = NULL;
+	struct urb		*urb;
+	struct musb_hw_ep	*hw_ep = musb->endpoints + epnum;
+	void __iomem		*epio = hw_ep->regs;
+	struct musb_qh		*qh = hw_ep->out_qh;
 	u32			status = 0;
-	void __iomem		*pBase = pThis->pRegs;
+	void __iomem		*mbase = musb->mregs;
 	struct dma_channel	*dma;
 
-	pUrb = next_urb(qh);
+	urb = next_urb(qh);
 
-	MGC_SelectEnd(pBase, bEnd);
-	wTxCsrVal = musb_readw(epio, MGC_O_HDRC_TXCSR);
+	musb_ep_select(mbase, epnum);
+	tx_csr = musb_readw(epio, MUSB_TXCSR);
 
 	/* with CPPI, DMA sometimes triggers "extra" irqs */
-	if (!pUrb) {
-		DBG(4, "extra TX%d ready, csr %04x\n", bEnd, wTxCsrVal);
+	if (!urb) {
+		DBG(4, "extra TX%d ready, csr %04x\n", epnum, tx_csr);
 		goto finish;
 	}
 
-	nPipe = pUrb->pipe;
-	dma = is_dma_capable() ? pEnd->tx_channel : NULL;
-	DBG(4, "OUT/TX%d end, csr %04x%s\n", bEnd, wTxCsrVal,
+	pipe = urb->pipe;
+	dma = is_dma_capable() ? hw_ep->tx_channel : NULL;
+	DBG(4, "OUT/TX%d end, csr %04x%s\n", epnum, tx_csr,
 			dma ? ", dma" : "");
 
 	/* check for errors */
-	if (wTxCsrVal & MGC_M_TXCSR_H_RXSTALL) {
+	if (tx_csr & MUSB_TXCSR_H_RXSTALL) {
 		/* dma was disabled, fifo flushed */
-		DBG(3, "TX end %d stall\n", bEnd);
+		DBG(3, "TX end %d stall\n", epnum);
 
 		/* stall; record URB status */
 		status = -EPIPE;
 
-	} else if (wTxCsrVal & MGC_M_TXCSR_H_ERROR) {
+	} else if (tx_csr & MUSB_TXCSR_H_ERROR) {
 		/* (NON-ISO) dma was disabled, fifo flushed */
-		DBG(3, "TX 3strikes on ep=%d\n", bEnd);
+		DBG(3, "TX 3strikes on ep=%d\n", epnum);
 
 		status = -ETIMEDOUT;
 
-	} else if (wTxCsrVal & MGC_M_TXCSR_H_NAKTIMEOUT) {
-		DBG(6, "TX end=%d device not responding\n", bEnd);
+	} else if (tx_csr & MUSB_TXCSR_H_NAKTIMEOUT) {
+		DBG(6, "TX end=%d device not responding\n", epnum);
 
 		/* NOTE:  this code path would be a good place to PAUSE a
 		 * transfer, if there's some other (nonperiodic) tx urb
@@ -1229,94 +1212,80 @@
 		 * if (bulk && qh->ring.next != &musb->out_bulk), then
 		 * we have a candidate... NAKing is *NOT* an error
 		 */
-		MGC_SelectEnd(pBase, bEnd);
-		musb_writew(epio, MGC_O_HDRC_CSR0,
-				MGC_M_TXCSR_H_WZC_BITS
-				| MGC_M_TXCSR_TXPKTRDY);
+		musb_ep_select(mbase, epnum);
+		musb_writew(epio, MUSB_CSR0,
+				MUSB_TXCSR_H_WZC_BITS
+				| MUSB_TXCSR_TXPKTRDY);
 		goto finish;
 	}
 
 	if (status) {
-		if (dma_channel_status(dma) == MGC_DMA_STATUS_BUSY) {
-			dma->bStatus = MGC_DMA_STATUS_CORE_ABORT;
-			(void) pThis->pDmaController->channel_abort(dma);
+		if (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {
+			dma->status = MUSB_DMA_STATUS_CORE_ABORT;
+			(void) musb->dma_controller->channel_abort(dma);
 		}
 
 		/* do the proper sequence to abort the transfer in the
 		 * usb core; the dma engine should already be stopped.
 		 */
-		musb_h_tx_flush_fifo(pEnd);
-		wTxCsrVal &= ~(MGC_M_TXCSR_AUTOSET
-				| MGC_M_TXCSR_DMAENAB
-				| MGC_M_TXCSR_H_ERROR
-				| MGC_M_TXCSR_H_RXSTALL
-				| MGC_M_TXCSR_H_NAKTIMEOUT
+		musb_h_tx_flush_fifo(hw_ep);
+		tx_csr &= ~(MUSB_TXCSR_AUTOSET
+				| MUSB_TXCSR_DMAENAB
+				| MUSB_TXCSR_H_ERROR
+				| MUSB_TXCSR_H_RXSTALL
+				| MUSB_TXCSR_H_NAKTIMEOUT
 				);
 
-		MGC_SelectEnd(pBase, bEnd);
-		musb_writew(epio, MGC_O_HDRC_TXCSR, wTxCsrVal);
+		musb_ep_select(mbase, epnum);
+		musb_writew(epio, MUSB_TXCSR, tx_csr);
 		/* REVISIT may need to clear FLUSHFIFO ... */
-		musb_writew(epio, MGC_O_HDRC_TXCSR, wTxCsrVal);
-		musb_writeb(epio, MGC_O_HDRC_TXINTERVAL, 0);
+		musb_writew(epio, MUSB_TXCSR, tx_csr);
+		musb_writeb(epio, MUSB_TXINTERVAL, 0);
 
-		bDone = TRUE;
+		done = true;
 	}
 
 	/* second cppi case */
-	if (dma_channel_status(dma) == MGC_DMA_STATUS_BUSY) {
-		DBG(4, "extra TX%d ready, csr %04x\n", bEnd, wTxCsrVal);
+	if (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {
+		DBG(4, "extra TX%d ready, csr %04x\n", epnum, tx_csr);
 		goto finish;
 
 	}
 
 	/* REVISIT this looks wrong... */
-	if (!status || dma || usb_pipeisoc(nPipe)) {
-
-#ifdef CONFIG_USB_INVENTRA_DMA
-		/* mode 0 or last short packet)
-		 * REVISIT how about ZLP?
-		 */
-		if ((dma->bDesiredMode == 0)
-				|| (dma->dwActualLength
-					& (qh->maxpacket - 1))) {
-			/* Send out the packet first ... */
-			MGC_SelectEnd(pBase, bEnd);
-			musb_writew(epio, MGC_O_HDRC_TXCSR,
-					MGC_M_TXCSR_TXPKTRDY);
-		}
-#endif
+	if (!status || dma || usb_pipeisoc(pipe)) {
 		if (dma)
-			wLength = dma->dwActualLength;
+			wLength = dma->actual_len;
 		else
 			wLength = qh->segsize;
 		qh->offset += wLength;
 
-		if (usb_pipeisoc(nPipe)) {
+		if (usb_pipeisoc(pipe)) {
 			struct usb_iso_packet_descriptor	*d;
 
-			d = pUrb->iso_frame_desc + qh->iso_idx;
+			d = urb->iso_frame_desc + qh->iso_idx;
 			d->actual_length = qh->segsize;
-			if (++qh->iso_idx >= pUrb->number_of_packets) {
-				bDone = TRUE;
+			if (++qh->iso_idx >= urb->number_of_packets) {
+				done = true;
 			} else if (!dma) {
 				d++;
-				pBuffer = pUrb->transfer_buffer + d->offset;
+				buf = urb->transfer_buffer + d->offset;
 				wLength = d->length;
 			}
 		} else if (dma) {
-			bDone = TRUE;
+			done = true;
 		} else {
 			/* see if we need to send more data, or ZLP */
 			if (qh->segsize < qh->maxpacket)
-				bDone = TRUE;
-			else if (qh->offset == pUrb->transfer_buffer_length
-					&& !(pUrb-> transfer_flags
-							& URB_ZERO_PACKET))
-				bDone = TRUE;
-			if (!bDone) {
-				pBuffer = pUrb->transfer_buffer
+				done = true;
+			else if (qh->offset == urb->transfer_buffer_length
+					&& !(urb->transfer_flags
+						& URB_ZERO_PACKET))
+				done = true;
+			if (!done) {
+				buf = urb->transfer_buffer
 						+ qh->offset;
-				wLength = pUrb->transfer_buffer_length
+				wLength = urb->transfer_buffer_length
 						- qh->offset;
 			}
 		}
@@ -1325,33 +1294,33 @@
 	/* urb->status != -EINPROGRESS means request has been faulted,
 	 * so we must abort this transfer after cleanup
 	 */
-	if (pUrb->status != -EINPROGRESS) {
-		bDone = TRUE;
+	if (urb->status != -EINPROGRESS) {
+		done = true;
 		if (status == 0)
-			status = pUrb->status;
+			status = urb->status;
 	}
 
-	if (bDone) {
+	if (done) {
 		/* set status */
-		pUrb->status = status;
-		pUrb->actual_length = qh->offset;
-		musb_advance_schedule(pThis, pUrb, pEnd, USB_DIR_OUT);
+		urb->status = status;
+		urb->actual_length = qh->offset;
+		musb_advance_schedule(musb, urb, hw_ep, USB_DIR_OUT);
 
-	} else if (!(wTxCsrVal & MGC_M_TXCSR_DMAENAB)) {
-		// WARN_ON(!pBuffer);
+	} else if (!(tx_csr & MUSB_TXCSR_DMAENAB)) {
+		/* WARN_ON(!buf); */
 
-		/* REVISIT:  some docs say that when pEnd->tx_double_buffered,
+		/* REVISIT:  some docs say that when hw_ep->tx_double_buffered,
 		 * (and presumably, fifo is not half-full) we should write TWO
 		 * packets before updating TXCSR ... other docs disagree ...
 		 */
 		/* PIO:  start next packet in this URB */
 		wLength = min(qh->maxpacket, (u16) wLength);
-		musb_write_fifo(pEnd, wLength, pBuffer);
+		musb_write_fifo(hw_ep, wLength, buf);
 		qh->segsize = wLength;
 
-		MGC_SelectEnd(pBase, bEnd);
-		musb_writew(epio, MGC_O_HDRC_TXCSR,
-				MGC_M_TXCSR_H_WZC_BITS | MGC_M_TXCSR_TXPKTRDY);
+		musb_ep_select(mbase, epnum);
+		musb_writew(epio, MUSB_TXCSR,
+				MUSB_TXCSR_H_WZC_BITS | MUSB_TXCSR_TXPKTRDY);
 	} else
 		DBG(1, "not complete, but dma enabled?\n");
 
@@ -1403,62 +1372,62 @@
  * Service an RX interrupt for the given IN endpoint; docs cover bulk, iso,
  * and high-bandwidth IN transfer cases.
  */
-void musb_host_rx(struct musb *pThis, u8 bEnd)
+void musb_host_rx(struct musb *musb, u8 epnum)
 {
-	struct urb		*pUrb;
-	struct musb_hw_ep	*pEnd = pThis->aLocalEnd + bEnd;
-	void __iomem		*epio = pEnd->regs;
-	struct musb_qh		*qh = pEnd->in_qh;
+	struct urb		*urb;
+	struct musb_hw_ep	*hw_ep = musb->endpoints + epnum;
+	void __iomem		*epio = hw_ep->regs;
+	struct musb_qh		*qh = hw_ep->in_qh;
 	size_t			xfer_len;
-	void __iomem		*pBase = pThis->pRegs;
-	int			nPipe;
-	u16			wRxCsrVal, wVal;
-	u8			bIsochError = FALSE;
-	u8			bDone = FALSE;
+	void __iomem		*mbase = musb->mregs;
+	int			pipe;
+	u16			rx_csr, val;
+	bool			iso_err = false;
+	bool			done = false;
 	u32			status;
 	struct dma_channel	*dma;
 
-	MGC_SelectEnd(pBase, bEnd);
+	musb_ep_select(mbase, epnum);
 
-	pUrb = next_urb(qh);
-	dma = is_dma_capable() ? pEnd->rx_channel : NULL;
+	urb = next_urb(qh);
+	dma = is_dma_capable() ? hw_ep->rx_channel : NULL;
 	status = 0;
 	xfer_len = 0;
 
-	wVal = wRxCsrVal = musb_readw(epio, MGC_O_HDRC_RXCSR);
+	val = rx_csr = musb_readw(epio, MUSB_RXCSR);
 
-	if (unlikely(!pUrb)) {
+	if (unlikely(!urb)) {
 		/* REVISIT -- THIS SHOULD NEVER HAPPEN ... but, at least
 		 * usbtest #11 (unlinks) triggers it regularly, sometimes
 		 * with fifo full.  (Only with DMA??)
 		 */
-		DBG(3, "BOGUS RX%d ready, csr %04x, count %d\n", bEnd, wVal,
-			musb_readw(epio, MGC_O_HDRC_RXCOUNT));
-		musb_h_flush_rxfifo(pEnd, MGC_M_RXCSR_CLRDATATOG);
+		DBG(3, "BOGUS RX%d ready, csr %04x, count %d\n", epnum, val,
+			musb_readw(epio, MUSB_RXCOUNT));
+		musb_h_flush_rxfifo(hw_ep, MUSB_RXCSR_CLRDATATOG);
 		return;
 	}
 
-	nPipe = pUrb->pipe;
+	pipe = urb->pipe;
 
 	DBG(5, "<== hw %d rxcsr %04x, urb actual %d (+dma %zd)\n",
-		bEnd, wRxCsrVal, pUrb->actual_length,
-		dma ? dma->dwActualLength : 0);
+		epnum, rx_csr, urb->actual_length,
+		dma ? dma->actual_len : 0);
 
 	/* check for errors, concurrent stall & unlink is not really
 	 * handled yet! */
-	if (wRxCsrVal & MGC_M_RXCSR_H_RXSTALL) {
-		DBG(3, "RX end %d STALL\n", bEnd);
+	if (rx_csr & MUSB_RXCSR_H_RXSTALL) {
+		DBG(3, "RX end %d STALL\n", epnum);
 
 		/* stall; record URB status */
 		status = -EPIPE;
 
-	} else if (wRxCsrVal & MGC_M_RXCSR_H_ERROR) {
-		DBG(3, "end %d RX proto error\n", bEnd);
+	} else if (rx_csr & MUSB_RXCSR_H_ERROR) {
+		DBG(3, "end %d RX proto error\n", epnum);
 
 		status = -EPROTO;
-		musb_writeb(epio, MGC_O_HDRC_RXINTERVAL, 0);
+		musb_writeb(epio, MUSB_RXINTERVAL, 0);
 
-	} else if (wRxCsrVal & MGC_M_RXCSR_DATAERROR) {
+	} else if (rx_csr & MUSB_RXCSR_DATAERROR) {
 
 		if (USB_ENDPOINT_XFER_ISOC != qh->type) {
 			/* NOTE this code path would be a good place to PAUSE a
@@ -1468,37 +1437,37 @@
 			 * if (bulk && qh->ring.next != &musb->in_bulk), then
 			 * we have a candidate... NAKing is *NOT* an error
 			 */
-			DBG(6, "RX end %d NAK timeout\n", bEnd);
-			MGC_SelectEnd(pBase, bEnd);
-			musb_writew(epio, MGC_O_HDRC_RXCSR,
-					MGC_M_RXCSR_H_WZC_BITS
-					| MGC_M_RXCSR_H_REQPKT);
+			DBG(6, "RX end %d NAK timeout\n", epnum);
+			musb_ep_select(mbase, epnum);
+			musb_writew(epio, MUSB_RXCSR,
+					MUSB_RXCSR_H_WZC_BITS
+					| MUSB_RXCSR_H_REQPKT);
 
 			goto finish;
 		} else {
-			DBG(4, "RX end %d ISO data error\n", bEnd);
+			DBG(4, "RX end %d ISO data error\n", epnum);
 			/* packet error reported later */
-			bIsochError = TRUE;
+			iso_err = true;
 		}
 	}
 
 	/* faults abort the transfer */
 	if (status) {
 		/* clean up dma and collect transfer count */
-		if (dma_channel_status(dma) == MGC_DMA_STATUS_BUSY) {
-			dma->bStatus = MGC_DMA_STATUS_CORE_ABORT;
-			(void) pThis->pDmaController->channel_abort(dma);
-			xfer_len = dma->dwActualLength;
-		}
-		musb_h_flush_rxfifo(pEnd, 0);
-		musb_writeb(epio, MGC_O_HDRC_RXINTERVAL, 0);
-		bDone = TRUE;
+		if (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {
+			dma->status = MUSB_DMA_STATUS_CORE_ABORT;
+			(void) musb->dma_controller->channel_abort(dma);
+			xfer_len = dma->actual_len;
+		}
+		musb_h_flush_rxfifo(hw_ep, 0);
+		musb_writeb(epio, MUSB_RXINTERVAL, 0);
+		done = true;
 		goto finish;
 	}
 
-	if (unlikely(dma_channel_status(dma) == MGC_DMA_STATUS_BUSY)) {
+	if (unlikely(dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY)) {
 		/* SHOULD NEVER HAPPEN ... but at least DaVinci has done it */
-		ERR("RX%d dma busy, csr %04x\n", bEnd, wRxCsrVal);
+		ERR("RX%d dma busy, csr %04x\n", epnum, rx_csr);
 		goto finish;
 	}
 
@@ -1510,72 +1479,70 @@
 	/* FIXME this is _way_ too much in-line logic for Mentor DMA */
 
 #ifndef CONFIG_USB_INVENTRA_DMA
-	if (wRxCsrVal & MGC_M_RXCSR_H_REQPKT)  {
+	if (rx_csr & MUSB_RXCSR_H_REQPKT)  {
 		/* REVISIT this happened for a while on some short reads...
 		 * the cleanup still needs investigation... looks bad...
 		 * and also duplicates dma cleanup code above ... plus,
 		 * shouldn't this be the "half full" double buffer case?
 		 */
-		if (dma_channel_status(dma) == MGC_DMA_STATUS_BUSY) {
-			dma->bStatus = MGC_DMA_STATUS_CORE_ABORT;
-			(void) pThis->pDmaController->channel_abort(dma);
-			xfer_len = dma->dwActualLength;
-			bDone = TRUE;
+		if (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {
+			dma->status = MUSB_DMA_STATUS_CORE_ABORT;
+			(void) musb->dma_controller->channel_abort(dma);
+			xfer_len = dma->actual_len;
+			done = true;
 		}
 
-		DBG(2, "RXCSR%d %04x, reqpkt, len %zd%s\n", bEnd, wRxCsrVal,
+		DBG(2, "RXCSR%d %04x, reqpkt, len %zd%s\n", epnum, rx_csr,
 				xfer_len, dma ? ", dma" : "");
-		wRxCsrVal &= ~MGC_M_RXCSR_H_REQPKT;
+		rx_csr &= ~MUSB_RXCSR_H_REQPKT;
 
-		MGC_SelectEnd(pBase, bEnd);
-		musb_writew(epio, MGC_O_HDRC_RXCSR,
-				MGC_M_RXCSR_H_WZC_BITS | wRxCsrVal);
+		musb_ep_select(mbase, epnum);
+		musb_writew(epio, MUSB_RXCSR,
+				MUSB_RXCSR_H_WZC_BITS | rx_csr);
 	}
 #endif
-	if (dma && (wRxCsrVal & MGC_M_RXCSR_DMAENAB)) {
-		xfer_len = dma->dwActualLength;
+	if (dma && (rx_csr & MUSB_RXCSR_DMAENAB)) {
+		xfer_len = dma->actual_len;
 
-		wVal &= ~(MGC_M_RXCSR_DMAENAB
-			| MGC_M_RXCSR_H_AUTOREQ
-			| MGC_M_RXCSR_AUTOCLEAR
-			| MGC_M_RXCSR_RXPKTRDY);
-		musb_writew(pEnd->regs, MGC_O_HDRC_RXCSR, wVal);
+		val &= ~(MUSB_RXCSR_DMAENAB
+			| MUSB_RXCSR_H_AUTOREQ
+			| MUSB_RXCSR_AUTOCLEAR
+			| MUSB_RXCSR_RXPKTRDY);
+		musb_writew(hw_ep->regs, MUSB_RXCSR, val);
 
 #ifdef CONFIG_USB_INVENTRA_DMA
-		pUrb->actual_length += xfer_len;
-		qh->offset += xfer_len;
-
-		/* bDone if pUrb buffer is full or short packet is recd */
-		bDone = (pUrb->actual_length >= pUrb->transfer_buffer_length)
-			|| (dma->dwActualLength & (qh->maxpacket - 1));
+		/* done if urb buffer is full or short packet is recd */
+		done = (urb->actual_length + xfer_len >=
+				urb->transfer_buffer_length
+			|| dma->actual_len < qh->maxpacket);
 
 		/* send IN token for next packet, without AUTOREQ */
-		if (!bDone) {
-			wVal |= MGC_M_RXCSR_H_REQPKT;
-			musb_writew(epio, MGC_O_HDRC_RXCSR,
-				MGC_M_RXCSR_H_WZC_BITS | wVal);
+		if (!done) {
+			val |= MUSB_RXCSR_H_REQPKT;
+			musb_writew(epio, MUSB_RXCSR,
+				MUSB_RXCSR_H_WZC_BITS | val);
 		}
 
-		DBG(4, "ep %d dma %s, rxcsr %04x, rxcount %d\n", bEnd,
-			bDone ? "off" : "reset",
-			musb_readw(epio, MGC_O_HDRC_RXCSR),
-			musb_readw(epio, MGC_O_HDRC_RXCOUNT));
+		DBG(4, "ep %d dma %s, rxcsr %04x, rxcount %d\n", epnum,
+			done ? "off" : "reset",
+			musb_readw(epio, MUSB_RXCSR),
+			musb_readw(epio, MUSB_RXCOUNT));
 #else
-		bDone = TRUE;
+		done = true;
 #endif
-	} else if (pUrb->status == -EINPROGRESS) {
+	} else if (urb->status == -EINPROGRESS) {
 		/* if no errors, be sure a packet is ready for unloading */
-		if (unlikely(!(wRxCsrVal & MGC_M_RXCSR_RXPKTRDY))) {
+		if (unlikely(!(rx_csr & MUSB_RXCSR_RXPKTRDY))) {
 			status = -EPROTO;
 			ERR("Rx interrupt with no errors or packet!\n");
 
-			// FIXME this is another "SHOULD NEVER HAPPEN"
+			/* FIXME this is another "SHOULD NEVER HAPPEN" */
 
-// SCRUB (RX)
+/* SCRUB (RX) */
 			/* do the proper sequence to abort the transfer */
-			MGC_SelectEnd(pBase, bEnd);
-			wVal &= ~MGC_M_RXCSR_H_REQPKT;
-			musb_writew(epio, MGC_O_HDRC_RXCSR, wVal);
+			musb_ep_select(mbase, epnum);
+			val &= ~MUSB_RXCSR_H_REQPKT;
+			musb_writew(epio, MUSB_RXCSR, val);
 			goto finish;
 		}
 
@@ -1583,31 +1550,31 @@
 #ifdef CONFIG_USB_INVENTRA_DMA
 		if (dma) {
 			struct dma_controller	*c;
-			u16			wRxCount;
-			int			status;
+			u16			rx_count;
+			int			ret;
 
-			wRxCount = musb_readw(epio, MGC_O_HDRC_RXCOUNT);
+			rx_count = musb_readw(epio, MUSB_RXCOUNT);
 
 			DBG(2, "RX%d count %d, buffer 0x%x len %d/%d\n",
-					bEnd, wRxCount,
-					pUrb->transfer_dma
-						+ pUrb->actual_length,
+					epnum, rx_count,
+					urb->transfer_dma
+						+ urb->actual_length,
 					qh->offset,
-					pUrb->transfer_buffer_length);
+					urb->transfer_buffer_length);
 
-			c = pThis->pDmaController;
+			c = musb->dma_controller;
 
-			dma->bDesiredMode = 0;
+			dma->desired_mode = 0;
 #ifdef USE_MODE1
 			/* because of the issue below, mode 1 will
 			 * only rarely behave with correct semantics.
 			 */
-			if ((pUrb->transfer_flags &
+			if ((urb->transfer_flags &
 						URB_SHORT_NOT_OK)
-				&& (pUrb->transfer_buffer_length -
-						pUrb->actual_length)
+				&& (urb->transfer_buffer_length -
+						urb->actual_length)
 					> qh->maxpacket)
-				dma->bDesiredMode = 1;
+				dma->desired_mode = 1;
 #endif
 
 /* Disadvantage of using mode 1:
@@ -1627,53 +1594,53 @@
  *	wait for an interrupt when the pkt is recd. Well, you won't get any!
  */
 
-			wVal = musb_readw(epio, MGC_O_HDRC_RXCSR);
-			wVal &= ~MGC_M_RXCSR_H_REQPKT;
+			val = musb_readw(epio, MUSB_RXCSR);
+			val &= ~MUSB_RXCSR_H_REQPKT;
 
-			if (dma->bDesiredMode == 0)
-				wVal &= ~MGC_M_RXCSR_H_AUTOREQ;
+			if (dma->desired_mode == 0)
+				val &= ~MUSB_RXCSR_H_AUTOREQ;
 			else
-				wVal |= MGC_M_RXCSR_H_AUTOREQ;
-			wVal |= MGC_M_RXCSR_AUTOCLEAR | MGC_M_RXCSR_DMAENAB;
+				val |= MUSB_RXCSR_H_AUTOREQ;
+			val |= MUSB_RXCSR_AUTOCLEAR | MUSB_RXCSR_DMAENAB;
 
-			musb_writew(epio, MGC_O_HDRC_RXCSR,
-				MGC_M_RXCSR_H_WZC_BITS | wVal);
+			musb_writew(epio, MUSB_RXCSR,
+				MUSB_RXCSR_H_WZC_BITS | val);
 
 			/* REVISIT if when actual_length != 0,
 			 * transfer_buffer_length needs to be
 			 * adjusted first...
 			 */
-			status = c->channel_program(
+			ret = c->channel_program(
 				dma, qh->maxpacket,
-				dma->bDesiredMode,
-				pUrb->transfer_dma
-					+ pUrb->actual_length,
-				(dma->bDesiredMode == 0)
-					? wRxCount
-					: pUrb->transfer_buffer_length);
+				dma->desired_mode,
+				urb->transfer_dma
+					+ urb->actual_length,
+				(dma->desired_mode == 0)
+					? rx_count
+					: urb->transfer_buffer_length);
 
-			if (!status) {
+			if (!ret) {
 				c->channel_release(dma);
-				dma = pEnd->rx_channel = NULL;
+				dma = hw_ep->rx_channel = NULL;
 				/* REVISIT reset CSR */
 			}
 		}
 #endif	/* Mentor DMA */
 
 		if (!dma) {
-			bDone = musb_host_packet_rx(pThis, pUrb,
-					bEnd, bIsochError);
-			DBG(6, "read %spacket\n", bDone ? "last " : "");
+			done = musb_host_packet_rx(musb, urb,
+					epnum, iso_err);
+			DBG(6, "read %spacket\n", done ? "last " : "");
 		}
 	}
 
 finish:
-	pUrb->actual_length += xfer_len;
+	urb->actual_length += xfer_len;
 	qh->offset += xfer_len;
-	if (bDone) {
-		if (pUrb->status == -EINPROGRESS)
-			pUrb->status = status;
-		musb_advance_schedule(pThis, pUrb, pEnd, USB_DIR_IN);
+	if (done) {
+		if (urb->status == -EINPROGRESS)
+			urb->status = status;
+		musb_advance_schedule(musb, urb, hw_ep, USB_DIR_IN);
 	}
 }
 
@@ -1688,8 +1655,8 @@
 	int			is_in)
 {
 	int			idle;
-	int			wBestDiff;
-	int			nBestEnd, nEnd;
+	int			best_diff;
+	int			best_end, epnum;
 	struct musb_hw_ep	*hw_ep = NULL;
 	struct list_head	*head = NULL;
 
@@ -1731,35 +1698,35 @@
 	 * that simplistic approach makes TT scheduling a lot simpler;
 	 * there is none, and thus none of its complexity...
 	 */
-	wBestDiff = 4096;
-	nBestEnd = -1;
+	best_diff = 4096;
+	best_end = -1;
 
-	for (nEnd = 1; nEnd < musb->bEndCount; nEnd++) {
+	for (epnum = 1; epnum < musb->nr_endpoints; epnum++) {
 		int	diff;
 
-		if (musb->periodic[nEnd])
+		if (musb->periodic[epnum])
 			continue;
-		hw_ep = &musb->aLocalEnd[nEnd];
+		hw_ep = &musb->endpoints[epnum];
 		if (hw_ep == musb->bulk_ep)
 			continue;
 
 		if (is_in)
-			diff = hw_ep->wMaxPacketSizeRx - qh->maxpacket;
+			diff = hw_ep->max_packet_sz_rx - qh->maxpacket;
 		else
-			diff = hw_ep->wMaxPacketSizeTx - qh->maxpacket;
+			diff = hw_ep->max_packet_sz_tx - qh->maxpacket;
 
-		if (diff > 0 && wBestDiff > diff) {
-			wBestDiff = diff;
-			nBestEnd = nEnd;
+		if (diff > 0 && best_diff > diff) {
+			best_diff = diff;
+			best_end = epnum;
 		}
 	}
-	if (nBestEnd < 0)
+	if (best_end < 0)
 		return -ENOSPC;
 
 	idle = 1;
-	hw_ep = musb->aLocalEnd + nBestEnd;
-	musb->periodic[nBestEnd] = qh;
-	DBG(4, "qh %p periodic slot %d\n", qh, nBestEnd);
+	hw_ep = musb->endpoints + best_end;
+	musb->periodic[best_end] = qh;
+	DBG(4, "qh %p periodic slot %d\n", qh, best_end);
 success:
 	qh->hw_ep = hw_ep;
 	qh->hep->hcpriv = qh;
@@ -1861,7 +1828,7 @@
 		 * transfer scheduling logic to try some other qh, e.g. try
 		 * for 2 msec first:
 		 *
-		 * interval = (USB_SPEED_HIGH == pUrb->dev->speed) ? 16 : 2;
+		 * interval = (USB_SPEED_HIGH == urb->dev->speed) ? 16 : 2;
 		 *
 		 * The downside of disabling this is that transfer scheduling
 		 * gets VERY unfair for nonperiodic transfers; a misbehaving
@@ -1878,7 +1845,7 @@
 	qh->intv_reg = interval;
 
 	/* precompute addressing for external hub/tt ports */
-	if (musb->bIsMultipoint) {
+	if (musb->is_multipoint) {
 		struct usb_device	*parent = urb->dev->parent;
 
 		if (parent != hcd->self.root_hub) {
@@ -1896,7 +1863,7 @@
 	 * until we get real dma queues (with an entry for each urb/buffer),
 	 * we only have work to do in the former case.
 	 */
-	spin_lock_irqsave(&musb->Lock, flags);
+	spin_lock_irqsave(&musb->lock, flags);
 	if (hep->hcpriv) {
 		/* some concurrent activity submitted another urb to hep...
 		 * odd, rare, error prone, but legal.
@@ -1913,7 +1880,7 @@
 		 * musb_start_urb(), but otherwise only konicawc cares ...
 		 */
 	}
-	spin_unlock_irqrestore(&musb->Lock, flags);
+	spin_unlock_irqrestore(&musb->lock, flags);
 
 done:
 	if (status != 0)
@@ -1931,24 +1898,24 @@
 {
 	struct musb_hw_ep	*ep = qh->hw_ep;
 	void __iomem		*epio = ep->regs;
-	unsigned		hw_end = ep->bLocalEnd;
-	void __iomem		*regs = ep->musb->pRegs;
+	unsigned		hw_end = ep->epnum;
+	void __iomem		*regs = ep->musb->mregs;
 	u16			csr;
 	int			status = 0;
 
-	MGC_SelectEnd(regs, hw_end);
+	musb_ep_select(regs, hw_end);
 
 	if (is_dma_capable()) {
 		struct dma_channel	*dma;
 
 		dma = is_in ? ep->rx_channel : ep->tx_channel;
 		if (dma) {
-			status = ep->musb->pDmaController->channel_abort(dma);
+			status = ep->musb->dma_controller->channel_abort(dma);
 			DBG(status ? 1 : 3,
 				"abort %cX%d DMA for urb %p --> %d\n",
-				is_in ? 'R' : 'T', ep->bLocalEnd,
+				is_in ? 'R' : 'T', ep->epnum,
 				urb, status);
-			urb->actual_length += dma->dwActualLength;
+			urb->actual_length += dma->actual_len;
 		}
 	}
 
@@ -1963,18 +1930,18 @@
 		 */
 	} else {
 		musb_h_tx_flush_fifo(ep);
-		csr = musb_readw(epio, MGC_O_HDRC_TXCSR);
-		csr &= ~( MGC_M_TXCSR_AUTOSET
-			| MGC_M_TXCSR_DMAENAB
-			| MGC_M_TXCSR_H_RXSTALL
-			| MGC_M_TXCSR_H_NAKTIMEOUT
-			| MGC_M_TXCSR_H_ERROR
-			);
-		musb_writew(epio, MGC_O_HDRC_TXCSR, csr);
+		csr = musb_readw(epio, MUSB_TXCSR);
+		csr &= ~(MUSB_TXCSR_AUTOSET
+			| MUSB_TXCSR_DMAENAB
+			| MUSB_TXCSR_H_RXSTALL
+			| MUSB_TXCSR_H_NAKTIMEOUT
+			| MUSB_TXCSR_H_ERROR
+			| MUSB_TXCSR_TXPKTRDY);
+		musb_writew(epio, MUSB_TXCSR, csr);
 		/* REVISIT may need to clear FLUSHFIFO ... */
-		musb_writew(epio, MGC_O_HDRC_TXCSR, csr);
+		musb_writew(epio, MUSB_TXCSR, csr);
 		/* flush cpu writebuffer */
-		csr = musb_readw(epio, MGC_O_HDRC_TXCSR);
+		csr = musb_readw(epio, MUSB_TXCSR);
 	}
 	if (status == 0)
 		musb_advance_schedule(ep->musb, urb, ep, is_in);
@@ -1995,7 +1962,7 @@
 			usb_pipeendpoint(urb->pipe),
 			usb_pipein(urb->pipe) ? "in" : "out");
 
-	spin_lock_irqsave(&musb->Lock, flags);
+	spin_lock_irqsave(&musb->lock, flags);
 
 	/* make sure the urb is still queued and not completed */
 	spin_lock(&urb->lock);
@@ -2066,7 +2033,7 @@
 	} else
 		status = musb_cleanup_urb(urb, qh, urb->pipe & USB_DIR_IN);
 done:
-	spin_unlock_irqrestore(&musb->Lock, flags);
+	spin_unlock_irqrestore(&musb->lock, flags);
 	return status;
 }
 
@@ -2085,7 +2052,7 @@
 	if (!qh)
 		return;
 
-	spin_lock_irqsave(&musb->Lock, flags);
+	spin_lock_irqsave(&musb->lock, flags);
 
 	switch (qh->type) {
 	case USB_ENDPOINT_XFER_CONTROL:
@@ -2127,14 +2094,14 @@
 	list_for_each_entry_safe_from(urb, tmp, &hep->urb_list, urb_list)
 		musb_giveback(qh, urb, -ESHUTDOWN);
 
-	spin_unlock_irqrestore(&musb->Lock, flags);
+	spin_unlock_irqrestore(&musb->lock, flags);
 }
 
 static int musb_h_get_frame_number(struct usb_hcd *hcd)
 {
 	struct musb	*musb = hcd_to_musb(hcd);
 
-	return musb_readw(musb->pRegs, MGC_O_HDRC_FRAME);
+	return musb_readw(musb->mregs, MUSB_FRAME);
 }
 
 static int musb_h_start(struct usb_hcd *hcd)
@@ -2159,9 +2126,14 @@
 {
 	struct musb	*musb = hcd_to_musb(hcd);
 
-	if (is_host_active(musb) && musb->is_active)
+	if (musb->xceiv.state == OTG_STATE_A_SUSPEND)
+		return 0;
+
+	if (is_host_active(musb) && musb->is_active) {
+		WARN("trying to suspend as %s is_active=%i\n",
+			otg_state_string(musb), musb->is_active);
 		return -EBUSY;
-	else
+	} else
 		return 0;
 }
 
@@ -2174,7 +2146,7 @@
 const struct hc_driver musb_hc_driver = {
 	.description		= "musb-hcd",
 	.product_desc		= "MUSB HDRC host driver",
-	.hcd_priv_size		= sizeof (struct musb),
+	.hcd_priv_size		= sizeof(struct musb),
 	.flags			= HCD_USB2 | HCD_MEMORY,
 
 	/* not using irq handler or reset hooks from usbcore, since
@@ -2194,6 +2166,6 @@
 	.hub_control		= musb_hub_control,
 	.bus_suspend		= musb_bus_suspend,
 	.bus_resume		= musb_bus_resume,
-//	.start_port_reset	= NULL,
-//	.hub_irq_enable		= NULL,
+	/* .start_port_reset	= NULL, */
+	/* .hub_irq_enable	= NULL, */
 };
diff -ruN linux-omap-2.6/drivers/usb/musb/musb_host.h maemo_src/drivers/usb/musb/musb_host.h
--- linux-omap-2.6/drivers/usb/musb/musb_host.h	2011-02-06 20:17:25.889999940 -0500
+++ maemo_src/drivers/usb/musb/musb_host.h	2011-02-06 20:12:11.319999940 -0500
@@ -1,59 +1,58 @@
-/******************************************************************
+/*
+ * MUSB OTG driver host defines
+ *
  * Copyright 2005 Mentor Graphics Corporation
  * Copyright (C) 2005-2006 by Texas Instruments
+ * Copyright (C) 2006-2007 Nokia Corporation
  *
- * This file is part of the Inventra Controller Driver for Linux.
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
  *
- * The Inventra Controller Driver for Linux is free software; you
- * can redistribute it and/or modify it under the terms of the GNU
- * General Public License version 2 as published by the Free Software
- * Foundation.
- *
- * The Inventra Controller Driver for Linux is distributed in
- * the hope that it will be useful, but WITHOUT ANY WARRANTY;
- * without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
- * License for more details.
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with The Inventra Controller Driver for Linux ; if not,
- * write to the Free Software Foundation, Inc., 59 Temple Place,
- * Suite 330, Boston, MA  02111-1307  USA
- *
- * ANY DOWNLOAD, USE, REPRODUCTION, MODIFICATION OR DISTRIBUTION
- * OF THIS DRIVER INDICATES YOUR COMPLETE AND UNCONDITIONAL ACCEPTANCE
- * OF THOSE TERMS.THIS DRIVER IS PROVIDED "AS IS" AND MENTOR GRAPHICS
- * MAKES NO WARRANTIES, EXPRESS OR IMPLIED, RELATED TO THIS DRIVER.
- * MENTOR GRAPHICS SPECIFICALLY DISCLAIMS ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY; FITNESS FOR A PARTICULAR PURPOSE AND
- * NON-INFRINGEMENT.  MENTOR GRAPHICS DOES NOT PROVIDE SUPPORT
- * SERVICES OR UPDATES FOR THIS DRIVER, EVEN IF YOU ARE A MENTOR
- * GRAPHICS SUPPORT CUSTOMER.
- ******************************************************************/
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
 
 #ifndef _MUSB_HOST_H
 #define _MUSB_HOST_H
 
 static inline struct usb_hcd *musb_to_hcd(struct musb *musb)
 {
-	return (struct usb_hcd *) (((void *)musb)
-			- offsetof(struct usb_hcd, hcd_priv));
+	return container_of((void *) musb, struct usb_hcd, hcd_priv);
 }
 
 static inline struct musb *hcd_to_musb(struct usb_hcd *hcd)
 {
-	return (void *) hcd->hcd_priv;
+	return (struct musb *) (hcd->hcd_priv);
 }
 
-/* stored in "usb_host_endpoint.hcpriv" for scheduled endpoints
- */
+/* stored in "usb_host_endpoint.hcpriv" for scheduled endpoints */
 struct musb_qh {
 	struct usb_host_endpoint *hep;		/* usbcore info */
 	struct usb_device	*dev;
 	struct musb_hw_ep	*hw_ep;		/* current binding */
 
 	struct list_head	ring;		/* of musb_qh */
-	//struct musb_qh		*next;		/* for periodic tree */
+	/* struct musb_qh		*next; */	/* for periodic tree */
 
 	unsigned		offset;		/* in urb->transfer_buffer */
 	unsigned		segsize;	/* current xfer fragment */
@@ -77,7 +76,7 @@
 {
 	if (list_empty(q))
 		return NULL;
-	return container_of(q->next, struct musb_qh, ring);
+	return list_entry(q->next, struct musb_qh, ring);
 }
 
 
@@ -102,7 +101,7 @@
 	queue = &qh->hep->urb_list;
 	if (list_empty(queue))
 		return NULL;
-	return container_of(queue->next, struct urb, urb_list);
+	return list_entry(queue->next, struct urb, urb_list);
 #else
 	return NULL;
 #endif
diff -ruN linux-omap-2.6/drivers/usb/musb/musbhsdma.c maemo_src/drivers/usb/musb/musbhsdma.c
--- linux-omap-2.6/drivers/usb/musb/musbhsdma.c	2011-02-06 20:17:25.893333273 -0500
+++ maemo_src/drivers/usb/musb/musbhsdma.c	2011-02-06 20:12:11.266666606 -0500
@@ -1,364 +1,398 @@
-/******************************************************************
- * Copyright 2005 Mentor Graphics Corporation
- * Copyright (C) 2005-2006 by Texas Instruments
+/*
+ * MUSB OTG driver - support for Mentor's DMA controller
  *
- * This file is part of the Inventra Controller Driver for Linux.
+ * Copyright 2005 Mentor Graphics Corporation
+ * Copyright (C) 2005-2007 by Texas Instruments
  *
- * The Inventra Controller Driver for Linux is free software; you
- * can redistribute it and/or modify it under the terms of the GNU
- * General Public License version 2 as published by the Free Software
- * Foundation.
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
  *
- * The Inventra Controller Driver for Linux is distributed in
- * the hope that it will be useful, but WITHOUT ANY WARRANTY;
- * without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
- * License for more details.
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with The Inventra Controller Driver for Linux ; if not,
- * write to the Free Software Foundation, Inc., 59 Temple Place,
- * Suite 330, Boston, MA  02111-1307  USA
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
- * ANY DOWNLOAD, USE, REPRODUCTION, MODIFICATION OR DISTRIBUTION
- * OF THIS DRIVER INDICATES YOUR COMPLETE AND UNCONDITIONAL ACCEPTANCE
- * OF THOSE TERMS.THIS DRIVER IS PROVIDED "AS IS" AND MENTOR GRAPHICS
- * MAKES NO WARRANTIES, EXPRESS OR IMPLIED, RELATED TO THIS DRIVER.
- * MENTOR GRAPHICS SPECIFICALLY DISCLAIMS ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY; FITNESS FOR A PARTICULAR PURPOSE AND
- * NON-INFRINGEMENT.  MENTOR GRAPHICS DOES NOT PROVIDE SUPPORT
- * SERVICES OR UPDATES FOR THIS DRIVER, EVEN IF YOU ARE A MENTOR
- * GRAPHICS SUPPORT CUSTOMER.
- ******************************************************************/
-
-/*
- * Interface to Mentor's DMA engine
  */
-
+#include <linux/device.h>
+#include <linux/interrupt.h>
 #include <linux/platform_device.h>
+#include "musb_core.h"
 
-#include "musbdefs.h"
-
-
-/****************************** CONSTANTS ********************************/
-
-#define MGC_O_HSDMA_BASE    0x200
-#define MGC_O_HSDMA_INTR    0x200
+#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3430)
+#include "omap2430.h"
+#endif
 
-#define MGC_O_HSDMA_CONTROL 4
-#define MGC_O_HSDMA_ADDRESS 8
-#define MGC_O_HSDMA_COUNT   0xc
+#define MUSB_HSDMA_BASE		0x200
+#define MUSB_HSDMA_INTR		(MUSB_HSDMA_BASE + 0)
+#define MUSB_HSDMA_CONTROL		0x4
+#define MUSB_HSDMA_ADDRESS		0x8
+#define MUSB_HSDMA_COUNT		0xc
 
-#define MGC_HSDMA_CHANNEL_OFFSET(_bChannel, _bOffset)		\
-		(MGC_O_HSDMA_BASE + (_bChannel << 4) + _bOffset)
+#define MUSB_HSDMA_CHANNEL_OFFSET(_bChannel, _offset)		\
+		(MUSB_HSDMA_BASE + (_bChannel << 4) + _offset)
 
 /* control register (16-bit): */
-#define MGC_S_HSDMA_ENABLE	0
-#define MGC_S_HSDMA_TRANSMIT	1
-#define MGC_S_HSDMA_MODE1	2
-#define MGC_S_HSDMA_IRQENABLE	3
-#define MGC_S_HSDMA_ENDPOINT	4
-#define MGC_S_HSDMA_BUSERROR	8
-#define MGC_S_HSDMA_BURSTMODE	9
-#define MGC_M_HSDMA_BURSTMODE	(3 << MGC_S_HSDMA_BURSTMODE)
-#define MGC_HSDMA_BURSTMODE_UNSPEC  0
-#define MGC_HSDMA_BURSTMODE_INCR4   1
-#define MGC_HSDMA_BURSTMODE_INCR8   2
-#define MGC_HSDMA_BURSTMODE_INCR16  3
-
-#define MGC_HSDMA_CHANNELS 8
-
-/******************************* Types ********************************/
-
-struct hsdma_channel {
-	struct dma_channel Channel;
-	struct hsdma *pController;
-	u32 dwStartAddress;
-	u32 dwCount;
-	u8 bIndex;
-	u8 bEnd;
-	u8 bTransmit;
+#define MUSB_HSDMA_ENABLE_SHIFT		0
+#define MUSB_HSDMA_TRANSMIT_SHIFT		1
+#define MUSB_HSDMA_MODE1_SHIFT		2
+#define MUSB_HSDMA_IRQENABLE_SHIFT		3
+#define MUSB_HSDMA_ENDPOINT_SHIFT		4
+#define MUSB_HSDMA_BUSERROR_SHIFT		8
+#define MUSB_HSDMA_BURSTMODE_SHIFT		9
+#define MUSB_HSDMA_BURSTMODE		(3 << MUSB_HSDMA_BURSTMODE_SHIFT)
+#define MUSB_HSDMA_BURSTMODE_UNSPEC	0
+#define MUSB_HSDMA_BURSTMODE_INCR4	1
+#define MUSB_HSDMA_BURSTMODE_INCR8	2
+#define MUSB_HSDMA_BURSTMODE_INCR16	3
+
+#define MUSB_HSDMA_CHANNELS		8
+
+struct musb_dma_controller;
+
+struct musb_dma_channel {
+	struct dma_channel		Channel;
+	struct musb_dma_controller	*controller;
+	u32				dwStartAddress;
+	u32				len;
+	u16				wMaxPacketSize;
+	u8				bIndex;
+	u8				epnum;
+	u8				transmit;
 };
 
-struct hsdma {
-	struct dma_controller Controller;
-	struct hsdma_channel aChannel[MGC_HSDMA_CHANNELS];
-	void *pDmaPrivate;
-	void __iomem *pCoreBase;
-	u8 bChannelCount;
-	u8 bmUsedChannels;
+struct musb_dma_controller {
+	struct dma_controller		Controller;
+	struct musb_dma_channel		aChannel[MUSB_HSDMA_CHANNELS];
+	void				*pDmaPrivate;
+	void __iomem			*pCoreBase;
+	u8				bChannelCount;
+	u8				bmUsedChannels;
+	u8				irq;
 };
 
-/****************************** FUNCTIONS ********************************/
-
-static int hsdma_start(struct dma_controller *c)
+static int dma_controller_start(struct dma_controller *c)
 {
 	/* nothing to do */
 	return 0;
 }
 
-static int hsdma_stop(struct dma_controller *c)
+static void dma_channel_release(struct dma_channel *pChannel);
+
+static int dma_controller_stop(struct dma_controller *c)
 {
-	/* nothing to do */
+	struct musb_dma_controller *controller =
+		container_of(c, struct musb_dma_controller, Controller);
+	struct musb *musb = (struct musb *) controller->pDmaPrivate;
+	struct dma_channel *pChannel;
+	u8 bBit;
+
+	if (controller->bmUsedChannels != 0) {
+		dev_err(musb->controller,
+			"Stopping DMA controller while channel active\n");
+
+		for (bBit = 0; bBit < MUSB_HSDMA_CHANNELS; bBit++) {
+			if (controller->bmUsedChannels & (1 << bBit)) {
+				pChannel = &controller->aChannel[bBit].Channel;
+				dma_channel_release(pChannel);
+
+				if (!controller->bmUsedChannels)
+					break;
+			}
+		}
+	}
 	return 0;
 }
 
-static struct dma_channel *
-hsdma_channel_alloc(struct dma_controller *c,
-		struct musb_hw_ep *hw_ep,
-		u8 bTransmit)
+static struct dma_channel *dma_channel_allocate(struct dma_controller *c,
+				struct musb_hw_ep *hw_ep, u8 transmit)
 {
 	u8 bBit;
 	struct dma_channel *pChannel = NULL;
-	struct hsdma_channel *pImplChannel = NULL;
-	struct hsdma *pController;
-
-	pController = container_of(c, struct hsdma, Controller);
-	for (bBit = 0; bBit < MGC_HSDMA_CHANNELS; bBit++) {
-		if (!(pController->bmUsedChannels & (1 << bBit))) {
-			pController->bmUsedChannels |= (1 << bBit);
-			pImplChannel = &(pController->aChannel[bBit]);
-			pImplChannel->pController = pController;
+	struct musb_dma_channel *pImplChannel = NULL;
+	struct musb_dma_controller *controller =
+			container_of(c, struct musb_dma_controller, Controller);
+
+	for (bBit = 0; bBit < MUSB_HSDMA_CHANNELS; bBit++) {
+		if (!(controller->bmUsedChannels & (1 << bBit))) {
+			controller->bmUsedChannels |= (1 << bBit);
+			pImplChannel = &(controller->aChannel[bBit]);
+			pImplChannel->controller = controller;
 			pImplChannel->bIndex = bBit;
-			pImplChannel->bEnd = hw_ep->bLocalEnd;
-			pImplChannel->bTransmit = bTransmit;
+			pImplChannel->epnum = hw_ep->epnum;
+			pImplChannel->transmit = transmit;
 			pChannel = &(pImplChannel->Channel);
-			pChannel->pPrivateData = pImplChannel;
-			pChannel->bStatus = MGC_DMA_STATUS_FREE;
-			pChannel->dwMaxLength = 0x10000;
+			pChannel->private_data = pImplChannel;
+			pChannel->status = MUSB_DMA_STATUS_FREE;
+			pChannel->max_len = 0x10000;
 			/* Tx => mode 1; Rx => mode 0 */
-			pChannel->bDesiredMode = bTransmit;
-			pChannel->dwActualLength = 0;
+			pChannel->desired_mode = transmit;
+			pChannel->actual_len = 0;
 			break;
 		}
 	}
 	return pChannel;
 }
 
-static void hsdma_channel_release(struct dma_channel *pChannel)
+static void dma_channel_release(struct dma_channel *pChannel)
 {
-	struct hsdma_channel *pImplChannel = pChannel->pPrivateData;
+	struct musb_dma_channel *pImplChannel =
+		(struct musb_dma_channel *) pChannel->private_data;
 
-	pImplChannel->pController->bmUsedChannels &=
-	    ~(1 << pImplChannel->bIndex);
-	pChannel->bStatus = MGC_DMA_STATUS_FREE;
-}
-
-static void clear_state(struct dma_channel *pChannel)
-{
-	struct hsdma_channel *pImplChannel = pChannel->pPrivateData;
-	struct hsdma *pController = pImplChannel->pController;
-	u8 *pBase = pController->pCoreBase;
-	u8 bChannel = pImplChannel->bIndex;
+	pChannel->actual_len = 0;
+	pImplChannel->dwStartAddress = 0;
+	pImplChannel->len = 0;
 
-	musb_writew(pBase,
-		    MGC_HSDMA_CHANNEL_OFFSET(bChannel, MGC_O_HSDMA_CONTROL),
-		    0);
-	musb_writel(pBase,
-		    MGC_HSDMA_CHANNEL_OFFSET(bChannel, MGC_O_HSDMA_ADDRESS),
-		    0);
-	musb_writel(pBase,
-		    MGC_HSDMA_CHANNEL_OFFSET(bChannel, MGC_O_HSDMA_COUNT),
-		    0);
+	pImplChannel->controller->bmUsedChannels &=
+		~(1 << pImplChannel->bIndex);
 
-	pChannel->dwActualLength = 0L;
-	pImplChannel->dwStartAddress = 0;
-	pImplChannel->dwCount = 0;
+	pChannel->status = MUSB_DMA_STATUS_UNKNOWN;
 }
 
-static u8 configure_channel(struct dma_channel *pChannel,
-				  u16 wPacketSize, u8 bMode,
-				  dma_addr_t dma_addr, u32 dwLength)
+static void configure_channel(struct dma_channel *pChannel,
+				u16 packet_sz, u8 mode,
+				dma_addr_t dma_addr, u32 len)
 {
-	struct hsdma_channel *pImplChannel = pChannel->pPrivateData;
-	struct hsdma *pController = pImplChannel->pController;
-	u8 *pBase = pController->pCoreBase;
+	struct musb_dma_channel *pImplChannel =
+		(struct musb_dma_channel *) pChannel->private_data;
+	struct musb_dma_controller *controller = pImplChannel->controller;
+	void __iomem *mbase = controller->pCoreBase;
 	u8 bChannel = pImplChannel->bIndex;
-	u16 wCsr = 0;
+	u16 csr = 0;
 
-	DBG(2, "%p, pkt_sz %d, addr 0x%x, len %d, mode %d\n",
-	    pChannel, wPacketSize, dma_addr, dwLength, bMode);
+	DBG(4, "%p, pkt_sz %d, addr 0x%x, len %d, mode %d\n",
+			pChannel, packet_sz, dma_addr, len, mode);
 
-	if (bMode) {
-		wCsr |= 1 << MGC_S_HSDMA_MODE1;
-		if (dwLength < wPacketSize) {
-			return FALSE;
-		}
-		if (wPacketSize >= 64) {
-			wCsr |=
-			    MGC_HSDMA_BURSTMODE_INCR16 << MGC_S_HSDMA_BURSTMODE;
-		} else if (wPacketSize >= 32) {
-			wCsr |=
-			    MGC_HSDMA_BURSTMODE_INCR8 << MGC_S_HSDMA_BURSTMODE;
-		} else if (wPacketSize >= 16) {
-			wCsr |=
-			    MGC_HSDMA_BURSTMODE_INCR4 << MGC_S_HSDMA_BURSTMODE;
+	if (mode) {
+		csr |= 1 << MUSB_HSDMA_MODE1_SHIFT;
+		BUG_ON(len < packet_sz);
+
+		if (packet_sz >= 64) {
+			csr |= MUSB_HSDMA_BURSTMODE_INCR16
+					<< MUSB_HSDMA_BURSTMODE_SHIFT;
+		} else if (packet_sz >= 32) {
+			csr |= MUSB_HSDMA_BURSTMODE_INCR8
+					<< MUSB_HSDMA_BURSTMODE_SHIFT;
+		} else if (packet_sz >= 16) {
+			csr |= MUSB_HSDMA_BURSTMODE_INCR4
+					<< MUSB_HSDMA_BURSTMODE_SHIFT;
 		}
 	}
 
-	wCsr |= (pImplChannel->bEnd << MGC_S_HSDMA_ENDPOINT)
-		| (1 << MGC_S_HSDMA_ENABLE)
-		| (1 << MGC_S_HSDMA_IRQENABLE)
-		| (pImplChannel->bTransmit ? (1 << MGC_S_HSDMA_TRANSMIT) : 0);
+	csr |= (pImplChannel->epnum << MUSB_HSDMA_ENDPOINT_SHIFT)
+		| (1 << MUSB_HSDMA_ENABLE_SHIFT)
+		| (1 << MUSB_HSDMA_IRQENABLE_SHIFT)
+		| (pImplChannel->transmit
+				? (1 << MUSB_HSDMA_TRANSMIT_SHIFT)
+				: 0);
 
 	/* address/count */
-	musb_writel(pBase,
-		    MGC_HSDMA_CHANNEL_OFFSET(bChannel, MGC_O_HSDMA_ADDRESS),
-		    dma_addr);
-	musb_writel(pBase,
-		    MGC_HSDMA_CHANNEL_OFFSET(bChannel, MGC_O_HSDMA_COUNT),
-		    dwLength);
+	musb_writel(mbase,
+		MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_ADDRESS),
+		dma_addr);
+	musb_writel(mbase,
+		MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_COUNT),
+		len);
 
 	/* control (this should start things) */
-	musb_writew(pBase,
-		    MGC_HSDMA_CHANNEL_OFFSET(bChannel, MGC_O_HSDMA_CONTROL),
-		    wCsr);
-
-	return TRUE;
+	musb_writew(mbase,
+		MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_CONTROL),
+		csr);
 }
 
-static int hsdma_channel_program(struct dma_channel * pChannel,
-				  u16 wPacketSize, u8 bMode,
-				  dma_addr_t dma_addr, u32 dwLength)
+static int dma_channel_program(struct dma_channel *pChannel,
+				u16 packet_sz, u8 mode,
+				dma_addr_t dma_addr, u32 len)
 {
-	struct hsdma_channel *pImplChannel = pChannel->pPrivateData;
+	struct musb_dma_channel *pImplChannel =
+			(struct musb_dma_channel *) pChannel->private_data;
 
-	DBG(2, "pkt_sz %d, dma_addr 0x%x length %d, mode %d\n",
-	       wPacketSize, dma_addr, dwLength, bMode);
+	DBG(2, "ep%d-%s pkt_sz %d, dma_addr 0x%x length %d, mode %d\n",
+		pImplChannel->epnum,
+		pImplChannel->transmit ? "Tx" : "Rx",
+		packet_sz, dma_addr, len, mode);
 
-	BUG_ON(pChannel->bStatus != MGC_DMA_STATUS_FREE);
+	BUG_ON(pChannel->status == MUSB_DMA_STATUS_UNKNOWN ||
+		pChannel->status == MUSB_DMA_STATUS_BUSY);
 
-	pChannel->dwActualLength = 0L;
+	pChannel->actual_len = 0;
 	pImplChannel->dwStartAddress = dma_addr;
-	pImplChannel->dwCount = dwLength;
+	pImplChannel->len = len;
+	pImplChannel->wMaxPacketSize = packet_sz;
+	pChannel->status = MUSB_DMA_STATUS_BUSY;
 
-	pChannel->bStatus = MGC_DMA_STATUS_BUSY;
+	if ((mode == 1) && (len >= packet_sz))
+		configure_channel(pChannel, packet_sz, 1, dma_addr, len);
+	else
+		configure_channel(pChannel, packet_sz, 0, dma_addr, len);
 
-	if ((bMode == 1) && (dwLength >= wPacketSize)) {
+	return true;
+}
 
-#if 0
-		/* mode 1 sends an extra IN token at the end of
-		 * full packet transfer in host Rx
-		 */
-		if (dwLength % wPacketSize == 0)
-			dwLength -= wPacketSize;
-
-		/* mode 1 doesn't give an interrupt on short packet */
-		configure_channel(pChannel, wPacketSize, 1, dma_addr,
-				  dwLength & ~(wPacketSize - 1));
-		/* the rest (<= pkt_size) will be transferred in mode 0 */
-#endif
+static int dma_channel_abort(struct dma_channel *pChannel)
+{
+	struct musb_dma_channel *pImplChannel =
+		(struct musb_dma_channel *) pChannel->private_data;
+	u8 bChannel = pImplChannel->bIndex;
+	void __iomem *mbase = pImplChannel->controller->pCoreBase;
+	u16 csr;
 
-		configure_channel(pChannel, wPacketSize, 1, dma_addr,
-				  dwLength);
+	if (pChannel->status == MUSB_DMA_STATUS_BUSY) {
+		if (pImplChannel->transmit) {
 
-	} else
-		configure_channel(pChannel, wPacketSize, 0, dma_addr,
-				  dwLength);
+			csr = musb_readw(mbase,
+				MUSB_EP_OFFSET(pImplChannel->epnum, MUSB_TXCSR));
+			csr &= ~(MUSB_TXCSR_AUTOSET |
+				 MUSB_TXCSR_DMAENAB |
+				 MUSB_TXCSR_DMAMODE);
+			musb_writew(mbase,
+				MUSB_EP_OFFSET(pImplChannel->epnum, MUSB_TXCSR),
+				csr);
+		} else {
+			csr = musb_readw(mbase,
+				MUSB_EP_OFFSET(pImplChannel->epnum, MUSB_RXCSR));
+			csr &= ~(MUSB_RXCSR_AUTOCLEAR |
+				 MUSB_RXCSR_DMAENAB |
+				 MUSB_RXCSR_DMAMODE);
+			musb_writew(mbase,
+				MUSB_EP_OFFSET(pImplChannel->epnum, MUSB_RXCSR),
+				csr);
+		}
 
-	return TRUE;
-}
+		musb_writew(mbase,
+			MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_CONTROL),
+			0);
+		musb_writel(mbase,
+			MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_ADDRESS),
+			0);
+		musb_writel(mbase,
+			MUSB_HSDMA_CHANNEL_OFFSET(bChannel, MUSB_HSDMA_COUNT),
+			0);
 
-// REVISIT...
-static int hsdma_channel_abort(struct dma_channel *pChannel)
-{
-	clear_state(pChannel);
-	pChannel->bStatus = MGC_DMA_STATUS_FREE;
+		pChannel->status = MUSB_DMA_STATUS_FREE;
+	}
 	return 0;
 }
 
-static irqreturn_t hsdma_irq(int irq, void *pPrivateData)
+static irqreturn_t dma_controller_irq(int irq, void *private_data)
 {
+	struct musb_dma_controller *controller =
+		(struct musb_dma_controller *)private_data;
+	struct musb_dma_channel *pImplChannel;
+	struct musb *musb = controller->pDmaPrivate;
+	void __iomem *mbase = controller->pCoreBase;
+	struct dma_channel *pChannel;
 	u8 bChannel;
-	u16 wCsr;
+	u16 csr;
 	u32 dwAddress;
-	struct hsdma_channel *pImplChannel;
-	struct hsdma *pController = pPrivateData;
-	u8 *pBase = pController->pCoreBase;
-	struct dma_channel *pChannel;
-	u8 bIntr = musb_readb(pBase, MGC_O_HSDMA_INTR);
-
-	if (!bIntr)
-		return IRQ_NONE;
-
-	for (bChannel = 0; bChannel < MGC_HSDMA_CHANNELS; bChannel++) {
-		if (bIntr & (1 << bChannel)) {
-
-			pImplChannel = &pController->aChannel[bChannel];
+	u8 int_hsdma;
+	irqreturn_t retval = IRQ_NONE;
+	unsigned long flags;
+
+	spin_lock_irqsave(&musb->lock, flags);
+
+	int_hsdma = musb_readb(mbase, MUSB_HSDMA_INTR);
+	if (!int_hsdma)
+		goto done;
+
+	for (bChannel = 0; bChannel < MUSB_HSDMA_CHANNELS; bChannel++) {
+		if (int_hsdma & (1 << bChannel)) {
+			pImplChannel = (struct musb_dma_channel *)
+					&(controller->aChannel[bChannel]);
 			pChannel = &pImplChannel->Channel;
 
-			wCsr = musb_readw(pBase,
-				       MGC_HSDMA_CHANNEL_OFFSET(bChannel,
-							MGC_O_HSDMA_CONTROL));
-
-			if (wCsr & (1 << MGC_S_HSDMA_BUSERROR)) {
-				pImplChannel->Channel.bStatus =
-				    MGC_DMA_STATUS_BUS_ABORT;
-			} else {
-				dwAddress = musb_readl(pBase,
-						       MGC_HSDMA_CHANNEL_OFFSET
-						       (bChannel,
-							MGC_O_HSDMA_ADDRESS));
-				pChannel->dwActualLength =
-				    dwAddress - pImplChannel->dwStartAddress;
+			csr = musb_readw(mbase,
+					MUSB_HSDMA_CHANNEL_OFFSET(bChannel,
+							MUSB_HSDMA_CONTROL));
+
+			if (csr & (1 << MUSB_HSDMA_BUSERROR_SHIFT))
+				pImplChannel->Channel.status =
+					MUSB_DMA_STATUS_BUS_ABORT;
+			else {
+				dwAddress = musb_readl(mbase,
+						MUSB_HSDMA_CHANNEL_OFFSET(
+							bChannel,
+							MUSB_HSDMA_ADDRESS));
+				pChannel->actual_len = dwAddress
+					- pImplChannel->dwStartAddress;
 
 				DBG(2, "ch %p, 0x%x -> 0x%x (%d / %d) %s\n",
-				    pChannel, pImplChannel->dwStartAddress,
-				    dwAddress, pChannel->dwActualLength,
-				    pImplChannel->dwCount,
-				    (pChannel->dwActualLength <
-					pImplChannel->dwCount) ?
+					pChannel, pImplChannel->dwStartAddress,
+					dwAddress, pChannel->actual_len,
+					pImplChannel->len,
+					(pChannel->actual_len
+						< pImplChannel->len) ?
 					"=> reconfig 0": "=> complete");
-#if 0
-				if (pChannel->dwActualLength <
-				    pImplChannel->dwCount) {
-					/* mode 1 sends an extra IN request if
-					the last packet is a complete packet */
-					u16 newcsr = MGC_ReadCsr16(pBase,
-							MGC_O_HDRC_RXCSR,
-							pImplChannel->bEnd);
-					newcsr &= ~(MGC_M_RXCSR_H_AUTOREQ |
-						    MGC_M_RXCSR_H_REQPKT);
-					MGC_WriteCsr16(pBase, MGC_O_HDRC_RXCSR,
-						       pImplChannel->bEnd,
-						       MGC_M_RXCSR_H_WZC_BITS |
-								newcsr);
-
-					configure_channel(pChannel,
-						pImplChannel->wMaxPacketSize,
-						0, dwAddress,
-						pImplChannel->dwCount -
-						    pChannel->dwActualLength);
-				}
-				else
-#endif
-				{
-					pChannel->bStatus = MGC_DMA_STATUS_FREE;
-					/* completed */
+
+				u8 devctl = musb_readb(mbase,
+						MUSB_DEVCTL);
+
+				pChannel->status = MUSB_DMA_STATUS_FREE;
+
+				/* completed */
+				if ((devctl & MUSB_DEVCTL_HM)
+					&& (pImplChannel->transmit)
+					&& ((pChannel->desired_mode == 0)
+					    || (pChannel->actual_len &
+					    (pImplChannel->wMaxPacketSize - 1)))
+					 ) {
+					/* Send out the packet */
+					musb_ep_select(mbase,
+						pImplChannel->epnum);
+					musb_writew(mbase, MUSB_EP_OFFSET(
+							pImplChannel->epnum,
+							MUSB_TXCSR),
+						MUSB_TXCSR_TXPKTRDY);
+				} else
 					musb_dma_completion(
-						pController->pDmaPrivate,
-						pImplChannel->bEnd,
-						pImplChannel->bTransmit);
-				}
+						musb,
+						pImplChannel->epnum,
+						pImplChannel->transmit);
 			}
 		}
 	}
-	return IRQ_HANDLED;
+	retval = IRQ_HANDLED;
+done:
+	spin_unlock_irqrestore(&musb->lock, flags);
+	return retval;
 }
 
-void dma_controller_destroy(struct dma_controller *pController)
+void dma_controller_destroy(struct dma_controller *c)
 {
-	struct hsdma *pHsController = pController->pPrivateData;
+	struct musb_dma_controller *controller =
+		(struct musb_dma_controller *) c->private_data;
 
-	pHsController->Controller.pPrivateData = NULL;
-	kfree(pHsController);
+	if (!controller)
+		return;
+
+	if (controller->irq)
+		free_irq(controller->irq, c);
+
+	kfree(controller);
+	c->private_data = NULL;
 }
 
 struct dma_controller *__init
-dma_controller_create(struct musb *pThis, void __iomem *pCoreBase)
+dma_controller_create(struct musb *musb, void __iomem *pCoreBase)
 {
-	struct hsdma *pController;
-	struct device *dev = pThis->controller;
+	struct musb_dma_controller *controller;
+	struct device *dev = musb->controller;
 	struct platform_device *pdev = to_platform_device(dev);
 	int irq = platform_get_irq(pdev, 1);
 
@@ -367,27 +401,30 @@
 		return NULL;
 	}
 
-	if (!(pController = kzalloc(sizeof *pController, GFP_KERNEL)))
+	controller = kzalloc(sizeof(struct musb_dma_controller), GFP_KERNEL);
+	if (!controller)
 		return NULL;
 
-	pController->bChannelCount = MGC_HSDMA_CHANNELS;
-	pController->pDmaPrivate = pThis;
-	pController->pCoreBase = pCoreBase;
-
-	pController->Controller.pPrivateData = pController;
-	pController->Controller.start = hsdma_start;
-	pController->Controller.stop = hsdma_stop;
-	pController->Controller.channel_alloc = hsdma_channel_alloc;
-	pController->Controller.channel_release = hsdma_channel_release;
-	pController->Controller.channel_program = hsdma_channel_program;
-	pController->Controller.channel_abort = hsdma_channel_abort;
+	controller->bChannelCount = MUSB_HSDMA_CHANNELS;
+	controller->pDmaPrivate = musb;
+	controller->pCoreBase = pCoreBase;
+
+	controller->Controller.private_data = controller;
+	controller->Controller.start = dma_controller_start;
+	controller->Controller.stop = dma_controller_stop;
+	controller->Controller.channel_alloc = dma_channel_allocate;
+	controller->Controller.channel_release = dma_channel_release;
+	controller->Controller.channel_program = dma_channel_program;
+	controller->Controller.channel_abort = dma_channel_abort;
 
-	if (request_irq(irq, hsdma_irq, IRQF_DISABLED,
-			pThis->controller->bus_id, &pController->Controller)) {
+	if (request_irq(irq, dma_controller_irq, IRQF_DISABLED,
+			musb->controller->bus_id, &controller->Controller)) {
 		dev_err(dev, "request_irq %d failed!\n", irq);
-		kfree(pController);
+		dma_controller_destroy(&controller->Controller);
 		return NULL;
 	}
 
-	return &pController->Controller;
+	controller->irq = irq;
+
+	return &controller->Controller;
 }
diff -ruN linux-omap-2.6/drivers/usb/musb/musb_hset.c maemo_src/drivers/usb/musb/musb_hset.c
--- linux-omap-2.6/drivers/usb/musb/musb_hset.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/usb/musb/musb_hset.c	2011-02-06 20:12:11.266666606 -0500
@@ -0,0 +1,531 @@
+/*
+ * HS USB Host-mode HSET driver for Mentor USB Controller
+ *
+ * Copyright (C) 2007 Texas Instruments, Inc.
+ * Copyright 2005 Mentor Graphics Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2.
+ *
+ * This driver is based on the USB Skeleton driver-2.0
+ * (drivers/usb/usb-skeleton.c) written by Greg Kroah-Hartman (greg@kroah.com)
+ *
+ * Notes:
+ * There are 2 ways this driver can be used:
+ *	1 - By attaching a HS OPT (OTG Protocol Tester) card.
+ *	    The OPT test application contains scripts to test each mode.
+ *	    Each script attaches the OPT with a distinct VID/PID. Depending on
+ *	    the VID/PID this driver go into a particular test mode.
+ *	2 - Through /proc/drivers/musb_HSET interface.
+ *	    This is a forceful method, and rather more useful.
+ *	    Any USB device can be attached to the Host.
+ */
+
+//#include <linux/config.h>
+#include <linux/platform_device.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/usb.h>
+#include <linux/timer.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <asm/uaccess.h>
+#include <linux/workqueue.h>
+#include "../core/usb.h"
+#include "musb_core.h"
+#include "musb_regs.h"
+
+/*---------------------------------------------------------------------------*/
+/* This is the list of VID/PID that the HS OPT card will use. */
+static struct usb_device_id hset_table [] = {
+#ifdef MUSB_HSET_TESTING
+	//Without the OPT card, Netchip is used to verify the driver flow
+	{ USB_DEVICE(0x0525, 0xa4a0)},
+#endif
+	{ USB_DEVICE(6666, 0x0101) },	/* TEST_SE0_NAK */
+	{ USB_DEVICE(6666, 0x0102) },	/* TEST_J */
+	{ USB_DEVICE(6666, 0x0103) },	/* TEST_K */
+	{ USB_DEVICE(6666, 0x0104) },	/* TEST_PACKET */
+	{ USB_DEVICE(6666, 0x0105) },	/* TEST_FORCE_ENABLE */
+	{ USB_DEVICE(6666, 0x0106) },	/* HS_HOST_PORT_SUSPEND_RESUME */
+	{ USB_DEVICE(6666, 0x0107) },	/* SINGLE_STEP_GET_DEV_DESC */
+	{ USB_DEVICE(6666, 0x0108) },	/* SINGLE_STEP_SET_FEATURE */
+	{ }				/* Terminating entry */
+};
+MODULE_DEVICE_TABLE (usb, hset_table);
+
+/* Structure to hold all of our device specific stuff */
+struct usb_hset {
+	struct usb_device	*udev;	/* the usb device for this device */
+	struct usb_interface	*interface; /* the interface for this device */
+	struct kref		kref;
+	struct musb		*musb; /* the controller */
+	struct proc_dir_entry	*pde;
+};
+#define to_hset_dev(d) container_of(d, struct usb_hset, kref)
+
+static struct usb_hset *the_hset;
+static struct usb_driver hset_driver;
+static struct proc_dir_entry
+	*hset_proc_create(char *name, struct usb_hset *hset);
+static void hset_proc_delete(char *name, struct usb_hset *hset);
+
+/*---------------------------------------------------------------------------*/
+/* Test routines */
+
+static void test_musb(struct musb *musb, u8 mode)
+{
+	void __iomem *mbase = musb->mregs;
+
+
+	/* ensure we have no garbage left in test_mode register */
+	musb_writeb(mbase, MUSB_TESTMODE, 0x0);
+
+	/* we need to manualy set session bit or musb won't
+	 * work fine in host role */
+	musb_writeb(mbase, MUSB_DEVCTL, MUSB_DEVCTL_SESSION);
+
+	if (mode == MUSB_TEST_PACKET) {
+		musb_load_testpacket(musb);
+		musb_writeb(mbase, MUSB_TESTMODE,
+				MUSB_TEST_PACKET);
+	} else {
+		musb_writeb(mbase, MUSB_TESTMODE, mode);
+	}
+}
+
+static inline void test_se0_nak(struct usb_hset *hset)
+{
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	test_musb(hset->musb, MUSB_TEST_SE0_NAK);
+}
+
+static inline void test_j(struct usb_hset *hset)
+{
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	test_musb(hset->musb, MUSB_TEST_J);
+}
+
+static inline void test_k(struct usb_hset *hset)
+{
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	test_musb(hset->musb, MUSB_TEST_K);
+}
+
+static inline void test_packet(struct usb_hset *hset)
+{
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	test_musb(hset->musb, MUSB_TEST_PACKET);
+}
+
+static inline void test_force_enable(struct usb_hset *hset)
+{
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	test_musb(hset->musb, MUSB_TEST_FORCE_HOST);
+}
+
+static void suspend(struct usb_hset *hset)
+{
+	struct musb *musb = hset->musb;
+	void __iomem *pBase = musb->mregs;
+	u8 power;
+
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	power = musb_readb(pBase, MUSB_POWER);
+	musb_writeb(pBase, MUSB_POWER, power | MUSB_POWER_SUSPENDM);
+}
+
+static void resume(struct usb_hset *hset)
+{
+	struct musb *musb = hset->musb;
+	void __iomem *pBase = musb->mregs;
+	u8 power;
+
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	power = musb_readb(pBase, MUSB_POWER);
+	if (power & MUSB_POWER_SUSPENDM) {
+		power &= ~(MUSB_POWER_SUSPENDM | MUSB_POWER_RESUME);
+		musb_writeb(pBase, MUSB_POWER, power | MUSB_POWER_RESUME);
+		msleep(20);
+		power = musb_readb(pBase, MUSB_POWER);
+		musb_writeb(pBase, MUSB_POWER, power & ~MUSB_POWER_RESUME);
+	} else
+		printk(KERN_DEBUG "not suspended??\n");
+}
+
+static void test_suspend_resume(struct usb_hset *hset)
+{
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	suspend(hset);
+	msleep(15000);	/* Wait for 15 sec */
+	resume(hset);
+}
+
+static void test_single_step_get_dev_desc(struct usb_hset *hset)
+{
+	struct musb *musb = hset->musb;
+	struct usb_device *udev;
+	struct usb_bus *bus = hcd_to_bus(musb_to_hcd(musb));
+
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	if (!musb || !bus || !bus->root_hub) {
+		printk(KERN_ERR "Host controller not ready!\n");
+		return;
+	}
+	udev = bus->root_hub->children[0];
+	if (!udev) {
+		printk(KERN_DEBUG "No device connected.\n");
+		return;
+	}
+	usb_get_device_descriptor(udev, sizeof(struct usb_device_descriptor));
+}
+
+static void test_single_step_set_feature(struct usb_hset *hset)
+{
+	struct musb *musb = hset->musb;
+	struct usb_device *udev;
+	struct usb_bus *bus = hcd_to_bus(musb_to_hcd(musb));
+
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	if (!musb || !bus || !bus->root_hub) {
+		printk(KERN_ERR "Host controller not ready!\n");
+		return;
+	}
+
+	udev = bus->root_hub->children[0];
+	if (!udev) {
+		printk(KERN_DEBUG "No device connected.\n");
+		return;
+	}
+	usb_control_msg(udev,
+			usb_sndctrlpipe(udev, 0),
+			USB_REQ_SET_FEATURE, 0, 0,
+			0, NULL, 0, HZ * USB_CTRL_SET_TIMEOUT);
+}
+
+static void enumerate_bus(struct work_struct *work)
+{
+	struct usb_hset *hset = the_hset;
+	struct musb *musb = hset->musb;
+	struct usb_device *udev;
+	struct usb_bus *bus = hcd_to_bus(musb_to_hcd(musb));
+
+	printk(KERN_INFO "%s\n", __FUNCTION__);
+	if (!musb || !bus || !bus->root_hub) {
+		printk(KERN_ERR "Host controller not ready!\n");
+		return;
+	}
+	udev = bus->root_hub->children[0];
+	if (udev)
+		usb_reset_device(udev);
+}
+DECLARE_WORK(enumerate, enumerate_bus);
+
+/*---------------------------------------------------------------------------*/
+
+/* This function can be called either by musb_init_hset() or usb_hset_probe().
+ * musb_init_hset() is called by the controller driver during its init(),
+ * while usb_hset_probe() is called when an OPT is attached. We take care not
+ * to allocate the usb_hset structure twice.
+ */
+static struct usb_hset *init_hset_dev(void *controller)
+{
+	struct usb_hset *hset = NULL;
+
+	/* if already allocated, just increment use count and return */
+	if (the_hset) {
+		kref_get(&the_hset->kref);
+		return the_hset;
+	}
+
+	hset = kmalloc(sizeof(*hset), GFP_KERNEL);
+	if (hset == NULL) {
+		err("Out of memory");
+		return NULL;
+	}
+	memset(hset, 0x00, sizeof(*hset));
+	hset->musb = (struct musb *)(controller);
+
+	kref_init(&hset->kref);
+	the_hset = hset;
+	return hset;
+}
+
+static void hset_delete(struct kref *kref)
+{
+	struct usb_hset *dev = to_hset_dev(kref);
+
+	kfree (dev);
+}
+/*---------------------------------------------------------------------------*/
+/* Usage of HS OPT */
+
+static inline struct musb *dev_to_musb(struct device *dev)
+{
+#ifdef CONFIG_USB_MUSB_HDRC_HCD
+        /* usbcore insists dev->driver_data is a "struct hcd *" */
+        return hcd_to_musb(dev_get_drvdata(dev));
+#else
+        return dev_get_drvdata(dev);
+#endif
+}
+
+/* Called when the HS OPT is attached as a device */
+static int hset_probe(struct usb_interface *interface,
+		      const struct usb_device_id *id)
+{
+	struct usb_hset *hset;
+	struct usb_device *udev;
+	struct usb_hcd *hcd;
+	int retval = -ENOMEM;
+
+	udev = usb_get_dev(interface_to_usbdev(interface));
+	hcd = udev->bus->controller->driver_data;
+	hset = init_hset_dev(hcd->hcd_priv);
+	if (!hset)
+		return retval;
+
+	hset->udev = udev;
+	hset->interface = interface;
+	usb_set_intfdata(interface, hset);
+
+	switch(id->idProduct) {
+#ifdef MUSB_HSET_TESTING
+	case 0xa4a0:
+		test_packet(hset);
+		break;
+#endif
+	case 0x0101:
+		test_se0_nak(hset);
+		break;
+	case 0x0102:
+		test_j(hset);
+		break;
+	case 0x0103:
+		test_k(hset);
+		break;
+	case 0x0104:
+		test_packet(hset);
+		break;
+	case 0x0105:
+		test_force_enable(hset);
+		break;
+	case 0x0106:
+		test_suspend_resume(hset);
+		break;
+	case 0x0107:
+		msleep(15000);	/* SOFs for 15 sec */
+		test_single_step_get_dev_desc(hset);
+		break;
+	case 0x0108:
+		test_single_step_get_dev_desc(hset);
+		msleep(15000);	/* SOFs for 15 sec */
+		test_single_step_set_feature(hset);
+		break;
+	};
+	return 0;
+}
+
+static void hset_disconnect(struct usb_interface *interface)
+{
+	struct usb_hset *hset;
+
+	/* prevent hset_open() from racing hset_disconnect() */
+	lock_kernel();
+	hset = usb_get_intfdata(interface);
+	usb_set_intfdata(interface, NULL);
+	unlock_kernel();
+
+	usb_put_dev(hset->udev);
+	kref_put(&hset->kref, hset_delete);
+}
+
+static struct usb_driver hset_driver = {
+//	.owner =	THIS_MODULE,
+	.name =		"hset",
+	.probe =	hset_probe,
+	.disconnect =	hset_disconnect,
+	.id_table =	hset_table,
+};
+
+MODULE_LICENSE("GPL");
+
+/*---------------------------------------------------------------------------*/
+/* Usage of /proc/driver/musb_hset interface */
+
+static char *hset_proc_entry = "driver/musb_hset";
+
+void musb_init_hset(struct musb *musb)
+{
+	struct usb_hset *hset;
+	int ret;
+
+	hset = init_hset_dev((void *)musb);
+
+	/* register this driver with the USB subsystem */
+	ret = usb_register(&hset_driver);
+	if (ret) {
+		printk(KERN_ERR "usb_register failed. Error number %d", ret);
+		return;
+	}
+
+	hset_proc_create(hset_proc_entry, hset);
+
+	return;
+}
+EXPORT_SYMBOL(musb_init_hset);
+
+void musb_exit_hset(struct musb *musb)
+{
+	struct usb_hset *hset = the_hset;
+
+	hset_proc_delete(hset_proc_entry, hset);
+	kref_put(&hset->kref, hset_delete);
+
+	/* deregister this driver with the USB subsystem */
+	usb_deregister(&hset_driver);
+}
+EXPORT_SYMBOL(musb_exit_hset);
+
+static int dump_menu(char *buffer)
+{
+	int count = 0;
+
+	*buffer = 0;
+	count = sprintf(buffer, "HOST-side high-speed electrical test modes:\n"
+				"J: Test_J\n"
+				"K: Test_K\n"
+				"S: Test_SE0_NAK\n"
+				"P: Test_PACKET\n"
+				"H: Test_FORCE_ENABLE\n"
+				"U: Test_SUSPEND_RESUME\n"
+				"G: Test_SINGLE_STEP_GET_DESC\n"
+				"F: Test_SINGLE_STEP_SET_FEATURE\n"
+				"E: Enumerate bus\n"
+				"D: Suspend bus\n"
+				"R: Resume bus\n"
+				"?: help menu\n");
+	if (count < 0)
+		return count;
+	buffer += count;
+	return count;
+}
+
+static int hset_proc_write(struct file *file, const char __user *buffer,
+			 unsigned long count, void *data)
+{
+	char cmd;
+	struct usb_hset *hset = (struct usb_hset *)data;
+	char help[500];
+	/* MOD_INC_USE_COUNT; */
+	/*if (hset->musb->asleep)
+		return EBUSY;*/
+
+	if(copy_from_user(&cmd, buffer, 1))
+		return -EFAULT;
+	switch (cmd) {
+	case 'S':
+		test_se0_nak(hset);
+		break;
+	case 'J':
+		test_j(hset);
+		break;
+	case 'K':
+		test_k(hset);
+		break;
+	case 'P':
+		test_packet(hset);
+		break;
+	case 'H':
+		test_force_enable(hset);
+		break;
+	case 'U':
+		test_suspend_resume(hset);
+		break;
+	case 'G':
+		test_single_step_get_dev_desc(hset);
+		break;
+	case 'F':
+		test_single_step_set_feature(hset);
+		break;
+	case 'E':
+		schedule_work(&enumerate);
+		break;
+	case 'D':
+		suspend(hset);
+		break;
+	case 'R':
+		resume(hset);
+		break;
+	case '?':
+		dump_menu(help);
+		printk(KERN_INFO "%s", help);
+		break;
+	default:
+		printk(KERN_ERR "Command %c not implemented\n", cmd);
+		break;
+	}
+
+	return count;
+}
+
+static int hset_proc_read(char *page, char **start,
+			off_t off, int count, int *eof, void *data)
+{
+	char *buffer = page;
+	int code = 0;
+
+	count -= off;
+	count -= 1;		/* for NUL at end */
+	if (count < 0)
+		return -EINVAL;
+
+	code = dump_menu(buffer);
+	if (code > 0) {
+		buffer += code;
+		count -= code;
+	}
+
+	*eof = 1;
+	return (buffer - page) - off;
+}
+
+void hset_proc_delete(char *name, struct usb_hset *hset)
+{
+	if (hset->pde)
+		remove_proc_entry(name, NULL);
+}
+
+struct proc_dir_entry *hset_proc_create(char *name, struct usb_hset *hset)
+{
+	struct proc_dir_entry	*pde;
+
+	/* FIXME convert everything to seq_file; then later, debugfs */
+
+	if (!name || !hset)
+		return NULL;
+
+	hset->pde = pde = create_proc_entry(name,
+				     S_IFREG | S_IRUGO | S_IWUSR, NULL);
+	if (pde) {
+		pde->data = (void *)hset;
+		// pde->owner = THIS_MODULE;
+
+		pde->read_proc = hset_proc_read;
+		pde->write_proc = hset_proc_write;
+
+		pde->size = 0;
+
+		pr_debug("Registered /proc/%s\n", name);
+	} else {
+		pr_debug("Cannot create a valid proc file entry");
+	}
+
+	return pde;
+}
+
diff -ruN linux-omap-2.6/drivers/usb/musb/musb_io.h maemo_src/drivers/usb/musb/musb_io.h
--- linux-omap-2.6/drivers/usb/musb/musb_io.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/usb/musb/musb_io.h	2011-02-06 20:12:11.316666607 -0500
@@ -0,0 +1,115 @@
+/*
+ * MUSB OTG driver register I/O
+ *
+ * Copyright 2005 Mentor Graphics Corporation
+ * Copyright (C) 2005-2006 by Texas Instruments
+ * Copyright (C) 2006-2007 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __MUSB_LINUX_PLATFORM_ARCH_H__
+#define __MUSB_LINUX_PLATFORM_ARCH_H__
+
+#include <linux/io.h>
+
+#ifndef	CONFIG_ARM
+static inline void readsl(const void __iomem *addr, void *buf, int len)
+	{ insl((unsigned long)addr, buf, len); }
+static inline void readsw(const void __iomem *addr, void *buf, int len)
+	{ insw((unsigned long)addr, buf, len); }
+static inline void readsb(const void __iomem *addr, void *buf, int len)
+	{ insb((unsigned long)addr, buf, len); }
+
+static inline void writesl(const void __iomem *addr, const void *buf, int len)
+	{ outsl((unsigned long)addr, buf, len); }
+static inline void writesw(const void __iomem *addr, const void *buf, int len)
+	{ outsw((unsigned long)addr, buf, len); }
+static inline void writesb(const void __iomem *addr, const void *buf, int len)
+	{ outsb((unsigned long)addr, buf, len); }
+
+#endif
+
+/* NOTE:  these offsets are all in bytes */
+
+static inline u16 musb_readw(const void __iomem *addr, unsigned offset)
+	{ return __raw_readw(addr + offset); }
+
+static inline u32 musb_readl(const void __iomem *addr, unsigned offset)
+	{ return __raw_readl(addr + offset); }
+
+
+static inline void musb_writew(void __iomem *addr, unsigned offset, u16 data)
+	{ __raw_writew(data, addr + offset); }
+
+static inline void musb_writel(void __iomem *addr, unsigned offset, u32 data)
+	{ __raw_writel(data, addr + offset); }
+
+
+#ifdef CONFIG_USB_TUSB6010
+
+/*
+ * TUSB6010 doesn't allow 8-bit access; 16-bit access is the minimum.
+ */
+static inline u8 musb_readb(const void __iomem *addr, unsigned offset)
+{
+	u16 tmp;
+	u8 val;
+
+	tmp = __raw_readw(addr + (offset & ~1));
+	if (offset & 1)
+		val = (tmp >> 8);
+	else
+		val = tmp & 0xff;
+
+	return val;
+}
+
+static inline void musb_writeb(void __iomem *addr, unsigned offset, u8 data)
+{
+	u16 tmp;
+
+	tmp = __raw_readw(addr + (offset & ~1));
+	if (offset & 1)
+		tmp = (data << 8) | (tmp & 0xff);
+	else
+		tmp = (tmp & 0xff00) | data;
+
+	__raw_writew(tmp, addr + (offset & ~1));
+}
+
+#else
+
+static inline u8 musb_readb(const void __iomem *addr, unsigned offset)
+	{ return __raw_readb(addr + offset); }
+
+static inline void musb_writeb(void __iomem *addr, unsigned offset, u8 data)
+	{ __raw_writeb(data, addr + offset); }
+
+#endif	/* CONFIG_USB_TUSB6010 */
+
+#endif
diff -ruN linux-omap-2.6/drivers/usb/musb/musb_procfs.c maemo_src/drivers/usb/musb/musb_procfs.c
--- linux-omap-2.6/drivers/usb/musb/musb_procfs.c	2011-02-06 20:17:25.889999940 -0500
+++ maemo_src/drivers/usb/musb/musb_procfs.c	2011-02-06 20:12:11.293333273 -0500
@@ -1,73 +1,47 @@
-/******************************************************************
+/*
+ * MUSB OTG driver debug support
+ *
  * Copyright 2005 Mentor Graphics Corporation
  * Copyright (C) 2005-2006 by Texas Instruments
+ * Copyright (C) 2006-2007 Nokia Corporation
  *
- * This file is part of the Inventra Controller Driver for Linux.
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
  *
- * The Inventra Controller Driver for Linux is free software; you
- * can redistribute it and/or modify it under the terms of the GNU
- * General Public License version 2 as published by the Free Software
- * Foundation.
- *
- * The Inventra Controller Driver for Linux is distributed in
- * the hope that it will be useful, but WITHOUT ANY WARRANTY;
- * without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
- * License for more details.
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with The Inventra Controller Driver for Linux ; if not,
- * write to the Free Software Foundation, Inc., 59 Temple Place,
- * Suite 330, Boston, MA  02111-1307  USA
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
  *
- * ANY DOWNLOAD, USE, REPRODUCTION, MODIFICATION OR DISTRIBUTION
- * OF THIS DRIVER INDICATES YOUR COMPLETE AND UNCONDITIONAL ACCEPTANCE
- * OF THOSE TERMS.THIS DRIVER IS PROVIDED "AS IS" AND MENTOR GRAPHICS
- * MAKES NO WARRANTIES, EXPRESS OR IMPLIED, RELATED TO THIS DRIVER.
- * MENTOR GRAPHICS SPECIFICALLY DISCLAIMS ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY; FITNESS FOR A PARTICULAR PURPOSE AND
- * NON-INFRINGEMENT.  MENTOR GRAPHICS DOES NOT PROVIDE SUPPORT
- * SERVICES OR UPDATES FOR THIS DRIVER, EVEN IF YOU ARE A MENTOR
- * GRAPHICS SUPPORT CUSTOMER.
- ******************************************************************/
-
-/*
- * Inventra Controller Driver (ICD) for Linux.
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
- * The code managing debug files (currently in procfs).
  */
 
 #include <linux/kernel.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
-#include <asm/uaccess.h>	/* FIXME remove procfs writes */
+#include <linux/uaccess.h>	/* FIXME remove procfs writes */
 #include <asm/arch/hardware.h>
 
-#include "musbdefs.h"
+#include "musb_core.h"
 
 #include "davinci.h"
 
-
-const char *otg_state_string(struct musb *musb)
-{
-	switch (musb->xceiv.state) {
-	case OTG_STATE_A_IDLE:		return "a_idle";
-	case OTG_STATE_A_WAIT_VRISE:	return "a_wait_vrise";
-	case OTG_STATE_A_WAIT_BCON:	return "a_wait_bcon";
-	case OTG_STATE_A_HOST:		return "a_host";
-	case OTG_STATE_A_SUSPEND:	return "a_suspend";
-	case OTG_STATE_A_PERIPHERAL:	return "a_peripheral";
-	case OTG_STATE_A_WAIT_VFALL:	return "a_wait_vfall";
-	case OTG_STATE_A_VBUS_ERR:	return "a_vbus_err";
-	case OTG_STATE_B_IDLE:		return "b_idle";
-	case OTG_STATE_B_SRP_INIT:	return "b_srp_init";
-	case OTG_STATE_B_PERIPHERAL:	return "b_peripheral";
-	case OTG_STATE_B_WAIT_ACON:	return "b_wait_acon";
-	case OTG_STATE_B_HOST:		return "b_host";
-	default:			return "UNDEFINED";
-	}
-}
-
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 
 static int dump_qh(struct musb_qh *qh, char *buf, unsigned max)
@@ -153,15 +127,15 @@
 
 		code = snprintf(buf, max,
 				"\n%s (hw%d): %s%s, csr %04x maxp %04x\n",
-				ep->name, ep->bEndNumber,
+				ep->name, ep->current_epnum,
 				mode, ep->dma ? " dma" : "",
 				musb_readw(regs,
-					(ep->is_in || !ep->bEndNumber)
-						? MGC_O_HDRC_TXCSR
-						: MGC_O_HDRC_RXCSR),
+					(ep->is_in || !ep->current_epnum)
+						? MUSB_TXCSR
+						: MUSB_RXCSR),
 				musb_readw(regs, ep->is_in
-						? MGC_O_HDRC_TXMAXP
-						: MGC_O_HDRC_RXMAXP)
+						? MUSB_TXMAXP
+						: MUSB_RXMAXP)
 				);
 		if (code <= 0)
 			break;
@@ -169,9 +143,9 @@
 		buf += code;
 		max -= code;
 
-		if (is_cppi_enabled() && ep->bEndNumber) {
-			unsigned	cppi = ep->bEndNumber - 1;
-			void __iomem	*base = ep->pThis->ctrl_base;
+		if (is_cppi_enabled() && ep->current_epnum) {
+			unsigned	cppi = ep->current_epnum - 1;
+			void __iomem	*base = ep->musb->ctrl_base;
 			unsigned	off1 = cppi << 2;
 			void __iomem	*ram = base;
 			char		tmp[16];
@@ -190,7 +164,7 @@
 					"%08x %08x, %08x %08x; "
 					"%08x %08x %08x .. %08x\n",
 				ep->is_in ? 'T' : 'R',
-				ep->bEndNumber - 1, tmp,
+				ep->current_epnum - 1, tmp,
 				musb_readl(ram, 0 * 4),
 				musb_readl(ram, 1 * 4),
 				musb_readl(ram, 2 * 4),
@@ -215,7 +189,7 @@
 			max -= code;
 			break;
 		}
-		list_for_each_entry (req, &ep->req_list, list) {
+		list_for_each_entry(req, &ep->req_list, list) {
 			code = snprintf(buf, max, "\treq %p, %s%s%d/%d\n",
 					req,
 					req->zero ? "zero, " : "",
@@ -227,41 +201,41 @@
 			buf += code;
 			max -= code;
 		}
-	} while(0);
+	} while (0);
 	return buf - buffer;
 }
 #endif
 
 static int
-dump_end_info(struct musb *pThis, u8 bEnd, char *aBuffer, unsigned max)
+dump_end_info(struct musb *musb, u8 epnum, char *aBuffer, unsigned max)
 {
 	int			code = 0;
 	char			*buf = aBuffer;
-	struct musb_hw_ep	*pEnd = &pThis->aLocalEnd[bEnd];
+	struct musb_hw_ep	*hw_ep = &musb->endpoints[epnum];
 
 	do {
-		MGC_SelectEnd(pThis->pRegs, bEnd);
+		musb_ep_select(musb->mregs, epnum);
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
-		if (is_host_active(pThis)) {
+		if (is_host_active(musb)) {
 			int		dump_rx, dump_tx;
-			void __iomem	*regs = pEnd->regs;
+			void __iomem	*regs = hw_ep->regs;
 
 			/* TEMPORARY (!) until we have a real periodic
 			 * schedule tree ...
 			 */
-			if (!bEnd) {
+			if (!epnum) {
 				/* control is shared, uses RX queue
 				 * but (mostly) shadowed tx registers
 				 */
-				dump_tx = !list_empty(&pThis->control);
+				dump_tx = !list_empty(&musb->control);
 				dump_rx = 0;
-			} else if (pEnd == pThis->bulk_ep) {
-				dump_tx = !list_empty(&pThis->out_bulk);
-				dump_rx = !list_empty(&pThis->in_bulk);
-			} else if (pThis->periodic[bEnd]) {
+			} else if (hw_ep == musb->bulk_ep) {
+				dump_tx = !list_empty(&musb->out_bulk);
+				dump_rx = !list_empty(&musb->in_bulk);
+			} else if (musb->periodic[epnum]) {
 				struct usb_host_endpoint	*hep;
 
-				hep = pThis->periodic[bEnd]->hep;
+				hep = musb->periodic[epnum]->hep;
 				dump_rx = hep->desc.bEndpointAddress
 						& USB_ENDPOINT_DIR_MASK;
 				dump_tx = !dump_rx;
@@ -276,23 +250,23 @@
 					"max %04x type %02x; "
 					"dev %d hub %d port %d"
 					"\n",
-					bEnd,
-					pEnd->rx_double_buffered
+					epnum,
+					hw_ep->rx_double_buffered
 						? "2buf" : "1buf",
-					musb_readw(regs, MGC_O_HDRC_RXCSR),
-					musb_readb(regs, MGC_O_HDRC_RXINTERVAL),
-					musb_readw(regs, MGC_O_HDRC_RXMAXP),
-					musb_readb(regs, MGC_O_HDRC_RXTYPE),
+					musb_readw(regs, MUSB_RXCSR),
+					musb_readb(regs, MUSB_RXINTERVAL),
+					musb_readw(regs, MUSB_RXMAXP),
+					musb_readb(regs, MUSB_RXTYPE),
 					/* FIXME:  assumes multipoint */
-					musb_readb(pThis->pRegs,
-						MGC_BUSCTL_OFFSET(bEnd,
-						MGC_O_HDRC_RXFUNCADDR)),
-					musb_readb(pThis->pRegs,
-						MGC_BUSCTL_OFFSET(bEnd,
-						MGC_O_HDRC_RXHUBADDR)),
-					musb_readb(pThis->pRegs,
-						MGC_BUSCTL_OFFSET(bEnd,
-						MGC_O_HDRC_RXHUBPORT))
+					musb_readb(musb->mregs,
+						MUSB_BUSCTL_OFFSET(epnum,
+						MUSB_RXFUNCADDR)),
+					musb_readb(musb->mregs,
+						MUSB_BUSCTL_OFFSET(epnum,
+						MUSB_RXHUBADDR)),
+					musb_readb(musb->mregs,
+						MUSB_BUSCTL_OFFSET(epnum,
+						MUSB_RXHUBPORT))
 					);
 				if (code <= 0)
 					break;
@@ -301,15 +275,15 @@
 				max -= code;
 
 				if (is_cppi_enabled()
-						&& bEnd
-						&& pEnd->rx_channel) {
-					unsigned	cppi = bEnd - 1;
+						&& epnum
+						&& hw_ep->rx_channel) {
+					unsigned	cppi = epnum - 1;
 					unsigned	off1 = cppi << 2;
 					void __iomem	*base;
 					void __iomem	*ram;
 					char		tmp[16];
 
-					base = pThis->ctrl_base;
+					base = musb->ctrl_base;
 					ram = DAVINCI_RXCPPI_STATERAM_OFFSET(
 							cppi) + base;
 					snprintf(tmp, sizeof tmp, "%d left, ",
@@ -337,18 +311,18 @@
 					max -= code;
 				}
 
-				if (pEnd == pThis->bulk_ep
+				if (hw_ep == musb->bulk_ep
 						&& !list_empty(
-							&pThis->in_bulk)) {
-					code = dump_queue(&pThis->in_bulk,
+							&musb->in_bulk)) {
+					code = dump_queue(&musb->in_bulk,
 							buf, max);
 					if (code <= 0)
 						break;
 					code = min(code, (int) max);
 					buf += code;
 					max -= code;
-				} else if (pThis->periodic[bEnd]) {
-					code = dump_qh(pThis->periodic[bEnd],
+				} else if (musb->periodic[epnum]) {
+					code = dump_qh(musb->periodic[epnum],
 							buf, max);
 					if (code <= 0)
 						break;
@@ -364,23 +338,23 @@
 					"max %04x type %02x; "
 					"dev %d hub %d port %d"
 					"\n",
-					bEnd,
-					pEnd->tx_double_buffered
+					epnum,
+					hw_ep->tx_double_buffered
 						? "2buf" : "1buf",
-					musb_readw(regs, MGC_O_HDRC_TXCSR),
-					musb_readb(regs, MGC_O_HDRC_TXINTERVAL),
-					musb_readw(regs, MGC_O_HDRC_TXMAXP),
-					musb_readb(regs, MGC_O_HDRC_TXTYPE),
+					musb_readw(regs, MUSB_TXCSR),
+					musb_readb(regs, MUSB_TXINTERVAL),
+					musb_readw(regs, MUSB_TXMAXP),
+					musb_readb(regs, MUSB_TXTYPE),
 					/* FIXME:  assumes multipoint */
-					musb_readb(pThis->pRegs,
-						MGC_BUSCTL_OFFSET(bEnd,
-						MGC_O_HDRC_TXFUNCADDR)),
-					musb_readb(pThis->pRegs,
-						MGC_BUSCTL_OFFSET(bEnd,
-						MGC_O_HDRC_TXHUBADDR)),
-					musb_readb(pThis->pRegs,
-						MGC_BUSCTL_OFFSET(bEnd,
-						MGC_O_HDRC_TXHUBPORT))
+					musb_readb(musb->mregs,
+						MUSB_BUSCTL_OFFSET(epnum,
+						MUSB_TXFUNCADDR)),
+					musb_readb(musb->mregs,
+						MUSB_BUSCTL_OFFSET(epnum,
+						MUSB_TXHUBADDR)),
+					musb_readb(musb->mregs,
+						MUSB_BUSCTL_OFFSET(epnum,
+						MUSB_TXHUBPORT))
 					);
 				if (code <= 0)
 					break;
@@ -389,13 +363,13 @@
 				max -= code;
 
 				if (is_cppi_enabled()
-						&& bEnd
-						&& pEnd->tx_channel) {
-					unsigned	cppi = bEnd - 1;
+						&& epnum
+						&& hw_ep->tx_channel) {
+					unsigned	cppi = epnum - 1;
 					void __iomem	*base;
 					void __iomem	*ram;
 
-					base = pThis->ctrl_base;
+					base = musb->ctrl_base;
 					ram = DAVINCI_RXCPPI_STATERAM_OFFSET(
 							cppi) + base;
 					code = snprintf(buf, max,
@@ -418,28 +392,28 @@
 					max -= code;
 				}
 
-				if (pEnd == pThis->control_ep
+				if (hw_ep == musb->control_ep
 						&& !list_empty(
-							&pThis->control)) {
-					code = dump_queue(&pThis->control,
+							&musb->control)) {
+					code = dump_queue(&musb->control,
 							buf, max);
 					if (code <= 0)
 						break;
 					code = min(code, (int) max);
 					buf += code;
 					max -= code;
-				} else if (pEnd == pThis->bulk_ep
+				} else if (hw_ep == musb->bulk_ep
 						&& !list_empty(
-							&pThis->out_bulk)) {
-					code = dump_queue(&pThis->out_bulk,
+							&musb->out_bulk)) {
+					code = dump_queue(&musb->out_bulk,
 							buf, max);
 					if (code <= 0)
 						break;
 					code = min(code, (int) max);
 					buf += code;
 					max -= code;
-				} else if (pThis->periodic[bEnd]) {
-					code = dump_qh(pThis->periodic[bEnd],
+				} else if (musb->periodic[epnum]) {
+					code = dump_qh(musb->periodic[epnum],
 							buf, max);
 					if (code <= 0)
 						break;
@@ -451,19 +425,19 @@
 		}
 #endif
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
-		if (is_peripheral_active(pThis)) {
+		if (is_peripheral_active(musb)) {
 			code = 0;
 
-			if (pEnd->ep_in.desc || !bEnd) {
-				code = dump_ep(&pEnd->ep_in, buf, max);
+			if (hw_ep->ep_in.desc || !epnum) {
+				code = dump_ep(&hw_ep->ep_in, buf, max);
 				if (code <= 0)
 					break;
 				code = min(code, (int) max);
 				buf += code;
 				max -= code;
 			}
-			if (pEnd->ep_out.desc) {
-				code = dump_ep(&pEnd->ep_out, buf, max);
+			if (hw_ep->ep_out.desc) {
+				code = dump_ep(&hw_ep->ep_out, buf, max);
 				if (code <= 0)
 					break;
 				code = min(code, (int) max);
@@ -477,29 +451,29 @@
 	return buf - aBuffer;
 }
 
-/** Dump the current status and compile options.
- * @param pThis the device driver instance
+/* Dump the current status and compile options.
+ * @param musb the device driver instance
  * @param buffer where to dump the status; it must be big enough hold the
  * result otherwise "BAD THINGS HAPPENS(TM)".
  */
-static int dump_header_stats(struct musb *pThis, char *buffer)
+static int dump_header_stats(struct musb *musb, char *buffer)
 {
 	int code, count = 0;
-	const void __iomem *pBase = pThis->pRegs;
+	const void __iomem *mbase = musb->mregs;
 
 	*buffer = 0;
 	count = sprintf(buffer, "Status: %sHDRC, Mode=%s "
 				"(Power=%02x, DevCtl=%02x)\n",
-			(pThis->bIsMultipoint ? "M" : ""), MUSB_MODE(pThis),
-			musb_readb(pBase, MGC_O_HDRC_POWER),
-			musb_readb(pBase, MGC_O_HDRC_DEVCTL));
+			(musb->is_multipoint ? "M" : ""), MUSB_MODE(musb),
+			musb_readb(mbase, MUSB_POWER),
+			musb_readb(mbase, MUSB_DEVCTL));
 	if (count <= 0)
 		return 0;
 	buffer += count;
 
 	code = sprintf(buffer, "OTG state: %s; %sactive\n",
-			otg_state_string(pThis),
-			pThis->is_active ? "" : "in");
+			otg_state_string(musb),
+			musb->is_active ? "" : "in");
 	if (code <= 0)
 		goto done;
 	buffer += code;
@@ -507,7 +481,7 @@
 
 	code = sprintf(buffer,
 			"Options: "
-#ifdef CONFIG_USB_INVENTRA_FIFO
+#ifdef CONFIG_MUSB_PIO_ONLY
 			"pio"
 #elif defined(CONFIG_USB_TI_CPPI_DMA)
 			"cppi-dma"
@@ -528,7 +502,7 @@
 #endif
 			", debug=%d [eps=%d]\n",
 		debug,
-		pThis->bEndCount);
+		musb->nr_endpoints);
 	if (code <= 0)
 		goto done;
 	count += code;
@@ -536,7 +510,7 @@
 
 #ifdef	CONFIG_USB_GADGET_MUSB_HDRC
 	code = sprintf(buffer, "Peripheral address: %02x\n",
-			musb_readb(pThis, MGC_O_HDRC_FADDR));
+			musb_readb(musb->ctrl_base, MUSB_FADDR));
 	if (code <= 0)
 		goto done;
 	buffer += code;
@@ -545,7 +519,7 @@
 
 #ifdef	CONFIG_USB_MUSB_HDRC_HCD
 	code = sprintf(buffer, "Root port status: %08x\n",
-			pThis->port1_status);
+			musb->port1_status);
 	if (code <= 0)
 		goto done;
 	buffer += code;
@@ -557,14 +531,15 @@
 			"DaVinci: ctrl=%02x stat=%1x phy=%03x\n"
 			"\trndis=%05x auto=%04x intsrc=%08x intmsk=%08x"
 			"\n",
-			musb_readl(pThis->ctrl_base, DAVINCI_USB_CTRL_REG),
-			musb_readl(pThis->ctrl_base, DAVINCI_USB_STAT_REG),
-			__raw_readl(IO_ADDRESS(USBPHY_CTL_PADDR)),
-			musb_readl(pThis->ctrl_base, DAVINCI_RNDIS_REG),
-			musb_readl(pThis->ctrl_base, DAVINCI_AUTOREQ_REG),
-			musb_readl(pThis->ctrl_base,
+			musb_readl(musb->ctrl_base, DAVINCI_USB_CTRL_REG),
+			musb_readl(musb->ctrl_base, DAVINCI_USB_STAT_REG),
+			__raw_readl((void __force __iomem *)
+					IO_ADDRESS(USBPHY_CTL_PADDR)),
+			musb_readl(musb->ctrl_base, DAVINCI_RNDIS_REG),
+			musb_readl(musb->ctrl_base, DAVINCI_AUTOREQ_REG),
+			musb_readl(musb->ctrl_base,
 					DAVINCI_USB_INT_SOURCE_REG),
-			musb_readl(pThis->ctrl_base,
+			musb_readl(musb->ctrl_base,
 					DAVINCI_USB_INT_MASK_REG));
 	if (code <= 0)
 		goto done;
@@ -578,37 +553,37 @@
 			"\n\totg %03x timer %08x"
 			"\n\tprcm conf %08x mgmt %08x; int src %08x mask %08x"
 			"\n",
-			musb_readl(pThis->ctrl_base, TUSB_DEV_CONF),
-			musb_readl(pThis->ctrl_base, TUSB_PHY_OTG_CTRL_ENABLE),
-			musb_readl(pThis->ctrl_base, TUSB_PHY_OTG_CTRL),
-			musb_readl(pThis->ctrl_base, TUSB_DEV_OTG_STAT),
-			musb_readl(pThis->ctrl_base, TUSB_DEV_OTG_TIMER),
-			musb_readl(pThis->ctrl_base, TUSB_PRCM_CONF),
-			musb_readl(pThis->ctrl_base, TUSB_PRCM_MNGMT),
-			musb_readl(pThis->ctrl_base, TUSB_INT_SRC),
-			musb_readl(pThis->ctrl_base, TUSB_INT_MASK));
+			musb_readl(musb->ctrl_base, TUSB_DEV_CONF),
+			musb_readl(musb->ctrl_base, TUSB_PHY_OTG_CTRL_ENABLE),
+			musb_readl(musb->ctrl_base, TUSB_PHY_OTG_CTRL),
+			musb_readl(musb->ctrl_base, TUSB_DEV_OTG_STAT),
+			musb_readl(musb->ctrl_base, TUSB_DEV_OTG_TIMER),
+			musb_readl(musb->ctrl_base, TUSB_PRCM_CONF),
+			musb_readl(musb->ctrl_base, TUSB_PRCM_MNGMT),
+			musb_readl(musb->ctrl_base, TUSB_INT_SRC),
+			musb_readl(musb->ctrl_base, TUSB_INT_MASK));
 	if (code <= 0)
 		goto done;
 	count += code;
 	buffer += code;
 #endif	/* DAVINCI */
 
-	if (is_cppi_enabled() && pThis->pDmaController) {
+	if (is_cppi_enabled() && musb->dma_controller) {
 		code = sprintf(buffer,
 				"CPPI: txcr=%d txsrc=%01x txena=%01x; "
 				"rxcr=%d rxsrc=%01x rxena=%01x "
 				"\n",
-				musb_readl(pThis->ctrl_base,
+				musb_readl(musb->ctrl_base,
 						DAVINCI_TXCPPI_CTRL_REG),
-				musb_readl(pThis->ctrl_base,
+				musb_readl(musb->ctrl_base,
 						DAVINCI_TXCPPI_RAW_REG),
-				musb_readl(pThis->ctrl_base,
+				musb_readl(musb->ctrl_base,
 						DAVINCI_TXCPPI_INTENAB_REG),
-				musb_readl(pThis->ctrl_base,
+				musb_readl(musb->ctrl_base,
 						DAVINCI_RXCPPI_CTRL_REG),
-				musb_readl(pThis->ctrl_base,
+				musb_readl(musb->ctrl_base,
 						DAVINCI_RXCPPI_RAW_REG),
-				musb_readl(pThis->ctrl_base,
+				musb_readl(musb->ctrl_base,
 						DAVINCI_RXCPPI_INTENAB_REG));
 		if (code <= 0)
 			goto done;
@@ -617,10 +592,10 @@
 	}
 
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
-	if (is_peripheral_enabled(pThis)) {
+	if (is_peripheral_enabled(musb)) {
 		code = sprintf(buffer, "Gadget driver: %s\n",
-				pThis->pGadgetDriver
-					? pThis->pGadgetDriver->driver.name
+				musb->gadget_driver
+					? musb->gadget_driver->driver.name
 					: "(none)");
 		if (code <= 0)
 			goto done;
@@ -651,9 +626,9 @@
 			unsigned long count, void *data)
 {
 	char cmd;
-	u8 bReg;
+	u8 reg;
 	struct musb *musb = (struct musb *)data;
-	void __iomem *pBase = musb->pRegs;
+	void __iomem *mbase = musb->mregs;
 
 	/* MOD_INC_USE_COUNT; */
 
@@ -662,70 +637,62 @@
 
 	switch (cmd) {
 	case 'C':
-		if (pBase) {
-			bReg = musb_readb(pBase, MGC_O_HDRC_POWER)
-					| MGC_M_POWER_SOFTCONN;
-			musb_writeb(pBase, MGC_O_HDRC_POWER, bReg);
+		if (mbase) {
+			reg = musb_readb(mbase, MUSB_POWER)
+					| MUSB_POWER_SOFTCONN;
+			musb_writeb(mbase, MUSB_POWER, reg);
 		}
 		break;
 
 	case 'c':
-		if (pBase) {
-			bReg = musb_readb(pBase, MGC_O_HDRC_POWER)
-					& ~MGC_M_POWER_SOFTCONN;
-			musb_writeb(pBase, MGC_O_HDRC_POWER, bReg);
+		if (mbase) {
+			reg = musb_readb(mbase, MUSB_POWER)
+					& ~MUSB_POWER_SOFTCONN;
+			musb_writeb(mbase, MUSB_POWER, reg);
 		}
 		break;
 
 	case 'I':
-		if (pBase) {
-			bReg = musb_readb(pBase, MGC_O_HDRC_POWER)
-					| MGC_M_POWER_HSENAB;
-			musb_writeb(pBase, MGC_O_HDRC_POWER, bReg);
+		if (mbase) {
+			reg = musb_readb(mbase, MUSB_POWER)
+					| MUSB_POWER_HSENAB;
+			musb_writeb(mbase, MUSB_POWER, reg);
 		}
 		break;
 
 	case 'i':
-		if (pBase) {
-			bReg = musb_readb(pBase, MGC_O_HDRC_POWER)
-					& ~MGC_M_POWER_HSENAB;
-			musb_writeb(pBase, MGC_O_HDRC_POWER, bReg);
+		if (mbase) {
+			reg = musb_readb(mbase, MUSB_POWER)
+					& ~MUSB_POWER_HSENAB;
+			musb_writeb(mbase, MUSB_POWER, reg);
 		}
 		break;
 
 	case 'F':
-		bReg = musb_readb(pBase, MGC_O_HDRC_DEVCTL);
-		bReg |= MGC_M_DEVCTL_SESSION;
-		musb_writeb(pBase, MGC_O_HDRC_DEVCTL, bReg);
+		reg = musb_readb(mbase, MUSB_DEVCTL);
+		reg |= MUSB_DEVCTL_SESSION;
+		musb_writeb(mbase, MUSB_DEVCTL, reg);
 		break;
 
 	case 'H':
-		if (pBase) {
-			bReg = musb_readb(pBase, MGC_O_HDRC_DEVCTL);
-			bReg |= MGC_M_DEVCTL_HR;
-			musb_writeb(pBase, MGC_O_HDRC_DEVCTL, bReg);
-			//MUSB_HST_MODE( ((struct musb*)data) );
-			//WARN("Host Mode\n");
+		if (mbase) {
+			reg = musb_readb(mbase, MUSB_DEVCTL);
+			reg |= MUSB_DEVCTL_HR;
+			musb_writeb(mbase, MUSB_DEVCTL, reg);
+			/* MUSB_HST_MODE( ((struct musb*)data) ); */
+			/* WARN("Host Mode\n"); */
 		}
 		break;
 
 	case 'h':
-		if (pBase) {
-			bReg = musb_readb(pBase, MGC_O_HDRC_DEVCTL);
-			bReg &= ~MGC_M_DEVCTL_HR;
-			musb_writeb(pBase, MGC_O_HDRC_DEVCTL, bReg);
-		}
-		break;
-
-	case 'T':
-		if (pBase) {
-			musb_load_testpacket(musb);
-			musb_writeb(pBase, MGC_O_HDRC_TESTMODE,
-					MGC_M_TEST_PACKET);
+		if (mbase) {
+			reg = musb_readb(mbase, MUSB_DEVCTL);
+			reg &= ~MUSB_DEVCTL_HR;
+			musb_writeb(mbase, MUSB_DEVCTL, reg);
 		}
 		break;
 
-#if (MUSB_DEBUG>0)
+#if (MUSB_DEBUG > 0)
 		/* set/read debug level */
 	case 'D':{
 			if (count > 1) {
@@ -763,7 +730,6 @@
 		INFO("I/i: hispeed enable/disable\n");
 		INFO("F: force session start\n");
 		INFO("H: host mode\n");
-		INFO("T: start sending TEST_PACKET\n");
 		INFO("D: set/read dbug level\n");
 		break;
 #endif
@@ -773,7 +739,7 @@
 		break;
 	}
 
-	musb_platform_try_idle(musb);
+	musb_platform_try_idle(musb, 0);
 
 	return count;
 }
@@ -784,36 +750,36 @@
 	char *buffer = page;
 	int code = 0;
 	unsigned long	flags;
-	struct musb	*pThis = data;
-	unsigned	bEnd;
+	struct musb	*musb = data;
+	unsigned	epnum;
 
 	count -= off;
 	count -= 1;		/* for NUL at end */
 	if (count <= 0)
 		return -EINVAL;
 
-	spin_lock_irqsave(&pThis->Lock, flags);
+	spin_lock_irqsave(&musb->lock, flags);
 
-	code = dump_header_stats(pThis, buffer);
+	code = dump_header_stats(musb, buffer);
 	if (code > 0) {
 		buffer += code;
 		count -= code;
 	}
 
 	/* generate the report for the end points */
-	// REVISIT ... not unless something's connected!
-	for (bEnd = 0; count >= 0 && bEnd < pThis->bEndCount;
-			bEnd++) {
-		code = dump_end_info(pThis, bEnd, buffer, count);
+	/* REVISIT ... not unless something's connected! */
+	for (epnum = 0; count >= 0 && epnum < musb->nr_endpoints;
+			epnum++) {
+		code = dump_end_info(musb, epnum, buffer, count);
 		if (code > 0) {
 			buffer += code;
 			count -= code;
 		}
 	}
 
-	musb_platform_try_idle(pThis);
+	musb_platform_try_idle(musb, 0);
 
-	spin_unlock_irqrestore(&pThis->Lock, flags);
+	spin_unlock_irqrestore(&musb->lock, flags);
 	*eof = 1;
 
 	return buffer - page;
@@ -821,7 +787,7 @@
 
 void __devexit musb_debug_delete(char *name, struct musb *musb)
 {
-	if (musb->pProcEntry)
+	if (musb->proc_entry)
 		remove_proc_entry(name, NULL);
 }
 
@@ -835,11 +801,11 @@
 	if (!name)
 		return NULL;
 
-	data->pProcEntry = pde = create_proc_entry(name,
+	data->proc_entry = pde = create_proc_entry(name,
 					S_IFREG | S_IRUGO | S_IWUSR, NULL);
 	if (pde) {
 		pde->data = data;
-		// pde->owner = THIS_MODULE;
+		/* pde->owner = THIS_MODULE; */
 
 		pde->read_proc = musb_proc_read;
 		pde->write_proc = musb_proc_write;
diff -ruN linux-omap-2.6/drivers/usb/musb/musb_regs.h maemo_src/drivers/usb/musb/musb_regs.h
--- linux-omap-2.6/drivers/usb/musb/musb_regs.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/usb/musb/musb_regs.h	2011-02-06 20:12:11.316666607 -0500
@@ -0,0 +1,300 @@
+/*
+ * MUSB OTG driver register defines
+ *
+ * Copyright 2005 Mentor Graphics Corporation
+ * Copyright (C) 2005-2006 by Texas Instruments
+ * Copyright (C) 2006-2007 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __MUSB_REGS_H__
+#define __MUSB_REGS_H__
+
+#define MUSB_EP0_FIFOSIZE	64	/* This is non-configurable */
+
+/*
+ * Common USB registers
+ */
+
+#define MUSB_FADDR		0x00	/* 8-bit */
+#define MUSB_POWER		0x01	/* 8-bit */
+
+#define MUSB_INTRTX		0x02	/* 16-bit */
+#define MUSB_INTRRX		0x04
+#define MUSB_INTRTXE		0x06
+#define MUSB_INTRRXE		0x08
+#define MUSB_INTRUSB		0x0A	/* 8 bit */
+#define MUSB_INTRUSBE		0x0B	/* 8 bit */
+#define MUSB_FRAME		0x0C
+#define MUSB_INDEX		0x0E	/* 8 bit */
+#define MUSB_TESTMODE		0x0F	/* 8 bit */
+
+/* Get offset for a given FIFO from musb->mregs */
+#ifdef	CONFIG_USB_TUSB6010
+#define MUSB_FIFO_OFFSET(epnum)	(0x200 + ((epnum) * 0x20))
+#else
+#define MUSB_FIFO_OFFSET(epnum)	(0x20 + ((epnum) * 4))
+#endif
+
+/*
+ * Additional Control Registers
+ */
+
+#define MUSB_DEVCTL		0x60	/* 8 bit */
+
+/* These are always controlled through the INDEX register */
+#define MUSB_TXFIFOSZ		0x62	/* 8-bit (see masks) */
+#define MUSB_RXFIFOSZ		0x63	/* 8-bit (see masks) */
+#define MUSB_TXFIFOADD		0x64	/* 16-bit offset shifted right 3 */
+#define MUSB_RXFIFOADD		0x66	/* 16-bit offset shifted right 3 */
+
+/* REVISIT: vctrl/vstatus: optional vendor utmi+phy register at 0x68 */
+#define MUSB_HWVERS		0x6C	/* 8 bit */
+
+#define MUSB_EPINFO		0x78	/* 8 bit */
+#define MUSB_RAMINFO		0x79	/* 8 bit */
+#define MUSB_LINKINFO		0x7a	/* 8 bit */
+#define MUSB_VPLEN		0x7b	/* 8 bit */
+#define MUSB_HS_EOF1		0x7c	/* 8 bit */
+#define MUSB_FS_EOF1		0x7d	/* 8 bit */
+#define MUSB_LS_EOF1		0x7e	/* 8 bit */
+
+/* Offsets to endpoint registers */
+#define MUSB_TXMAXP		0x00
+#define MUSB_TXCSR		0x02
+#define MUSB_CSR0		MUSB_TXCSR	/* Re-used for EP0 */
+#define MUSB_RXMAXP		0x04
+#define MUSB_RXCSR		0x06
+#define MUSB_RXCOUNT		0x08
+#define MUSB_COUNT0		MUSB_RXCOUNT	/* Re-used for EP0 */
+#define MUSB_TXTYPE		0x0A
+#define MUSB_TYPE0		MUSB_TXTYPE	/* Re-used for EP0 */
+#define MUSB_TXINTERVAL		0x0B
+#define MUSB_NAKLIMIT0		MUSB_TXINTERVAL	/* Re-used for EP0 */
+#define MUSB_RXTYPE		0x0C
+#define MUSB_RXINTERVAL		0x0D
+#define MUSB_FIFOSIZE		0x0F
+#define MUSB_CONFIGDATA		MUSB_FIFOSIZE	/* Re-used for EP0 */
+
+/* Offsets to endpoint registers in indexed model (using INDEX register) */
+#define MUSB_INDEXED_OFFSET(_epnum, _offset)	\
+	(0x10 + (_offset))
+
+/* Offsets to endpoint registers in flat models */
+#define MUSB_FLAT_OFFSET(_epnum, _offset)	\
+	(0x100 + (0x10*(_epnum)) + (_offset))
+
+#ifdef CONFIG_USB_TUSB6010
+/* TUSB6010 EP0 configuration register is special */
+#define MUSB_TUSB_OFFSET(_epnum, _offset)	\
+	(0x10 + _offset)
+#include "tusb6010.h"		/* Needed "only" for TUSB_EP0_CONF */
+#endif
+
+/* "bus control"/target registers, for host side multipoint (external hubs) */
+#define MUSB_TXFUNCADDR		0x00
+#define MUSB_TXHUBADDR		0x02
+#define MUSB_TXHUBPORT		0x03
+
+#define MUSB_RXFUNCADDR		0x04
+#define MUSB_RXHUBADDR		0x06
+#define MUSB_RXHUBPORT		0x07
+
+#define MUSB_BUSCTL_OFFSET(_epnum, _offset) \
+	(0x80 + (8*(_epnum)) + (_offset))
+
+/*
+ * MUSB Register bits
+ */
+
+/* POWER */
+#define MUSB_POWER_ISOUPDATE	0x80
+#define MUSB_POWER_SOFTCONN	0x40
+#define MUSB_POWER_HSENAB	0x20
+#define MUSB_POWER_HSMODE	0x10
+#define MUSB_POWER_RESET	0x08
+#define MUSB_POWER_RESUME	0x04
+#define MUSB_POWER_SUSPENDM	0x02
+#define MUSB_POWER_ENSUSPEND	0x01
+
+/* INTRUSB */
+#define MUSB_INTR_SUSPEND	0x01
+#define MUSB_INTR_RESUME	0x02
+#define MUSB_INTR_RESET		0x04
+#define MUSB_INTR_BABBLE	0x04
+#define MUSB_INTR_SOF		0x08
+#define MUSB_INTR_CONNECT	0x10
+#define MUSB_INTR_DISCONNECT	0x20
+#define MUSB_INTR_SESSREQ	0x40
+#define MUSB_INTR_VBUSERROR	0x80	/* For SESSION end */
+
+/* DEVCTL */
+#define MUSB_DEVCTL_BDEVICE	0x80
+#define MUSB_DEVCTL_FSDEV	0x40
+#define MUSB_DEVCTL_LSDEV	0x20
+#define MUSB_DEVCTL_VBUS	0x18
+#define MUSB_DEVCTL_VBUS_SHIFT	3
+#define MUSB_DEVCTL_HM		0x04
+#define MUSB_DEVCTL_HR		0x02
+#define MUSB_DEVCTL_SESSION	0x01
+
+/* TESTMODE */
+#define MUSB_TEST_FORCE_HOST	0x80
+#define MUSB_TEST_FIFO_ACCESS	0x40
+#define MUSB_TEST_FORCE_FS	0x20
+#define MUSB_TEST_FORCE_HS	0x10
+#define MUSB_TEST_PACKET	0x08
+#define MUSB_TEST_K		0x04
+#define MUSB_TEST_J		0x02
+#define MUSB_TEST_SE0_NAK	0x01
+
+/* Allocate for double-packet buffering (effectively doubles assigned _SIZE) */
+#define MUSB_FIFOSZ_DPB	0x10
+/* Allocation size (8, 16, 32, ... 4096) */
+#define MUSB_FIFOSZ_SIZE	0x0f
+
+/* CSR0 */
+#define MUSB_CSR0_FLUSHFIFO	0x0100
+#define MUSB_CSR0_TXPKTRDY	0x0002
+#define MUSB_CSR0_RXPKTRDY	0x0001
+
+/* CSR0 in Peripheral mode */
+#define MUSB_CSR0_P_SVDSETUPEND	0x0080
+#define MUSB_CSR0_P_SVDRXPKTRDY	0x0040
+#define MUSB_CSR0_P_SENDSTALL	0x0020
+#define MUSB_CSR0_P_SETUPEND	0x0010
+#define MUSB_CSR0_P_DATAEND	0x0008
+#define MUSB_CSR0_P_SENTSTALL	0x0004
+
+/* CSR0 in Host mode */
+#define MUSB_CSR0_H_DIS_PING		0x0800
+#define MUSB_CSR0_H_WR_DATATOGGLE	0x0400	/* Set to allow setting: */
+#define MUSB_CSR0_H_DATATOGGLE		0x0200	/* Data toggle control */
+#define MUSB_CSR0_H_NAKTIMEOUT		0x0080
+#define MUSB_CSR0_H_STATUSPKT		0x0040
+#define MUSB_CSR0_H_REQPKT		0x0020
+#define MUSB_CSR0_H_ERROR		0x0010
+#define MUSB_CSR0_H_SETUPPKT		0x0008
+#define MUSB_CSR0_H_RXSTALL		0x0004
+
+/* CSR0 bits to avoid zeroing (write zero clears, write 1 ignored) */
+#define MUSB_CSR0_P_WZC_BITS	\
+	(MUSB_CSR0_P_SENTSTALL)
+#define MUSB_CSR0_H_WZC_BITS	\
+	(MUSB_CSR0_H_NAKTIMEOUT | MUSB_CSR0_H_RXSTALL \
+	| MUSB_CSR0_RXPKTRDY)
+
+/* TxType/RxType */
+#define MUSB_TYPE_SPEED		0xc0
+#define MUSB_TYPE_SPEED_SHIFT	6
+#define MUSB_TYPE_PROTO		0x30	/* Implicitly zero for ep0 */
+#define MUSB_TYPE_PROTO_SHIFT	4
+#define MUSB_TYPE_REMOTE_END	0xf	/* Implicitly zero for ep0 */
+
+/* CONFIGDATA */
+#define MUSB_CONFIGDATA_MPRXE		0x80	/* Auto bulk pkt combining */
+#define MUSB_CONFIGDATA_MPTXE		0x40	/* Auto bulk pkt splitting */
+#define MUSB_CONFIGDATA_BIGENDIAN	0x20
+#define MUSB_CONFIGDATA_HBRXE		0x10	/* HB-ISO for RX */
+#define MUSB_CONFIGDATA_HBTXE		0x08	/* HB-ISO for TX */
+#define MUSB_CONFIGDATA_DYNFIFO		0x04	/* Dynamic FIFO sizing */
+#define MUSB_CONFIGDATA_SOFTCONE	0x02	/* SoftConnect */
+#define MUSB_CONFIGDATA_UTMIDW		0x01	/* Data width 0/1 => 8/16bits */
+
+/* TXCSR in Peripheral and Host mode */
+#define MUSB_TXCSR_AUTOSET		0x8000
+#define MUSB_TXCSR_MODE			0x2000
+#define MUSB_TXCSR_DMAENAB		0x1000
+#define MUSB_TXCSR_FRCDATATOG		0x0800
+#define MUSB_TXCSR_DMAMODE		0x0400
+#define MUSB_TXCSR_CLRDATATOG		0x0040
+#define MUSB_TXCSR_FLUSHFIFO		0x0008
+#define MUSB_TXCSR_FIFONOTEMPTY		0x0002
+#define MUSB_TXCSR_TXPKTRDY		0x0001
+
+/* TXCSR in Peripheral mode */
+#define MUSB_TXCSR_P_ISO		0x4000
+#define MUSB_TXCSR_P_INCOMPTX		0x0080
+#define MUSB_TXCSR_P_SENTSTALL		0x0020
+#define MUSB_TXCSR_P_SENDSTALL		0x0010
+#define MUSB_TXCSR_P_UNDERRUN		0x0004
+
+/* TXCSR in Host mode */
+#define MUSB_TXCSR_H_WR_DATATOGGLE	0x0200
+#define MUSB_TXCSR_H_DATATOGGLE		0x0100
+#define MUSB_TXCSR_H_NAKTIMEOUT		0x0080
+#define MUSB_TXCSR_H_RXSTALL		0x0020
+#define MUSB_TXCSR_H_ERROR		0x0004
+
+/* TXCSR bits to avoid zeroing (write zero clears, write 1 ignored) */
+#define MUSB_TXCSR_P_WZC_BITS	\
+	(MUSB_TXCSR_P_INCOMPTX | MUSB_TXCSR_P_SENTSTALL \
+	| MUSB_TXCSR_P_UNDERRUN | MUSB_TXCSR_FIFONOTEMPTY)
+#define MUSB_TXCSR_H_WZC_BITS	\
+	(MUSB_TXCSR_H_NAKTIMEOUT | MUSB_TXCSR_H_RXSTALL \
+	| MUSB_TXCSR_H_ERROR | MUSB_TXCSR_FIFONOTEMPTY)
+
+/* RXCSR in Peripheral and Host mode */
+#define MUSB_RXCSR_AUTOCLEAR		0x8000
+#define MUSB_RXCSR_DMAENAB		0x2000
+#define MUSB_RXCSR_DISNYET		0x1000
+#define MUSB_RXCSR_PID_ERR		0x1000
+#define MUSB_RXCSR_DMAMODE		0x0800
+#define MUSB_RXCSR_INCOMPRX		0x0100
+#define MUSB_RXCSR_CLRDATATOG		0x0080
+#define MUSB_RXCSR_FLUSHFIFO		0x0010
+#define MUSB_RXCSR_DATAERROR		0x0008
+#define MUSB_RXCSR_FIFOFULL		0x0002
+#define MUSB_RXCSR_RXPKTRDY		0x0001
+
+/* RXCSR in Peripheral mode */
+#define MUSB_RXCSR_P_ISO		0x4000
+#define MUSB_RXCSR_P_SENTSTALL		0x0040
+#define MUSB_RXCSR_P_SENDSTALL		0x0020
+#define MUSB_RXCSR_P_OVERRUN		0x0004
+
+/* RXCSR in Host mode */
+#define MUSB_RXCSR_H_AUTOREQ		0x4000
+#define MUSB_RXCSR_H_WR_DATATOGGLE	0x0400
+#define MUSB_RXCSR_H_DATATOGGLE		0x0200
+#define MUSB_RXCSR_H_RXSTALL		0x0040
+#define MUSB_RXCSR_H_REQPKT		0x0020
+#define MUSB_RXCSR_H_ERROR		0x0004
+
+/* RXCSR bits to avoid zeroing (write zero clears, write 1 ignored) */
+#define MUSB_RXCSR_P_WZC_BITS	\
+	(MUSB_RXCSR_P_SENTSTALL | MUSB_RXCSR_P_OVERRUN \
+	| MUSB_RXCSR_RXPKTRDY)
+#define MUSB_RXCSR_H_WZC_BITS	\
+	(MUSB_RXCSR_H_RXSTALL | MUSB_RXCSR_H_ERROR \
+	| MUSB_RXCSR_DATAERROR | MUSB_RXCSR_RXPKTRDY)
+
+/* HUBADDR */
+#define MUSB_HUBADDR_MULTI_TT		0x80
+
+#endif	/* __MUSB_REGS_H__ */
diff -ruN linux-omap-2.6/drivers/usb/musb/musb_virthub.c maemo_src/drivers/usb/musb/musb_virthub.c
--- linux-omap-2.6/drivers/usb/musb/musb_virthub.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/usb/musb/musb_virthub.c	2011-02-06 20:12:11.226666607 -0500
@@ -0,0 +1,425 @@
+/*
+ * MUSB OTG driver virtual root hub support
+ *
+ * Copyright 2005 Mentor Graphics Corporation
+ * Copyright (C) 2005-2006 by Texas Instruments
+ * Copyright (C) 2006-2007 Nokia Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/time.h>
+#include <linux/timer.h>
+
+#include <asm/unaligned.h>
+
+#include "musb_core.h"
+
+
+static void musb_port_suspend(struct musb *musb, bool do_suspend)
+{
+	u8		power;
+	void __iomem	*mbase = musb->mregs;
+
+	if (!is_host_active(musb))
+		return;
+
+	/* NOTE:  this doesn't necessarily put PHY into low power mode,
+	 * turning off its clock; that's a function of PHY integration and
+	 * MUSB_POWER_ENSUSPEND.  PHY may need a clock (sigh) to detect
+	 * SE0 changing to connect (J) or wakeup (K) states.
+	 */
+	power = musb_readb(mbase, MUSB_POWER);
+	if (do_suspend) {
+		int retries = 10000;
+
+		power &= ~MUSB_POWER_RESUME;
+		power |= MUSB_POWER_SUSPENDM;
+		musb_writeb(mbase, MUSB_POWER, power);
+
+		/* Needed for OPT A tests */
+		power = musb_readb(mbase, MUSB_POWER);
+		while (power & MUSB_POWER_SUSPENDM) {
+			power = musb_readb(mbase, MUSB_POWER);
+			if (retries-- < 1)
+				break;
+		}
+
+		DBG(3, "Root port suspended, power %02x\n", power);
+
+		musb->port1_status |= USB_PORT_STAT_SUSPEND;
+		switch (musb->xceiv.state) {
+		case OTG_STATE_A_HOST:
+			musb->xceiv.state = OTG_STATE_A_SUSPEND;
+			musb->is_active = is_otg_enabled(musb)
+					&& musb->xceiv.host->b_hnp_enable;
+			musb_platform_try_idle(musb, 0);
+			break;
+#ifdef	CONFIG_USB_MUSB_OTG
+		case OTG_STATE_B_HOST:
+			musb->xceiv.state = OTG_STATE_B_WAIT_ACON;
+			musb->is_active = is_otg_enabled(musb)
+					&& musb->xceiv.host->b_hnp_enable;
+			musb_platform_try_idle(musb, 0);
+			break;
+#endif
+		default:
+			DBG(1, "bogus rh suspend? %s\n",
+				otg_state_string(musb));
+		}
+	} else if (power & MUSB_POWER_SUSPENDM) {
+		power &= ~MUSB_POWER_SUSPENDM;
+		power |= MUSB_POWER_RESUME;
+		musb_writeb(mbase, MUSB_POWER, power);
+
+		DBG(3, "Root port resuming, power %02x\n", power);
+
+		/* later, GetPortStatus will stop RESUME signaling */
+		musb->port1_status |= MUSB_PORT_STAT_RESUME;
+		musb->rh_timer = jiffies + msecs_to_jiffies(20);
+	}
+}
+
+static void musb_port_reset(struct musb *musb, bool do_reset)
+{
+	u8		power;
+	void __iomem	*mbase = musb->mregs;
+
+#ifdef CONFIG_USB_MUSB_OTG
+	if (musb->xceiv.state == OTG_STATE_B_IDLE) {
+		DBG(2, "HNP: Returning from HNP; no hub reset from b_idle\n");
+		musb->port1_status &= ~USB_PORT_STAT_RESET;
+		return;
+	}
+#endif
+
+	if (!is_host_active(musb))
+		return;
+
+	/* NOTE:  caller guarantees it will turn off the reset when
+	 * the appropriate amount of time has passed
+	 */
+	power = musb_readb(mbase, MUSB_POWER);
+	if (do_reset) {
+
+		/*
+		 * If RESUME is set, we must make sure it stays minimum 20 ms.
+		 * Then we must clear RESUME and wait a bit to let musb start
+		 * generating SOFs. If we don't do this, OPT HS A 6.8 tests
+		 * fail with "Error! Did not receive an SOF before suspend
+		 * detected".
+		 */
+		if (power &  MUSB_POWER_RESUME) {
+			while (time_before(jiffies, musb->rh_timer))
+				msleep(1);
+			musb_writeb(mbase, MUSB_POWER,
+				power & ~MUSB_POWER_RESUME);
+			msleep(1);
+		}
+
+		musb->ignore_disconnect = true;
+		power &= 0xf0;
+		musb_writeb(mbase, MUSB_POWER,
+				power | MUSB_POWER_RESET);
+
+		musb->port1_status |= USB_PORT_STAT_RESET;
+		musb->port1_status &= ~USB_PORT_STAT_ENABLE;
+		musb->rh_timer = jiffies + msecs_to_jiffies(50);
+	} else {
+		DBG(4, "root port reset stopped\n");
+		musb_writeb(mbase, MUSB_POWER,
+				power & ~MUSB_POWER_RESET);
+
+		musb->ignore_disconnect = false;
+
+		power = musb_readb(mbase, MUSB_POWER);
+		if (power & MUSB_POWER_HSMODE) {
+			DBG(4, "high-speed device connected\n");
+			musb->port1_status |= USB_PORT_STAT_HIGH_SPEED;
+		}
+
+		musb->port1_status &= ~USB_PORT_STAT_RESET;
+		musb->port1_status |= USB_PORT_STAT_ENABLE
+					| (USB_PORT_STAT_C_RESET << 16)
+					| (USB_PORT_STAT_C_ENABLE << 16);
+		usb_hcd_poll_rh_status(musb_to_hcd(musb));
+
+		musb->vbuserr_retry = VBUSERR_RETRY_COUNT;
+	}
+}
+
+void musb_root_disconnect(struct musb *musb)
+{
+	musb->port1_status = (1 << USB_PORT_FEAT_POWER)
+			| (1 << USB_PORT_FEAT_C_CONNECTION);
+
+	usb_hcd_poll_rh_status(musb_to_hcd(musb));
+	musb->is_active = 0;
+
+	switch (musb->xceiv.state) {
+	case OTG_STATE_A_HOST:
+	case OTG_STATE_A_SUSPEND:
+		musb->xceiv.state = OTG_STATE_A_WAIT_BCON;
+		musb->is_active = 0;
+		break;
+	case OTG_STATE_A_WAIT_VFALL:
+		musb->xceiv.state = OTG_STATE_B_IDLE;
+		break;
+	default:
+		DBG(1, "host disconnect (%s)\n", otg_state_string(musb));
+	}
+}
+
+
+/*---------------------------------------------------------------------*/
+
+/* Caller may or may not hold musb->lock */
+int musb_hub_status_data(struct usb_hcd *hcd, char *buf)
+{
+	struct musb	*musb = hcd_to_musb(hcd);
+	int		retval = 0;
+
+	/* called in_irq() via usb_hcd_poll_rh_status() */
+	if (musb->port1_status & 0xffff0000) {
+		*buf = 0x02;
+		retval = 1;
+	}
+	return retval;
+}
+
+int musb_hub_control(
+	struct usb_hcd	*hcd,
+	u16		typeReq,
+	u16		wValue,
+	u16		wIndex,
+	char		*buf,
+	u16		wLength)
+{
+	struct musb	*musb = hcd_to_musb(hcd);
+	u32		temp;
+	int		retval = 0;
+	unsigned long	flags;
+
+	spin_lock_irqsave(&musb->lock, flags);
+
+	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags))) {
+		spin_unlock_irqrestore(&musb->lock, flags);
+		return -ESHUTDOWN;
+	}
+
+	/* hub features:  always zero, setting is a NOP
+	 * port features: reported, sometimes updated when host is active
+	 * no indicators
+	 */
+	switch (typeReq) {
+	case ClearHubFeature:
+	case SetHubFeature:
+		switch (wValue) {
+		case C_HUB_OVER_CURRENT:
+		case C_HUB_LOCAL_POWER:
+			break;
+		default:
+			goto error;
+		}
+		break;
+	case ClearPortFeature:
+		if ((wIndex & 0xff) != 1)
+			goto error;
+
+		switch (wValue) {
+		case USB_PORT_FEAT_ENABLE:
+			break;
+		case USB_PORT_FEAT_SUSPEND:
+			musb_port_suspend(musb, false);
+			break;
+		case USB_PORT_FEAT_POWER:
+			if (!(is_otg_enabled(musb) && hcd->self.is_b_host))
+				musb_set_vbus(musb, 0);
+			break;
+		case USB_PORT_FEAT_C_CONNECTION:
+		case USB_PORT_FEAT_C_ENABLE:
+		case USB_PORT_FEAT_C_OVER_CURRENT:
+		case USB_PORT_FEAT_C_RESET:
+		case USB_PORT_FEAT_C_SUSPEND:
+			break;
+		default:
+			goto error;
+		}
+		DBG(5, "clear feature %d\n", wValue);
+		musb->port1_status &= ~(1 << wValue);
+		break;
+	case GetHubDescriptor:
+		{
+		struct usb_hub_descriptor *desc = (void *)buf;
+
+		desc->bDescLength = 9;
+		desc->bDescriptorType = 0x29;
+		desc->bNbrPorts = 1;
+		desc->wHubCharacteristics = __constant_cpu_to_le16(
+				  0x0001	/* per-port power switching */
+				| 0x0010	/* no overcurrent reporting */
+				);
+		desc->bPwrOn2PwrGood = 5;	/* msec/2 */
+		desc->bHubContrCurrent = 0;
+
+		/* workaround bogus struct definition */
+		desc->DeviceRemovable[0] = 0x02;	/* port 1 */
+		desc->DeviceRemovable[1] = 0xff;
+		}
+		break;
+	case GetHubStatus:
+		temp = 0;
+		*(__le32 *) buf = cpu_to_le32(temp);
+		break;
+	case GetPortStatus:
+		if (wIndex != 1)
+			goto error;
+
+		/* finish RESET signaling? */
+		if ((musb->port1_status & USB_PORT_STAT_RESET)
+				&& time_after_eq(jiffies, musb->rh_timer))
+			musb_port_reset(musb, false);
+
+		/* finish RESUME signaling? */
+		if ((musb->port1_status & MUSB_PORT_STAT_RESUME)
+				&& time_after_eq(jiffies, musb->rh_timer)) {
+			u8		power;
+
+			power = musb_readb(musb->mregs, MUSB_POWER);
+			power &= ~MUSB_POWER_RESUME;
+			DBG(4, "root port resume stopped, power %02x\n",
+					power);
+			musb_writeb(musb->mregs, MUSB_POWER, power);
+
+			/* ISSUE:  DaVinci (RTL 1.300) disconnects after
+			 * resume of high speed peripherals (but not full
+			 * speed ones).
+			 */
+
+			musb->is_active = 1;
+			musb->port1_status &= ~(USB_PORT_STAT_SUSPEND
+					| MUSB_PORT_STAT_RESUME);
+			musb->port1_status |= USB_PORT_STAT_C_SUSPEND << 16;
+			usb_hcd_poll_rh_status(musb_to_hcd(musb));
+			/* NOTE: it might really be A_WAIT_BCON ... */
+			musb->xceiv.state = OTG_STATE_A_HOST;
+		}
+
+		put_unaligned(cpu_to_le32(musb->port1_status
+					& ~MUSB_PORT_STAT_RESUME),
+				(__le32 *) buf);
+
+		/* port change status is more interesting */
+		DBG(get_unaligned((u16 *)(buf+2)) ? 2 : 5, "port status %08x\n",
+				musb->port1_status);
+		break;
+	case SetPortFeature:
+		if ((wIndex & 0xff) != 1)
+			goto error;
+
+		switch (wValue) {
+		case USB_PORT_FEAT_POWER:
+			/* NOTE: this controller has a strange state machine
+			 * that involves "requesting sessions" according to
+			 * magic side effects from incompletely-described
+			 * rules about startup...
+			 *
+			 * This call is what really starts the host mode; be
+			 * very careful about side effects if you reorder any
+			 * initialization logic, e.g. for OTG, or change any
+			 * logic relating to VBUS power-up.
+			 */
+			if (!(is_otg_enabled(musb) && hcd->self.is_b_host))
+				musb_start(musb);
+			break;
+		case USB_PORT_FEAT_RESET:
+			musb_port_reset(musb, true);
+			break;
+		case USB_PORT_FEAT_SUSPEND:
+			musb_port_suspend(musb, true);
+			break;
+		case USB_PORT_FEAT_TEST:
+			if (unlikely(is_host_active(musb)))
+				goto error;
+
+			wIndex >>= 8;
+			switch (wIndex) {
+			case 1:
+				pr_debug("TEST_J\n");
+				temp = MUSB_TEST_J;
+				break;
+			case 2:
+				pr_debug("TEST_K\n");
+				temp = MUSB_TEST_K;
+				break;
+			case 3:
+				pr_debug("TEST_SE0_NAK\n");
+				temp = MUSB_TEST_SE0_NAK;
+				break;
+			case 4:
+				pr_debug("TEST_PACKET\n");
+				temp = MUSB_TEST_PACKET;
+				musb_load_testpacket(musb);
+				break;
+			case 5:
+				pr_debug("TEST_FORCE_ENABLE\n");
+				temp = MUSB_TEST_FORCE_HOST
+					| MUSB_TEST_FORCE_HS;
+
+				musb_writeb(musb->mregs, MUSB_DEVCTL,
+						MUSB_DEVCTL_SESSION);
+				break;
+			case 6:
+				pr_debug("TEST_FIFO_ACCESS\n");
+				temp = MUSB_TEST_FIFO_ACCESS;
+				break;
+			default:
+				goto error;
+			}
+			musb_writeb(musb->mregs, MUSB_TESTMODE, temp);
+			break;
+		default:
+			goto error;
+		}
+		DBG(5, "set feature %d\n", wValue);
+		musb->port1_status |= 1 << wValue;
+		break;
+
+	default:
+error:
+		/* "protocol stall" on error */
+		retval = -EPIPE;
+	}
+	spin_unlock_irqrestore(&musb->lock, flags);
+	return retval;
+}
diff -ruN linux-omap-2.6/drivers/usb/musb/omap2430.c maemo_src/drivers/usb/musb/omap2430.c
--- linux-omap-2.6/drivers/usb/musb/omap2430.c	2011-02-06 20:17:25.929999940 -0500
+++ maemo_src/drivers/usb/musb/omap2430.c	2011-02-06 20:12:11.286666607 -0500
@@ -27,70 +27,144 @@
 #include <linux/init.h>
 #include <linux/list.h>
 #include <linux/clk.h>
+#include <linux/io.h>
 
-#include <asm/io.h>
 #include <asm/mach-types.h>
 #include <asm/arch/hardware.h>
 #include <asm/arch/mux.h>
 
-#include "musbdefs.h"
+#include "musb_core.h"
 #include "omap2430.h"
 
+#ifdef CONFIG_ARCH_OMAP3430
+#define	get_cpu_rev()	2
+#endif
 
-static int dma_off;
 
 void musb_platform_enable(struct musb *musb)
 {
-	if (is_dma_capable() && dma_off)
-		printk(KERN_WARNING "%s %s: dma not reactivated\n",
-				__FILE__, __FUNCTION__);
-	else
-		dma_off = 1;
 }
-
 void musb_platform_disable(struct musb *musb)
 {
-	if (is_dma_capable()) {
-		printk(KERN_WARNING "%s %s: dma still active\n",
-				__FILE__, __FUNCTION__);
-		dma_off = 1;
-	}
 }
-
 static void omap_vbus_power(struct musb *musb, int is_on, int sleeping)
 {
 }
 
+static void omap_set_vbus(struct musb *musb, int is_on)
+{
+	u8		devctl;
+	/* HDRC controls CPEN, but beware current surges during device
+	 * connect.  They can trigger transient overcurrent conditions
+	 * that must be ignored.
+	 */
+
+	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
+
+	if (is_on) {
+		musb->is_active = 1;
+		musb->xceiv.default_a = 1;
+		musb->xceiv.state = OTG_STATE_A_WAIT_VRISE;
+		devctl |= MUSB_DEVCTL_SESSION;
+
+		MUSB_HST_MODE(musb);
+	} else {
+		musb->is_active = 0;
+
+		/* NOTE:  we're skipping A_WAIT_VFALL -> A_IDLE and
+		 * jumping right to B_IDLE...
+		 */
+
+		musb->xceiv.default_a = 0;
+		musb->xceiv.state = OTG_STATE_B_IDLE;
+		devctl &= ~MUSB_DEVCTL_SESSION;
+
+		MUSB_DEV_MODE(musb);
+	}
+	musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
+
+	DBG(1, "VBUS %s, devctl %02x "
+		/* otg %3x conf %08x prcm %08x */ "\n",
+		otg_state_string(musb),
+		musb_readb(musb->mregs, MUSB_DEVCTL));
+}
+static int omap_set_power(struct otg_transceiver *x, unsigned mA)
+{
+	return 0;
+}
+
+int musb_platform_resume(struct musb *musb);
+
 int __init musb_platform_init(struct musb *musb)
 {
-	/* Erratum - reset value of STP has pull-down.
-	   Change it to pull-up. */
+#if defined(CONFIG_ARCH_OMAP2430)
 	omap_cfg_reg(AE5_2430_USB0HS_STP);
-
-	/* start clock */
+	/* get the clock */
 	musb->clock = clk_get((struct device *)musb->controller, "usbhs_ick");
-	clk_enable(musb->clock);
+#else
+	musb->clock = clk_get((struct device *)musb->controller, "hsusb_ick");
+#endif
+	if(IS_ERR(musb->clock))
+		return PTR_ERR(musb->clock);
+
+	musb_platform_resume(musb);
+
+	OTG_SYSCONFIG_REG &= ~ENABLEWAKEUP;	/* disable wakeup */
+	OTG_SYSCONFIG_REG &= ~NOSTDBY;		/* remove possible nostdby */
+	OTG_SYSCONFIG_REG |= SMARTSTDBY;	/* enable smart standby */
+	OTG_SYSCONFIG_REG &= ~AUTOIDLE;		/* disable auto idle */
+	OTG_SYSCONFIG_REG &= ~NOIDLE;		/* remove possible noidle */
+	OTG_SYSCONFIG_REG |= SMARTIDLE;		/* enable smart idle */
+	OTG_SYSCONFIG_REG |= AUTOIDLE;		/* enable auto idle */
 
-	omap_writel(omap_readl(OTG_INTERFSEL) | (1<<0), OTG_INTERFSEL);
-	omap_writel(omap_readl(OTG_SYSCONFIG) |
-		    ((1 << 12) | (1 << 3) | (1 << 2)),
-		    OTG_SYSCONFIG);
+	OTG_INTERFSEL_REG |= ULPI_12PIN;
 
 	pr_debug("HS USB OTG: revision 0x%x, sysconfig 0x%02x, "
 			"sysstatus 0x%x, intrfsel 0x%x, simenable  0x%x\n",
-			omap_readl(OTG_REVISION), omap_readl(OTG_SYSCONFIG),
-			omap_readl(OTG_SYSSTATUS), omap_readl(OTG_INTERFSEL),
-			omap_readl(OTG_SIMENABLE));
+			OTG_REVISION_REG, OTG_SYSCONFIG_REG, OTG_SYSSTATUS_REG,
+			OTG_INTERFSEL_REG, OTG_SIMENABLE_REG);
 
 	omap_vbus_power(musb, musb->board_mode == MUSB_HOST, 1);
 
+
+	if (is_host_enabled(musb))
+		musb->board_set_vbus = omap_set_vbus;
+	if (is_peripheral_enabled(musb))
+		musb->xceiv.set_power = omap_set_power;
+
 	return 0;
 }
 
-int __exit musb_platform_exit(struct musb *musb)
+int musb_platform_suspend(struct musb *musb)
 {
-	omap_vbus_power(musb, 0 /*off*/, 1);
+	/* in any role */
+	OTG_FORCESTDBY_REG |= ENABLEFORCE;	/* enable MSTANDBY */
+	OTG_SYSCONFIG_REG |= ENABLEWAKEUP;	/* enable wakeup */
+
 	clk_disable(musb->clock);
+	return 0;
+}
+
+int musb_platform_resume(struct musb *musb)
+{
+	clk_enable(musb->clock);
+
+	OTG_SYSCONFIG_REG &= ~ENABLEWAKEUP;	/* disable wakeup */
+	OTG_FORCESTDBY_REG &= ~ENABLEFORCE;	/* disable MSTANDBY */
+
+	return 0;
+}
+
+
+int musb_platform_exit(struct musb *musb)
+{
+
+	omap_vbus_power(musb, 0 /*off*/, 1);
+
+	musb_platform_suspend(musb);
+
+	clk_put(musb->clock);
+	musb->clock = 0;
 
 	return 0;
 }
diff -ruN linux-omap-2.6/drivers/usb/musb/omap2430.h maemo_src/drivers/usb/musb/omap2430.h
--- linux-omap-2.6/drivers/usb/musb/omap2430.h	2011-02-06 20:17:25.929999940 -0500
+++ maemo_src/drivers/usb/musb/omap2430.h	2007-10-02 03:09:32.000000000 -0400
@@ -10,18 +10,45 @@
 #ifndef __MUSB_OMAP243X_H__
 #define __MUSB_OMAP243X_H__
 
-#ifdef CONFIG_ARCH_OMAP2430
+#if defined(CONFIG_ARCH_OMAP2430) || defined(CONFIG_ARCH_OMAP3430)
+#include <asm/arch/hardware.h>
+#include <asm/arch/usb.h>
 /*
  * OMAP2430-specific definitions
  */
 
 #define MENTOR_BASE_OFFSET	0
-#define HS_OTG(offset)		(OMAP243X_HS_BASE + (offset))
-#define OTG_REVISION		HS_OTG(0x400)
-#define OTG_SYSCONFIG		HS_OTG(0x404)
-#define OTG_SYSSTATUS		HS_OTG(0x408)
-#define OTG_INTERFSEL		HS_OTG(0x40c)
-#define OTG_SIMENABLE		HS_OTG(0x410)
+#if	defined(CONFIG_ARCH_OMAP2430)
+#define	OMAP_HSOTG_BASE		(OMAP243X_HS_BASE)
+#elif	defined(CONFIG_ARCH_OMAP3430)
+#define	OMAP_HSOTG_BASE		(HS_BASE)
+#endif
+#define OMAP_HSOTG(offset)	__REG32(OMAP_HSOTG_BASE + 0x400 + (offset))
+#define OTG_REVISION_REG	OMAP_HSOTG(0x0)
+#define OTG_SYSCONFIG_REG	OMAP_HSOTG(0x4)
+#	define	MIDLEMODE	12	/* bit position */
+#	define	FORCESTDBY		(0 << MIDLEMODE)
+#	define	NOSTDBY			(1 << MIDLEMODE)
+#	define	SMARTSTDBY		(2 << MIDLEMODE)
+#	define	SIDLEMODE		3	/* bit position */
+#	define	FORCEIDLE		(0 << SIDLEMODE)
+#	define	NOIDLE			(1 << SIDLEMODE)
+#	define	SMARTIDLE		(2 << SIDLEMODE)
+#	define	ENABLEWAKEUP		(1 << 2)
+#	define	SOFTRST			(1 << 1)
+#	define	AUTOIDLE		(1 << 0)
+#define OTG_SYSSTATUS_REG	OMAP_HSOTG(0x8)
+#	define	RESETDONE		(1 << 0)
+#define OTG_INTERFSEL_REG	OMAP_HSOTG(0xc)
+#	define	EXTCP			(1 << 2)
+#	define	PHYSEL		0	/* bit position */
+#	define	UTMI_8BIT		(0 << PHYSEL)
+#	define	ULPI_12PIN		(1 << PHYSEL)
+#	define	ULPI_8PIN		(2 << PHYSEL)
+#define OTG_SIMENABLE_REG	OMAP_HSOTG(0x10)
+#	define	TM1			(1 << 0)
+#define OTG_FORCESTDBY_REG	OMAP_HSOTG(0x14)
+#	define	ENABLEFORCE		(1 << 0)
 
 #endif	/* CONFIG_ARCH_OMAP2430 */
 
diff -ruN linux-omap-2.6/drivers/usb/musb/plat_arc.h maemo_src/drivers/usb/musb/plat_arc.h
--- linux-omap-2.6/drivers/usb/musb/plat_arc.h	2011-02-06 20:17:25.929999940 -0500
+++ maemo_src/drivers/usb/musb/plat_arc.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,118 +0,0 @@
-/******************************************************************
- * Copyright 2005 Mentor Graphics Corporation
- * Copyright (C) 2005-2006 by Texas Instruments
- *
- * This file is part of the Inventra Controller Driver for Linux.
- *
- * The Inventra Controller Driver for Linux is free software; you
- * can redistribute it and/or modify it under the terms of the GNU
- * General Public License version 2 as published by the Free Software
- * Foundation.
- *
- * The Inventra Controller Driver for Linux is distributed in
- * the hope that it will be useful, but WITHOUT ANY WARRANTY;
- * without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
- * License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with The Inventra Controller Driver for Linux ; if not,
- * write to the Free Software Foundation, Inc., 59 Temple Place,
- * Suite 330, Boston, MA  02111-1307  USA
- *
- * ANY DOWNLOAD, USE, REPRODUCTION, MODIFICATION OR DISTRIBUTION
- * OF THIS DRIVER INDICATES YOUR COMPLETE AND UNCONDITIONAL ACCEPTANCE
- * OF THOSE TERMS.THIS DRIVER IS PROVIDED "AS IS" AND MENTOR GRAPHICS
- * MAKES NO WARRANTIES, EXPRESS OR IMPLIED, RELATED TO THIS DRIVER.
- * MENTOR GRAPHICS SPECIFICALLY DISCLAIMS ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY; FITNESS FOR A PARTICULAR PURPOSE AND
- * NON-INFRINGEMENT.  MENTOR GRAPHICS DOES NOT PROVIDE SUPPORT
- * SERVICES OR UPDATES FOR THIS DRIVER, EVEN IF YOU ARE A MENTOR
- * GRAPHICS SUPPORT CUSTOMER.
- ******************************************************************/
-
-/*
- * Linux-specific architecture definitions
- */
-
-#ifndef __MUSB_LINUX_PLATFORM_ARCH_H__
-#define __MUSB_LINUX_PLATFORM_ARCH_H__
-
-#include <asm/io.h>
-
-#ifndef	CONFIG_ARM
-static inline void readsl(const void __iomem *addr, void *buf, int len)
-	{ insl((unsigned long)addr, buf, len); }
-static inline void readsw(const void __iomem *addr, void *buf, int len)
-	{ insw((unsigned long)addr, buf, len); }
-static inline void readsb(const void __iomem *addr, void *buf, int len)
-	{ insb((unsigned long)addr, buf, len); }
-
-static inline void writesl(const void __iomem *addr, const void *buf, int len)
-	{ outsl((unsigned long)addr, buf, len); }
-static inline void writesw(const void __iomem *addr, const void *buf, int len)
-	{ outsw((unsigned long)addr, buf, len); }
-static inline void writesb(const void __iomem *addr, const void *buf, int len)
-	{ outsb((unsigned long)addr, buf, len); }
-
-#endif
-
-/* NOTE:  these offsets are all in bytes */
-
-static inline u16 musb_readw(const void __iomem *addr, unsigned offset)
-	{ return __raw_readw(addr + offset); }
-
-static inline u32 musb_readl(const void __iomem *addr, unsigned offset)
-	{ return __raw_readl(addr + offset); }
-
-
-static inline void musb_writew(void __iomem *addr, unsigned offset, u16 data)
-	{ __raw_writew(data, addr + offset); }
-
-static inline void musb_writel(void __iomem *addr, unsigned offset, u32 data)
-	{ __raw_writel(data, addr + offset); }
-
-
-#ifdef CONFIG_USB_TUSB6010
-
-/*
- * TUSB6010 doesn't allow 8-bit access; 16-bit access is the minimum.
- */
-static inline u8 musb_readb(const void __iomem *addr, unsigned offset)
-{
-	u16 tmp;
-	u8 val;
-
-	tmp = __raw_readw(addr + (offset & ~1));
-	if (offset & 1)
-		val = (tmp >> 8);
-	else
-		val = tmp & 0xff;
-
-	return val;
-}
-
-static inline void musb_writeb(void __iomem *addr, unsigned offset, u8 data)
-{
-	u16 tmp;
-
-	tmp = __raw_readw(addr + (offset & ~1));
-	if (offset & 1)
-		tmp = (data << 8) | (tmp & 0xff);
-	else
-		tmp = (tmp & 0xff00) | data;
-
-	__raw_writew(tmp, addr + (offset & ~1));
-}
-
-#else
-
-static inline u8 musb_readb(const void __iomem *addr, unsigned offset)
-	{ return __raw_readb(addr + offset); }
-
-static inline void musb_writeb(void __iomem *addr, unsigned offset, u8 data)
-	{ __raw_writeb(data, addr + offset); }
-
-#endif	/* CONFIG_USB_TUSB6010 */
-
-#endif
diff -ruN linux-omap-2.6/drivers/usb/musb/plat_uds.c maemo_src/drivers/usb/musb/plat_uds.c
--- linux-omap-2.6/drivers/usb/musb/plat_uds.c	2011-02-06 20:17:25.929999940 -0500
+++ maemo_src/drivers/usb/musb/plat_uds.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,2049 +0,0 @@
-/*****************************************************************
- * Copyright 2005 Mentor Graphics Corporation
- * Copyright (C) 2005-2006 by Texas Instruments
- * Copyright (C) 2006 by Nokia Corporation
- *
- * This file is part of the Inventra Controller Driver for Linux.
- *
- * The Inventra Controller Driver for Linux is free software; you
- * can redistribute it and/or modify it under the terms of the GNU
- * General Public License version 2 as published by the Free Software
- * Foundation.
- *
- * The Inventra Controller Driver for Linux is distributed in
- * the hope that it will be useful, but WITHOUT ANY WARRANTY;
- * without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
- * License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with The Inventra Controller Driver for Linux ; if not,
- * write to the Free Software Foundation, Inc., 59 Temple Place,
- * Suite 330, Boston, MA  02111-1307  USA
- *
- * ANY DOWNLOAD, USE, REPRODUCTION, MODIFICATION OR DISTRIBUTION
- * OF THIS DRIVER INDICATES YOUR COMPLETE AND UNCONDITIONAL ACCEPTANCE
- * OF THOSE TERMS.THIS DRIVER IS PROVIDED "AS IS" AND MENTOR GRAPHICS
- * MAKES NO WARRANTIES, EXPRESS OR IMPLIED, RELATED TO THIS DRIVER.
- * MENTOR GRAPHICS SPECIFICALLY DISCLAIMS ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY; FITNESS FOR A PARTICULAR PURPOSE AND
- * NON-INFRINGEMENT.  MENTOR GRAPHICS DOES NOT PROVIDE SUPPORT
- * SERVICES OR UPDATES FOR THIS DRIVER, EVEN IF YOU ARE A MENTOR
- * GRAPHICS SUPPORT CUSTOMER.
- ******************************************************************/
-
-/*
- * Inventra (Multipoint) Dual-Role Controller Driver for Linux.
- *
- * This consists of a Host Controller Driver (HCD) and a peripheral
- * controller driver implementing the "Gadget" API; OTG support is
- * in the works.  These are normal Linux-USB controller drivers which
- * use IRQs and have no dedicated thread.
- *
- * This version of the driver has only been used with products from
- * Texas Instruments.  Those products integrate the Inventra logic
- * with other DMA, IRQ, and bus modules, as well as other logic that
- * needs to be reflected in this driver.
- *
- *
- * NOTE:  the original Mentor code here was pretty much a collection
- * of mechanisms that don't seem to have been fully integrated/working
- * for *any* Linux kernel version.  This version aims at Linux 2.6.now,
- * Key open issues include:
- *
- *  - Lack of host-side transaction scheduling, for all transfer types.
- *    The hardware doesn't do it; instead, software must.
- *
- *    This is not an issue for OTG devices that don't support external
- *    hubs, but for more "normal" USB hosts it's a user issue that the
- *    "multipoint" support doesn't scale in the expected ways.  That
- *    includes DaVinci EVM in a common non-OTG mode.
- *
- *      * Control and bulk use dedicated endpoints, and there's as
- *        yet no mechanism to either (a) reclaim the hardware when
- *        peripherals are NAKing, which gets complicated with bulk
- *        endpoints, or (b) use more than a single bulk endpoint in
- *        each direction.
- *
- *        RESULT:  one device may be perceived as blocking another one.
- *
- *      * Interrupt and isochronous will dynamically allocate endpoint
- *        hardware, but (a) there's no record keeping for bandwidth;
- *        (b) in the common case that few endpoints are available, there
- *        is no mechanism to reuse endpoints to talk to multiple devices.
- *
- *        RESULT:  At one extreme, bandwidth can be overcommitted in
- *        some hardware configurations, no faults will be reported.
- *        At the other extreme, the bandwidth capabilities which do
- *        exist tend to be severely undercommitted.  You can't yet hook
- *        up both a keyboard and a mouse to an external USB hub.
- */
-
-/*
- * This gets many kinds of configuration information:
- *	- Kconfig for everything user-configurable
- *	- <asm/arch/hdrc_cnf.h> for SOC or family details
- *	- platform_device for addressing, irq, and platform_data
- *	- platform_data is mostly for board-specific informarion
- *
- * Most of the conditional compilation will (someday) vanish.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <linux/init.h>
-#include <linux/list.h>
-#include <linux/kobject.h>
-#include <linux/platform_device.h>
-
-#include <asm/io.h>
-
-#ifdef	CONFIG_ARM
-#include <asm/arch/hardware.h>
-#include <asm/arch/memory.h>
-#include <asm/mach-types.h>
-#endif
-
-#include "musbdefs.h"
-
-
-#ifdef CONFIG_ARCH_DAVINCI
-#include "davinci.h"
-#endif
-
-
-
-#if MUSB_DEBUG > 0
-unsigned debug = MUSB_DEBUG;
-module_param(debug, uint, 0);
-MODULE_PARM_DESC(debug, "initial debug message level");
-
-#define MUSB_VERSION_SUFFIX	"/dbg"
-#else
-
-const char *otg_state_string(struct musb *musb)
-{
-	static char buf[8];
-
-	snprintf(buf, sizeof buf, "otg-%d", musb->xceiv.state);
-	return buf;
-}
-#endif
-
-#define DRIVER_AUTHOR "Mentor Graphics, Texas Instruments, Nokia"
-#define DRIVER_DESC "Inventra Dual-Role USB Controller Driver"
-
-#define MUSB_VERSION_BASE "2.2a/db-0.5.2"
-
-#ifndef MUSB_VERSION_SUFFIX
-#define MUSB_VERSION_SUFFIX	""
-#endif
-#define MUSB_VERSION	MUSB_VERSION_BASE MUSB_VERSION_SUFFIX
-
-#define DRIVER_INFO DRIVER_DESC ", v" MUSB_VERSION
-
-const char musb_driver_name[] = "musb_hdrc";
-
-MODULE_DESCRIPTION(DRIVER_INFO);
-MODULE_AUTHOR(DRIVER_AUTHOR);
-MODULE_LICENSE("GPL");
-
-
-/*-------------------------------------------------------------------------*/
-
-static inline struct musb *dev_to_musb(struct device *dev)
-{
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-	/* usbcore insists dev->driver_data is a "struct hcd *" */
-	return hcd_to_musb(dev_get_drvdata(dev));
-#else
-	return dev_get_drvdata(dev);
-#endif
-}
-
-/*-------------------------------------------------------------------------*/
-
-#ifndef CONFIG_USB_TUSB6010
-/*
- * Load an endpoint's FIFO
- */
-void musb_write_fifo(struct musb_hw_ep *hw_ep, u16 wCount, const u8 *pSource)
-{
-	void __iomem *fifo = hw_ep->fifo;
-
-	prefetch((u8 *)pSource);
-
-	DBG(4, "%cX ep%d fifo %p count %d buf %p\n",
-			'T', hw_ep->bLocalEnd, fifo, wCount, pSource);
-
-	/* we can't assume unaligned reads work */
-	if (likely((0x01 & (unsigned long) pSource) == 0)) {
-		u16	index = 0;
-
-		/* best case is 32bit-aligned source address */
-		if ((0x02 & (unsigned long) pSource) == 0) {
-			if (wCount >= 4) {
-				writesl(fifo, pSource + index, wCount >> 2);
-				index += wCount & ~0x03;
-			}
-			if (wCount & 0x02) {
-				musb_writew(fifo, 0, *(u16*)&pSource[index]);
-				index += 2;
-			}
-		} else {
-			if (wCount >= 2) {
-				writesw(fifo, pSource + index, wCount >> 1);
-				index += wCount & ~0x01;
-			}
-		}
-		if (wCount & 0x01)
-			musb_writeb(fifo, 0, pSource[index]);
-	} else  {
-		/* byte aligned */
-		writesb(fifo, pSource, wCount);
-	}
-}
-
-/*
- * Unload an endpoint's FIFO
- */
-void musb_read_fifo(struct musb_hw_ep *hw_ep, u16 wCount, u8 *pDest)
-{
-	void __iomem *fifo = hw_ep->fifo;
-
-	DBG(4, "%cX ep%d fifo %p count %d buf %p\n",
-			'R', hw_ep->bLocalEnd, fifo, wCount, pDest);
-
-	/* we can't assume unaligned writes work */
-	if (likely((0x01 & (unsigned long) pDest) == 0)) {
-		u16	index = 0;
-
-		/* best case is 32bit-aligned destination address */
-		if ((0x02 & (unsigned long) pDest) == 0) {
-			if (wCount >= 4) {
-				readsl(fifo, pDest, wCount >> 2);
-				index = wCount & ~0x03;
-			}
-			if (wCount & 0x02) {
-				*(u16*)&pDest[index] = musb_readw(fifo, 0);
-				index += 2;
-			}
-		} else {
-			if (wCount >= 2) {
-				readsw(fifo, pDest, wCount >> 1);
-				index = wCount & ~0x01;
-			}
-		}
-		if (wCount & 0x01)
-			pDest[index] = musb_readb(fifo, 0);
-	} else  {
-		/* byte aligned */
-		readsb(fifo, pDest, wCount);
-	}
-}
-
-#endif	/* normal PIO */
-
-
-/*-------------------------------------------------------------------------*/
-
-/* for high speed test mode; see USB 2.0 spec 7.1.20 */
-static const u8 musb_test_packet[53] = {
-	/* implicit SYNC then DATA0 to start */
-
-	/* JKJKJKJK x9 */
-	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-	/* JJKKJJKK x8 */
-	0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
-	/* JJJJKKKK x8 */
-	0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee,
-	/* JJJJJJJKKKKKKK x8 */
-	0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
-	/* JJJJJJJK x8 */
-	0x7f, 0xbf, 0xdf, 0xef, 0xf7, 0xfb, 0xfd,
-	/* JKKKKKKK x10, JK */
-	0xfc, 0x7e, 0xbf, 0xdf, 0xef, 0xf7, 0xfb, 0xfd, 0x7e
-
-	/* implicit CRC16 then EOP to end */
-};
-
-void musb_load_testpacket(struct musb *musb)
-{
-	void __iomem	*regs = musb->aLocalEnd[0].regs;
-
-	MGC_SelectEnd(musb->pRegs, 0);
-	musb_write_fifo(musb->control_ep,
-			sizeof(musb_test_packet), musb_test_packet);
-	musb_writew(regs, MGC_O_HDRC_CSR0, MGC_M_CSR0_TXPKTRDY);
-}
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * Interrupt Service Routine to record USB "global" interrupts.
- * Since these do not happen often and signify things of
- * paramount importance, it seems OK to check them individually;
- * the order of the tests is specified in the manual
- *
- * @param pThis instance pointer
- * @param bIntrUSB register contents
- * @param devctl
- * @param power
- */
-
-#define STAGE0_MASK (MGC_M_INTR_RESUME | MGC_M_INTR_SESSREQ \
-		| MGC_M_INTR_VBUSERROR | MGC_M_INTR_CONNECT \
-		| MGC_M_INTR_RESET )
-
-static irqreturn_t musb_stage0_irq(struct musb * pThis, u8 bIntrUSB,
-				u8 devctl, u8 power)
-{
-	irqreturn_t handled = IRQ_NONE;
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-	void __iomem *pBase = pThis->pRegs;
-#endif
-
-	DBG(3, "<== Power=%02x, DevCtl=%02x, bIntrUSB=0x%x\n", power, devctl,
-		bIntrUSB);
-
-	/* in host mode, the peripheral may issue remote wakeup.
-	 * in peripheral mode, the host may resume the link.
-	 * spurious RESUME irqs happen too, paired with SUSPEND.
-	 */
-	if (bIntrUSB & MGC_M_INTR_RESUME) {
-		handled = IRQ_HANDLED;
-		DBG(3, "RESUME (%s)\n", otg_state_string(pThis));
-
-		if (devctl & MGC_M_DEVCTL_HM) {
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-			switch (pThis->xceiv.state) {
-			case OTG_STATE_A_SUSPEND:
-				/* remote wakeup?  later, GetPortStatus
-				 * will stop RESUME signaling
-				 */
-				if (power & MGC_M_POWER_RESUME) {
-					power &= ~MGC_M_POWER_SUSPENDM;
-					musb_writeb(pBase, MGC_O_HDRC_POWER,
-						power | MGC_M_POWER_RESUME);
-
-					pThis->port1_status |=
-						(USB_PORT_STAT_C_SUSPEND << 16)
-						| MUSB_PORT_STAT_RESUME;
-					pThis->rh_timer = jiffies
-						+ msecs_to_jiffies(20);
-
-					pThis->xceiv.state = OTG_STATE_A_HOST;
-					pThis->is_active = 1;
-					usb_hcd_resume_root_hub(
-							musb_to_hcd(pThis));
-
-				} else if (power & MGC_M_POWER_SUSPENDM) {
-					/* spurious */
-					pThis->int_usb &= ~MGC_M_INTR_SUSPEND;
-				}
-				break;
-			case OTG_STATE_B_WAIT_ACON:
-				pThis->xceiv.state = OTG_STATE_B_PERIPHERAL;
-				pThis->is_active = 1;
-				MUSB_DEV_MODE(pThis);
-				break;
-			default:
-				WARN("bogus %s RESUME (%s)\n",
-					"host",
-					otg_state_string(pThis));
-			}
-#endif
-		} else {
-			switch (pThis->xceiv.state) {
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-			case OTG_STATE_A_SUSPEND:
-				/* possibly DISCONNECT is upcoming */
-				pThis->xceiv.state = OTG_STATE_A_HOST;
-				usb_hcd_resume_root_hub(musb_to_hcd(pThis));
-				break;
-#endif
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
-			case OTG_STATE_B_WAIT_ACON:
-			case OTG_STATE_B_PERIPHERAL:
-				/* disconnect while suspended?  we may
-				 * not get a disconnect irq...
-				 */
-				if ((devctl & MGC_M_DEVCTL_VBUS)
-						!= (3 << MGC_S_DEVCTL_VBUS)) {
-					pThis->int_usb |= MGC_M_INTR_DISCONNECT;
-					pThis->int_usb &= ~MGC_M_INTR_SUSPEND;
-					break;
-				}
-				musb_g_resume(pThis);
-				break;
-			case OTG_STATE_B_IDLE:
-				pThis->int_usb &= ~MGC_M_INTR_SUSPEND;
-				break;
-#endif
-			default:
-				WARN("bogus %s RESUME (%s)\n",
-					"peripheral",
-					otg_state_string(pThis));
-			}
-		}
-	}
-
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-	/* see manual for the order of the tests */
-	if (bIntrUSB & MGC_M_INTR_SESSREQ) {
-		DBG(1, "SESSION_REQUEST (%s)\n", otg_state_string(pThis));
-
-		/* IRQ arrives from ID pin sense or (later, if VBUS power
-		 * is removed) SRP.  responses are time critical:
-		 *  - turn on VBUS (with silicon-specific mechanism)
-		 *  - go through A_WAIT_VRISE
-		 *  - ... to A_WAIT_BCON.
-		 * a_wait_vrise_tmout triggers VBUS_ERROR transitions
-		 */
-		musb_writeb(pBase, MGC_O_HDRC_DEVCTL, MGC_M_DEVCTL_SESSION);
-		pThis->bEnd0Stage = MGC_END0_START;
-		pThis->xceiv.state = OTG_STATE_A_IDLE;
-		MUSB_HST_MODE(pThis);
-		musb_set_vbus(pThis, 1);
-
-		handled = IRQ_HANDLED;
-	}
-
-	if (bIntrUSB & MGC_M_INTR_VBUSERROR) {
-		int	ignore = 0;
-
-		/* During connection as an A-Device, we may see a short
-		 * current spikes causing voltage drop, because of cable
-		 * and peripheral capacitance combined with vbus draw.
-		 * (So: less common with truly self-powered devices, where
-		 * vbus doesn't act like a power supply.)
-		 *
-		 * Such spikes are short; usually less than ~500 usec, max
-		 * of ~2 msec.  That is, they're not sustained overcurrent
-		 * errors, though they're reported using VBUSERROR irqs.
-		 *
-		 * Workarounds:  (a) hardware: use self powered devices.
-		 * (b) software:  ignore non-repeated VBUS errors.
-		 *
-		 * REVISIT:  do delays from lots of DEBUG_KERNEL checks
-		 * make trouble here, keeping VBUS < 4.4V ?
-		 */
-		switch (pThis->xceiv.state) {
-		case OTG_STATE_A_HOST:
-			/* recovery is dicey once we've gotten past the
-			 * initial stages of enumeration, but if VBUS
-			 * stayed ok at the other end of the link, and
-			 * another reset is due (at least for high speed,
-			 * to redo the chirp etc), it might work OK...
-			 */
-		case OTG_STATE_A_WAIT_BCON:
-		case OTG_STATE_A_WAIT_VRISE:
-			if (pThis->vbuserr_retry) {
-				pThis->vbuserr_retry--;
-				ignore = 1;
-				devctl |= MGC_M_DEVCTL_SESSION;
-				musb_writeb(pBase, MGC_O_HDRC_DEVCTL, devctl);
-			} else {
-				pThis->port1_status |=
-					  (1 << USB_PORT_FEAT_OVER_CURRENT)
-					| (1 << USB_PORT_FEAT_C_OVER_CURRENT);
-			}
-			break;
-		default:
-			break;
-		}
-
-		DBG(1, "VBUS_ERROR in %s (%02x, %s), retry #%d, port1 %08x\n",
-				otg_state_string(pThis),
-				devctl,
-				({ char *s;
-				switch (devctl & MGC_M_DEVCTL_VBUS) {
-				case 0 << MGC_S_DEVCTL_VBUS:
-					s = "<SessEnd"; break;
-				case 1 << MGC_S_DEVCTL_VBUS:
-					s = "<AValid"; break;
-				case 2 << MGC_S_DEVCTL_VBUS:
-					s = "<VBusValid"; break;
-				//case 3 << MGC_S_DEVCTL_VBUS:
-				default:
-					s = "VALID"; break;
-				}; s; }),
-				VBUSERR_RETRY_COUNT - pThis->vbuserr_retry,
-				pThis->port1_status);
-
-		/* go through A_WAIT_VFALL then start a new session */
-		if (!ignore)
-			musb_set_vbus(pThis, 0);
-		handled = IRQ_HANDLED;
-	}
-
-	if (bIntrUSB & MGC_M_INTR_CONNECT) {
-		struct usb_hcd *hcd = musb_to_hcd(pThis);
-
-		handled = IRQ_HANDLED;
-		pThis->is_active = 1;
-		set_bit(HCD_FLAG_SAW_IRQ, &hcd->flags);
-
-		pThis->bEnd0Stage = MGC_END0_START;
-
-#ifdef CONFIG_USB_MUSB_OTG
-		/* flush endpoints when transitioning from Device Mode */
-		if (is_peripheral_active(pThis)) {
-			// REVISIT HNP; just force disconnect
-		}
-		pThis->bDelayPortPowerOff = FALSE;
-#endif
-		pThis->port1_status &= ~(USB_PORT_STAT_LOW_SPEED
-					|USB_PORT_STAT_HIGH_SPEED
-					|USB_PORT_STAT_ENABLE
-					);
-		pThis->port1_status |= USB_PORT_STAT_CONNECTION
-					|(USB_PORT_STAT_C_CONNECTION << 16);
-
-		/* high vs full speed is just a guess until after reset */
-		if (devctl & MGC_M_DEVCTL_LSDEV)
-			pThis->port1_status |= USB_PORT_STAT_LOW_SPEED;
-
-		if (hcd->status_urb)
-			usb_hcd_poll_rh_status(hcd);
-		else
-			usb_hcd_resume_root_hub(hcd);
-
-		MUSB_HST_MODE(pThis);
-
-		/* indicate new connection to OTG machine */
-		switch (pThis->xceiv.state) {
-		case OTG_STATE_B_WAIT_ACON:
-			pThis->xceiv.state = OTG_STATE_B_HOST;
-			break;
-		default:
-			if ((devctl & MGC_M_DEVCTL_VBUS)
-					== (3 << MGC_S_DEVCTL_VBUS))
-				pThis->xceiv.state = OTG_STATE_A_HOST;
-			break;
-		}
-		DBG(1, "CONNECT (%s) devctl %02x\n",
-				otg_state_string(pThis), devctl);
-	}
-#endif	/* CONFIG_USB_MUSB_HDRC_HCD */
-
-	/* mentor saves a bit: bus reset and babble share the same irq.
-	 * only host sees babble; only peripheral sees bus reset.
-	 */
-	if (bIntrUSB & MGC_M_INTR_RESET) {
-		if (devctl & MGC_M_DEVCTL_HM) {
-			/*
-			 * BABBLE is an error condition, so the solution is
-			 * to avoid babble in the first place and fix whatever
-			 * causes BABBLE. When BABBLE happens we can only stop
-			 * the session.
-			 */
-			ERR("Stopping host session because of babble\n");
-			musb_writeb(pBase, MGC_O_HDRC_DEVCTL, 0);
-		} else {
-			DBG(1, "BUS RESET\n");
-
-			musb_g_reset(pThis);
-			schedule_work(&pThis->irq_work);
-		}
-
-		handled = IRQ_HANDLED;
-	}
-
-	return handled;
-}
-
-/*
- * Interrupt Service Routine to record USB "global" interrupts.
- * Since these do not happen often and signify things of
- * paramount importance, it seems OK to check them individually;
- * the order of the tests is specified in the manual
- *
- * @param pThis instance pointer
- * @param bIntrUSB register contents
- * @param devctl
- * @param power
- */
-static irqreturn_t musb_stage2_irq(struct musb * pThis, u8 bIntrUSB,
-				u8 devctl, u8 power)
-{
-	irqreturn_t handled = IRQ_NONE;
-
-#if 0
-/* REVISIT ... this would be for multiplexing periodic endpoints, or
- * supporting transfer phasing to prevent exceeding ISO bandwidth
- * limits of a given frame or microframe.
- *
- * It's not needed for peripheral side, which dedicates endpoints;
- * though it _might_ use SOF irqs for other purposes.
- *
- * And it's not currently needed for host side, which also dedicates
- * endpoints, relies on TX/RX interval registers, and isn't claimed
- * to support ISO transfers yet.
- */
-	if (bIntrUSB & MGC_M_INTR_SOF) {
-		void __iomem *pBase = pThis->pRegs;
-		struct musb_hw_ep	*ep;
-		u8 bEnd;
-		u16 wFrame;
-
-		DBG(6, "START_OF_FRAME\n");
-		handled = IRQ_HANDLED;
-
-		/* start any periodic Tx transfers waiting for current frame */
-		wFrame = musb_readw(pBase, MGC_O_HDRC_FRAME);
-		ep = pThis->aLocalEnd;
-		for (bEnd = 1; (bEnd < pThis->bEndCount)
-					&& (pThis->wEndMask >= (1 << bEnd));
-				bEnd++, ep++) {
-			// FIXME handle framecounter wraps (12 bits)
-			// eliminate duplicated StartUrb logic
-			if (ep->dwWaitFrame >= wFrame) {
-				ep->dwWaitFrame = 0;
-				printk("SOF --> periodic TX%s on %d\n",
-					ep->tx_channel ? " DMA" : "",
-					bEnd);
-				if (!ep->tx_channel)
-					musb_h_tx_start(pThis, bEnd);
-				else
-					cppi_hostdma_start(pThis, bEnd);
-			}
-		}		/* end of for loop */
-	}
-#endif
-
-	if ((bIntrUSB & MGC_M_INTR_DISCONNECT) && !pThis->bIgnoreDisconnect) {
-		DBG(1, "DISCONNECT (%s) as %s, devctl %02x\n",
-				otg_state_string(pThis),
-				MUSB_MODE(pThis), devctl);
-		handled = IRQ_HANDLED;
-
-		switch (pThis->xceiv.state) {
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-		case OTG_STATE_A_HOST:
-		case OTG_STATE_A_SUSPEND:
-			musb_root_disconnect(pThis);
-			break;
-#endif	/* HOST */
-#ifdef CONFIG_USB_MUSB_OTG
-		case OTG_STATE_A_PERIPHERAL:
-		case OTG_STATE_B_HOST:
-			musb_root_disconnect(pThis);
-			/* FALLTHROUGH */
-		case OTG_STATE_B_WAIT_ACON:
-#endif	/* OTG */
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
-		case OTG_STATE_B_PERIPHERAL:
-			musb_g_disconnect(pThis);
-			break;
-#endif	/* GADGET */
-		default:
-			WARN("unhandled DISCONNECT transition (%s)\n",
-				otg_state_string(pThis));
-			break;
-		}
-
-		schedule_work(&pThis->irq_work);
-	}
-
-	if (bIntrUSB & MGC_M_INTR_SUSPEND) {
-		DBG(1, "SUSPEND (%s) devctl %02x power %02x\n",
-				otg_state_string(pThis), devctl, power);
-		handled = IRQ_HANDLED;
-
-		switch (pThis->xceiv.state) {
-		case OTG_STATE_B_PERIPHERAL:
-			musb_g_suspend(pThis);
-			pThis->is_active = is_otg_enabled(pThis)
-					&& pThis->xceiv.gadget->b_hnp_enable;
-			if (pThis->is_active) {
-				pThis->xceiv.state = OTG_STATE_B_WAIT_ACON;
-				/* REVISIT timeout for b_ase0_brst, etc */
-			}
-			break;
-		case OTG_STATE_A_HOST:
-			pThis->xceiv.state = OTG_STATE_A_SUSPEND;
-			pThis->is_active = is_otg_enabled(pThis)
-					&& pThis->xceiv.host->b_hnp_enable;
-			break;
-		default:
-			/* "should not happen" */
-			pThis->is_active = 0;
-			break;
-		}
-	}
-
-
-	return handled;
-}
-
-/*-------------------------------------------------------------------------*/
-
-/*
-* Program the HDRC to start (enable interrupts, dma, etc.).
-*/
-void musb_start(struct musb *musb)
-{
-	void __iomem	*regs = musb->pRegs;
-	u8		devctl = musb_readb(regs, MGC_O_HDRC_DEVCTL);
-
-	DBG(2, "<== devctl %02x\n", devctl);
-
-	/*  Set INT enable registers, enable interrupts */
-	musb_writew(regs, MGC_O_HDRC_INTRTXE, musb->wEndMask);
-	musb_writew(regs, MGC_O_HDRC_INTRRXE, musb->wEndMask & 0xfffe);
-	musb_writeb(regs, MGC_O_HDRC_INTRUSBE, 0xf7);
-
-	musb_writeb(regs, MGC_O_HDRC_TESTMODE, 0);
-
-	/* put into basic highspeed mode and start session */
-	musb_writeb(regs, MGC_O_HDRC_POWER, MGC_M_POWER_ISOUPDATE
-						| MGC_M_POWER_SOFTCONN
-						| MGC_M_POWER_HSENAB
-						/* ENSUSPEND wedges tusb */
-						// | MGC_M_POWER_ENSUSPEND
-						);
-
-	musb->is_active = 0;
-	devctl = musb_readb(regs, MGC_O_HDRC_DEVCTL);
-	devctl &= ~MGC_M_DEVCTL_SESSION;
-
-	if (is_otg_enabled(musb)) {
-		/* session started after:
-		 * (a) ID-grounded irq, host mode;
-		 * (b) vbus present/connect IRQ, peripheral mode;
-		 * (c) peripheral initiates, using SRP
-		 */
-		if ((devctl & MGC_M_DEVCTL_VBUS) == MGC_M_DEVCTL_VBUS)
-			musb->is_active = 1;
-		else
-			devctl |= MGC_M_DEVCTL_SESSION;
-
-	} else if (is_host_enabled(musb)) {
-		/* assume ID pin is hard-wired to ground */
-		devctl |= MGC_M_DEVCTL_SESSION;
-
-	} else /* peripheral is enabled */ {
-		if ((devctl & MGC_M_DEVCTL_VBUS) == MGC_M_DEVCTL_VBUS)
-			musb->is_active = 1;
-	}
-	musb_platform_enable(musb);
-	musb_writeb(regs, MGC_O_HDRC_DEVCTL, devctl);
-}
-
-
-static void musb_generic_disable(struct musb *pThis)
-{
-	void __iomem	*pBase = pThis->pRegs;
-	u16	temp;
-
-	/* disable interrupts */
-	musb_writeb(pBase, MGC_O_HDRC_INTRUSBE, 0);
-	musb_writew(pBase, MGC_O_HDRC_INTRTX, 0);
-	musb_writew(pBase, MGC_O_HDRC_INTRRX, 0);
-
-	/* off */
-	musb_writeb(pBase, MGC_O_HDRC_DEVCTL, 0);
-
-	/*  flush pending interrupts */
-	temp = musb_readb(pBase, MGC_O_HDRC_INTRUSB);
-	temp = musb_readw(pBase, MGC_O_HDRC_INTRTX);
-	temp = musb_readw(pBase, MGC_O_HDRC_INTRRX);
-
-}
-
-/*
- * Make the HDRC stop (disable interrupts, etc.);
- * reversible by musb_start
- * called on gadget driver unregister
- * with controller locked, irqs blocked
- * acts as a NOP unless some role activated the hardware
- */
-void musb_stop(struct musb *musb)
-{
-	/* stop IRQs, timers, ... */
-	musb_platform_disable(musb);
-	musb_generic_disable(musb);
-	DBG(3, "HDRC disabled\n");
-
-	/* FIXME
-	 *  - mark host and/or peripheral drivers unusable/inactive
-	 *  - disable DMA (and enable it in HdrcStart)
-	 *  - make sure we can musb_start() after musb_stop(); with
-	 *    OTG mode, gadget driver module rmmod/modprobe cycles that
-	 *  - ...
-	 */
-	musb_platform_try_idle(musb);
-}
-
-static void musb_shutdown(struct platform_device *pdev)
-{
-	struct musb	*musb = dev_to_musb(&pdev->dev);
-	unsigned long	flags;
-
-	spin_lock_irqsave(&musb->Lock, flags);
-	musb_platform_disable(musb);
-	musb_generic_disable(musb);
-	if (musb->clock) {
-		clk_put(musb->clock);
-		musb->clock = NULL;
-	}
-	spin_unlock_irqrestore(&musb->Lock, flags);
-
-	/* FIXME power down */
-}
-
-
-/*-------------------------------------------------------------------------*/
-
-/*
- * The silicon either has hard-wired endpoint configurations, or else
- * "dynamic fifo" sizing.  The driver has support for both, though at this
- * writing only the dynamic sizing is very well tested.   We use normal
- * idioms to so both modes are compile-tested, but dead code elimination
- * leaves only the relevant one in the object file.
- *
- * We don't currently use dynamic fifo setup capability to do anything
- * more than selecting one of a bunch of predefined configurations.
- */
-#ifdef MUSB_C_DYNFIFO_DEF
-#define	can_dynfifo()	1
-#else
-#define	can_dynfifo()	0
-#endif
-
-#ifdef CONFIG_USB_TUSB6010
-static ushort __initdata fifo_mode = 4;
-#else
-static ushort __initdata fifo_mode = 2;
-#endif
-
-/* "modprobe ... fifo_mode=1" etc */
-module_param(fifo_mode, ushort, 0);
-MODULE_PARM_DESC(fifo_mode, "initial endpoint configuration");
-
-
-#define DYN_FIFO_SIZE (1<<(MUSB_C_RAM_BITS+2))
-
-enum fifo_style { FIFO_RXTX, FIFO_TX, FIFO_RX } __attribute__ ((packed));
-enum buf_mode { BUF_SINGLE, BUF_DOUBLE } __attribute__ ((packed));
-
-struct fifo_cfg {
-	u8		hw_ep_num;
-	enum fifo_style	style;
-	enum buf_mode	mode;
-	u16		maxpacket;
-};
-
-/*
- * tables defining fifo_mode values.  define more if you like.
- * for host side, make sure both halves of ep1 are set up.
- */
-
-/* mode 0 - fits in 2KB */
-static struct fifo_cfg __initdata mode_0_cfg[] = {
-{ .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num = 1, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num = 2, .style = FIFO_RXTX, .maxpacket = 512, },
-{ .hw_ep_num = 3, .style = FIFO_RXTX, .maxpacket = 256, },
-{ .hw_ep_num = 4, .style = FIFO_RXTX, .maxpacket = 256, },
-};
-
-/* mode 1 - fits in 4KB */
-static struct fifo_cfg __initdata mode_1_cfg[] = {
-{ .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
-{ .hw_ep_num = 1, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
-{ .hw_ep_num = 2, .style = FIFO_RXTX, .maxpacket = 512, .mode = BUF_DOUBLE, },
-{ .hw_ep_num = 3, .style = FIFO_RXTX, .maxpacket = 256, },
-{ .hw_ep_num = 4, .style = FIFO_RXTX, .maxpacket = 256, },
-};
-
-/* mode 2 - fits in 4KB */
-static struct fifo_cfg __initdata mode_2_cfg[] = {
-{ .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num = 1, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num = 2, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num = 2, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num = 3, .style = FIFO_RXTX, .maxpacket = 256, },
-{ .hw_ep_num = 4, .style = FIFO_RXTX, .maxpacket = 256, },
-};
-
-/* mode 3 - fits in 4KB */
-static struct fifo_cfg __initdata mode_3_cfg[] = {
-{ .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
-{ .hw_ep_num = 1, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_DOUBLE, },
-{ .hw_ep_num = 2, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num = 2, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num = 3, .style = FIFO_RXTX, .maxpacket = 256, },
-{ .hw_ep_num = 4, .style = FIFO_RXTX, .maxpacket = 256, },
-};
-
-/* mode 4 - fits in 16KB */
-static struct fifo_cfg __initdata mode_4_cfg[] = {
-{ .hw_ep_num =  1, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num =  1, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num =  2, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num =  2, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num =  3, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num =  3, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num =  4, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num =  4, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num =  5, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num =  5, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num =  6, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num =  6, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num =  7, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num =  7, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num =  8, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num =  8, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num =  9, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num =  9, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num = 10, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num = 10, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num = 11, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num = 11, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num = 12, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num = 12, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num = 13, .style = FIFO_TX,   .maxpacket = 512, },
-{ .hw_ep_num = 13, .style = FIFO_RX,   .maxpacket = 512, },
-{ .hw_ep_num = 14, .style = FIFO_RXTX, .maxpacket = 1024, },
-{ .hw_ep_num = 15, .style = FIFO_RXTX, .maxpacket = 1024, },
-};
-
-
-/*
- * configure a fifo; for non-shared endpoints, this may be called
- * once for a tx fifo and once for an rx fifo.
- *
- * returns negative errno or offset for next fifo.
- */
-static int __init
-fifo_setup(struct musb *musb, struct musb_hw_ep  *hw_ep,
-		const struct fifo_cfg *cfg, u16 offset)
-{
-	void __iomem	*mbase = musb->pRegs;
-	int	size = 0;
-	u16	maxpacket = cfg->maxpacket;
-	u16	c_off = offset >> 3;
-	u8	c_size;
-
-	/* expect hw_ep has already been zero-initialized */
-
-	size = ffs(max(maxpacket, (u16) 8)) - 1;
-	maxpacket = 1 << size;
-
-	c_size = size - 3;
-	if (cfg->mode == BUF_DOUBLE) {
-		if ((offset + (maxpacket << 1)) > DYN_FIFO_SIZE)
-			return -EMSGSIZE;
-		c_size |= MGC_M_FIFOSZ_DPB;
-	} else {
-		if ((offset + maxpacket) > DYN_FIFO_SIZE)
-			return -EMSGSIZE;
-	}
-
-	/* configure the FIFO */
-	musb_writeb(mbase, MGC_O_HDRC_INDEX, hw_ep->bLocalEnd);
-
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-	/* EP0 reserved endpoint for control, bidirectional;
-	 * EP1 reserved for bulk, two unidirection halves.
-	 */
-	if (hw_ep->bLocalEnd == 1)
-		musb->bulk_ep = hw_ep;
-	/* REVISIT error check:  be sure ep0 can both rx and tx ... */
-#endif
-	switch (cfg->style) {
-	case FIFO_TX:
-		musb_writeb(mbase, MGC_O_HDRC_TXFIFOSZ, c_size);
-		musb_writew(mbase, MGC_O_HDRC_TXFIFOADD, c_off);
-		hw_ep->tx_double_buffered = !!(c_size & MGC_M_FIFOSZ_DPB);
-		hw_ep->wMaxPacketSizeTx = maxpacket;
-		break;
-	case FIFO_RX:
-		musb_writeb(mbase, MGC_O_HDRC_RXFIFOSZ, c_size);
-		musb_writew(mbase, MGC_O_HDRC_RXFIFOADD, c_off);
-		hw_ep->rx_double_buffered = !!(c_size & MGC_M_FIFOSZ_DPB);
-		hw_ep->wMaxPacketSizeRx = maxpacket;
-		break;
-	case FIFO_RXTX:
-		musb_writeb(mbase, MGC_O_HDRC_TXFIFOSZ, c_size);
-		musb_writew(mbase, MGC_O_HDRC_TXFIFOADD, c_off);
-		hw_ep->rx_double_buffered = !!(c_size & MGC_M_FIFOSZ_DPB);
-		hw_ep->wMaxPacketSizeRx = maxpacket;
-
-		musb_writeb(mbase, MGC_O_HDRC_RXFIFOSZ, c_size);
-		musb_writew(mbase, MGC_O_HDRC_RXFIFOADD, c_off);
-		hw_ep->tx_double_buffered = hw_ep->rx_double_buffered;
-		hw_ep->wMaxPacketSizeTx = maxpacket;
-
-		hw_ep->bIsSharedFifo = TRUE;
-		break;
-	}
-
-	/* NOTE rx and tx endpoint irqs aren't managed separately,
-	 * which happens to be ok
-	 */
-	musb->wEndMask |= (1 << hw_ep->bLocalEnd);
-
-	return offset + (maxpacket << ((c_size & MGC_M_FIFOSZ_DPB) ? 1 : 0));
-}
-
-static struct fifo_cfg __initdata ep0_cfg = {
-	.style = FIFO_RXTX, .maxpacket = 64,
-};
-
-static int __init ep_config_from_table(struct musb *musb)
-{
-	const struct fifo_cfg	*cfg;
-	unsigned		i, n;
-	int			offset;
-	struct musb_hw_ep	*hw_ep = musb->aLocalEnd;
-
-	switch (fifo_mode) {
-	default:
-		fifo_mode = 0;
-		/* FALLTHROUGH */
-	case 0:
-		cfg = mode_0_cfg;
-		n = ARRAY_SIZE(mode_0_cfg);
-		break;
-	case 1:
-		cfg = mode_1_cfg;
-		n = ARRAY_SIZE(mode_1_cfg);
-		break;
-	case 2:
-		cfg = mode_2_cfg;
-		n = ARRAY_SIZE(mode_2_cfg);
-		break;
-	case 3:
-		cfg = mode_3_cfg;
-		n = ARRAY_SIZE(mode_3_cfg);
-		break;
-	case 4:
-		cfg = mode_4_cfg;
-		n = ARRAY_SIZE(mode_4_cfg);
-		break;
-	}
-
-	printk(KERN_DEBUG "%s: setup fifo_mode %d\n",
-			musb_driver_name, fifo_mode);
-
-
-	offset = fifo_setup(musb, hw_ep, &ep0_cfg, 0);
-	// assert(offset > 0)
-
-	/* NOTE:  for RTL versions >= 1.400 EPINFO and RAMINFO would
-	 * be better than static MUSB_C_NUM_EPS and DYN_FIFO_SIZE...
-	 */
-
-	for (i = 0; i < n; i++) {
-		u8	epn = cfg->hw_ep_num;
-
-		if (epn >= MUSB_C_NUM_EPS) {
-			pr_debug( "%s: invalid ep %d\n",
-					musb_driver_name, epn);
-			continue;
-		}
-		offset = fifo_setup(musb, hw_ep + epn, cfg++, offset);
-		if (offset < 0) {
-			pr_debug( "%s: mem overrun, ep %d\n",
-					musb_driver_name, epn);
-			return -EINVAL;
-		}
-		epn++;
-		musb->bEndCount = max(epn, musb->bEndCount);
-	}
-
-	printk(KERN_DEBUG "%s: %d/%d max ep, %d/%d memory\n",
-			musb_driver_name,
-			n + 1, MUSB_C_NUM_EPS * 2 - 1,
-			offset, DYN_FIFO_SIZE);
-
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-	if (!musb->bulk_ep) {
-		pr_debug( "%s: missing bulk\n", musb_driver_name);
-		return -EINVAL;
-	}
-#endif
-
-	return 0;
-}
-
-
-/*
- * ep_config_from_hw - when MUSB_C_DYNFIFO_DEF is false
- * @param pThis the controller
- */
-static int __init ep_config_from_hw(struct musb *musb)
-{
-	u8 bEnd = 0, reg;
-	struct musb_hw_ep *pEnd;
-	void *pBase = musb->pRegs;
-
-	DBG(2, "<== static silicon ep config\n");
-
-	/* FIXME pick up ep0 maxpacket size */
-
-	for (bEnd = 1; bEnd < MUSB_C_NUM_EPS; bEnd++) {
-		MGC_SelectEnd(pBase, bEnd);
-		pEnd = musb->aLocalEnd + bEnd;
-
-		/* read from core using indexed model */
-		reg = musb_readb(pEnd->regs, 0x10 + MGC_O_HDRC_FIFOSIZE);
-		if (!reg) {
-			/* 0's returned when no more endpoints */
-			break;
-		}
-		musb->bEndCount++;
-		musb->wEndMask |= (1 << bEnd);
-
-		pEnd->wMaxPacketSizeTx = 1 << (reg & 0x0f);
-
-		/* shared TX/RX FIFO? */
-		if ((reg & 0xf0) == 0xf0) {
-			pEnd->wMaxPacketSizeRx = pEnd->wMaxPacketSizeTx;
-			pEnd->bIsSharedFifo = TRUE;
-			continue;
-		} else {
-			pEnd->wMaxPacketSizeRx = 1 << ((reg & 0xf0) >> 4);
-			pEnd->bIsSharedFifo = FALSE;
-		}
-
-		/* FIXME set up pEnd->{rx,tx}_double_buffered */
-
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-		/* pick an RX/TX endpoint for bulk */
-		if (pEnd->wMaxPacketSizeTx < 512
-				|| pEnd->wMaxPacketSizeRx < 512)
-			continue;
-
-		/* REVISIT:  this algorithm is lazy, we should at least
-		 * try to pick a double buffered endpoint.
-		 */
-		if (musb->bulk_ep)
-			continue;
-		musb->bulk_ep = pEnd;
-#endif
-	}
-
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-	if (!musb->bulk_ep) {
-		pr_debug( "%s: missing bulk\n", musb_driver_name);
-		return -EINVAL;
-	}
-#endif
-
-	return 0;
-}
-
-enum { MUSB_CONTROLLER_MHDRC, MUSB_CONTROLLER_HDRC, };
-
-/* Initialize MUSB (M)HDRC part of the USB hardware subsystem;
- * configure endpoints, or take their config from silicon
- */
-static int __init musb_core_init(u16 wType, struct musb *pThis)
-{
-#ifdef MUSB_AHB_ID
-	u32 dwData;
-#endif
-	u8 reg;
-	char *type;
-	u16 wRelease, wRelMajor, wRelMinor;
-	char aInfo[78], aRevision[32], aDate[12];
-	void __iomem	*pBase = pThis->pRegs;
-	int		status = 0;
-	int		i;
-
-	/* log core options (read using indexed model) */
-	MGC_SelectEnd(pBase, 0);
-	reg = musb_readb(pBase, 0x10 + MGC_O_HDRC_CONFIGDATA);
-
-	strcpy(aInfo, (reg & MGC_M_CONFIGDATA_UTMIDW) ? "UTMI-16" : "UTMI-8");
-	if (reg & MGC_M_CONFIGDATA_DYNFIFO) {
-		strcat(aInfo, ", dyn FIFOs");
-	}
-	if (reg & MGC_M_CONFIGDATA_MPRXE) {
-		strcat(aInfo, ", bulk combine");
-#ifdef C_MP_RX
-		pThis->bBulkCombine = TRUE;
-#else
-		strcat(aInfo, " (X)");		/* no driver support */
-#endif
-	}
-	if (reg & MGC_M_CONFIGDATA_MPTXE) {
-		strcat(aInfo, ", bulk split");
-#ifdef C_MP_TX
-		pThis->bBulkSplit = TRUE;
-#else
-		strcat(aInfo, " (X)");		/* no driver support */
-#endif
-	}
-	if (reg & MGC_M_CONFIGDATA_HBRXE) {
-		strcat(aInfo, ", HB-ISO Rx");
-		strcat(aInfo, " (X)");		/* no driver support */
-	}
-	if (reg & MGC_M_CONFIGDATA_HBTXE) {
-		strcat(aInfo, ", HB-ISO Tx");
-		strcat(aInfo, " (X)");		/* no driver support */
-	}
-	if (reg & MGC_M_CONFIGDATA_SOFTCONE) {
-		strcat(aInfo, ", SoftConn");
-	}
-
-	printk(KERN_DEBUG "%s: ConfigData=0x%02x (%s)\n",
-			musb_driver_name, reg, aInfo);
-
-#ifdef MUSB_AHB_ID
-	dwData = musb_readl(pBase, 0x404);
-	sprintf(aDate, "%04d-%02x-%02x", (dwData & 0xffff),
-		(dwData >> 16) & 0xff, (dwData >> 24) & 0xff);
-	/* FIXME ID2 and ID3 are unused */
-	dwData = musb_readl(pBase, 0x408);
-	printk("ID2=%lx\n", (long unsigned)dwData);
-	dwData = musb_readl(pBase, 0x40c);
-	printk("ID3=%lx\n", (long unsigned)dwData);
-	reg = musb_readb(pBase, 0x400);
-	wType = ('M' == reg) ? MUSB_CONTROLLER_MHDRC : MUSB_CONTROLLER_HDRC;
-#else
-	aDate[0] = 0;
-#endif
-	if (MUSB_CONTROLLER_MHDRC == wType) {
-		pThis->bIsMultipoint = 1;
-		type = "M";
-	} else {
-		pThis->bIsMultipoint = 0;
-		type = "";
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-#ifndef	CONFIG_USB_OTG_BLACKLIST_HUB
-		printk(KERN_ERR
-			"%s: kernel must blacklist external hubs\n",
-			musb_driver_name);
-#endif
-#endif
-	}
-
-	/* log release info */
-	wRelease = musb_readw(pBase, MGC_O_HDRC_HWVERS);
-	wRelMajor = (wRelease >> 10) & 0x1f;
-	wRelMinor = wRelease & 0x3ff;
-	snprintf(aRevision, 32, "%d.%d%s", wRelMajor,
-		wRelMinor, (wRelease & 0x8000) ? "RC" : "");
-	printk(KERN_DEBUG "%s: %sHDRC RTL version %s %s\n",
-			musb_driver_name, type, aRevision, aDate);
-
-	/* configure ep0 */
-	pThis->aLocalEnd[0].wMaxPacketSizeTx = MGC_END0_FIFOSIZE;
-	pThis->aLocalEnd[0].wMaxPacketSizeRx = MGC_END0_FIFOSIZE;
-
-	/* discover endpoint configuration */
-	pThis->bEndCount = 1;
-	pThis->wEndMask = 1;
-
-	if (reg & MGC_M_CONFIGDATA_DYNFIFO) {
-		if (can_dynfifo())
-			status = ep_config_from_table(pThis);
-		else {
-			ERR("reconfigure software for Dynamic FIFOs\n");
-			status = -ENODEV;
-		}
-	} else {
-		if (!can_dynfifo())
-			status = ep_config_from_hw(pThis);
-		else {
-			ERR("reconfigure software for static FIFOs\n");
-			return -ENODEV;
-		}
-	}
-
-	if (status < 0)
-		return status;
-
-	/* finish init, and print endpoint config */
-	for (i = 0; i < pThis->bEndCount; i++) {
-		struct musb_hw_ep	*hw_ep = pThis->aLocalEnd + i;
-
-		hw_ep->fifo = MUSB_FIFO_OFFSET(i) + pBase;
-#ifdef CONFIG_USB_TUSB6010
-		hw_ep->fifo_async = pThis->async + 0x400 + MUSB_FIFO_OFFSET(i);
-		hw_ep->fifo_sync = pThis->sync + 0x400 + MUSB_FIFO_OFFSET(i);
-		hw_ep->fifo_sync_va =
-			pThis->sync_va + 0x400 + MUSB_FIFO_OFFSET(i);
-
-		if (i == 0)
-			hw_ep->conf = pBase - 0x400 + TUSB_EP0_CONF;
-		else
-			hw_ep->conf = pBase + 0x400 + (((i - 1) & 0xf) << 2);
-#endif
-
-		hw_ep->regs = MGC_END_OFFSET(i, 0) + pBase;
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-		hw_ep->target_regs = MGC_BUSCTL_OFFSET(i, 0) + pBase;
-		hw_ep->rx_reinit = 1;
-		hw_ep->tx_reinit = 1;
-#endif
-
-		if (hw_ep->wMaxPacketSizeTx) {
-			printk(KERN_DEBUG
-				"%s: hw_ep %d%s, %smax %d\n",
-				musb_driver_name, i,
-				hw_ep->bIsSharedFifo ? "shared" : "tx",
-				hw_ep->tx_double_buffered
-					? "doublebuffer, " : "",
-				hw_ep->wMaxPacketSizeTx);
-		}
-		if (hw_ep->wMaxPacketSizeRx && !hw_ep->bIsSharedFifo) {
-			printk(KERN_DEBUG
-				"%s: hw_ep %d%s, %smax %d\n",
-				musb_driver_name, i,
-				"rx",
-				hw_ep->rx_double_buffered
-					? "doublebuffer, " : "",
-				hw_ep->wMaxPacketSizeRx);
-		}
-		if (!(hw_ep->wMaxPacketSizeTx || hw_ep->wMaxPacketSizeRx))
-			DBG(1, "hw_ep %d not configured\n", i);
-	}
-
-	return 0;
-}
-
-/*-------------------------------------------------------------------------*/
-
-#ifdef CONFIG_ARCH_OMAP2430
-
-static irqreturn_t generic_interrupt(int irq, void *__hci)
-{
-	unsigned long	flags;
-	irqreturn_t	retval = IRQ_NONE;
-	struct musb	*musb = __hci;
-
-	spin_lock_irqsave(&musb->Lock, flags);
-
-	musb->int_usb = musb_readb(musb->pRegs, MGC_O_HDRC_INTRUSB);
-	musb->int_tx = musb_readw(musb->pRegs, MGC_O_HDRC_INTRTX);
-	musb->int_rx = musb_readw(musb->pRegs, MGC_O_HDRC_INTRRX);
-
-	if (musb->int_usb || musb->int_tx || musb->int_rx)
-		retval = musb_interrupt(musb);
-
-	spin_unlock_irqrestore(&musb->Lock, flags);
-
-	/* REVISIT we sometimes get spurious IRQs on g_ep0
-	 * not clear why...
-	 */
-	if (retval != IRQ_HANDLED)
-		DBG(5, "spurious?\n");
-
-	return IRQ_HANDLED;
-}
-
-#else
-#define generic_interrupt	NULL
-#endif
-
-/*
- * handle all the irqs defined by the HDRC core. for now we expect:  other
- * irq sources (phy, dma, etc) will be handled first, musb->int_* values
- * will be assigned, and the irq will already have been acked.
- *
- * called in irq context with spinlock held, irqs blocked
- */
-irqreturn_t musb_interrupt(struct musb *musb)
-{
-	irqreturn_t	retval = IRQ_NONE;
-	u8		devctl, power;
-	int		ep_num;
-	u32		reg;
-
-	devctl = musb_readb(musb->pRegs, MGC_O_HDRC_DEVCTL);
-	power = musb_readb(musb->pRegs, MGC_O_HDRC_POWER);
-
-	DBG(4, "** IRQ %s usb%04x tx%04x rx%04x\n",
-		(devctl & MGC_M_DEVCTL_HM) ? "host" : "peripheral",
-		musb->int_usb, musb->int_tx, musb->int_rx);
-
-	/* the core can interrupt us for multiple reasons; docs have
-	 * a generic interrupt flowchart to follow
-	 */
-	if (musb->int_usb & STAGE0_MASK)
-		retval |= musb_stage0_irq(musb, musb->int_usb,
-				devctl, power);
-
-	/* "stage 1" is handling endpoint irqs */
-
-	/* handle endpoint 0 first */
-	if (musb->int_tx & 1) {
-		if (devctl & MGC_M_DEVCTL_HM)
-			retval |= musb_h_ep0_irq(musb);
-		else
-			retval |= musb_g_ep0_irq(musb);
-	}
-
-	/* RX on endpoints 1-15 */
-	reg = musb->int_rx >> 1;
-	ep_num = 1;
-	while (reg) {
-		if (reg & 1) {
-			// MGC_SelectEnd(musb->pRegs, ep_num);
-			/* REVISIT just retval = ep->rx_irq(...) */
-			retval = IRQ_HANDLED;
-			if (devctl & MGC_M_DEVCTL_HM) {
-				if (is_host_capable())
-					musb_host_rx(musb, ep_num);
-			} else {
-				if (is_peripheral_capable())
-					musb_g_rx(musb, ep_num);
-			}
-		}
-
-		reg >>= 1;
-		ep_num++;
-	}
-
-	/* TX on endpoints 1-15 */
-	reg = musb->int_tx >> 1;
-	ep_num = 1;
-	while (reg) {
-		if (reg & 1) {
-			// MGC_SelectEnd(musb->pRegs, ep_num);
-			/* REVISIT just retval |= ep->tx_irq(...) */
-			retval = IRQ_HANDLED;
-			if (devctl & MGC_M_DEVCTL_HM) {
-				if (is_host_capable())
-					musb_host_tx(musb, ep_num);
-			} else {
-				if (is_peripheral_capable())
-					musb_g_tx(musb, ep_num);
-			}
-		}
-		reg >>= 1;
-		ep_num++;
-	}
-
-	/* finish handling "global" interrupts after handling fifos */
-	if (musb->int_usb)
-		retval |= musb_stage2_irq(musb,
-				musb->int_usb, devctl, power);
-
-	return retval;
-}
-
-
-#ifndef CONFIG_USB_INVENTRA_FIFO
-static int __initdata use_dma = 1;
-
-/* "modprobe ... use_dma=0" etc */
-module_param(use_dma, bool, 0);
-MODULE_PARM_DESC(use_dma, "enable/disable use of DMA");
-
-void musb_dma_completion(struct musb *musb, u8 bLocalEnd, u8 bTransmit)
-{
-	u8	devctl = musb_readb(musb->pRegs, MGC_O_HDRC_DEVCTL);
-
-	/* called with controller lock already held */
-
-	if (!bLocalEnd) {
-#ifndef CONFIG_USB_TUSB_OMAP_DMA
-		if (!is_cppi_enabled()) {
-			/* endpoint 0 */
-			if (devctl & MGC_M_DEVCTL_HM)
-				musb_h_ep0_irq(musb);
-			else
-				musb_g_ep0_irq(musb);
-		}
-#endif
-	} else {
-		/* endpoints 1..15 */
-		if (bTransmit) {
-			if (devctl & MGC_M_DEVCTL_HM) {
-				if (is_host_capable())
-					musb_host_tx(musb, bLocalEnd);
-			} else {
-				if (is_peripheral_capable())
-					musb_g_tx(musb, bLocalEnd);
-			}
-		} else {
-			/* receive */
-			if (devctl & MGC_M_DEVCTL_HM) {
-				if (is_host_capable())
-					musb_host_rx(musb, bLocalEnd);
-			} else {
-				if (is_peripheral_capable())
-					musb_g_rx(musb, bLocalEnd);
-			}
-		}
-	}
-}
-
-#else
-#define use_dma			0
-#endif
-
-/*-------------------------------------------------------------------------*/
-
-#ifdef CONFIG_SYSFS
-
-static ssize_t
-musb_mode_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	struct musb *musb = dev_to_musb(dev);
-	unsigned long flags;
-	int ret = -EINVAL;
-
-	spin_lock_irqsave(&musb->Lock, flags);
-	switch (musb->board_mode) {
-	case MUSB_HOST:
-		ret = sprintf(buf, "host\n");
-		break;
-	case MUSB_PERIPHERAL:
-		ret = sprintf(buf, "peripheral\n");
-		break;
-	case MUSB_OTG:
-		ret = sprintf(buf, "otg\n");
-		break;
-	}
-	spin_unlock_irqrestore(&musb->Lock, flags);
-
-	return ret;
-}
-
-static ssize_t
-musb_mode_store(struct device *dev, struct device_attribute *attr,
-		const char *buf, size_t n)
-{
-	struct musb	*musb = dev_to_musb(dev);
-	unsigned long	flags;
-
-	spin_lock_irqsave(&musb->Lock, flags);
-	if (!strncmp(buf, "host", 4))
-		musb_platform_set_mode(musb, MUSB_HOST);
-	if (!strncmp(buf, "peripheral", 10))
-		musb_platform_set_mode(musb, MUSB_PERIPHERAL);
-	if (!strncmp(buf, "otg", 3))
-		musb_platform_set_mode(musb, MUSB_OTG);
-	spin_unlock_irqrestore(&musb->Lock, flags);
-
-	return n;
-}
-static DEVICE_ATTR(mode, 0644, musb_mode_show, musb_mode_store);
-
-static ssize_t
-musb_cable_show(struct device *dev, struct device_attribute *attr, char *buf)
-{
-	struct musb *musb = dev_to_musb(dev);
-	char *v1= "", *v2 = "?";
-	unsigned long flags;
-	int vbus;
-
-	spin_lock_irqsave(&musb->Lock, flags);
-#if defined(CONFIG_USB_TUSB6010) && !defined(CONFIG_USB_MUSB_OTG)
-	/* REVISIT: connect-A != connect-B ... */
-	vbus = musb_platform_get_vbus_status(musb);
-	if (vbus)
-		v2 = "connected";
-	else
-		v2 = "disconnected";
-#else
-	/* NOTE: board-specific issues, like too-big capacitors keeping
-	 * VBUS high for a long time after power has been removed, can
-	 * cause temporary false indications of a connection.
-	 */
-	vbus = musb_readb(musb->pRegs, MGC_O_HDRC_DEVCTL);
-	if (vbus & 0x10) {
-		/* REVISIT retest on real OTG hardware */
-		switch (musb->board_mode) {
-		case MUSB_HOST:
-			v2 = "A";
-			break;
-		case MUSB_PERIPHERAL:
-			v2 = "B";
-			break;
-		case MUSB_OTG:
-			v1 = "Mini-";
-			v2 = (vbus & MGC_M_DEVCTL_BDEVICE) ? "B" : "A";
-			break;
-		}
-	} else	/* VBUS level below A-Valid */
-		v2 = "disconnected";
-#endif
-	musb_platform_try_idle(musb);
-	spin_unlock_irqrestore(&musb->Lock, flags);
-
-	return sprintf(buf, "%s%s\n", v1, v2);
-}
-static DEVICE_ATTR(cable, S_IRUGO, musb_cable_show, NULL);
-
-#endif
-
-/* Only used to provide cable state change events */
-static void musb_irq_work(struct work_struct *data)
-{
-	struct musb *musb = container_of(data, struct musb, irq_work);
-
-	sysfs_notify(&musb->controller->kobj, NULL, "cable");
-}
-
-/* --------------------------------------------------------------------------
- * Init support
- */
-
-static struct musb *__init
-allocate_instance(struct device *dev, void __iomem *mbase)
-{
-	struct musb		*musb;
-	struct musb_hw_ep	*ep;
-	int			epnum;
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-	struct usb_hcd	*hcd;
-
-	hcd = usb_create_hcd(&musb_hc_driver, dev, dev->bus_id);
-	if (!hcd)
-		return NULL;
-	/* usbcore sets dev->driver_data to hcd, and sometimes uses that... */
-
-	musb = hcd_to_musb(hcd);
-	INIT_LIST_HEAD(&musb->control);
-	INIT_LIST_HEAD(&musb->in_bulk);
-	INIT_LIST_HEAD(&musb->out_bulk);
-
-	hcd->uses_new_polling = 1;
-
-	musb->vbuserr_retry = VBUSERR_RETRY_COUNT;
-#else
-	musb = kzalloc(sizeof *musb, GFP_KERNEL);
-	if (!musb)
-		return NULL;
-	dev_set_drvdata(dev, musb);
-
-#endif
-
-	musb->pRegs = mbase;
-	musb->ctrl_base = mbase;
-	musb->nIrq = -ENODEV;
-	for (epnum = 0, ep = musb->aLocalEnd;
-			epnum < MUSB_C_NUM_EPS;
-			epnum++, ep++) {
-
-		ep->musb = musb;
-		ep->bLocalEnd = epnum;
-	}
-
-	musb->controller = dev;
-	return musb;
-}
-
-static void musb_free(struct musb *musb)
-{
-	/* this has multiple entry modes. it handles fault cleanup after
-	 * probe(), where things may be partially set up, as well as rmmod
-	 * cleanup after everything's been de-activated.
-	 */
-
-#ifdef CONFIG_SYSFS
-	device_remove_file(musb->controller, &dev_attr_mode);
-	device_remove_file(musb->controller, &dev_attr_cable);
-#endif
-
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
-	musb_gadget_cleanup(musb);
-#endif
-
-	if (musb->nIrq >= 0) {
-		disable_irq_wake(musb->nIrq);
-		free_irq(musb->nIrq, musb);
-	}
-	if (is_dma_capable() && musb->pDmaController) {
-		struct dma_controller	*c = musb->pDmaController;
-
-		(void) c->stop(c->pPrivateData);
-		dma_controller_destroy(c);
-	}
-
-	musb_writeb(musb->pRegs, MGC_O_HDRC_DEVCTL, 0);
-	musb_platform_exit(musb);
-	musb_writeb(musb->pRegs, MGC_O_HDRC_DEVCTL, 0);
-
-	if (musb->clock) {
-		clk_disable(musb->clock);
-		clk_put(musb->clock);
-	}
-
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-	usb_put_hcd(musb_to_hcd(musb));
-#else
-	kfree(musb);
-#endif
-}
-
-/*
- * Perform generic per-controller initialization.
- *
- * @pDevice: the controller (already clocked, etc)
- * @nIrq: irq
- * @pRegs: virtual address of controller registers,
- *	not yet corrected for platform-specific offsets
- */
-static int __init
-musb_init_controller(struct device *dev, int nIrq, void __iomem *ctrl)
-{
-	int			status;
-	struct musb		*pThis;
-	struct musb_hdrc_platform_data *plat = dev->platform_data;
-
-	/* The driver might handle more features than the board; OK.
-	 * Fail when the board needs a feature that's not enabled.
-	 */
-	if (!plat) {
-		dev_dbg(dev, "no platform_data?\n");
-		return -ENODEV;
-	}
-	switch (plat->mode) {
-	case MUSB_HOST:
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-		break;
-#else
-		goto bad_config;
-#endif
-	case MUSB_PERIPHERAL:
-#ifdef CONFIG_USB_GADGET_MUSB_HDRC
-		break;
-#else
-		goto bad_config;
-#endif
-	case MUSB_OTG:
-#ifdef CONFIG_USB_MUSB_OTG
-		break;
-#else
-	bad_config:
-#endif
-	default:
-		dev_err(dev, "incompatible Kconfig role setting\n");
-		return -EINVAL;
-	}
-
-	/* allocate */
-	pThis = allocate_instance(dev, ctrl);
-	if (!pThis)
-		return -ENOMEM;
-
-	spin_lock_init(&pThis->Lock);
-	pThis->board_mode = plat->mode;
-	pThis->board_set_power = plat->set_power;
-	pThis->set_clock = plat->set_clock;
-	pThis->min_power = plat->min_power;
-
-	/* Clock usage is chip-specific ... functional clock (DaVinci,
-	 * OMAP2430), or PHY ref (some TUSB6010 boards).  All this core
-	 * code does is make sure a clock handle is available; platform
-	 * code manages it during start/stop and suspend/resume.
-	 */
-	if (plat->clock) {
-		pThis->clock = clk_get(dev, plat->clock);
-		if (IS_ERR(pThis->clock)) {
-			status = PTR_ERR(pThis->clock);
-			pThis->clock = NULL;
-			goto fail;
-		}
-	}
-
-	/* assume vbus is off */
-
-	/* platform adjusts pThis->pRegs and pThis->isr if needed,
-	 * and activates clocks
-	 */
-	pThis->isr = generic_interrupt;
-	status = musb_platform_init(pThis);
-
-	if (status < 0)
-		goto fail;
-	if (!pThis->isr) {
-		status = -ENODEV;
-		goto fail2;
-	}
-
-#ifndef CONFIG_USB_INVENTRA_FIFO
-	if (use_dma && dev->dma_mask) {
-		struct dma_controller	*c;
-
-		c = dma_controller_create(pThis, pThis->pRegs);
-		pThis->pDmaController = c;
-		if (c)
-			(void) c->start(c->pPrivateData);
-	}
-#endif
-	/* ideally this would be abstracted in platform setup */
-	if (!is_dma_capable() || !pThis->pDmaController)
-		dev->dma_mask = NULL;
-
-	/* be sure interrupts are disabled before connecting ISR */
-	musb_platform_disable(pThis);
-
-	/* setup musb parts of the core (especially endpoints) */
-	status = musb_core_init(plat->multipoint
-			? MUSB_CONTROLLER_MHDRC
-			: MUSB_CONTROLLER_HDRC, pThis);
-	if (status < 0)
-		goto fail2;
-
-	/* attach to the IRQ */
-	if (request_irq (nIrq, pThis->isr, 0, dev->bus_id, pThis)) {
-		dev_err(dev, "request_irq %d failed!\n", nIrq);
-		status = -ENODEV;
-		goto fail2;
-	}
-	pThis->nIrq = nIrq;
-// FIXME this handles wakeup irqs wrong
-	if (enable_irq_wake(nIrq) == 0)
-		device_init_wakeup(dev, 1);
-
-	pr_info("%s: USB %s mode controller at %p using %s, IRQ %d\n",
-			musb_driver_name,
-			({char *s;
-			switch (pThis->board_mode) {
-			case MUSB_HOST:		s = "Host"; break;
-			case MUSB_PERIPHERAL:	s = "Peripheral"; break;
-			default:		s = "OTG"; break;
-			}; s; }),
-			ctrl,
-			(is_dma_capable() && pThis->pDmaController)
-				? "DMA" : "PIO",
-			pThis->nIrq);
-
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-	/* host side needs more setup, except for no-host modes */
-	if (pThis->board_mode != MUSB_PERIPHERAL) {
-		struct usb_hcd	*hcd = musb_to_hcd(pThis);
-
-		if (pThis->board_mode == MUSB_OTG)
-			hcd->self.otg_port = 1;
-		pThis->xceiv.host = &hcd->self;
-		hcd->power_budget = 2 * (plat->power ? : 250);
-	}
-#endif				/* CONFIG_USB_MUSB_HDRC_HCD */
-
-	/* For the host-only role, we can activate right away.
-	 * (We expect the ID pin to be forcibly grounded!!)
-	 * Otherwise, wait till the gadget driver hooks up.
-	 */
-	if (!is_otg_enabled(pThis) && is_host_enabled(pThis)) {
-		MUSB_HST_MODE(pThis);
-		pThis->xceiv.default_a = 1;
-		pThis->xceiv.state = OTG_STATE_A_IDLE;
-
-		status = usb_add_hcd(musb_to_hcd(pThis), -1, 0);
-
-		DBG(1, "%s mode, status %d, devctl %02x %c\n",
-			"HOST", status,
-			musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL),
-			(musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL)
-					& MGC_M_DEVCTL_BDEVICE
-				? 'B' : 'A'));
-
-	} else /* peripheral is enabled */ {
-		MUSB_DEV_MODE(pThis);
-		pThis->xceiv.default_a = 0;
-		pThis->xceiv.state = OTG_STATE_B_IDLE;
-
-		status = musb_gadget_setup(pThis);
-
-		DBG(1, "%s mode, status %d, dev%02x\n",
-			is_otg_enabled(pThis) ? "OTG" : "PERIPHERAL",
-			status,
-			musb_readb(pThis->pRegs, MGC_O_HDRC_DEVCTL));
-
-	}
-
-	if (status == 0)
-		musb_debug_create("driver/musb_hdrc", pThis);
-	else {
-fail:
-		if (pThis->clock)
-			clk_put(pThis->clock);
-		device_init_wakeup(dev, 0);
-		musb_free(pThis);
-		return status;
-	}
-
-	INIT_WORK(&pThis->irq_work, musb_irq_work);
-
-#ifdef CONFIG_SYSFS
-	status = device_create_file(dev, &dev_attr_mode);
-	status = device_create_file(dev, &dev_attr_cable);
-	status = 0;
-#endif
-
-	return status;
-
-fail2:
-	musb_platform_exit(pThis);
-	goto fail;
-}
-
-/*-------------------------------------------------------------------------*/
-
-/* all implementations (PCI bridge to FPGA, VLYNQ, etc) should just
- * bridge to a platform device; this driver then suffices.
- */
-
-#ifndef CONFIG_USB_INVENTRA_FIFO
-static u64	*orig_dma_mask;
-#endif
-
-static int __init musb_probe(struct platform_device *pdev)
-{
-	struct device	*dev = &pdev->dev;
-	int		irq = platform_get_irq(pdev, 0);
-	struct resource	*iomem;
-	void __iomem	*base;
-
-	iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!iomem || irq == 0)
-		return -ENODEV;
-
-	base = ioremap(iomem->start, iomem->end - iomem->start + 1);
-	if (!base) {
-		dev_err(dev, "ioremap failed\n");
-		return -ENOMEM;
-	}
-
-#ifndef CONFIG_USB_INVENTRA_FIFO
-	/* clobbered by use_dma=n */
-	orig_dma_mask = dev->dma_mask;
-#endif
-	return musb_init_controller(dev, irq, base);
-}
-
-static int __devexit musb_remove(struct platform_device *pdev)
-{
-	struct musb	*musb = dev_to_musb(&pdev->dev);
-	void __iomem	*ctrl_base = musb->ctrl_base;
-
-	/* this gets called on rmmod.
-	 *  - Host mode: host may still be active
-	 *  - Peripheral mode: peripheral is deactivated (or never-activated)
-	 *  - OTG mode: both roles are deactivated (or never-activated)
-	 */
-	musb_shutdown(pdev);
-	musb_debug_delete("driver/musb_hdrc", musb);
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-	if (musb->board_mode == MUSB_HOST)
-		usb_remove_hcd(musb_to_hcd(musb));
-#endif
-	musb_free(musb);
-	iounmap(ctrl_base);
-	device_init_wakeup(&pdev->dev, 0);
-#ifndef CONFIG_USB_INVENTRA_FIFO
-	pdev->dev.dma_mask = orig_dma_mask;
-#endif
-	return 0;
-}
-
-#ifdef	CONFIG_PM
-
-static int musb_suspend(struct platform_device *pdev, pm_message_t message)
-{
-	unsigned long	flags;
-	struct musb	*musb = dev_to_musb(&pdev->dev);
-
-	if (!musb->clock)
-		return 0;
-
-	spin_lock_irqsave(&musb->Lock, flags);
-
-	if (is_peripheral_active(musb)) {
-		/* FIXME force disconnect unless we know USB will wake
-		 * the system up quickly enough to respond ...
-		 */
-	} else if (is_host_active(musb)) {
-		/* we know all the children are suspended; sometimes
-		 * they will even be wakeup-enabled.
-		 */
-	}
-
-	clk_disable(musb->clock);
-	spin_unlock_irqrestore(&musb->Lock, flags);
-	return 0;
-}
-
-static int musb_resume(struct platform_device *pdev)
-{
-	unsigned long	flags;
-	struct musb	*musb = dev_to_musb(&pdev->dev);
-
-	if (!musb->clock)
-		return 0;
-
-	spin_lock_irqsave(&musb->Lock, flags);
-	clk_enable(musb->clock);
-	/* for static cmos like DaVinci, register values were preserved
-	 * unless for some reason the whole soc powered down and we're
-	 * not treating that as a whole-system restart (e.g. swsusp)
-	 */
-	spin_unlock_irqrestore(&musb->Lock, flags);
-	return 0;
-}
-
-#else
-#define	musb_suspend	NULL
-#define	musb_resume	NULL
-#endif
-
-static struct platform_driver musb_driver = {
-	.driver = {
-		.name		= (char *)musb_driver_name,
-		.bus		= &platform_bus_type,
-		.owner		= THIS_MODULE,
-	},
-	.remove		= __devexit_p(musb_remove),
-	.shutdown	= musb_shutdown,
-	.suspend	= musb_suspend,
-	.resume		= musb_resume,
-};
-
-/*-------------------------------------------------------------------------*/
-
-static int __init musb_init(void)
-{
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
-	if (usb_disabled())
-		return 0;
-#endif
-
-	pr_info("%s: version " MUSB_VERSION ", "
-#ifdef CONFIG_USB_INVENTRA_FIFO
-		"pio"
-#elif defined(CONFIG_USB_TI_CPPI_DMA)
-		"cppi-dma"
-#elif defined(CONFIG_USB_INVENTRA_DMA)
-		"musb-dma"
-#elif defined(CONFIG_USB_TUSB_OMAP_DMA)
-		"tusb-omap-dma"
-#else
-		"?dma?"
-#endif
-		", "
-#ifdef CONFIG_USB_MUSB_OTG
-		"otg (peripheral+host)"
-#elif defined(CONFIG_USB_GADGET_MUSB_HDRC)
-		"peripheral"
-#elif defined(CONFIG_USB_MUSB_HDRC_HCD)
-		"host"
-#endif
-		", debug=%d\n",
-		musb_driver_name, debug);
-	return platform_driver_probe(&musb_driver, musb_probe);
-}
-
-/* make us init after usbcore and before usb
- * gadget and host-side drivers start to register
- */
-subsys_initcall(musb_init);
-
-static void __exit musb_cleanup(void)
-{
-	platform_driver_unregister(&musb_driver);
-}
-module_exit(musb_cleanup);
diff -ruN linux-omap-2.6/drivers/usb/musb/tusb6010.c maemo_src/drivers/usb/musb/tusb6010.c
--- linux-omap-2.6/drivers/usb/musb/tusb6010.c	2011-02-06 20:17:25.933333273 -0500
+++ maemo_src/drivers/usb/musb/tusb6010.c	2011-02-06 20:12:11.266666606 -0500
@@ -23,8 +23,100 @@
 #include <linux/irq.h>
 #include <linux/platform_device.h>
 
-#include "musbdefs.h"
+#include "musb_core.h"
 
+static void tusb_source_power(struct musb *musb, int is_on);
+
+#define TUSB_REV_MAJOR(reg_val)		((reg_val >> 4) & 0xf)
+#define TUSB_REV_MINOR(reg_val)		(reg_val & 0xf)
+
+/*
+ * Checks the revision. We need to use the DMA register as 3.0 does not
+ * have correct versions for TUSB_PRCM_REV or TUSB_INT_CTRL_REV.
+ */
+static u8 tusb_get_revision(struct musb *musb)
+{
+	void __iomem	*tbase = musb->ctrl_base;
+	u32		die_id;
+	u8		rev;
+
+	rev = musb_readl(tbase, TUSB_DMA_CTRL_REV) & 0xff;
+	if (TUSB_REV_MAJOR(rev) == 3) {
+		die_id = TUSB_DIDR1_HI_CHIP_REV(musb_readl(tbase,
+				TUSB_DIDR1_HI));
+		if (die_id >= TUSB_DIDR1_HI_REV_31)
+			rev |= 1;
+	}
+
+	return rev;
+}
+
+static int __init tusb_print_revision(struct musb *musb)
+{
+	void __iomem	*tbase = musb->ctrl_base;
+	u8		rev;
+
+	rev = tusb_get_revision(musb);
+
+	pr_info("tusb: %s%i.%i %s%i.%i %s%i.%i %s%i.%i %s%i %s%i.%i\n",
+		"prcm",
+		TUSB_REV_MAJOR(musb_readl(tbase, TUSB_PRCM_REV)),
+		TUSB_REV_MINOR(musb_readl(tbase, TUSB_PRCM_REV)),
+		"int",
+		TUSB_REV_MAJOR(musb_readl(tbase, TUSB_INT_CTRL_REV)),
+		TUSB_REV_MINOR(musb_readl(tbase, TUSB_INT_CTRL_REV)),
+		"gpio",
+		TUSB_REV_MAJOR(musb_readl(tbase, TUSB_GPIO_REV)),
+		TUSB_REV_MINOR(musb_readl(tbase, TUSB_GPIO_REV)),
+		"dma",
+		TUSB_REV_MAJOR(musb_readl(tbase, TUSB_DMA_CTRL_REV)),
+		TUSB_REV_MINOR(musb_readl(tbase, TUSB_DMA_CTRL_REV)),
+		"dieid",
+		TUSB_DIDR1_HI_CHIP_REV(musb_readl(tbase, TUSB_DIDR1_HI)),
+		"rev",
+		TUSB_REV_MAJOR(rev), TUSB_REV_MINOR(rev));
+
+	return tusb_get_revision(musb);
+}
+
+#define WBUS_QUIRK_MASK	(TUSB_PHY_OTG_CTRL_TESTM2 | TUSB_PHY_OTG_CTRL_TESTM1 \
+				| TUSB_PHY_OTG_CTRL_TESTM0)
+
+/*
+ * Workaround for spontaneous WBUS wake-up issue #2 for tusb3.0.
+ * Disables power detection in PHY for the duration of idle.
+ */
+static void tusb_wbus_quirk(struct musb *musb, int enabled)
+{
+	void __iomem	*tbase = musb->ctrl_base;
+	static u32	phy_otg_ctrl, phy_otg_ena;
+	u32		tmp;
+
+	if (enabled) {
+		phy_otg_ctrl = musb_readl(tbase, TUSB_PHY_OTG_CTRL);
+		phy_otg_ena = musb_readl(tbase, TUSB_PHY_OTG_CTRL_ENABLE);
+		tmp = TUSB_PHY_OTG_CTRL_WRPROTECT
+				| phy_otg_ena | WBUS_QUIRK_MASK;
+		musb_writel(tbase, TUSB_PHY_OTG_CTRL, tmp);
+		tmp = phy_otg_ena & ~WBUS_QUIRK_MASK;
+		tmp |= TUSB_PHY_OTG_CTRL_WRPROTECT | TUSB_PHY_OTG_CTRL_TESTM2;
+		musb_writel(tbase, TUSB_PHY_OTG_CTRL_ENABLE, tmp);
+		DBG(2, "Enabled tusb wbus quirk ctrl %08x ena %08x\n",
+			musb_readl(tbase, TUSB_PHY_OTG_CTRL),
+			musb_readl(tbase, TUSB_PHY_OTG_CTRL_ENABLE));
+	} else if (musb_readl(tbase, TUSB_PHY_OTG_CTRL_ENABLE)
+					& TUSB_PHY_OTG_CTRL_TESTM2) {
+		tmp = TUSB_PHY_OTG_CTRL_WRPROTECT | phy_otg_ctrl;
+		musb_writel(tbase, TUSB_PHY_OTG_CTRL, tmp);
+		tmp = TUSB_PHY_OTG_CTRL_WRPROTECT | phy_otg_ena;
+		musb_writel(tbase, TUSB_PHY_OTG_CTRL_ENABLE, tmp);
+		DBG(2, "Disabled tusb wbus quirk ctrl %08x ena %08x\n",
+			musb_readl(tbase, TUSB_PHY_OTG_CTRL),
+			musb_readl(tbase, TUSB_PHY_OTG_CTRL_ENABLE));
+		phy_otg_ctrl = 0;
+		phy_otg_ena = 0;
+	}
+}
 
 /*
  * TUSB 6010 may use a parallel bus that doesn't support byte ops;
@@ -77,7 +169,7 @@
 {
 	void __iomem	*ep_conf = hw_ep->conf;
 	void __iomem	*fifo = hw_ep->fifo;
-	u8		epnum = hw_ep->bLocalEnd;
+	u8		epnum = hw_ep->epnum;
 
 	prefetch(buf);
 
@@ -126,7 +218,7 @@
 {
 	void __iomem	*ep_conf = hw_ep->conf;
 	void __iomem	*fifo = hw_ep->fifo;
-	u8		epnum = hw_ep->bLocalEnd;
+	u8		epnum = hw_ep->epnum;
 
 	DBG(4, "%cX ep%d fifo %p count %d buf %p\n",
 			'R', epnum, fifo, len, buf);
@@ -179,9 +271,21 @@
 static int tusb_draw_power(struct otg_transceiver *x, unsigned mA)
 {
 	struct musb	*musb = container_of(x, struct musb, xceiv);
-	void __iomem	*base = musb->ctrl_base;
+	void __iomem	*tbase = musb->ctrl_base;
 	u32		reg;
 
+	/*
+	 * Keep clock active when enabled. Note that this is not tied to
+	 * drawing VBUS, as with OTG mA can be less than musb->min_power.
+	 * Note that peripheral osc_ck gets disabled in tusb_allow_idle().
+	 */
+	if (musb->set_clock) {
+		if (mA)
+			musb->set_clock(musb->clock, 1);
+		else
+			musb->set_clock(musb->clock, 0);
+	}
+
 	/* tps65030 seems to consume max 100mA, with maybe 60mA available
 	 * (measured on one board) for things other than tps and tusb.
 	 *
@@ -195,19 +299,15 @@
 	if (x->default_a || mA < (musb->min_power << 1))
 		mA = 0;
 
-	reg = musb_readl(base, TUSB_PRCM_MNGMT);
+	reg = musb_readl(tbase, TUSB_PRCM_MNGMT);
 	if (mA) {
-		if (musb->set_clock)
-			musb->set_clock(musb->clock, 1);
 		musb->is_bus_powered = 1;
 		reg |= TUSB_PRCM_MNGMT_15_SW_EN | TUSB_PRCM_MNGMT_33_SW_EN;
 	} else {
 		musb->is_bus_powered = 0;
 		reg &= ~(TUSB_PRCM_MNGMT_15_SW_EN | TUSB_PRCM_MNGMT_33_SW_EN);
-		if (musb->set_clock)
-			musb->set_clock(musb->clock, 0);
 	}
-	musb_writel(base, TUSB_PRCM_MNGMT, reg);
+	musb_writel(tbase, TUSB_PRCM_MNGMT, reg);
 
 	DBG(2, "draw max %d mA VBUS\n", mA);
 	return 0;
@@ -217,16 +317,36 @@
 #define tusb_draw_power	NULL
 #endif
 
+/* There are issues re-locking the PLL on wakeup */
+static inline void tusb_lock_pll(struct musb *musb)
+{
+	void __iomem	*tbase = musb->ctrl_base;
+	u32		reg;
+	int		i;
+
+	for (i = 0xf7f7f7; i > 0xf7f7f7 - 1000; i--) {
+		musb_writel(tbase, TUSB_SCRATCH_PAD, 0);
+		musb_writel(tbase, TUSB_SCRATCH_PAD, i);
+		reg = musb_readl(tbase, TUSB_SCRATCH_PAD);
+		if (reg == i)
+			break;
+		DBG(6, "TUSB NOR not ready\n");
+	}
+}
+
 /* workaround for issue 13:  change clock during chip idle
  * (to be fixed in rev3 silicon) ... symptoms include disconnect
  * or looping suspend/resume cycles
  */
 static void tusb_set_clock_source(struct musb *musb, unsigned mode)
 {
-	void __iomem	*base = musb->ctrl_base;
+	void __iomem	*tbase = musb->ctrl_base;
 	u32		reg;
 
-	reg = musb_readl(base, TUSB_PRCM_CONF);
+	if (musb->set_clock && (mode == 1))
+		musb->set_clock(musb->clock, 1);
+
+	reg = musb_readl(tbase, TUSB_PRCM_CONF);
 	reg &= ~TUSB_PRCM_CONF_SYS_CLKSEL(0x3);
 
 	/* 0 = refclk (clkin, XI)
@@ -237,9 +357,24 @@
 	if (mode > 0)
 		reg |= TUSB_PRCM_CONF_SYS_CLKSEL(mode & 0x3);
 
-	musb_writel(base, TUSB_PRCM_CONF, reg);
+	musb_writel(tbase, TUSB_PRCM_CONF, reg);
+
+	/* FIXME tusb6010_platform_retime(mode == 0); */
+}
+
+/*
+ * Wake-up tusb from idle. Caller must take care of locking.
+ */
+void musb_platform_wakeup(struct musb *musb)
+{
+	void __iomem	*tbase = musb->ctrl_base;
+	u32		int_src;
 
-	// FIXME tusb6010_platform_retime(mode == 0);
+	tusb_lock_pll(musb);
+	tusb_set_clock_source(musb, 1);
+	int_src = musb_readl(tbase, TUSB_INT_SRC) & ~TUSB_INT_SRC_RESERVED_BITS;
+	if (int_src & TUSB_INT_SRC_DEV_WAKEUP)
+		musb_writel(tbase, TUSB_INT_SRC_CLEAR, TUSB_INT_SRC_DEV_WAKEUP);
 }
 
 /*
@@ -248,22 +383,29 @@
  * USB link is not suspended ... and tells us the relevant wakeup
  * events.  SW_EN for voltage is handled separately.
  */
-static void tusb_allow_idle(struct musb *musb, u32 wakeup_enables)
+void tusb_allow_idle(struct musb *musb, u32 wakeup_enables)
 {
-	void __iomem	*base = musb->ctrl_base;
+	void __iomem	*tbase = musb->ctrl_base;
 	u32		reg;
 
+	if ((wakeup_enables & TUSB_PRCM_WBUS)
+			&& (tusb_get_revision(musb) == TUSB_REV_30))
+		tusb_wbus_quirk(musb, 1);
+
 	tusb_set_clock_source(musb, 0);
+	if ((musb_platform_get_vbus_status(musb) == 0)
+		&& (musb->xceiv.state == OTG_STATE_B_IDLE))
+			musb->set_clock(musb->clock, 0);
 
 	wakeup_enables |= TUSB_PRCM_WNORCS;
-	musb_writel(base, TUSB_PRCM_WAKEUP_MASK, ~wakeup_enables);
+	musb_writel(tbase, TUSB_PRCM_WAKEUP_MASK, ~wakeup_enables);
 
 	/* REVISIT writeup of WID implies that if WID set and ID is grounded,
 	 * TUSB_PHY_OTG_CTRL.TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP must be cleared.
 	 * Presumably that's mostly to save power, hence WID is immaterial ...
 	 */
 
-	reg = musb_readl(base, TUSB_PRCM_MNGMT);
+	reg = musb_readl(tbase, TUSB_PRCM_MNGMT);
 	/* issue 4: when driving vbus, use hipower (vbus_det) comparator */
 	if (is_host_active(musb)) {
 		reg |= TUSB_PRCM_MNGMT_OTG_VBUS_DET_EN;
@@ -273,7 +415,14 @@
 		reg &= ~TUSB_PRCM_MNGMT_OTG_VBUS_DET_EN;
 	}
 	reg |= TUSB_PRCM_MNGMT_PM_IDLE | TUSB_PRCM_MNGMT_DEV_IDLE;
-	musb_writel(base, TUSB_PRCM_MNGMT, reg);
+	musb_writel(tbase, TUSB_PRCM_MNGMT, reg);
+
+#ifdef CONFIG_USB_MUSB_OTG
+	if (musb->srp_sent) {
+		otg_set_error(&musb->xceiv, OTG_ERR_DEVICE_NOT_RESPONDING);
+		musb->srp_sent = 0;
+	}
+#endif
 
 	DBG(6, "idle, wake on %02x\n", wakeup_enables);
 }
@@ -283,12 +432,12 @@
  */
 int musb_platform_get_vbus_status(struct musb *musb)
 {
-	void __iomem	*base = musb->ctrl_base;
+	void __iomem	*tbase = musb->ctrl_base;
 	u32		otg_stat, prcm_mngmt;
 	int		ret = 0;
 
-	otg_stat = musb_readl(base, TUSB_DEV_OTG_STAT);
-	prcm_mngmt = musb_readl(base, TUSB_PRCM_MNGMT);
+	otg_stat = musb_readl(tbase, TUSB_DEV_OTG_STAT);
+	prcm_mngmt = musb_readl(tbase, TUSB_PRCM_MNGMT);
 
 	/* Temporarily enable VBUS detection if it was disabled for
 	 * suspend mode. Unless it's enabled otg_stat and devctl will
@@ -297,12 +446,12 @@
 	if (!(prcm_mngmt & TUSB_PRCM_MNGMT_OTG_VBUS_DET_EN)) {
 		u32 tmp = prcm_mngmt;
 		tmp |= TUSB_PRCM_MNGMT_OTG_VBUS_DET_EN;
-		musb_writel(base, TUSB_PRCM_MNGMT, tmp);
-		otg_stat = musb_readl(base, TUSB_DEV_OTG_STAT);
-		musb_writel(base, TUSB_PRCM_MNGMT, prcm_mngmt);
+		musb_writel(tbase, TUSB_PRCM_MNGMT, tmp);
+		otg_stat = musb_readl(tbase, TUSB_DEV_OTG_STAT);
+		musb_writel(tbase, TUSB_PRCM_MNGMT, prcm_mngmt);
 	}
 
-	if (otg_stat & TUSB_DEV_OTG_STAT_VBUS_SENSE)
+	if (otg_stat & TUSB_DEV_OTG_STAT_VBUS_VALID)
 		ret = 1;
 
 	return ret;
@@ -315,18 +464,32 @@
 	struct musb	*musb = (void *)_musb;
 	unsigned long	flags;
 
-	spin_lock_irqsave(&musb->Lock, flags);
+	spin_lock_irqsave(&musb->lock, flags);
+
+	switch (musb->xceiv.state) {
+	case OTG_STATE_A_WAIT_BCON:
+		if ((musb->a_wait_bcon != 0)
+			&& (musb->idle_timeout == 0
+				|| time_after(jiffies, musb->idle_timeout))) {
+			DBG(4, "Nothing connected %s, turning off VBUS\n",
+					otg_state_string(musb));
+		}
+		/* FALLTHROUGH */
+	case OTG_STATE_A_IDLE:
+		tusb_source_power(musb, 0);
+	default:
+		break;
+	}
+
 	if (!musb->is_active) {
 		u32	wakeups;
 
-#ifdef CONFIG_USB_MUSB_HDRC_HCD
 		/* wait until khubd handles port change status */
 		if (is_host_active(musb) && (musb->port1_status >> 16))
 			goto done;
-#endif
 
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
-		if (is_peripheral_enabled(musb) && !musb->pGadgetDriver)
+		if (is_peripheral_enabled(musb) && !musb->gadget_driver)
 			wakeups = 0;
 		else {
 			wakeups = TUSB_PRCM_WHOSTDISCON
@@ -341,7 +504,7 @@
 		tusb_allow_idle(musb, wakeups);
 	}
 done:
-	spin_unlock_irqrestore(&musb->Lock, flags);
+	spin_unlock_irqrestore(&musb->lock, flags);
 }
 
 /*
@@ -357,12 +520,37 @@
  * we don't want to treat that full speed J as a wakeup event.
  * ... peripherals must draw only suspend current after 10 msec.
  */
-void musb_platform_try_idle(struct musb *musb)
+void musb_platform_try_idle(struct musb *musb, unsigned long timeout)
 {
-	if (musb->is_active)
+	unsigned long		default_timeout = jiffies + msecs_to_jiffies(3);
+	static unsigned long	last_timer;
+
+	if (timeout == 0)
+		timeout = default_timeout;
+
+	/* Never idle if active, or when VBUS timeout is not set as host */
+	if (musb->is_active || ((musb->a_wait_bcon == 0)
+			&& (musb->xceiv.state == OTG_STATE_A_WAIT_BCON))) {
+		DBG(4, "%s active, deleting timer\n", otg_state_string(musb));
 		del_timer(&musb_idle_timer);
-	else
-		mod_timer(&musb_idle_timer, jiffies + msecs_to_jiffies(3));
+		last_timer = jiffies;
+		return;
+	}
+
+	if (time_after(last_timer, timeout)) {
+		if (!timer_pending(&musb_idle_timer))
+			last_timer = timeout;
+		else {
+			DBG(4, "Longer idle timer already pending, ignoring\n");
+			return;
+		}
+	}
+	last_timer = timeout;
+
+	DBG(4, "%s inactive, for idle timer for %lu ms\n",
+		otg_state_string(musb),
+		(unsigned long)jiffies_to_msecs(timeout - jiffies));
+	mod_timer(&musb_idle_timer, timeout);
 }
 
 /* ticks of 60 MHz clock */
@@ -374,7 +562,7 @@
 
 static void tusb_source_power(struct musb *musb, int is_on)
 {
-	void __iomem	*base = musb->ctrl_base;
+	void __iomem	*tbase = musb->ctrl_base;
 	u32		conf, prcm, timer;
 	u8		devctl;
 
@@ -383,46 +571,65 @@
 	 * that must be ignored.
 	 */
 
-	prcm = musb_readl(base, TUSB_PRCM_MNGMT);
-	conf = musb_readl(base, TUSB_DEV_CONF);
-	devctl = musb_readb(musb->pRegs, MGC_O_HDRC_DEVCTL);
+	prcm = musb_readl(tbase, TUSB_PRCM_MNGMT);
+	conf = musb_readl(tbase, TUSB_DEV_CONF);
+	devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 
 	if (is_on) {
-		musb->is_active = 1;
+		if (musb->set_clock)
+			musb->set_clock(musb->clock, 1);
 		timer = OTG_TIMER_MS(OTG_TIME_A_WAIT_VRISE);
-
 		musb->xceiv.default_a = 1;
 		musb->xceiv.state = OTG_STATE_A_WAIT_VRISE;
-		devctl |= MGC_M_DEVCTL_SESSION;
+		devctl |= MUSB_DEVCTL_SESSION;
 
 		conf |= TUSB_DEV_CONF_USB_HOST_MODE;
 		MUSB_HST_MODE(musb);
 	} else {
-		musb->is_active = 0;
+		u32	otg_stat;
+
 		timer = 0;
 
-		/* NOTE:  we're skipping A_WAIT_VFALL -> A_IDLE and
-		 * jumping right to B_IDLE...
-		 */
-
-		musb->xceiv.default_a = 0;
-		musb->xceiv.state = OTG_STATE_B_IDLE;
-		devctl &= ~MGC_M_DEVCTL_SESSION;
+		/* If ID pin is grounded, we want to be a_idle */
+		otg_stat = musb_readl(tbase, TUSB_DEV_OTG_STAT);
+		if (!(otg_stat & TUSB_DEV_OTG_STAT_ID_STATUS)) {
+			switch (musb->xceiv.state) {
+			case OTG_STATE_A_WAIT_VRISE:
+			case OTG_STATE_A_WAIT_BCON:
+				musb->xceiv.state = OTG_STATE_A_WAIT_VFALL;
+				break;
+			case OTG_STATE_A_WAIT_VFALL:
+				musb->xceiv.state = OTG_STATE_A_IDLE;
+				break;
+			default:
+				musb->xceiv.state = OTG_STATE_A_IDLE;
+			}
+			musb->is_active = 0;
+			musb->xceiv.default_a = 1;
+			MUSB_HST_MODE(musb);
+		} else {
+			musb->is_active = 0;
+			musb->xceiv.default_a = 0;
+			musb->xceiv.state = OTG_STATE_B_IDLE;
+			MUSB_DEV_MODE(musb);
+		}
 
+		devctl &= ~MUSB_DEVCTL_SESSION;
 		conf &= ~TUSB_DEV_CONF_USB_HOST_MODE;
-		MUSB_DEV_MODE(musb);
+		if (musb->set_clock)
+			musb->set_clock(musb->clock, 0);
 	}
 	prcm &= ~(TUSB_PRCM_MNGMT_15_SW_EN | TUSB_PRCM_MNGMT_33_SW_EN);
 
-	musb_writel(base, TUSB_PRCM_MNGMT, prcm);
-	musb_writel(base, TUSB_DEV_OTG_TIMER, timer);
-	musb_writel(base, TUSB_DEV_CONF, conf);
-	musb_writeb(musb->pRegs, MGC_O_HDRC_DEVCTL, devctl);
+	musb_writel(tbase, TUSB_PRCM_MNGMT, prcm);
+	musb_writel(tbase, TUSB_DEV_OTG_TIMER, timer);
+	musb_writel(tbase, TUSB_DEV_CONF, conf);
+	musb_writeb(musb->mregs, MUSB_DEVCTL, devctl);
 
 	DBG(1, "VBUS %s, devctl %02x otg %3x conf %08x prcm %08x\n",
 		otg_state_string(musb),
-		musb_readb(musb->pRegs, MGC_O_HDRC_DEVCTL),
-		musb_readl(base, TUSB_DEV_OTG_STAT),
+		musb_readb(musb->mregs, MUSB_DEVCTL),
+		musb_readl(tbase, TUSB_DEV_OTG_STAT),
 		conf, prcm);
 }
 
@@ -439,53 +646,42 @@
  */
 void musb_platform_set_mode(struct musb *musb, u8 musb_mode)
 {
-	void __iomem	*base = musb->ctrl_base;
-	u32		otg_stat, phy_otg_ena, phy_otg_ctrl, dev_conf;
-	int		vbus = 0;
+	void __iomem	*tbase = musb->ctrl_base;
+	u32		otg_stat, phy_otg_ctrl, phy_otg_ena, dev_conf;
 
 	if (musb->board_mode != MUSB_OTG) {
 		ERR("Changing mode currently only supported in OTG mode\n");
 		return;
 	}
 
-	otg_stat = musb_readl(base, TUSB_DEV_OTG_STAT);
-	phy_otg_ena = musb_readl(base, TUSB_PHY_OTG_CTRL_ENABLE);
-	phy_otg_ctrl = musb_readl(base, TUSB_PHY_OTG_CTRL);
-	dev_conf = musb_readl(base, TUSB_DEV_CONF);
+	otg_stat = musb_readl(tbase, TUSB_DEV_OTG_STAT);
+	phy_otg_ctrl = musb_readl(tbase, TUSB_PHY_OTG_CTRL);
+	phy_otg_ena = musb_readl(tbase, TUSB_PHY_OTG_CTRL_ENABLE);
+	dev_conf = musb_readl(tbase, TUSB_DEV_CONF);
 
 	switch (musb_mode) {
 
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
 	case MUSB_HOST:		/* Disable PHY ID detect, ground ID */
-		if (!(otg_stat & TUSB_DEV_OTG_STAT_ID_STATUS)) {
-			ERR("Already in host mode otg_stat: %08x\n", otg_stat);
-			return;
-		}
-		phy_otg_ena |= TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;
 		phy_otg_ctrl &= ~TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;
+		phy_otg_ena |= TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;
 		dev_conf |= TUSB_DEV_CONF_ID_SEL;
 		dev_conf &= ~TUSB_DEV_CONF_SOFT_ID;
-		vbus = 1;
 		break;
 #endif
 
 #ifdef CONFIG_USB_GADGET_MUSB_HDRC
 	case MUSB_PERIPHERAL:	/* Disable PHY ID detect, keep ID pull-up on */
-		if (otg_stat & TUSB_DEV_OTG_STAT_ID_STATUS) {
-			ERR("Already in peripheral mode otg_stat: %08x\n",
-				otg_stat);
-			return;
-		}
-		phy_otg_ena |= TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;
 		phy_otg_ctrl |= TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;
+		phy_otg_ena |= TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;
 		dev_conf |= (TUSB_DEV_CONF_ID_SEL | TUSB_DEV_CONF_SOFT_ID);
 		break;
 #endif
 
 #ifdef CONFIG_USB_MUSB_OTG
 	case MUSB_OTG:		/* Use PHY ID detection */
-		phy_otg_ena &= ~TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;
-		phy_otg_ctrl &= ~TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;
+		phy_otg_ctrl |= TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;
+		phy_otg_ena |= TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;
 		dev_conf &= ~(TUSB_DEV_CONF_ID_SEL | TUSB_DEV_CONF_SOFT_ID);
 		break;
 #endif
@@ -494,24 +690,24 @@
 		DBG(2, "Trying to set unknown mode %i\n", musb_mode);
 	}
 
-	musb_writel(base, TUSB_PHY_OTG_CTRL_ENABLE,
-			TUSB_PHY_OTG_CTRL_WRPROTECT | phy_otg_ena);
-	musb_writel(base, TUSB_PHY_OTG_CTRL,
+	musb_writel(tbase, TUSB_PHY_OTG_CTRL,
 			TUSB_PHY_OTG_CTRL_WRPROTECT | phy_otg_ctrl);
-	musb_writel(base, TUSB_DEV_CONF, dev_conf);
+	musb_writel(tbase, TUSB_PHY_OTG_CTRL_ENABLE,
+			TUSB_PHY_OTG_CTRL_WRPROTECT | phy_otg_ena);
+	musb_writel(tbase, TUSB_DEV_CONF, dev_conf);
 
-	msleep(1);
-	otg_stat = musb_readl(base, TUSB_DEV_OTG_STAT);
+	otg_stat = musb_readl(tbase, TUSB_DEV_OTG_STAT);
 	if ((musb_mode == MUSB_PERIPHERAL) &&
 		!(otg_stat & TUSB_DEV_OTG_STAT_ID_STATUS))
-			ERR("Cannot be peripheral with mini-A cable "
+			INFO("Cannot be peripheral with mini-A cable "
 			"otg_stat: %08x\n", otg_stat);
 }
 
-static inline void
-tusb_otg_ints(struct musb *musb, u32 int_src, void __iomem *base)
+static inline unsigned long
+tusb_otg_ints(struct musb *musb, u32 int_src, void __iomem *tbase)
 {
-	u32	otg_stat = musb_readl(base, TUSB_DEV_OTG_STAT);
+	u32		otg_stat = musb_readl(tbase, TUSB_DEV_OTG_STAT);
+	unsigned long	idle_timeout = 0;
 
 	/* ID pin */
 	if ((int_src & TUSB_INT_SRC_ID_STATUS_CHNG)) {
@@ -524,6 +720,10 @@
 		DBG(2, "Default-%c\n", default_a ? 'A' : 'B');
 		musb->xceiv.default_a = default_a;
 		tusb_source_power(musb, default_a);
+
+		/* Don't allow idling immediately */
+		if (default_a)
+			idle_timeout = jiffies + (HZ * 3);
 	}
 
 	/* VBUS state change */
@@ -533,7 +733,7 @@
 		if ((is_otg_enabled(musb) && !musb->xceiv.default_a)
 				|| !is_host_enabled(musb)) {
 #ifdef CONFIG_USB_MUSB_HDRC_HCD
-			// ? musb_root_disconnect(musb);
+			/* ? musb_root_disconnect(musb); */
 			musb->port1_status &=
 				~(USB_PORT_STAT_CONNECTION
 				| USB_PORT_STAT_ENABLE
@@ -544,34 +744,64 @@
 #endif
 
 			if (otg_stat & TUSB_DEV_OTG_STAT_SESS_END) {
+				DBG(1, "Forcing disconnect (no interrupt)\n");
 				if (musb->xceiv.state != OTG_STATE_B_IDLE) {
 					/* INTR_DISCONNECT can hide... */
 					musb->xceiv.state = OTG_STATE_B_IDLE;
-					musb->int_usb |= MGC_M_INTR_DISCONNECT;
+					musb->int_usb |= MUSB_INTR_DISCONNECT;
 				}
 				musb->is_active = 0;
 			}
 			DBG(2, "vbus change, %s, otg %03x\n",
 				otg_state_string(musb), otg_stat);
+			idle_timeout = jiffies + (1 * HZ);
 			schedule_work(&musb->irq_work);
 
 		} else /* A-dev state machine */ {
-			DBG(4, "vbus change, %s, otg %03x\n",
+			DBG(2, "vbus change, %s, otg %03x\n",
 				otg_state_string(musb), otg_stat);
 
 			switch (musb->xceiv.state) {
+			case OTG_STATE_A_IDLE:
+				DBG(2, "Got SRP, turning on VBUS\n");
+				musb_set_vbus(musb, 1);
+
+				/* CONNECT can wake if a_wait_bcon is set */
+				if (musb->a_wait_bcon != 0)
+					musb->is_active = 0;
+				else
+					musb->is_active = 1;
+
+				/*
+				 * OPT FS A TD.4.6 needs few seconds for
+				 * A_WAIT_VRISE
+				 */
+				idle_timeout = jiffies + (2 * HZ);
+
+				break;
 			case OTG_STATE_A_WAIT_VRISE:
 				/* ignore; A-session-valid < VBUS_VALID/2,
 				 * we monitor this with the timer
 				 */
 				break;
 			case OTG_STATE_A_WAIT_VFALL:
+#ifdef CONFIG_USB_OTG
+				/* Cannot retry VBUS, see OTG 1.3 5.1.3 */
+				if (musb->xceiv.tpl_enabled) {
+					tusb_source_power(musb, 0);
+					break;
+				}
+#endif
 				/* REVISIT this irq triggers during short
 				 * spikes causet by enumeration ...
 				 */
 				if (musb->vbuserr_retry) {
 					musb->vbuserr_retry--;
 					tusb_source_power(musb, 1);
+				} else {
+					musb->vbuserr_retry
+						= VBUSERR_RETRY_COUNT;
+					tusb_source_power(musb, 0);
 				}
 				break;
 			default:
@@ -591,36 +821,30 @@
 			/* VBUS has probably been valid for a while now,
 			 * but may well have bounced out of range a bit
 			 */
-			devctl = musb_readb(musb->pRegs, MGC_O_HDRC_DEVCTL);
+			devctl = musb_readb(musb->mregs, MUSB_DEVCTL);
 			if (otg_stat & TUSB_DEV_OTG_STAT_VBUS_VALID) {
-				u32	timer;
-
-				if ((devctl & MGC_M_DEVCTL_VBUS)
-						!= MGC_M_DEVCTL_VBUS) {
+				if ((devctl & MUSB_DEVCTL_VBUS)
+						!= MUSB_DEVCTL_VBUS) {
 					DBG(2, "devctl %02x\n", devctl);
 					break;
 				}
 				musb->xceiv.state = OTG_STATE_A_WAIT_BCON;
-
-				/* REVISIT: if nothing is connected yet,
-				 * mark controller as inactive so that
-				 * we can suspend the TUSB chip.
-				 */
-
-				/* timeout 0 == infinite (like non-OTG hosts) */
-				timer = OTG_TIMER_MS(OTG_TIME_A_WAIT_BCON);
-				if (timer)
-					musb_writel(base, TUSB_DEV_OTG_TIMER,
-							timer);
+				musb->is_active = 0;
+				idle_timeout = jiffies
+					+ msecs_to_jiffies(musb->a_wait_bcon);
 			} else {
 				/* REVISIT report overcurrent to hub? */
 				ERR("vbus too slow, devctl %02x\n", devctl);
+#ifdef CONFIG_USB_MUSB_OTG
+				otg_set_error(&musb->xceiv, OTG_ERR_DEVICE_NOT_SUPPORTED);
+#endif
 				tusb_source_power(musb, 0);
 			}
 			break;
 		case OTG_STATE_A_WAIT_BCON:
-			if (OTG_TIME_A_WAIT_BCON)
-				tusb_source_power(musb, 0);
+			if (musb->a_wait_bcon != 0)
+				idle_timeout = jiffies
+					+ msecs_to_jiffies(musb->a_wait_bcon);
 			break;
 		case OTG_STATE_A_SUSPEND:
 			break;
@@ -630,44 +854,43 @@
 			break;
 		}
 	}
+	schedule_work(&musb->irq_work);
+
+	return idle_timeout;
 }
 
 static irqreturn_t tusb_interrupt(int irq, void *__hci)
 {
 	struct musb	*musb = __hci;
-	void __iomem	*base = musb->ctrl_base;
-	unsigned long	flags;
-	u32		int_src;
+	void __iomem	*tbase = musb->ctrl_base;
+	unsigned long	flags, idle_timeout = 0;
+	u32		int_mask, int_src;
+	u32		reg;
+
+	spin_lock_irqsave(&musb->lock, flags);
 
-	spin_lock_irqsave(&musb->Lock, flags);
+	tusb_lock_pll(musb);
 
-	int_src = musb_readl(base, TUSB_INT_SRC) & ~TUSB_INT_SRC_RESERVED_BITS;
+	/* Mask all interrupts to allow using both edge and level GPIO irq */
+	int_mask = musb_readl(tbase, TUSB_INT_MASK);
+	musb_writel(tbase, TUSB_INT_MASK, ~TUSB_INT_MASK_RESERVED_BITS);
+
+	int_src = musb_readl(tbase, TUSB_INT_SRC) & ~TUSB_INT_SRC_RESERVED_BITS;
 	DBG(3, "TUSB IRQ %08x\n", int_src);
 
 	musb->int_usb = (u8) int_src;
 
 	/* Acknowledge wake-up source interrupts */
 	if (int_src & TUSB_INT_SRC_DEV_WAKEUP) {
-		u32	reg;
-		u32	i;
 
-		/* there are issues re-locking the PLL on wakeup ... */
-
-		/* work around issue 8 */
-		for (i = 0xf7f7f7; i > 0xf7f7f7 - 1000; i--) {
-			musb_writel(base, TUSB_SCRATCH_PAD, 0);
-			musb_writel(base, TUSB_SCRATCH_PAD, i);
-			reg = musb_readl(base, TUSB_SCRATCH_PAD);
-			if (reg == i)
-				break;
-			DBG(6, "TUSB NOR not ready\n");
-		}
+		if (tusb_get_revision(musb) == TUSB_REV_30)
+			tusb_wbus_quirk(musb, 0);
 
 		/* work around issue 13 (2nd half) */
 		tusb_set_clock_source(musb, 1);
 
-		reg = musb_readl(base, TUSB_PRCM_WAKEUP_SOURCE);
-		musb_writel(base, TUSB_PRCM_WAKEUP_CLEAR, reg);
+		reg = musb_readl(tbase, TUSB_PRCM_WAKEUP_SOURCE);
+		musb_writel(tbase, TUSB_PRCM_WAKEUP_CLEAR, reg);
 		if (reg & ~TUSB_PRCM_WNORCS) {
 			musb->is_active = 1;
 			schedule_work(&musb->irq_work);
@@ -675,21 +898,24 @@
 		DBG(3, "wake %sactive %02x\n",
 				musb->is_active ? "" : "in", reg);
 
-		// REVISIT host side TUSB_PRCM_WHOSTDISCON, TUSB_PRCM_WBUS
+		/* REVISIT host side TUSB_PRCM_WHOSTDISCON, TUSB_PRCM_WBUS */
 	}
 
+	if (int_src & TUSB_INT_SRC_USB_IP_CONN)
+		del_timer(&musb_idle_timer);
+
 	/* OTG state change reports (annoyingly) not issued by Mentor core */
 	if (int_src & (TUSB_INT_SRC_VBUS_SENSE_CHNG
 				| TUSB_INT_SRC_OTG_TIMEOUT
 				| TUSB_INT_SRC_ID_STATUS_CHNG))
-		tusb_otg_ints(musb, int_src, base);
+		idle_timeout = tusb_otg_ints(musb, int_src, tbase);
 
 	/* TX dma callback must be handled here, RX dma callback is
 	 * handled in tusb_omap_dma_cb.
 	 */
 	if ((int_src & TUSB_INT_SRC_TXRX_DMA_DONE)) {
-		u32	dma_src = musb_readl(base, TUSB_DMA_INT_SRC);
-		u32	real_dma_src = musb_readl(base, TUSB_DMA_INT_MASK);
+		u32	dma_src = musb_readl(tbase, TUSB_DMA_INT_SRC);
+		u32	real_dma_src = musb_readl(tbase, TUSB_DMA_INT_MASK);
 
 		DBG(3, "DMA IRQ %08x\n", dma_src);
 		real_dma_src = ~real_dma_src & dma_src;
@@ -704,14 +930,14 @@
 				}
 			}
 		}
-		musb_writel(base, TUSB_DMA_INT_CLEAR, dma_src);
+		musb_writel(tbase, TUSB_DMA_INT_CLEAR, dma_src);
 	}
 
 	/* EP interrupts. In OCP mode tusb6010 mirrors the MUSB * interrupts */
 	if (int_src & (TUSB_INT_SRC_USB_IP_TX | TUSB_INT_SRC_USB_IP_RX)) {
-		u32	musb_src = musb_readl(base, TUSB_USBIP_INT_SRC);
+		u32	musb_src = musb_readl(tbase, TUSB_USBIP_INT_SRC);
 
-		musb_writel(base, TUSB_USBIP_INT_CLEAR, musb_src);
+		musb_writel(tbase, TUSB_USBIP_INT_CLEAR, musb_src);
 		musb->int_rx = (((musb_src >> 16) & 0xffff) << 1);
 		musb->int_tx = (musb_src & 0xffff);
 	} else
@@ -721,11 +947,13 @@
 		musb_interrupt(musb);
 
 	/* Acknowledge TUSB interrupts. Clear only non-reserved bits */
-	musb_writel(base, TUSB_INT_SRC_CLEAR,
+	musb_writel(tbase, TUSB_INT_SRC_CLEAR,
 		int_src & ~TUSB_INT_MASK_RESERVED_BITS);
 
-	musb_platform_try_idle(musb);
-	spin_unlock_irqrestore(&musb->Lock, flags);
+	musb_platform_try_idle(musb, idle_timeout);
+
+	musb_writel(tbase, TUSB_INT_MASK, int_mask);
+	spin_unlock_irqrestore(&musb->lock, flags);
 
 	return IRQ_HANDLED;
 }
@@ -737,43 +965,43 @@
  * REVISIT:
  * - Check what is unnecessary in MGC_HdrcStart()
  */
-void musb_platform_enable(struct musb * musb)
+void musb_platform_enable(struct musb *musb)
 {
-	void __iomem	*base = musb->ctrl_base;
+	void __iomem	*tbase = musb->ctrl_base;
 
 	/* Setup TUSB6010 main interrupt mask. Enable all interrupts except SOF.
 	 * REVISIT: Enable and deal with TUSB_INT_SRC_USB_IP_SOF */
-	musb_writel(base, TUSB_INT_MASK, TUSB_INT_SRC_USB_IP_SOF);
+	musb_writel(tbase, TUSB_INT_MASK, TUSB_INT_SRC_USB_IP_SOF);
 
 	/* Setup TUSB interrupt, disable DMA and GPIO interrupts */
-	musb_writel(base, TUSB_USBIP_INT_MASK, 0);
-	musb_writel(base, TUSB_DMA_INT_MASK, 0x7fffffff);
-	musb_writel(base, TUSB_GPIO_INT_MASK, 0x1ff);
+	musb_writel(tbase, TUSB_USBIP_INT_MASK, 0);
+	musb_writel(tbase, TUSB_DMA_INT_MASK, 0x7fffffff);
+	musb_writel(tbase, TUSB_GPIO_INT_MASK, 0x1ff);
 
 	/* Clear all subsystem interrups */
-	musb_writel(base, TUSB_USBIP_INT_CLEAR, 0x7fffffff);
-	musb_writel(base, TUSB_DMA_INT_CLEAR, 0x7fffffff);
-	musb_writel(base, TUSB_GPIO_INT_CLEAR, 0x1ff);
+	musb_writel(tbase, TUSB_USBIP_INT_CLEAR, 0x7fffffff);
+	musb_writel(tbase, TUSB_DMA_INT_CLEAR, 0x7fffffff);
+	musb_writel(tbase, TUSB_GPIO_INT_CLEAR, 0x1ff);
 
 	/* Acknowledge pending interrupt(s) */
-	musb_writel(base, TUSB_INT_SRC_CLEAR, ~TUSB_INT_MASK_RESERVED_BITS);
+	musb_writel(tbase, TUSB_INT_SRC_CLEAR, ~TUSB_INT_MASK_RESERVED_BITS);
 
 	/* Only 0 clock cycles for minimum interrupt de-assertion time and
 	 * interrupt polarity active low seems to work reliably here */
-	musb_writel(base, TUSB_INT_CTRL_CONF,
+	musb_writel(tbase, TUSB_INT_CTRL_CONF,
 			TUSB_INT_CTRL_CONF_INT_RELCYC(0));
 
 	set_irq_type(musb->nIrq, IRQ_TYPE_LEVEL_LOW);
 
 	/* maybe force into the Default-A OTG state machine */
-	if (!(musb_readl(base, TUSB_DEV_OTG_STAT)
+	if (!(musb_readl(tbase, TUSB_DEV_OTG_STAT)
 			& TUSB_DEV_OTG_STAT_ID_STATUS))
-		musb_writel(base, TUSB_INT_SRC_SET,
+		musb_writel(tbase, TUSB_INT_SRC_SET,
 				TUSB_INT_SRC_ID_STATUS_CHNG);
 
 	if (is_dma_capable() && dma_off)
 		printk(KERN_WARNING "%s %s: dma not reactivated\n",
-				__FILE__, __FUNCTION__);
+				__FILE__, __func__);
 	else
 		dma_off = 1;
 }
@@ -783,21 +1011,24 @@
  */
 void musb_platform_disable(struct musb *musb)
 {
-	void __iomem	*base = musb->ctrl_base;
+	void __iomem	*tbase = musb->ctrl_base;
 
 	/* FIXME stop DMA, IRQs, timers, ... */
 
 	/* disable all IRQs */
-	musb_writel(base, TUSB_INT_MASK, ~TUSB_INT_MASK_RESERVED_BITS);
-	musb_writel(base, TUSB_USBIP_INT_MASK, 0);
-	musb_writel(base, TUSB_DMA_INT_MASK, 0x7fffffff);
-	musb_writel(base, TUSB_GPIO_INT_MASK, 0x1ff);
+	musb_writel(tbase, TUSB_INT_MASK, ~TUSB_INT_MASK_RESERVED_BITS);
+	musb_writel(tbase, TUSB_USBIP_INT_MASK, 0);
+	musb_writel(tbase, TUSB_DMA_INT_MASK, 0x7fffffff);
+	musb_writel(tbase, TUSB_GPIO_INT_MASK, 0x1ff);
 
 	del_timer(&musb_idle_timer);
 
+	if (musb->set_clock)
+		musb->set_clock(musb->clock, 0);
+
 	if (is_dma_capable() && !dma_off) {
 		printk(KERN_WARNING "%s %s: dma still active\n",
-				__FILE__, __FUNCTION__);
+				__FILE__, __func__);
 		dma_off = 1;
 	}
 }
@@ -808,54 +1039,34 @@
  */
 static void __init tusb_setup_cpu_interface(struct musb *musb)
 {
-	void __iomem	*base = musb->ctrl_base;
+	void __iomem	*tbase = musb->ctrl_base;
+
+	/*
+	 * Disable GPIO[5:0] pullups (used as output DMA requests)
+	 * Don't disable GPIO[7:6] as they are needed for wake-up.
+	 */
+	musb_writel(tbase, TUSB_PULLUP_1_CTRL, 0x0000003F);
 
-	/* Disable GPIO[7:0] pullups (used as output DMA requests) */
-	musb_writel(base, TUSB_PULLUP_1_CTRL, 0x000000FF);
 	/* Disable all pullups on NOR IF, DMAREQ0 and DMAREQ1 */
-	musb_writel(base, TUSB_PULLUP_2_CTRL, 0x01FFFFFF);
+	musb_writel(tbase, TUSB_PULLUP_2_CTRL, 0x01FFFFFF);
 
 	/* Turn GPIO[5:0] to DMAREQ[5:0] signals */
-	musb_writel(base, TUSB_GPIO_CONF, TUSB_GPIO_CONF_DMAREQ(0x3f));
+	musb_writel(tbase, TUSB_GPIO_CONF, TUSB_GPIO_CONF_DMAREQ(0x3f));
 
 	/* Burst size 16x16 bits, all six DMA requests enabled, DMA request
 	 * de-assertion time 2 system clocks p 62 */
-	musb_writel(base, TUSB_DMA_REQ_CONF,
+	musb_writel(tbase, TUSB_DMA_REQ_CONF,
 		TUSB_DMA_REQ_CONF_BURST_SIZE(2) |
 		TUSB_DMA_REQ_CONF_DMA_REQ_EN(0x3f) |
 		TUSB_DMA_REQ_CONF_DMA_REQ_ASSER(2));
 
 	/* Set 0 wait count for synchronous burst access */
-	musb_writel(base, TUSB_WAIT_COUNT, 1);
-}
-
-#define TUSB_REV_MAJOR(reg_val)		((reg_val >> 4) & 0xf)
-#define TUSB_REV_MINOR(reg_val)		(reg_val & 0xf)
-
-static int __init tusb_print_revision(struct musb *musb)
-{
-	void __iomem	*base = musb->ctrl_base;
-
-	pr_info("tusb: Revisions: %s%i.%i %s%i.%i %s%i.%i %s%i.%i\n",
-		"prcm",
-		TUSB_REV_MAJOR(musb_readl(base, TUSB_PRCM_REV)),
-		TUSB_REV_MINOR(musb_readl(base, TUSB_PRCM_REV)),
-		"int",
-		TUSB_REV_MAJOR(musb_readl(base, TUSB_INT_CTRL_REV)),
-		TUSB_REV_MINOR(musb_readl(base, TUSB_INT_CTRL_REV)),
-		"gpio",
-		TUSB_REV_MAJOR(musb_readl(base, TUSB_GPIO_REV)),
-		TUSB_REV_MINOR(musb_readl(base, TUSB_GPIO_REV)),
-		"dma",
-		TUSB_REV_MAJOR(musb_readl(base, TUSB_DMA_CTRL_REV)),
-		TUSB_REV_MINOR(musb_readl(base, TUSB_DMA_CTRL_REV)));
-
-	return TUSB_REV_MAJOR(musb_readl(base, TUSB_INT_CTRL_REV));
+	musb_writel(tbase, TUSB_WAIT_COUNT, 1);
 }
 
 static int __init tusb_start(struct musb *musb)
 {
-	void __iomem	*base = musb->ctrl_base;
+	void __iomem	*tbase = musb->ctrl_base;
 	int		ret = 0;
 	unsigned long	flags;
 	u32		reg;
@@ -867,9 +1078,9 @@
 		return ret;
 	}
 
-	spin_lock_irqsave(&musb->Lock, flags);
+	spin_lock_irqsave(&musb->lock, flags);
 
-	if (musb_readl(base, TUSB_PROD_TEST_RESET) !=
+	if (musb_readl(tbase, TUSB_PROD_TEST_RESET) !=
 		TUSB_PROD_TEST_RESET_VAL) {
 		printk(KERN_ERR "tusb: Unable to detect TUSB6010\n");
 		goto err;
@@ -884,7 +1095,7 @@
 
 	/* The uint bit for "USB non-PDR interrupt enable" has to be 1 when
 	 * NOR FLASH interface is used */
-	musb_writel(base, TUSB_VLYNQ_CTRL, 8);
+	musb_writel(tbase, TUSB_VLYNQ_CTRL, 8);
 
 	/* Select PHY free running 60MHz as a system clock */
 	tusb_set_clock_source(musb, 1);
@@ -892,7 +1103,7 @@
 	/* VBus valid timer 1us, disable DFT/Debug and VLYNQ clocks for
 	 * power saving, enable VBus detect and session end comparators,
 	 * enable IDpullup, enable VBus charging */
-	musb_writel(base, TUSB_PRCM_MNGMT,
+	musb_writel(tbase, TUSB_PRCM_MNGMT,
 		TUSB_PRCM_MNGMT_VBUS_VALID_TIMER(0xa) |
 		TUSB_PRCM_MNGMT_VBUS_VALID_FLT_EN |
 		TUSB_PRCM_MNGMT_OTG_SESS_END_EN |
@@ -901,20 +1112,20 @@
 	tusb_setup_cpu_interface(musb);
 
 	/* simplify:  always sense/pullup ID pins, as if in OTG mode */
-	reg = musb_readl(base, TUSB_PHY_OTG_CTRL);
+	reg = musb_readl(tbase, TUSB_PHY_OTG_CTRL_ENABLE);
 	reg |= TUSB_PHY_OTG_CTRL_WRPROTECT | TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;
-	musb_writel(base, TUSB_PHY_OTG_CTRL, reg);
+	musb_writel(tbase, TUSB_PHY_OTG_CTRL_ENABLE, reg);
 
-	reg = musb_readl(base, TUSB_PHY_OTG_CTRL_ENABLE);
+	reg = musb_readl(tbase, TUSB_PHY_OTG_CTRL);
 	reg |= TUSB_PHY_OTG_CTRL_WRPROTECT | TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;
-	musb_writel(base, TUSB_PHY_OTG_CTRL_ENABLE, reg);
+	musb_writel(tbase, TUSB_PHY_OTG_CTRL, reg);
 
-	spin_unlock_irqrestore(&musb->Lock, flags);
+	spin_unlock_irqrestore(&musb->lock, flags);
 
 	return 0;
 
 err:
-	spin_unlock_irqrestore(&musb->Lock, flags);
+	spin_unlock_irqrestore(&musb->lock, flags);
 
 	if (musb->board_set_power)
 		musb->board_set_power(0);
@@ -953,7 +1164,7 @@
 	/* Offsets from base: VLYNQ at 0x000, MUSB regs at 0x400,
 	 * FIFOs at 0x600, TUSB at 0x800
 	 */
-	musb->pRegs += TUSB_BASE_OFFSET;
+	musb->mregs += TUSB_BASE_OFFSET;
 
 	ret = tusb_start(musb);
 	if (ret) {
@@ -968,6 +1179,11 @@
 	if (is_peripheral_enabled(musb))
 		musb->xceiv.set_power = tusb_draw_power;
 
+	ret = tusb_test_init(musb);
+	if (ret)
+		printk(KERN_WARNING "Could not start tusb6010 looptest (%d)\n",
+					ret);
+
 	setup_timer(&musb_idle_timer, musb_do_idle, (unsigned long) musb);
 
 	return ret;
@@ -975,6 +1191,7 @@
 
 int musb_platform_exit(struct musb *musb)
 {
+	tusb_test_release();
 	del_timer_sync(&musb_idle_timer);
 
 	if (musb->board_set_power)
diff -ruN linux-omap-2.6/drivers/usb/musb/tusb6010.h maemo_src/drivers/usb/musb/tusb6010.h
--- linux-omap-2.6/drivers/usb/musb/tusb6010.h	2011-02-06 20:17:25.933333273 -0500
+++ maemo_src/drivers/usb/musb/tusb6010.h	2011-02-06 20:12:11.333333272 -0500
@@ -25,6 +25,15 @@
 #define tusb_dma_omap()			0
 #endif
 
+#ifdef CONFIG_USB_TUSB6010_TEST
+extern int tusb_test_init(struct musb *musb);
+extern void tusb_test_release(void);
+extern void tusb_allow_idle(struct musb *musb, u32 wakeup_enables);
+#else
+#define tusb_test_init(x)	0
+#define tusb_test_release()	do {} while(0)
+#endif
+
 /* VLYNQ control register. 32-bit at offset 0x000 */
 #define TUSB_VLYNQ_CTRL			0x004
 
@@ -216,6 +225,18 @@
 #define TUSB_PROD_TEST_RESET_VAL		0xa596
 #define TUSB_EP_FIFO(ep)			(TUSB_FIFO_BASE + (ep) * 0x20)
 
+#define TUSB_DIDR1_LO				(TUSB_SYS_REG_BASE + 0x1f8)
+#define TUSB_DIDR1_HI				(TUSB_SYS_REG_BASE + 0x1fc)
+#define		TUSB_DIDR1_HI_CHIP_REV(v)		(((v) >> 17) & 0xf)
+#define			TUSB_DIDR1_HI_REV_20		0
+#define			TUSB_DIDR1_HI_REV_30		1
+#define			TUSB_DIDR1_HI_REV_31		2
+
+#define TUSB_REV_10	0x10
+#define TUSB_REV_20	0x20
+#define TUSB_REV_30	0x30
+#define TUSB_REV_31	0x31
+
 /*----------------------------------------------------------------------------*/
 
 #ifdef CONFIG_USB_TUSB6010
diff -ruN linux-omap-2.6/drivers/usb/musb/tusb6010_omap.c maemo_src/drivers/usb/musb/tusb6010_omap.c
--- linux-omap-2.6/drivers/usb/musb/tusb6010_omap.c	2011-02-06 20:17:25.933333273 -0500
+++ maemo_src/drivers/usb/musb/tusb6010_omap.c	2011-02-06 20:12:11.223333274 -0500
@@ -18,7 +18,7 @@
 #include <asm/arch/dma.h>
 #include <asm/arch/mux.h>
 
-#include "musbdefs.h"
+#include "musb_core.h"
 
 /*
  * REVISIT: With TUSB2.0 only one dmareq line can be used at a time.
@@ -32,13 +32,13 @@
 #define dmareq_works()		1
 #endif
 
-#define to_chdat(c)		(struct tusb_omap_dma_ch *)(c)->pPrivateData
+#define to_chdat(c)		(struct tusb_omap_dma_ch *)(c)->private_data
 
 #define MAX_DMAREQ		5	/* REVISIT: Really 6, but req5 not OK */
 
 struct tusb_omap_dma_ch {
 	struct musb		*musb;
-	void __iomem		*tusb_base;
+	void __iomem		*tbase;
 	unsigned long		phys_offset;
 	int			epnum;
 	u8			tx;
@@ -62,7 +62,7 @@
 struct tusb_omap_dma {
 	struct dma_controller		controller;
 	struct musb			*musb;
-	void __iomem			*tusb_base;
+	void __iomem			*tbase;
 
 	int				ch;
 	s8				dmareq;
@@ -75,7 +75,7 @@
 
 	tusb_dma = container_of(c, struct tusb_omap_dma, controller);
 
-	// DBG(3, "ep%i ch: %i\n", chdat->epnum, chdat->ch);
+	/* DBG(3, "ep%i ch: %i\n", chdat->epnum, chdat->ch); */
 
 	return 0;
 }
@@ -86,7 +86,7 @@
 
 	tusb_dma = container_of(c, struct tusb_omap_dma, controller);
 
-	// DBG(3, "ep%i ch: %i\n", chdat->epnum, chdat->ch);
+	/* DBG(3, "ep%i ch: %i\n", chdat->epnum, chdat->ch); */
 
 	return 0;
 }
@@ -98,7 +98,7 @@
  */
 static inline int tusb_omap_use_shared_dmareq(struct tusb_omap_dma_ch *chdat)
 {
-	u32		reg = musb_readl(chdat->tusb_base, TUSB_DMA_EP_MAP);
+	u32		reg = musb_readl(chdat->tbase, TUSB_DMA_EP_MAP);
 
 	if (reg != 0) {
 		DBG(3, "ep%i dmareq0 is busy for ep%i\n",
@@ -111,21 +111,21 @@
 	else
 		reg = chdat->epnum;
 
-	musb_writel(chdat->tusb_base, TUSB_DMA_EP_MAP, reg);
+	musb_writel(chdat->tbase, TUSB_DMA_EP_MAP, reg);
 
 	return 0;
 }
 
 static inline void tusb_omap_free_shared_dmareq(struct tusb_omap_dma_ch *chdat)
 {
-	u32		reg = musb_readl(chdat->tusb_base, TUSB_DMA_EP_MAP);
+	u32		reg = musb_readl(chdat->tbase, TUSB_DMA_EP_MAP);
 
 	if ((reg & 0xf) != chdat->epnum) {
 		printk(KERN_ERR "ep%i trying to release dmareq0 for ep%i\n",
 			chdat->epnum, reg & 0xf);
 		return;
 	}
-	musb_writel(chdat->tusb_base, TUSB_DMA_EP_MAP, 0);
+	musb_writel(chdat->tbase, TUSB_DMA_EP_MAP, 0);
 }
 
 #else
@@ -145,11 +145,11 @@
 	struct musb		*musb = chdat->musb;
 	struct musb_hw_ep	*hw_ep = chdat->hw_ep;
 	void __iomem		*ep_conf = hw_ep->conf;
-	void __iomem		*musb_base = musb->pRegs;
+	void __iomem		*mbase = musb->mregs;
 	unsigned long		remaining, flags, pio;
 	int			ch;
 
-	spin_lock_irqsave(&musb->Lock, flags);
+	spin_lock_irqsave(&musb->lock, flags);
 
 	if (dmareq_works())
 		ch = chdat->ch;
@@ -159,7 +159,7 @@
 	if (ch_status != OMAP_DMA_BLOCK_IRQ)
 		printk(KERN_ERR "TUSB DMA error status: %i\n", ch_status);
 
-	DBG(2, "ep%i %s dma callback ch: %i status: %x\n",
+	DBG(3, "ep%i %s dma callback ch: %i status: %x\n",
 		chdat->epnum, chdat->tx ? "tx" : "rx",
 		ch, ch_status);
 
@@ -170,22 +170,24 @@
 
 	remaining = TUSB_EP_CONFIG_XFR_SIZE(remaining);
 
-	/* HW issue #10: XFR_SIZE may get corrupt on async DMA */
+	/* HW issue #10: XFR_SIZE may get corrupt on DMA (both async & sync) */
 	if (unlikely(remaining > chdat->transfer_len)) {
-		WARN("Corrupt XFR_SIZE with async DMA: %lu\n", remaining);
+		DBG(2, "Corrupt %s dma ch%i XFR_SIZE: 0x%08lx\n",
+			chdat->tx ? "tx" : "rx", chdat->ch,
+			remaining);
 		remaining = 0;
 	}
 
-	channel->dwActualLength = chdat->transfer_len - remaining;
-	pio = chdat->len - channel->dwActualLength;
+	channel->actual_len = chdat->transfer_len - remaining;
+	pio = chdat->len - channel->actual_len;
 
-	DBG(2, "DMA remaining %lu/%u\n", remaining, chdat->transfer_len);
+	DBG(3, "DMA remaining %lu/%u\n", remaining, chdat->transfer_len);
 
 	/* Transfer remaining 1 - 31 bytes */
 	if (pio > 0 && pio < 32) {
 		u8	*buf;
 
-		DBG(2, "Using PIO for remaining %i bytes\n", pio);
+		DBG(3, "Using PIO for remaining %lu bytes\n", pio);
 		buf = phys_to_virt((u32)chdat->dma_addr) + chdat->transfer_len;
 		if (chdat->tx) {
 			consistent_sync(phys_to_virt((u32)chdat->dma_addr),
@@ -196,13 +198,13 @@
 			consistent_sync(phys_to_virt((u32)chdat->dma_addr),
 					chdat->transfer_len, DMA_FROM_DEVICE);
 		}
-		channel->dwActualLength += pio;
+		channel->actual_len += pio;
 	}
 
 	if (!dmareq_works())
 		tusb_omap_free_shared_dmareq(chdat);
 
-	channel->bStatus = MGC_DMA_STATUS_FREE;
+	channel->status = MUSB_DMA_STATUS_FREE;
 
 	/* Handle only RX callbacks here. TX callbacks musb be handled based
 	 * on the TUSB DMA status interrupt.
@@ -221,16 +223,16 @@
 		u16	csr;
 
 		if (chdat->tx) {
-			DBG(2, "terminating short tx packet\n");
-			MGC_SelectEnd(musb_base, chdat->epnum);
-			csr = musb_readw(hw_ep->regs, MGC_O_HDRC_TXCSR);
-			csr |= MGC_M_TXCSR_MODE | MGC_M_TXCSR_TXPKTRDY
-				| MGC_M_TXCSR_P_WZC_BITS;
-			musb_writew(hw_ep->regs, MGC_O_HDRC_TXCSR, csr);
+			DBG(3, "terminating short tx packet\n");
+			musb_ep_select(mbase, chdat->epnum);
+			csr = musb_readw(hw_ep->regs, MUSB_TXCSR);
+			csr |= MUSB_TXCSR_MODE | MUSB_TXCSR_TXPKTRDY
+				| MUSB_TXCSR_P_WZC_BITS;
+			musb_writew(hw_ep->regs, MUSB_TXCSR, csr);
 		}
 	}
 
-	spin_unlock_irqrestore(&musb->Lock, flags);
+	spin_unlock_irqrestore(&musb->lock, flags);
 }
 
 static int tusb_omap_dma_program(struct dma_channel *channel, u16 packet_sz,
@@ -240,10 +242,11 @@
 	struct tusb_omap_dma		*tusb_dma = chdat->tusb_dma;
 	struct musb			*musb = chdat->musb;
 	struct musb_hw_ep		*hw_ep = chdat->hw_ep;
-	void __iomem			*musb_base = musb->pRegs;
+	void __iomem			*mbase = musb->mregs;
 	void __iomem			*ep_conf = hw_ep->conf;
 	dma_addr_t			fifo = hw_ep->fifo_sync;
 	struct omap_dma_channel_params	dma_params;
+	u32				dma_remaining;
 	int				src_burst, dst_burst;
 	u16				csr;
 	int				ch;
@@ -251,7 +254,7 @@
 	s8				sync_dev;
 
 	if (unlikely(dma_addr & 0x1) || (len < 32) || (len > packet_sz))
-		return FALSE;
+		return false;
 
 	/*
 	 * HW issue #10: Async dma will eventually corrupt the XFR_SIZE
@@ -260,7 +263,26 @@
 	 * register is corrupt, and we won't know if the DMA worked.
 	 */
 	if (dma_addr & 0x2)
-		return FALSE;
+		return false;
+
+	/*
+	 * Because of HW issue #10, it seems like mixing sync DMA and async
+	 * PIO access can confuse the DMA. Make sure XFR_SIZE is reset before
+	 * using the channel for DMA.
+	 */
+	if (chdat->tx)
+		dma_remaining = musb_readl(ep_conf, TUSB_EP_TX_OFFSET);
+	else
+		dma_remaining = musb_readl(ep_conf, TUSB_EP_RX_OFFSET);
+
+	dma_remaining = TUSB_EP_CONFIG_XFR_SIZE(dma_remaining);
+	if (dma_remaining) {
+		DBG(2, "Busy %s dma ch%i, not using: %08x\n",
+			chdat->tx ? "tx" : "rx", chdat->ch,
+			dma_remaining);
+		return false;
+	}
+
 
 	chdat->transfer_len = len & ~0x1f;
 
@@ -276,14 +298,14 @@
 	} else {
 		if (tusb_omap_use_shared_dmareq(chdat) != 0) {
 			DBG(3, "could not get dma for ep%i\n", chdat->epnum);
-			return FALSE;
+			return false;
 		}
 		if (tusb_dma->ch < 0) {
 			/* REVISIT: This should get blocked earlier, happens
 			 * with MSC ErrorRecoveryTest
 			 */
 			WARN_ON(1);
-			return FALSE;
+			return false;
 		}
 
 		ch = tusb_dma->ch;
@@ -294,14 +316,14 @@
 
 	chdat->packet_sz = packet_sz;
 	chdat->len = len;
-	channel->dwActualLength = 0;
+	channel->actual_len = 0;
 	chdat->dma_addr = (void __iomem *)dma_addr;
-	channel->bStatus = MGC_DMA_STATUS_BUSY;
+	channel->status = MUSB_DMA_STATUS_BUSY;
 
 	/* Since we're recycling dma areas, we need to clean or invalidate */
-	if (chdat->tx) {
+	if (chdat->tx)
 		consistent_sync(phys_to_virt(dma_addr), len, DMA_TO_DEVICE);
-	} else
+	else
 		consistent_sync(phys_to_virt(dma_addr), len, DMA_FROM_DEVICE);
 
 	/* Use 16-bit transfer if dma_addr is not 32-bit aligned */
@@ -316,7 +338,7 @@
 
 	dma_params.frame_count	= chdat->transfer_len / 32; /* Burst sz frame */
 
-	DBG(2, "ep%i %s dma ch%i dma: %08x len: %u(%u) packet_sz: %i(%i)\n",
+	DBG(3, "ep%i %s dma ch%i dma: %08x len: %u(%u) packet_sz: %i(%i)\n",
 		chdat->epnum, chdat->tx ? "tx" : "rx",
 		ch, dma_addr, chdat->transfer_len, len,
 		chdat->transfer_packet_sz, packet_sz);
@@ -333,7 +355,7 @@
 		dma_params.dst_amode	= OMAP_DMA_AMODE_DOUBLE_IDX;
 		dma_params.dst_start	= (unsigned long)fifo;
 		dma_params.dst_ei	= 1;
-		dma_params.dst_fi	= -31;		/* Loop 32 byte window */
+		dma_params.dst_fi	= -31;	/* Loop 32 byte window */
 
 		dma_params.trigger	= sync_dev;
 		dma_params.sync_mode	= OMAP_DMA_SYNC_FRAME;
@@ -345,7 +367,7 @@
 		dma_params.src_amode	= OMAP_DMA_AMODE_DOUBLE_IDX;
 		dma_params.src_start	= (unsigned long)fifo;
 		dma_params.src_ei	= 1;
-		dma_params.src_fi	= -31;		/* Loop 32 byte window */
+		dma_params.src_fi	= -31;	/* Loop 32 byte window */
 
 		dma_params.dst_amode	= OMAP_DMA_AMODE_POST_INC;
 		dma_params.dst_start	= (unsigned long)dma_addr;
@@ -360,7 +382,7 @@
 		dst_burst = OMAP_DMA_DATA_BURST_16;	/* 16x32 write */
 	}
 
-	DBG(2, "ep%i %s using %i-bit %s dma from 0x%08lx to 0x%08lx\n",
+	DBG(3, "ep%i %s using %i-bit %s dma from 0x%08lx to 0x%08lx\n",
 		chdat->epnum, chdat->tx ? "tx" : "rx",
 		(dma_params.data_type == OMAP_DMA_DATA_TYPE_S32) ? 32 : 16,
 		((dma_addr & 0x3) == 0) ? "sync" : "async",
@@ -375,19 +397,19 @@
 	 * Prepare MUSB for DMA transfer
 	 */
 	if (chdat->tx) {
-		MGC_SelectEnd(musb_base, chdat->epnum);
-		csr = musb_readw(hw_ep->regs, MGC_O_HDRC_TXCSR);
-		csr |= (MGC_M_TXCSR_AUTOSET | MGC_M_TXCSR_DMAENAB
-			| MGC_M_TXCSR_DMAMODE | MGC_M_TXCSR_MODE);
-		csr &= ~MGC_M_TXCSR_P_UNDERRUN;
-		musb_writew(hw_ep->regs, MGC_O_HDRC_TXCSR, csr);
+		musb_ep_select(mbase, chdat->epnum);
+		csr = musb_readw(hw_ep->regs, MUSB_TXCSR);
+		csr |= (MUSB_TXCSR_AUTOSET | MUSB_TXCSR_DMAENAB
+			| MUSB_TXCSR_DMAMODE | MUSB_TXCSR_MODE);
+		csr &= ~MUSB_TXCSR_P_UNDERRUN;
+		musb_writew(hw_ep->regs, MUSB_TXCSR, csr);
 	} else {
-		MGC_SelectEnd(musb_base, chdat->epnum);
-		csr = musb_readw(hw_ep->regs, MGC_O_HDRC_RXCSR);
-		csr |= MGC_M_RXCSR_DMAENAB;
-		csr &= ~(MGC_M_RXCSR_AUTOCLEAR | MGC_M_RXCSR_DMAMODE);
-		musb_writew(hw_ep->regs, MGC_O_HDRC_RXCSR,
-			csr | MGC_M_RXCSR_P_WZC_BITS);
+		musb_ep_select(mbase, chdat->epnum);
+		csr = musb_readw(hw_ep->regs, MUSB_RXCSR);
+		csr |= MUSB_RXCSR_DMAENAB;
+		csr &= ~(MUSB_RXCSR_AUTOCLEAR | MUSB_RXCSR_DMAMODE);
+		musb_writew(hw_ep->regs, MUSB_RXCSR,
+			csr | MUSB_RXCSR_P_WZC_BITS);
 	}
 
 	/*
@@ -411,7 +433,7 @@
 			TUSB_EP_CONFIG_XFR_SIZE(chdat->transfer_len));
 	}
 
-	return TRUE;
+	return true;
 }
 
 static int tusb_omap_dma_abort(struct dma_channel *channel)
@@ -430,14 +452,14 @@
 		tusb_dma->sync_dev = -1;
 	}
 
-	channel->bStatus = MGC_DMA_STATUS_FREE;
+	channel->status = MUSB_DMA_STATUS_FREE;
 
 	return 0;
 }
 
 static inline int tusb_omap_dma_allocate_dmareq(struct tusb_omap_dma_ch *chdat)
 {
-	u32		reg = musb_readl(chdat->tusb_base, TUSB_DMA_EP_MAP);
+	u32		reg = musb_readl(chdat->tbase, TUSB_DMA_EP_MAP);
 	int		i, dmareq_nr = -1;
 
 	const int sync_dev[6] = {
@@ -463,7 +485,7 @@
 	reg |= (chdat->epnum << (dmareq_nr * 5));
 	if (chdat->tx)
 		reg |= ((1 << 4) << (dmareq_nr * 5));
-	musb_writel(chdat->tusb_base, TUSB_DMA_EP_MAP, reg);
+	musb_writel(chdat->tbase, TUSB_DMA_EP_MAP, reg);
 
 	chdat->dmareq = dmareq_nr;
 	chdat->sync_dev = sync_dev[chdat->dmareq];
@@ -478,9 +500,9 @@
 	if (!chdat || chdat->dmareq < 0)
 		return;
 
-	reg = musb_readl(chdat->tusb_base, TUSB_DMA_EP_MAP);
+	reg = musb_readl(chdat->tbase, TUSB_DMA_EP_MAP);
 	reg &= ~(0x1f << (chdat->dmareq * 5));
-	musb_writel(chdat->tusb_base, TUSB_DMA_EP_MAP, reg);
+	musb_writel(chdat->tbase, TUSB_DMA_EP_MAP, reg);
 
 	chdat->dmareq = -1;
 	chdat->sync_dev = -1;
@@ -497,34 +519,34 @@
 	const char		*dev_name;
 	struct tusb_omap_dma	*tusb_dma;
 	struct musb		*musb;
-	void __iomem		*tusb_base;
+	void __iomem		*tbase;
 	struct dma_channel	*channel = NULL;
 	struct tusb_omap_dma_ch	*chdat = NULL;
 	u32			reg;
 
 	tusb_dma = container_of(c, struct tusb_omap_dma, controller);
 	musb = tusb_dma->musb;
-	tusb_base = musb->ctrl_base;
+	tbase = musb->ctrl_base;
 
-	reg = musb_readl(tusb_base, TUSB_DMA_INT_MASK);
+	reg = musb_readl(tbase, TUSB_DMA_INT_MASK);
 	if (tx)
-		reg &= ~(1 << hw_ep->bLocalEnd);
+		reg &= ~(1 << hw_ep->epnum);
 	else
-		reg &= ~(1 << (hw_ep->bLocalEnd + 15));
-	musb_writel(tusb_base, TUSB_DMA_INT_MASK, reg);
+		reg &= ~(1 << (hw_ep->epnum + 15));
+	musb_writel(tbase, TUSB_DMA_INT_MASK, reg);
 
 	/* REVISIT: Why does dmareq5 not work? */
-	if (hw_ep->bLocalEnd == 0) {
+	if (hw_ep->epnum == 0) {
 		DBG(3, "Not allowing DMA for ep0 %s\n", tx ? "tx" : "rx");
 		return NULL;
 	}
 
 	for (i = 0; i < MAX_DMAREQ; i++) {
 		struct dma_channel *ch = dma_channel_pool[i];
-		if (ch->bStatus == MGC_DMA_STATUS_UNKNOWN) {
-			ch->bStatus = MGC_DMA_STATUS_FREE;
+		if (ch->status == MUSB_DMA_STATUS_UNKNOWN) {
+			ch->status = MUSB_DMA_STATUS_FREE;
 			channel = ch;
-			chdat = ch->pPrivateData;
+			chdat = ch->private_data;
 			break;
 		}
 	}
@@ -541,16 +563,16 @@
 	}
 
 	chdat->musb = tusb_dma->musb;
-	chdat->tusb_base = tusb_dma->tusb_base;
+	chdat->tbase = tusb_dma->tbase;
 	chdat->hw_ep = hw_ep;
-	chdat->epnum = hw_ep->bLocalEnd;
+	chdat->epnum = hw_ep->epnum;
 	chdat->dmareq = -1;
 	chdat->completed_len = 0;
 	chdat->tusb_dma = tusb_dma;
 
-	channel->dwMaxLength = 0x7fffffff;
-	channel->bDesiredMode = 0;
-	channel->dwActualLength = 0;
+	channel->max_len = 0x7fffffff;
+	channel->desired_mode = 0;
+	channel->actual_len = 0;
 
 	if (dmareq_works()) {
 		ret = tusb_omap_dma_allocate_dmareq(chdat);
@@ -578,7 +600,7 @@
 	DBG(3, "ep%i %s dma: %s dma%i dmareq%i sync%i\n",
 		chdat->epnum,
 		chdat->tx ? "tx" : "rx",
-		chdat->ch >=0 ? "dedicated" : "shared",
+		chdat->ch >= 0 ? "dedicated" : "shared",
 		chdat->ch >= 0 ? chdat->ch : tusb_dma->ch,
 		chdat->dmareq >= 0 ? chdat->dmareq : tusb_dma->dmareq,
 		chdat->sync_dev >= 0 ? chdat->sync_dev : tusb_dma->sync_dev);
@@ -589,7 +611,7 @@
 	tusb_omap_dma_free_dmareq(chdat);
 
 	DBG(3, "ep%i: Could not get a DMA channel\n", chdat->epnum);
-	channel->bStatus = MGC_DMA_STATUS_UNKNOWN;
+	channel->status = MUSB_DMA_STATUS_UNKNOWN;
 
 	return NULL;
 }
@@ -598,26 +620,26 @@
 {
 	struct tusb_omap_dma_ch	*chdat = to_chdat(channel);
 	struct musb		*musb = chdat->musb;
-	void __iomem		*tusb_base = musb->ctrl_base;
+	void __iomem		*tbase = musb->ctrl_base;
 	u32			reg;
 
 	DBG(3, "ep%i ch%i\n", chdat->epnum, chdat->ch);
 
-	reg = musb_readl(tusb_base, TUSB_DMA_INT_MASK);
+	reg = musb_readl(tbase, TUSB_DMA_INT_MASK);
 	if (chdat->tx)
 		reg |= (1 << chdat->epnum);
 	else
 		reg |= (1 << (chdat->epnum + 15));
-	musb_writel(tusb_base, TUSB_DMA_INT_MASK, reg);
+	musb_writel(tbase, TUSB_DMA_INT_MASK, reg);
 
-	reg = musb_readl(tusb_base, TUSB_DMA_INT_CLEAR);
+	reg = musb_readl(tbase, TUSB_DMA_INT_CLEAR);
 	if (chdat->tx)
 		reg |= (1 << chdat->epnum);
 	else
 		reg |= (1 << (chdat->epnum + 15));
-	musb_writel(tusb_base, TUSB_DMA_INT_CLEAR, reg);
+	musb_writel(tbase, TUSB_DMA_INT_CLEAR, reg);
 
-	channel->bStatus = MGC_DMA_STATUS_UNKNOWN;
+	channel->status = MUSB_DMA_STATUS_UNKNOWN;
 
 	if (chdat->ch >= 0) {
 		omap_stop_dma(chdat->ch);
@@ -640,8 +662,7 @@
 	for (i = 0; i < MAX_DMAREQ; i++) {
 		struct dma_channel *ch = dma_channel_pool[i];
 		if (ch) {
-			if (ch->pPrivateData)
-				kfree(ch->pPrivateData);
+			kfree(ch->private_data);
 			kfree(ch);
 		}
 	}
@@ -655,7 +676,7 @@
 struct dma_controller *__init
 dma_controller_create(struct musb *musb, void __iomem *base)
 {
-	void __iomem		*tusb_base = musb->ctrl_base;
+	void __iomem		*tbase = musb->ctrl_base;
 	struct tusb_omap_dma	*tusb_dma;
 	int			i;
 
@@ -664,7 +685,7 @@
 	musb_writel(musb->ctrl_base, TUSB_DMA_INT_MASK, 0x7fffffff);
 	musb_writel(musb->ctrl_base, TUSB_DMA_EP_MAP, 0);
 
-	musb_writel(tusb_base, TUSB_DMA_REQ_CONF,
+	musb_writel(tbase, TUSB_DMA_REQ_CONF,
 		TUSB_DMA_REQ_CONF_BURST_SIZE(2)
 		| TUSB_DMA_REQ_CONF_DMA_REQ_EN(0x3f)
 		| TUSB_DMA_REQ_CONF_DMA_REQ_ASSER(2));
@@ -674,7 +695,7 @@
 		goto cleanup;
 
 	tusb_dma->musb = musb;
-	tusb_dma->tusb_base = musb->ctrl_base;
+	tusb_dma->tbase = musb->ctrl_base;
 
 	tusb_dma->ch = -1;
 	tusb_dma->dmareq = -1;
@@ -686,7 +707,7 @@
 	tusb_dma->controller.channel_release = tusb_omap_dma_release;
 	tusb_dma->controller.channel_program = tusb_omap_dma_program;
 	tusb_dma->controller.channel_abort = tusb_omap_dma_abort;
-	tusb_dma->controller.pPrivateData = tusb_dma;
+	tusb_dma->controller.private_data = tusb_dma;
 
 	for (i = 0; i < MAX_DMAREQ; i++) {
 		struct dma_channel	*ch;
@@ -702,8 +723,8 @@
 		if (!chdat)
 			goto cleanup;
 
-		ch->bStatus = MGC_DMA_STATUS_UNKNOWN;
-		ch->pPrivateData = chdat;
+		ch->status = MUSB_DMA_STATUS_UNKNOWN;
+		ch->private_data = chdat;
 	}
 
 	return &tusb_dma->controller;
diff -ruN linux-omap-2.6/drivers/usb/musb/tusb6010_test.c maemo_src/drivers/usb/musb/tusb6010_test.c
--- linux-omap-2.6/drivers/usb/musb/tusb6010_test.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/drivers/usb/musb/tusb6010_test.c	2007-10-02 03:09:32.000000000 -0400
@@ -0,0 +1,267 @@
+/*
+ * Optional support for a non-standard TUSB6010 loopback test
+ *
+ * Copyright (C) 2006 Nokia Corporation
+ * Tony Lindgren <tony@atomide.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ * In order for the test to work, the dongle musb connect DM to DP over a 1k
+ * resistor when VBUS is enabled. By using direct OTG PHY register access
+ * DM line is raised by the test function, which then also raises DP line if
+ * the dongle is connected.
+ *
+ * To run the test, connect the loopback dongle to the USB interface on the
+ * board and type the following on the board:
+ *
+ * # cat /sys/devices/platform/musb_hdrc/looptest
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/irq.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <asm/mach-types.h>
+
+#include "musb_core.h"
+#include "tusb6010.h"
+
+#define TUSB_TEST_PASSED		0
+#define TUSB_TEST_FAILED		-1
+#define TUSB_TEST_INIT_ERROR		-2
+
+#define TUSB_PIN_TEST_MASK	(TUSB_DEV_OTG_STAT_DP_ENABLE |	\
+					TUSB_DEV_OTG_STAT_DM_ENABLE)
+
+#define test_otg()		(!machine_is_nokia_n800())
+
+static struct musb *the_musb;
+
+static inline void tusb_test_debug(u32 otg_stat, char *msg)
+{
+	DBG(2, "%s %s %s otg_stat: 0x%08x %s\n",
+		otg_stat & TUSB_DEV_OTG_STAT_ID_STATUS ? "ID" : "  ",
+		otg_stat & TUSB_DEV_OTG_STAT_DP_ENABLE ? "D+" : "  ",
+		otg_stat & TUSB_DEV_OTG_STAT_DM_ENABLE ? "D-" : "  ",
+		otg_stat, msg);
+}
+
+static inline void tusb_test_set_mode(struct musb *musb, u8 musb_mode)
+{
+	void __iomem	*mbase = musb->mregs;
+	void __iomem	*tbase = musb->ctrl_base;
+	u32		dev_conf, otg_stat;
+	u8		devctl;
+
+	dev_conf = musb_readl(tbase, TUSB_DEV_CONF);
+	devctl = musb_readb(mbase, MUSB_DEVCTL);
+	switch (musb_mode) {
+	case MUSB_HOST:
+		otg_stat = musb_readl(tbase, TUSB_DEV_OTG_STAT);
+		tusb_test_debug(otg_stat, "Forcing VBUS on");
+		musb_platform_set_mode(the_musb, MUSB_HOST);
+		dev_conf |= TUSB_DEV_CONF_USB_HOST_MODE;
+		devctl |= MUSB_DEVCTL_SESSION;
+		break;
+	case MUSB_PERIPHERAL:
+		musb_platform_set_mode(the_musb, MUSB_PERIPHERAL);
+		devctl &= ~MUSB_DEVCTL_SESSION;
+		break;
+	case MUSB_OTG:	/* Use OTG for ID pin, turn session on */
+		musb_platform_set_mode(the_musb, MUSB_OTG);
+		dev_conf &= ~TUSB_DEV_CONF_USB_HOST_MODE;
+		devctl |= MUSB_DEVCTL_SESSION;
+		break;
+	}
+	musb_writeb(mbase, MUSB_DEVCTL, devctl);
+	musb_writel(tbase, TUSB_DEV_CONF, dev_conf);
+}
+
+/*
+ * Runs a loopback test if a test device is connected.
+ * REVISIT: Change mdelay() to msleep() once GPIO level interrupt
+ * masking works. Note that we cannot currently mask tusb6010
+ * wake-up interrupt in the device.
+ */
+static int tusb_do_test(void)
+{
+	void __iomem	*base = the_musb->ctrl_base;
+	unsigned long	flags;
+	u32		int_mask, phy_otg_ena, phy_otg_ctrl, prcm_conf, otg_stat;
+	int		retries;
+	int		ret = 0;
+
+	if (the_musb == NULL)
+		return TUSB_TEST_INIT_ERROR;
+
+	spin_lock_irqsave(&the_musb->lock, flags);
+	int_mask = musb_readl(base, TUSB_INT_MASK);
+	musb_writel(base, TUSB_INT_MASK, ~TUSB_INT_MASK_RESERVED_BITS);
+	set_irq_type(the_musb->nIrq, IRQ_TYPE_NONE);
+
+	tusb_allow_idle(the_musb, 0);
+
+	/* Save registers */
+	phy_otg_ena = musb_readl(base, TUSB_PHY_OTG_CTRL_ENABLE);
+	phy_otg_ctrl = musb_readl(base, TUSB_PHY_OTG_CTRL);
+	prcm_conf = musb_readl(base, TUSB_PRCM_CONF);
+
+	/* Enable access to PHY OTG registers */
+	musb_writel(base, TUSB_PHY_OTG_CTRL_ENABLE, TUSB_PHY_OTG_CTRL_WRPROTECT
+			| phy_otg_ena | TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP
+			| TUSB_PHY_OTG_CTRL_DM_PULLDOWN);
+
+	/* Check ID line. It should be up at this point */
+	otg_stat = musb_readl(base, TUSB_DEV_OTG_STAT);
+	if (test_otg() && !(otg_stat & TUSB_DEV_OTG_STAT_ID_STATUS)) {
+		tusb_test_debug(otg_stat, "ID down before VBUS is on");
+		ret = TUSB_TEST_INIT_ERROR;
+		goto restore;
+	}
+
+	/* Pull down data lines */
+	musb_writel(base, TUSB_PHY_OTG_CTRL, TUSB_PHY_OTG_CTRL_WRPROTECT
+			 | (phy_otg_ctrl | TUSB_PHY_OTG_CTRL_DM_PULLDOWN
+				| TUSB_PHY_OTG_CTRL_DP_PULLDOWN));
+
+	/* Turn on VBUS as the test device needs it to ground ID pin */
+	tusb_test_set_mode(the_musb, MUSB_HOST);
+	mdelay(500);
+
+	/* Wait for the test device to ground ID pin */
+	retries = 30;
+	tusb_test_set_mode(the_musb, MUSB_OTG);
+	otg_stat = musb_readl(base, TUSB_DEV_OTG_STAT);
+	while (test_otg() && (otg_stat & TUSB_DEV_OTG_STAT_ID_STATUS)) {
+		tusb_test_debug(otg_stat, "ID still high after VBUS");
+		if (retries-- < 1) {
+			tusb_test_debug(otg_stat, "Timeout waiting ID ground");
+			ret = TUSB_TEST_FAILED;
+			goto restore;
+		}
+		tusb_test_set_mode(the_musb, MUSB_HOST);
+		musb_writel(base, TUSB_PHY_OTG_CTRL, TUSB_PHY_OTG_CTRL_WRPROTECT
+			 | (phy_otg_ctrl | TUSB_PHY_OTG_CTRL_DM_PULLDOWN));
+		mdelay(100);
+		tusb_test_set_mode(the_musb, MUSB_OTG);
+		otg_stat = musb_readl(base, TUSB_DEV_OTG_STAT);
+	}
+
+	/* Check lines. DM and DP lines should be now down */
+	otg_stat = musb_readl(base, TUSB_DEV_OTG_STAT);
+	if (otg_stat & TUSB_PIN_TEST_MASK) {
+		tusb_test_debug(otg_stat, "Line(s) up after VBUS is on");
+		ret = TUSB_TEST_INIT_ERROR;
+		goto restore;
+	}
+
+	/*
+	 * Try to raise DM line. If the loopback dongle is connected, DP
+	 * line should go up as well.
+	 */
+	for (retries = 0; retries < 30; retries++) {
+		static int	connected = 0;
+
+		tusb_test_set_mode(the_musb, MUSB_HOST);
+		mdelay(100);
+
+		musb_writel(base, TUSB_PHY_OTG_CTRL, TUSB_PHY_OTG_CTRL_WRPROTECT
+			| (phy_otg_ctrl & ~TUSB_PHY_OTG_CTRL_DM_PULLDOWN));
+
+		otg_stat = musb_readl(base, TUSB_DEV_OTG_STAT);
+
+		if (otg_stat & TUSB_DEV_OTG_STAT_DP_ENABLE)
+			connected++;
+		else
+			connected = 0;
+
+		if (connected)
+			tusb_test_debug(otg_stat, "D- & D+ connected");
+		else
+			tusb_test_debug(otg_stat, "D- & D+ disconnected");
+
+		if (connected >= 5) {
+			ret = TUSB_TEST_PASSED;
+			goto restore;
+		}
+		mdelay(100);
+	}
+
+	/* Failed to raise DP line */
+	tusb_test_debug(otg_stat, "DP down after test");
+	ret = TUSB_TEST_FAILED;
+
+restore:
+	tusb_test_set_mode(the_musb, MUSB_PERIPHERAL);
+
+	musb_writel(base, TUSB_PHY_OTG_CTRL_ENABLE, phy_otg_ena);
+	musb_writel(base, TUSB_PHY_OTG_CTRL, phy_otg_ctrl);
+	musb_writel(base, TUSB_PRCM_CONF, prcm_conf);
+
+	musb_platform_try_idle(the_musb, 0);
+
+	musb_writel(base, TUSB_INT_SRC_CLEAR,
+			0xffffffff & ~TUSB_INT_MASK_RESERVED_BITS);
+	musb_writel(base, TUSB_INT_MASK, int_mask);
+	spin_unlock_irqrestore(&the_musb->lock, flags);
+	set_irq_type(the_musb->nIrq, IRQ_TYPE_LEVEL_LOW);
+
+	return ret;
+}
+
+static ssize_t tusb_show_result(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	char		*s;
+	int		len;
+
+	switch (tusb_do_test()) {
+	case TUSB_TEST_PASSED:
+		s = "passed";
+		break;
+	case TUSB_TEST_FAILED:
+		s = "failed";
+		break;
+	case TUSB_TEST_INIT_ERROR:
+		s = "init error";
+		break;
+	default:
+		s = "unknown error";
+		break;
+	}
+
+	len = sprintf(buf, "%s\n", s);
+
+	return len;
+}
+
+static DEVICE_ATTR(looptest, 0440, tusb_show_result, NULL);
+
+int __devinit tusb_test_init(struct musb *musb)
+{
+	struct platform_device	*pdev;
+	struct device		*dev;
+
+	the_musb = musb;
+
+	pdev = to_platform_device(musb->controller);
+	dev = &pdev->dev;
+	return device_create_file(dev, &dev_attr_looptest);
+}
+
+void __devexit tusb_test_release(void)
+{
+	struct platform_device	*pdev;
+	struct device		*dev;
+
+	if (the_musb == NULL)
+		return;
+
+	pdev = to_platform_device(the_musb->controller);
+	dev = &pdev->dev;
+	device_remove_file(dev, &dev_attr_looptest);
+}
diff -ruN linux-omap-2.6/drivers/usb/musb/virthub.c maemo_src/drivers/usb/musb/virthub.c
--- linux-omap-2.6/drivers/usb/musb/virthub.c	2011-02-06 20:17:25.943333272 -0500
+++ maemo_src/drivers/usb/musb/virthub.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,386 +0,0 @@
-/*****************************************************************
- * Copyright 2005 Mentor Graphics Corporation
- * Copyright (C) 2005-2006 by Texas Instruments
- * Copyright (C) 2006 by Nokia Corporation
- *
- * This file is part of the Inventra Controller Driver for Linux.
- *
- * The Inventra Controller Driver for Linux is free software; you
- * can redistribute it and/or modify it under the terms of the GNU
- * General Public License version 2 as published by the Free Software
- * Foundation.
- *
- * The Inventra Controller Driver for Linux is distributed in
- * the hope that it will be useful, but WITHOUT ANY WARRANTY;
- * without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
- * License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with The Inventra Controller Driver for Linux ; if not,
- * write to the Free Software Foundation, Inc., 59 Temple Place,
- * Suite 330, Boston, MA  02111-1307  USA
- *
- * ANY DOWNLOAD, USE, REPRODUCTION, MODIFICATION OR DISTRIBUTION
- * OF THIS DRIVER INDICATES YOUR COMPLETE AND UNCONDITIONAL ACCEPTANCE
- * OF THOSE TERMS.THIS DRIVER IS PROVIDED "AS IS" AND MENTOR GRAPHICS
- * MAKES NO WARRANTIES, EXPRESS OR IMPLIED, RELATED TO THIS DRIVER.
- * MENTOR GRAPHICS SPECIFICALLY DISCLAIMS ALL IMPLIED WARRANTIES
- * OF MERCHANTABILITY; FITNESS FOR A PARTICULAR PURPOSE AND
- * NON-INFRINGEMENT.  MENTOR GRAPHICS DOES NOT PROVIDE SUPPORT
- * SERVICES OR UPDATES FOR THIS DRIVER, EVEN IF YOU ARE A MENTOR
- * GRAPHICS SUPPORT CUSTOMER.
- ******************************************************************/
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/slab.h>
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/time.h>
-#include <linux/timer.h>
-
-#include <asm/unaligned.h>
-
-#include "musbdefs.h"
-
-
-static void musb_port_suspend(struct musb *musb, u8 bSuspend)
-{
-	u8		power;
-	void __iomem	*pBase = musb->pRegs;
-
-	if (!is_host_active(musb))
-		return;
-
-	/* NOTE:  this doesn't necessarily put PHY into low power mode,
-	 * turning off its clock; that's a function of PHY integration and
-	 * MGC_M_POWER_ENSUSPEND.  PHY may need a clock (sigh) to detect
-	 * SE0 changing to connect (J) or wakeup (K) states.
-	 */
-	power = musb_readb(pBase, MGC_O_HDRC_POWER);
-	if (bSuspend) {
-		power &= ~MGC_M_POWER_RESUME;
-		power |= MGC_M_POWER_SUSPENDM;
-		musb_writeb(pBase, MGC_O_HDRC_POWER, power);
-
-		DBG(3, "Root port suspended, power %02x\n", power);
-
-		musb->port1_status |= USB_PORT_STAT_SUSPEND;
-		switch (musb->xceiv.state) {
-		case OTG_STATE_A_HOST:
-			musb->xceiv.state = OTG_STATE_A_SUSPEND;
-			musb->is_active = is_otg_enabled(musb)
-					&& musb->xceiv.host->b_hnp_enable;
-			musb_platform_try_idle(musb);
-			break;
-		case OTG_STATE_B_HOST:
-			musb->xceiv.state = OTG_STATE_B_PERIPHERAL;
-			MUSB_DEV_MODE(musb);
-			/* REVISIT restore setting of MGC_M_DEVCTL_HR */
-			break;
-		default:
-			DBG(1, "bogus rh suspend? %s\n",
-				otg_state_string(musb));
-		}
-	} else if (power & MGC_M_POWER_SUSPENDM) {
-		power &= ~MGC_M_POWER_SUSPENDM;
-		power |= MGC_M_POWER_RESUME;
-		musb_writeb(pBase, MGC_O_HDRC_POWER, power);
-
-		DBG(3, "Root port resuming, power %02x\n", power);
-
-		/* later, GetPortStatus will stop RESUME signaling */
-		musb->port1_status |= MUSB_PORT_STAT_RESUME;
-		musb->rh_timer = jiffies + msecs_to_jiffies(20);
-	}
-}
-
-static void musb_port_reset(struct musb *musb, u8 bReset)
-{
-	u8		power;
-	void __iomem	*pBase = musb->pRegs;
-
-#ifdef CONFIG_USB_MUSB_OTG
-	/* REVISIT this looks wrong for HNP */
-	u8 devctl = musb_readb(pBase, MGC_O_HDRC_DEVCTL);
-
-	if (musb->bDelayPortPowerOff || !(devctl & MGC_M_DEVCTL_HM)) {
-		return;
-	}
-#endif
-
-	if (!is_host_active(musb))
-		return;
-
-	/* NOTE:  caller guarantees it will turn off the reset when
-	 * the appropriate amount of time has passed
-	 */
-	power = musb_readb(pBase, MGC_O_HDRC_POWER);
-	if (bReset) {
-		musb->bIgnoreDisconnect = TRUE;
-		power &= 0xf0;
-		musb_writeb(pBase, MGC_O_HDRC_POWER,
-				power | MGC_M_POWER_RESET);
-
-		musb->port1_status |= USB_PORT_STAT_RESET;
-		musb->port1_status &= ~USB_PORT_STAT_ENABLE;
-		musb->rh_timer = jiffies + msecs_to_jiffies(50);
-	} else {
-		DBG(4, "root port reset stopped\n");
-		musb_writeb(pBase, MGC_O_HDRC_POWER,
-				power & ~MGC_M_POWER_RESET);
-
-		musb->bIgnoreDisconnect = FALSE;
-
-		power = musb_readb(pBase, MGC_O_HDRC_POWER);
-		if (power & MGC_M_POWER_HSMODE) {
-			DBG(4, "high-speed device connected\n");
-			musb->port1_status |= USB_PORT_STAT_HIGH_SPEED;
-		}
-
-		musb->port1_status &= ~USB_PORT_STAT_RESET;
-		musb->port1_status |= USB_PORT_STAT_ENABLE
-					| (USB_PORT_STAT_C_RESET << 16)
-					| (USB_PORT_STAT_C_ENABLE << 16);
-		usb_hcd_poll_rh_status(musb_to_hcd(musb));
-
-		musb->vbuserr_retry = VBUSERR_RETRY_COUNT;
-	}
-}
-
-void musb_root_disconnect(struct musb *musb)
-{
-	musb->port1_status = (1 << USB_PORT_FEAT_POWER)
-			| (1 << USB_PORT_FEAT_C_CONNECTION);
-
-	usb_hcd_poll_rh_status(musb_to_hcd(musb));
-	musb->is_active = 0;
-
-	switch (musb->xceiv.state) {
-	case OTG_STATE_A_HOST:
-	case OTG_STATE_A_SUSPEND:
-		musb->xceiv.state = OTG_STATE_A_WAIT_BCON;
-		break;
-	case OTG_STATE_A_WAIT_VFALL:
-		musb->xceiv.state = OTG_STATE_B_IDLE;
-		break;
-	default:
-		DBG(1, "host disconnect (%s)\n", otg_state_string(musb));
-	}
-}
-
-
-/*---------------------------------------------------------------------*/
-
-int musb_hub_status_data(struct usb_hcd *hcd, char *buf)
-{
-	struct musb	*musb = hcd_to_musb(hcd);
-	int		retval = 0;
-
-	/* called in_irq() via usb_hcd_poll_rh_status() */
-	if (musb->port1_status & 0xffff0000) {
-		*buf = 0x02;
-		retval = 1;
-	}
-	return retval;
-}
-
-int musb_hub_control(
-	struct usb_hcd	*hcd,
-	u16		typeReq,
-	u16		wValue,
-	u16		wIndex,
-	char		*buf,
-	u16		wLength)
-{
-	struct musb	*musb = hcd_to_musb(hcd);
-	u32		temp;
-	int		retval = 0;
-	unsigned long	flags;
-
-	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)))
-		return -ESHUTDOWN;
-
-	/* hub features:  always zero, setting is a NOP
-	 * port features: reported, sometimes updated when host is active
-	 * no indicators
-	 */
-	spin_lock_irqsave(&musb->Lock, flags);
-	switch (typeReq) {
-	case ClearHubFeature:
-	case SetHubFeature:
-		switch (wValue) {
-		case C_HUB_OVER_CURRENT:
-		case C_HUB_LOCAL_POWER:
-			break;
-		default:
-			goto error;
-		}
-		break;
-	case ClearPortFeature:
-		if (wIndex != 1)
-			goto error;
-
-		switch (wValue) {
-		case USB_PORT_FEAT_ENABLE:
-			break;
-		case USB_PORT_FEAT_SUSPEND:
-			musb_port_suspend(musb, FALSE);
-			break;
-		case USB_PORT_FEAT_POWER:
-			if (!(is_otg_enabled(musb) && hcd->self.is_b_host))
-				musb_set_vbus(musb, 0);
-			break;
-		case USB_PORT_FEAT_C_CONNECTION:
-		case USB_PORT_FEAT_C_ENABLE:
-		case USB_PORT_FEAT_C_OVER_CURRENT:
-		case USB_PORT_FEAT_C_RESET:
-		case USB_PORT_FEAT_C_SUSPEND:
-			break;
-		default:
-			goto error;
-		}
-		DBG(5, "clear feature %d\n", wValue);
-		musb->port1_status &= ~(1 << wValue);
-		break;
-	case GetHubDescriptor:
-		{
-		struct usb_hub_descriptor *desc = (void *)buf;
-
-		desc->bDescLength = 9;
-		desc->bDescriptorType = 0x29;
-		desc->bNbrPorts = 1;
-		desc->wHubCharacteristics = __constant_cpu_to_le16(
-				  0x0001	/* per-port power switching */
-				| 0x0010	/* no overcurrent reporting */
-				);
-		desc->bPwrOn2PwrGood = 5;	/* msec/2 */
-		desc->bHubContrCurrent = 0;
-
-		/* workaround bogus struct definition */
-		desc->DeviceRemovable[0] = 0x02;	/* port 1 */
-		desc->DeviceRemovable[1] = 0xff;
-		}
-		break;
-	case GetHubStatus:
-		temp = 0;
-		*(__le32 *) buf = cpu_to_le32 (temp);
-		break;
-	case GetPortStatus:
-		if (wIndex != 1)
-			goto error;
-
-		/* finish RESET signaling? */
-		if ((musb->port1_status & USB_PORT_STAT_RESET)
-				&& time_after(jiffies, musb->rh_timer))
-			musb_port_reset(musb, FALSE);
-
-		/* finish RESUME signaling? */
-		if ((musb->port1_status & MUSB_PORT_STAT_RESUME)
-				&& time_after(jiffies, musb->rh_timer)) {
-			u8		power;
-
-			power = musb_readb(musb->pRegs, MGC_O_HDRC_POWER);
-			power &= ~MGC_M_POWER_RESUME;
-			DBG(4, "root port resume stopped, power %02x\n",
-					power);
-			musb_writeb(musb->pRegs, MGC_O_HDRC_POWER, power);
-
-			/* ISSUE:  DaVinci (RTL 1.300) disconnects after
-			 * resume of high speed peripherals (but not full
-			 * speed ones).
-			 */
-
-			musb->is_active = 1;
-			musb->port1_status &= ~(USB_PORT_STAT_SUSPEND
-					| MUSB_PORT_STAT_RESUME);
-			musb->port1_status |= USB_PORT_STAT_C_SUSPEND << 16;
-			usb_hcd_poll_rh_status(musb_to_hcd(musb));
-			/* NOTE: it might really be A_WAIT_BCON ... */
-			musb->xceiv.state = OTG_STATE_A_HOST;
-		}
-
-		put_unaligned(cpu_to_le32(musb->port1_status & ~MUSB_PORT_STAT_RESUME),
-				(__le32 *) buf);
-
-		/* port change status is more interesting */
-		DBG(get_unaligned((u16*)(buf+2)) ? 2 : 5, "port status %08x\n",
-				musb->port1_status);
-		break;
-	case SetPortFeature:
-		if ((wIndex & 0xff) != 1)
-			goto error;
-
-		switch (wValue) {
-		case USB_PORT_FEAT_POWER:
-			/* NOTE: this controller has a strange state machine
-			 * that involves "requesting sessions" according to
-			 * magic side effects from incompletely-described
-			 * rules about startup...
-			 *
-			 * This call is what really starts the host mode; be
-			 * very careful about side effects if you reorder any
-			 * initialization logic, e.g. for OTG, or change any
-			 * logic relating to VBUS power-up.
-			 */
-			if (!(is_otg_enabled(musb) && hcd->self.is_b_host))
-				musb_start(musb);
-			break;
-		case USB_PORT_FEAT_RESET:
-			musb_port_reset(musb, TRUE);
-			break;
-		case USB_PORT_FEAT_SUSPEND:
-			musb_port_suspend(musb, TRUE);
-			break;
-		case USB_PORT_FEAT_TEST:
-			if (unlikely(is_host_active(musb)))
-				goto error;
-
-			wIndex >>= 8;
-			switch (wIndex) {
-			case 1:
-				pr_debug("TEST_J\n");
-				temp = MGC_M_TEST_J;
-				break;
-			case 2:
-				pr_debug("TEST_K\n");
-				temp = MGC_M_TEST_K;
-				break;
-			case 3:
-				pr_debug("TEST_SE0_NAK\n");
-				temp = MGC_M_TEST_SE0_NAK;
-				break;
-			case 4:
-				pr_debug("TEST_PACKET\n");
-				temp = MGC_M_TEST_PACKET;
-				musb_load_testpacket(musb);
-				break;
-			case 5:
-				pr_debug("TEST_FORCE_ENABLE\n");
-				temp = MGC_M_TEST_FORCE_HOST
-					| MGC_M_TEST_FORCE_HS;
-
-				/* FIXME and enable a session too */
-				break;
-			default:
-				goto error;
-			}
-			musb_writeb(musb->pRegs, MGC_O_HDRC_TESTMODE, temp);
-			break;
-		default:
-			goto error;
-		}
-		DBG(5, "set feature %d\n", wValue);
-		musb->port1_status |= 1 << wValue;
-		break;
-
-	default:
-error:
-		/* "protocol stall" on error */
-		retval = -EPIPE;
-	}
-	spin_unlock_irqrestore(&musb->Lock, flags);
-	return retval;
-}
diff -ruN linux-omap-2.6/drivers/video/omap/blizzard.c maemo_src/drivers/video/omap/blizzard.c
--- linux-omap-2.6/drivers/video/omap/blizzard.c	2011-02-06 20:17:25.949999940 -0500
+++ maemo_src/drivers/video/omap/blizzard.c	2011-02-06 20:12:10.746666607 -0500
@@ -136,6 +136,12 @@
 	void		 (*complete)(void *data);
 	void		 *complete_data;
 
+	enum {
+		OMAPFB_REQ_UPDATE_AUTO,
+		OMAPFB_REQ_UPDATE_MANUAL,
+		OMAPFB_REQ_SYNC,
+	} type;
+
 	union {
 		struct update_param	update;
 		struct completion	*sync;
@@ -192,6 +198,7 @@
 
 	void			(*power_up)(struct device *dev);
 	void			(*power_down)(struct device *dev);
+	unsigned long		(*get_clock_rate)(struct device *dev);
 
 	int			version;
 } blizzard;
@@ -470,6 +477,8 @@
 {
 	int i;
 	int flags;
+	struct list_head *queue, *next;
+	struct blizzard_request *entry;
 
 	for (i = 0; i < 3; i++) {
 		struct plane_info *p = &blizzard.plane[i];
@@ -500,6 +509,19 @@
 	else
 		disable_tearsync();
 
+	/* Coalesce redundant requests, given that we're already doing a full
+	 * screen update. */
+	queue = blizzard.pending_req_list.next;
+	while (queue != &blizzard.pending_req_list) {
+		entry = list_entry(queue, struct blizzard_request, entry);
+		next = queue->next;
+
+		if (entry != req && entry->type == OMAPFB_REQ_UPDATE_MANUAL)
+			free_req(entry);
+
+		queue = next;
+	}
+
 	set_window_regs(0, 0, blizzard.screen_width, blizzard.screen_height,
 			0, 0, blizzard.screen_width, blizzard.screen_height,
 			BLIZZARD_COLOR_RGB565, blizzard.zoom_on, flags);
@@ -701,8 +723,10 @@
 
 #define ADD_PREQ(_x, _y, _w, _h, _x_out, _y_out, _w_out, _h_out) do {	\
 	req = alloc_req();			\
+	req->type = OMAPFB_REQ_UPDATE_MANUAL;	\
 	req->handler	= send_frame_handler;	\
 	req->complete	= send_frame_complete;	\
+	req->complete_data = req;		\
 	req->par.update.plane = plane_idx;	\
 	req->par.update.x = _x;			\
 	req->par.update.y = _y;			\
@@ -790,6 +814,7 @@
 			&blizzard.auto_update_window, &req_list);
 	last = list_entry(req_list.prev, struct blizzard_request, entry);
 
+	last->type = OMAPFB_REQ_UPDATE_AUTO;
 	last->complete = auto_update_complete;
 	last->complete_data = NULL;
 
@@ -934,6 +959,7 @@
 
 	req = alloc_req();
 
+	req->type = OMAPFB_REQ_SYNC;
 	req->handler = sync_handler;
 	req->complete = NULL;
 	init_completion(&comp);
@@ -963,7 +989,7 @@
 	if (mode == blizzard.update_mode)
 		return 0;
 
-	dev_info(blizzard.fbdev->dev, "s1d1374x: setting update mode to %s\n",
+	dev_dbg(blizzard.fbdev->dev, "s1d1374x: setting update mode to %s\n",
 			mode == OMAPFB_UPDATE_DISABLED ? "disabled" :
 			(mode == OMAPFB_AUTO_UPDATE ? "auto" : "manual"));
 
@@ -1176,6 +1202,25 @@
 		*sys_clk, *pix_clk);
 }
 
+static void tearsync_update_pix_tx_time()
+{
+	/* time to transfer one pixel (16bpp) in ps */
+	blizzard.pix_tx_time = blizzard.reg_timings.we_cycle_time;
+	if (blizzard.extif->get_max_tx_rate != NULL) {
+		/* The external interface might have a rate limitation,
+		 * if so, we have to maximize our transfer rate.
+		 */
+		unsigned long min_tx_time;
+		unsigned long max_tx_rate = blizzard.extif->get_max_tx_rate();
+
+		dev_dbg(blizzard.fbdev->dev, "max_tx_rate %ld HZ\n",
+			max_tx_rate);
+		min_tx_time = 1000000000 / (max_tx_rate / 1000);  /* ps */
+		if (blizzard.pix_tx_time < min_tx_time)
+			blizzard.pix_tx_time = min_tx_time;
+	}
+}
+
 static int setup_tearsync(unsigned long pix_clk, int extif_div)
 {
 	int hdisp, vdisp;
@@ -1200,21 +1245,7 @@
 	hndp = blizzard_read_reg(BLIZZARD_HNDP) & 0x3f;
 	vndp = blizzard_read_reg(BLIZZARD_VNDP);
 
-	/* time to transfer one pixel (16bpp) in ps */
-	blizzard.pix_tx_time = blizzard.reg_timings.we_cycle_time;
-	if (blizzard.extif->get_max_tx_rate != NULL) {
-		/* The external interface might have a rate limitation,
-		 * if so, we have to maximize our transfer rate.
-		 */
-		unsigned long min_tx_time;
-		unsigned long max_tx_rate = blizzard.extif->get_max_tx_rate();
-
-		dev_dbg(blizzard.fbdev->dev, "max_tx_rate %ld HZ\n",
-			max_tx_rate);
-		min_tx_time = 1000000000 / (max_tx_rate / 1000);  /* ps */
-		if (blizzard.pix_tx_time < min_tx_time)
-			blizzard.pix_tx_time = min_tx_time;
-	}
+	tearsync_update_pix_tx_time();
 
 	/* time to update one line in ps */
 	blizzard.line_upd_time = (hdisp + hndp) * 1000000 / (pix_clk / 1000);
@@ -1255,8 +1286,8 @@
 
 	if (vs <= hs)
 		return -EDOM;
-	/* set VS to 120% of HS to minimize VS detection time */
-	vs = hs * 12 / 10;
+	/* set VS to 150% of HS to minimize VS detection time */
+	vs = hs * 15 / 10;
 	/* minimize HS too */
 	if (hs > 10000)
 		hs = 10000;
@@ -1281,6 +1312,44 @@
 					      extif_div);
 }
 
+static int blizzard_setup_clocks(void)
+{
+	struct omapfb_device *fbdev = blizzard.fbdev;
+	unsigned long ext_clk, sys_clk, pix_clk;
+	int extif_div;
+	int r;
+
+	ext_clk = blizzard.get_clock_rate(fbdev->dev);
+	r = calc_extif_timings(ext_clk, &extif_div);
+	if (r < 0)
+		return r;
+
+	set_extif_timings(&blizzard.reg_timings);
+
+	if (!(blizzard_read_reg(BLIZZARD_PLL_DIV) & 0x80)) {
+		dev_err(fbdev->dev,
+			"Blizzard PLL not locked.\n");
+		return -ENODEV;
+	}
+
+	calc_blizzard_clk_rates(ext_clk, &sys_clk, &pix_clk);
+
+	r = calc_extif_timings(sys_clk, &extif_div);
+	if (r < 0)
+		return r;
+	set_extif_timings(&blizzard.reg_timings);
+
+	if (blizzard.te_connected) {
+		r = setup_tearsync(pix_clk, extif_div);
+		if (r < 0)
+			return r;
+	}
+
+	blizzard.max_transmit_size = blizzard.extif->max_transmit_size;
+
+	return 0;
+}
+
 static void blizzard_get_caps(int plane, struct omapfb_caps *caps)
 {
 	blizzard.int_ctrl->get_caps(plane, caps);
@@ -1411,14 +1480,29 @@
 	blizzard_sync();
 }
 
+static void blizzard_freq_change(void)
+{
+#if 0
+	/* FIXME: this part of code was not active anyway,
+	   so keep it disabled for now */
+	if (blizzard.update_mode == OMAPFB_UPDATE_DISABLED)
+		return;
+
+	(void) blizzard_setup_clocks();
+
+	if (blizzard.int_ctrl->freq_changed)
+		blizzard.int_ctrl->freq_changed();
+#else
+	/* Update pixel transfer time on frequency change */
+	tearsync_update_pix_tx_time();
+#endif
+}
+
 static int blizzard_init(struct omapfb_device *fbdev, int ext_mode,
 			 struct omapfb_mem_desc *req_vram)
 {
 	int r = 0, i;
 	u8 rev, conf;
-	unsigned long ext_clk;
-	int extif_div;
-	unsigned long sys_clk, pix_clk;
 	struct omapfb_platform_data *omapfb_conf;
 	struct blizzard_platform_data *ctrl_conf;
 
@@ -1440,6 +1524,8 @@
 
 	blizzard.power_down = ctrl_conf->power_down;
 	blizzard.power_up = ctrl_conf->power_up;
+	blizzard.get_clock_rate = ctrl_conf->get_clock_rate;
+	blizzard.te_connected = ctrl_conf->te_connected;
 
 	spin_lock_init(&blizzard.req_lock);
 
@@ -1454,33 +1540,12 @@
 	blizzard_ctrl.setup_mem = blizzard.int_ctrl->setup_mem;
 	blizzard_ctrl.mmap = blizzard.int_ctrl->mmap;
 
-	ext_clk = ctrl_conf->get_clock_rate(fbdev->dev);
-	if ((r = calc_extif_timings(ext_clk, &extif_div)) < 0)
-		goto err3;
-
-	set_extif_timings(&blizzard.reg_timings);
-
 	if (blizzard.power_up != NULL)
 		blizzard.power_up(fbdev->dev);
 
-	calc_blizzard_clk_rates(ext_clk, &sys_clk, &pix_clk);
-
-	if ((r = calc_extif_timings(sys_clk, &extif_div)) < 0)
-		goto err3;
-	set_extif_timings(&blizzard.reg_timings);
-
-	if (!(blizzard_read_reg(BLIZZARD_PLL_DIV) & 0x80)) {
-		dev_err(fbdev->dev,
-			"controller not initialized by the bootloader\n");
-		r = -ENODEV;
+	r = blizzard_setup_clocks();
+	if (r < 0)
 		goto err3;
-	}
-
-	if (ctrl_conf->te_connected) {
-		if ((r = setup_tearsync(pix_clk, extif_div)) < 0)
-			goto err3;
-		blizzard.te_connected = 1;
-	}
 
 	rev = blizzard_read_reg(BLIZZARD_REV_CODE);
 	conf = blizzard_read_reg(BLIZZARD_CONFIG);
@@ -1503,8 +1568,6 @@
 		goto err3;
 	}
 
-	blizzard.max_transmit_size = blizzard.extif->max_transmit_size;
-
 	blizzard.update_mode = OMAPFB_UPDATE_DISABLED;
 
 	blizzard.auto_update_window.x = 0;
@@ -1566,5 +1629,6 @@
 	.sync			= blizzard_sync,
 	.suspend		= blizzard_suspend,
 	.resume			= blizzard_resume,
+	.freq_changed		= blizzard_freq_change,
 };
 
diff -ruN linux-omap-2.6/drivers/video/omap/dispc.c maemo_src/drivers/video/omap/dispc.c
--- linux-omap-2.6/drivers/video/omap/dispc.c	2011-02-06 20:17:25.966666606 -0500
+++ maemo_src/drivers/video/omap/dispc.c	2011-02-06 20:12:10.729999939 -0500
@@ -132,6 +132,10 @@
 
 #define MAX_PALETTE_SIZE		(256 * 16)
 
+#define VA_CONTROL_STAT			IO_ADDRESS(0x480002F8)
+#define GP_DEVICE			0x300
+#define TYPE_MASK			0x700
+
 #define FLD_MASK(pos, len)	(((1 << len) - 1) << pos)
 
 #define MOD_REG_FLD(reg, mask, val) \
@@ -868,6 +872,7 @@
 static irqreturn_t omap_dispc_irq_handler(int irq, void *dev)
 {
 	u32 stat = dispc_read_reg(DISPC_IRQSTATUS);
+	dispc_write_reg(DISPC_IRQSTATUS, stat);
 
 	if (stat & DISPC_IRQ_FRAMEMASK)
 		complete(&dispc.frame_done);
@@ -882,8 +887,6 @@
 	if ((stat & dispc.enabled_irqs) && dispc.irq_callback)
 		dispc.irq_callback(dispc.irq_callback_data);
 
-	dispc_write_reg(DISPC_IRQSTATUS, stat);
-
 	return IRQ_HANDLED;
 }
 
@@ -1355,6 +1358,7 @@
 	int tmo = 10000;
 	int skip_init = 0;
 	int i;
+	int type;
 
 	memset(&dispc, 0, sizeof(dispc));
 
@@ -1422,8 +1426,14 @@
 		goto fail1;
 	}
 
-	/* L3 firewall setting: enable access to OCM RAM */
-	__raw_writel(0x402000b0, io_p2v(0x680050a0));
+	/* L3 firewall setting: enable DMA access to OCM SRAM */
+	/* set only if GP OMAP */
+
+	type = __raw_readl(VA_CONTROL_STAT) & TYPE_MASK;
+
+	if(type == GP_DEVICE) {
+		__raw_writel(0x402000b0, io_p2v(0x680050a0)); 
+	}
 
 	if ((r = alloc_palette_ram()) < 0)
 		goto fail2;
diff -ruN linux-omap-2.6/drivers/video/omap/Kconfig maemo_src/drivers/video/omap/Kconfig
--- linux-omap-2.6/drivers/video/omap/Kconfig	2011-02-06 20:17:25.946666606 -0500
+++ maemo_src/drivers/video/omap/Kconfig	2011-02-06 20:12:10.743333274 -0500
@@ -72,4 +72,7 @@
           answer yes. Answer no if you have a dedicated video
           memory, or don't use any of the accelerated features.
 
+config FB_OMAP_PAUSING
+	bool "Support pausing OMAP frame buffer transfers"
+	depends on FB_OMAP
 
diff -ruN linux-omap-2.6/drivers/video/omap/lcd_mipid.c maemo_src/drivers/video/omap/lcd_mipid.c
--- linux-omap-2.6/drivers/video/omap/lcd_mipid.c	2011-02-06 20:17:25.983333273 -0500
+++ maemo_src/drivers/video/omap/lcd_mipid.c	2011-02-06 20:12:10.696666604 -0500
@@ -69,6 +69,9 @@
 	struct workqueue_struct	*esd_wq;
 	struct delayed_work	esd_work;
 	void			(*esd_check)(struct mipid_device *m);
+
+	void			(*shutdown)(struct mipid_platform_data *pdata);
+	struct mipid_platform_data *pdata;
 };
 
 static void mipid_transfer(struct mipid_device *md, int cmd, const u8 *wbuf,
@@ -468,7 +471,7 @@
 		dev_err(&md->spi->dev, "can't create ESD workqueue\n");
 		return -ENOMEM;
 	}
-	INIT_DELAYED_WORK(&md->esd_work, mipid_esd_work);
+	INIT_DELAYED_WORK_DEFERRABLE(&md->esd_work, mipid_esd_work);
 	mutex_init(&md->mutex);
 
 	md->enabled = panel_enabled(md);
@@ -547,6 +550,8 @@
 
 	md->revision = md->display_id[1];
 	md->panel.data_lines = pdata->data_lines;
+	md->shutdown = pdata->shutdown;
+	md->pdata = pdata;
 	pr_info("omapfb: %s rev %02x LCD detected\n",
 			md->panel.name, md->revision);
 
@@ -588,6 +593,15 @@
 	return 0;
 }
 
+static void mipid_spi_shutdown(struct spi_device *spi)
+{
+	struct mipid_device *md = dev_get_drvdata(&spi->dev);
+
+	set_sleep_mode(md, 1);
+	if (md->shutdown)
+		md->shutdown(md->pdata);
+}
+
 static struct spi_driver mipid_spi_driver = {
 	.driver = {
 		.name	= MIPID_MODULE_NAME,
@@ -596,6 +610,7 @@
 	},
 	.probe	= mipid_spi_probe,
 	.remove	= __devexit_p(mipid_spi_remove),
+	.shutdown = mipid_spi_shutdown,
 };
 
 static int mipid_drv_init(void)
diff -ruN linux-omap-2.6/drivers/video/omap/omapfb_main.c maemo_src/drivers/video/omap/omapfb_main.c
--- linux-omap-2.6/drivers/video/omap/omapfb_main.c	2011-02-06 20:17:26.023333274 -0500
+++ maemo_src/drivers/video/omap/omapfb_main.c	2011-02-06 20:12:10.743333274 -0500
@@ -124,6 +124,37 @@
 	mutex_unlock(&fbdev->rqueue_mutex);
 }
 
+#ifdef CONFIG_FB_OMAP_PAUSING
+/*
+ * OMAPFB_DVFS_PAUSE and OMAPFB_DVFS_CONTINUE should be paired in the
+ * caller function to keep track of the consistency of omapfb state
+ * and locks.
+ */
+void omapfb_pause_set(int state)
+{
+	static enum omapfb_update_mode saved_mode;
+
+	if (!omapfb_dev)
+		return;
+
+	switch (state) {
+	case OMAPFB_DVFS_PAUSE:
+		omapfb_rqueue_lock(omapfb_dev);
+		saved_mode = omapfb_dev->ctrl->get_update_mode();
+		omapfb_dev->ctrl->set_update_mode(OMAPFB_UPDATE_DISABLED);
+		break;
+	case OMAPFB_DVFS_CONTINUE:
+		omapfb_dev->ctrl->set_update_mode(saved_mode);
+		if (omapfb_dev->ctrl->freq_changed) omapfb_dev->ctrl->freq_changed();
+		omapfb_rqueue_unlock(omapfb_dev);
+		break;
+	default:
+		BUG();
+		break;
+	}
+}
+#endif
+
 /*
  * ---------------------------------------------------------------------------
  * LCD controller and LCD DMA
@@ -756,6 +787,10 @@
 	win.y = 0;
 	win.width = fbi->var.xres;
 	win.height = fbi->var.yres;
+	win.out_x = 0;
+	win.out_y = 0;
+	win.out_width = fbi->var.xres;
+	win.out_height = fbi->var.yres;
 	win.format = 0;
 
 	omapfb_rqueue_lock(fbdev);
@@ -1027,6 +1062,13 @@
 {
 	omapfb_rqueue_lock(fbdev);
 	*(u16 *)fbdev->mem_desc.region[0].vaddr = pixval;
+
+	/*
+	 * FIXME. Hot fix. It appears that the first pixel read by
+	 * MIPID_CMD_READ_RED/GREEN/BLUE is y=0, x=1 pixel in framebuffer.
+	 */
+	((u16 *)fbdev->mem_desc.region[0].vaddr)[1] = pixval;
+
 	if (fbdev->ctrl->get_update_mode() == OMAPFB_MANUAL_UPDATE) {
 		struct omapfb_update_window win;
 
diff -ruN linux-omap-2.6/drivers/video/omap/rfbi.c maemo_src/drivers/video/omap/rfbi.c
--- linux-omap-2.6/drivers/video/omap/rfbi.c	2011-02-06 20:17:26.023333274 -0500
+++ maemo_src/drivers/video/omap/rfbi.c	2011-02-06 20:12:10.743333274 -0500
@@ -189,7 +189,7 @@
 #ifdef OMAP_RFBI_RATE_LIMIT
 static unsigned long rfbi_get_max_tx_rate(void)
 {
-	unsigned long	l4_rate, dss1_rate;
+	unsigned long	l4_rate_hz, l4_rate, dss1_rate;
 	int		min_l4_ticks = 0;
 	int		i;
 
@@ -202,14 +202,26 @@
 		unsigned long dss1_clk;		/* HZ */
 		unsigned long min_l4_ticks;
 	} ftab[] = {
+#if 0
 		{ 55,	132,	7, },		/* 7.86 MPix/s */
 		{ 110,	110,	12, },		/* 9.16 MPix/s */
 		{ 110,	132,	10, },		/* 11   Mpix/s */
 		{ 120,	120,	10, },		/* 12   Mpix/s */
 		{ 133,	133,	10, },		/* 13.3 Mpix/s */
+#else
+	/* 'min_l4_ticks' values that actually correspond to N800/N810 OP modes,
+	 * data is obtained in an "experimental" way by benchmarking actual
+	 * RFBI transfers
+	 */
+		{ 133,	133,	12, },		/* OP0 (11.08 MPix/s) */
+		{ 110,	110,	12, },		/* OP1 (9.16 MPix/s) */
+		{ 44,	88,	8, },		/* OP2 (5.50 Mpix/s) */
+		{ 27,	110,	6, },		/* OP3 (4.58 Mpix/s) */
+#endif
 	};
 
-	l4_rate = rfbi.l4_khz / 1000;
+	l4_rate_hz = clk_get_rate(rfbi.dss_ick);
+	l4_rate = l4_rate_hz / 1000000;
 	dss1_rate = clk_get_rate(rfbi.dss1_fck) / 1000000;
 
 	for (i = 0; i < ARRAY_SIZE(ftab); i++) {
@@ -228,10 +240,11 @@
 		 * tearing synchronisation.
 		 */
 		dev_err(rfbi.fbdev->dev,
-			"can't determine maximum RFBI transfer rate\n");
-		return rfbi.l4_khz * 1000;
+			"can't determine maximum RFBI transfer rate "
+			"(%lu, %lu)\n", l4_rate, dss1_rate);
+		return l4_rate_hz;
 	}
-	return rfbi.l4_khz * 1000 / min_l4_ticks;
+	return l4_rate_hz / min_l4_ticks;
 }
 #else
 static int rfbi_get_max_tx_rate(void)
diff -ruN linux-omap-2.6/fs/exec.c maemo_src/fs/exec.c
--- linux-omap-2.6/fs/exec.c	2011-02-06 19:45:02.533333273 -0500
+++ maemo_src/fs/exec.c	2007-10-02 03:09:32.000000000 -0400
@@ -1510,8 +1510,22 @@
 	ispipe = format_corename(corename, core_pattern, signr);
 	unlock_kernel();
  	if (ispipe) {
+		/* pass process information in environment */
+		char env_exe[64];
+		char env_pid[16], env_sig[16];
+		char env_uid[16], env_gid[16];
+		char *envp[] = { env_exe,
+				 env_pid, env_sig,
+				 env_uid, env_gid,
+				 NULL };
+		snprintf(env_exe, sizeof(env_exe), "CORE_EXE=%s", current->comm);
+		snprintf(env_pid, sizeof(env_pid), "CORE_PID=%d", current->tgid);
+		snprintf(env_sig, sizeof(env_sig), "CORE_SIG=%ld", signr);
+		snprintf(env_uid, sizeof(env_uid), "CORE_UID=%u", current->uid);
+		snprintf(env_gid, sizeof(env_gid), "CORE_GID=%u", current->gid);
+
 		/* SIGPIPE can happen, but it's just never processed */
- 		if(call_usermodehelper_pipe(corename+1, NULL, NULL, &file)) {
+		if(call_usermodehelper_pipe(corename+1, NULL, envp, &file)) {
  			printk(KERN_INFO "Core dump to %s pipe failed\n",
 			       corename);
  			goto fail_unlock;
diff -ruN linux-omap-2.6/fs/fat/inode.c maemo_src/fs/fat/inode.c
--- linux-omap-2.6/fs/fat/inode.c	2011-02-06 19:45:02.686666606 -0500
+++ maemo_src/fs/fat/inode.c	2011-02-06 20:12:10.069999937 -0500
@@ -825,6 +825,8 @@
 	}
 	if (opts->name_check != 'n')
 		seq_printf(m, ",check=%c", opts->name_check);
+	if (opts->usefree)
+		seq_puts(m, ",usefree");
 	if (opts->quiet)
 		seq_puts(m, ",quiet");
 	if (opts->showexec)
@@ -850,7 +852,7 @@
 
 enum {
 	Opt_check_n, Opt_check_r, Opt_check_s, Opt_uid, Opt_gid,
-	Opt_umask, Opt_dmask, Opt_fmask, Opt_codepage, Opt_nocase,
+	Opt_umask, Opt_dmask, Opt_fmask, Opt_codepage, Opt_usefree, Opt_nocase,
 	Opt_quiet, Opt_showexec, Opt_debug, Opt_immutable,
 	Opt_dots, Opt_nodots,
 	Opt_charset, Opt_shortname_lower, Opt_shortname_win95,
@@ -872,6 +874,7 @@
 	{Opt_dmask, "dmask=%o"},
 	{Opt_fmask, "fmask=%o"},
 	{Opt_codepage, "codepage=%u"},
+	{Opt_usefree, "usefree"},
 	{Opt_nocase, "nocase"},
 	{Opt_quiet, "quiet"},
 	{Opt_showexec, "showexec"},
@@ -951,7 +954,7 @@
 	opts->quiet = opts->showexec = opts->sys_immutable = opts->dotsOK =  0;
 	opts->utf8 = opts->unicode_xlate = 0;
 	opts->numtail = 1;
-	opts->nocase = 0;
+	opts->usefree = opts->nocase = 0;
 	*debug = 0;
 
 	if (!options)
@@ -979,6 +982,9 @@
 		case Opt_check_n:
 			opts->name_check = 'n';
 			break;
+		case Opt_usefree:
+			opts->usefree = 1;
+			break;
 		case Opt_nocase:
 			if (!is_vfat)
 				opts->nocase = 1;
@@ -1306,7 +1312,9 @@
 			       le32_to_cpu(fsinfo->signature2),
 			       sbi->fsinfo_sector);
 		} else {
-			sbi->free_clusters = le32_to_cpu(fsinfo->free_clusters);
+			if (sbi->options.usefree)
+				sbi->free_clusters =
+					le32_to_cpu(fsinfo->free_clusters);
 			sbi->prev_free = le32_to_cpu(fsinfo->next_cluster);
 		}
 
diff -ruN linux-omap-2.6/fs/jffs2/background.c maemo_src/fs/jffs2/background.c
--- linux-omap-2.6/fs/jffs2/background.c	2011-02-06 19:45:03.136666607 -0500
+++ maemo_src/fs/jffs2/background.c	2007-10-02 03:09:32.000000000 -0400
@@ -25,8 +25,8 @@
 void jffs2_garbage_collect_trigger(struct jffs2_sb_info *c)
 {
 	spin_lock(&c->erase_completion_lock);
-        if (c->gc_task && jffs2_thread_should_wake(c))
-                send_sig(SIGHUP, c->gc_task, 1);
+	if (c->gc_task && jffs2_thread_should_wake(c))
+		send_sig(SIGHUP, c->gc_task, 1);
 	spin_unlock(&c->erase_completion_lock);
 }
 
@@ -85,7 +85,7 @@
 
 	for (;;) {
 		allow_signal(SIGHUP);
-
+	again:
 		if (!jffs2_thread_should_wake(c)) {
 			set_current_state (TASK_INTERRUPTIBLE);
 			D1(printk(KERN_DEBUG "jffs2_garbage_collect_thread sleeping...\n"));
@@ -96,9 +96,6 @@
 			schedule();
 		}
 
-		if (try_to_freeze())
-			continue;
-
 		/* This thread is purely an optimisation. But if it runs when
 		   other things could be running, it actually makes things a
 		   lot worse. Use yield() and put it at the back of the runqueue
@@ -113,6 +110,9 @@
 			siginfo_t info;
 			unsigned long signr;
 
+			if (try_to_freeze())
+				goto again;
+
 			signr = dequeue_signal_lock(current, &current->blocked, &info);
 
 			switch(signr) {
diff -ruN linux-omap-2.6/fs/jffs2/compr.c maemo_src/fs/jffs2/compr.c
--- linux-omap-2.6/fs/jffs2/compr.c	2011-02-06 19:45:03.136666607 -0500
+++ maemo_src/fs/jffs2/compr.c	2007-10-02 03:09:32.000000000 -0400
@@ -13,6 +13,7 @@
  *
  */
 
+#include <linux/kobject.h>
 #include "compr.h"
 
 static DEFINE_SPINLOCK(jffs2_compressor_list_lock);
@@ -26,6 +27,34 @@
 /* Statistics for blocks stored without compression */
 static uint32_t none_stat_compr_blocks=0,none_stat_decompr_blocks=0,none_stat_compr_size=0;
 
+
+/*
+ * Return 1 to use this compression
+ */
+static int jffs2_is_best_compression(struct jffs2_compressor *this,
+		struct jffs2_compressor *best, uint32_t size, uint32_t bestsize)
+{
+	switch (jffs2_compression_mode) {
+		case JFFS2_COMPR_MODE_SIZE:
+			if (bestsize > size)
+				return 1;
+			return 0;
+		case JFFS2_COMPR_MODE_FAVOURLZO:
+			if ((this->compr == JFFS2_COMPR_LZO) && (bestsize > size))
+				return 1;
+			if ((best->compr != JFFS2_COMPR_LZO) && (bestsize > size))
+				return 1;
+			if ((this->compr == JFFS2_COMPR_LZO) && (bestsize > (size * FAVOUR_LZO_PERCENT / 100)))
+				return 1;
+			if ((bestsize * FAVOUR_LZO_PERCENT / 100) > size)
+				return 1;
+
+			return 0;
+	}
+	/* Shouldn't happen */
+	return 0;
+}
+
 /* jffs2_compress:
  * @data: Pointer to uncompressed data
  * @cdata: Pointer to returned pointer to buffer for compressed data
@@ -91,6 +120,7 @@
                 if (ret == JFFS2_COMPR_NONE) kfree(output_buf);
                 break;
         case JFFS2_COMPR_MODE_SIZE:
+        case JFFS2_COMPR_MODE_FAVOURLZO:
                 orig_slen = *datalen;
                 orig_dlen = *cdatalen;
                 spin_lock(&jffs2_compressor_list_lock);
@@ -99,7 +129,7 @@
                         if ((!this->compress)||(this->disabled))
                                 continue;
                         /* Allocating memory for output buffer if necessary */
-                        if ((this->compr_buf_size<orig_dlen)&&(this->compr_buf)) {
+                        if ((this->compr_buf_size<orig_slen)&&(this->compr_buf)) {
                                 spin_unlock(&jffs2_compressor_list_lock);
                                 kfree(this->compr_buf);
                                 spin_lock(&jffs2_compressor_list_lock);
@@ -108,15 +138,15 @@
                         }
                         if (!this->compr_buf) {
                                 spin_unlock(&jffs2_compressor_list_lock);
-                                tmp_buf = kmalloc(orig_dlen,GFP_KERNEL);
+                                tmp_buf = kmalloc(orig_slen,GFP_KERNEL);
                                 spin_lock(&jffs2_compressor_list_lock);
                                 if (!tmp_buf) {
-                                        printk(KERN_WARNING "JFFS2: No memory for compressor allocation. (%d bytes)\n",orig_dlen);
+                                        printk(KERN_WARNING "JFFS2: No memory for compressor allocation. (%d bytes)\n",orig_slen);
                                         continue;
                                 }
                                 else {
                                         this->compr_buf = tmp_buf;
-                                        this->compr_buf_size = orig_dlen;
+                                        this->compr_buf_size = orig_slen;
                                 }
                         }
                         this->usecount++;
@@ -127,7 +157,8 @@
                         spin_lock(&jffs2_compressor_list_lock);
                         this->usecount--;
                         if (!compr_ret) {
-                                if ((!best_dlen)||(best_dlen>*cdatalen)) {
+				if (((!best_dlen) || jffs2_is_best_compression(this, best, *cdatalen, best_dlen))
+						&& (*cdatalen < *datalen)) {
                                         best_dlen = *cdatalen;
                                         best_slen = *datalen;
                                         best = this;
@@ -167,8 +198,8 @@
 		     uint16_t comprtype, unsigned char *cdata_in,
 		     unsigned char *data_out, uint32_t cdatalen, uint32_t datalen)
 {
-        struct jffs2_compressor *this;
-        int ret;
+	struct jffs2_compressor *this;
+	int ret;
 
 	/* Older code had a bug where it would write non-zero 'usercompr'
 	   fields. Deal with it. */
@@ -179,32 +210,32 @@
 	case JFFS2_COMPR_NONE:
 		/* This should be special-cased elsewhere, but we might as well deal with it */
 		memcpy(data_out, cdata_in, datalen);
-                none_stat_decompr_blocks++;
+		none_stat_decompr_blocks++;
 		break;
 	case JFFS2_COMPR_ZERO:
 		memset(data_out, 0, datalen);
 		break;
 	default:
-                spin_lock(&jffs2_compressor_list_lock);
-                list_for_each_entry(this, &jffs2_compressor_list, list) {
-                        if (comprtype == this->compr) {
-                                this->usecount++;
-                                spin_unlock(&jffs2_compressor_list_lock);
-                                ret = this->decompress(cdata_in, data_out, cdatalen, datalen, NULL);
-                                spin_lock(&jffs2_compressor_list_lock);
-                                if (ret) {
-                                        printk(KERN_WARNING "Decompressor \"%s\" returned %d\n", this->name, ret);
-                                }
-                                else {
-                                        this->stat_decompr_blocks++;
-                                }
-                                this->usecount--;
-                                spin_unlock(&jffs2_compressor_list_lock);
-                                return ret;
-                        }
-                }
+		spin_lock(&jffs2_compressor_list_lock);
+		list_for_each_entry(this, &jffs2_compressor_list, list) {
+			if (comprtype == this->compr) {
+				this->usecount++;
+				spin_unlock(&jffs2_compressor_list_lock);
+				ret = this->decompress(cdata_in, data_out, cdatalen, datalen, NULL);
+				spin_lock(&jffs2_compressor_list_lock);
+				if (ret) {
+					printk(KERN_WARNING "Decompressor \"%s\" returned %d\n", this->name, ret);
+				}
+				else {
+					this->stat_decompr_blocks++;
+				}
+				this->usecount--;
+				spin_unlock(&jffs2_compressor_list_lock);
+				return ret;
+			}
+		}
 		printk(KERN_WARNING "JFFS2 compression type 0x%02x not available.\n", comprtype);
-                spin_unlock(&jffs2_compressor_list_lock);
+		spin_unlock(&jffs2_compressor_list_lock);
 		return -EIO;
 	}
 	return 0;
@@ -406,6 +437,46 @@
 
 #endif
 
+#ifdef CONFIG_JFFS2_SYSFS
+
+char *jffs2_get_compression_mode_name(void)
+{
+        switch (jffs2_compression_mode) {
+        case JFFS2_COMPR_MODE_NONE:
+                return "none";
+        case JFFS2_COMPR_MODE_PRIORITY:
+                return "priority";
+        case JFFS2_COMPR_MODE_SIZE:
+                return "size";
+	case JFFS2_COMPR_MODE_FAVOURLZO:
+		return "favourlzo";
+        }
+        return "unkown";
+}
+
+int jffs2_set_compression_mode_name(const char *name)
+{
+        if (!strncmp("none", name, 4)) {
+                jffs2_compression_mode = JFFS2_COMPR_MODE_NONE;
+                return 0;
+        }
+        if (!strncmp("priority", name, 8)) {
+                jffs2_compression_mode = JFFS2_COMPR_MODE_PRIORITY;
+                return 0;
+        }
+        if (!strncmp("size", name, 4)) {
+                jffs2_compression_mode = JFFS2_COMPR_MODE_SIZE;
+                return 0;
+        }
+	if (!strncmp("favourlzo", name, 9)) {
+		jffs2_compression_mode = JFFS2_COMPR_MODE_FAVOURLZO;
+		return 0;
+	}
+        return -EINVAL;
+}
+
+#endif
+
 void jffs2_free_comprbuf(unsigned char *comprbuf, unsigned char *orig)
 {
         if (orig != comprbuf)
@@ -425,6 +496,9 @@
         jffs2_rubinmips_init();
         jffs2_dynrubin_init();
 #endif
+#ifdef CONFIG_JFFS2_LZO
+        jffs2_lzo_init();
+#endif
 /* Setting default compression mode */
 #ifdef CONFIG_JFFS2_CMODE_NONE
         jffs2_compression_mode = JFFS2_COMPR_MODE_NONE;
@@ -434,15 +508,23 @@
         jffs2_compression_mode = JFFS2_COMPR_MODE_SIZE;
         D1(printk(KERN_INFO "JFFS2: default compression mode: size\n");)
 #else
+#ifdef CONFIG_JFFS2_CMODE_FAVOURLZO
+        jffs2_compression_mode = JFFS2_COMPR_MODE_FAVOURLZO;
+        D1(printk(KERN_INFO "JFFS2: default compression mode: favourlzo\n");)
+#else
         D1(printk(KERN_INFO "JFFS2: default compression mode: priority\n");)
 #endif
 #endif
+#endif
         return 0;
 }
 
 int jffs2_compressors_exit(void)
 {
 /* Unregistering compressors */
+#ifdef CONFIG_JFFS2_LZO
+        jffs2_lzo_exit();
+#endif
 #ifdef CONFIG_JFFS2_RUBIN
         jffs2_dynrubin_exit();
         jffs2_rubinmips_exit();
diff -ruN linux-omap-2.6/fs/jffs2/compr.h maemo_src/fs/jffs2/compr.h
--- linux-omap-2.6/fs/jffs2/compr.h	2011-02-06 19:45:03.136666607 -0500
+++ maemo_src/fs/jffs2/compr.h	2007-10-02 03:09:32.000000000 -0400
@@ -30,9 +30,10 @@
 #define JFFS2_RUBINMIPS_PRIORITY 10
 #define JFFS2_DYNRUBIN_PRIORITY  20
 #define JFFS2_LZARI_PRIORITY     30
-#define JFFS2_LZO_PRIORITY       40
 #define JFFS2_RTIME_PRIORITY     50
 #define JFFS2_ZLIB_PRIORITY      60
+#define JFFS2_LZO_PRIORITY       80
+
 
 #define JFFS2_RUBINMIPS_DISABLED /* RUBINs will be used only */
 #define JFFS2_DYNRUBIN_DISABLED  /*        for decompression */
@@ -40,6 +41,9 @@
 #define JFFS2_COMPR_MODE_NONE       0
 #define JFFS2_COMPR_MODE_PRIORITY   1
 #define JFFS2_COMPR_MODE_SIZE       2
+#define JFFS2_COMPR_MODE_FAVOURLZO  3
+
+#define FAVOUR_LZO_PERCENT 80
 
 struct jffs2_compressor {
         struct list_head list;
@@ -67,12 +71,12 @@
 int jffs2_compressors_exit(void);
 
 uint16_t jffs2_compress(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
-                             unsigned char *data_in, unsigned char **cpage_out,
-                             uint32_t *datalen, uint32_t *cdatalen);
+			unsigned char *data_in, unsigned char **cpage_out,
+			uint32_t *datalen, uint32_t *cdatalen);
 
 int jffs2_decompress(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
-                     uint16_t comprtype, unsigned char *cdata_in,
-                     unsigned char *data_out, uint32_t cdatalen, uint32_t datalen);
+		     uint16_t comprtype, unsigned char *cdata_in,
+		     unsigned char *data_out, uint32_t cdatalen, uint32_t datalen);
 
 void jffs2_free_comprbuf(unsigned char *comprbuf, unsigned char *orig);
 
@@ -86,6 +90,12 @@
 char *jffs2_stats(void);
 #endif
 
+#ifdef CONFIG_JFFS2_SYSFS
+int jffs2_set_compression_mode_name(const char *mode_name);
+char *jffs2_get_compression_mode_name(void);
+#endif
+
+
 /* Compressor modules */
 /* These functions will be called by jffs2_compressors_init/exit */
 
@@ -103,5 +113,9 @@
 int jffs2_zlib_init(void);
 void jffs2_zlib_exit(void);
 #endif
+#ifdef CONFIG_JFFS2_LZO
+int jffs2_lzo_init(void);
+void jffs2_lzo_exit(void);
+#endif
 
 #endif /* __JFFS2_COMPR_H__ */
diff -ruN linux-omap-2.6/fs/jffs2/compr_lzo.c maemo_src/fs/jffs2/compr_lzo.c
--- linux-omap-2.6/fs/jffs2/compr_lzo.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/fs/jffs2/compr_lzo.c	2007-10-02 03:09:32.000000000 -0400
@@ -0,0 +1,112 @@
+/*
+ * JFFS2 LZO Compression Interface
+ *
+ * Copyright (C) 2007 Nokia Corporation. All rights reserved.
+ *
+ * Author: Richard Purdie <rpurdie@openedhand.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * For licensing information, see the file 'LICENCE' in this directory.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/init.h>
+#include <linux/lzo.h>
+#include "compr.h"
+
+static void *lzo_mem;
+static void *lzo_compress_buf;
+static DEFINE_MUTEX(deflate_mutex);
+
+static void free_workspace(void)
+{
+	vfree(lzo_mem);
+	vfree(lzo_compress_buf);
+}
+
+static int __init alloc_workspace(void)
+{
+	lzo_mem = vmalloc(LZO1X_MEM_COMPRESS);
+	lzo_compress_buf = vmalloc(lzo1x_worst_compress(PAGE_SIZE));
+
+	if (!lzo_mem || !lzo_compress_buf) {
+		printk(KERN_WARNING "Failed to allocate lzo deflate workspace\n");
+		free_workspace();
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int jffs2_lzo_compress(unsigned char *data_in, unsigned char *cpage_out,
+			      uint32_t *sourcelen, uint32_t *dstlen, void *model)
+{
+	size_t compress_size;
+	int ret;
+
+	mutex_lock(&deflate_mutex);
+	ret = lzo1x_1_compress(data_in, *sourcelen, lzo_compress_buf, &compress_size, lzo_mem);
+	mutex_unlock(&deflate_mutex);
+
+	if (ret != LZO_E_OK)
+		return -1;
+
+	if (compress_size > *dstlen)
+		return -1;
+
+	memcpy(cpage_out, lzo_compress_buf, compress_size);
+	*dstlen = compress_size;
+
+	return 0;
+}
+
+static int jffs2_lzo_decompress(unsigned char *data_in, unsigned char *cpage_out,
+				 uint32_t srclen, uint32_t destlen, void *model)
+{
+	size_t dl = destlen;
+	int ret;
+
+	ret = lzo1x_decompress_safe(data_in, srclen, cpage_out, &dl);
+
+	if (ret != LZO_E_OK || dl != destlen)
+		return -1;
+
+	return 0;
+}
+
+static struct jffs2_compressor jffs2_lzo_comp = {
+	.priority = JFFS2_LZO_PRIORITY,
+	.name = "lzo",
+	.compr = JFFS2_COMPR_LZO,
+	.compress = &jffs2_lzo_compress,
+	.decompress = &jffs2_lzo_decompress,
+	.disabled = 0,
+};
+
+int __init jffs2_lzo_init(void)
+{
+	int ret;
+
+	ret = alloc_workspace();
+	if (ret < 0)
+		return ret;
+
+	ret = jffs2_register_compressor(&jffs2_lzo_comp);
+	if (ret)
+		free_workspace();
+
+	return ret;
+}
+
+void jffs2_lzo_exit(void)
+{
+	jffs2_unregister_compressor(&jffs2_lzo_comp);
+	free_workspace();
+}
diff -ruN linux-omap-2.6/fs/jffs2/compr_rtime.c maemo_src/fs/jffs2/compr_rtime.c
--- linux-omap-2.6/fs/jffs2/compr_rtime.c	2011-02-06 19:45:03.136666607 -0500
+++ maemo_src/fs/jffs2/compr_rtime.c	2007-10-02 03:09:32.000000000 -0400
@@ -105,7 +105,7 @@
 			}
 		}
 	}
-        return 0;
+	return 0;
 }
 
 static struct jffs2_compressor jffs2_rtime_comp = {
diff -ruN linux-omap-2.6/fs/jffs2/compr_rubin.c maemo_src/fs/jffs2/compr_rubin.c
--- linux-omap-2.6/fs/jffs2/compr_rubin.c	2011-02-06 19:45:03.136666607 -0500
+++ maemo_src/fs/jffs2/compr_rubin.c	2007-10-02 03:09:32.000000000 -0400
@@ -313,7 +313,7 @@
 				      void *model)
 {
 	rubin_do_decompress(BIT_DIVIDER_MIPS, bits_mips, data_in, cpage_out, sourcelen, dstlen);
-        return 0;
+	return 0;
 }
 
 static int jffs2_dynrubin_decompress(unsigned char *data_in,
@@ -328,7 +328,7 @@
 		bits[c] = data_in[c];
 
 	rubin_do_decompress(256, bits, data_in+8, cpage_out, sourcelen-8, dstlen);
-        return 0;
+	return 0;
 }
 
 static struct jffs2_compressor jffs2_rubinmips_comp = {
diff -ruN linux-omap-2.6/fs/jffs2/compr_zlib.c maemo_src/fs/jffs2/compr_zlib.c
--- linux-omap-2.6/fs/jffs2/compr_zlib.c	2011-02-06 19:45:03.139999940 -0500
+++ maemo_src/fs/jffs2/compr_zlib.c	2007-10-02 03:09:32.000000000 -0400
@@ -183,7 +183,7 @@
 	}
 	zlib_inflateEnd(&inf_strm);
 	mutex_unlock(&inflate_mutex);
-        return 0;
+	return 0;
 }
 
 static struct jffs2_compressor jffs2_zlib_comp = {
@@ -205,11 +205,11 @@
 
     ret = alloc_workspaces();
     if (ret)
-        return ret;
+	    return ret;
 
     ret = jffs2_register_compressor(&jffs2_zlib_comp);
     if (ret)
-        free_workspaces();
+	    free_workspaces();
 
     return ret;
 }
diff -ruN linux-omap-2.6/fs/jffs2/dir.c maemo_src/fs/jffs2/dir.c
--- linux-omap-2.6/fs/jffs2/dir.c	2011-02-06 19:45:03.139999940 -0500
+++ maemo_src/fs/jffs2/dir.c	2007-10-02 03:09:32.000000000 -0400
@@ -34,7 +34,7 @@
 static int jffs2_rmdir (struct inode *,struct dentry *);
 static int jffs2_mknod (struct inode *,struct dentry *,int,dev_t);
 static int jffs2_rename (struct inode *, struct dentry *,
-                        struct inode *, struct dentry *);
+			 struct inode *, struct dentry *);
 
 const struct file_operations jffs2_dir_operations =
 {
@@ -772,7 +772,7 @@
 }
 
 static int jffs2_rename (struct inode *old_dir_i, struct dentry *old_dentry,
-                        struct inode *new_dir_i, struct dentry *new_dentry)
+			 struct inode *new_dir_i, struct dentry *new_dentry)
 {
 	int ret;
 	struct jffs2_sb_info *c = JFFS2_SB_INFO(old_dir_i->i_sb);
diff -ruN linux-omap-2.6/fs/jffs2/erase.c maemo_src/fs/jffs2/erase.c
--- linux-omap-2.6/fs/jffs2/erase.c	2011-02-06 19:45:03.139999940 -0500
+++ maemo_src/fs/jffs2/erase.c	2011-02-06 20:12:10.153333273 -0500
@@ -40,8 +40,8 @@
 #ifdef __ECOS
        ret = jffs2_flash_erase(c, jeb);
        if (!ret) {
-               jffs2_erase_succeeded(c, jeb);
-               return;
+	       jffs2_erase_succeeded(c, jeb);
+	       return;
        }
        bad_offset = jeb->offset;
 #else /* Linux */
@@ -144,7 +144,7 @@
 		}
 
 		/* Be nice */
-		cond_resched();
+		yield();
 		spin_lock(&c->erase_completion_lock);
 	}
 
@@ -333,7 +333,7 @@
 
 		*bad_offset = ofs;
 
-		ret = jffs2_flash_read(c, ofs, readlen, &retlen, ebuf);
+		ret = c->mtd->read(c->mtd, ofs, readlen, &retlen, ebuf);
 		if (ret) {
 			printk(KERN_WARNING "Read of newly-erased block at 0x%08x failed: %d. Putting on bad_list\n", ofs, ret);
 			goto fail;
diff -ruN linux-omap-2.6/fs/jffs2/fs.c maemo_src/fs/jffs2/fs.c
--- linux-omap-2.6/fs/jffs2/fs.c	2011-02-06 19:45:03.143333273 -0500
+++ maemo_src/fs/jffs2/fs.c	2007-10-02 03:09:32.000000000 -0400
@@ -361,10 +361,18 @@
 int jffs2_remount_fs (struct super_block *sb, int *flags, char *data)
 {
 	struct jffs2_sb_info *c = JFFS2_SB_INFO(sb);
+	int ret;
 
 	if (c->flags & JFFS2_SB_FLAG_RO && !(sb->s_flags & MS_RDONLY))
 		return -EROFS;
 
+	jffs2_rp_free(c);
+
+	/* Re-parse mount options */
+	ret = jffs2_rp_parse_options(sb, data);
+	if (ret)
+		return ret;
+
 	/* We stop if it was running, then restart if it needs to.
 	   This also catches the case where it was stopped and this
 	   is just a remount to restart it.
diff -ruN linux-omap-2.6/fs/jffs2/gc.c maemo_src/fs/jffs2/gc.c
--- linux-omap-2.6/fs/jffs2/gc.c	2011-02-06 19:45:03.143333273 -0500
+++ maemo_src/fs/jffs2/gc.c	2007-10-02 03:09:32.000000000 -0400
@@ -144,7 +144,8 @@
 			       c->unchecked_size);
 			jffs2_dbg_dump_block_lists_nolock(c);
 			spin_unlock(&c->erase_completion_lock);
-			BUG();
+			up(&c->alloc_sem);
+			return -ENOSPC;
 		}
 
 		spin_unlock(&c->erase_completion_lock);
@@ -557,7 +558,7 @@
 
 	node = kmalloc(rawlen, GFP_KERNEL);
 	if (!node)
-               return -ENOMEM;
+		return -ENOMEM;
 
 	ret = jffs2_flash_read(c, ref_offset(raw), rawlen, &retlen, (char *)node);
 	if (!ret && retlen != rawlen)
@@ -625,7 +626,7 @@
 
 	if (ret || (retlen != rawlen)) {
 		printk(KERN_NOTICE "Write of %d bytes at 0x%08x failed. returned %d, retlen %zd\n",
-                       rawlen, phys_ofs, ret, retlen);
+		       rawlen, phys_ofs, ret, retlen);
 		if (retlen) {
 			jffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, rawlen, NULL);
 		} else {
diff -ruN linux-omap-2.6/fs/jffs2/jffs2_fs_sb.h maemo_src/fs/jffs2/jffs2_fs_sb.h
--- linux-omap-2.6/fs/jffs2/jffs2_fs_sb.h	2011-02-06 19:45:03.143333273 -0500
+++ maemo_src/fs/jffs2/jffs2_fs_sb.h	2007-10-02 03:09:32.000000000 -0400
@@ -18,6 +18,7 @@
 #define JFFS2_SB_FLAG_BUILDING 4 /* File system building is in progress */
 
 struct jffs2_inodirty;
+struct jffs2_rp_id;
 
 /* A struct for the overall file system control.  Pointers to
    jffs2_sb_info structs are named `c' in the source code.
@@ -97,6 +98,16 @@
 
 	uint32_t wbuf_pagesize; /* 0 for NOR and other flashes with no wbuf */
 
+	/* The size of the reserved pool. The reserved pool is the JFFS2 flash
+	 * space which may only be used by users with certain UID or GID and
+	 * cannot be used by the other users. This is implemented simply by
+	 * means of not allowing the latter users to write to the file system
+	 * if the amount if the available space is less then 'rp_size'. */
+	unsigned int rp_size;
+
+	/* The list of IDs which may use the reserved pool */
+	struct jffs2_rp_id *rp_ids;
+
 #ifdef CONFIG_JFFS2_FS_WRITEBUFFER
 	unsigned char *wbuf; /* Write-behind buffer for NAND flash */
 	uint32_t wbuf_ofs;
diff -ruN linux-omap-2.6/fs/jffs2/Makefile maemo_src/fs/jffs2/Makefile
--- linux-omap-2.6/fs/jffs2/Makefile	2011-02-06 19:45:03.133333274 -0500
+++ maemo_src/fs/jffs2/Makefile	2007-10-02 03:09:32.000000000 -0400
@@ -9,7 +9,7 @@
 jffs2-y	:= compr.o dir.o file.o ioctl.o nodelist.o malloc.o
 jffs2-y	+= read.o nodemgmt.o readinode.o write.o scan.o gc.o
 jffs2-y	+= symlink.o build.o erase.o background.o fs.o writev.o
-jffs2-y	+= super.o debug.o
+jffs2-y	+= super.o debug.o respool.o
 
 jffs2-$(CONFIG_JFFS2_FS_WRITEBUFFER)	+= wbuf.o
 jffs2-$(CONFIG_JFFS2_FS_XATTR)		+= xattr.o xattr_trusted.o xattr_user.o
@@ -18,4 +18,5 @@
 jffs2-$(CONFIG_JFFS2_RUBIN)	+= compr_rubin.o
 jffs2-$(CONFIG_JFFS2_RTIME)	+= compr_rtime.o
 jffs2-$(CONFIG_JFFS2_ZLIB)	+= compr_zlib.o
+jffs2-$(CONFIG_JFFS2_LZO)	+= compr_lzo.o
 jffs2-$(CONFIG_JFFS2_SUMMARY)   += summary.o
diff -ruN linux-omap-2.6/fs/jffs2/nodelist.c maemo_src/fs/jffs2/nodelist.c
--- linux-omap-2.6/fs/jffs2/nodelist.c	2011-02-06 19:45:03.146666606 -0500
+++ maemo_src/fs/jffs2/nodelist.c	2007-10-02 03:09:32.000000000 -0400
@@ -54,7 +54,7 @@
 	*prev = new;
 }
 
-void jffs2_truncate_fragtree(struct jffs2_sb_info *c, struct rb_root *list, uint32_t size)
+uint32_t jffs2_truncate_fragtree(struct jffs2_sb_info *c, struct rb_root *list, uint32_t size)
 {
 	struct jffs2_node_frag *frag = jffs2_lookup_node_frag(list, size);
 
@@ -76,18 +76,24 @@
 	}
 
 	if (size == 0)
-		return;
+		return 0;
 
-	/*
-	 * If the last fragment starts at the RAM page boundary, it is
-	 * REF_PRISTINE irrespective of its size.
-	 */
 	frag = frag_last(list);
+
+	/* Sanity check for truncation to longer than we started with... */
+	if (!frag)
+		return 0;
+	if (frag->ofs + frag->size < size)
+		return frag->ofs + frag->size;
+
+	/* If the last fragment starts at the RAM page boundary, it is
+	 * REF_PRISTINE irrespective of its size. */
 	if (frag->node && (frag->ofs & (PAGE_CACHE_SIZE - 1)) == 0) {
 		dbg_fragtree2("marking the last fragment 0x%08x-0x%08x REF_PRISTINE.\n",
 			frag->ofs, frag->ofs + frag->size);
 		frag->node->raw->flash_offset = ref_offset(frag->node->raw) | REF_PRISTINE;
 	}
+	return size;
 }
 
 static void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,
@@ -396,466 +402,6 @@
 
 	return 0;
 }
-
-/*
- * Check the data CRC of the node.
- *
- * Returns: 0 if the data CRC is correct;
- * 	    1 - if incorrect;
- *	    error code if an error occured.
- */
-static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)
-{
-	struct jffs2_raw_node_ref *ref = tn->fn->raw;
-	int err = 0, pointed = 0;
-	struct jffs2_eraseblock *jeb;
-	unsigned char *buffer;
-	uint32_t crc, ofs, len;
-	size_t retlen;
-
-	BUG_ON(tn->csize == 0);
-
-	if (!jffs2_is_writebuffered(c))
-		goto adj_acc;
-
-	/* Calculate how many bytes were already checked */
-	ofs = ref_offset(ref) + sizeof(struct jffs2_raw_inode);
-	len = ofs % c->wbuf_pagesize;
-	if (likely(len))
-		len = c->wbuf_pagesize - len;
-
-	if (len >= tn->csize) {
-		dbg_readinode("no need to check node at %#08x, data length %u, data starts at %#08x - it has already been checked.\n",
-			ref_offset(ref), tn->csize, ofs);
-		goto adj_acc;
-	}
-
-	ofs += len;
-	len = tn->csize - len;
-
-	dbg_readinode("check node at %#08x, data length %u, partial CRC %#08x, correct CRC %#08x, data starts at %#08x, start checking from %#08x - %u bytes.\n",
-		ref_offset(ref), tn->csize, tn->partial_crc, tn->data_crc, ofs - len, ofs, len);
-
-#ifndef __ECOS
-	/* TODO: instead, incapsulate point() stuff to jffs2_flash_read(),
-	 * adding and jffs2_flash_read_end() interface. */
-	if (c->mtd->point) {
-		err = c->mtd->point(c->mtd, ofs, len, &retlen, &buffer);
-		if (!err && retlen < tn->csize) {
-			JFFS2_WARNING("MTD point returned len too short: %zu instead of %u.\n", retlen, tn->csize);
-			c->mtd->unpoint(c->mtd, buffer, ofs, len);
-		} else if (err)
-			JFFS2_WARNING("MTD point failed: error code %d.\n", err);
-		else
-			pointed = 1; /* succefully pointed to device */
-	}
-#endif
-
-	if (!pointed) {
-		buffer = kmalloc(len, GFP_KERNEL);
-		if (unlikely(!buffer))
-			return -ENOMEM;
-
-		/* TODO: this is very frequent pattern, make it a separate
-		 * routine */
-		err = jffs2_flash_read(c, ofs, len, &retlen, buffer);
-		if (err) {
-			JFFS2_ERROR("can not read %d bytes from 0x%08x, error code: %d.\n", len, ofs, err);
-			goto free_out;
-		}
-
-		if (retlen != len) {
-			JFFS2_ERROR("short read at %#08x: %zd instead of %d.\n", ofs, retlen, len);
-			err = -EIO;
-			goto free_out;
-		}
-	}
-
-	/* Continue calculating CRC */
-	crc = crc32(tn->partial_crc, buffer, len);
-	if(!pointed)
-		kfree(buffer);
-#ifndef __ECOS
-	else
-		c->mtd->unpoint(c->mtd, buffer, ofs, len);
-#endif
-
-	if (crc != tn->data_crc) {
-		JFFS2_NOTICE("wrong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.\n",
-			ofs, tn->data_crc, crc);
-		return 1;
-	}
-
-adj_acc:
-	jeb = &c->blocks[ref->flash_offset / c->sector_size];
-	len = ref_totlen(c, jeb, ref);
-
-	/*
-	 * Mark the node as having been checked and fix the
-	 * accounting accordingly.
-	 */
-	spin_lock(&c->erase_completion_lock);
-	jeb->used_size += len;
-	jeb->unchecked_size -= len;
-	c->used_size += len;
-	c->unchecked_size -= len;
-	spin_unlock(&c->erase_completion_lock);
-
-	return 0;
-
-free_out:
-	if(!pointed)
-		kfree(buffer);
-#ifndef __ECOS
-	else
-		c->mtd->unpoint(c->mtd, buffer, ofs, len);
-#endif
-	return err;
-}
-
-/*
- * Helper function for jffs2_add_older_frag_to_fragtree().
- *
- * Checks the node if we are in the checking stage.
- */
-static int check_node(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_tmp_dnode_info *tn)
-{
-	int ret;
-
-	BUG_ON(ref_obsolete(tn->fn->raw));
-
-	/* We only check the data CRC of unchecked nodes */
-	if (ref_flags(tn->fn->raw) != REF_UNCHECKED)
-		return 0;
-
-	dbg_fragtree2("check node %#04x-%#04x, phys offs %#08x.\n",
-		tn->fn->ofs, tn->fn->ofs + tn->fn->size, ref_offset(tn->fn->raw));
-
-	ret = check_node_data(c, tn);
-	if (unlikely(ret < 0)) {
-		JFFS2_ERROR("check_node_data() returned error: %d.\n",
-			ret);
-	} else if (unlikely(ret > 0)) {
-		dbg_fragtree2("CRC error, mark it obsolete.\n");
-		jffs2_mark_node_obsolete(c, tn->fn->raw);
-	}
-
-	return ret;
-}
-
-/*
- * Helper function for jffs2_add_older_frag_to_fragtree().
- *
- * Called when the new fragment that is being inserted
- * splits a hole fragment.
- */
-static int split_hole(struct jffs2_sb_info *c, struct rb_root *root,
-		      struct jffs2_node_frag *newfrag, struct jffs2_node_frag *hole)
-{
-	dbg_fragtree2("fragment %#04x-%#04x splits the hole %#04x-%#04x\n",
-		newfrag->ofs, newfrag->ofs + newfrag->size, hole->ofs, hole->ofs + hole->size);
-
-	if (hole->ofs == newfrag->ofs) {
-		/*
-		 * Well, the new fragment actually starts at the same offset as
-		 * the hole.
-		 */
-		if (hole->ofs + hole->size > newfrag->ofs + newfrag->size) {
-			/*
-			 * We replace the overlapped left part of the hole by
-			 * the new node.
-			 */
-
-			dbg_fragtree2("insert fragment %#04x-%#04x and cut the left part of the hole\n",
-				newfrag->ofs, newfrag->ofs + newfrag->size);
-			rb_replace_node(&hole->rb, &newfrag->rb, root);
-
-			hole->ofs += newfrag->size;
-			hole->size -= newfrag->size;
-
-			/*
-			 * We know that 'hole' should be the right hand
-			 * fragment.
-			 */
-			jffs2_fragtree_insert(hole, newfrag);
-			rb_insert_color(&hole->rb, root);
-		} else {
-			/*
-			 * Ah, the new fragment is of the same size as the hole.
-			 * Relace the hole by it.
-			 */
-			dbg_fragtree2("insert fragment %#04x-%#04x and overwrite hole\n",
-				newfrag->ofs, newfrag->ofs + newfrag->size);
-			rb_replace_node(&hole->rb, &newfrag->rb, root);
-			jffs2_free_node_frag(hole);
-		}
-	} else {
-		/* The new fragment lefts some hole space at the left */
-
-		struct jffs2_node_frag * newfrag2 = NULL;
-
-		if (hole->ofs + hole->size > newfrag->ofs + newfrag->size) {
-			/* The new frag also lefts some space at the right */
-			newfrag2 = new_fragment(NULL, newfrag->ofs +
-				newfrag->size, hole->ofs + hole->size
-				- newfrag->ofs - newfrag->size);
-			if (unlikely(!newfrag2)) {
-				jffs2_free_node_frag(newfrag);
-				return -ENOMEM;
-			}
-		}
-
-		hole->size = newfrag->ofs - hole->ofs;
-		dbg_fragtree2("left the hole %#04x-%#04x at the left and inserd fragment %#04x-%#04x\n",
-			hole->ofs, hole->ofs + hole->size, newfrag->ofs, newfrag->ofs + newfrag->size);
-
-		jffs2_fragtree_insert(newfrag, hole);
-		rb_insert_color(&newfrag->rb, root);
-
-		if (newfrag2) {
-			dbg_fragtree2("left the hole %#04x-%#04x at the right\n",
-				newfrag2->ofs, newfrag2->ofs + newfrag2->size);
-			jffs2_fragtree_insert(newfrag2, newfrag);
-			rb_insert_color(&newfrag2->rb, root);
-		}
-	}
-
-	return 0;
-}
-
-/*
- * This function is used when we build inode. It expects the nodes are passed
- * in the decreasing version order. The whole point of this is to improve the
- * inodes checking on NAND: we check the nodes' data CRC only when they are not
- * obsoleted. Previously, add_frag_to_fragtree() function was used and
- * nodes were passed to it in the increasing version ordes and CRCs of all
- * nodes were checked.
- *
- * Note: tn->fn->size shouldn't be zero.
- *
- * Returns 0 if the node was inserted
- *         1 if it wasn't inserted (since it is obsolete)
- *         < 0 an if error occured
- */
-int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
-				     struct jffs2_tmp_dnode_info *tn)
-{
-	struct jffs2_node_frag *this, *newfrag;
-	uint32_t lastend;
-	struct jffs2_full_dnode *fn = tn->fn;
-	struct rb_root *root = &f->fragtree;
-	uint32_t fn_size = fn->size, fn_ofs = fn->ofs;
-	int err, checked = 0;
-	int ref_flag;
-
-	dbg_fragtree("insert fragment %#04x-%#04x, ver %u\n", fn_ofs, fn_ofs + fn_size, tn->version);
-
-	/* Skip all the nodes which are completed before this one starts */
-	this = jffs2_lookup_node_frag(root, fn_ofs);
-	if (this)
-		dbg_fragtree2("'this' found %#04x-%#04x (%s)\n", this->ofs, this->ofs + this->size, this->node ? "data" : "hole");
-
-	if (this)
-		lastend = this->ofs + this->size;
-	else
-		lastend = 0;
-
-	/* Detect the preliminary type of node */
-	if (fn->size >= PAGE_CACHE_SIZE)
-		ref_flag = REF_PRISTINE;
-	else
-		ref_flag = REF_NORMAL;
-
-	/* See if we ran off the end of the root */
-	if (lastend <= fn_ofs) {
-		/* We did */
-
-		/*
-		 * We are going to insert the new node into the
-		 * fragment tree, so check it.
-		 */
-		err = check_node(c, f, tn);
-		if (err != 0)
-			return err;
-
-		fn->frags = 1;
-
-		newfrag = new_fragment(fn, fn_ofs, fn_size);
-		if (unlikely(!newfrag))
-			return -ENOMEM;
-
-		err = no_overlapping_node(c, root, newfrag, this, lastend);
-		if (unlikely(err != 0)) {
-			jffs2_free_node_frag(newfrag);
-			return err;
-		}
-
-		goto out_ok;
-	}
-
-	fn->frags = 0;
-
-	while (1) {
-		/*
-		 * Here we have:
-		 * fn_ofs < this->ofs + this->size && fn_ofs >= this->ofs.
-		 *
-		 * Remember, 'this' has higher version, any non-hole node
-		 * which is already in the fragtree is newer then the newly
-		 * inserted.
-		 */
-		if (!this->node) {
-			/*
-			 * 'this' is the hole fragment, so at least the
-			 * beginning of the new fragment is valid.
-			 */
-
-			/*
-			 * We are going to insert the new node into the
-			 * fragment tree, so check it.
-			 */
-			if (!checked) {
-				err = check_node(c, f, tn);
-				if (unlikely(err != 0))
-					return err;
-				checked = 1;
-			}
-
-			if (this->ofs + this->size >= fn_ofs + fn_size) {
-				/* We split the hole on two parts */
-
-				fn->frags += 1;
-				newfrag = new_fragment(fn, fn_ofs, fn_size);
-				if (unlikely(!newfrag))
-					return -ENOMEM;
-
-				err = split_hole(c, root, newfrag, this);
-				if (unlikely(err))
-					return err;
-				goto out_ok;
-			}
-
-			/*
-			 * The beginning of the new fragment is valid since it
-			 * overlaps the hole node.
-			 */
-
-			ref_flag = REF_NORMAL;
-
-			fn->frags += 1;
-			newfrag = new_fragment(fn, fn_ofs,
-					this->ofs + this->size - fn_ofs);
-			if (unlikely(!newfrag))
-				return -ENOMEM;
-
-			if (fn_ofs == this->ofs) {
-				/*
-				 * The new node starts at the same offset as
-				 * the hole and supersieds the hole.
-				 */
-				dbg_fragtree2("add the new fragment instead of hole %#04x-%#04x, refcnt %d\n",
-					fn_ofs, fn_ofs + this->ofs + this->size - fn_ofs, fn->frags);
-
-				rb_replace_node(&this->rb, &newfrag->rb, root);
-				jffs2_free_node_frag(this);
-			} else {
-				/*
-				 * The hole becomes shorter as its right part
-				 * is supersieded by the new fragment.
-				 */
-				dbg_fragtree2("reduce size of hole %#04x-%#04x to %#04x-%#04x\n",
-					this->ofs, this->ofs + this->size, this->ofs, this->ofs + this->size - newfrag->size);
-
-				dbg_fragtree2("add new fragment %#04x-%#04x, refcnt %d\n", fn_ofs,
-					fn_ofs + this->ofs + this->size - fn_ofs, fn->frags);
-
-				this->size -= newfrag->size;
-				jffs2_fragtree_insert(newfrag, this);
-				rb_insert_color(&newfrag->rb, root);
-			}
-
-			fn_ofs += newfrag->size;
-			fn_size -= newfrag->size;
-			this = rb_entry(rb_next(&newfrag->rb),
-					struct jffs2_node_frag, rb);
-
-			dbg_fragtree2("switch to the next 'this' fragment: %#04x-%#04x %s\n",
-				this->ofs, this->ofs + this->size, this->node ? "(data)" : "(hole)");
-		}
-
-		/*
-		 * 'This' node is not the hole so it obsoletes the new fragment
-		 * either fully or partially.
-		 */
-		if (this->ofs + this->size >= fn_ofs + fn_size) {
-			/* The new node is obsolete, drop it */
-			if (fn->frags == 0) {
-				dbg_fragtree2("%#04x-%#04x is obsolete, mark it obsolete\n", fn_ofs, fn_ofs + fn_size);
-				ref_flag = REF_OBSOLETE;
-			}
-			goto out_ok;
-		} else {
-			struct jffs2_node_frag *new_this;
-
-			/* 'This' node obsoletes the beginning of the new node */
-			dbg_fragtree2("the beginning %#04x-%#04x is obsolete\n", fn_ofs, this->ofs + this->size);
-
-			ref_flag = REF_NORMAL;
-
-			fn_size -= this->ofs + this->size - fn_ofs;
-			fn_ofs = this->ofs + this->size;
-			dbg_fragtree2("now considering %#04x-%#04x\n", fn_ofs, fn_ofs + fn_size);
-
-			new_this = rb_entry(rb_next(&this->rb), struct jffs2_node_frag, rb);
-			if (!new_this) {
-				/*
-				 * There is no next fragment. Add the rest of
-				 * the new node as the right-hand child.
-				 */
-				if (!checked) {
-					err = check_node(c, f, tn);
-					if (unlikely(err != 0))
-						return err;
-					checked = 1;
-				}
-
-				fn->frags += 1;
-				newfrag = new_fragment(fn, fn_ofs, fn_size);
-				if (unlikely(!newfrag))
-					return -ENOMEM;
-
-				dbg_fragtree2("there are no more fragments, insert %#04x-%#04x\n",
-					newfrag->ofs, newfrag->ofs + newfrag->size);
-				rb_link_node(&newfrag->rb, &this->rb, &this->rb.rb_right);
-				rb_insert_color(&newfrag->rb, root);
-				goto out_ok;
-			} else {
-				this = new_this;
-				dbg_fragtree2("switch to the next 'this' fragment: %#04x-%#04x %s\n",
-					this->ofs, this->ofs + this->size, this->node ? "(data)" : "(hole)");
-			}
-		}
-	}
-
-out_ok:
-	BUG_ON(fn->size < PAGE_CACHE_SIZE && ref_flag == REF_PRISTINE);
-
-	if (ref_flag == REF_OBSOLETE) {
-		dbg_fragtree2("the node is obsolete now\n");
-		/* jffs2_mark_node_obsolete() will adjust space accounting */
-		jffs2_mark_node_obsolete(c, fn->raw);
-		return 1;
-	}
-
-	dbg_fragtree2("the node is \"%s\" now\n", ref_flag == REF_NORMAL ? "REF_NORMAL" : "REF_PRISTINE");
-
-	/* Space accounting was adjusted at check_node_data() */
-	spin_lock(&c->erase_completion_lock);
-	fn->raw->flash_offset = ref_offset(fn->raw) | ref_flag;
-	spin_unlock(&c->erase_completion_lock);
-
-	return 0;
-}
 
 void jffs2_set_inocache_state(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic, int state)
 {
diff -ruN linux-omap-2.6/fs/jffs2/nodelist.h maemo_src/fs/jffs2/nodelist.h
--- linux-omap-2.6/fs/jffs2/nodelist.h	2011-02-06 19:45:03.146666606 -0500
+++ maemo_src/fs/jffs2/nodelist.h	2007-10-02 03:09:32.000000000 -0400
@@ -120,7 +120,7 @@
 	return ((struct jffs2_inode_cache *)raw);
 }
 
-        /* flash_offset & 3 always has to be zero, because nodes are
+	/* flash_offset & 3 always has to be zero, because nodes are
 	   always aligned at 4 bytes. So we have a couple of extra bits
 	   to play with, which indicate the node's status; see below: */
 #define REF_UNCHECKED	0	/* We haven't yet checked the CRC or built its inode */
@@ -132,6 +132,11 @@
 #define ref_obsolete(ref)	(((ref)->flash_offset & 3) == REF_OBSOLETE)
 #define mark_ref_normal(ref)    do { (ref)->flash_offset = ref_offset(ref) | REF_NORMAL; } while(0)
 
+/* Dirent nodes should be REF_PRISTINE only if they are not a deletion
+   dirent. Deletion dirents should be REF_NORMAL so that GC gets to
+   throw them away when appropriate */
+#define dirent_node_state(rd)	( (je32_to_cpu((rd)->ino)?REF_PRISTINE:REF_NORMAL) )
+
 /* NB: REF_PRISTINE for an inode-less node (ref->next_in_ino == NULL) indicates
    it is an unknown node of type JFFS2_NODETYPE_RWCOMPAT_COPY, so it'll get
    copied. If you need to do anything different to GC inode-less nodes, then
@@ -216,7 +221,20 @@
 	uint32_t version;
 	uint32_t data_crc;
 	uint32_t partial_crc;
-	uint32_t csize;
+	uint16_t csize;
+	uint16_t overlapped;
+};
+
+/* Temporary data structure used during readinode. */
+struct jffs2_readinode_info
+{
+	struct rb_root tn_root;
+	struct jffs2_tmp_dnode_info *mdata_tn;
+	uint32_t highest_version;
+	uint32_t latest_mctime;
+	uint32_t mctime_ver;
+	struct jffs2_full_dirent *fds;
+	struct jffs2_raw_node_ref *latest_ref;
 };
 
 struct jffs2_full_dirent
@@ -319,6 +337,15 @@
 #define frag_right(frag) rb_entry((frag)->rb.rb_right, struct jffs2_node_frag, rb)
 #define frag_erase(frag, list) rb_erase(&frag->rb, list);
 
+#define tn_next(tn) rb_entry(rb_next(&(tn)->rb), struct jffs2_tmp_dnode_info, rb)
+#define tn_prev(tn) rb_entry(rb_prev(&(tn)->rb), struct jffs2_tmp_dnode_info, rb)
+#define tn_parent(tn) rb_entry(rb_parent(&(tn)->rb), struct jffs2_tmp_dnode_info, rb)
+#define tn_left(tn) rb_entry((tn)->rb.rb_left, struct jffs2_tmp_dnode_info, rb)
+#define tn_right(tn) rb_entry((tn)->rb.rb_right, struct jffs2_tmp_dnode_info, rb)
+#define tn_erase(tn, list) rb_erase(&tn->rb, list);
+#define tn_last(list) rb_entry(rb_last(list), struct jffs2_tmp_dnode_info, rb)
+#define tn_first(list) rb_entry(rb_first(list), struct jffs2_tmp_dnode_info, rb)
+
 /* nodelist.c */
 void jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list);
 void jffs2_set_inocache_state(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic, int state);
@@ -333,8 +360,7 @@
 struct rb_node *rb_prev(struct rb_node *);
 void rb_replace_node(struct rb_node *victim, struct rb_node *new, struct rb_root *root);
 int jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_full_dnode *fn);
-void jffs2_truncate_fragtree (struct jffs2_sb_info *c, struct rb_root *list, uint32_t size);
-int jffs2_add_older_frag_to_fragtree(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_tmp_dnode_info *tn);
+uint32_t jffs2_truncate_fragtree (struct jffs2_sb_info *c, struct rb_root *list, uint32_t size);
 struct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,
 					       struct jffs2_eraseblock *jeb,
 					       uint32_t ofs, uint32_t len,
@@ -444,4 +470,9 @@
 
 #include "debug.h"
 
+int jffs2_rp_parse_options(struct super_block *sb, char *opts);
+int jffs2_rp_show_options(struct seq_file *m, struct vfsmount *mnt);
+int jffs2_rp_can_write(struct jffs2_sb_info *c);
+void jffs2_rp_free(struct jffs2_sb_info *c);
+
 #endif /* __JFFS2_NODELIST_H__ */
diff -ruN linux-omap-2.6/fs/jffs2/nodemgmt.c maemo_src/fs/jffs2/nodemgmt.c
--- linux-omap-2.6/fs/jffs2/nodemgmt.c	2011-02-06 19:45:03.146666606 -0500
+++ maemo_src/fs/jffs2/nodemgmt.c	2007-10-02 03:09:32.000000000 -0400
@@ -56,6 +56,17 @@
 
 	spin_lock(&c->erase_completion_lock);
 
+	/*
+	 * Check if the free space is greater then size of the reserved pool.
+	 * If not, allow to proceed with writing only to the users which are in
+	 * the c->rp_ids list.
+	 */
+        if (c->rp_ids && prio != ALLOC_DELETION && !jffs2_rp_can_write(c)) {
+		spin_unlock(&c->erase_completion_lock);
+		up(&c->alloc_sem);
+		return -ENOSPC;
+	}
+
 	/* this needs a little more thought (true <tglx> :)) */
 	while(ret == -EAGAIN) {
 		while(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {
@@ -156,7 +167,7 @@
 	while(ret == -EAGAIN) {
 		ret = jffs2_do_reserve_space(c, minsize, len, sumsize);
 		if (ret) {
-		        D1(printk(KERN_DEBUG "jffs2_reserve_space_gc: looping, ret is %d\n", ret));
+			D1(printk(KERN_DEBUG "jffs2_reserve_space_gc: looping, ret is %d\n", ret));
 		}
 	}
 	spin_unlock(&c->erase_completion_lock);
@@ -172,6 +183,11 @@
 static void jffs2_close_nextblock(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)
 {
 
+	if (c->nextblock == NULL) {
+		D1(printk(KERN_DEBUG "jffs2_close_nextblock: Erase block at 0x%08x has already been placed in a list\n",
+		  jeb->offset));
+		return;
+	}
 	/* Check, if we have a dirty block now, or if it was dirty already */
 	if (ISDIRTY (jeb->wasted_size + jeb->dirty_size)) {
 		c->dirty_size += jeb->wasted_size;
diff -ruN linux-omap-2.6/fs/jffs2/readinode.c maemo_src/fs/jffs2/readinode.c
--- linux-omap-2.6/fs/jffs2/readinode.c	2011-02-06 19:45:03.149999939 -0500
+++ maemo_src/fs/jffs2/readinode.c	2007-10-02 03:09:32.000000000 -0400
@@ -22,30 +22,496 @@
 #include "nodelist.h"
 
 /*
- * Put a new tmp_dnode_info into the temporaty RB-tree, keeping the list in
- * order of increasing version.
+ * Check the data CRC of the node.
+ *
+ * Returns: 0 if the data CRC is correct;
+ * 	    1 - if incorrect;
+ *	    error code if an error occured.
  */
-static void jffs2_add_tn_to_tree(struct jffs2_tmp_dnode_info *tn, struct rb_root *list)
+static int check_node_data(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)
+{
+	struct jffs2_raw_node_ref *ref = tn->fn->raw;
+	int err = 0, pointed = 0;
+	struct jffs2_eraseblock *jeb;
+	unsigned char *buffer;
+	uint32_t crc, ofs, len;
+	size_t retlen;
+
+	BUG_ON(tn->csize == 0);
+
+	if (!jffs2_is_writebuffered(c))
+		goto adj_acc;
+
+	/* Calculate how many bytes were already checked */
+	ofs = ref_offset(ref) + sizeof(struct jffs2_raw_inode);
+	len = ofs % c->wbuf_pagesize;
+	if (likely(len))
+		len = c->wbuf_pagesize - len;
+
+	if (len >= tn->csize) {
+		dbg_readinode("no need to check node at %#08x, data length %u, data starts at %#08x - it has already been checked.\n",
+			ref_offset(ref), tn->csize, ofs);
+		goto adj_acc;
+	}
+
+	ofs += len;
+	len = tn->csize - len;
+
+	dbg_readinode("check node at %#08x, data length %u, partial CRC %#08x, correct CRC %#08x, data starts at %#08x, start checking from %#08x - %u bytes.\n",
+		ref_offset(ref), tn->csize, tn->partial_crc, tn->data_crc, ofs - len, ofs, len);
+
+#ifndef __ECOS
+	/* TODO: instead, incapsulate point() stuff to jffs2_flash_read(),
+	 * adding and jffs2_flash_read_end() interface. */
+	if (c->mtd->point) {
+		err = c->mtd->point(c->mtd, ofs, len, &retlen, &buffer);
+		if (!err && retlen < tn->csize) {
+			JFFS2_WARNING("MTD point returned len too short: %zu instead of %u.\n", retlen, tn->csize);
+			c->mtd->unpoint(c->mtd, buffer, ofs, len);
+		} else if (err)
+			JFFS2_WARNING("MTD point failed: error code %d.\n", err);
+		else
+			pointed = 1; /* succefully pointed to device */
+	}
+#endif
+
+	if (!pointed) {
+		buffer = kmalloc(len, GFP_KERNEL);
+		if (unlikely(!buffer))
+			return -ENOMEM;
+
+		/* TODO: this is very frequent pattern, make it a separate
+		 * routine */
+		err = jffs2_flash_read(c, ofs, len, &retlen, buffer);
+		if (err) {
+			JFFS2_ERROR("can not read %d bytes from 0x%08x, error code: %d.\n", len, ofs, err);
+			goto free_out;
+		}
+
+		if (retlen != len) {
+			JFFS2_ERROR("short read at %#08x: %zd instead of %d.\n", ofs, retlen, len);
+			err = -EIO;
+			goto free_out;
+		}
+	}
+
+	/* Continue calculating CRC */
+	crc = crc32(tn->partial_crc, buffer, len);
+	if(!pointed)
+		kfree(buffer);
+#ifndef __ECOS
+	else
+		c->mtd->unpoint(c->mtd, buffer, ofs, len);
+#endif
+
+	if (crc != tn->data_crc) {
+		JFFS2_NOTICE("wrong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.\n",
+			     ref_offset(ref), tn->data_crc, crc);
+		return 1;
+	}
+
+adj_acc:
+	jeb = &c->blocks[ref->flash_offset / c->sector_size];
+	len = ref_totlen(c, jeb, ref);
+	/* If it should be REF_NORMAL, it'll get marked as such when
+	   we build the fragtree, shortly. No need to worry about GC
+	   moving it while it's marked REF_PRISTINE -- GC won't happen
+	   till we've finished checking every inode anyway. */
+	ref->flash_offset |= REF_PRISTINE;
+	/*
+	 * Mark the node as having been checked and fix the
+	 * accounting accordingly.
+	 */
+	spin_lock(&c->erase_completion_lock);
+	jeb->used_size += len;
+	jeb->unchecked_size -= len;
+	c->used_size += len;
+	c->unchecked_size -= len;
+	jffs2_dbg_acct_paranoia_check_nolock(c, jeb);
+	spin_unlock(&c->erase_completion_lock);
+
+	return 0;
+
+free_out:
+	if(!pointed)
+		kfree(buffer);
+#ifndef __ECOS
+	else
+		c->mtd->unpoint(c->mtd, buffer, ofs, len);
+#endif
+	return err;
+}
+
+/*
+ * Helper function for jffs2_add_older_frag_to_fragtree().
+ *
+ * Checks the node if we are in the checking stage.
+ */
+static int check_tn_node(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)
+{
+	int ret;
+
+	BUG_ON(ref_obsolete(tn->fn->raw));
+
+	/* We only check the data CRC of unchecked nodes */
+	if (ref_flags(tn->fn->raw) != REF_UNCHECKED)
+		return 0;
+
+	dbg_readinode("check node %#04x-%#04x, phys offs %#08x\n",
+		      tn->fn->ofs, tn->fn->ofs + tn->fn->size, ref_offset(tn->fn->raw));
+
+	ret = check_node_data(c, tn);
+	if (unlikely(ret < 0)) {
+		JFFS2_ERROR("check_node_data() returned error: %d.\n",
+			ret);
+	} else if (unlikely(ret > 0)) {
+		dbg_readinode("CRC error, mark it obsolete.\n");
+		jffs2_mark_node_obsolete(c, tn->fn->raw);
+	}
+
+	return ret;
+}
+
+static struct jffs2_tmp_dnode_info *jffs2_lookup_tn(struct rb_root *tn_root, uint32_t offset)
 {
-	struct rb_node **p = &list->rb_node;
-	struct rb_node * parent = NULL;
+	struct rb_node *next;
+	struct jffs2_tmp_dnode_info *tn = NULL;
+
+	dbg_readinode("root %p, offset %d\n", tn_root, offset);
+
+	next = tn_root->rb_node;
+
+	while (next) {
+		tn = rb_entry(next, struct jffs2_tmp_dnode_info, rb);
+
+		if (tn->fn->ofs < offset)
+			next = tn->rb.rb_right;
+		else if (tn->fn->ofs >= offset)
+			next = tn->rb.rb_left;
+		else
+			break;
+	}
+
+	return tn;
+}
+
+
+static void jffs2_kill_tn(struct jffs2_sb_info *c, struct jffs2_tmp_dnode_info *tn)
+{
+	jffs2_mark_node_obsolete(c, tn->fn->raw);
+	jffs2_free_full_dnode(tn->fn);
+	jffs2_free_tmp_dnode_info(tn);
+}
+/*
+ * This function is used when we read an inode. Data nodes arrive in
+ * arbitrary order -- they may be older or newer than the nodes which
+ * are already in the tree. Where overlaps occur, the older node can
+ * be discarded as long as the newer passes the CRC check. We don't
+ * bother to keep track of holes in this rbtree, and neither do we deal
+ * with frags -- we can have multiple entries starting at the same
+ * offset, and the one with the smallest length will come first in the
+ * ordering.
+ *
+ * Returns 0 if the node was handled (including marking it obsolete)
+ *	 < 0 an if error occurred
+ */
+static int jffs2_add_tn_to_tree(struct jffs2_sb_info *c,
+				struct jffs2_readinode_info *rii,
+				struct jffs2_tmp_dnode_info *tn)
+{
+	uint32_t fn_end = tn->fn->ofs + tn->fn->size;
 	struct jffs2_tmp_dnode_info *this;
 
-	while (*p) {
-		parent = *p;
-		this = rb_entry(parent, struct jffs2_tmp_dnode_info, rb);
-
-		/* There may actually be a collision here, but it doesn't
-		   actually matter. As long as the two nodes with the same
-		   version are together, it's all fine. */
-		if (tn->version > this->version)
-			p = &(*p)->rb_left;
+	dbg_readinode("insert fragment %#04x-%#04x, ver %u at %08x\n", tn->fn->ofs, fn_end, tn->version, ref_offset(tn->fn->raw));
+
+	/* If a node has zero dsize, we only have to keep if it if it might be the
+	   node with highest version -- i.e. the one which will end up as f->metadata.
+	   Note that such nodes won't be REF_UNCHECKED since there are no data to
+	   check anyway. */
+	if (!tn->fn->size) {
+		if (rii->mdata_tn) {
+			if (rii->mdata_tn->version < tn->version) {
+				/* We had a candidate mdata node already */
+				dbg_readinode("kill old mdata with ver %d\n", rii->mdata_tn->version);
+				jffs2_kill_tn(c, rii->mdata_tn);
+			} else {
+				dbg_readinode("kill new mdata with ver %d (older than existing %d\n",
+					      tn->version, rii->mdata_tn->version);
+				jffs2_kill_tn(c, tn);
+				return 0;
+			}
+		}
+		rii->mdata_tn = tn;
+		dbg_readinode("keep new mdata with ver %d\n", tn->version);
+		return 0;
+	}
+
+	/* Find the earliest node which _may_ be relevant to this one */
+	this = jffs2_lookup_tn(&rii->tn_root, tn->fn->ofs);
+	if (this) {
+		/* If the node is coincident with another at a lower address,
+		   back up until the other node is found. It may be relevant */
+		while (this->overlapped)
+			this = tn_prev(this);
+
+		/* First node should never be marked overlapped */
+		BUG_ON(!this);
+		dbg_readinode("'this' found %#04x-%#04x (%s)\n", this->fn->ofs, this->fn->ofs + this->fn->size, this->fn ? "data" : "hole");
+	}
+
+	while (this) {
+		if (this->fn->ofs > fn_end)
+			break;
+		dbg_readinode("Ponder this ver %d, 0x%x-0x%x\n",
+			      this->version, this->fn->ofs, this->fn->size);
+
+		if (this->version == tn->version) {
+			/* Version number collision means REF_PRISTINE GC. Accept either of them
+			   as long as the CRC is correct. Check the one we have already...  */
+			if (!check_tn_node(c, this)) {
+				/* The one we already had was OK. Keep it and throw away the new one */
+				dbg_readinode("Like old node. Throw away new\n");
+				jffs2_kill_tn(c, tn);
+				return 0;
+			} else {
+				/* Who cares if the new one is good; keep it for now anyway. */
+				dbg_readinode("Like new node. Throw away old\n");
+				rb_replace_node(&this->rb, &tn->rb, &rii->tn_root);
+				jffs2_kill_tn(c, this);
+				/* Same overlapping from in front and behind */
+				return 0;
+			}
+		}
+		if (this->version < tn->version &&
+		    this->fn->ofs >= tn->fn->ofs &&
+		    this->fn->ofs + this->fn->size <= fn_end) {
+			/* New node entirely overlaps 'this' */
+			if (check_tn_node(c, tn)) {
+				dbg_readinode("new node bad CRC\n");
+				jffs2_kill_tn(c, tn);
+				return 0;
+			}
+			/* ... and is good. Kill 'this' and any subsequent nodes which are also overlapped */
+			while (this && this->fn->ofs + this->fn->size <= fn_end) {
+				struct jffs2_tmp_dnode_info *next = tn_next(this);
+				if (this->version < tn->version) {
+					tn_erase(this, &rii->tn_root);
+					dbg_readinode("Kill overlapped ver %d, 0x%x-0x%x\n",
+						      this->version, this->fn->ofs,
+						      this->fn->ofs+this->fn->size);
+					jffs2_kill_tn(c, this);
+				}
+				this = next;
+			}
+			dbg_readinode("Done killing overlapped nodes\n");
+			continue;
+		}
+		if (this->version > tn->version &&
+		    this->fn->ofs <= tn->fn->ofs &&
+		    this->fn->ofs+this->fn->size >= fn_end) {
+			/* New node entirely overlapped by 'this' */
+			if (!check_tn_node(c, this)) {
+				dbg_readinode("Good CRC on old node. Kill new\n");
+				jffs2_kill_tn(c, tn);
+				return 0;
+			}
+			/* ... but 'this' was bad. Replace it... */
+			dbg_readinode("Bad CRC on old overlapping node. Kill it\n");
+			tn_erase(this, &rii->tn_root);
+			jffs2_kill_tn(c, this);
+			break;
+		}
+
+		this = tn_next(this);
+	}
+
+	/* We neither completely obsoleted nor were completely
+	   obsoleted by an earlier node. Insert into the tree */
+	{
+		struct rb_node *parent;
+		struct rb_node **link = &rii->tn_root.rb_node;
+		struct jffs2_tmp_dnode_info *insert_point = NULL;
+
+		while (*link) {
+			parent = *link;
+			insert_point = rb_entry(parent, struct jffs2_tmp_dnode_info, rb);
+			if (tn->fn->ofs > insert_point->fn->ofs)
+				link = &insert_point->rb.rb_right;
+			else if (tn->fn->ofs < insert_point->fn->ofs ||
+				 tn->fn->size < insert_point->fn->size)
+				link = &insert_point->rb.rb_left;
+			else
+				link = &insert_point->rb.rb_right;
+		}
+		rb_link_node(&tn->rb, &insert_point->rb, link);
+		rb_insert_color(&tn->rb, &rii->tn_root);
+	}
+
+	/* If there's anything behind that overlaps us, note it */
+	this = tn_prev(tn);
+	if (this) {
+		while (1) {
+			if (this->fn->ofs + this->fn->size > tn->fn->ofs) {
+				dbg_readinode("Node is overlapped by %p (v %d, 0x%x-0x%x)\n",
+					      this, this->version, this->fn->ofs,
+					      this->fn->ofs+this->fn->size);
+				tn->overlapped = 1;
+				break;
+			}
+			if (!this->overlapped)
+				break;
+			this = tn_prev(this);
+		}
+	}
+
+	/* If the new node overlaps anything ahead, note it */
+	this = tn_next(tn);
+	while (this && this->fn->ofs < fn_end) {
+		this->overlapped = 1;
+		dbg_readinode("Node ver %d, 0x%x-0x%x is overlapped\n",
+			      this->version, this->fn->ofs,
+			      this->fn->ofs+this->fn->size);
+		this = tn_next(this);
+	}
+	return 0;
+}
+
+/* Trivial function to remove the last node in the tree. Which by definition
+   has no right-hand -- so can be removed just by making its only child (if
+   any) take its place under its parent. */
+static void eat_last(struct rb_root *root, struct rb_node *node)
+{
+	struct rb_node *parent = rb_parent(node);
+	struct rb_node **link;
+
+	/* LAST! */
+	BUG_ON(node->rb_right);
+
+	if (!parent)
+		link = &root->rb_node;
+	else if (node == parent->rb_left)
+		link = &parent->rb_left;
+	else
+		link = &parent->rb_right;
+
+	*link = node->rb_left;
+	/* Colour doesn't matter now. Only the parent pointer. */
+	if (node->rb_left)
+		node->rb_left->rb_parent_color = node->rb_parent_color;
+}
+
+/* We put this in reverse order, so we can just use eat_last */
+static void ver_insert(struct rb_root *ver_root, struct jffs2_tmp_dnode_info *tn)
+{
+	struct rb_node **link = &ver_root->rb_node;
+	struct rb_node *parent = NULL;
+	struct jffs2_tmp_dnode_info *this_tn;
+
+	while (*link) {
+		parent = *link;
+		this_tn = rb_entry(parent, struct jffs2_tmp_dnode_info, rb);
+
+		if (tn->version > this_tn->version)
+			link = &parent->rb_left;
 		else
-			p = &(*p)->rb_right;
+			link = &parent->rb_right;
 	}
+	dbg_readinode("Link new node at %p (root is %p)\n", link, ver_root);
+	rb_link_node(&tn->rb, parent, link);
+	rb_insert_color(&tn->rb, ver_root);
+}
 
-	rb_link_node(&tn->rb, parent, p);
-	rb_insert_color(&tn->rb, list);
+/* Build final, normal fragtree from tn tree. It doesn't matter which order
+   we add nodes to the real fragtree, as long as they don't overlap. And
+   having thrown away the majority of overlapped nodes as we went, there
+   really shouldn't be many sets of nodes which do overlap. If we start at
+   the end, we can use the overlap markers -- we can just eat nodes which
+   aren't overlapped, and when we encounter nodes which _do_ overlap we
+   sort them all into a temporary tree in version order before replaying them. */
+static int jffs2_build_inode_fragtree(struct jffs2_sb_info *c,
+				      struct jffs2_inode_info *f,
+				      struct jffs2_readinode_info *rii)
+{
+	struct jffs2_tmp_dnode_info *pen, *last, *this;
+	struct rb_root ver_root = RB_ROOT;
+	uint32_t high_ver = 0;
+
+	if (rii->mdata_tn) {
+		dbg_readinode("potential mdata is ver %d at %p\n", rii->mdata_tn->version, rii->mdata_tn);
+		high_ver = rii->mdata_tn->version;
+		rii->latest_ref = rii->mdata_tn->fn->raw;
+	}
+#ifdef JFFS2_DBG_READINODE_MESSAGES
+	this = tn_last(&rii->tn_root);
+	while (this) {
+		dbg_readinode("tn %p ver %d range 0x%x-0x%x ov %d\n", this, this->version, this->fn->ofs,
+			      this->fn->ofs+this->fn->size, this->overlapped);
+		this = tn_prev(this);
+	}
+#endif
+	pen = tn_last(&rii->tn_root);
+	while ((last = pen)) {
+		pen = tn_prev(last);
+
+		eat_last(&rii->tn_root, &last->rb);
+		ver_insert(&ver_root, last);
+
+		if (unlikely(last->overlapped))
+			continue;
+
+		/* Now we have a bunch of nodes in reverse version
+		   order, in the tree at ver_root. Most of the time,
+		   there'll actually be only one node in the 'tree',
+		   in fact. */
+		this = tn_last(&ver_root);
+
+		while (this) {
+			struct jffs2_tmp_dnode_info *vers_next;
+			int ret;
+			vers_next = tn_prev(this);
+			eat_last(&ver_root, &this->rb);
+			if (check_tn_node(c, this)) {
+				dbg_readinode("node ver %d, 0x%x-0x%x failed CRC\n",
+					     this->version, this->fn->ofs,
+					     this->fn->ofs+this->fn->size);
+				jffs2_kill_tn(c, this);
+			} else {
+				if (this->version > high_ver) {
+					/* Note that this is different from the other
+					   highest_version, because this one is only
+					   counting _valid_ nodes which could give the
+					   latest inode metadata */
+					high_ver = this->version;
+					rii->latest_ref = this->fn->raw;
+				}
+				dbg_readinode("Add %p (v %d, 0x%x-0x%x, ov %d) to fragtree\n",
+					     this, this->version, this->fn->ofs,
+					     this->fn->ofs+this->fn->size, this->overlapped);
+
+				ret = jffs2_add_full_dnode_to_inode(c, f, this->fn);
+				if (ret) {
+					/* Free the nodes in vers_root; let the caller
+					   deal with the rest */
+					JFFS2_ERROR("Add node to tree failed %d\n", ret);
+					while (1) {
+						vers_next = tn_prev(this);
+						if (check_tn_node(c, this))
+							jffs2_mark_node_obsolete(c, this->fn->raw);
+						jffs2_free_full_dnode(this->fn);
+						jffs2_free_tmp_dnode_info(this);
+						this = vers_next;
+						if (!this)
+							break;
+						eat_last(&ver_root, &vers_next->rb);
+					}
+					return ret;
+				}
+				jffs2_free_tmp_dnode_info(this);
+			}
+			this = vers_next;
+		}
+	}
+	return 0;
 }
 
 static void jffs2_free_tmp_dnode_info_list(struct rb_root *list)
@@ -107,13 +573,12 @@
  * Helper function for jffs2_get_inode_nodes().
  * It is called every time an directory entry node is found.
  *
- * Returns: 0 on succes;
- * 	    1 if the node should be marked obsolete;
+ * Returns: 0 on success;
  * 	    negative error code on failure.
  */
 static inline int read_direntry(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref,
-				struct jffs2_raw_dirent *rd, size_t read, struct jffs2_full_dirent **fdp,
-				uint32_t *latest_mctime, uint32_t *mctime_ver)
+				struct jffs2_raw_dirent *rd, size_t read,
+				struct jffs2_readinode_info *rii)
 {
 	struct jffs2_full_dirent *fd;
 	uint32_t crc;
@@ -125,7 +590,8 @@
 	if (unlikely(crc != je32_to_cpu(rd->node_crc))) {
 		JFFS2_NOTICE("header CRC failed on dirent node at %#08x: read %#08x, calculated %#08x\n",
 			     ref_offset(ref), je32_to_cpu(rd->node_crc), crc);
-		return 1;
+		jffs2_mark_node_obsolete(c, ref);
+		return 0;
 	}
 
 	/* If we've never checked the CRCs on this node, check them now */
@@ -137,7 +603,8 @@
 		if (unlikely(PAD((rd->nsize + sizeof(*rd))) != PAD(je32_to_cpu(rd->totlen)))) {
 			JFFS2_ERROR("illegal nsize in node at %#08x: nsize %#02x, totlen %#04x\n",
 				    ref_offset(ref), rd->nsize, je32_to_cpu(rd->totlen));
-			return 1;
+			jffs2_mark_node_obsolete(c, ref);
+			return 0;
 		}
 
 		jeb = &c->blocks[ref->flash_offset / c->sector_size];
@@ -148,7 +615,7 @@
 		jeb->unchecked_size -= len;
 		c->used_size += len;
 		c->unchecked_size -= len;
-		ref->flash_offset = ref_offset(ref) | REF_PRISTINE;
+		ref->flash_offset = ref_offset(ref) | dirent_node_state(rd);
 		spin_unlock(&c->erase_completion_lock);
 	}
 
@@ -161,10 +628,13 @@
 	fd->ino = je32_to_cpu(rd->ino);
 	fd->type = rd->type;
 
+	if (fd->version > rii->highest_version)
+		rii->highest_version = fd->version;
+
 	/* Pick out the mctime of the latest dirent */
-	if(fd->version > *mctime_ver && je32_to_cpu(rd->mctime)) {
-		*mctime_ver = fd->version;
-		*latest_mctime = je32_to_cpu(rd->mctime);
+	if(fd->version > rii->mctime_ver && je32_to_cpu(rd->mctime)) {
+		rii->mctime_ver = fd->version;
+		rii->latest_mctime = je32_to_cpu(rd->mctime);
 	}
 
 	/*
@@ -201,7 +671,7 @@
 	 * Wheee. We now have a complete jffs2_full_dirent structure, with
 	 * the name in it and everything. Link it into the list
 	 */
-	jffs2_add_fd_to_list(c, fd, fdp);
+	jffs2_add_fd_to_list(c, fd, &rii->fds);
 
 	return 0;
 }
@@ -210,17 +680,16 @@
  * Helper function for jffs2_get_inode_nodes().
  * It is called every time an inode node is found.
  *
- * Returns: 0 on succes;
- * 	    1 if the node should be marked obsolete;
+ * Returns: 0 on success (possibly after marking a bad node obsolete);
  * 	    negative error code on failure.
  */
 static inline int read_dnode(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref,
-			     struct jffs2_raw_inode *rd, struct rb_root *tnp, int rdlen,
-			     uint32_t *latest_mctime, uint32_t *mctime_ver)
+			     struct jffs2_raw_inode *rd, int rdlen,
+			     struct jffs2_readinode_info *rii)
 {
 	struct jffs2_tmp_dnode_info *tn;
 	uint32_t len, csize;
-	int ret = 1;
+	int ret = 0;
 	uint32_t crc;
 
 	/* Obsoleted. This cannot happen, surely? dwmw2 20020308 */
@@ -230,7 +699,8 @@
 	if (unlikely(crc != je32_to_cpu(rd->node_crc))) {
 		JFFS2_NOTICE("node CRC failed on dnode at %#08x: read %#08x, calculated %#08x\n",
 			     ref_offset(ref), je32_to_cpu(rd->node_crc), crc);
-		return 1;
+		jffs2_mark_node_obsolete(c, ref);
+		return 0;
 	}
 
 	tn = jffs2_alloc_tmp_dnode_info();
@@ -248,8 +718,9 @@
 		/* Sanity checks */
 		if (unlikely(je32_to_cpu(rd->offset) > je32_to_cpu(rd->isize)) ||
 		    unlikely(PAD(je32_to_cpu(rd->csize) + sizeof(*rd)) != PAD(je32_to_cpu(rd->totlen)))) {
-				JFFS2_WARNING("inode node header CRC is corrupted at %#08x\n", ref_offset(ref));
-				jffs2_dbg_dump_node(c, ref_offset(ref));
+			JFFS2_WARNING("inode node header CRC is corrupted at %#08x\n", ref_offset(ref));
+			jffs2_dbg_dump_node(c, ref_offset(ref));
+			jffs2_mark_node_obsolete(c, ref);
 			goto free_out;
 		}
 
@@ -304,6 +775,7 @@
 			if (len >= csize && unlikely(tn->partial_crc != je32_to_cpu(rd->data_crc))) {
 				JFFS2_NOTICE("wrong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.\n",
 					ref_offset(ref), tn->partial_crc, je32_to_cpu(rd->data_crc));
+				jffs2_mark_node_obsolete(c, ref);
 				goto free_out;
 			}
 
@@ -342,6 +814,10 @@
 	tn->data_crc = je32_to_cpu(rd->data_crc);
 	tn->csize = csize;
 	tn->fn->raw = ref;
+	tn->overlapped = 0;
+
+	if (tn->version > rii->highest_version)
+		rii->highest_version = tn->version;
 
 	/* There was a bug where we wrote hole nodes out with
 	   csize/dsize swapped. Deal with it */
@@ -353,13 +829,25 @@
 	dbg_readinode("dnode @%08x: ver %u, offset %#04x, dsize %#04x, csize %#04x\n",
 		  ref_offset(ref), je32_to_cpu(rd->version), je32_to_cpu(rd->offset), je32_to_cpu(rd->dsize), csize);
 
-	jffs2_add_tn_to_tree(tn, tnp);
+	ret = jffs2_add_tn_to_tree(c, rii, tn);
 
+	if (ret) {
+		jffs2_free_full_dnode(tn->fn);
+	free_out:
+		jffs2_free_tmp_dnode_info(tn);
+		return ret;
+	}
+#ifdef JFFS2_DBG_READINODE_MESSAGES
+	dbg_readinode("After adding ver %d:\n", je32_to_cpu(rd->version));
+	tn = tn_first(&rii->tn_root);
+	while (tn) {
+		dbg_readinode("%p: v %d r 0x%x-0x%x ov %d\n",
+			     tn, tn->version, tn->fn->ofs,
+			     tn->fn->ofs+tn->fn->size, tn->overlapped);
+		tn = tn_next(tn);
+	}
+#endif
 	return 0;
-
-free_out:
-	jffs2_free_tmp_dnode_info(tn);
-	return ret;
 }
 
 /*
@@ -367,7 +855,6 @@
  * It is called every time an unknown node is found.
  *
  * Returns: 0 on success;
- * 	    1 if the node should be marked obsolete;
  * 	    negative error code on failure.
  */
 static inline int read_unknown(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref, struct jffs2_unknown_node *un)
@@ -377,9 +864,10 @@
 		JFFS2_ERROR("REF_UNCHECKED but unknown node at %#08x\n",
 			    ref_offset(ref));
 		JFFS2_ERROR("Node is {%04x,%04x,%08x,%08x}. Please report this error.\n",
-                            je16_to_cpu(un->magic), je16_to_cpu(un->nodetype),
-                            je32_to_cpu(un->totlen), je32_to_cpu(un->hdr_crc));
-		return 1;
+			    je16_to_cpu(un->magic), je16_to_cpu(un->nodetype),
+			    je32_to_cpu(un->totlen), je32_to_cpu(un->hdr_crc));
+		jffs2_mark_node_obsolete(c, ref);
+		return 0;
 	}
 
 	un->nodetype = cpu_to_je16(JFFS2_NODE_ACCURATE | je16_to_cpu(un->nodetype));
@@ -407,7 +895,8 @@
 	case JFFS2_FEATURE_RWCOMPAT_DELETE:
 		JFFS2_NOTICE("unknown RWCOMPAT_DELETE nodetype %#04X at %#08x\n",
 			     je16_to_cpu(un->nodetype), ref_offset(ref));
-		return 1;
+		jffs2_mark_node_obsolete(c, ref);
+		return 0;
 	}
 
 	return 0;
@@ -421,92 +910,62 @@
  * 	    negative error code on failure.
  */
 static int read_more(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref,
-		     int right_size, int *rdlen, unsigned char *buf, unsigned char *bufstart)
+		     int needed_len, int *rdlen, unsigned char *buf)
 {
-	int right_len, err, len;
+	int err, to_read = needed_len - *rdlen;
 	size_t retlen;
 	uint32_t offs;
 
 	if (jffs2_is_writebuffered(c)) {
-		right_len = c->wbuf_pagesize - (bufstart - buf);
-		if (right_size + (int)(bufstart - buf) > c->wbuf_pagesize)
-			right_len += c->wbuf_pagesize;
-	} else
-		right_len = right_size;
+		int rem = to_read % c->wbuf_pagesize;
 
-	if (*rdlen == right_len)
-		return 0;
+		if (rem)
+			to_read += c->wbuf_pagesize - rem;
+	}
 
 	/* We need to read more data */
 	offs = ref_offset(ref) + *rdlen;
-	if (jffs2_is_writebuffered(c)) {
-		bufstart = buf + c->wbuf_pagesize;
-		len = c->wbuf_pagesize;
-	} else {
-		bufstart = buf + *rdlen;
-		len = right_size - *rdlen;
-	}
 
-	dbg_readinode("read more %d bytes\n", len);
+	dbg_readinode("read more %d bytes\n", to_read);
 
-	err = jffs2_flash_read(c, offs, len, &retlen, bufstart);
+	err = jffs2_flash_read(c, offs, to_read, &retlen, buf + *rdlen);
 	if (err) {
 		JFFS2_ERROR("can not read %d bytes from 0x%08x, "
-			"error code: %d.\n", len, offs, err);
+			"error code: %d.\n", to_read, offs, err);
 		return err;
 	}
 
-	if (retlen < len) {
+	if (retlen < to_read) {
 		JFFS2_ERROR("short read at %#08x: %zu instead of %d.\n",
-				offs, retlen, len);
+				offs, retlen, to_read);
 		return -EIO;
 	}
 
-	*rdlen = right_len;
-
+	*rdlen += to_read;
 	return 0;
 }
 
 /* Get tmp_dnode_info and full_dirent for all non-obsolete nodes associated
-   with this ino, returning the former in order of version */
+   with this ino. Perform a preliminary ordering on data nodes, throwing away
+   those which are completely obsoleted by newer ones. The nave approach we
+   use to take of just returning them _all_ in version order will cause us to
+   run out of memory in certain degenerate cases. */
 static int jffs2_get_inode_nodes(struct jffs2_sb_info *c, struct jffs2_inode_info *f,
-				 struct rb_root *tnp, struct jffs2_full_dirent **fdp,
-				 uint32_t *highest_version, uint32_t *latest_mctime,
-				 uint32_t *mctime_ver)
+				 struct jffs2_readinode_info *rii)
 {
 	struct jffs2_raw_node_ref *ref, *valid_ref;
-	struct rb_root ret_tn = RB_ROOT;
-	struct jffs2_full_dirent *ret_fd = NULL;
 	unsigned char *buf = NULL;
 	union jffs2_node_union *node;
 	size_t retlen;
 	int len, err;
 
-	*mctime_ver = 0;
+	rii->mctime_ver = 0;
 
 	dbg_readinode("ino #%u\n", f->inocache->ino);
 
-	if (jffs2_is_writebuffered(c)) {
-		/*
-		 * If we have the write buffer, we assume the minimal I/O unit
-		 * is c->wbuf_pagesize. We implement some optimizations which in
-		 * this case and we need a temporary buffer of size =
-		 * 2*c->wbuf_pagesize bytes (see comments in read_dnode()).
-		 * Basically, we want to read not only the node header, but the
-		 * whole wbuf (NAND page in case of NAND) or 2, if the node
-		 * header overlaps the border between the 2 wbufs.
-		 */
-		len = 2*c->wbuf_pagesize;
-	} else {
-		/*
-		 * When there is no write buffer, the size of the temporary
-		 * buffer is the size of the larges node header.
-		 */
-		len = sizeof(union jffs2_node_union);
-	}
-
 	/* FIXME: in case of NOR and available ->point() this
 	 * needs to be fixed. */
+	len = sizeof(union jffs2_node_union) + c->wbuf_pagesize;
 	buf = kmalloc(len, GFP_KERNEL);
 	if (!buf)
 		return -ENOMEM;
@@ -516,8 +975,6 @@
 	if (!valid_ref && f->inocache->ino != 1)
 		JFFS2_WARNING("Eep. No valid nodes for ino #%u.\n", f->inocache->ino);
 	while (valid_ref) {
-		unsigned char *bufstart;
-
 		/* We can hold a pointer to a non-obsolete node without the spinlock,
 		   but _obsolete_ nodes may disappear at any time, if the block
 		   they're in gets erased. So if we mark 'ref' obsolete while we're
@@ -533,32 +990,31 @@
 		/*
 		 * At this point we don't know the type of the node we're going
 		 * to read, so we do not know the size of its header. In order
-		 * to minimize the amount of flash IO we assume the node has
-		 * size = JFFS2_MIN_NODE_HEADER.
+		 * to minimize the amount of flash IO we assume the header is
+		 * of size = JFFS2_MIN_NODE_HEADER.
 		 */
+		len = JFFS2_MIN_NODE_HEADER;
 		if (jffs2_is_writebuffered(c)) {
+			int end, rem;
+
 			/*
-			 * We treat 'buf' as 2 adjacent wbufs. We want to
-			 * adjust bufstart such as it points to the
-			 * beginning of the node within this wbuf.
+			 * We are about to read JFFS2_MIN_NODE_HEADER bytes,
+			 * but this flash has some minimal I/O unit. It is
+			 * possible that we'll need to read more soon, so read
+			 * up to the next min. I/O unit, in order not to
+			 * re-read the same min. I/O unit twice.
 			 */
-			bufstart = buf + (ref_offset(ref) % c->wbuf_pagesize);
-			/* We will read either one wbuf or 2 wbufs. */
-			len = c->wbuf_pagesize - (bufstart - buf);
-			if (JFFS2_MIN_NODE_HEADER + (int)(bufstart - buf) > c->wbuf_pagesize) {
-				/* The header spans the border of the first wbuf */
-				len += c->wbuf_pagesize;
-			}
-		} else {
-			bufstart = buf;
-			len = JFFS2_MIN_NODE_HEADER;
+			end = ref_offset(ref) + len;
+			rem = end % c->wbuf_pagesize;
+			if (rem)
+				end += c->wbuf_pagesize - rem;
+			len = end - ref_offset(ref);
 		}
 
 		dbg_readinode("read %d bytes at %#08x(%d).\n", len, ref_offset(ref), ref_flags(ref));
 
 		/* FIXME: point() */
-		err = jffs2_flash_read(c, ref_offset(ref), len,
-				       &retlen, bufstart);
+		err = jffs2_flash_read(c, ref_offset(ref), len, &retlen, buf);
 		if (err) {
 			JFFS2_ERROR("can not read %d bytes from 0x%08x, " "error code: %d.\n", len, ref_offset(ref), err);
 			goto free_out;
@@ -570,7 +1026,7 @@
 			goto free_out;
 		}
 
-		node = (union jffs2_node_union *)bufstart;
+		node = (union jffs2_node_union *)buf;
 
 		/* No need to mask in the valid bit; it shouldn't be invalid */
 		if (je32_to_cpu(node->u.hdr_crc) != crc32(0, node, sizeof(node->u)-4)) {
@@ -583,10 +1039,10 @@
 			jffs2_mark_node_obsolete(c, ref);
 			goto cont;
 		}
-		/* Due to poor choice of crc32 seed, an all-zero node will have a correct CRC */
-		if (!je32_to_cpu(node->u.hdr_crc) && !je16_to_cpu(node->u.nodetype) &&
-		    !je16_to_cpu(node->u.magic) && !je32_to_cpu(node->u.totlen)) {
-			JFFS2_NOTICE("All zero node header at %#08x.\n", ref_offset(ref));
+		if (je16_to_cpu(node->u.magic) != JFFS2_MAGIC_BITMASK) {
+			/* Not a JFFS2 node, whinge and move on */
+			JFFS2_NOTICE("Wrong magic bitmask 0x%04x in node header at %#08x.\n",
+				     je16_to_cpu(node->u.magic), ref_offset(ref));
 			jffs2_mark_node_obsolete(c, ref);
 			goto cont;
 		}
@@ -595,56 +1051,44 @@
 
 		case JFFS2_NODETYPE_DIRENT:
 
-			if (JFFS2_MIN_NODE_HEADER < sizeof(struct jffs2_raw_dirent)) {
-				err = read_more(c, ref, sizeof(struct jffs2_raw_dirent), &len, buf, bufstart);
+			if (JFFS2_MIN_NODE_HEADER < sizeof(struct jffs2_raw_dirent) &&
+			    len < sizeof(struct jffs2_raw_dirent)) {
+				err = read_more(c, ref, sizeof(struct jffs2_raw_dirent), &len, buf);
 				if (unlikely(err))
 					goto free_out;
 			}
 
-			err = read_direntry(c, ref, &node->d, retlen, &ret_fd, latest_mctime, mctime_ver);
-			if (err == 1) {
-				jffs2_mark_node_obsolete(c, ref);
-				break;
-			} else if (unlikely(err))
+			err = read_direntry(c, ref, &node->d, retlen, rii);
+			if (unlikely(err))
 				goto free_out;
 
-			if (je32_to_cpu(node->d.version) > *highest_version)
-				*highest_version = je32_to_cpu(node->d.version);
-
 			break;
 
 		case JFFS2_NODETYPE_INODE:
 
-			if (JFFS2_MIN_NODE_HEADER < sizeof(struct jffs2_raw_inode)) {
-				err = read_more(c, ref, sizeof(struct jffs2_raw_inode), &len, buf, bufstart);
+			if (JFFS2_MIN_NODE_HEADER < sizeof(struct jffs2_raw_inode) &&
+			    len < sizeof(struct jffs2_raw_inode)) {
+				err = read_more(c, ref, sizeof(struct jffs2_raw_inode), &len, buf);
 				if (unlikely(err))
 					goto free_out;
 			}
 
-			err = read_dnode(c, ref, &node->i, &ret_tn, len, latest_mctime, mctime_ver);
-			if (err == 1) {
-				jffs2_mark_node_obsolete(c, ref);
-				break;
-			} else if (unlikely(err))
+			err = read_dnode(c, ref, &node->i, len, rii);
+			if (unlikely(err))
 				goto free_out;
 
-			if (je32_to_cpu(node->i.version) > *highest_version)
-				*highest_version = je32_to_cpu(node->i.version);
-
 			break;
 
 		default:
-			if (JFFS2_MIN_NODE_HEADER < sizeof(struct jffs2_unknown_node)) {
-				err = read_more(c, ref, sizeof(struct jffs2_unknown_node), &len, buf, bufstart);
+			if (JFFS2_MIN_NODE_HEADER < sizeof(struct jffs2_unknown_node) &&
+			    len < sizeof(struct jffs2_unknown_node)) {
+				err = read_more(c, ref, sizeof(struct jffs2_unknown_node), &len, buf);
 				if (unlikely(err))
 					goto free_out;
 			}
 
 			err = read_unknown(c, ref, &node->u);
-			if (err == 1) {
-				jffs2_mark_node_obsolete(c, ref);
-				break;
-			} else if (unlikely(err))
+			if (unlikely(err))
 				goto free_out;
 
 		}
@@ -653,17 +1097,19 @@
 	}
 
 	spin_unlock(&c->erase_completion_lock);
-	*tnp = ret_tn;
-	*fdp = ret_fd;
 	kfree(buf);
 
+	f->highest_version = rii->highest_version;
+
 	dbg_readinode("nodes of inode #%u were read, the highest version is %u, latest_mctime %u, mctime_ver %u.\n",
-			f->inocache->ino, *highest_version, *latest_mctime, *mctime_ver);
+		      f->inocache->ino, rii->highest_version, rii->latest_mctime,
+		      rii->mctime_ver);
 	return 0;
 
  free_out:
-	jffs2_free_tmp_dnode_info_list(&ret_tn);
-	jffs2_free_full_dirent_list(ret_fd);
+	jffs2_free_tmp_dnode_info_list(&rii->tn_root);
+	jffs2_free_full_dirent_list(rii->fds);
+	rii->fds = NULL;
 	kfree(buf);
 	return err;
 }
@@ -672,20 +1118,17 @@
 					struct jffs2_inode_info *f,
 					struct jffs2_raw_inode *latest_node)
 {
-	struct jffs2_tmp_dnode_info *tn;
-	struct rb_root tn_list;
-	struct rb_node *rb, *repl_rb;
-	struct jffs2_full_dirent *fd_list;
-	struct jffs2_full_dnode *fn, *first_fn = NULL;
-	uint32_t crc;
-	uint32_t latest_mctime, mctime_ver;
+	struct jffs2_readinode_info rii;
+	uint32_t crc, new_size;
 	size_t retlen;
 	int ret;
 
 	dbg_readinode("ino #%u nlink is %d\n", f->inocache->ino, f->inocache->nlink);
 
+	memset(&rii, 0, sizeof(rii));
+
 	/* Grab all nodes relevant to this ino */
-	ret = jffs2_get_inode_nodes(c, f, &tn_list, &fd_list, &f->highest_version, &latest_mctime, &mctime_ver);
+	ret = jffs2_get_inode_nodes(c, f, &rii);
 
 	if (ret) {
 		JFFS2_ERROR("cannot read nodes for ino %u, returned error is %d\n", f->inocache->ino, ret);
@@ -693,74 +1136,42 @@
 			jffs2_set_inocache_state(c, f->inocache, INO_STATE_CHECKEDABSENT);
 		return ret;
 	}
-	f->dents = fd_list;
-
-	rb = rb_first(&tn_list);
-
-	while (rb) {
-		cond_resched();
-		tn = rb_entry(rb, struct jffs2_tmp_dnode_info, rb);
-		fn = tn->fn;
-		ret = 1;
-		dbg_readinode("consider node ver %u, phys offset "
-			"%#08x(%d), range %u-%u.\n", tn->version,
-			ref_offset(fn->raw), ref_flags(fn->raw),
-			fn->ofs, fn->ofs + fn->size);
-
-		if (fn->size) {
-			ret = jffs2_add_older_frag_to_fragtree(c, f, tn);
-			/* TODO: the error code isn't checked, check it */
-			jffs2_dbg_fragtree_paranoia_check_nolock(f);
-			BUG_ON(ret < 0);
-			if (!first_fn && ret == 0)
-				first_fn = fn;
-		} else if (!first_fn) {
-			first_fn = fn;
-			f->metadata = fn;
-			ret = 0; /* Prevent freeing the metadata update node */
-		} else
-			jffs2_mark_node_obsolete(c, fn->raw);
-
-		BUG_ON(rb->rb_left);
-		if (rb_parent(rb) && rb_parent(rb)->rb_left == rb) {
-			/* We were then left-hand child of our parent. We need
-			 * to move our own right-hand child into our place. */
-			repl_rb = rb->rb_right;
-			if (repl_rb)
-				rb_set_parent(repl_rb, rb_parent(rb));
-		} else
-			repl_rb = NULL;
-
-		rb = rb_next(rb);
-
-		/* Remove the spent tn from the tree; don't bother rebalancing
-		 * but put our right-hand child in our own place. */
-		if (rb_parent(&tn->rb)) {
-			if (rb_parent(&tn->rb)->rb_left == &tn->rb)
-				rb_parent(&tn->rb)->rb_left = repl_rb;
-			else if (rb_parent(&tn->rb)->rb_right == &tn->rb)
-				rb_parent(&tn->rb)->rb_right = repl_rb;
-			else BUG();
-		} else if (tn->rb.rb_right)
-			rb_set_parent(tn->rb.rb_right, NULL);
 
-		jffs2_free_tmp_dnode_info(tn);
-		if (ret) {
-			dbg_readinode("delete dnode %u-%u.\n",
-				fn->ofs, fn->ofs + fn->size);
-			jffs2_free_full_dnode(fn);
+	ret = jffs2_build_inode_fragtree(c, f, &rii);
+	if (ret) {
+		JFFS2_ERROR("Failed to build final fragtree for inode #%u: error %d\n",
+			    f->inocache->ino, ret);
+		if (f->inocache->state == INO_STATE_READING)
+			jffs2_set_inocache_state(c, f->inocache, INO_STATE_CHECKEDABSENT);
+		jffs2_free_tmp_dnode_info_list(&rii.tn_root);
+		/* FIXME: We could at least crc-check them all */
+		if (rii.mdata_tn) {
+			jffs2_free_full_dnode(rii.mdata_tn->fn);
+			jffs2_free_tmp_dnode_info(rii.mdata_tn);
+			rii.mdata_tn = NULL;
 		}
+		return ret;
 	}
-	jffs2_dbg_fragtree_paranoia_check_nolock(f);
 
-	BUG_ON(first_fn && ref_obsolete(first_fn->raw));
+	if (rii.mdata_tn) {
+		if (rii.mdata_tn->fn->raw == rii.latest_ref) {
+			f->metadata = rii.mdata_tn->fn;
+			jffs2_free_tmp_dnode_info(rii.mdata_tn);
+		} else {
+			jffs2_kill_tn(c, rii.mdata_tn);
+		}
+		rii.mdata_tn = NULL;
+       }
+
+	f->dents = rii.fds;
 
-	fn = first_fn;
-	if (unlikely(!first_fn)) {
+	jffs2_dbg_fragtree_paranoia_check_nolock(f);
+
+	if (unlikely(!rii.latest_ref)) {
 		/* No data nodes for this inode. */
 		if (f->inocache->ino != 1) {
 			JFFS2_WARNING("no data nodes found for ino #%u\n", f->inocache->ino);
-			if (!fd_list) {
+			if (!rii.fds) {
 				if (f->inocache->state == INO_STATE_READING)
 					jffs2_set_inocache_state(c, f->inocache, INO_STATE_CHECKEDABSENT);
 				return -EIO;
@@ -778,7 +1189,7 @@
 		return 0;
 	}
 
-	ret = jffs2_flash_read(c, ref_offset(fn->raw), sizeof(*latest_node), &retlen, (void *)latest_node);
+	ret = jffs2_flash_read(c, ref_offset(rii.latest_ref), sizeof(*latest_node), &retlen, (void *)latest_node);
 	if (ret || retlen != sizeof(*latest_node)) {
 		JFFS2_ERROR("failed to read from flash: error %d, %zd of %zd bytes read\n",
 			ret, retlen, sizeof(*latest_node));
@@ -791,7 +1202,7 @@
 	crc = crc32(0, latest_node, sizeof(*latest_node)-8);
 	if (crc != je32_to_cpu(latest_node->node_crc)) {
 		JFFS2_ERROR("CRC failed for read_inode of inode %u at physical location 0x%x\n",
-			f->inocache->ino, ref_offset(fn->raw));
+			f->inocache->ino, ref_offset(rii.latest_ref));
 		up(&f->sem);
 		jffs2_do_clear_inode(c, f);
 		return -EIO;
@@ -799,17 +1210,22 @@
 
 	switch(jemode_to_cpu(latest_node->mode) & S_IFMT) {
 	case S_IFDIR:
-		if (mctime_ver > je32_to_cpu(latest_node->version)) {
+		if (rii.mctime_ver > je32_to_cpu(latest_node->version)) {
 			/* The times in the latest_node are actually older than
 			   mctime in the latest dirent. Cheat. */
-			latest_node->ctime = latest_node->mtime = cpu_to_je32(latest_mctime);
+			latest_node->ctime = latest_node->mtime = cpu_to_je32(rii.latest_mctime);
 		}
 		break;
 
 
 	case S_IFREG:
 		/* If it was a regular file, truncate it to the latest node's isize */
-		jffs2_truncate_fragtree(c, &f->fragtree, je32_to_cpu(latest_node->isize));
+		new_size = jffs2_truncate_fragtree(c, &f->fragtree, je32_to_cpu(latest_node->isize));
+		if (new_size != je32_to_cpu(latest_node->isize)) {
+			JFFS2_WARNING("Truncating ino #%u to %d bytes failed because it only had %d bytes to start with!\n",
+				      f->inocache->ino, je32_to_cpu(latest_node->isize), new_size);
+			latest_node->isize = cpu_to_je32(new_size);
+		}
 		break;
 
 	case S_IFLNK:
@@ -832,7 +1248,7 @@
 				return -ENOMEM;
 			}
 
-			ret = jffs2_flash_read(c, ref_offset(fn->raw) + sizeof(*latest_node),
+			ret = jffs2_flash_read(c, ref_offset(rii.latest_ref) + sizeof(*latest_node),
 						je32_to_cpu(latest_node->csize), &retlen, (char *)f->target);
 
 			if (ret  || retlen != je32_to_cpu(latest_node->csize)) {
diff -ruN linux-omap-2.6/fs/jffs2/respool.c maemo_src/fs/jffs2/respool.c
--- linux-omap-2.6/fs/jffs2/respool.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/fs/jffs2/respool.c	2007-10-02 03:09:32.000000000 -0400
@@ -0,0 +1,221 @@
+#include <linux/kernel.h>
+#include <linux/mtd/mtd.h>
+#include <linux/string.h>
+#include <linux/parser.h>
+#include <linux/seq_file.h>
+#include <linux/jffs2.h>
+#include <linux/mount.h>
+#include <linux/fs.h>
+#include "nodelist.h"
+
+/* Define RP_DEBUG macro to enable RP dbg messages */
+#undef RP_DEBUG
+
+#ifdef RP_DEBUG
+#define RP_MSG(fmt, ...) printk(KERN_DEBUG "[JFFS2 RP] %s:\t" fmt, __FUNCTION__, ## __VA_ARGS__);
+#else
+#define RP_MSG(fmt, ...)
+#endif
+
+/*
+ * The maximal number of arguments which the parser may find in one mount
+ * option pattern.
+ */
+#define JFFS2_MAX_ARGS	1
+
+/*
+ * The type of the entry in the list of UIDs/GIDs whic hare allowed to use the
+ * reserved pool.
+ */
+enum jffs2_rp_id_type {
+	JFFS2_IDTYPE_UID,
+	JFFS2_IDTYPE_GID
+};
+
+/*
+ * The entry of the list of the UIDs/GIDs which are allowed to use the reserved
+ * pool.
+ */
+struct jffs2_rp_id {
+	enum jffs2_rp_id_type type;
+	unsigned int id;
+	struct jffs2_rp_id *next;
+};
+
+/*
+ * The mount option identifiers.
+ */
+enum {
+	JFFS2_OPT_RP_SIZE,
+	JFFS2_OPT_RP_UID,
+	JFFS2_OPT_RP_GID,
+	JFFS2_OPT_LAST_FAKE
+};
+
+/*
+ * The supported mount options to feed to the mount options parser.
+ */
+static match_table_t tokens = {
+	{JFFS2_OPT_RP_SIZE, "rpsize=%u"}, /* The size of the reserved pool */
+	{JFFS2_OPT_RP_UID, "rpuid=%u"},   /* UID of a user of the reserved pool */
+	{JFFS2_OPT_RP_GID, "rpgid=%u"},   /* GID of a user of the reserved pool */
+	{JFFS2_OPT_LAST_FAKE, NULL}       /* End of list marker */
+};
+
+/*
+ * This is probably a generic function and should be kept somwhere in super.c,
+ * but sence our reserved pool hack is not in mainline, we prevere to keep as
+ * much as possible in one file in order to fasicilate easier patch
+ * management.
+ */
+int jffs2_rp_parse_options(struct super_block *sb, char *opts)
+{
+	unsigned int opt;
+	int ret = -EINVAL;
+	char *p;
+	substring_t args[JFFS2_MAX_ARGS];
+	struct jffs2_sb_info *c = JFFS2_SB_INFO(sb);
+	struct jffs2_rp_id *rp_list_tail = NULL;
+
+	if (!opts)
+		return 0;
+
+	while ((p = strsep(&opts, ",")) != NULL) {
+		int token;
+
+		if (!*p)
+			continue;
+
+		token = match_token(p, tokens, args);
+
+		switch (token) {
+			case JFFS2_OPT_RP_SIZE:
+				if (match_int(&args[0], &opt))
+					goto error;
+				c->rp_size = opt * 1024;
+				if (c->rp_size > c->mtd->size) {
+					printk(KERN_WARNING "Warning: too large reserve pool specified, max is %u KB\n",
+							c->mtd->size / 1024);
+					goto error;
+				}
+				RP_MSG("RP size is %u KB\n", opt);
+				break;
+
+			case JFFS2_OPT_RP_UID:
+			case JFFS2_OPT_RP_GID:
+			{
+				struct jffs2_rp_id *id;
+				if (match_int(&args[0], &opt))
+					goto error;
+
+				id = kmalloc(sizeof(*id), GFP_KERNEL);
+				if (!id) {
+					ret = -ENOMEM;
+					goto error;
+				}
+
+				id->id = opt;
+				id->next = NULL;
+				if (token == JFFS2_OPT_RP_UID) {
+					id->type = JFFS2_IDTYPE_UID;
+					RP_MSG("UID %u may use RP\n", opt);
+				} else {
+					id->type = JFFS2_IDTYPE_GID;
+					RP_MSG("GID %u may use RP\n", opt);
+				}
+
+				if (rp_list_tail == NULL)
+					c->rp_ids = id;
+				else
+					rp_list_tail->next = id;
+
+				rp_list_tail = id;
+				break;
+			}
+		}
+	}
+
+	return 0;
+
+error:
+	jffs2_rp_free(c);
+
+	return ret;
+}
+
+void jffs2_rp_free(struct jffs2_sb_info *c)
+{
+	/* Free the reserved pool UIDs/GIDs */
+	while (c->rp_ids) {
+		struct jffs2_rp_id *id = c->rp_ids;
+		c->rp_ids = c->rp_ids->next;
+		kfree(id);
+	}
+	c->rp_size = 0;
+}
+
+int jffs2_rp_show_options(struct seq_file *m, struct vfsmount *mnt)
+{
+	struct jffs2_sb_info *c = JFFS2_SB_INFO(mnt->mnt_sb);
+	struct jffs2_rp_id *id;
+
+	if (c->rp_size)
+		seq_printf(m, ",rpsize=%d", c->rp_size/1024);
+
+	id = c->rp_ids;
+	while(id) {
+		if (id->type == JFFS2_IDTYPE_UID)
+			seq_printf(m, ",rpuid=%d", id->id);
+		else
+			seq_printf(m, ",rpgid=%d", id->id);
+		id = id->next;
+	}
+	return 0;
+}
+
+/*
+ * Check whether the user is allowed to write.
+ */
+int jffs2_rp_can_write(struct jffs2_sb_info *c)
+{
+	uint32_t avail;
+	struct jffs2_rp_id *id = c->rp_ids;
+
+	avail = c->dirty_size + c->free_size + c->unchecked_size +
+		c->erasing_size - c->resv_blocks_write * c->sector_size
+		- c->nospc_dirty_size;
+
+	if (avail < 2*c->rp_size)
+		RP_MSG("rpsize %u, dirty_size %u, free_size %u, erasing_size %u, "
+			"unchecked_size %u, nr_erasing_blocks %u, avail %u, resrv %u\n",
+			c->rp_size, c->dirty_size, c->free_size, c->erasing_size,
+			c->unchecked_size, c->nr_erasing_blocks, avail,
+			c->nospc_dirty_size);
+
+	if(avail > c->rp_size)
+		return 1;
+
+	while (id) {
+
+		if (id->type == JFFS2_IDTYPE_UID) {
+			if ((unsigned int)current->user->uid == id->id)
+				return 1;
+		} else {
+			int i;
+
+			/* Walk the groups user belongs to */
+			for (i = 0; i< current->group_info->ngroups; i++) {
+				int blk = i / NGROUPS_PER_BLOCK;
+				int grp = i - blk;
+
+				if ((current->group_info->blocks[blk])[grp] == (gid_t)id->id)
+					return 1;
+			}
+		}
+
+		id = id->next;
+	}
+
+	RP_MSG("forbid writing\n");
+	return 0;
+}
diff -ruN linux-omap-2.6/fs/jffs2/scan.c maemo_src/fs/jffs2/scan.c
--- linux-omap-2.6/fs/jffs2/scan.c	2011-02-06 19:45:03.149999939 -0500
+++ maemo_src/fs/jffs2/scan.c	2007-10-02 03:09:32.000000000 -0400
@@ -734,18 +734,8 @@
 			ofs += 4;
 			continue;
 		}
-		/* Due to poor choice of crc32 seed, an all-zero node will have a correct CRC */
-		if (!je32_to_cpu(node->hdr_crc) && !je16_to_cpu(node->nodetype) &&
-		    !je16_to_cpu(node->magic) && !je32_to_cpu(node->totlen)) {
-			noisy_printk(&noise, "jffs2_scan_eraseblock(): All zero node header at 0x%08x.\n", ofs);
-			if ((err = jffs2_scan_dirty_space(c, jeb, 4)))
-				return err;
-			ofs += 4;
-			continue;
-		}
 
-		if (ofs + je32_to_cpu(node->totlen) >
-		    jeb->offset + c->sector_size) {
+		if (ofs + je32_to_cpu(node->totlen) > jeb->offset + c->sector_size) {
 			/* Eep. Node goes over the end of the erase block. */
 			printk(KERN_WARNING "Node at 0x%08x with length 0x%08x would run over the end of the erase block\n",
 			       ofs, je32_to_cpu(node->totlen));
@@ -867,7 +857,7 @@
 			switch (je16_to_cpu(node->nodetype) & JFFS2_COMPAT_MASK) {
 			case JFFS2_FEATURE_ROCOMPAT:
 				printk(KERN_NOTICE "Read-only compatible feature node (0x%04x) found at offset 0x%08x\n", je16_to_cpu(node->nodetype), ofs);
-			        c->flags |= JFFS2_SB_FLAG_RO;
+				c->flags |= JFFS2_SB_FLAG_RO;
 				if (!(jffs2_is_readonly(c)))
 					return -EROFS;
 				if ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(node->totlen)))))
@@ -952,8 +942,7 @@
 				 struct jffs2_raw_inode *ri, uint32_t ofs, struct jffs2_summary *s)
 {
 	struct jffs2_inode_cache *ic;
-	uint32_t ino = je32_to_cpu(ri->ino);
-	int err;
+	uint32_t crc, ino = je32_to_cpu(ri->ino);
 
 	D1(printk(KERN_DEBUG "jffs2_scan_inode_node(): Node at 0x%08x\n", ofs));
 
@@ -966,21 +955,22 @@
 	   Which means that the _full_ amount of time to get to proper write mode with GC
 	   operational may actually be _longer_ than before. Sucks to be me. */
 
+	/* Check the node CRC in any case. */
+	crc = crc32(0, ri, sizeof(*ri)-8);
+	if (crc != je32_to_cpu(ri->node_crc)) {
+		printk(KERN_NOTICE "jffs2_scan_inode_node(): CRC failed on "
+		       "node at 0x%08x: Read 0x%08x, calculated 0x%08x\n",
+		       ofs, je32_to_cpu(ri->node_crc), crc);
+		/*
+		 * We believe totlen because the CRC on the node
+		 * _header_ was OK, just the node itself failed.
+		 */
+		return jffs2_scan_dirty_space(c, jeb,
+					      PAD(je32_to_cpu(ri->totlen)));
+	}
+
 	ic = jffs2_get_ino_cache(c, ino);
 	if (!ic) {
-		/* Inocache get failed. Either we read a bogus ino# or it's just genuinely the
-		   first node we found for this inode. Do a CRC check to protect against the former
-		   case */
-		uint32_t crc = crc32(0, ri, sizeof(*ri)-8);
-
-		if (crc != je32_to_cpu(ri->node_crc)) {
-			printk(KERN_NOTICE "jffs2_scan_inode_node(): CRC failed on node at 0x%08x: Read 0x%08x, calculated 0x%08x\n",
-			       ofs, je32_to_cpu(ri->node_crc), crc);
-			/* We believe totlen because the CRC on the node _header_ was OK, just the node itself failed. */
-			if ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(ri->totlen)))))
-				return err;
-			return 0;
-		}
 		ic = jffs2_scan_make_ino_cache(c, ino);
 		if (!ic)
 			return -ENOMEM;
@@ -1053,7 +1043,8 @@
 		return -ENOMEM;
 	}
 
-	fd->raw = jffs2_link_node_ref(c, jeb, ofs | REF_PRISTINE, PAD(je32_to_cpu(rd->totlen)), ic);
+	fd->raw = jffs2_link_node_ref(c, jeb, ofs | dirent_node_state(rd),
+				      PAD(je32_to_cpu(rd->totlen)), ic);
 
 	fd->next = NULL;
 	fd->version = je32_to_cpu(rd->version);
diff -ruN linux-omap-2.6/fs/jffs2/security.c maemo_src/fs/jffs2/security.c
--- linux-omap-2.6/fs/jffs2/security.c	2011-02-06 19:45:03.149999939 -0500
+++ maemo_src/fs/jffs2/security.c	2007-10-02 03:09:32.000000000 -0400
@@ -37,9 +37,9 @@
 	}
 	rc = do_jffs2_setxattr(inode, JFFS2_XPREFIX_SECURITY, name, value, len, 0);
 
-        kfree(name);
-        kfree(value);
-        return rc;
+	kfree(name);
+	kfree(value);
+	return rc;
 }
 
 /* ---- XATTR Handler for "security.*" ----------------- */
diff -ruN linux-omap-2.6/fs/jffs2/super.c maemo_src/fs/jffs2/super.c
--- linux-omap-2.6/fs/jffs2/super.c	2011-02-06 19:45:03.153333272 -0500
+++ maemo_src/fs/jffs2/super.c	2007-10-02 03:09:32.000000000 -0400
@@ -78,6 +78,7 @@
 	.clear_inode =	jffs2_clear_inode,
 	.dirty_inode =	jffs2_dirty_inode,
 	.sync_fs =	jffs2_sync_fs,
+	.show_options = jffs2_rp_show_options,
 };
 
 static int jffs2_sb_compare(struct super_block *sb, void *data)
@@ -156,25 +157,31 @@
 #ifdef CONFIG_JFFS2_FS_POSIX_ACL
 	sb->s_flags |= MS_POSIXACL;
 #endif
-	ret = jffs2_do_fill_super(sb, data, flags & MS_SILENT ? 1 : 0);
+	/* Parse mount options */
+	ret = jffs2_rp_parse_options(sb, data);
+	if (ret)
+		goto error;
 
-	if (ret) {
-		/* Failure case... */
-		up_write(&sb->s_umount);
-		deactivate_super(sb);
-		return ret;
-	}
+	ret = jffs2_do_fill_super(sb, data, flags & MS_SILENT ? 1 : 0);
+	if (ret)
+		goto error;
 
 	sb->s_flags |= MS_ACTIVE;
 	return simple_set_mnt(mnt, sb);
 
 out_error:
 	ret = PTR_ERR(sb);
- out_put:
+out_put:
 	kfree(c);
 	put_mtd_device(mtd);
 
 	return ret;
+
+error:
+	/* Failure case... */
+	up_write(&sb->s_umount);
+	deactivate_super(sb);
+	return ret;
 }
 
 static int jffs2_get_sb_mtdnr(struct file_system_type *fs_type,
@@ -301,6 +308,7 @@
 	jffs2_flash_cleanup(c);
 	kfree(c->inocache_list);
 	jffs2_clear_xattr_subsystem(c);
+	jffs2_rp_free(c);
 	if (c->mtd->sync)
 		c->mtd->sync(c->mtd);
 
@@ -324,6 +332,54 @@
 	.kill_sb =	jffs2_kill_sb,
 };
 
+#ifdef CONFIG_JFFS2_SYSFS
+
+static struct attribute jffs2_attr_mode = {
+	.name = "compression_mode",
+	.mode = S_IRUGO | S_IWUSR,
+};
+
+static struct attribute *jffs2_attrs[] = {
+	&jffs2_attr_mode,
+	NULL,
+};
+
+static ssize_t jffs2_attr_show(struct kobject *kobj, struct attribute *attr,
+		char *page)
+{
+	if (!strcmp("compression_mode", attr->name))
+		return sprintf(page, "%s\n", jffs2_get_compression_mode_name());
+	return 0;
+}
+
+static ssize_t jffs2_attr_store(struct kobject *kobj, struct attribute *attr,
+		const char *page, size_t count)
+{
+	int ret = -EINVAL;
+
+	if (!strcmp("compression_mode", attr->name)) {
+		ret = jffs2_set_compression_mode_name(page);
+		if (ret >= 0)
+			return count;
+	}
+	return ret;
+}
+
+static struct sysfs_ops jffs2_sysfs_ops = {
+	.show	=	jffs2_attr_show,
+	.store	=	jffs2_attr_store,
+};
+
+static struct kobj_type jffs2_subsys_type = {
+	.default_attrs	= jffs2_attrs,
+	.sysfs_ops	= &jffs2_sysfs_ops,
+};
+
+/* gives us jffs2_subsys */
+static decl_subsys(jffs2, NULL, NULL);
+
+#endif
+
 static int __init init_jffs2_fs(void)
 {
 	int ret;
@@ -373,6 +429,16 @@
 		printk(KERN_ERR "JFFS2 error: Failed to register filesystem\n");
 		goto out_slab;
 	}
+
+#ifdef CONFIG_JFFS2_SYSFS
+	/* Errors here are not fatal */
+	kset_set_kset_s(&jffs2_subsys, fs_subsys);
+	jffs2_subsys.kset.kobj.ktype = &jffs2_subsys_type;
+	ret = subsystem_register(&jffs2_subsys);
+	if (ret)
+		printk(KERN_WARNING "Error registering JFFS2 sysfs attributes\n");
+#endif
+
 	return 0;
 
  out_slab:
@@ -386,6 +452,9 @@
 
 static void __exit exit_jffs2_fs(void)
 {
+#ifdef CONFIG_JFFS2_SYSFS
+	subsystem_unregister(&jffs2_subsys);
+#endif
 	unregister_filesystem(&jffs2_fs_type);
 	jffs2_destroy_slab_caches();
 	jffs2_compressors_exit();
diff -ruN linux-omap-2.6/fs/jffs2/wbuf.c maemo_src/fs/jffs2/wbuf.c
--- linux-omap-2.6/fs/jffs2/wbuf.c	2011-02-06 19:45:03.153333272 -0500
+++ maemo_src/fs/jffs2/wbuf.c	2007-10-02 03:09:32.000000000 -0400
@@ -345,6 +345,9 @@
 		return;
 	}
 
+	/* The summary is not recovered, so it must be disabled for this erase block */
+	jffs2_sum_disable_collecting(c->summary);
+
 	ret = jffs2_prealloc_raw_node_refs(c, c->nextblock, nr_refile);
 	if (ret) {
 		printk(KERN_WARNING "Failed to allocate node refs for wbuf recovery. Data loss ensues.\n");
@@ -962,8 +965,8 @@
 
 #define NR_OOB_SCAN_PAGES 4
 
-/* For historical reasons we use only 12 bytes for OOB clean marker */
-#define OOB_CM_SIZE 12
+/* For historical reasons we use only 8 bytes for OOB clean marker */
+#define OOB_CM_SIZE 8
 
 static const struct jffs2_unknown_node oob_cleanmarker =
 {
@@ -1017,8 +1020,8 @@
 /*
  * Check for a valid cleanmarker.
  * Returns: 0 if a valid cleanmarker was found
- *          1 if no cleanmarker was found
- *          negative error code if an error occurred
+ *	    1 if no cleanmarker was found
+ *	    negative error code if an error occurred
  */
 int jffs2_check_nand_cleanmarker(struct jffs2_sb_info *c,
 				 struct jffs2_eraseblock *jeb)
diff -ruN linux-omap-2.6/fs/jffs2/write.c maemo_src/fs/jffs2/write.c
--- linux-omap-2.6/fs/jffs2/write.c	2011-02-06 19:45:03.156666606 -0500
+++ maemo_src/fs/jffs2/write.c	2007-10-02 03:09:32.000000000 -0400
@@ -175,6 +175,12 @@
 		flash_ofs |= REF_NORMAL;
 	}
 	fn->raw = jffs2_add_physical_node_ref(c, flash_ofs, PAD(sizeof(*ri)+datalen), f->inocache);
+	if (IS_ERR(fn->raw)) {
+		void *hold_err = fn->raw;
+		/* Release the full_dnode which is now useless, and return */
+		jffs2_free_full_dnode(fn);
+		return ERR_PTR(PTR_ERR(hold_err));
+	}
 	fn->ofs = je32_to_cpu(ri->offset);
 	fn->size = je32_to_cpu(ri->dsize);
 	fn->frags = 0;
@@ -292,7 +298,14 @@
 		return ERR_PTR(ret?ret:-EIO);
 	}
 	/* Mark the space used */
-	fd->raw = jffs2_add_physical_node_ref(c, flash_ofs | REF_PRISTINE, PAD(sizeof(*rd)+namelen), f->inocache);
+	fd->raw = jffs2_add_physical_node_ref(c, flash_ofs | dirent_node_state(rd),
+					      PAD(sizeof(*rd)+namelen), f->inocache);
+	if (IS_ERR(fd->raw)) {
+		void *hold_err = fd->raw;
+		/* Release the full_dirent which is now useless, and return */
+		jffs2_free_full_dirent(fd);
+		return ERR_PTR(PTR_ERR(hold_err));
+	}
 
 	if (retried) {
 		jffs2_dbg_acct_sanity_check(c,NULL);
diff -ruN linux-omap-2.6/fs/jffs2/xattr.h maemo_src/fs/jffs2/xattr.h
--- linux-omap-2.6/fs/jffs2/xattr.h	2011-02-06 19:45:03.156666606 -0500
+++ maemo_src/fs/jffs2/xattr.h	2007-10-02 03:09:32.000000000 -0400
@@ -74,7 +74,7 @@
 extern void jffs2_clear_xattr_subsystem(struct jffs2_sb_info *c);
 
 extern struct jffs2_xattr_datum *jffs2_setup_xattr_datum(struct jffs2_sb_info *c,
-                                                  uint32_t xid, uint32_t version);
+							 uint32_t xid, uint32_t version);
 
 extern void jffs2_xattr_delete_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic);
 extern void jffs2_xattr_free_inode(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic);
diff -ruN linux-omap-2.6/fs/jffs2/xattr_user.c maemo_src/fs/jffs2/xattr_user.c
--- linux-omap-2.6/fs/jffs2/xattr_user.c	2011-02-06 19:45:03.156666606 -0500
+++ maemo_src/fs/jffs2/xattr_user.c	2007-10-02 03:09:32.000000000 -0400
@@ -16,7 +16,7 @@
 #include "nodelist.h"
 
 static int jffs2_user_getxattr(struct inode *inode, const char *name,
-                               void *buffer, size_t size)
+			       void *buffer, size_t size)
 {
 	if (!strcmp(name, ""))
 		return -EINVAL;
@@ -24,7 +24,7 @@
 }
 
 static int jffs2_user_setxattr(struct inode *inode, const char *name, const void *buffer,
-                               size_t size, int flags)
+			       size_t size, int flags)
 {
 	if (!strcmp(name, ""))
 		return -EINVAL;
diff -ruN linux-omap-2.6/fs/Kconfig maemo_src/fs/Kconfig
--- linux-omap-2.6/fs/Kconfig	2011-02-06 19:45:02.323333273 -0500
+++ maemo_src/fs/Kconfig	2007-10-02 03:09:32.000000000 -0400
@@ -1283,6 +1283,15 @@
 	  If you are not using a security module that requires using
 	  extended attributes for file security labels, say N.
 
+config JFFS2_SYSFS
+	bool "JFFS2 sysfs attributes"
+	depends on JFFS2_FS
+	default n
+	help
+	  Enable control of jffs2 features through sysfs.
+
+	  If unsure, say 'N'.
+
 config JFFS2_COMPRESSION_OPTIONS
 	bool "Advanced compression options for JFFS2"
 	depends on JFFS2_FS
@@ -1310,6 +1319,17 @@
 
           Say 'Y' if unsure.
 
+config JFFS2_LZO
+	bool "JFFS2 LZO compression support" if JFFS2_COMPRESSION_OPTIONS
+	select LZO_COMPRESS
+	select LZO_DECOMPRESS
+	depends on JFFS2_FS
+	default y
+        help
+          minilzo-based compression. Generally works better than Zlib.
+
+          Say 'Y' if unsure.
+
 config JFFS2_RTIME
 	bool "JFFS2 RTIME compression support" if JFFS2_COMPRESSION_OPTIONS
 	depends on JFFS2_FS
@@ -1349,6 +1369,13 @@
           Tries all compressors and chooses the one which has the smallest
           result.
 
+config JFFS2_CMODE_FAVOURLZO
+        bool "Favour LZO"
+        help
+          Tries all compressors and chooses the one which has the smallest
+          result but gives some preference to LZO (which has faster
+	  decompression) at the expense of size.
+
 endchoice
 
 config CRAMFS
diff -ruN linux-omap-2.6/.git/config maemo_src/.git/config
--- linux-omap-2.6/.git/config	2011-02-06 19:37:35.033333271 -0500
+++ maemo_src/.git/config	1969-12-31 19:00:00.000000000 -0500
@@ -1,11 +0,0 @@
-[core]
-	repositoryformatversion = 0
-	filemode = true
-	bare = false
-	logallrefupdates = true
-[remote "origin"]
-	fetch = +refs/heads/*:refs/remotes/origin/*
-	url = git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap-2.6.git
-[branch "master"]
-	remote = origin
-	merge = refs/heads/master
diff -ruN linux-omap-2.6/.git/description maemo_src/.git/description
--- linux-omap-2.6/.git/description	2011-02-06 19:13:56.629999940 -0500
+++ maemo_src/.git/description	1969-12-31 19:00:00.000000000 -0500
@@ -1 +0,0 @@
-Unnamed repository; edit this file 'description' to name the repository.
diff -ruN linux-omap-2.6/.git/HEAD maemo_src/.git/HEAD
--- linux-omap-2.6/.git/HEAD	2011-02-06 19:37:34.973333272 -0500
+++ maemo_src/.git/HEAD	1969-12-31 19:00:00.000000000 -0500
@@ -1 +0,0 @@
-ref: refs/heads/master
diff -ruN linux-omap-2.6/.git/hooks/applypatch-msg.sample maemo_src/.git/hooks/applypatch-msg.sample
--- linux-omap-2.6/.git/hooks/applypatch-msg.sample	2011-02-06 19:13:56.633333273 -0500
+++ maemo_src/.git/hooks/applypatch-msg.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,15 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to check the commit log message taken by
-# applypatch from an e-mail message.
-#
-# The hook should exit with non-zero status after issuing an
-# appropriate message if it wants to stop the commit.  The hook is
-# allowed to edit the commit message file.
-#
-# To enable this hook, rename this file to "applypatch-msg".
-
-. git-sh-setup
-test -x "$GIT_DIR/hooks/commit-msg" &&
-	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
-:
diff -ruN linux-omap-2.6/.git/hooks/commit-msg.sample maemo_src/.git/hooks/commit-msg.sample
--- linux-omap-2.6/.git/hooks/commit-msg.sample	2011-02-06 19:13:56.633333273 -0500
+++ maemo_src/.git/hooks/commit-msg.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,24 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to check the commit log message.
-# Called by "git commit" with one argument, the name of the file
-# that has the commit message.  The hook should exit with non-zero
-# status after issuing an appropriate message if it wants to stop the
-# commit.  The hook is allowed to edit the commit message file.
-#
-# To enable this hook, rename this file to "commit-msg".
-
-# Uncomment the below to add a Signed-off-by line to the message.
-# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
-# hook is more suited to it.
-#
-# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
-# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
-
-# This example catches duplicate Signed-off-by lines.
-
-test "" = "$(grep '^Signed-off-by: ' "$1" |
-	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
-	echo >&2 Duplicate Signed-off-by lines.
-	exit 1
-}
diff -ruN linux-omap-2.6/.git/hooks/post-commit.sample maemo_src/.git/hooks/post-commit.sample
--- linux-omap-2.6/.git/hooks/post-commit.sample	2011-02-06 19:13:56.633333273 -0500
+++ maemo_src/.git/hooks/post-commit.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,8 +0,0 @@
-#!/bin/sh
-#
-# An example hook script that is called after a successful
-# commit is made.
-#
-# To enable this hook, rename this file to "post-commit".
-
-: Nothing
diff -ruN linux-omap-2.6/.git/hooks/post-receive.sample maemo_src/.git/hooks/post-receive.sample
--- linux-omap-2.6/.git/hooks/post-receive.sample	2011-02-06 19:13:56.633333273 -0500
+++ maemo_src/.git/hooks/post-receive.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,15 +0,0 @@
-#!/bin/sh
-#
-# An example hook script for the "post-receive" event.
-#
-# The "post-receive" script is run after receive-pack has accepted a pack
-# and the repository has been updated.  It is passed arguments in through
-# stdin in the form
-#  <oldrev> <newrev> <refname>
-# For example:
-#  aa453216d1b3e49e7f6f98441fa56946ddcd6a20 68f7abf4e6f922807889f52bc043ecd31b79f814 refs/heads/master
-#
-# see contrib/hooks/ for a sample, or uncomment the next line and
-# rename the file to "post-receive".
-
-#. /usr/share/doc/git-core/contrib/hooks/post-receive-email
diff -ruN linux-omap-2.6/.git/hooks/post-update.sample maemo_src/.git/hooks/post-update.sample
--- linux-omap-2.6/.git/hooks/post-update.sample	2011-02-06 19:13:56.633333273 -0500
+++ maemo_src/.git/hooks/post-update.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,8 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to prepare a packed repository for use over
-# dumb transports.
-#
-# To enable this hook, rename this file to "post-update".
-
-exec git update-server-info
diff -ruN linux-omap-2.6/.git/hooks/pre-applypatch.sample maemo_src/.git/hooks/pre-applypatch.sample
--- linux-omap-2.6/.git/hooks/pre-applypatch.sample	2011-02-06 19:13:56.633333273 -0500
+++ maemo_src/.git/hooks/pre-applypatch.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed
-# by applypatch from an e-mail message.
-#
-# The hook should exit with non-zero status after issuing an
-# appropriate message if it wants to stop the commit.
-#
-# To enable this hook, rename this file to "pre-applypatch".
-
-. git-sh-setup
-test -x "$GIT_DIR/hooks/pre-commit" &&
-	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
-:
diff -ruN linux-omap-2.6/.git/hooks/pre-commit.sample maemo_src/.git/hooks/pre-commit.sample
--- linux-omap-2.6/.git/hooks/pre-commit.sample	2011-02-06 19:13:56.629999940 -0500
+++ maemo_src/.git/hooks/pre-commit.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,46 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed.
-# Called by "git commit" with no arguments.  The hook should
-# exit with non-zero status after issuing an appropriate message if
-# it wants to stop the commit.
-#
-# To enable this hook, rename this file to "pre-commit".
-
-if git rev-parse --verify HEAD >/dev/null 2>&1
-then
-	against=HEAD
-else
-	# Initial commit: diff against an empty tree object
-	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
-fi
-
-# If you want to allow non-ascii filenames set this variable to true.
-allownonascii=$(git config hooks.allownonascii)
-
-# Cross platform projects tend to avoid non-ascii filenames; prevent
-# them from being added to the repository. We exploit the fact that the
-# printable range starts at the space character and ends with tilde.
-if [ "$allownonascii" != "true" ] &&
-	# Note that the use of brackets around a tr range is ok here, (it's
-	# even required, for portability to Solaris 10's /usr/bin/tr), since
-	# the square bracket bytes happen to fall in the designated range.
-	test "$(git diff --cached --name-only --diff-filter=A -z $against |
-	  LC_ALL=C tr -d '[ -~]\0')"
-then
-	echo "Error: Attempt to add a non-ascii file name."
-	echo
-	echo "This can cause problems if you want to work"
-	echo "with people on other platforms."
-	echo
-	echo "To be portable it is advisable to rename the file ..."
-	echo
-	echo "If you know what you are doing you can disable this"
-	echo "check using:"
-	echo
-	echo "  git config hooks.allownonascii true"
-	echo
-	exit 1
-fi
-
-exec git diff-index --check --cached $against --
diff -ruN linux-omap-2.6/.git/hooks/prepare-commit-msg.sample maemo_src/.git/hooks/prepare-commit-msg.sample
--- linux-omap-2.6/.git/hooks/prepare-commit-msg.sample	2011-02-06 19:13:56.633333273 -0500
+++ maemo_src/.git/hooks/prepare-commit-msg.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,36 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to prepare the commit log message.
-# Called by "git commit" with the name of the file that has the
-# commit message, followed by the description of the commit
-# message's source.  The hook's purpose is to edit the commit
-# message file.  If the hook fails with a non-zero status,
-# the commit is aborted.
-#
-# To enable this hook, rename this file to "prepare-commit-msg".
-
-# This hook includes three examples.  The first comments out the
-# "Conflicts:" part of a merge commit.
-#
-# The second includes the output of "git diff --name-status -r"
-# into the message, just before the "git status" output.  It is
-# commented because it doesn't cope with --amend or with squashed
-# commits.
-#
-# The third example adds a Signed-off-by line to the message, that can
-# still be edited.  This is rarely a good idea.
-
-case "$2,$3" in
-  merge,)
-    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
-
-# ,|template,)
-#   /usr/bin/perl -i.bak -pe '
-#      print "\n" . `git diff --cached --name-status -r`
-#	 if /^#/ && $first++ == 0' "$1" ;;
-
-  *) ;;
-esac
-
-# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
-# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
diff -ruN linux-omap-2.6/.git/hooks/pre-rebase.sample maemo_src/.git/hooks/pre-rebase.sample
--- linux-omap-2.6/.git/hooks/pre-rebase.sample	2011-02-06 19:13:56.633333273 -0500
+++ maemo_src/.git/hooks/pre-rebase.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,169 +0,0 @@
-#!/bin/sh
-#
-# Copyright (c) 2006, 2008 Junio C Hamano
-#
-# The "pre-rebase" hook is run just before "git rebase" starts doing
-# its job, and can prevent the command from running by exiting with
-# non-zero status.
-#
-# The hook is called with the following parameters:
-#
-# $1 -- the upstream the series was forked from.
-# $2 -- the branch being rebased (or empty when rebasing the current branch).
-#
-# This sample shows how to prevent topic branches that are already
-# merged to 'next' branch from getting rebased, because allowing it
-# would result in rebasing already published history.
-
-publish=next
-basebranch="$1"
-if test "$#" = 2
-then
-	topic="refs/heads/$2"
-else
-	topic=`git symbolic-ref HEAD` ||
-	exit 0 ;# we do not interrupt rebasing detached HEAD
-fi
-
-case "$topic" in
-refs/heads/??/*)
-	;;
-*)
-	exit 0 ;# we do not interrupt others.
-	;;
-esac
-
-# Now we are dealing with a topic branch being rebased
-# on top of master.  Is it OK to rebase it?
-
-# Does the topic really exist?
-git show-ref -q "$topic" || {
-	echo >&2 "No such branch $topic"
-	exit 1
-}
-
-# Is topic fully merged to master?
-not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
-if test -z "$not_in_master"
-then
-	echo >&2 "$topic is fully merged to master; better remove it."
-	exit 1 ;# we could allow it, but there is no point.
-fi
-
-# Is topic ever merged to next?  If so you should not be rebasing it.
-only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
-only_next_2=`git rev-list ^master           ${publish} | sort`
-if test "$only_next_1" = "$only_next_2"
-then
-	not_in_topic=`git rev-list "^$topic" master`
-	if test -z "$not_in_topic"
-	then
-		echo >&2 "$topic is already up-to-date with master"
-		exit 1 ;# we could allow it, but there is no point.
-	else
-		exit 0
-	fi
-else
-	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
-	/usr/bin/perl -e '
-		my $topic = $ARGV[0];
-		my $msg = "* $topic has commits already merged to public branch:\n";
-		my (%not_in_next) = map {
-			/^([0-9a-f]+) /;
-			($1 => 1);
-		} split(/\n/, $ARGV[1]);
-		for my $elem (map {
-				/^([0-9a-f]+) (.*)$/;
-				[$1 => $2];
-			} split(/\n/, $ARGV[2])) {
-			if (!exists $not_in_next{$elem->[0]}) {
-				if ($msg) {
-					print STDERR $msg;
-					undef $msg;
-				}
-				print STDERR " $elem->[1]\n";
-			}
-		}
-	' "$topic" "$not_in_next" "$not_in_master"
-	exit 1
-fi
-
-exit 0
-
-################################################################
-
-This sample hook safeguards topic branches that have been
-published from being rewound.
-
-The workflow assumed here is:
-
- * Once a topic branch forks from "master", "master" is never
-   merged into it again (either directly or indirectly).
-
- * Once a topic branch is fully cooked and merged into "master",
-   it is deleted.  If you need to build on top of it to correct
-   earlier mistakes, a new topic branch is created by forking at
-   the tip of the "master".  This is not strictly necessary, but
-   it makes it easier to keep your history simple.
-
- * Whenever you need to test or publish your changes to topic
-   branches, merge them into "next" branch.
-
-The script, being an example, hardcodes the publish branch name
-to be "next", but it is trivial to make it configurable via
-$GIT_DIR/config mechanism.
-
-With this workflow, you would want to know:
-
-(1) ... if a topic branch has ever been merged to "next".  Young
-    topic branches can have stupid mistakes you would rather
-    clean up before publishing, and things that have not been
-    merged into other branches can be easily rebased without
-    affecting other people.  But once it is published, you would
-    not want to rewind it.
-
-(2) ... if a topic branch has been fully merged to "master".
-    Then you can delete it.  More importantly, you should not
-    build on top of it -- other people may already want to
-    change things related to the topic as patches against your
-    "master", so if you need further changes, it is better to
-    fork the topic (perhaps with the same name) afresh from the
-    tip of "master".
-
-Let's look at this example:
-
-		   o---o---o---o---o---o---o---o---o---o "next"
-		  /       /           /           /
-		 /   a---a---b A     /           /
-		/   /               /           /
-	       /   /   c---c---c---c B         /
-	      /   /   /             \         /
-	     /   /   /   b---b C     \       /
-	    /   /   /   /             \     /
-    ---o---o---o---o---o---o---o---o---o---o---o "master"
-
-
-A, B and C are topic branches.
-
- * A has one fix since it was merged up to "next".
-
- * B has finished.  It has been fully merged up to "master" and "next",
-   and is ready to be deleted.
-
- * C has not merged to "next" at all.
-
-We would want to allow C to be rebased, refuse A, and encourage
-B to be deleted.
-
-To compute (1):
-
-	git rev-list ^master ^topic next
-	git rev-list ^master        next
-
-	if these match, topic has not merged in next at all.
-
-To compute (2):
-
-	git rev-list master..topic
-
-	if this is empty, it is fully merged to "master".
diff -ruN linux-omap-2.6/.git/hooks/update.sample maemo_src/.git/hooks/update.sample
--- linux-omap-2.6/.git/hooks/update.sample	2011-02-06 19:13:56.633333273 -0500
+++ maemo_src/.git/hooks/update.sample	1969-12-31 19:00:00.000000000 -0500
@@ -1,128 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to blocks unannotated tags from entering.
-# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
-#
-# To enable this hook, rename this file to "update".
-#
-# Config
-# ------
-# hooks.allowunannotated
-#   This boolean sets whether unannotated tags will be allowed into the
-#   repository.  By default they won't be.
-# hooks.allowdeletetag
-#   This boolean sets whether deleting tags will be allowed in the
-#   repository.  By default they won't be.
-# hooks.allowmodifytag
-#   This boolean sets whether a tag may be modified after creation. By default
-#   it won't be.
-# hooks.allowdeletebranch
-#   This boolean sets whether deleting branches will be allowed in the
-#   repository.  By default they won't be.
-# hooks.denycreatebranch
-#   This boolean sets whether remotely creating branches will be denied
-#   in the repository.  By default this is allowed.
-#
-
-# --- Command line
-refname="$1"
-oldrev="$2"
-newrev="$3"
-
-# --- Safety check
-if [ -z "$GIT_DIR" ]; then
-	echo "Don't run this script from the command line." >&2
-	echo " (if you want, you could supply GIT_DIR then run" >&2
-	echo "  $0 <ref> <oldrev> <newrev>)" >&2
-	exit 1
-fi
-
-if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
-	echo "Usage: $0 <ref> <oldrev> <newrev>" >&2
-	exit 1
-fi
-
-# --- Config
-allowunannotated=$(git config --bool hooks.allowunannotated)
-allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
-denycreatebranch=$(git config --bool hooks.denycreatebranch)
-allowdeletetag=$(git config --bool hooks.allowdeletetag)
-allowmodifytag=$(git config --bool hooks.allowmodifytag)
-
-# check for no description
-projectdesc=$(sed -e '1q' "$GIT_DIR/description")
-case "$projectdesc" in
-"Unnamed repository"* | "")
-	echo "*** Project description file hasn't been set" >&2
-	exit 1
-	;;
-esac
-
-# --- Check types
-# if $newrev is 0000...0000, it's a commit to delete a ref.
-zero="0000000000000000000000000000000000000000"
-if [ "$newrev" = "$zero" ]; then
-	newrev_type=delete
-else
-	newrev_type=$(git cat-file -t $newrev)
-fi
-
-case "$refname","$newrev_type" in
-	refs/tags/*,commit)
-		# un-annotated tag
-		short_refname=${refname##refs/tags/}
-		if [ "$allowunannotated" != "true" ]; then
-			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
-			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
-			exit 1
-		fi
-		;;
-	refs/tags/*,delete)
-		# delete tag
-		if [ "$allowdeletetag" != "true" ]; then
-			echo "*** Deleting a tag is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/tags/*,tag)
-		# annotated tag
-		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
-		then
-			echo "*** Tag '$refname' already exists." >&2
-			echo "*** Modifying a tag is not allowed in this repository." >&2
-			exit 1
-		fi
-		;;
-	refs/heads/*,commit)
-		# branch
-		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
-			echo "*** Creating a branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/heads/*,delete)
-		# delete branch
-		if [ "$allowdeletebranch" != "true" ]; then
-			echo "*** Deleting a branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/remotes/*,commit)
-		# tracking branch
-		;;
-	refs/remotes/*,delete)
-		# delete tracking branch
-		if [ "$allowdeletebranch" != "true" ]; then
-			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	*)
-		# Anything else (is there anything else?)
-		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
-		exit 1
-		;;
-esac
-
-# --- Finished
-exit 0
Binary files linux-omap-2.6/.git/index and maemo_src/.git/index differ
diff -ruN linux-omap-2.6/.git/info/exclude maemo_src/.git/info/exclude
--- linux-omap-2.6/.git/info/exclude	2011-02-06 19:13:56.629999940 -0500
+++ maemo_src/.git/info/exclude	1969-12-31 19:00:00.000000000 -0500
@@ -1,6 +0,0 @@
-# git ls-files --others --exclude-from=.git/info/exclude
-# Lines that start with '#' are comments.
-# For a project mostly in C, the following would be a good set of
-# exclude patterns (uncomment them if you want to use them):
-# *.[oa]
-# *~
diff -ruN linux-omap-2.6/.git/logs/HEAD maemo_src/.git/logs/HEAD
--- linux-omap-2.6/.git/logs/HEAD	2011-02-06 20:17:26.289999939 -0500
+++ maemo_src/.git/logs/HEAD	1969-12-31 19:00:00.000000000 -0500
@@ -1,4 +0,0 @@
-0000000000000000000000000000000000000000 6cd5fb725cb1e89c58de6be59a7ff8fda32e4ffa Chuan Ji <chuan@Profox.localdomain> 1297039055 -0500	clone: from git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap-2.6.git
-6cd5fb725cb1e89c58de6be59a7ff8fda32e4ffa 78e73e07e27783951ba64da4a3012b84b43b7b90 Chuan Ji <chuan@Profox.localdomain> 1297039517 -0500	v2.6.21-omap1: updating HEAD
-78e73e07e27783951ba64da4a3012b84b43b7b90 de46c33745f5e2ad594c72f2cf5f490861b16ce1 Chuan Ji <chuan@Profox.localdomain> 1297041183 -0500	v2.6.21: updating HEAD
-de46c33745f5e2ad594c72f2cf5f490861b16ce1 78e73e07e27783951ba64da4a3012b84b43b7b90 Chuan Ji <chuan@Profox.localdomain> 1297041446 -0500	v2.6.21-omap1: updating HEAD
diff -ruN linux-omap-2.6/.git/logs/refs/heads/master maemo_src/.git/logs/refs/heads/master
--- linux-omap-2.6/.git/logs/refs/heads/master	2011-02-06 20:17:26.289999939 -0500
+++ maemo_src/.git/logs/refs/heads/master	1969-12-31 19:00:00.000000000 -0500
@@ -1,4 +0,0 @@
-0000000000000000000000000000000000000000 6cd5fb725cb1e89c58de6be59a7ff8fda32e4ffa Chuan Ji <chuan@Profox.localdomain> 1297039055 -0500	clone: from git://git.kernel.org/pub/scm/linux/kernel/git/tmlind/linux-omap-2.6.git
-6cd5fb725cb1e89c58de6be59a7ff8fda32e4ffa 78e73e07e27783951ba64da4a3012b84b43b7b90 Chuan Ji <chuan@Profox.localdomain> 1297039517 -0500	v2.6.21-omap1: updating HEAD
-78e73e07e27783951ba64da4a3012b84b43b7b90 de46c33745f5e2ad594c72f2cf5f490861b16ce1 Chuan Ji <chuan@Profox.localdomain> 1297041183 -0500	v2.6.21: updating HEAD
-de46c33745f5e2ad594c72f2cf5f490861b16ce1 78e73e07e27783951ba64da4a3012b84b43b7b90 Chuan Ji <chuan@Profox.localdomain> 1297041446 -0500	v2.6.21-omap1: updating HEAD
Binary files linux-omap-2.6/.git/objects/pack/pack-c6b6157d0b1c3129949dd0a41f496b7d9ee7e33d.idx and maemo_src/.git/objects/pack/pack-c6b6157d0b1c3129949dd0a41f496b7d9ee7e33d.idx differ
Binary files linux-omap-2.6/.git/objects/pack/pack-c6b6157d0b1c3129949dd0a41f496b7d9ee7e33d.pack and maemo_src/.git/objects/pack/pack-c6b6157d0b1c3129949dd0a41f496b7d9ee7e33d.pack differ
diff -ruN linux-omap-2.6/.git/ORIG_HEAD maemo_src/.git/ORIG_HEAD
--- linux-omap-2.6/.git/ORIG_HEAD	2011-02-06 20:17:26.289999939 -0500
+++ maemo_src/.git/ORIG_HEAD	1969-12-31 19:00:00.000000000 -0500
@@ -1 +0,0 @@
-de46c33745f5e2ad594c72f2cf5f490861b16ce1
diff -ruN linux-omap-2.6/.git/packed-refs maemo_src/.git/packed-refs
--- linux-omap-2.6/.git/packed-refs	2011-02-06 19:37:34.866666606 -0500
+++ maemo_src/.git/packed-refs	1969-12-31 19:00:00.000000000 -0500
@@ -1,492 +0,0 @@
-# pack-refs with: peeled 
-70f1e06182fab9290a1f7775ade996e4854dec3a refs/tags/v2.6.38-rc3
-^ebf53826e105f488f4f628703a108e98940d1dc5
-182a43159a3ea400594ca05ce7ff5052950a1010 refs/tags/v2.6.38-rc2
-^1bae4ce27c9c90344f23c65ea6966c50ffeae2f5
-aa6741cead5660406a453c01b6e37cbe06d52433 refs/tags/v2.6.38-rc1
-^c56eb8fb6dccb83d9fe62fd4dc00c834de9bc470
-5720e551140dd586156e9875b0d1ef528e9c5f59 refs/tags/v2.6.37-rc8
-^387c31c7e5c9805b0aef8833d1731a5fe7bdea14
-6261d1ea5bdbc9baf84c192242c82e63cdb02788 refs/tags/v2.6.37-rc7
-^90a8a73c06cc32b609a880d48449d7083327e11a
-3f4ddf273ce92382ad3ce55fde3d773bd9e4bddd refs/tags/v2.6.37-rc6
-^b0c3844d8af6b9f3f18f31e1b0502fbefa2166be
-f9459ed00525f440d25d7c88fe8d52abd3746066 refs/tags/v2.6.37-rc5
-^cf7d7e5a1980d1116ee152d25dac382b112b9c17
-78d3494aa9e5cbd28600b5440655b263ab1c0efd refs/tags/v2.6.37-rc4
-^e8a7e48bb248a1196484d3f8afa53bded2b24e71
-8a198c8196ac3716e1856978d3e18cca5d800ef3 refs/tags/v2.6.37-rc3
-^3561d43fd289f590fdae672e5eb831b8d5cf0bf6
-a1e4aaecda4a52e850e90d4f95ed2f59955ed057 refs/tags/v2.6.37-rc2
-^e53beacd23d9cb47590da6a7a7f6d417b941a994
-579cc3d8b5840f3355bad58e7ab23eae04ff9cb6 refs/tags/v2.6.37-rc1
-^c8ddb2713c624f432fa5fe3c7ecffcdda46ea0d4
-4a7895f41220ed60e97b736ac1b92e589e67b263 refs/tags/v2.6.37
-^3c0eee3fe6a3a1c745379547c7e7c904aa64f6d5
-7619e63f48822b2c68d0e108677340573873fb93 refs/tags/v2.6.36-rc8
-^cd07202cc8262e1669edff0d97715f3dd9260917
-f3f2d2543afa76bcc13a58fc6a1ff723f28890da refs/tags/v2.6.36-rc7
-^cb655d0f3d57c23db51b981648e452988c0223f9
-93590f17a2e3ba2aed400c7608263b97da62b6d4 refs/tags/v2.6.36-rc6
-^899611ee7d373e5eeda08e9a8632684e1ebbbf00
-f4d2c86897046fb2dd9680b3446dfcc17a11e7f4 refs/tags/v2.6.36-rc5
-^b30a3f6257ed2105259b404d419b4964e363928c
-8607f6908a65fbd41d8eee6d0572425182eced69 refs/tags/v2.6.36-rc4
-^49553c2ef88749dd502687f4eb9c258bb10a4f44
-40f7ec041a61c6b6d419e418818c79f7c23a1007 refs/tags/v2.6.36-rc3
-^2bfc96a127bc1cc94d26bfaa40159966064f9c8c
-58d3707b8891f71d4891e6b36129eeacd3ba63f4 refs/tags/v2.6.36-rc2
-^76be97c1fc945db08aae1f1b746012662d643e97
-8ed88d401f908a594cd74a4f2513b0fabd32b699 refs/tags/v2.6.36-rc1
-^da5cabf80e2433131bf0ed8993abc0f7ea618c73
-25427f38d3b791d986812cb81c68df38e8249ef8 refs/tags/v2.6.36
-^f6f94e2ab1b33f0082ac22d71f66385a60d8157f
-37a3bd34ba0892f0f1c1a0a03b06d61ed3c554c1 refs/tags/v2.6.35-rc6
-^b37fa16e78d6f9790462b3181602a26b5af36260
-1dd55af06d281ffbc945cd7bb21cfb98d6e84a99 refs/tags/v2.6.35-rc5
-^1c5474a65bf15a4cb162dfff86d6d0b5a08a740c
-55acf6b6533581f03df07ddd166c6631bc304845 refs/tags/v2.6.35-rc4
-^815c4163b6c8ebf8152f42b0a5fd015cfdcedc78
-f51882c32dcbec0befa48e12682f1651c4772b7b refs/tags/v2.6.35-rc3
-^7e27d6e778cd87b6f2415515d7127eba53fe5d02
-06006d039fbf390b87b5ee76d16187b5cb9b3f4d refs/tags/v2.6.35-rc2
-^e44a21b7268a022c7749f521c06214145bd161e4
-77cb4411c86825cf693e338fada52dfca3345668 refs/tags/v2.6.35-rc1
-^67a3e12b05e055c0415c556a315a3d3eb637e29e
-d786bf1b8352facdde8cc28725e1e6e067e1854d refs/tags/v2.6.35
-^9fe6206f400646a2322096b56c59891d530e8d51
-3884cbfac5cf610a7116ca90a970a11cf495bb83 refs/tags/v2.6.34-rc7
-^b57f95a38233a2e73b679bea4a5453a1cc2a1cc9
-1b5265c5905fdc68873d37c902adc4aec2cbd6a3 refs/tags/v2.6.34-rc6
-^66f41d4c5c8a5deed66fdcc84509376c9a0bf9d8
-d1744e136396b363e5844ed5f928e40067b5784a refs/tags/v2.6.34-rc5
-^01bf0b64579ead8a82e7cfc32ae44bc667e7ad0f
-cb0cbeb16ff949783023da2270d5af36af416865 refs/tags/v2.6.34-rc4
-^0d0fb0f9c5fddef4a10242fe3337f00f528a3099
-fc2199137e85558e1f8f2bf44e0d3fa2b5cc4371 refs/tags/v2.6.34-rc3
-^2eaa9cfdf33b8d7fb7aff27792192e0019ae8fc6
-2fc56a2a7aa32adeddf7efe074b38cbdbb41894a refs/tags/v2.6.34-rc2
-^220bf991b0366cc50a94feede3d7341fa5710ee4
-fe2098f5dff78881162f71ae028384435681a90a refs/tags/v2.6.34-rc1
-^57d54889cd00db2752994b389ba714138652e60c
-dba2e709efc365df385a762e763b51365403bc0f refs/tags/v2.6.34
-^e40152ee1e1c7a63f4777791863215e3faa37a86
-22ebef85968508e596dc60d970b716024cb9a34e refs/tags/v2.6.33-rc8
-^724e6d3fe8003c3f60bf404bf22e4e331327c596
-600255d9e9ec0eecc49be78197c630504cf8c263 refs/tags/v2.6.33-rc7
-^29275254caedfedce960cfe6df24b90cb04fe431
-b02c43040da3d3e4f56d34d443c4c2a0d41da367 refs/tags/v2.6.33-rc6
-^abe94c756c08d50566c09a65b9c7fe72f83071c5
-76efcb71c910774213480cdfe20b73e07c6a00aa refs/tags/v2.6.33-rc5
-^92dcffb916d309aa01778bf8963a6932e4014d07
-5ba7808eabc37cb2464096077d0df55f33148245 refs/tags/v2.6.33-rc4
-^7284ce6c9f6153d1777df5f310c959724d1bd446
-31fdc15b99788540d0ee8b8b337242e38489f603 refs/tags/v2.6.33-rc3
-^74d2e4f8d79ae0c4b6ec027958d5b18058662eea
-331ce84170c8ebba5f0fadac64f66d6f00a438e4 refs/tags/v2.6.33-rc2
-^6b7b284958d47b77d06745b36bc7f36dab769d9b
-d14e040a3592de665407269688d70296955c5f14 refs/tags/v2.6.33-rc1
-^55639353a0035052d9ea6cfe4dde0ac7fcbb2c9f
-4ac8e07ee3f251ae32329a24e0b01a316b21ead9 refs/tags/v2.6.33
-^60b341b778cc2929df16c0a504c91621b3c6a4ad
-de8a4af91ab6fa3cde2618f4021b5faabdcd95ea refs/tags/v2.6.32-rc8
-^648f4e3e50c4793d9dbf9a09afa193631f76fa26
-5946e9740318d61b3d1c3d7bfdc3b54fc3ac181c refs/tags/v2.6.32-rc7
-^156171c71a0dc4bce12b4408bb1591f8fe32dc1a
-53a1963436f23ee8b6fa29a5ebcd925a9912594b refs/tags/v2.6.32-rc6
-^b419148e567728f6af0c3b01965c1cc141e3e13a
-c6add0a844533aeaa7bf86dcd4f924dca085d287 refs/tags/v2.6.32-rc5
-^012abeea669ea49636cf952d13298bb68654146a
-742a213497d587595f23674eafad1e520c5af6bd refs/tags/v2.6.32-rc4
-^161291396e76e0832c08f617eb9bd364d1648148
-910eff4ec30f648f297700d43784b2159d35fb4f refs/tags/v2.6.32-rc3
-^374576a8b6f865022c0fd1ca62396889b23d66dd
-1016bf08944977a33d3a48edc15ee34b425f6d8a refs/tags/v2.6.32-rc2
-^17d857be649a21ca90008c6dc425d849fa83db5c
-1016bf08944977a33d3a48edc15ee34b425f6d8a refs/tags/v2.6.32-rc1
-^17d857be649a21ca90008c6dc425d849fa83db5c
-2a20002a83ce565ed16aaec5e64151cae165cb8f refs/tags/v2.6.32-omap1
-459b3d520991ec1b8e5ba68fbc4b206d602fee6e refs/tags/v2.6.32
-^22763c5cf3690a681551162c15d34d935308c8d7
-0827eb5df631ed1756653faf74248a9524f202cd refs/tags/v2.6.31-rc9
-^e07cccf4046978df10f2e13fe2b99b2f9b3a65db
-da1ee8b71154887fe5298ae683c089050f2c49a5 refs/tags/v2.6.31-rc8
-^326ba5010a5429a5a528b268b36a5900d4ab0eba
-dcd5e628b7dc7f393dd728999fb0fb73a96d5e1b refs/tags/v2.6.31-rc7
-^422bef879e84104fee6dc68ded0e371dbeb5f88e
-73e5ade3a45e2096db80f0e87d6d838d0499f0fe refs/tags/v2.6.31-rc6
-^64f1607ffbbc772685733ea63e6f7f4183df1b16
-948e7a0b0e000a8d646b72fcfd8ccaa047e046ab refs/tags/v2.6.31-rc5
-^ed680c4ad478d0fee9740f7d029087f181346564
-12ae5c63b8a8ac621ddfc810f774d00cad44765a refs/tags/v2.6.31-rc4
-^4be3bd7849165e7efa6b0b35a23d6a3598d97465
-c361304f4a17c05992b1cf68172a5ea8389649ee refs/tags/v2.6.31-rc3
-^6847e154e3cd74fca6084124c097980a7634285a
-c5d511255186f0bba081f11cbe11c856cadaedf7 refs/tags/v2.6.31-rc2
-^8e4a718ff38d8539938ec3421935904c27e00c39
-eeadf87f8411b42b9803312d2870aa424602a99c refs/tags/v2.6.31-rc1
-^28d0325ce6e0a52f53d8af687e6427fee59004d3
-a271b16ba5478acead8773ebe01ee9b6365154d8 refs/tags/v2.6.31
-^74fca6a42863ffacaf7ba6f1936a9f228950f657
-e6c72abc9d239d788b0cdb20cb3d20ba04c33707 refs/tags/v2.6.30-rc8
-^9fa7eb283c5cdc2b0f4a8cfe6387ed82e5e9a3d3
-efa3e68c670b745894255af9827b3902bbc9376e refs/tags/v2.6.30-rc7
-^59a3759d0fe8d969888c741bb33f4946e4d3750d
-6492b02a211a5fd0fc92e68d171fc3644cda71a7 refs/tags/v2.6.30-rc6
-^1406de8e11eb043681297adf86d6892ff8efc27a
-4266b00c9dc3e1e071bde0ebfeadc40bbc1e8316 refs/tags/v2.6.30-rc5
-^091bf7624d1c90cec9e578a18529f615213ff847
-176c5e45fe4f1c83df9429b7c2668b41446baac2 refs/tags/v2.6.30-rc4
-^091438dd5668396328a3419abcbc6591159eb8d1
-b2fdb301af8f488952aaab7de3ff8d3294c3274f refs/tags/v2.6.30-rc3
-^091069740304c979f957ceacec39c461d0192158
-7c941a7798a5169ee0dd69a9e8d5c40ceb702023 refs/tags/v2.6.30-rc2
-^0882e8dd3aad33eca41696d463bb896e6c8817eb
-42ae7400074d449189d41fceb6d6f871490d7842 refs/tags/v2.6.30-rc1
-^577c9c456f0e1371cbade38eaf91ae8e8a308555
-fa9c4d0983f98945b32d6bd0dfc1ba1b02d3773c refs/tags/v2.6.30
-^07a2039b8eb0af4ff464efd3dfd95de5c02648c6
-73e37758f6b500a67d918528204832cc8f256516 refs/tags/v2.6.29-rc8
-^041b62374c7fedc11a8a1eeda2868612d3d1436c
-b21232ea962bbaf0e909365f4964f6cceb2ba8ce refs/tags/v2.6.29-rc7
-^fec6c6fec3e20637bee5d276fb61dd8b49a3f9cc
-0715562512ca6cf14c1b8f08e09d5907118deaf0 refs/tags/v2.6.29-rc6
-^20f4d6c3a2a23c5d7d9cc7f42fbb943ca7a03d1f
-1dcda2df87ba4ecc7988be7a45d01645e11c9f4c refs/tags/v2.6.29-rc5
-^d2f8d7ee1a9b4650b4e43325b321801264f7c37a
-87c16e9e8bb74f14f4504305957e4346e7fc46ea refs/tags/v2.6.29-rc4
-^8e4921515c1a379539607eb443d51c30f4f7f338
-8be00154b8e949bf4b89ac198aef9a247532ac2d refs/tags/v2.6.29-rc3
-^18e352e4a73465349711a9324767e1b2453383e2
-d31ce8060b0e875179ba5ca1d40475dc2a082cc7 refs/tags/v2.6.29-rc2
-^1de9e8e70f5acc441550ca75433563d91b269bbe
-7a3862d6e9934ffe107fe7ddfbe2c63dba321793 refs/tags/v2.6.29-rc1
-^c59765042f53a79a7a65585042ff463b69cb248c
-58cf2f1425abfd3a449f9fe985e48be2d2555022 refs/tags/v2.6.29-omap1
-5dfd736f95b3d84a18b5bb8e50ac71f245438acf refs/tags/v2.6.29
-^8e0ee43bc2c3e19db56a4adaa9a9b04ce885cd84
-7d4b1bcc5e7411fc9e63f610c16e5de8fe6dfde8 refs/tags/v2.6.28-rc9
-^929096fe9ff1f4b3645cf3919527ab47e8d5e17c
-6fa7003fe34e9a8a31fb91754f3c289cc045564b refs/tags/v2.6.28-rc8
-^8b1fae4e4200388b64dd88065639413cb3f1051c
-1a0bff987b27da5181f112bcc60f34d6fbb7e67e refs/tags/v2.6.28-rc7
-^061e41fdb5047b1fb161e89664057835935ca1d2
-b503092a16bdba0a418e155fe592521fc20855af refs/tags/v2.6.28-rc6
-^13d428afc007fcfcd6deeb215618f54cf9c0cae6
-68185b00cf91c1c4dcc761a2f3a1631562ed52f3 refs/tags/v2.6.28-rc5
-^9bf1a2445f3c569098b8de7097ca324e65abecc2
-b65a80a5ee7923355cbca669cead08e067fc7ada refs/tags/v2.6.28-rc4
-^f7160c7573615ec82c691e294cf80d920b5d588d
-31cb515c75388d457c2f318a0ee9606b3527852f refs/tags/v2.6.28-rc3
-^45beca08dd8b6d6a65c5ffd730af2eac7a2c7a03
-5eb14db1f80df4eb0ecb0976e47e8e287e3175fc refs/tags/v2.6.28-rc2
-^0173a3265b228da319ceb9c1ec6a5682fd1b2d92
-cb50773491b0066d0e55f31f8875d5678fa3f8ad refs/tags/v2.6.28-rc1
-^57f8f7b60db6f1ed2c6918ab9230c4623a9dbe37
-afe318c7ff937227eec924bced31d7b764f6ae46 refs/tags/v2.6.28-omap1
-^0ec95b96fd77036a13398c66901e11cd301190d0
-8a38e7fd7a30cd44be954f9a3b062e607cec5d41 refs/tags/v2.6.28
-^4a6908a3a050aacc9c3a2f36b276b46c0629ad91
-5a97794d66909dbe3282062d7637705bcd352815 refs/tags/v2.6.27-rc9
-^4330ed8ed4da360ac1ca14b0fddff4c05b10de16
-7b4e06aa7c0952353096105f87be67615e4382f5 refs/tags/v2.6.27-rc8
-^94aca1dac6f6d21f4b07e4864baf7768cabcc6e7
-cb1d73008533d7c4a949fc0867de2612dab23572 refs/tags/v2.6.27-rc7
-^72d31053f62c4bc464c2783974926969614a8649
-89c44b4a5ad50f8b85846b16af5f977f3861d197 refs/tags/v2.6.27-rc6
-^adee14b2e1557d0a8559f29681732d05a89dfc35
-d17d499628a7d4a34c11f54a203281773885a3e7 refs/tags/v2.6.27-rc5
-^24342c34a022ee90839873d91396045e12ef1090
-0572569f90ba4175e0400f3be7b9f42e1c803e55 refs/tags/v2.6.27-rc4
-^6a55617ed5d1aa62b850de2cf66f5ede2eef4825
-4aca83081f7ddf04d74989cc9b5e149160096324 refs/tags/v2.6.27-rc3
-^30a2f3c60a84092c8084dfe788b710f8d0768cd4
-b27c893faffea2a0c49cf6170d89c2a7aeba6598 refs/tags/v2.6.27-rc2
-^0967d61ea0d8e8a7826bd8949cd93dd1e829ac55
-78e28361b194c98eaa987e368264c2209ca08976 refs/tags/v2.6.27-rc1
-^6e86841d05f371b5b9b86ce76c02aaee83352298
-0df297a72329ce8f4f6895c4473661abb4277913 refs/tags/v2.6.27-omap1
-^189f0e76832b4a2d3bcc0d973ed4240170e04c29
-4b5127df968616dee2f4775d795198878ef1638b refs/tags/v2.6.27
-^3fa8749e584b55f1180411ab1b51117190bac1e5
-c22689a6f45beff21b97df566e0da17b4fa9ec19 refs/tags/v2.6.26-rc9
-^b7279469d66b55119784b8b9529c99c1955fe747
-496a3db2bfb98f1e9c7b73514d8d25790f69f5fb refs/tags/v2.6.26-rc8
-^543cf4cb3fe6f6cae3651ba918b9c56200b257d0
-f40883d058ed196976285fc1fd5fd6c85dcb5bef refs/tags/v2.6.26-rc7
-^d70ac829b7f42d7ef4f879635c6a772b0b4ed0a2
-c047413a582cbf2c7e1b012458c1665d959703be refs/tags/v2.6.26-rc6
-^5dd34572ad9a3be430632dd42e4af2ea370b397b
-9ab8267ac47ce50b932cc4b1cbd9b05e2faac8b7 refs/tags/v2.6.26-rc5
-^53c8ba95402be65d412a806cda3430f0e72cd107
-e21868a4cdd93e5883ff61579d4cd799d1a3c244 refs/tags/v2.6.26-rc4
-^e490517a039a99d692cb3a5561941b0a5f576172
-b041a30258df00c90ac1ed532cec3f25c00a3ce8 refs/tags/v2.6.26-rc3
-^b8291ad07a7f3b5b990900f0001198ac23ba893e
-b67fc588ce611ca847620bd1353bf2d68fc3027f refs/tags/v2.6.26-rc2
-^492c2e476eac010962850006c49df326919b284c
-d6b7f73ed134769c86966697e61b235b200cc4ae refs/tags/v2.6.26-rc1
-^2ddcca36c8bcfa251724fe342c8327451988be0d
-9882ca1b309ef95e528fe048499b831f99a688a3 refs/tags/v2.6.26-omap2
-d6daf8d8cc5ccf90247def5551ee9c3e8555e848 refs/tags/v2.6.26-omap1
-14650d6ec137e70b6c1918cdef235027c5156020 refs/tags/v2.6.26
-^bce7f793daec3e65ec5c5705d2457b81fe7b5725
-3df83da958163beeca00d1254f512fafd79a19ed refs/tags/v2.6.25-rc9
-^120dd64cacd4fb796bca0acba3665553f1d9ecaa
-e39586f39c2829d30f4ea6680a846dfe4aad2f2e refs/tags/v2.6.25-rc8
-^0e81a8ae37687845f7cdfa2adce14ea6a5f1dd34
-f4281310b609edd587922b7d4afa63e4b9a1ffd4 refs/tags/v2.6.25-rc7
-^05dda977f2574c3341abef9b74c27d2b362e1e3a
-b22f07f908a648c864b16d2ba71f03aba4b684c9 refs/tags/v2.6.25-rc6
-^a978b30af3bab0dd9af9350eeda25e76123fa28e
-cd81f35c48b7e0c2a871f88e1973f391f8330449 refs/tags/v2.6.25-rc5
-^cdeeeae056a429e729ae9e914fa8142ee45bee93
-c6c155e032361b0031943141b1a6f231e4f63817 refs/tags/v2.6.25-rc4
-^29e8c3c304b62f31b799565c9ee85d42bd163f80
-d622f5379e88a3bac4f8decfa49c0a04a8e209d3 refs/tags/v2.6.25-rc3
-^bfa274e2436fc7ef72ef51c878083647f1cfd429
-b74415eac8d3f1fcb39ad4bcef0c829635a3bc9f refs/tags/v2.6.25-rc2
-^101142c37be8e5af9b847860219217e6b958c739
-abf6976c818c553eb2209fe32028a4c5eecab0cb refs/tags/v2.6.25-rc1
-^19af35546de68c872dcb687613e0902a602cb20e
-3ce7ba0c3c9566f50725b0108916180db86e1641 refs/tags/v2.6.25-omap1
-20b8df8e5501bac243e64c0c8c52907735a0041b refs/tags/v2.6.25
-^4b119e21d0c66c22e8ca03df05d9de623d0eb50f
-c9ba0caa9650a1898c839a79f6ff96a8a982424c refs/tags/v2.6.24-rc8
-^cbd9c883696da72b2b1f03f909dbacc04bbf8b58
-fcb31af14662059db467201ec73dfbb6f3300342 refs/tags/v2.6.24-rc7
-^3ce54450461bad18bbe1f9f5aa3ecd2f8e8d1235
-f49e4e249d57ddfa97e046bc5c994ef72c93e63b refs/tags/v2.6.24-rc6
-^ea67db4cdbbf7f4e74150e71da0984e25121f500
-9f11d5919577129413e8389e43e5b6e8413dff53 refs/tags/v2.6.24-rc5
-^82d29bf6dc7317aeb0a3a13c2348ca8591965875
-b6fa40f5916811c6aad6625c384d26fd01135014 refs/tags/v2.6.24-rc4
-^09b56adc98e0f8a21644fcb4d20ad367c3fceb55
-f05092637dc0d9a3f2249c9b283b973e6e96b7d2 refs/tags/v2.6.24-rc3
-^d9f8bcbf67a0ee67c8cb0734f003dfe916bb5248
-9aae299f7fd1888ea3a195cfe0edef17bb647415 refs/tags/v2.6.24-rc2
-^dbeeb816e805091e7cfc03baf36dc40b4adb2bbd
-cebdeed27b068dcc3e7c311d7ec0d9c33b5138c2 refs/tags/v2.6.24-rc1
-^c9927c2bf4f45bb85e8b502ab3fb79ad6483c244
-3ca40ae9cd60ba3630d830f7c848ba30613dbe01 refs/tags/v2.6.24-omap1
-0d733ddb2026683da26c1722847b99911c43ccb5 refs/tags/v2.6.24
-^49914084e797530d9baaf51df9eda77babc98fa8
-da0a81e98c06aa0d1e05b9012c2b2facb1807e12 refs/tags/v2.6.23-rc9
-^3146b39c185f8a436d430132457e84fa1d8f8208
-fc4a2ad046f06bed41eda33142c5767149a72fe7 refs/tags/v2.6.23-rc8
-^4942de4a0e914f205d351a81873f4f63986bcc3c
-c3e1edc6a6b420f81a6bc1ea47c5b3dd157e76aa refs/tags/v2.6.23-rc7
-^81cfe79b9c577139a873483654640eb3f6e78c39
-a33969a68b624d98356398af0a59856cc52f47a5 refs/tags/v2.6.23-rc6
-^0d4cbb5e7f60b2f1a4d8b7f6ea4cc264262c7a01
-f3cfc7abf10379d926dd04008059d2b04eaf4499 refs/tags/v2.6.23-rc5
-^40ffbfad6bb79a99cc7627bdaca0ee22dec526f6
-e7afef45b41f5f5e2211322f083247e42ba13a78 refs/tags/v2.6.23-rc4
-^b07d68b5ca4d55a16fab223d63d5fb36f89ff42f
-39e7e2ec80646a62a9d61871bee8d2736088a86f refs/tags/v2.6.23-rc3
-^39d3520c92cf7a28c07229ca00cc35a1e8026c77
-2c7522b19c386ed601d27b2aed3e7b84ac7852f0 refs/tags/v2.6.23-rc2
-^d4ac2477fad0f2680e84ec12e387ce67682c5c13
-7d57c74238cdf570bca20b711b2c0b31a553c1e5 refs/tags/v2.6.23-rc1
-^f695baf2df9e0413d3521661070103711545207a
-266b0072e043ab81e19e5595e95f557fb43a3cb5 refs/tags/v2.6.23-omap1
-0b8bc8b91cf6befea20fe78b90367ca7b61cfa0d refs/tags/v2.6.23
-^bbf25010f1a6b761914430f5fca081ec8c7accd1
-087ea061253277de2b27e82d8572a386835a1b7e refs/tags/v2.6.22-rc7
-^a38d6181ff27824c79fc7df825164a212eff6a3f
-953e420db7c599f7db00548243f2afddc8440329 refs/tags/v2.6.22-rc6
-^189548642c5962e60c3667bdb3a703fe0bed12a6
-aec07c7abc280bd5d0ca33b7cda3eb7b9b6e89c1 refs/tags/v2.6.22-rc5
-^188e1f81ba31af1b65a2f3611df4c670b092bbac
-5b78c77092a64e253fe1fde9fbbe818b49330ffc refs/tags/v2.6.22-rc4
-^5ecd3100e695228ac5e0ce0e325e252c0f11806f
-0119a8416e0827bf2b937a1cf21d4909db3fa111 refs/tags/v2.6.22-rc3
-^c420bc9f09a0926b708c3edb27eacba434a4f4ba
-5a1b8597cd250efd5bda1cba08417c95b6b314d7 refs/tags/v2.6.22-rc2
-^55b637c6a003a8c4850b41a2c2fd6942d8a7f530
-cb22632a37a5d797da988453924206d1638e4e6c refs/tags/v2.6.22-rc1
-^39403865d2e4590802553370a56c9ab93131e4ee
-2a1c4dfbbe9fd7f756e62579bb42d341d340bd0f refs/tags/v2.6.22-omap1
-098fd16f00005f665d3baa7e682d8cb3d7c0fe6f refs/tags/v2.6.22
-^7dcca30a32aadb0520417521b0c44f42d09fe05c
-60afa917fea11f7cc93281b2dfd64b19b6521a93 refs/tags/v2.6.21-rc7
-^94a05509a9e11806acd797153d03019706e466f1
-a5d693edb558469a6f72bfda1253c7ba2278d657 refs/tags/v2.6.21-rc6
-^a21bd69e1509b43823c317c3bf3f7ffa99884356
-6fb04ccf5c5e054c4107090bed6e866489f1089f refs/tags/v2.6.21-rc5
-^e0f2e3a06be513352cb4955313ed7e55909acd84
-bac6eefe96204d0ad67d144f2511a6fc487aa594 refs/tags/v2.6.21-rc4
-^db98e0b434a6265c451ffe94ec0a29b8d0aaf587
-44e05067b4b767fa3137335818c399b9b198c925 refs/tags/v2.6.21-rc3
-^08e15e81a40e3241ce93b4a43886f3abda184aa6
-fa18364691754673df97824d81bfe8524a3a0595 refs/tags/v2.6.21-rc2
-^606135a3081e045b677cde164a296c51f66c4633
-2eb1ae149a28c1b8ade687c5fbab3c37da4c0fba refs/tags/v2.6.21-rc1
-^c8f71b01a50597e298dc3214a2f2be7b8d31170c
-78e73e07e27783951ba64da4a3012b84b43b7b90 refs/tags/v2.6.21-omap1
-d1be341dba5521506d9e6dccfd66179080705bea refs/tags/v2.6.21
-^de46c33745f5e2ad594c72f2cf5f490861b16ce1
-97c617f72b58983017f32da97fc228597c0dae8f refs/tags/v2.6.20-rc7
-^f56df2f4db6e4af87fb8e941cff69f4501a111df
-0909eebced6eadf15ea6aadce0d79c08676de3fe refs/tags/v2.6.20-rc6
-^99abfeafb5f2eea1bb481330ff37343e1133c924
-c81c70d32732b7abc644ec7aca24f3597aa921ea refs/tags/v2.6.20-rc5
-^a8b3485287731978899ced11f24628c927890e78
-cb15cca892ac09f7cb99618a09304c5f5620e6ee refs/tags/v2.6.20-rc4
-^bf81b46482c0fa8ea638e409d39768ea92a6b0f0
-9d37e643a198d4232d2a12f1107358eb02b6cece refs/tags/v2.6.20-rc3
-^669df1b478803f49a356528d290af7bf442eb3be
-8a2d17a56a71c5c796b0a5378ee76a105f21fdd9 refs/tags/v2.6.20-rc2
-^3bf8ba38f38d3647368e4edcf7d019f9f8d9184a
-a7ecdd29e85a7d51179c6a4507a4c25a87ab5c0e refs/tags/v2.6.20-rc1
-^cc016448b0bf0764928275d034e367753bde8162
-fa285a3d7924a0e3782926e51f16865c5129a2f7 refs/tags/v2.6.20
-^62d0cfcb27cf755cebdc93ca95dabc83608007cd
-82471364173618c5a97b6c02bf6e72deddde9632 refs/tags/v2.6.19-rc6
-^44597f65f6af3c692560a639f61d25398d13d1b6
-2f4871018917f13c7cd01254335561a152decc00 refs/tags/v2.6.19-rc5
-^80c218812786f619c9a1ce50d0e7c32c7afde4de
-7a9d289b6650bf78df77ab463bedc2919df89833 refs/tags/v2.6.19-rc4
-^ae99a78af33f00565a05dbbc6ca9b247fed002c5
-aaa751e8aa7dd8b1c1f787728d279d9dadbb5938 refs/tags/v2.6.19-rc3
-^7059abedd2f04b68bd7e1a79c9c72f7aeee134c0
-5e2c92804ed42d0be784e4dc4041dc3ca001810b refs/tags/v2.6.19-rc2
-^b4bd8c66435a8cdf8c90334fb3b517a23ff2ab95
-008616c979c90b1a4ea2d2cebf4996743463b001 refs/tags/v2.6.19-rc1
-^d223a60106891bfe46febfacf46b20cd8509aaad
-cd7e4d7aad3fd915366dff89d0a6a3e0868f1180 refs/tags/v2.6.19-omap1
-c3fe6924620fd733ffe8bc8a9da1e9cde08402b3 refs/tags/v2.6.19
-^0215ffb08ce99e2bb59eca114a99499a4d06e704
-3d3f47c98b3696f5bd677f89a755c239f4d52a4c refs/tags/v2.6.18-rc7
-^95064a75ebf8744e1ff595e8cd7ff9b6c851523e
-12c8b6ff70a17bfcb59bcca55fa8e79d809c1c70 refs/tags/v2.6.18-rc6
-^c336923b668fdcf0312efbec3b44895d713f4d81
-69b7510036d06c6aabcdc0bb03f35cfc62160302 refs/tags/v2.6.18-rc5
-^60d4684068ff1eec78f55b5888d0bd2d4cca1520
-06abe048193087f81ee67c225a1b685d937f220d refs/tags/v2.6.18-rc4
-^9f737633e6ee54fc174282d49b2559bd2208391d
-5031a46c0d098346e4c9cd56f7858def243da096 refs/tags/v2.6.18-rc3
-^b6ff50833ad43a8ebd9b16bf53c334f7aaf33c41
-f4035c6284f7de0b47ccf68264f289e7e0b47da2 refs/tags/v2.6.18-rc2
-^82d6897fefca6206bca7153805b4c5359ce97fc4
-7df8ea909888d4856d3aff1c41192739d715a393 refs/tags/v2.6.18-rc1
-^120bda20c6f64b32e8bfbdd7b34feafaa5f5332e
-40749d1d5792748372ae3becf638944b896ef8f1 refs/tags/v2.6.18-omap1
-119248f4578ca60b09c20893724e10f19806e6f1 refs/tags/v2.6.18
-^e478bec0ba0a83a48a0f6982934b6de079e7e6b3
-831695cbeb7a0e8f9ddb9c0203a22723da2c3f2f refs/tags/v2.6.17-rc6
-^1def630a6a49dda5bc89dfbd86656293640456f0
-39beb382e4e11ed01cb5e73022f18bbed2aefd8b refs/tags/v2.6.17-rc5
-^a8bd60705aa17a998516837d9c1e503ad4cbd7fc
-90b92312eeebc70e61415394be3cc03b08a74945 refs/tags/v2.6.17-rc4
-^d8c3291c73b958243b33f8509d4507e76dafd055
-6716c37ec2dbf78b85a55cc5605677b6cf2299a0 refs/tags/v2.6.17-rc3
-^2be4d50295e2b6f62c07b614e1b103e280dddb84
-f61c8059ffbc29bd8a1ffbd5a87e5135bc28a752 refs/tags/v2.6.17-rc2
-^8bbde0e6d52265158ee9625f383500c1a7d09ba9
-d882e0c80e6e3c60640492b83395e6fbbae04276 refs/tags/v2.6.17-rc1
-^6246b6128bbe34d0752f119cf7c5111c85fe481d
-a7abfb3157101ee90f45e261c64850c980d1b6dc refs/tags/v2.6.17-omap2
-d78bae00e94e74090b92a6506b50d40bedeb2f08 refs/tags/v2.6.17-omap1
-8ba130df4b67fa40878ccf80d54615132d24bc68 refs/tags/v2.6.17
-^427abfa28afedffadfca9dd8b067eb6d36bac53f
-76dbe3f496eeaadab8977409b930e7d522dcf750 refs/tags/v2.6.16-rc6
-^535744878e34d01a53f946f26dfbca37186f2cf8
-afdf555c717a6ace9e5446dda4d169eaa5ca8062 refs/tags/v2.6.16-rc5
-^b9a33cebac70d6f67a769ce8d4078fee2b254ada
-d94ef3bc908905e8bc0f1560a90df76a4c4b60bb refs/tags/v2.6.16-rc4
-^bd71c2b17468a2531fb4c81ec1d73520845e97e1
-a3adf278bcd5852d8c6345c9b0a44a0cc71c7454 refs/tags/v2.6.16-rc3
-^e9bb4c9929a63b23dcc637fae312b36b038bdc61
-e4f9aae0d74cb7d2fd5f0eb315cf9de1118fe260 refs/tags/v2.6.16-rc2
-^826eeb53a6f264842200d3311d69107d2eb25f5e
-f3bcf72eb85aba88a7bd0a6116dd0b5418590dbe refs/tags/v2.6.16-rc1
-^2664b25051f7ab96b22b199aa2f5ef6a949a4296
-8c6cfface78a77ed68788216d5fecdac7d8d09c3 refs/tags/v2.6.16-omap2
-40d3d73c7f2b37793947cecb1c35084e8d9ab80d refs/tags/v2.6.16-omap1
-414ad0ded83f088608f7c0e774df8cccbba4e229 refs/tags/v2.6.16
-^7705a8792b0fc82fd7d4dd923724606bbfd9fb20
-373540886574ecf8b864fa7b8a5cf879b1d7b054 refs/tags/v2.6.15-rc7
-^f89f5948fc10bb973cd452d2e334da207828e228
-20f065bc620db2d6157c95b117910c4ed59acc46 refs/tags/v2.6.15-rc6
-^df7addbb45874f0f992266003155de5a22e1872f
-b58cb01b0f7eff054d1246e63f0eebfbdf8e6686 refs/tags/v2.6.15-rc5
-^436b0f76f2cee6617f27a649637766628909dd5d
-8c27e9cccbc96548646606a2eb52c27e72abf5e1 refs/tags/v2.6.15-rc4
-^5666c0947ede0432ba5148570aa66ffb9febff5b
-00d7a7358e3f9f2575501674e604fe4c6700b365 refs/tags/v2.6.15-rc3
-^624f54be206adf970cd8eece16446b027913e533
-7305b5cb045e2c71250b5b7472771ed2620bc514 refs/tags/v2.6.15-rc2
-^3bedff1d73b86e0cf52634efb447e9ada08f2cc6
-1400e40b758e4099e4d758d8fc38981b33b71897 refs/tags/v2.6.15-rc1
-^cd52d1ee9a92587b242d946a2300a3245d3b885a
-58d582b9109ab35aa79a372c3427d25d8ff49438 refs/tags/v2.6.15-omap2
-dab47a31f42a23d2b374e1cd7d0b797e8e08b23d refs/tags/v2.6.15
-^88026842b0a760145aa71d69e74fbc9ec118ca44
-c08359b174c3b3a175979f81cc786c791f74c852 refs/tags/v2.6.14-rc5
-^93918e9afc76717176e9e114e79cdbb602a45ae8
-a1aeb6f9e4306b1a62629c56197eea65afd372b3 refs/tags/v2.6.14-rc4
-^907a42617970a159361f17ef9a63f04d276995ab
-f92737b18abac90af30ac26a050fda879c9b238b refs/tags/v2.6.14-rc3
-^1c9426e8a59461688bb451e006456987b198e4c0
-c2bbf523f1d454649897b3e4bcd71778e4fa5913 refs/tags/v2.6.14-rc2
-^676d55ae30ea3b688f0386f70553489f25f24d55
-c9c7de1d74d475e6a0f02ccc4ace6dc0066507aa refs/tags/v2.6.14-rc1-omap1
-1f9d1e3248d4eb96b229eecf0e5d9445d3529e85 refs/tags/v2.6.14-rc1
-^2f4ba45a75d6383b4a1201169a808ffea416ffa0
-2b10839e32c4c476e9d94492756bb1a3e1ec4aa8 refs/tags/v2.6.14
-^741b2252a5e14d6c60a913c77a6099abe73a854a
-3e6f704488332c74e7defec13f22bf2e2bccb444 refs/tags/v2.6.13-rc7
-^0572e3da3ff5c3744b2f606ecf296d5f89a4bbdf
-50f0e20a16496a9feb52cf1d79a0c33cce1a682d refs/tags/v2.6.13-rc6
-^6fc32179de9e14c542e0b1760e412bc670611c53
-2ef68d3fdfacf92ac5ff84be969b4b8acb5c0723 refs/tags/v2.6.13-rc5
-^9a351e30d72d409ec62c83f380e330e0baa584b4
-7eab951de91d95875ba34ec4c599f37e1208db93 refs/tags/v2.6.13-rc4
-^63953523341bcafe5928bf6e99bffd7db94b471e
-a339981ec18d304f9efeb9ccf01b1f04302edf32 refs/tags/v2.6.13-rc3
-^c32511e2718618f0b53479eb36e07439aa363a74
-c521cb0f10ef2bf28a18e1cc8adf378ccbbe5a19 refs/tags/v2.6.13-rc2
-^a18bcb7450840f07a772a45229de4811d930f461
-733ad933f62e82ebc92fed988c7f0795e64dea62 refs/tags/v2.6.13-rc1
-^4c91aedb75d1b87deccf16d58f67fb46402d7d44
-031ddf931431d019fc1b586e9066b160009b77b1 refs/tags/v2.6.13-omap1
-0da688d20078783b23f99b232b272b027d6c3f59 refs/tags/v2.6.13
-^02b3e4e2d71b6058ec11cc01c72ac651eb3ded2b
-701d7ecec3e0c6b4ab9bb824fd2b34be4da63b7e refs/tags/v2.6.12-rc6
-^7cef5677ef3a8084f2588ce0a129dc95d65161f6
-06f6d9e2f140466eeb41e494e14167f90210f89d refs/tags/v2.6.12-rc5
-^2a24ab628aa7b190be32f63dfb6d96f3fb61580a
-ebb5573ea8beaf000d4833735f3e53acb9af844c refs/tags/v2.6.12-rc4
-^88d7bd8cb9eb8d64bf7997600b0d64f7834047c5
-0397236d43e48e821cce5bbe6a80a1a56bb7cc3a refs/tags/v2.6.12-rc3
-^a2755a80f40e5794ddc20e00f781af9d6320fafb
-9e734775f7c22d2f89943ad6c745571f1930105f refs/tags/v2.6.12-rc2
-^1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
-26791a8bcf0e6d33f43aef7682bdb555236d56de refs/tags/v2.6.12
-^9ee1c939d1cb936b1f98e8d81aeffab57bae46ab
-5dc01c595e6c6ec9ccda4f6f69c131c0dd945f8c refs/tags/v2.6.11-tree
-^c39ae07f393806ccf406ef966e9a15afc43cc36a
-5dc01c595e6c6ec9ccda4f6f69c131c0dd945f8c refs/tags/v2.6.11
-^c39ae07f393806ccf406ef966e9a15afc43cc36a
-1406de8e11eb043681297adf86d6892ff8efc27a refs/tags/linux-omap-v2.6.30-rc6
-448e9a675e2cfb173fc47083058cf254ccc114a0 refs/remotes/origin/pm
-da3e3a222aa188cccac2fae6038bf2dc9b3d36e1 refs/remotes/origin/omap-testing
-ed2af92bc3adf7f5c09edef64cf4383b3d60b070 refs/remotes/origin/omap-fixes-for-linus
-2a20002a83ce565ed16aaec5e64151cae165cb8f refs/remotes/origin/omap-2.6.32
-8e82dfe2923852135efbcbf4930e1def23b11cfc refs/remotes/origin/omap-2.6.31
-947478830b2046913ef6cbe64243a4c6530ff835 refs/remotes/origin/omap-2.6.30
-58cf2f1425abfd3a449f9fe985e48be2d2555022 refs/remotes/origin/omap-2.6.29
-b9eeea406f365a40585733934cfecd90feef286d refs/remotes/origin/omap-2.6.28
-6cd5fb725cb1e89c58de6be59a7ff8fda32e4ffa refs/remotes/origin/master
-ebf53826e105f488f4f628703a108e98940d1dc5 refs/remotes/origin/linus
-9eaf60e4834a9001f51b2840ac438afec0726d0c refs/remotes/origin/for-next
-0f1acc98d059d89062269f5c4e6271f4d9ac884d refs/remotes/origin/dss2
-b79ca7bae67fdad5a8a0ed5be3323126903f18eb refs/remotes/origin/dspgateway
-ec08f70c36bb707e724f4e63eb5b0a54c5d0c5df refs/remotes/origin/dspbridge
-d92bdac6e899e44d56c2bc219166d988f657edbc refs/remotes/origin/devel-fixes
-26469ccbb755d25f94590c040ebcb2e4f96f9817 refs/remotes/origin/devel-early-init
-3fc98ec9930ee397c402177307b0dfe92e66b8a5 refs/remotes/origin/devel-debug-ll
-232bc6514fbf67abdaec1899a6d818c1dc70cbd6 refs/remotes/origin/devel-cleanup
-7d4ca85a53bab1f6f9911411be38e0486a11187a refs/remotes/origin/devel-board
-0b3d37362f07e92aa71fe496bccd189b35532aed refs/remotes/origin/cbus
diff -ruN linux-omap-2.6/.git/refs/heads/master maemo_src/.git/refs/heads/master
--- linux-omap-2.6/.git/refs/heads/master	2011-02-06 20:17:26.289999939 -0500
+++ maemo_src/.git/refs/heads/master	1969-12-31 19:00:00.000000000 -0500
@@ -1 +0,0 @@
-78e73e07e27783951ba64da4a3012b84b43b7b90
diff -ruN linux-omap-2.6/.git/refs/remotes/origin/HEAD maemo_src/.git/refs/remotes/origin/HEAD
--- linux-omap-2.6/.git/refs/remotes/origin/HEAD	2011-02-06 19:37:34.973333272 -0500
+++ maemo_src/.git/refs/remotes/origin/HEAD	1969-12-31 19:00:00.000000000 -0500
@@ -1 +0,0 @@
-ref: refs/remotes/origin/master
diff -ruN linux-omap-2.6/include/asm-arm/arch-omap/board.h maemo_src/include/asm-arm/arch-omap/board.h
--- linux-omap-2.6/include/asm-arm/arch-omap/board.h	2011-02-06 20:17:26.033333273 -0500
+++ maemo_src/include/asm-arm/arch-omap/board.h	2007-10-02 03:09:32.000000000 -0400
@@ -14,6 +14,8 @@
 
 #include <asm/arch/gpio-switch.h>
 
+#include "../../../drivers/media/video/omap/tcm825x.h"
+
 /* Different peripheral ids */
 #define OMAP_TAG_CLOCK		0x4f01
 #define OMAP_TAG_MMC		0x4f02
@@ -28,6 +30,8 @@
 #define OMAP_TAG_PARTITION      0x4f0b
 #define OMAP_TAG_TEA5761	0x4f10
 #define OMAP_TAG_TMP105		0x4f11
+#define OMAP_TAG_DVFS		0x4f12
+#define OMAP_TAG_TSL2563	0x4f13
 
 #define OMAP_TAG_BOOT_REASON    0x4f80
 #define OMAP_TAG_FLASH_PART_STR	0x4f81
@@ -67,10 +71,17 @@
 	u8 channel;
 };
 
+struct omap_camera;
+
 struct omap_camera_sensor_config {
-	u16 reset_gpio;
-	int (*power_on)(void * data);
-	int (*power_off)(void * data);
+	/* Is the sensor usable? Doesn't yet mean it's there, but you
+	 * can try! */
+	int (*is_okay)(void);
+	/* Set power state, zero is off, non-zero is on. */
+	int (*power_set)(int power);
+	struct omap_camera *camera;
+	const struct tcm825x_reg *(*default_regs)(void);
+	int (*is_upside_down)(void);
 };
 
 struct omap_usb_config {
@@ -146,12 +157,20 @@
 	u16 enable_gpio;
 };
 
+struct tsl2563_config {
+	s16 irq_gpio;
+};
+
 /* This cannot be passed from the bootloader */
 struct omap_tmp105_config {
 	u16 tmp105_irq_pin;
 	int (* set_power)(int enable);
 };
 
+struct omap_dvfs_config {
+	u8 dvfs_init_op;
+};
+
 struct omap_partition_config {
 	char name[16];
 	unsigned int size;
diff -ruN linux-omap-2.6/include/asm-arm/arch-omap/board-nokia.h maemo_src/include/asm-arm/arch-omap/board-nokia.h
--- linux-omap-2.6/include/asm-arm/arch-omap/board-nokia.h	2011-02-06 20:17:26.033333273 -0500
+++ maemo_src/include/asm-arm/arch-omap/board-nokia.h	2011-02-06 20:12:13.739999940 -0500
@@ -28,6 +28,7 @@
 #define OMAP_TAG_WLAN_CX3110X	0x4e02
 #define OMAP_TAG_CBUS		0x4e03
 #define OMAP_TAG_EM_ASIC_BB5	0x4e04
+#define OMAP_TAG_PC2400M	0x4e05
 
 #define BT_CHIP_CSR		1
 #define BT_CHIP_TI		2
@@ -63,4 +64,12 @@
 	s16 tahvo_irq_gpio;
 };
 
+struct omap_pc2400m_config {
+	u8  chip_type;
+	s16 enable_gpio;
+	s16 irq_gpio;
+	s16 reset_gpio;
+	s16 spi_cs_gpio;
+};
+
 #endif
diff -ruN linux-omap-2.6/include/asm-arm/arch-omap/dma.h maemo_src/include/asm-arm/arch-omap/dma.h
--- linux-omap-2.6/include/asm-arm/arch-omap/dma.h	2011-02-06 20:17:26.046666606 -0500
+++ maemo_src/include/asm-arm/arch-omap/dma.h	2011-02-06 20:12:13.806666605 -0500
@@ -57,6 +57,7 @@
 #define OMAP_DMA4_IRQENABLE_L2		(OMAP24XX_DMA_BASE + 0x20)
 #define OMAP_DMA4_IRQENABLE_L3		(OMAP24XX_DMA_BASE + 0x24)
 #define OMAP_DMA4_SYSSTATUS		(OMAP24XX_DMA_BASE + 0x28)
+#define OMAP_DMA4_SYSCONFIG		(OMAP24XX_DMA_BASE + 0x2c)
 #define OMAP_DMA4_CAPS_0		(OMAP24XX_DMA_BASE + 0x64)
 #define OMAP_DMA4_CAPS_2		(OMAP24XX_DMA_BASE + 0x6c)
 #define OMAP_DMA4_CAPS_3		(OMAP24XX_DMA_BASE + 0x70)
@@ -426,4 +427,8 @@
 extern void omap_set_lcd_dma_b1_mirror(int mirror);
 extern void omap_set_lcd_dma_b1_scale(unsigned int xscale, unsigned int yscale);
 
+#ifdef CONFIG_ARCH_OMAP2420_DMA_DRAIN
+void omap2_dma_pause(void);
+#endif
+
 #endif /* __ASM_ARCH_DMA_H */
diff -ruN linux-omap-2.6/include/asm-arm/arch-omap/dsp.h maemo_src/include/asm-arm/arch-omap/dsp.h
--- linux-omap-2.6/include/asm-arm/arch-omap/dsp.h	2011-02-06 20:17:26.046666606 -0500
+++ maemo_src/include/asm-arm/arch-omap/dsp.h	2011-02-06 20:12:13.726666605 -0500
@@ -115,4 +115,9 @@
 
 #define TADD_ABORTADR	0xffffffff
 
+#ifdef CONFIG_OMAP_DSP_PAUSING
+int dsp_pause(void);
+int dsp_continue(void);
+#endif
+
 #endif /* __ARCH_OMAP_DSP_H */
diff -ruN linux-omap-2.6/include/asm-arm/arch-omap/dvfs.h maemo_src/include/asm-arm/arch-omap/dvfs.h
--- linux-omap-2.6/include/asm-arm/arch-omap/dvfs.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/include/asm-arm/arch-omap/dvfs.h	2011-02-06 20:12:13.809999940 -0500
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2007 Nokia Corporation. All rights reserved.
+ *
+ * Contact: Klaus Pedersen <klaus.k.pedersen@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef ASM_ARCH_DVFS_H
+#define ASM_ARCH_DVFS_H
+
+enum dvfs_op_policy_change {
+	DSP_DYNAMIC_TASK_CHANGED = 1,
+	DSP_AUDIO_PATH_CHANGED   = 2,
+	CAM_STREAMING_CHANGED    = 3,
+};
+
+#ifdef CONFIG_MACH_OMAP2420_DVFS
+void dvfs_op_policy_update(enum dvfs_op_policy_change type, int data);
+void dvfs_op_policy_update_delayed(enum dvfs_op_policy_change type, int data);
+#else
+static inline void dvfs_op_policy_update(
+	enum dvfs_op_policy_change type, int data) {}
+
+static inline void dvfs_op_policy_update_delayed(
+	enum dvfs_op_policy_change type, int data) {}
+#endif
+
+#define cam_policy_update(streaming) \
+	dvfs_op_policy_update_delayed(CAM_STREAMING_CHANGED, streaming)
+
+#endif /* ASM_ARCH_DVFS_H */
+
diff -ruN linux-omap-2.6/include/asm-arm/arch-omap/dvfs_notif.h maemo_src/include/asm-arm/arch-omap/dvfs_notif.h
--- linux-omap-2.6/include/asm-arm/arch-omap/dvfs_notif.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/include/asm-arm/arch-omap/dvfs_notif.h	2007-10-02 03:09:32.000000000 -0400
@@ -0,0 +1,100 @@
+/*
+ *
+ * Copyright (C) 2007 Nokia Corporation.
+ *
+ * Contact: Igor Stoppa <igor.stoppa@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __NOTIFICATIONS_H
+#define __NOTIFICATIONS_H
+
+#include <linux/kthread.h>
+#include <linux/list.h>
+#include <linux/notifier.h>
+
+/*
+ * Every notification is associated to 2 driver states: waiting and done.
+ * The driver state is used to detect, in case of timeout, which drivers have
+ * failed to ACK the notification sent.
+ */
+enum dvfs_driver_state {
+	STATE_WAITING_FOR_PRE = 0,
+	STATE_DONE_PRE,
+	STATE_WAITING_FOR_POST,
+	STATE_DONE_POST,
+	NUM_DVFS_DRIVER_STATES
+};
+
+enum dvfs_notifications {
+	DVFS_PRE_NOTIFICATION = STATE_DONE_PRE,
+	DVFS_POST_NOTIFICATION = STATE_DONE_POST,
+	NUM_DVFS_NOTIFICATIONS
+};
+
+enum dvfs_threaded {
+	DVFS_CHAINED_NOTIF = 0,
+	DVFS_THREADED_NOTIF,
+};
+
+struct dvfs_notif {
+	struct list_head list;
+	struct task_struct *task;
+	struct notifier_block nb;
+	const char * name;
+	int err;
+	enum dvfs_driver_state state;
+	enum dvfs_threaded threaded;
+	unsigned int timeout;
+};
+
+#ifdef CONFIG_MACH_OMAP2420_DVFS
+
+#define DVFS_NOTIF(n) container_of(n, struct dvfs_notif, nb)
+
+int dvfs_run_notifications(enum dvfs_notifications event);
+int dvfs_notif_set(struct dvfs_notif *target, const char *name,
+		   int (*callback)(struct notifier_block *,
+		   unsigned long, void *),
+		   enum dvfs_threaded threaded, unsigned long timeout);
+void dvfs_client_notification_cb(struct dvfs_notif *n);
+int dvfs_register_notifier(struct dvfs_notif *n);
+int dvfs_unregister_notifier(struct dvfs_notif *n);
+
+#else
+
+#define DVFS_NOTIF(n) NULL
+
+static inline int dvfs_run_notifications(enum dvfs_notifications event)
+{
+	return 0;
+}
+
+static inline int dvfs_notif_set(struct dvfs_notif *target, const char *name,
+				 int (*callback)(struct notifier_block *,
+				 unsigned long, void *),
+				 enum dvfs_threaded threaded,
+				 unsigned long timeout)
+{
+	return 0;
+}
+static inline void dvfs_client_notification_cb(struct dvfs_notif *n) { }
+static inline int dvfs_register_notifier(struct dvfs_notif *n) { return 0;}
+static inline int dvfs_unregister_notifier(struct dvfs_notif *n) { return 0;}
+#endif /* CONFIG_MACH_OMAP2420_DVFS */
+
+#endif /* __NOTIFICATIONS_H */
diff -ruN linux-omap-2.6/include/asm-arm/arch-omap/gpmc.h maemo_src/include/asm-arm/arch-omap/gpmc.h
--- linux-omap-2.6/include/asm-arm/arch-omap/gpmc.h	2011-02-06 20:17:26.069999938 -0500
+++ maemo_src/include/asm-arm/arch-omap/gpmc.h	2011-02-06 20:12:13.739999940 -0500
@@ -87,6 +87,7 @@
 };
 
 extern unsigned int gpmc_ns_to_ticks(unsigned int time_ns);
+extern unsigned int gpmc_ticks_to_ns(unsigned int ticks);
 extern unsigned int gpmc_round_ns_to_ticks(unsigned int time_ns);
 extern unsigned long gpmc_get_fclk_period(void);
 
diff -ruN linux-omap-2.6/include/asm-arm/arch-omap/mailbox.h maemo_src/include/asm-arm/arch-omap/mailbox.h
--- linux-omap-2.6/include/asm-arm/arch-omap/mailbox.h	2011-02-06 20:17:26.073333272 -0500
+++ maemo_src/include/asm-arm/arch-omap/mailbox.h	2011-02-06 20:12:13.756666605 -0500
@@ -36,11 +36,12 @@
 };
 
 struct omap_mbox_queue {
+	int			state;
 	spinlock_t		lock;
 	request_queue_t		*queue;
 	struct work_struct	work;
+	struct workqueue_struct	*wq;
 	int	(*callback)(void *);
-	struct omap_mbox	*mbox;
 };
 
 struct omap_mbox {
@@ -61,7 +62,25 @@
 	void			(*err_notify)(void);
 };
 
-int omap_mbox_msg_send(struct omap_mbox *, mbox_msg_t msg, void *);
+enum {
+	MBOX_QUEUE_READY,
+	MBOX_QUEUE_SUSPEND,
+};
+
+#define mbox_queue_ok(q)	((q)->state == MBOX_QUEUE_READY)
+
+static inline void mbox_queue_resume(struct omap_mbox_queue *q)
+{
+	q->state = MBOX_QUEUE_READY;
+	queue_work(q->wq, &q->work);
+}
+static inline void mbox_queue_suspend(struct omap_mbox_queue *q)
+{
+	q->state = MBOX_QUEUE_SUSPEND;
+}
+
+int omap_mbox_send(struct omap_mbox *, mbox_msg_t msg, void *);
+int omap_mbox_send_sync(struct omap_mbox *, mbox_msg_t msg, void *);
 void omap_mbox_init_seq(struct omap_mbox *);
 
 struct omap_mbox *omap_mbox_get(const char *);
diff -ruN linux-omap-2.6/include/asm-arm/arch-omap/mcspi.h maemo_src/include/asm-arm/arch-omap/mcspi.h
--- linux-omap-2.6/include/asm-arm/arch-omap/mcspi.h	2011-02-06 20:17:26.073333272 -0500
+++ maemo_src/include/asm-arm/arch-omap/mcspi.h	2011-02-06 20:12:13.713333273 -0500
@@ -12,4 +12,8 @@
 	unsigned single_channel:1;
 };
 
+#ifdef CONFIG_SPI_OMAP_PAUSING
+void omap2_spi_pause(void);
+void omap2_spi_continue(void);
+#endif
 #endif
diff -ruN linux-omap-2.6/include/asm-arm/arch-omap/menelaus.h maemo_src/include/asm-arm/arch-omap/menelaus.h
--- linux-omap-2.6/include/asm-arm/arch-omap/menelaus.h	2011-02-06 20:17:26.073333272 -0500
+++ maemo_src/include/asm-arm/arch-omap/menelaus.h	2011-02-06 20:12:13.809999940 -0500
@@ -24,9 +24,9 @@
 
 extern int menelaus_set_vmem(unsigned int mV);
 extern int menelaus_set_vio(unsigned int mV);
-extern int menelaus_set_vmmc(unsigned int mV);
+extern int menelaus_set_vmmc(unsigned int mV, int low_power);
 extern int menelaus_set_vaux(unsigned int mV);
-extern int menelaus_set_vdcdc(int dcdc, unsigned int mV);
+extern int menelaus_set_vdcdc(int dcdc, unsigned int mV, int low_power);
 extern int menelaus_set_slot_sel(int enable);
 extern int menelaus_get_slot_pin_states(void);
 extern int menelaus_set_vcore_sw(unsigned int mV);
diff -ruN linux-omap-2.6/include/asm-arm/arch-omap/mmc.h maemo_src/include/asm-arm/arch-omap/mmc.h
--- linux-omap-2.6/include/asm-arm/arch-omap/mmc.h	2011-02-06 20:17:26.093333271 -0500
+++ maemo_src/include/asm-arm/arch-omap/mmc.h	2011-02-06 20:12:13.789999939 -0500
@@ -16,19 +16,16 @@
 #include <linux/mmc/protocol.h>
 #include <linux/mmc/host.h>
 
+#include <asm/arch/board.h>
+
 #define OMAP_MMC_MAX_SLOTS	2
 
 struct omap_mmc_platform_data {
-	unsigned enabled:1;
+	struct omap_mmc_conf  conf;
+
 	/* number of slots on board */
 	unsigned nr_slots:2;
-	/* nomux means "standard" muxing is wrong on this board, and that
-	 * board-specific code handled it before common init logic.
-	 */
-	unsigned nomux:1;
-	/* 4 wire signaling is optional, and is only used for SD/SDIO and
-	 * MMCv4 */
-	unsigned wire4:1;
+
 	/* set if your board has components or wiring that limits the
 	 * maximum frequency on the MMC bus */
 	unsigned int max_freq;
@@ -39,6 +36,7 @@
 	 * not supported */
 	int (* init)(struct device *dev);
 	void (* cleanup)(struct device *dev);
+	void (* shutdown)(struct device *dev);
 
 	struct omap_mmc_slot_data {
 		int (* set_bus_mode)(struct device *dev, int slot, int bus_mode);
@@ -55,6 +53,7 @@
 
 		const char *name;
 		u32 ocr_mask;
+		unsigned int ban_openended_read:1;
 	} slots[OMAP_MMC_MAX_SLOTS];
 };
 
@@ -64,4 +63,14 @@
 extern void omap_mmc_notify_card_detect(struct device *dev, int slot, int detected);
 extern void omap_mmc_notify_cover_event(struct device *dev, int slot, int is_closed);
 
+#ifdef CONFIG_MMC_PAUSING
+
+void mmc_running_lock(void);
+void mmc_running_unlock(void);
+
+#define mmc_pause()	mmc_running_lock()
+#define mmc_continue()	mmc_running_unlock()
+
+#endif
+
 #endif
diff -ruN linux-omap-2.6/include/asm-arm/arch-omap/mmu.h maemo_src/include/asm-arm/arch-omap/mmu.h
--- linux-omap-2.6/include/asm-arm/arch-omap/mmu.h	2011-02-06 20:17:26.093333271 -0500
+++ maemo_src/include/asm-arm/arch-omap/mmu.h	2011-02-06 20:12:13.786666606 -0500
@@ -115,6 +115,8 @@
 	struct device dev;
 
 	struct rw_semaphore exmap_sem;
+	struct mutex deadlock_skipper;
+	int deadlock_counter;
 	struct exmap_tbl *exmap_tbl;
 
 	unsigned int nr_tlb_entries;
diff -ruN linux-omap-2.6/include/asm-arm/arch-omap/observability.h maemo_src/include/asm-arm/arch-omap/observability.h
--- linux-omap-2.6/include/asm-arm/arch-omap/observability.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/include/asm-arm/arch-omap/observability.h	2007-10-02 03:09:32.000000000 -0400
@@ -0,0 +1,69 @@
+/*
+ * linux/include/asm-arm/arch-omap/observability.h
+ *
+ * Interface for using debug functionalities on OMAP24XX
+ *
+ * Copyright (C) 2006 Nokia Corporation
+ * Igor Stoppa <igor.stoppa@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef OMAP_OBSERVABILITY_H
+#define OMAP_OBSERVABILITY_H
+
+enum dbg_gpios {
+	OMAP2420_HW_DBG_GPIO49 = 0,
+	OMAP2420_HW_DBG_GPIO50,
+	OMAP2420_HW_DBG_GPIO51,
+	OMAP2420_HW_DBG_GPIO52,
+	OMAP2420_HW_DBG_GPIO53,
+	OMAP2420_HW_DBG_GPIO54,
+	OMAP2420_HW_DBG_GPIO55,
+	OMAP2420_HW_DBG_GPIO56,
+	OMAP2420_HW_DBG_GPIOS_NUM
+};
+
+enum omap_dbg_modes {
+	OMAP2420_HW_DBG_MODE_CAMERA = 0,
+	OMAP2420_HW_DBG_MODE_OBS,
+	OMAP2420_HW_DBG_MODE_GPIO,
+	OMAP2420_HW_DBG_MODE_PEEK,
+	OMAP2420_HW_DBG_MODES_NUM
+};
+
+enum omap_dbg_register_sizes {
+	OMAP2420_HW_DBG_REG_SIZE_1,
+	OMAP2420_HW_DBG_REG_SIZE_2,
+	OMAP2420_HW_DBG_REG_SIZE_4,
+	OMAP2420_HW_DBG_REG_SIZES_NUM
+};
+
+int omap_set_dbg_gpio_val(enum dbg_gpios gpio, u8 val);
+int omap_get_dbg_gpio_word(void);
+int omap_set_dbg_gpio_word(u8 val);
+void omap_set_dbg_mode(const enum omap_dbg_modes mode);
+inline void omap_dbg_set_register_size(const enum omap_dbg_register_sizes new_size);
+inline enum omap_dbg_register_sizes omap_dbg_get_register_size(void);
+inline void omap_dbg_set_address(unsigned * new_address);
+inline unsigned * omap_dbg_get_address(void);
+inline void omap_dbg_set_position(unsigned new_position);
+inline unsigned omap_dbg_get_position(void);
+inline void omap_dbg_set_visible_byte(u8 new_visible_byte);
+inline u8 omap_dbg_get_visible_byte(void);
+inline void omap_dbg_update_visible_byte(void);
+
+#endif
diff -ruN linux-omap-2.6/include/asm-arm/arch-omap/omapfb.h maemo_src/include/asm-arm/arch-omap/omapfb.h
--- linux-omap-2.6/include/asm-arm/arch-omap/omapfb.h	2011-02-06 20:17:26.116666606 -0500
+++ maemo_src/include/asm-arm/arch-omap/omapfb.h	2011-02-06 20:12:13.823333272 -0500
@@ -326,6 +326,7 @@
 					   int update_hw_mem);
 	int		(*set_color_key)  (struct omapfb_color_key *ck);
 	int		(*get_color_key)  (struct omapfb_color_key *ck);
+	void		(*freq_changed)   (void);
 };
 
 enum omapfb_state {
@@ -390,6 +391,11 @@
 /* in arch/arm/plat-omap/fb.c */
 extern void omapfb_set_ctrl_platform_data(void *pdata);
 
+
+#define OMAPFB_DVFS_PAUSE	0
+#define OMAPFB_DVFS_CONTINUE	1
+void omapfb_pause_set(int state);
+
 #endif /* __KERNEL__ */
 
 #endif /* __OMAPFB_H */
diff -ruN linux-omap-2.6/include/asm-arm/arch-omap/onenand.h maemo_src/include/asm-arm/arch-omap/onenand.h
--- linux-omap-2.6/include/asm-arm/arch-omap/onenand.h	2011-02-06 20:17:26.116666606 -0500
+++ maemo_src/include/asm-arm/arch-omap/onenand.h	2011-02-06 20:12:13.823333272 -0500
@@ -16,6 +16,8 @@
 	int			gpio_irq;
 	struct mtd_partition	*parts;
 	int			nr_parts;
-	int                     (*onenand_setup)(void __iomem *);
+	int                     (*onenand_setup)(void __iomem *, int freq);
 	int			dma_channel;
 };
+
+int omap2_onenand_rephase(void);
diff -ruN linux-omap-2.6/include/asm-arm/arch-omap/pa.h maemo_src/include/asm-arm/arch-omap/pa.h
--- linux-omap-2.6/include/asm-arm/arch-omap/pa.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/include/asm-arm/arch-omap/pa.h	2011-02-06 20:12:13.806666606 -0500
@@ -0,0 +1,72 @@
+/*
+ * linux/include/asm-arm/arch-omap/pa.h
+ *
+ * Copyright (C) 2007 Nokia Corporation
+ * Author: Sami Tolvanen
+ * Maintainer: Timo O. Karjalainen <timo.o.karjalainen@nokia.com>
+ *
+ * OMAP HS protected applications (PA) format handling
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef __ARCH_ARM_OMAP_PA_H
+#define __ARCH_ARM_OMAP_PA_H
+
+struct pa_format_command {
+	u32 cmd;
+	u8 filename[12];	/* TOC filename */
+	u8 sa;			/* Sub-application */
+	u8 index;		/* Function index */
+	u8 npar;
+	u8 nres;
+};
+
+struct pa_format_entry;
+
+struct pa_command {
+	struct pa_format_command *cmd;
+	struct pa_format_entry *par;
+	struct pa_format_entry *res;
+};
+
+struct pa_format {
+	struct pa_command *cmd;	/* Commands */
+	u32 ncmd;
+};
+
+typedef void *pa_ptr_conv(const void *);
+
+struct pa_command_data {
+	struct pa_command *c;
+	struct pa_format *format;
+	pa_ptr_conv *ptv;	/* Physical to virtual */
+	pa_ptr_conv *vtp;	/* Virtual to physical */
+	u32 cinp;
+	u32 coup;
+	u32 cpar;		/* PA parameter buffer size */
+	u32 cres;		/* PA result buffer size */
+	u8 *input;
+	u8 *output;
+	u8 *par;
+	u8 *res;
+	void *keys;		/* Public keys (KEYS) */
+	void *papub;		/* PA public keys (PAPUBKEYS) */
+};
+
+extern void *pa_image_address(u8 *base, struct pa_format_command *cmd);
+
+extern void pa_format_free(struct pa_format *p);
+
+extern int pa_format_parse(u8 *base, u32 size, struct pa_format *p);
+
+extern int pa_command_query(u32 cmd, u8 *input, u32 cinp, u32 *mininp,
+			    u32 *maxout, struct pa_format *p);
+
+extern int pa_command_prepare(u32 cmd, struct pa_command_data *p);
+
+extern int pa_command_finish(struct pa_command_data *p);
+
+#endif /* __ARCH_ARM_OMAP_PA_H */
diff -ruN linux-omap-2.6/include/asm-arm/arch-omap/pm.h maemo_src/include/asm-arm/arch-omap/pm.h
--- linux-omap-2.6/include/asm-arm/arch-omap/pm.h	2011-02-06 20:17:26.116666606 -0500
+++ maemo_src/include/asm-arm/arch-omap/pm.h	2011-02-06 20:12:13.836666607 -0500
@@ -130,7 +130,7 @@
  * clk_allow_idle - Counters previous clk_deny_idle
  * @clk: clock signal handle
  */
-void clk_deny_idle(struct clk *clk);
+void clk_allow_idle(struct clk *clk);
 
 extern void omap_pm_idle(void);
 extern void omap_pm_suspend(void);
diff -ruN linux-omap-2.6/include/asm-arm/arch-omap/sec.h maemo_src/include/asm-arm/arch-omap/sec.h
--- linux-omap-2.6/include/asm-arm/arch-omap/sec.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/include/asm-arm/arch-omap/sec.h	2011-02-06 20:12:13.806666606 -0500
@@ -0,0 +1,93 @@
+/*
+ * linux/include/asm-arm/arch-omap/sec.h
+ *
+ * Copyright (C) 2007 Nokia Corporation
+ * Author: Sami Tolvanen
+ * Maintainer: Timo O. Karjalainen <timo.o.karjalainen@nokia.com>
+ *
+ * OMAP HS secure mode driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef __ARCH_ARM_OMAP_SEC_H
+#define __ARCH_ARM_OMAP_SEC_H
+
+#define	SEC_CMD_NONE	 0
+#define	SEC_CMD_INIT	 1
+#define	SEC_CMD_SECS	 2
+#define	SEC_CMD_RANDOM	 3
+#define	SEC_CMD_PA_FIRST 0x100
+
+/* Return codes */
+#define SEC_NOTEXEC	0x00000000
+#define SEC_OK		0x00000001
+#define SEC_FAIL	0x00000002
+#define SEC_ENOMEM	0x00000007
+#define SEC_ENOPA	0xFFFFFFFF
+
+#define SEC_STORAGE_SIZE	4096
+
+struct sec_init {
+	struct device *dev; /* sysfs device */
+};
+
+struct sec_result {
+	u32 rv;		/* Secure ROM return value */
+	u8  data[0];	/* Variable length */
+};
+
+struct sec_pa_result {
+	u32 rom_rv;
+	u32 pa_rv;
+	u8  data[0];	/* Variable length */
+};
+
+/*
+ * DEVICE I/O INTERFACE
+ *
+ * Begin all commands with a 32-bit command code (SEC_CMD_* or SEC_CMD_PA_*)
+ * followed by 32-bit length of argument data. Structure of argument data is
+ * documented in per-command structure definitions below.
+ */
+struct sec_cmd_header {
+	u32 cmd;
+	u32 length;
+};
+
+struct sec_cmd_init_args {
+	u8 data[SEC_STORAGE_SIZE];	/* Secure storage contents */
+};
+/* Output of SEC_CMD_INIT is only return code. */
+
+/* SEC_CMD_SECS does not take arguments */
+
+struct sec_cmd_secs_output {
+	u32 len;
+	u8 data[SEC_STORAGE_SIZE];
+};
+
+struct sec_cmd_random_args {
+	u32 len;	/* How many bytes of random data you want */
+};
+/* Output of SEC_CMD_RANDOM is the requested number of random bytes. */
+
+struct sec_operations {
+	int (*init)(struct sec_init *);
+	void (*exit)(void);
+	u32 (*secenv_init)(void *data, u32 len);
+	u32 (*random_get)(void *buf, u32 len);
+	u32 (*pa_query)(u32 cmd, u8 *input, u32 len, u32 *cpar, u32 *cres);
+	void (*pa_service)(u32 cmd, u8 *input, u32 ilen,
+			   struct sec_pa_result *out, u32 olen);
+};
+
+extern int sec_register(struct sec_operations *ops);
+extern int sec_unregister(struct sec_operations *ops);
+extern struct device *sec_get_device(void);
+extern void sec_storage_write(void *storage, u32 size);
+
+#endif /* __ARCH_ARM_OMAP_SEC_H */
+
diff -ruN linux-omap-2.6/include/asm-arm/arch-omap/serial.h maemo_src/include/asm-arm/arch-omap/serial.h
--- linux-omap-2.6/include/asm-arm/arch-omap/serial.h	2011-02-06 19:45:04.263333274 -0500
+++ maemo_src/include/asm-arm/arch-omap/serial.h	2007-10-02 03:09:32.000000000 -0400
@@ -26,12 +26,4 @@
 #define OMAP1510_BASE_BAUD	(12000000/16)
 #define OMAP16XX_BASE_BAUD	(48000000/16)
 
-#define is_omap_port(p)	({int __ret = 0;			\
-			if (p == IO_ADDRESS(OMAP_UART1_BASE) ||	\
-			    p == IO_ADDRESS(OMAP_UART2_BASE) ||	\
-			    p == IO_ADDRESS(OMAP_UART3_BASE))	\
-				__ret = 1;			\
-			__ret;					\
-			})
-
 #endif
diff -ruN linux-omap-2.6/include/asm-arm/arch-omap/snapshot.h maemo_src/include/asm-arm/arch-omap/snapshot.h
--- linux-omap-2.6/include/asm-arm/arch-omap/snapshot.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/include/asm-arm/arch-omap/snapshot.h	2007-10-02 03:09:32.000000000 -0400
@@ -0,0 +1,38 @@
+/*
+ * linux/include/asm-arm/arch-omap/debug.h
+ *
+ * Interface for enabling debug functionalities on OMAP24XX
+ *
+ * Copyright (C) 2006 Nokia Corporation
+ * Igor Stoppa <igor.stoppa@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef OMAP_SNAPSHOT_H
+#define OMAP_SNAPSHOT_H
+
+#include <asm/mach-types.h>
+
+#define OMAP_SNAPSHOT_SIZE 500
+
+typedef u32 snapshot_t[2];
+
+void (*omap_snap_shot_ptr)(void);
+void omap_snapshot_push_address(u32 address);
+int omap_snapshot_pop_data(snapshot_t *read);
+
+#endif
diff -ruN linux-omap-2.6/include/asm-arm/futex.h maemo_src/include/asm-arm/futex.h
--- linux-omap-2.6/include/asm-arm/futex.h	2011-02-06 19:45:06.249999939 -0500
+++ maemo_src/include/asm-arm/futex.h	2011-02-06 20:12:13.839999940 -0500
@@ -1,6 +1,65 @@
-#ifndef _ASM_FUTEX_H
-#define _ASM_FUTEX_H
+#ifndef _ASM_ARM_FUTEX_H
+#define _ASM_ARM_FUTEX_H
 
-#include <asm-generic/futex.h>
+#ifdef __KERNEL__
+
+#include <linux/futex.h>
+#include <linux/errno.h>
+#include <linux/uaccess.h>
+#include <asm/atomic.h>
+
+static inline int
+futex_atomic_op_inuser(int encoded_op, int __user *uaddr)
+{
+	int op = (encoded_op >> 28) & 7;
+	int cmp = (encoded_op >> 24) & 15;
+	int oparg = (encoded_op << 8) >> 20;
+	int cmparg = (encoded_op << 20) >> 20;
+	int oldval = 0;
+	int ret;
+	if (encoded_op & (FUTEX_OP_OPARG_SHIFT << 28))
+		oparg = 1 << oparg;
+
+	if (!access_ok (VERIFY_WRITE, uaddr, sizeof(int)))
+		return -EFAULT;
+
+	pagefault_disable();
+
+	switch (op) {
+	case FUTEX_OP_SET:
+	case FUTEX_OP_ADD:
+	case FUTEX_OP_OR:
+	case FUTEX_OP_ANDN:
+	case FUTEX_OP_XOR:
+	default:
+		ret = -ENOSYS;
+	}
+
+	pagefault_enable();
+
+	if (!ret) {
+		switch (cmp) {
+		case FUTEX_OP_CMP_EQ: ret = (oldval == cmparg); break;
+		case FUTEX_OP_CMP_NE: ret = (oldval != cmparg); break;
+		case FUTEX_OP_CMP_LT: ret = (oldval < cmparg); break;
+		case FUTEX_OP_CMP_GE: ret = (oldval >= cmparg); break;
+		case FUTEX_OP_CMP_LE: ret = (oldval <= cmparg); break;
+		case FUTEX_OP_CMP_GT: ret = (oldval > cmparg); break;
+		default: ret = -ENOSYS;
+		}
+	}
+	return ret;
+}
+
+static inline int
+futex_atomic_cmpxchg_inatomic(int __user *uaddr, int oldval, int newval)
+{
+	if (!access_ok(VERIFY_WRITE, uaddr, sizeof(int)))
+		return -EFAULT;
+
+	return atomic_cmpxchg(uaddr, oldval, newval);
+}
+
+#endif
 
 #endif
diff -ruN linux-omap-2.6/include/asm-arm/pgtable.h maemo_src/include/asm-arm/pgtable.h
--- linux-omap-2.6/include/asm-arm/pgtable.h	2011-02-06 20:17:26.136666607 -0500
+++ maemo_src/include/asm-arm/pgtable.h	2011-02-06 20:12:13.839999940 -0500
@@ -170,6 +170,7 @@
 #define L_PTE_WRITE		(1 << 5)
 #define L_PTE_EXEC		(1 << 6)
 #define L_PTE_DIRTY		(1 << 7)
+#define L_PTE_EXTENDED		(1 << 9)	/* CB bits mapped to extended memory type */
 #define L_PTE_SHARED		(1 << 10)	/* shared(v6), coherent(xsc3) */
 
 #ifndef __ASSEMBLY__
@@ -291,6 +292,14 @@
  */
 #define pgprot_noncached(prot)	__pgprot(pgprot_val(prot) & ~(L_PTE_CACHEABLE | L_PTE_BUFFERABLE))
 #define pgprot_writecombine(prot) __pgprot(pgprot_val(prot) & ~L_PTE_CACHEABLE)
+#define pgprot_writethru(prot)	__pgprot(pgprot_val(prot) & ~L_PTE_BUFFERABLE)
+
+/* Extended config for non-shared device attributes */
+#define pgprot_nonshareddev(prot) __pgprot(pgprot_val(prot) | L_PTE_EXTENDED)
+/* Extended configurations for inner writeback cacheable */
+#define pgprot_writealloc(prot) __pgprot(pgprot_val(prot) | L_PTE_EXTENDED & ~L_PTE_CACHEABLE)
+#define pgprot_outer_wrthru(prot) __pgprot(pgprot_val(prot) | L_PTE_EXTENDED & ~L_PTE_BUFFERABLE)
+#define pgprot_outer_noncached(prot) __pgprot(pgprot_val(prot) | L_PTE_EXTENDED & ~(L_PTE_CACHEABLE | L_PTE_BUFFERABLE))
 
 #define pmd_none(pmd)		(!pmd_val(pmd))
 #define pmd_present(pmd)	(pmd_val(pmd))
diff -ruN linux-omap-2.6/include/asm-generic/vmlinux.lds.h maemo_src/include/asm-generic/vmlinux.lds.h
--- linux-omap-2.6/include/asm-generic/vmlinux.lds.h	2011-02-06 19:45:06.989999938 -0500
+++ maemo_src/include/asm-generic/vmlinux.lds.h	2007-10-02 03:09:32.000000000 -0400
@@ -229,3 +229,16 @@
   	*(.initcall7.init)						\
   	*(.initcall7s.init)
 
+#ifdef CONFIG_GCOV_PROFILE
+#define CONSTRUCTORS							\
+		__CTOR_LIST__ = .;					\
+		LONG((__CTOR_END__ - __CTOR_LIST__) / 4 - 2)		\
+		*(SORT_BY_NAME(.init_array))				\
+		LONG(0)							\
+		__CTOR_END__ = .;					\
+		__DTOR_LIST__ = .;					\
+		LONG((__DTOR_END__ - __DTOR_LIST__) / 4 - 2)		\
+		*(SORT_BY_NAME(.fini_array))				\
+		LONG(0)							\
+		__DTOR_END__ = .;
+#endif
diff -ruN linux-omap-2.6/include/linux/cpufreq.h maemo_src/include/linux/cpufreq.h
--- linux-omap-2.6/include/linux/cpufreq.h	2011-02-06 19:45:09.706666606 -0500
+++ maemo_src/include/linux/cpufreq.h	2007-10-02 03:09:33.000000000 -0400
@@ -46,6 +46,9 @@
 
 #define CPUFREQ_POLICY_POWERSAVE	(1)
 #define CPUFREQ_POLICY_PERFORMANCE	(2)
+#define CPUFREQ_POLICY_USERSPACE	(3)
+#define CPUFREQ_POLICY_NULL		(4)
+
 
 /* Frequency values here are CPU kHz so that hardware which doesn't run 
  * with some frequencies can complain without having to guess what per 
@@ -283,9 +286,19 @@
 #ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE
 extern struct cpufreq_governor cpufreq_gov_performance;
 #define CPUFREQ_DEFAULT_GOVERNOR	&cpufreq_gov_performance
+
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE)
 extern struct cpufreq_governor cpufreq_gov_userspace;
 #define CPUFREQ_DEFAULT_GOVERNOR	&cpufreq_gov_userspace
+
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE)
+extern struct cpufreq_governor cpufreq_gov_powersave;
+#define CPUFREQ_DEFAULT_GOVERNOR	&cpufreq_gov_powersave
+
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_NULL)
+extern struct cpufreq_governor cpufreq_gov_null;
+#define CPUFREQ_DEFAULT_GOVERNOR	&cpufreq_gov_null
+
 #endif
 
 
diff -ruN linux-omap-2.6/include/linux/gcov.h maemo_src/include/linux/gcov.h
--- linux-omap-2.6/include/linux/gcov.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/include/linux/gcov.h	2007-10-02 03:09:33.000000000 -0400
@@ -0,0 +1,243 @@
+/*
+ * include/linux/gcov.h
+ *
+ * Type declarations and macros used by GCOV kernel profiling.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (c) International Business Machines Corp., 2002-2003
+ *
+ * Author: Hubertus Franke <frankeh@us.ibm.com>
+ *         Peter Oberparleiter <peter.oberparleiter@de.ibm.com>
+ */
+
+#ifndef GCOV_H
+#define GCOV_H GCOV_H
+
+#include <linux/module.h>
+#include <asm/semaphore.h>
+#include <asm/types.h>
+
+#define GCC_VERSION_LOWER(major, minor) ((__GNUC__ < major) || \
+					 (__GNUC__ == major) && \
+					 (__GNUC_MINOR__ < minor))
+#define GCC_VERSION_EQUAL(major, minor)	 (__GNUC__ == major) && \
+					 (__GNUC_MINOR__ == minor)
+
+#if GCC_VERSION_LOWER(3, 1)
+
+/*
+ * Profiling types for GCC prior to version 3.1
+ */
+
+typedef long gcov_type;
+
+/* Same as gcc/libgcc2.c */
+struct bb
+{
+	long zero_word;
+	const char *filename;
+	long *counts;
+	long ncounts;
+	struct bb *next;
+	const unsigned long *addresses;
+	long nwords;
+	const char **functions;
+	const long *line_nums;
+	const char **filenames;
+	char *flags;
+};
+
+#elif GCC_VERSION_LOWER(3, 3)
+
+/*
+ * Profiling types for GCC 3.1 to 3.2
+ */
+
+#if BITS_PER_LONG >= 64
+typedef long gcov_type;
+#else
+typedef long long gcov_type;
+#endif
+
+/* Same as gcc/libgcc2.c */
+struct bb
+{
+	long zero_word;
+	const char *filename;
+	gcov_type *counts;
+	long ncounts;
+	struct bb *next;
+	const unsigned long *addresses;
+	long nwords;
+	const char **functions;
+	const long *line_nums;
+	const char **filenames;
+	char *flags;
+};
+
+#elif GCC_VERSION_EQUAL(3, 3) && CONFIG_GCOV_HAMMER
+
+/*
+ * Profiling types for modified GCC 3.3 (hammer patch)
+ */
+
+#define GCOV_DATA_MAGIC		0x67636f76
+#define GCOV_TAG_FUNCTION	0x01000000
+
+
+#if BITS_PER_LONG >= 64
+typedef long gcov_type;
+#else
+typedef long long gcov_type;
+#endif
+
+struct counter_section
+{
+	unsigned int tag;
+	unsigned int n_counters;
+};
+
+struct counter_section_data
+{
+	unsigned int tag;
+	unsigned int n_counters;
+	gcov_type *counters;
+};
+
+struct function_info
+{
+	const char *name;
+	unsigned int checksum;
+	unsigned int n_counter_sections;
+	const struct counter_section *counter_sections;
+};
+
+struct bb /* should be 'struct gcov_info' but we're sticking with the old name
+	   * so we can reuse some of our pre-3.4 functions */
+{
+	unsigned long version;
+	struct bb *next;
+	const char *filename;
+	long wkspc;
+	unsigned int n_functions;
+	const struct function_info *functions;
+	unsigned int n_counter_sections;
+	const struct counter_section_data *counter_sections;
+};
+
+extern unsigned long gcov_version;
+#elif GCC_VERSION_LOWER(3, 4)
+
+/*
+ * Profiling types for vanilla GCC 3.3
+ */
+
+typedef long long gcov_type;
+
+/* Same as gcc/libgcc2.c */
+struct bb_function_info
+{
+	long checksum;
+	int arc_count;
+	const char *name;
+};
+
+struct bb
+{
+	long zero_word;
+	const char *filename;
+	gcov_type *counts;
+	long ncounts;
+	struct bb *next;
+	long sizeof_bb;
+	struct bb_function_info *function_infos;
+};
+
+#else /* GCC_VERSION */
+
+/*
+ * Profiling types for GCC 3.4 and above (see gcc-3.4/gcc/gcov-io.h)
+ */
+
+#define GCOV_COUNTERS		5
+#define GCOV_DATA_MAGIC		((gcov_unsigned_t) 0x67636461)
+#define GCOV_TAG_FUNCTION	((gcov_unsigned_t) 0x01000000)
+#define GCOV_TAG_COUNTER_BASE	((gcov_unsigned_t) 0x01a10000)
+#define GCOV_TAG_FOR_COUNTER(COUNT)					\
+	(GCOV_TAG_COUNTER_BASE + ((gcov_unsigned_t) (COUNT) << 17))
+
+#if BITS_PER_LONG >= 64
+typedef long gcov_type;
+#else
+typedef long long gcov_type;
+#endif
+
+typedef unsigned int gcov_unsigned_t;
+typedef unsigned int gcov_position_t;
+
+typedef void (*gcov_merge_fn) (gcov_type *, gcov_unsigned_t);
+
+struct gcov_fn_info
+{
+	gcov_unsigned_t ident;
+	gcov_unsigned_t checksum;
+	unsigned int n_ctrs[0];			/* Note: the number of bits
+						 * set in bb->ctr_mask decides
+						 * how big this array is. */
+};
+
+struct gcov_ctr_info
+{
+	gcov_unsigned_t num;
+	gcov_type *values;
+	gcov_merge_fn merge;
+};
+
+struct bb /* should be 'struct gcov_info' but we're sticking with the old name
+	   * so we can reuse some of our pre-3.4 functions */
+{
+	gcov_unsigned_t version;
+	struct bb *next;
+	gcov_unsigned_t stamp;
+	const char *filename;
+	unsigned int n_functions;
+	const struct gcov_fn_info *functions;
+	unsigned int ctr_mask;
+	struct gcov_ctr_info counts[0];		/* Note: the number of bits
+						 * set in ctr_mask decides
+						 * how big this array is. */
+};
+
+extern gcov_unsigned_t gcov_version;
+#endif /* GCC_VERSION */
+
+enum gcov_cmd {
+	gcov_add,
+	gcov_remove
+};
+
+typedef void (*ctor_t)(void);
+
+extern struct bb *bb_head;
+extern const char *gcov_sourcepath;
+extern const char *gcov_objectpath;
+extern struct semaphore gcov_core_lock;
+
+extern void do_global_ctors(ctor_t[], unsigned long, struct module *);
+extern void (*gcov_callback)(enum gcov_cmd, struct bb *);
+extern void remove_bb_link(struct module *);
+
+#endif /* GCOV_H */
diff -ruN linux-omap-2.6/include/linux/hid.h maemo_src/include/linux/hid.h
--- linux-omap-2.6/include/linux/hid.h	2011-02-06 19:45:09.759999939 -0500
+++ maemo_src/include/linux/hid.h	2007-10-02 03:09:33.000000000 -0400
@@ -269,6 +269,7 @@
 #define HID_QUIRK_SONY_PS3_CONTROLLER		0x00080000
 #define HID_QUIRK_LOGITECH_S510_DESCRIPTOR	0x00100000
 #define HID_QUIRK_DUPLICATE_USAGES		0x00200000
+#define HID_QUIRK_SU_8W				0x00400000
 
 /*
  * This is the global environment of the parser. This information is
diff -ruN linux-omap-2.6/include/linux/jffs2.h maemo_src/include/linux/jffs2.h
--- linux-omap-2.6/include/linux/jffs2.h	2011-02-06 19:45:09.803333272 -0500
+++ maemo_src/include/linux/jffs2.h	2007-10-02 03:09:33.000000000 -0400
@@ -46,6 +46,7 @@
 #define JFFS2_COMPR_COPY	0x04
 #define JFFS2_COMPR_DYNRUBIN	0x05
 #define JFFS2_COMPR_ZLIB	0x06
+#define JFFS2_COMPR_LZO		0x07
 /* Compatibility flags. */
 #define JFFS2_COMPAT_MASK 0xc000      /* What do to if an unknown nodetype is found */
 #define JFFS2_NODE_ACCURATE 0x2000
diff -ruN linux-omap-2.6/include/linux/lm8323.h maemo_src/include/linux/lm8323.h
--- linux-omap-2.6/include/linux/lm8323.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/include/linux/lm8323.h	2007-10-02 03:09:33.000000000 -0400
@@ -0,0 +1,45 @@
+/*
+ * include/lm8323.h
+ *
+ * Configuration for LM8323 keypad driver.
+ */
+
+#ifndef __LINUX_LM8323_H
+#define __LINUX_LM8323_H
+
+#include <linux/types.h>
+
+/*
+ * Largest keycode that the chip can send, plus one,
+ * so keys can be mapped directly at the index of the
+ * LM8323 keycode instead of subtracting one.
+ */
+#define LM8323_KEYMAP_SIZE (0x7f + 1)
+
+/*
+ * Keymap is an array indexed with chip keycode, the array entry being
+ * the evdev (not AT) keycode.
+ */
+typedef s16 lm8323_km_t[LM8323_KEYMAP_SIZE];
+
+struct lm8323_platform_data {
+	u16 irq_gpio;
+
+	int debounce_time; /* Time to watch for key bouncing, in ms. */
+	int active_time; /* Idle time until sleep, in ms. */
+
+	int size_x;
+	int size_y;
+	int repeat : 1;
+	const s16 *keymap;
+
+	char *pwm1_name; /* Device name for PWM1. */
+	char *pwm2_name; /* Device name for PWM2. */
+	char *pwm3_name; /* Device name for PWM3. */
+
+	char *name; /* Device name. */
+};
+
+void __init lm8323_set_platform_data(struct lm8323_platform_data *pdata);
+
+#endif /* __LINUX_LM8323_H */
diff -ruN linux-omap-2.6/include/linux/lzo.h maemo_src/include/linux/lzo.h
--- linux-omap-2.6/include/linux/lzo.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/include/linux/lzo.h	2007-10-02 03:09:33.000000000 -0400
@@ -0,0 +1,44 @@
+#ifndef __LZO_H__
+#define __LZO_H__
+/*
+ *  LZO Public Kernel Interface
+ *  A mini subset of the LZO real-time data compression library
+ *
+ *  Copyright (C) 1996-2005 Markus F.X.J. Oberhumer <markus@oberhumer.com>
+ *
+ *  The full LZO package can be found at:
+ *  http://www.oberhumer.com/opensource/lzo/
+ *
+ *  Changed for kernel use by:
+ *  Nitin Gupta <nitingupta910@gmail.com>
+ *  Richard Purdie <rpurdie@openedhand.com>
+ */
+
+#define LZO1X_MEM_COMPRESS	(16384 * sizeof(unsigned char *))
+#define LZO1X_1_MEM_COMPRESS	LZO1X_MEM_COMPRESS
+
+#define lzo1x_worst_compress(x) ((x) + ((x) / 16) + 64 + 3)
+
+/* This requires 'workmem' of size LZO1X_1_MEM_COMPRESS */
+int lzo1x_1_compress(const unsigned char *src, size_t src_len,
+			unsigned char *dst, size_t *dst_len, void *wrkmem);
+
+/* safe decompression with overrun testing */
+int lzo1x_decompress_safe(const unsigned char *src, size_t src_len,
+			unsigned char *dst, size_t *dst_len);
+
+/*
+ * Return values (< 0 = Error)
+ */
+#define LZO_E_OK			0
+#define LZO_E_ERROR			(-1)
+#define LZO_E_OUT_OF_MEMORY		(-2)
+#define LZO_E_NOT_COMPRESSIBLE		(-3)
+#define LZO_E_INPUT_OVERRUN		(-4)
+#define LZO_E_OUTPUT_OVERRUN		(-5)
+#define LZO_E_LOOKBEHIND_OVERRUN	(-6)
+#define LZO_E_EOF_NOT_FOUND		(-7)
+#define LZO_E_INPUT_NOT_CONSUMED	(-8)
+#define LZO_E_NOT_YET_IMPLEMENTED	(-9)
+
+#endif
diff -ruN linux-omap-2.6/include/linux/mmc/card.h maemo_src/include/linux/mmc/card.h
--- linux-omap-2.6/include/linux/mmc/card.h	2011-02-06 19:45:11.113333272 -0500
+++ maemo_src/include/linux/mmc/card.h	2011-02-06 20:12:13.533333273 -0500
@@ -41,6 +41,7 @@
 
 struct mmc_ext_csd {
 	unsigned int		hs_max_dtr;
+	unsigned int		sectors;
 };
 
 struct sd_scr {
@@ -72,6 +73,7 @@
 #define MMC_STATE_READONLY	(1<<4)		/* card is read-only */
 #define MMC_STATE_HIGHSPEED	(1<<5)		/* card is in high speed mode */
 #define MMC_STATE_BLOCKADDR	(1<<6)		/* card uses block-addressing */
+	unsigned int            rq_state;       /* Last state at end of rq */
 	u32			raw_cid[4];	/* raw card CID */
 	u32			raw_csd[4];	/* raw card CSD */
 	u32			raw_scr[2];	/* raw card SCR */
diff -ruN linux-omap-2.6/include/linux/mmc/host.h maemo_src/include/linux/mmc/host.h
--- linux-omap-2.6/include/linux/mmc/host.h	2011-02-06 19:45:11.113333272 -0500
+++ maemo_src/include/linux/mmc/host.h	2011-02-06 20:12:13.539999940 -0500
@@ -16,30 +16,7 @@
 	unsigned int	clock;			/* clock rate */
 	unsigned short	vdd;
 
-#define	MMC_VDD_150	0
-#define	MMC_VDD_155	1
-#define	MMC_VDD_160	2
-#define	MMC_VDD_165	3
-#define	MMC_VDD_170	4
-#define	MMC_VDD_180	5
-#define	MMC_VDD_190	6
-#define	MMC_VDD_200	7
-#define	MMC_VDD_210	8
-#define	MMC_VDD_220	9
-#define	MMC_VDD_230	10
-#define	MMC_VDD_240	11
-#define	MMC_VDD_250	12
-#define	MMC_VDD_260	13
-#define	MMC_VDD_270	14
-#define	MMC_VDD_280	15
-#define	MMC_VDD_290	16
-#define	MMC_VDD_300	17
-#define	MMC_VDD_310	18
-#define	MMC_VDD_320	19
-#define	MMC_VDD_330	20
-#define	MMC_VDD_340	21
-#define	MMC_VDD_350	22
-#define	MMC_VDD_360	23
+/* vdd stores the bit number of the selected voltage range from protocol.h */
 
 	unsigned char	bus_mode;		/* command output mode */
 
@@ -57,6 +34,7 @@
 #define MMC_POWER_OFF		0
 #define MMC_POWER_UP		1
 #define MMC_POWER_ON		2
+#define MMC_POWER_STANDBY	3
 
 	unsigned char	bus_width;		/* data bus width */
 
@@ -95,6 +73,8 @@
 #define MMC_CAP_BYTEBLOCK	(1 << 2)	/* Can do non-log2 block sizes */
 #define MMC_CAP_MMC_HIGHSPEED	(1 << 3)	/* Can do MMC high-speed timing */
 #define MMC_CAP_SD_HIGHSPEED	(1 << 4)	/* Can do SD high-speed timing */
+#define MMC_CAP_STANDBY         (1 << 5)        /* Low power mode available */
+#define MMC_CAP_BAN_OPENENDED_READ (1 << 6)
 
 	/* host specific block data */
 	unsigned int		max_seg_size;	/* see blk_queue_max_segment_size */
@@ -122,6 +102,9 @@
 	struct mmc_card		*card_selected;	/* the selected MMC card */
 
 	struct delayed_work	detect;
+	struct work_struct	idle_work;
+	struct timer_list	idle_timer;
+	unsigned int		idle_delay;
 
 	unsigned long		private[0] ____cacheline_aligned;
 };
@@ -142,9 +125,9 @@
 
 extern int mmc_suspend_host(struct mmc_host *, pm_message_t);
 extern int mmc_resume_host(struct mmc_host *);
+extern void mmc_shutdown_host(struct mmc_host *host);
 
 extern void mmc_detect_change(struct mmc_host *, unsigned long delay);
 extern void mmc_request_done(struct mmc_host *, struct mmc_request *);
 
 #endif
-
diff -ruN linux-omap-2.6/include/linux/mmc/protocol.h maemo_src/include/linux/mmc/protocol.h
--- linux-omap-2.6/include/linux/mmc/protocol.h	2011-02-06 19:45:11.116666606 -0500
+++ maemo_src/include/linux/mmc/protocol.h	2011-02-06 20:12:13.553333272 -0500
@@ -164,6 +164,17 @@
 #define R1_READY_FOR_DATA	(1 << 8)	/* sx, a */
 #define R1_APP_CMD		(1 << 5)	/* sr, c */
 
+#define R1_STATE_IDLE           0
+#define R1_STATE_READY          1
+#define R1_STATE_IDENT          2
+#define R1_STATE_STBY           3
+#define R1_STATE_TRAN		4
+#define R1_STATE_DATA		5
+#define R1_STATE_REV		6
+#define R1_STATE_PRG		7
+#define R1_STATE_DIS		8
+#define R1_STATE_BTST		9
+
 /* These are unpacked versions of the actual responses */
 
 struct _mmc_csd {
@@ -208,14 +219,7 @@
 	u8  ecc;
 };
 
-#define MMC_VDD_145_150	0x00000001	/* VDD voltage 1.45 - 1.50 */
-#define MMC_VDD_150_155	0x00000002	/* VDD voltage 1.50 - 1.55 */
-#define MMC_VDD_155_160	0x00000004	/* VDD voltage 1.55 - 1.60 */
-#define MMC_VDD_160_165	0x00000008	/* VDD voltage 1.60 - 1.65 */
-#define MMC_VDD_165_170	0x00000010	/* VDD voltage 1.65 - 1.70 */
-#define MMC_VDD_17_18	0x00000020	/* VDD voltage 1.7 - 1.8 */
-#define MMC_VDD_18_19	0x00000040	/* VDD voltage 1.8 - 1.9 */
-#define MMC_VDD_19_20	0x00000080	/* VDD voltage 1.9 - 2.0 */
+#define MMC_VDD_165_195	0x00000080	/* VDD voltage 1.65 - 1.95 */
 #define MMC_VDD_20_21	0x00000100	/* VDD voltage 2.0 ~ 2.1 */
 #define MMC_VDD_21_22	0x00000200	/* VDD voltage 2.1 ~ 2.2 */
 #define MMC_VDD_22_23	0x00000400	/* VDD voltage 2.2 ~ 2.3 */
@@ -284,6 +288,7 @@
 #define EXT_CSD_BUS_WIDTH	183	/* R/W */
 #define EXT_CSD_HS_TIMING	185	/* R/W */
 #define EXT_CSD_CARD_TYPE	196	/* RO */
+#define EXT_CSD_SEC_CNT		212	/* RO, 4 bytes */
 
 /*
  * EXT_CSD field definitions
@@ -300,6 +305,8 @@
 #define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
 #define EXT_CSD_BUS_WIDTH_8	2	/* Card is in 8 bit mode */
 
+#define EXT_CSD_SEC_CNT_2GB     (2 << (30 - 9))
+
 /*
  * MMC_SWITCH access modes
  */
diff -ruN linux-omap-2.6/include/linux/module.h maemo_src/include/linux/module.h
--- linux-omap-2.6/include/linux/module.h	2011-02-06 19:45:11.123333274 -0500
+++ maemo_src/include/linux/module.h	2007-10-02 03:09:33.000000000 -0400
@@ -355,6 +355,11 @@
 	/* The command line arguments (may be mangled).  People like
 	   keeping pointers to this stuff */
 	char *args;
+
+	#ifdef CONFIG_GCOV_PROFILE
+	const char *ctors_start;        /* Pointer to start of .ctors-section */
+	const char *ctors_end;          /* Pointer to end of .ctors-section */
+	#endif
 };
 
 /* FIXME: It'd be nice to isolate modules during init, too, so they
diff -ruN linux-omap-2.6/include/linux/msdos_fs.h maemo_src/include/linux/msdos_fs.h
--- linux-omap-2.6/include/linux/msdos_fs.h	2011-02-06 19:45:11.126666607 -0500
+++ maemo_src/include/linux/msdos_fs.h	2011-02-06 20:12:13.366666605 -0500
@@ -205,7 +205,8 @@
 		 numtail:1,       /* Does first alias have a numeric '~1' type tail? */
 		 atari:1,         /* Use Atari GEMDOS variation of MS-DOS fs */
 		 flush:1,	  /* write things quickly */
-		 nocase:1;	  /* Does this need case conversion? 0=need case conversion*/
+		 nocase:1,	  /* Does this need case conversion? 0=need case conversion*/
+		 usefree:1;	  /* Use free_clusters for FAT32 */
 };
 
 #define FAT_HASH_BITS	8
diff -ruN linux-omap-2.6/include/linux/mtd/mtd.h maemo_src/include/linux/mtd/mtd.h
--- linux-omap-2.6/include/linux/mtd/mtd.h	2011-02-06 19:45:11.136666606 -0500
+++ maemo_src/include/linux/mtd/mtd.h	2011-02-06 20:12:13.609999939 -0500
@@ -151,6 +151,15 @@
 	int (*read) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
 	int (*write) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf);
 
+	/* In blackbox flight recorder like scenarios we want to make successful
+	   writes in interrupt context. panic_write() is only intended to be
+	   called when its known the kernel is about to panic and we need the
+	   write to succeed. Since the kernel is not going to be running for much
+	   longer, this function can break locks and delay to ensure the write
+	   succeeds (but not sleep). */
+
+	int (*panic_write) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf);
+
 	int (*read_oob) (struct mtd_info *mtd, loff_t from,
 			 struct mtd_oob_ops *ops);
 	int (*write_oob) (struct mtd_info *mtd, loff_t to,
diff -ruN linux-omap-2.6/include/linux/sched.h maemo_src/include/linux/sched.h
--- linux-omap-2.6/include/linux/sched.h	2011-02-06 19:45:11.756666605 -0500
+++ maemo_src/include/linux/sched.h	2007-10-02 03:09:33.000000000 -0400
@@ -226,6 +226,7 @@
 extern void softlockup_tick(void);
 extern void spawn_softlockup_task(void);
 extern void touch_softlockup_watchdog(void);
+extern void touch_all_softlockup_watchdogs(void);
 #else
 static inline void softlockup_tick(void)
 {
@@ -236,6 +237,9 @@
 static inline void touch_softlockup_watchdog(void)
 {
 }
+static inline void touch_all_softlockup_watchdogs(void)
+{
+}
 #endif
 
 
diff -ruN linux-omap-2.6/include/linux/serial_core.h maemo_src/include/linux/serial_core.h
--- linux-omap-2.6/include/linux/serial_core.h	2011-02-06 19:45:11.769999940 -0500
+++ maemo_src/include/linux/serial_core.h	2007-10-02 03:09:33.000000000 -0400
@@ -135,6 +135,9 @@
 /* Xilinx uartlite */
 #define PORT_UARTLITE	74
 
+/* omap */
+#define PORT_OMAP	75
+
 #ifdef __KERNEL__
 
 #include <linux/compiler.h>
diff -ruN linux-omap-2.6/include/linux/spi/spi.h maemo_src/include/linux/spi/spi.h
--- linux-omap-2.6/include/linux/spi/spi.h	2011-02-06 19:45:11.789999938 -0500
+++ maemo_src/include/linux/spi/spi.h	2007-10-02 03:09:33.000000000 -0400
@@ -71,6 +71,7 @@
 #define	SPI_MODE_3	(SPI_CPOL|SPI_CPHA)
 #define	SPI_CS_HIGH	0x04			/* chipselect active high? */
 #define	SPI_LSB_FIRST	0x08			/* per-word bits-on-wire */
+#define SPI_MOSI_HIGH	0x10			/* TX high while receiving */
 	u8			bits_per_word;
 	int			irq;
 	void			*controller_state;
diff -ruN linux-omap-2.6/include/linux/spi/tsc2005.h maemo_src/include/linux/spi/tsc2005.h
--- linux-omap-2.6/include/linux/spi/tsc2005.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/include/linux/spi/tsc2005.h	2011-02-06 20:12:13.593333274 -0500
@@ -0,0 +1,29 @@
+#ifndef _LINUX_SPI_TSC2005_H
+#define _LINUX_SPI_TSC2005_H
+
+#include <linux/types.h>
+
+struct tsc2005_platform_data {
+	s16	reset_gpio;
+	s16	dav_gpio;
+	s16	pen_int_gpio;
+	u16	ts_x_plate_ohm;
+	u32	ts_stab_time;	/* voltage settling time */
+	u8	ts_hw_avg;	/* HW assiseted averaging. Can be
+				   0, 4, 8, 16 samples per reading */
+	u32	ts_touch_pressure;	/* Pressure limit until we report a
+					   touch event. After that we switch
+					   to ts_max_pressure. */
+	u32	ts_pressure_max;/* Samples with bigger pressure value will
+				   be ignored, since the corresponding X, Y
+				   values are unreliable */
+	u32	ts_pressure_fudge;
+	u32	ts_x_max;
+	u32	ts_x_fudge;
+	u32	ts_y_max;
+	u32	ts_y_fudge;
+
+	unsigned ts_ignore_last : 1;
+};
+
+#endif
diff -ruN linux-omap-2.6/include/linux/spi/tsc2301.h maemo_src/include/linux/spi/tsc2301.h
--- linux-omap-2.6/include/linux/spi/tsc2301.h	2011-02-06 20:17:26.149999939 -0500
+++ maemo_src/include/linux/spi/tsc2301.h	2011-02-06 20:12:13.593333273 -0500
@@ -12,23 +12,27 @@
 	s16	keyb_int;
 	s16	keymap[16];	/* Set a key to a negative value if not used */
 	unsigned kp_rep:1;	/* Enable keypad repeating */
+	char    *keyb_name;     /* Keyboard device name */
 
 	/*
 	 * Touchscreen
 	 */
 	s16	dav_gpio;
-	s16	pen_int_gpio;
 	u16	ts_x_plate_ohm;
 	u32	ts_stab_time;	/* voltage settling time */
 	u8	ts_hw_avg;	/* HW assiseted averaging. Can be
 				   0, 4, 8, 16 samples per reading */
-	u32	ts_max_pressure;/* Samples with bigger pressure value will
-				   be ignored, since the corresponding X, Y
-				   values are unreliable */
 	u32	ts_touch_pressure;	/* Pressure limit until we report a
 					   touch event. After that we switch
 					   to ts_max_pressure. */
-	unsigned ts_ignore_last : 1;
+	u32	ts_pressure_max;/* Samples with bigger pressure value will
+				   be ignored, since the corresponding X, Y
+				   values are unreliable */
+	u32	ts_pressure_fudge;
+	u32	ts_x_max;
+	u32	ts_x_fudge;
+	u32	ts_y_max;
+	u32	ts_y_fudge;
 
 	/*
 	 * Audio
@@ -50,7 +54,6 @@
 	void (* codec_cleanup)(struct device *tsc2301_dev);
 	int	(*enable_clock)(struct device *dev);
 	void	(*disable_clock)(struct device *dev);
-	int	(*get_keyb_irq_state)(struct device *dev);
 
 	const struct tsc2301_mixer_gpio {
 		const char	*name;
diff -ruN linux-omap-2.6/include/linux/timer.h maemo_src/include/linux/timer.h
--- linux-omap-2.6/include/linux/timer.h	2011-02-06 19:45:11.816666605 -0500
+++ maemo_src/include/linux/timer.h	2007-10-02 03:09:33.000000000 -0400
@@ -37,6 +37,7 @@
 		TIMER_INITIALIZER(_function, _expires, _data)
 
 void fastcall init_timer(struct timer_list * timer);
+void fastcall init_timer_deferrable(struct timer_list *timer);
 
 static inline void setup_timer(struct timer_list * timer,
 				void (*function)(unsigned long),
diff -ruN linux-omap-2.6/include/linux/tlv320aic33.h maemo_src/include/linux/tlv320aic33.h
--- linux-omap-2.6/include/linux/tlv320aic33.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/include/linux/tlv320aic33.h	2011-02-06 20:12:13.443333272 -0500
@@ -0,0 +1,104 @@
+/*
+ * tlv320aic33.h -- Definitions for Texas Instruments TLV320AIC33 Audio Codec
+ *
+ * Copyright (C) 2007 Nokia Corporation.
+ *
+ * Contact: Jarkko Nikula <jarkko.nikula@nokia.com>
+ *          Eero Nurkkala
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __TLV320AIC33_H
+#define __TLV320AIC33_H
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <linux/i2c.h>
+
+#define SIZE_REG_CACHE		100
+#define SIZE_IGAIN_CACHE	8 /* input level control registers 17-24 */
+
+enum aic33_micbias {
+	AIC33_MICBIAS_OFF,
+	AIC33_MICBIAS_2V,
+	AIC33_MICBIAS_2V5,
+	AIC33_MICBIAS_AVDD,
+};
+
+enum aic33_dmic_rate {
+	AIC33_DMIC_DISABLED,
+	AIC33_DMIC_OVERSAMPLING_128,
+	AIC33_DMIC_OVERSAMPLING_64,
+	AIC33_DMIC_OVERSAMPLING_32,
+};
+
+/* digital mic configuration */
+struct aic33_dmic_data {
+	enum aic33_dmic_rate	dmic_rate;
+
+	/* set if dmic needs bias voltage from AIC33 */
+	unsigned		needs_bias:1;
+	enum aic33_micbias	dmic_bias;
+};
+
+/* high-power output configuration */
+struct aic33_hp_data {
+	unsigned		ac_coupled:1;
+	unsigned		pd_tri_stated:1;
+};
+
+enum aic33_adc_hp_filter {
+	AIC33_ADC_HP_DISABLED,
+	AIC33_ADC_HP_0_0045xFS,	/* 0.0045 x Fs */
+	AIC33_ADC_HP_0_0125xFs,	/* 0.0125 x Fs */
+	AIC33_ADC_HP_0_025xFs,	/* 0.025 x Fs */
+};
+
+struct aic33_platform_data {
+	void		(*codec_reset)(int reset_active);
+	int		(*codec_init)(struct device *aic33_dev);
+	void		(*codec_cleanup)(struct device *aic33_dev);
+	int		(*enable_clock)(struct device *dev);
+	void		(*disable_clock)(struct device *dev);
+
+	void		(*ext_hp_amplifier_ctrl)(struct device *dev, int on);
+	void		(*ext_lo_amplifier_ctrl)(struct device *dev, int on);
+
+	unsigned	pll_p;
+	unsigned	pll_r;
+	unsigned	pll_j;
+	unsigned	pll_d;
+
+	/* bit and word clock directions */
+	unsigned	bclk_output:1;
+	unsigned	wclk_output:1;
+
+	enum aic33_adc_hp_filter	adc_hp_filter;
+
+	/* digital mic configuration. NULL if not used */
+	struct aic33_dmic_data		*dmic_data;
+	/* high-power output configuration. NULL if not used */
+	struct aic33_hp_data		*hp_data;
+};
+
+extern void aic33_mixer_set_power(struct device *dev, int dac, int adc);
+extern int aic33_mixer_register_controls(struct device *dev,
+					 struct snd_card *card);
+extern int aic33_enable_mclk(struct device *dev);
+extern void aic33_disable_mclk(struct device *dev);
+
+#endif
diff -ruN linux-omap-2.6/include/linux/tsl2563.h maemo_src/include/linux/tsl2563.h
--- linux-omap-2.6/include/linux/tsl2563.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/include/linux/tsl2563.h	2007-10-02 03:09:33.000000000 -0400
@@ -0,0 +1,34 @@
+/*
+ * tsl2563.h
+ *
+ * Copyright (C) 2007 Nokia Corporation.
+ *
+ * Contact: Jarkko Nikula <jarkko.nikula@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#ifndef __TSL2563_H
+#define __TSL2563_H
+
+#include <linux/device.h>
+
+struct tsl2563_platform_data {
+	unsigned int	irq;
+	void		(*set_power)(struct device *dev, int on);
+};
+
+#endif
diff -ruN linux-omap-2.6/include/linux/usb/musb.h maemo_src/include/linux/usb/musb.h
--- linux-omap-2.6/include/linux/usb/musb.h	2011-02-06 20:17:26.169999940 -0500
+++ maemo_src/include/linux/usb/musb.h	2007-10-02 03:09:33.000000000 -0400
@@ -55,7 +55,7 @@
 
 #define	TUSB6010_OSCCLK_60	16667	/* psec/clk @ 60.0 MHz */
 #define	TUSB6010_REFCLK_24	41667	/* psec/clk @ 24.0 MHz XI */
-#define	TUSB6010_REFCLK_19	52633	/* psec/clk @ 19.2 MHz CLKIN */
+#define	TUSB6010_REFCLK_19	52083	/* psec/clk @ 19.2 MHz CLKIN */
 
 #ifdef	CONFIG_ARCH_OMAP2
 
diff -ruN linux-omap-2.6/include/linux/usb/otg.h maemo_src/include/linux/usb/otg.h
--- linux-omap-2.6/include/linux/usb/otg.h	2011-02-06 19:45:11.833333273 -0500
+++ maemo_src/include/linux/usb/otg.h	2011-02-06 20:12:13.433333273 -0500
@@ -31,6 +31,13 @@
 	OTG_STATE_A_VBUS_ERR,
 };
 
+enum usb_otg_error {
+	OTG_ERR_DEVICE_SUPPORTED,
+	OTG_ERR_DEVICE_NOT_SUPPORTED,
+	OTG_ERR_DEVICE_NOT_RESPONDING,
+	OTG_ERR_HUB_NOT_SUPPORTED,
+};
+
 /*
  * the otg driver needs to interact with both device side and host side
  * usb controllers.  it decides which controller is active at a given
@@ -42,7 +49,10 @@
 	const char		*label;
 
 	u8			default_a;
+	unsigned		tpl_enabled:1;
+
 	enum usb_otg_state	state;
+	enum usb_otg_error	last_error;
 
 	struct usb_bus		*host;
 	struct usb_gadget	*gadget;
@@ -79,9 +89,12 @@
 /* for board-specific init logic */
 extern int otg_set_transceiver(struct otg_transceiver *);
 
-
+#ifdef CONFIG_USB_OTG
 /* for usb host and peripheral controller drivers */
 extern struct otg_transceiver *otg_get_transceiver(void);
+#else
+#define otg_get_transceiver(x)	NULL
+#endif
 
 static inline int
 otg_start_hnp(struct otg_transceiver *otg)
@@ -89,6 +102,7 @@
 	return otg->start_hnp(otg);
 }
 
+extern void otg_set_error(struct otg_transceiver *otg, enum usb_otg_error);
 
 /* for HCDs */
 static inline int
@@ -129,3 +143,11 @@
 
 /* for OTG controller drivers (and maybe other stuff) */
 extern int usb_bus_start_enum(struct usb_bus *bus, unsigned port_num);
+
+#ifdef CONFIG_USB_OTG_WHITELIST
+struct usb_device;
+extern int otg_targeted(struct usb_device *dev);
+extern ssize_t otg_print_whitelist(char *buf);
+#else
+#define otg_targeted(x)		OTG_ERR_DEVICE_SUPPORTED
+#endif
diff -ruN linux-omap-2.6/include/linux/workqueue.h maemo_src/include/linux/workqueue.h
--- linux-omap-2.6/include/linux/workqueue.h	2011-02-06 19:45:11.849999938 -0500
+++ maemo_src/include/linux/workqueue.h	2007-10-02 03:09:33.000000000 -0400
@@ -121,6 +121,12 @@
 		init_timer(&(_work)->timer);			\
 	} while (0)
 
+#define INIT_DELAYED_WORK_DEFERRABLE(_work, _func)			\
+	do {							\
+		INIT_WORK(&(_work)->work, (_func));		\
+		init_timer_deferrable(&(_work)->timer);		\
+	} while (0)
+
 /**
  * work_pending - Find out whether a work item is currently pending
  * @work: The work item in question
diff -ruN linux-omap-2.6/include/net/bluetooth/l2cap.h maemo_src/include/net/bluetooth/l2cap.h
--- linux-omap-2.6/include/net/bluetooth/l2cap.h	2011-02-06 19:45:11.869999939 -0500
+++ maemo_src/include/net/bluetooth/l2cap.h	2007-10-02 03:09:33.000000000 -0400
@@ -129,8 +129,10 @@
 	__u8       data[0];
 } __attribute__ ((packed));
 
-#define L2CAP_CONF_SUCCESS	0x00
-#define L2CAP_CONF_UNACCEPT	0x01
+#define L2CAP_CONF_SUCCESS	0x0000
+#define L2CAP_CONF_UNACCEPT	0x0001
+#define L2CAP_CONF_REJECT	0x0002
+#define L2CAP_CONF_UNKNOWN	0x0003
 
 struct l2cap_conf_opt {
 	__u8       type;
@@ -215,6 +217,8 @@
 
 	__u32		link_mode;
 
+	__u8		conf_req[64];
+	__u8		conf_len;
 	__u8		conf_state;
 	__u8		conf_retry;
 	__u16		conf_mtu;
diff -ruN linux-omap-2.6/include/net/bluetooth/rfcomm.h maemo_src/include/net/bluetooth/rfcomm.h
--- linux-omap-2.6/include/net/bluetooth/rfcomm.h	2011-02-06 19:45:11.873333272 -0500
+++ maemo_src/include/net/bluetooth/rfcomm.h	2007-10-02 03:09:33.000000000 -0400
@@ -323,6 +323,7 @@
 #define RFCOMM_RELEASE_ONHUP  1
 #define RFCOMM_HANGUP_NOW     2
 #define RFCOMM_TTY_ATTACHED   3
+#define RFCOMM_TTY_RELEASED   4
 
 struct rfcomm_dev_req {
 	s16      dev_id;
diff -ruN linux-omap-2.6/kernel/gcov/gcov-core.c maemo_src/kernel/gcov/gcov-core.c
--- linux-omap-2.6/kernel/gcov/gcov-core.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/kernel/gcov/gcov-core.c	2007-10-02 03:09:33.000000000 -0400
@@ -0,0 +1,294 @@
+/*
+ * kernel/gcov/gcov-core.c
+ *
+ * Core functionality for GCOV kernel profiling.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (c) International Business Machines Corp., 2002-2006
+ *
+ * Author: Hubertus Franke <frankeh@us.ibm.com>
+ *         Rajan Ravindran <rajancr@us.ibm.com>
+ *         Peter Oberparleiter <Peter.Oberparleiter@de.ibm.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/gcov.h>
+#include <linux/unistd.h>
+#include <linux/syscalls.h>
+#include <asm/semaphore.h>
+
+/* Newer kernel versions no longer support EXPORT_SYMBOL_NOVERS */
+#ifndef EXPORT_SYMBOL_NOVERS
+#define EXPORT_SYMBOL_NOVERS(x)	EXPORT_SYMBOL(x)
+#endif
+
+#define GCOV_CORE_HEADER	"gcov-core: "
+
+/* This structure is used to keep track of all struct bbs associated with a
+ * module. */
+struct gcov_context
+{
+	struct list_head list;
+	struct module *module;
+	unsigned long count;
+	struct bb **bb;
+};
+
+struct ctor_list
+{
+	unsigned long num;
+	ctor_t ctor[];
+};
+
+/* Start of global constructor list. Declared in vmlinux-ld script.  */
+extern struct ctor_list __CTOR_LIST__;
+
+/* Linked list for registered struct bbs. */
+struct bb *bb_head;
+
+/* Callback informed of struct bb addition and removal. */
+void (*gcov_callback)(enum gcov_cmd, struct bb *bbptr) = NULL;
+
+/* Path to kernel files. */
+const char *gcov_sourcepath = GCOV_SRC_PATH;
+const char *gcov_objectpath = GCOV_OBJ_PATH;
+
+/* List of contexts for registered bb entries. */
+static LIST_HEAD(context_list);
+
+/* Context into which blocks are inserted during initialization. */
+static struct gcov_context *current_context;
+
+/* Protect global variables from concurrent access. */
+DECLARE_MUTEX(gcov_core_lock);
+
+#if GCC_VERSION_LOWER(3, 4) && !CONFIG_GCOV_HAMMER
+static const char *gcov_format = "pre-gcc_3.4";
+
+/* Register supplied struct BB. Called by each object code constructor. */
+void
+__bb_init_func(struct bb *bb)
+{
+	if (bb->zero_word)
+		return;
+	/* Set up linked list */
+	bb->zero_word = 1;
+	bb->next = bb_head;
+	bb_head = bb;
+	/* Associate with module context */
+	if (current_context)
+		current_context->bb[current_context->count++] = bb;
+	/* Notify callback */
+	if (gcov_callback != NULL)
+		(*gcov_callback)(gcov_add, bb);
+}
+
+
+/* Unused functions needed to prevent linker errors. */
+void __bb_fork_func(void) {}
+
+EXPORT_SYMBOL_NOVERS(__bb_init_func);
+EXPORT_SYMBOL_NOVERS(__bb_fork_func);
+#elif GCC_VERSION_EQUAL(3, 3) && CONFIG_GCOV_HAMMER
+static const char *gcov_format = "gcc_3.3_(hammer)";
+unsigned long gcov_version;
+
+/* Register supplied struct BB. Called by each object code constructor. */
+void
+__gcov_init(struct bb *bb)
+{
+	if (!bb->version)
+		return;
+	/* Check for compatible gcc version */
+	if (gcov_version == 0)
+		gcov_version = bb->version;
+	else if (bb->version != gcov_version) {
+		printk(KERN_WARNING GCOV_CORE_HEADER "gcc version mismatch in "
+		       "file '%s'!\n", bb->filename);
+		return;
+	}
+	/* Set up linked list */
+	bb->version = 0;
+	bb->next = bb_head;
+	bb_head = bb;
+	/* Associate with module context */
+	if (current_context)
+		current_context->bb[current_context->count++] = bb;
+	/* Notify callback */
+	if (gcov_callback != NULL)
+		(*gcov_callback)(gcov_add, bb);
+}
+
+void __gcov_flush(void) {}
+
+EXPORT_SYMBOL_NOVERS(gcov_version);
+EXPORT_SYMBOL_NOVERS(__gcov_init);
+EXPORT_SYMBOL_NOVERS(__gcov_flush);
+#else
+static const char *gcov_format = "gcc_3.4";
+gcov_unsigned_t gcov_version = 0;
+
+/* Register supplied struct BB. Called by each object code constructor. */
+void
+__gcov_init(struct bb *bb)
+{
+	if (!bb->version)
+		return;
+	/* Check for compatible gcc version */
+	if (gcov_version == 0)
+		gcov_version = bb->version;
+	else if (bb->version != gcov_version) {
+		printk(KERN_WARNING GCOV_CORE_HEADER "gcc version mismatch in "
+		       "file '%s'!\n", bb->filename);
+		return;
+	}
+	/* Set up linked list */
+	bb->version = 0;
+	bb->next = bb_head;
+	bb_head = bb;
+	/* Associate with module context */
+	if (current_context)
+		current_context->bb[current_context->count++] = bb;
+	/* Notify callback */
+	if (gcov_callback != NULL)
+		(*gcov_callback)(gcov_add, bb);
+}
+
+
+/* Unused functions needed to prevent linker errors. */
+void __gcov_flush(void) {}
+void __gcov_merge_add(gcov_type *counters, unsigned int n_counters) {}
+void __gcov_merge_single(gcov_type *counters, unsigned int n_counters) {}
+void __gcov_merge_delta(gcov_type *counters, unsigned int n_counters) {}
+int __gcov_execve(const char *path, char *const argv[], char *const envp[])
+{
+	return kernel_execve(path, argv, envp);
+}
+
+EXPORT_SYMBOL_NOVERS(gcov_version);
+EXPORT_SYMBOL_NOVERS(__gcov_init);
+EXPORT_SYMBOL_NOVERS(__gcov_flush);
+EXPORT_SYMBOL_NOVERS(__gcov_merge_add);
+EXPORT_SYMBOL_NOVERS(__gcov_merge_single);
+EXPORT_SYMBOL_NOVERS(__gcov_merge_delta);
+EXPORT_SYMBOL_NOVERS(__gcov_execve);
+#endif /* GCC_VERSION */
+
+
+/* Call NUM constructors in CTOR. If defined, MODULE specifies that resulting
+ * bb data be associated with module. */
+void
+do_global_ctors(ctor_t ctor[], unsigned long num, struct module *module)
+{
+	unsigned long i;
+
+	down(&gcov_core_lock);
+	if (module) {
+		/* Create a context to associate struct bbs with this MODULE */
+		current_context = (struct gcov_context *) kmalloc(
+					sizeof(struct gcov_context) +
+					num * sizeof(struct bb *),
+					GFP_KERNEL);
+		if (!current_context) {
+			printk(KERN_WARNING GCOV_CORE_HEADER "not enough memory"
+			       " for coverage data!\n");
+			up(&gcov_core_lock);
+			return;
+		}
+		current_context->module = module;
+		current_context->count = 0;
+		current_context->bb = (struct bb **) (current_context + 1);
+		list_add(&current_context->list, &context_list);
+	}
+	/* Call constructors */
+	for (i = 0; i < num && ctor[i]; i++)
+		ctor[i]();
+	current_context = NULL;
+	up(&gcov_core_lock);
+}
+
+
+/* Remove data associated with MODULE. */
+void
+remove_bb_link(struct module *module)
+{
+	struct gcov_context* context;
+	struct gcov_context* tmp;
+	struct bb *bb;
+	struct bb *prev;
+	unsigned long i;
+
+	down(&gcov_core_lock);
+	/* Get associated context */
+	context = NULL;
+	list_for_each_entry(tmp, &context_list, list) {
+		if (tmp->module == module) {
+			context = tmp;
+			break;
+		}
+	}
+	if (!context) {
+		up(&gcov_core_lock);
+		return;
+	}
+	/* Remove all bb entries belonging to this module */
+	prev = NULL;
+	for (bb = bb_head; bb ; bb = bb->next) {
+		for (i = 0; i < context->count; i++) {
+			if (context->bb[i] == bb) {
+				/* Detach bb from list. */
+				if (prev)
+					prev->next = bb->next;
+				else
+					bb_head = bb->next;
+				/* Notify callback */
+				if (gcov_callback)
+					(*gcov_callback)(gcov_remove, bb);
+				break;
+			}
+		}
+		if (i == context->count)
+			prev = bb;
+	}
+	list_del(&context->list);
+	kfree(context);
+	up(&gcov_core_lock);
+}
+
+
+static int __init
+gcov_core_init(void)
+{
+	printk(KERN_INFO GCOV_CORE_HEADER "initializing core module: "
+	       "format=%s\n", gcov_format);
+	do_global_ctors(__CTOR_LIST__.ctor, __CTOR_LIST__.num, NULL);
+	printk(KERN_INFO GCOV_CORE_HEADER "init done\n");
+	return 0;
+}
+
+module_init(gcov_core_init);
+
+
+EXPORT_SYMBOL_NOVERS(bb_head);
+EXPORT_SYMBOL_NOVERS(gcov_sourcepath);
+EXPORT_SYMBOL_NOVERS(gcov_objectpath);
+EXPORT_SYMBOL_NOVERS(gcov_callback);
+EXPORT_SYMBOL_NOVERS(gcov_core_lock);
+EXPORT_SYMBOL_NOVERS(do_global_ctors);
diff -ruN linux-omap-2.6/kernel/gcov/gcov-proc.c maemo_src/kernel/gcov/gcov-proc.c
--- linux-omap-2.6/kernel/gcov/gcov-proc.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/kernel/gcov/gcov-proc.c	2007-10-02 03:09:33.000000000 -0400
@@ -0,0 +1,2146 @@
+/*
+ * kernel/gcov/gcov-proc.c
+ *
+ * Provides proc filesystem entry for GCOV kernel profiling.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (c) International Business Machines Corp., 2002-2003
+ *
+ * Author: Hubertus Franke <frankeh@us.ibm.com>
+ *         Rajan Ravindran <rajancr@us.ibm.com>
+ *         Peter Oberparleiter <Peter.Oberparleiter@de.ibm.com>
+ *         Paul Larson
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/proc_fs.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+#include <linux/gcov.h>
+
+
+MODULE_LICENSE("GPL");
+
+#define GCOV_PROC_HEADER	"gcov-proc: "
+#define GCOV_PROC_ROOT		"gcov"
+#define GCOV_PROC_MODULE	"module"
+#define GCOV_PROC_VMLINUX	"vmlinux"
+#define PAD8(x)			(((x) + 7) & ~7)
+#define PAD4(x)			(((x) + 3) & ~3)
+
+typedef enum {
+	status_normal,	/* Normal status */
+	status_ghost	/* Module associated with this node has been unloaded
+			 * but data was saved. */
+} node_status;
+
+/* Data structure used to manage proc filesystem entries. */
+struct gcov_ftree_node
+{
+	char *fname;			 /* Hierarchy-relative name */
+	struct gcov_ftree_node *sibling; /* First sibling of this node */
+	struct gcov_ftree_node *files;	 /* First child of this node */
+	struct gcov_ftree_node *parent;	 /* Parent of this node */
+	struct proc_dir_entry *proc[4];	 /* Entries for .da, .bb, .bbg, .c */
+	struct bb *bb;			 /* Associated struct bb */
+	loff_t offset;			 /* Offset in vmlinux file */
+	size_t da_size;			 /* Size of associated .da file */
+	size_t header_size;		 /* Size of associated file header */
+	struct gcov_ftree_node *next;	 /* Next leaf node */
+	node_status status;		 /* Status of this node */
+};
+
+
+/* If set to non-zero, keep gcov data for modules after unload. */
+static int gcov_persist = 0;
+
+/* If set to non-zero, create links to additional files in proc filesystem
+ * entries. */
+static int gcov_link = 1;
+
+/* Protect global variables from concurrent access. */
+static DECLARE_MUTEX_LOCKED(gcov_lock);
+
+/* Length of kernel source path string. */
+static int sourcepath_len;
+
+/* Length of kernel object path string. */
+static int objectpath_len;
+
+/* Filesystem entry for /proc/gcov/vmlinux */
+static struct proc_dir_entry *proc_vmlinux = NULL;
+
+/* First leaf node. */
+static struct gcov_ftree_node *leaf_nodes = NULL;
+
+/* Cached node used to speed up sequential reads in /proc/vmlinux. */
+static struct gcov_ftree_node *cached_node = NULL;
+
+/* Root node for internal data tree. */
+static struct gcov_ftree_node tree_root;
+
+#if GCC_VERSION_LOWER(3,4) && !CONFIG_GCOV_HAMMER
+/* Filename extension for data files. */
+static const char *da_ending = "da";
+
+/* Array of filename endings to use when creating links. */
+static const char *endings[] = { "bb", "bbg", "c" };
+#elif GCC_VERSION_EQUAL(3,3) && CONFIG_GCOV_HAMMER
+/* Filename extension for data files. */
+static const char *da_ending = "da";
+
+/* Array of filename endings to use when creating links. */
+static const char *endings[] = { "bbg", "c" };
+#else /* GCC_VERSION */
+/* Filename extension for data files. */
+static const char *da_ending = "gcda";
+
+/* Array of filename endings to use when creating links. */
+static const char *endings[] = { "gcno", "c" };
+#endif /* GCC_VERSION_LOWER */
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)) &&	\
+    (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,4)) ||	\
+    (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,23))
+/* Retrieve proc_dir_entry associated with INODE. */
+static inline struct proc_dir_entry *
+PDE(const struct inode *inode)
+{
+	return ((struct proc_dir_entry *) inode->u.generic_ip);
+}
+#endif
+
+
+#ifdef MODULE
+/* Parameter handling. */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
+/* module_param is a 2.6 thing (though there are compat macros since 2.4.25) */
+MODULE_PARM(gcov_persist, "i");
+MODULE_PARM(gcov_link, "i");
+#else
+module_param(gcov_persist, int, 0400);
+module_param(gcov_link, int, 0400);
+#endif /* LINUX_VERSION_CODE */
+
+MODULE_PARM_DESC(gcov_persist, "If set to non-zero, keep gcov data for modules "
+			       "after unload");
+MODULE_PARM_DESC(gcov_link, "If set to non-zero, create links to additional "
+			    "files in proc filesystem entries");
+
+#else /* MODULE */
+
+/* Called when 'gcov_persist' is specified on the kernel command line. */
+static int __init
+gcov_persist_setup(char *str)
+{
+	gcov_persist = (int) simple_strtol(str, NULL, 10);
+	return 1;
+}
+
+__setup("gcov_persist=", gcov_persist_setup);
+
+
+/* Called when 'gcov_link' is specified on the kernel command line. */
+static int __init
+gcov_link_setup(char *str)
+{
+	gcov_link = (int) simple_strtol(str, NULL, 10);
+	return 1;
+}
+
+__setup("gcov_link=", gcov_link_setup);
+#endif /* MODULE */
+
+
+/* Store a portable representation of VALUE in DEST using BYTES*8-1 bits.
+ * Return a non-zero value if VALUE requires more than BYTES*8-1 bits
+ * to store (adapted from gcc/gcov-io.h). */
+static int
+store_gcov_type(gcov_type value, char *dest, size_t bytes)
+{
+	int upper_bit = (value < 0 ? 128 : 0);
+	size_t i;
+
+	if (value < 0) {
+		gcov_type oldvalue = value;
+		value = -value;
+		if (oldvalue != -value)
+			return 1;
+	}
+
+	for (i = 0 ; i < (sizeof(value) < bytes ? sizeof(value) : bytes) ;
+	     i++) {
+		dest[i] = value & (i == (bytes - 1) ? 127 : 255);
+		value = value / 256;
+	}
+
+	if (value && value != -1)
+		return 1;
+
+	for(; i < bytes ; i++)
+		dest[i] = 0;
+	dest[bytes - 1] |= upper_bit;
+	return 0;
+}
+
+
+/* Return size of header which precedes .da file entry associated with BB
+ * in the vmlinux file. */
+static inline size_t
+sizeof_vmlinux_header(struct bb *bb)
+{
+	return 8 + PAD8(strlen(bb->filename) + 1);
+}
+
+
+/* Store data of header which precedes .da file entry associated with NODE
+ * in the vmlinux file to userspace memory at BUF. OFFSET specifies the offset
+ * inside the header file. COUNT is the maximum number of bytes to store.
+ * Return the number of bytes stored, zero for EOF or a negative number in
+ * case of error. */
+static ssize_t
+store_vmlinux_header(struct gcov_ftree_node *node, char *buf, size_t count,
+		     loff_t offset)
+{
+	char data[8];
+	char *from;
+	size_t namelen;
+	ssize_t stored;
+	size_t len;
+
+	namelen = strlen(node->bb->filename);
+	stored = 0;
+	while (count > 0) {
+		if (offset < 8) {
+			/* Filename length */
+			if (store_gcov_type(PAD8(namelen + 1), data, 8))
+				return -EINVAL;
+			from = data + offset;
+			len = 8 - offset;
+		} else if (offset < 8 + namelen) {
+			/* Filename */
+			from = (char *) node->bb->filename + offset - 8;
+			len = namelen - (offset - 8);
+		} else if (offset < node->header_size) {
+			/* Nil byte padding */
+			memset(data, 0, 8);
+			from = data;
+			len = PAD8(namelen + 1) - (offset - 8);
+		} else
+			break;
+		if (len > count)
+			len = count;
+		if (copy_to_user(buf, from, len))
+			return -EFAULT;
+		stored += len;
+		count -= len;
+		offset += len;
+		buf += len;
+	}
+
+	return stored;
+}
+
+
+#if GCC_VERSION_LOWER(3, 3)
+/*
+ *  pre-gcc 3.3 functions
+ */
+static const char* gcov_proc_format = "pre-gcc 3.3";
+
+
+/* Return size of .da file associated with BB. */
+static inline size_t
+sizeof_da_file(struct bb *bb)
+{
+	return (bb->ncounts + 1) * 8;
+}
+
+
+/* Store data of .da file associated with NODE to userspace memory at BUF.
+ * OFFSET specifies the offset inside the .da file. COUNT is the maximum
+ * number of bytes to store. Return the number of bytes stored, zero for
+ * EOF or a negative number in case of error. */
+static ssize_t
+store_da_file(struct gcov_ftree_node *node, char *buf, size_t count,
+	      loff_t offset)
+{
+	char data[8];
+	char *from;
+	ssize_t stored;
+	size_t len;
+
+	stored = 0;
+	while (count > 0) {
+		if (offset < 8) {
+			/* Number of counts */
+			if (store_gcov_type(node->bb->ncounts, data, 8))
+				return -EINVAL;
+			from = data + offset;
+			len = 8 - offset;
+		} else if (offset < node->da_size) {
+			/* Count data */
+			if (store_gcov_type(node->bb->counts[(offset - 8) / 8],
+					    data, 8))
+				return -EINVAL;
+			from = data + offset % 8;
+			len = 8 - offset % 8;
+		} else
+			break;
+		if (len > count)
+			len = count;
+		if (copy_to_user(buf, from, len))
+			return -EFAULT;
+		stored += len;
+		count -= len;
+		offset += len;
+		buf += len;
+	}
+	return stored;
+}
+
+#elif GCC_VERSION_EQUAL(3, 3) && CONFIG_GCOV_HAMMER
+
+/*
+ *   gcc 3.3 specific functions (hammer patch)
+ */
+static const char* gcov_proc_format = "gcc 3.3 (hammer)";
+
+
+/* Return length of string encoded in GCOV format. */
+static size_t
+sizeof_str(const char *str)
+{
+	size_t len;
+
+	len = strlen(str);
+	if (len == 0)
+		return 4;
+
+	return 4 + len + 4 - (len & 3);
+}
+
+
+/* Return length of counter section encoded in GCOV format. */
+static size_t
+sizeof_counter_data(const struct counter_section *section)
+{
+	return /* tag */ 4 + /* length */ 4 +
+	       /* counters */ section->n_counters * 8;
+}
+
+
+/* Return length of function section encoded in GCOV format. */
+static size_t
+sizeof_func_data(const struct function_info *fn)
+{
+	size_t sec_len;
+	unsigned int i;
+
+	sec_len = 0;
+	for (i=0; i < fn->n_counter_sections; i++)
+		sec_len += sizeof_counter_data(&fn->counter_sections[i]);
+
+	return /* tag */ 4 + /* length */ 4 + sizeof_str(fn->name) +
+	       /* checksum */ 4 + sec_len;
+}
+
+
+/* Return length of node data encoded in GCOV format. */
+static size_t
+sizeof_da_file(struct bb *bb)
+{
+	size_t fn_len;
+	unsigned int i;
+
+	fn_len = 0;
+	for (i=0; i < bb->n_functions; i++)
+		fn_len += sizeof_func_data(&bb->functions[i]);
+	return /* magic */ 4 + /* version */ 4 + fn_len;
+}
+
+
+/* Store a 32 bit unsigned integer value in GCOV format to memory at address
+ * BUF. */
+static void
+store_unsigned(unsigned int v, unsigned char *buf)
+{
+	int i;
+
+	for (i=0; i < 4; i++) {
+		buf[3 - i] = v & 0xff;
+		v >>= 8;
+	}
+}
+
+
+/* Store a 64 bit unsigned integer value in GCOV format to memory at address
+ * BUF. */
+static void
+store_counter(gcov_type v, unsigned char *buf)
+{
+	int i;
+
+	for (i=0; i < 8; i++) {
+		buf[7 - i] = v & 0xff;
+		v >>= 8;
+	}
+}
+
+
+/* Find counter section data with given TAG. Return number if found, -EINVAL
+ * otherwise. */
+static long
+find_count_section(struct bb *bb, unsigned int tag)
+{
+	unsigned int i;
+
+	for (i=0; i < bb->n_counter_sections; i++)
+		if (bb->counter_sections[i].tag == tag)
+			return i;
+
+	return -EINVAL;
+}
+
+
+/* Store a string in GCOV format in userspace memory. The string is passed in
+ * STR. The destination address is BUF. Store at most COUNT bytes beginning at
+ * OFFSET. Return the number of bytes stored or a negative value on error. */
+static ssize_t
+store_string_data(const char *str, char *buf, size_t count, loff_t offset)
+{
+	const char *from;
+	char data[8];
+	size_t len;
+	ssize_t result;
+	size_t str_len;
+
+	str_len = strlen(str);
+	result = 0;
+	while (count > 0) {
+		if (offset < 4) {
+			/* Tag ID */
+			store_unsigned(str_len, data);
+			len = 4 - offset;
+			from = data + offset;
+		} else if (offset < 4 + str_len) {
+			/* String */
+			len = str_len - (offset - 4);
+			from = str + (offset - 4);
+		} else if (offset < sizeof_str(str)) {
+			/* Nil byte padding */
+			store_unsigned(0, data);
+			len = 4 - (str_len & 3) - (offset - 4 - str_len);
+			from = data;
+		} else
+			/* EOF */
+			break;
+		if (len > count)
+			len = count;
+		if (copy_to_user(buf, from, len))
+			return -EFAULT;
+		count -= len;
+		buf += len;
+		offset += len;
+		result += len;
+	}
+	return result;
+}
+
+
+/* Store a counter section in userspace memory. The counter section is
+ * identified by BB, FUNC and SEC. The destination address is BUF. Store at
+ * most COUNT bytes beginning at OFFSET. Return the number of bytes stored or a
+ * negative value on error. */
+static ssize_t
+store_counter_data(struct bb *bb, unsigned int func, unsigned int sec,
+		   gcov_type ***counters, char *buf, size_t count,
+		   loff_t offset)
+{
+	const struct function_info *func_ptr;
+	char data[8];
+	char *from;
+	size_t len;
+	ssize_t result;
+	unsigned int i;
+
+	func_ptr = &bb->functions[func];
+	result = 0;
+	while (count > 0) {
+		if (offset < 4) {
+			/* Tag ID */
+			store_unsigned(func_ptr->counter_sections[sec].tag,
+				       data);
+			len = 4 - offset;
+			from = data + offset;
+		} else if (offset < 8) {
+			/* Tag length in bytes */
+			store_unsigned(
+				func_ptr->counter_sections[sec].n_counters * 8,
+				data);
+			len = 4 - (offset - 4);
+			from = data + (offset - 4);
+		} else {
+			/* Actual counter data */
+			i = (offset - 8) / 8;
+			/* Check for EOF */
+			if (i >= func_ptr->counter_sections[sec].n_counters)
+				break;
+			store_counter(*(counters[func][sec] + i), data);
+			len = 8 - (offset - 8) % 8;
+			from = data + (offset - 8) % 8;
+		}
+		if (len > count)
+			len = count;
+		if (copy_to_user(buf, from, len))
+			return -EFAULT;
+		count -= len;
+		buf += len;
+		offset += len;
+		result += len;
+	}
+	return result;
+}
+
+
+/* Store a function section and associated counter sections in userspace memory.
+ * The function section is identified by BB and FUNC. The destination address is
+ * BUF. Store at most COUNT bytes beginning at OFFSET. Return the number of
+ * bytes stored or a negative value on error. */
+static ssize_t
+store_func_data(struct bb *bb, unsigned int func, gcov_type ***counters,
+		char *buf, size_t count, loff_t offset)
+{
+	const struct function_info *func_ptr;
+	char data[4];
+	char *from;
+	size_t len;
+	ssize_t result;
+	ssize_t rc;
+	size_t name_len;
+	unsigned int i;
+	loff_t off;
+	size_t size;
+
+	func_ptr = &bb->functions[func];
+	name_len = sizeof_str(func_ptr->name);
+	result = 0;
+	from = NULL;
+	len = 0;
+	while (count > 0) {
+		if (offset < 8) {
+			if (offset < 4) {
+				/* Tag ID */
+				store_unsigned(GCOV_TAG_FUNCTION, data);
+				len = 4 - offset;
+				from = data + offset;
+			} else if (offset < 8) {
+				/* Tag length */
+				store_unsigned(name_len + 4, data);
+				len = 4 - (offset - 4);
+				from = data + (offset - 4);
+			}
+			/* Do the actual store */
+			if (len > count)
+				len = count;
+			if (copy_to_user(buf, from, len))
+				return -EFAULT;
+		} else if (offset < 8 + name_len) {
+			/* Function name */
+			rc = store_string_data(func_ptr->name, buf, count,
+					       offset - 8);
+			if (rc < 0)
+				return rc;
+			len = rc;
+		} else if (offset < 8 + name_len + 4) {
+			/* Function checksum */
+			store_unsigned(func_ptr->checksum, data);
+			len = 4 - (offset - (8 + name_len));
+			from = data + (offset - (8 + name_len));
+			/* Do the actual store */
+			if (len > count)
+				len = count;
+			if (copy_to_user(buf, from, len))
+				return -EFAULT;
+		} else {
+			off = 8 + name_len + 4;
+			len = 0;
+			for (i=0; i < func_ptr->n_counter_sections; i++) {
+				size = sizeof_counter_data(
+					&func_ptr->counter_sections[i]);
+				if (offset < off + size) {
+					rc = store_counter_data(bb, func, i,
+								counters,
+								buf, count,
+								offset - off);
+					if (rc < 0)
+						return rc;
+					len = rc;
+					break;
+				}
+				off += size;
+			}
+			/* Check for EOF */
+			if (len == 0)
+				break;
+		}
+		count -= len;
+		buf += len;
+		offset += len;
+		result += len;
+	}
+	return result;
+}
+
+
+/* Allocate and initialize counter pointer array for BB. Return zero on
+ * success, non-zero otherwise. The array will have the following content:
+ *
+ *   counters[function_index][counter_section_index] = pointer to first count */
+static int
+create_counters_array(struct bb *bb, gcov_type ****counters)
+{
+	unsigned int f;
+	long bb_c;
+	unsigned int fn_c;
+	unsigned int max_c;
+	gcov_type ***fn_counters;
+	gcov_type **bb_counters;
+	const struct function_info *fn;
+	const struct counter_section *sec;
+
+	/* Calculate maximum number of counter_sections */
+	max_c = 0;
+	for (f=0; f < bb->n_functions; f++)
+		if (bb->functions[f].n_counter_sections > max_c)
+			max_c = bb->functions[f].n_counter_sections;
+	fn_counters = kmalloc(bb->n_functions * sizeof(gcov_type **) +
+			      bb->n_functions * max_c * sizeof(gcov_type *),
+			      GFP_KERNEL);
+	if (!fn_counters)
+		return -ENOMEM;
+	for (f=0; f < bb->n_functions; f++)
+		fn_counters[f] =
+			((gcov_type **) &fn_counters[bb->n_functions]) +
+			f * max_c;
+	bb_counters = kmalloc(bb->n_counter_sections * sizeof(gcov_type *),
+			      GFP_KERNEL);
+	if (!bb_counters) {
+		kfree(fn_counters);
+		return -ENOMEM;
+	}
+	/* Initialize arrays */
+	for (bb_c=0; bb_c < bb->n_counter_sections; bb_c++)
+		bb_counters[bb_c] = bb->counter_sections[bb_c].counters;
+	for (f=0; f < bb->n_functions; f++) {
+		fn = &bb->functions[f];
+		for (fn_c=0; fn_c < fn->n_counter_sections; fn_c++) {
+			sec = &fn->counter_sections[fn_c];
+			bb_c = find_count_section(bb, sec->tag);
+			if (bb_c < 0) {
+				/* Tag not found */
+				kfree(fn_counters);
+				kfree(bb_counters);
+				return -EINVAL;
+			}
+			fn_counters[f][fn_c] = bb_counters[bb_c];
+			bb_counters[bb_c] += sec->n_counters;
+		}
+	}
+	kfree(bb_counters);
+	*counters = fn_counters;
+	return 0;
+}
+
+/* Store data of .da file associated with NODE to userspace memory at BUF.
+ * OFFSET specifies the offset inside the .da file. COUNT is the maximum
+ * number of bytes to store. Return the number of bytes stored, zero for
+ * EOF or a negative number in case of error. */
+static ssize_t
+store_da_file(struct gcov_ftree_node *node, char *buf, size_t count,
+	      loff_t offset)
+{
+	struct bb *bb;
+	char data[4];
+	char *from;
+	size_t len;
+	unsigned int i;
+	loff_t off;
+	size_t size;
+	ssize_t result;
+	ssize_t rc;
+	gcov_type ***counters;
+
+	bb = node->bb;
+	rc = create_counters_array(bb, &counters);
+	if (rc)
+		return rc;
+	result = 0;
+	while (count > 0) {
+		if (offset < 8) {
+			if (offset < 4) {
+				/* File magic */
+				store_unsigned(GCOV_DATA_MAGIC, data);
+				len = 4 - offset;
+				from = data + offset;
+			} else {
+				/* File format/GCC version */
+				store_unsigned(gcov_version, data);
+				len = 4 - (offset - 4);
+				from = data + (offset - 4);
+			}
+			/* Do the actual store */
+			if (len > count)
+				len = count;
+			if (copy_to_user(buf, from, len)) {
+				kfree(counters);
+				return -EFAULT;
+			}
+		} else {
+			off = 8;
+			len = 0;
+			for (i=0; i < bb->n_functions; i++) {
+				size = sizeof_func_data(&bb->functions[i]);
+				if (offset < off + size) {
+					rc = store_func_data(bb, i, counters,
+							     buf, count,
+							     offset - off);
+					if (rc < 0) {
+						kfree(counters);
+						return rc;
+					}
+					len = rc;
+					break;
+				}
+				off += size;
+			}
+			/* Check for EOF */
+			if (len == 0)
+				break;
+		}
+		count -= len;
+		buf += len;
+		offset += len;
+		result += len;
+	}
+	kfree(counters);
+	return result;
+}
+
+#elif GCC_VERSION_LOWER(3, 4)
+
+/*
+ *   gcc 3.3 specific functions (unmodified)
+ */
+static const char* gcov_proc_format = "gcc 3.3";
+
+
+/* Return size of .da file section associated with function data FUNC. */
+static inline size_t
+sizeof_func_info(struct bb_function_info *func)
+{
+	return (size_t)
+	       (/* delim */ 4 + /* strlen */ 4 + PAD4(strlen(func->name) + 1) +
+	        /* delim */ 4 + /* checksum */ 4 + /* arc_count */ 4 +
+	        /* count values */ func->arc_count * 8);
+}
+
+
+/* Return size of .da file associated with BB. */
+static inline size_t
+sizeof_da_file(struct bb *bb)
+{
+	struct bb_function_info *func;
+	size_t size;
+
+	size = ( /* magic */ 4 + /* num_func */ 4 + /* num_extra */ 4);
+	for (func = bb->function_infos; func->arc_count != -1; func++)
+		size += sizeof_func_info(func);
+	return size;
+}
+
+
+/* Return the number of functions associated with BB. */
+static inline gcov_type
+count_functions(struct bb *bb)
+{
+	gcov_type result;
+
+	for (result = 0; bb->function_infos[result].arc_count != -1;
+	     result++);
+	return result;
+}
+
+
+/* Return non-zero if OFFSET is within the range START <= OFFSET < START + SIZE,
+ * zero otherwise. Update REL_OFF to contain the relative offset inside the
+ * range, SIZE_VAR to contain the range size and START to point to the next
+ * range after this one. */
+static inline int in_range(loff_t offset, size_t size, loff_t *rel_off,
+			   loff_t *start, size_t *size_var)
+{
+	int result;
+
+	result = (offset >= *start) && (offset < *start + size);
+	*rel_off = offset - *start;
+	*start += size;
+	*size_var = size;
+	return result;
+}
+
+
+/* Store data of .da file associated with NODE to userspace memory at BUF.
+ * OFFSET specifies the offset inside the .da file. COUNT is the maximum
+ * number of bytes to store. Return the number of bytes stored, zero for
+ * EOF or a negative number in case of error. */
+static ssize_t
+store_da_file(struct gcov_ftree_node *node, char *buf, size_t count,
+	      loff_t offset)
+{
+	struct bb_function_info *func;
+	gcov_type *count_ptr;
+	char data[8];
+	char *from;
+	ssize_t stored;
+	size_t len;
+	size_t size;
+	size_t func_off;
+	size_t next_off;
+	loff_t rel_off;
+	loff_t start;
+
+	func_off = 0;
+	func = NULL;
+	count_ptr = NULL;
+	stored = 0;
+	while (count > 0) {
+		start = 0;
+		if (in_range(offset, 4, &rel_off, &start, &size)) {
+			/* Magic */
+			if (store_gcov_type(-123, data, 4))
+				return -EINVAL;
+			from = data + rel_off;
+			len = size - rel_off;
+		} else if (in_range(offset, 4, &rel_off, &start, &size)) {
+			/* Number of functions */
+			if (store_gcov_type(count_functions(node->bb),
+					    data, 4))
+				return -EINVAL;
+			from = data + rel_off;
+			len = size - rel_off;
+		} else if (in_range(offset, 4, &rel_off, &start, &size)) {
+			/* Size of extra data */
+			store_gcov_type(0, data, 4);
+			from = data + rel_off;
+			len = size - rel_off;
+		} else if (offset < node->da_size) {
+			/* Function data */
+			rel_off = offset - 12;
+			/* Try to minimize search effort */
+			if (!(func && (func_off <= rel_off))) {
+				func = node->bb->function_infos;
+				func_off = 0;
+				count_ptr = node->bb->counts;
+			}
+			/* Find function which is hit by offset */
+			for (; func->arc_count != -1; func++) {
+				next_off = func_off + sizeof_func_info(func);
+				if (next_off > rel_off)
+					break;
+				func_off = next_off;
+				count_ptr += func->arc_count;
+			}
+			start = 0;
+			if (in_range(offset - func_off - 12, 4, &rel_off,
+				     &start, &size)) {
+				/* String delimiter */
+				store_gcov_type(-1, data, 4);
+				from = data + rel_off;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12, 4, &rel_off,
+				   &start, &size)) {
+				/* String length */
+				if (store_gcov_type(strlen(func->name),
+						    data, 4))
+					return -EINVAL;
+				from = data + rel_off;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12,
+				   strlen(func->name), &rel_off, &start,
+				   &size)) {
+				/* Function name */
+				from = (char *) func->name + rel_off;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12,
+				   PAD4(strlen(func->name) + 1) -
+				   strlen(func->name), &rel_off, &start,
+				   &size)) {
+				/* Nil byte padding */
+				memset(data, 0, size);
+				from = data;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12, 4, &rel_off,
+				   &start, &size)) {
+				/* String delimiter */
+				store_gcov_type(-1, data, size);
+				from = data + rel_off;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12, 4, &rel_off,
+				   &start, &size)) {
+				/* Checksum */
+				store_gcov_type(func->checksum, data, 4);
+				from = data + rel_off;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12, 4, &rel_off,
+				   &start, &size)) {
+				/* Number of arcs */
+				if (store_gcov_type(func->arc_count, data, 4))
+					return -EINVAL;
+				from = data + rel_off;
+				len = size - rel_off;
+			} else if (in_range(offset - func_off - 12,
+				   func->arc_count * 8, &rel_off, &start,
+				   &size)) {
+				/* Counts */
+				if (store_gcov_type(count_ptr[rel_off / 8],
+						    data, 8))
+					return -EINVAL;
+				from = data + rel_off % 8;
+				len = 8 - rel_off % 8;
+			} else {
+				break;
+			}
+		} else
+			break;
+		if (len > count)
+			len = count;
+		if (copy_to_user(buf, from, len))
+			return -EFAULT;
+		stored += len;
+		count -= len;
+		offset += len;
+		buf += len;
+	}
+	return stored;
+}
+
+#else /* GCC_VERSION */
+
+/*
+ *  gcc 3.4 functions
+ */
+static const char* gcov_proc_format = "gcc 3.4";
+
+/* Determine whether counter TYPE is active in BB. */
+static inline int
+counter_active(struct bb *bb, unsigned int type)
+{
+	return (1 << type) & bb->ctr_mask;
+}
+
+
+/* Return the number of active counter types for BB. */
+static inline unsigned int
+num_counter_active(struct bb *bb)
+{
+	unsigned int i;
+	unsigned int result;
+
+	result = 0;
+	for (i=0; i < GCOV_COUNTERS; i++)
+		if (counter_active(bb, i))
+			result++;
+	return result;
+}
+
+
+/* Get number of bytes used for one entry in the gcov_fn_info array pointed to
+ * by BB->functions. */
+static inline unsigned int
+get_fn_stride(struct bb *bb)
+{
+	unsigned int stride;
+
+	stride = sizeof(struct gcov_fn_info) + num_counter_active(bb) *
+		 sizeof(unsigned int);
+	if (__alignof__(struct gcov_fn_info) > sizeof(unsigned int)) {
+		stride += __alignof__(struct gcov_fn_info) - 1;
+		stride &= ~(__alignof__(struct gcov_fn_info) - 1);
+	}
+	return stride;
+}
+
+
+/* Get the address of gcov_fn_info for function FUNC of BB. */
+static inline struct gcov_fn_info *
+get_fn_info(struct bb *bb, unsigned int func)
+{
+	return (struct gcov_fn_info *)
+		((char *) bb->functions + func * get_fn_stride(bb));
+}
+
+
+/* Return size of .gcda counter section. */
+static inline size_t
+sizeof_counter_data(struct bb *bb, struct gcov_fn_info *func, unsigned int type)
+{
+	if (counter_active(bb, type)) {
+		return /* tag */ 4 + /* length */ 4 +
+		       /* counters */ func->n_ctrs[type] * 8;
+	} else
+		return 0;
+}
+
+
+/* Return size of .gcda data section associated with FUNC.  */
+static inline size_t
+sizeof_func_data(struct bb *bb, struct gcov_fn_info *func)
+{
+	size_t result;
+	unsigned int type;
+
+	result = /* tag */ 4 + /* length */ 4 + /* ident */ 4+
+		 /* checksum */ 4;
+	for (type=0; type < GCOV_COUNTERS; type++)
+		result += sizeof_counter_data(bb, func, type);
+	return result;
+}
+
+
+/* Get size of .gcda file associated with BB. */
+static inline size_t
+sizeof_da_file(struct bb *bb)
+{
+	size_t result;
+	unsigned int i;
+
+	result = /* magic */ 4 + /* version */ 4 + /* stamp */ 4;
+	for (i=0; i < bb->n_functions; i++)
+		result += sizeof_func_data(bb, get_fn_info(bb, i));
+	return result;
+}
+
+
+/* Store a 32 bit unsigned integer value in GCOV format to memory at address
+ * BUF. */
+static inline void
+store_int32(uint32_t i, char *buf)
+{
+	uint32_t *p;
+
+	p = (int *) buf;
+	*p = i;
+}
+
+
+/* Store a 64 bit unsigned integer value in GCOV format to memory at address
+ * BUF. */
+static inline void
+store_int64(uint64_t i, char *buf)
+{
+	store_int32((uint32_t) (i & 0xffff), buf);
+	store_int32((uint32_t) (i >> 32), buf + 4);
+}
+
+
+/* Store a gcov counter in GCOV format to memory at address BUF. The counter is
+ * identified by BB, FUNC, TYPE and COUNTER. */
+static inline void
+store_counter(struct bb *bb, unsigned int func, unsigned int type,
+	      unsigned int counter, char *buf)
+{
+	unsigned int counter_off;
+	unsigned int type_off;
+	unsigned int i;
+
+	/* Get offset into counts array */
+	type_off = 0;
+	for (i=0; i < type; i++)
+		if (counter_active(bb, i))
+			type_off++;
+	/* Get offset into values array. */
+	counter_off = counter;
+	for (i=0; i < func; i++)
+		counter_off += get_fn_info(bb, i)->n_ctrs[type];
+	/* Create in temporary storage */
+	store_int64(bb->counts[type_off].values[counter_off], buf);
+}
+
+
+/* Store a counter section in userspace memory. The counter section is
+ * identified by BB, FUNC and TYPE. The destination address is BUF. Store at
+ * most COUNT bytes beginning at OFFSET. Return the number of bytes stored or a
+ * negative value on error. */
+static inline ssize_t
+store_counter_data(struct bb *bb, unsigned int func, unsigned int type,
+		  char *buf, size_t count, loff_t offset)
+{
+	struct gcov_fn_info *func_ptr;
+	char data[8];
+	char *from;
+	size_t len;
+	ssize_t result;
+	unsigned int i;
+
+	func_ptr = get_fn_info(bb, func);
+	result = 0;
+	while (count > 0) {
+		if (offset < 4) {
+			/* Tag ID */
+			store_int32((uint32_t) GCOV_TAG_FOR_COUNTER(type),
+				    data);
+			len = 4 - offset;
+			from = data + offset;
+		} else if (offset < 8) {
+			/* Tag length in groups of 4 bytes */
+			store_int32((uint32_t)
+				    func_ptr->n_ctrs[type] * 2, data);
+			len = 4 - (offset - 4);
+			from = data + (offset - 4);
+		} else {
+			/* Actual counter data */
+			i = (offset - 8) / 8;
+			/* Check for EOF */
+			if (i >= func_ptr->n_ctrs[type])
+				break;
+			store_counter(bb, func, type, i, data);
+			len = 8 - (offset - 8) % 8;
+			from = data + (offset - 8) % 8;
+		}
+		if (len > count)
+			len = count;
+		if (copy_to_user(buf, from, len))
+			return -EFAULT;
+		count -= len;
+		buf += len;
+		offset += len;
+		result += len;
+	}
+	return result;
+}
+
+
+/* Store a function section and associated counter sections in userspace memory.
+ * The function section is identified by BB and FUNC. The destination address is
+ * BUF. Store at most COUNT bytes beginning at OFFSET. Return the number of
+ * bytes stored or a negative value on error. */
+static inline ssize_t
+store_func_data(struct bb *bb, unsigned int func, char *buf,
+		size_t count, loff_t offset)
+{
+	struct gcov_fn_info *func_ptr;
+	char data[4];
+	char *from;
+	size_t len;
+	unsigned int i;
+	loff_t off;
+	size_t size;
+	ssize_t result;
+	ssize_t rc;
+
+	func_ptr = get_fn_info(bb, func);
+	result = 0;
+	while (count > 0) {
+		if (offset < 16) {
+			if (offset < 4) {
+				/* Tag ID */
+				store_int32((uint32_t) GCOV_TAG_FUNCTION, data);
+				len = 4 - offset;
+				from = data + offset;
+			} else if (offset < 8) {
+				/* Tag length */
+				store_int32(2, data);
+				len = 4 - (offset - 4);
+				from = data + (offset - 4);
+			} else if (offset < 12) {
+				/* Function ident */
+				store_int32((uint32_t) func_ptr->ident, data);
+				len = 4 - (offset - 8);
+				from = data + (offset - 8);
+			} else {
+				/* Function checksum */
+				store_int32((uint32_t) func_ptr->checksum,
+					    data);
+				len = 4 - (offset - 12);
+				from = data + (offset - 12);
+			}
+			/* Do the actual store */
+			if (len > count)
+				len = count;
+			if (copy_to_user(buf, from, len))
+				return -EFAULT;
+		} else {
+			off = 16;
+			len = 0;
+			for (i=0; i < GCOV_COUNTERS; i++) {
+				size = sizeof_counter_data(bb, func_ptr, i);
+				if (offset < off + size) {
+					rc = store_counter_data(bb, func, i,
+								buf, count,
+								offset - off);
+					if (rc < 0)
+						return rc;
+					len = rc;
+					break;
+				}
+				off += size;
+			}
+			/* Check for EOF */
+			if (i == GCOV_COUNTERS)
+				break;
+		}
+		count -= len;
+		buf += len;
+		offset += len;
+		result += len;
+	}
+	return result;
+}
+
+
+/* Store data of .gcda file associated with NODE to userspace memory at BUF.
+ * OFFSET specifies the offset inside the .da file. COUNT is the maximum
+ * number of bytes to store. Return the number of bytes stored, zero for
+ * EOF or a negative number in case of error. */
+static ssize_t
+store_da_file(struct gcov_ftree_node *node, char *buf, size_t count,
+	      loff_t offset)
+{
+	struct bb *bb;
+	char data[4];
+	char *from;
+	size_t len;
+	unsigned int i;
+	loff_t off;
+	size_t size;
+	ssize_t result;
+	ssize_t rc;
+
+	bb = node->bb;
+	result = 0;
+	while (count > 0) {
+		if (offset < 12) {
+			if (offset < 4) {
+				/* File magic */
+				store_int32((uint32_t) GCOV_DATA_MAGIC, data);
+				len = 4 - offset;
+				from = data + offset;
+			} else if (offset < 8) {
+				/* File format/GCC version */
+				store_int32(gcov_version, data);
+				len = 4 - (offset - 4);
+				from = data + (offset - 4);
+			} else {
+				/* Time stamp */
+				store_int32((uint32_t) bb->stamp, data);
+				len = 4 - (offset - 8);
+				from = data + (offset - 8);
+			}
+			/* Do the actual store */
+			if (len > count)
+				len = count;
+			if (copy_to_user(buf, from, len))
+				return -EFAULT;
+		} else {
+			off = 12;
+			len = 0;
+			for (i=0; i < bb->n_functions; i++) {
+				size = sizeof_func_data(bb, get_fn_info(bb, i));
+				if (offset < off + size) {
+					rc = store_func_data(bb, i, buf, count,
+							     offset - off);
+					if (rc < 0)
+						return rc;
+					len = rc;
+					break;
+				}
+				off += size;
+			}
+			/* Check for EOF */
+			if (i == bb->n_functions)
+				break;
+		}
+		count -= len;
+		buf += len;
+		offset += len;
+		result += len;
+	}
+	return result;
+}
+#endif /* GCC_VERSION */
+
+
+/* Update data related to vmlinux file. */
+static void
+update_vmlinux_data(void)
+{
+	struct gcov_ftree_node *node;
+	loff_t offset;
+
+	offset = 0;
+	for (node = leaf_nodes; node; node = node->next) {
+		node->offset = offset;
+		node->da_size = sizeof_da_file(node->bb);
+		node->header_size = sizeof_vmlinux_header(node->bb);
+		offset += node->header_size + node->da_size;
+	}
+	proc_vmlinux->size = offset;
+	cached_node = NULL;
+}
+
+
+/* Read .da or vmlinux file. */
+static ssize_t
+read_gcov(struct file *file, char *buf, size_t count, loff_t *pos)
+{
+	struct gcov_ftree_node *node;
+	struct proc_dir_entry *dir_entry;
+	ssize_t rc;
+
+	down(&gcov_lock);
+	dir_entry = PDE(file->f_dentry->d_inode);
+	rc = 0;
+	if (dir_entry == proc_vmlinux) {
+		/* Are we in a sequential read? */
+		if (cached_node && (*pos >= cached_node->offset))
+			node = cached_node;
+		else
+			node = leaf_nodes;
+		/* Find node corresponding to offset */
+		while (node && node->next && (*pos >= node->next->offset))
+			node = node->next;
+		cached_node = node;
+		if (node) {
+			if (*pos - node->offset < node->header_size)
+				rc = store_vmlinux_header(node, buf, count,
+							  *pos - node->offset);
+			else
+				rc = store_da_file(node, buf, count,
+						   *pos - node->offset -
+							node->header_size);
+		}
+	} else {
+		node = (struct gcov_ftree_node *) dir_entry->data;
+		if (node)
+			rc = store_da_file(node, buf, count, *pos);
+	}
+	if (rc > 0)
+		*pos += rc;
+	up(&gcov_lock);
+	return rc;
+}
+
+
+static inline void
+reset_bb(struct bb* bb)
+{
+#if GCC_VERSION_EQUAL(3,3) && defined(CONFIG_GCOV_HAMMER)
+	unsigned int i;
+
+	for (i=0; i < bb->n_counter_sections; i++)
+		memset(bb->counter_sections[i].counters, 0,
+		       bb->counter_sections[i].n_counters * sizeof(gcov_type));
+#elif GCC_VERSION_LOWER(3, 4)
+	memset(bb->counts, 0, bb->ncounts * sizeof(gcov_type));
+#else /* GCC_VERSION */
+	const struct gcov_ctr_info *ctr;
+	unsigned int i;
+
+	ctr = bb->counts;
+	for (i=0; i < GCOV_COUNTERS; i++)
+		if (counter_active(bb, i)) {
+			memset(ctr->values, 0, ctr->num * sizeof(gcov_type));
+			ctr++;
+		}
+#endif /* GCC_VERSION */
+}
+
+
+static void cleanup_node_and_path(struct gcov_ftree_node *node);
+
+/* Reset counters on write request. */
+static ssize_t
+write_gcov(struct file *file, const char *buf, size_t count, loff_t *ppos)
+{
+	struct gcov_ftree_node *node;
+	struct gcov_ftree_node *next;
+	struct proc_dir_entry *dir_entry;
+
+	down(&gcov_lock);
+	dir_entry = PDE(file->f_dentry->d_inode);
+	if (dir_entry == proc_vmlinux) {
+		/* Reset all nodes */
+		node = leaf_nodes;
+		while (node) {
+			next = node->next;
+			/* Delete ghosted nodes */
+			if (node->status == status_ghost)
+				cleanup_node_and_path(node);
+			else
+				reset_bb(node->bb);
+			node = next;
+		}
+		/* Nodes may have been deleted - update data */
+		if (gcov_persist)
+			update_vmlinux_data();
+	} else {
+		node = (struct gcov_ftree_node *) dir_entry->data;
+		reset_bb(node->bb);
+	}
+	up(&gcov_lock);
+	return count;
+}
+
+
+/* Return a newly allocated copy of STRING. */
+static inline char *
+strdup(const char *string)
+{
+	char *result;
+
+	result = (char *) kmalloc(strlen(string) + 1, GFP_KERNEL);
+	if (result)
+		strcpy(result, string);
+	return result;
+}
+
+
+/* Allocate a new node and fill in NAME and BB. */
+static struct gcov_ftree_node *
+alloc_node(const char *name, struct bb *bb)
+{
+	struct gcov_ftree_node *node;
+
+	node = (struct gcov_ftree_node *)
+		kmalloc(sizeof(struct gcov_ftree_node), GFP_KERNEL);
+	if (!node)
+		return NULL;
+	memset(node, 0, sizeof(struct gcov_ftree_node));
+	node->fname = strdup(name);
+	if (!node->fname) {
+		kfree(node);
+		return NULL;
+	}
+	node->bb = bb;
+	node->status = status_normal;
+	return node;
+}
+
+
+/* Free memory allocated for BB. */
+static void
+free_bb(struct bb *bb)
+{
+#if GCC_VERSION_LOWER(3,4)
+	kfree(bb);
+#else /* GCC_VERSION */
+	kfree(bb->functions);
+	kfree(bb);
+#endif /* GCC_VERSION */
+}
+
+
+/* Free memory allocated for NODE. */
+static void
+free_node(struct gcov_ftree_node *node)
+{
+	if (node == &tree_root)
+		return;
+	if (node->fname)
+		kfree(node->fname);
+	if (node->status == status_ghost)
+		free_bb(node->bb);
+	kfree(node);
+}
+
+
+/* Remove proc filesystem entries associated with NODE. */
+static void
+delete_from_proc(struct gcov_ftree_node *node)
+{
+	struct proc_dir_entry *parent;
+	int i;
+
+	if (node->parent)
+		parent = node->parent->proc[0];
+	else
+		parent = &proc_root;
+	for (i = 0; i < sizeof(node->proc) / sizeof(node->proc[0]); i++)
+		if (node->proc[i])
+			remove_proc_entry(node->proc[i]->name, parent);
+}
+
+
+/* Release all resources associated with NODE. If NODE is a directory node,
+ * also clean up all children. */
+static void
+cleanup_node(struct gcov_ftree_node *node)
+{
+	struct gcov_ftree_node *curr;
+	struct gcov_ftree_node *next;
+	struct gcov_ftree_node *prev;
+
+	next = node;
+	do {
+		/* Depth first traversal of all children */
+		curr = next;
+		while (curr->files)
+			curr = curr->files;
+		if (curr->sibling)
+			next = curr->sibling;
+		else
+			next = curr->parent;
+		/* Remove from tree */
+		if (curr->parent) {
+			if (curr->parent->files == curr)
+				curr->parent->files = curr->sibling;
+			else {
+				for (prev = curr->parent->files;
+				     prev->sibling != curr;
+				     prev = prev->sibling);
+				prev->sibling = curr->sibling;
+			}
+		}
+		/* Remove from leaf node list if necessary */
+		if (curr->bb) {
+			if (leaf_nodes == curr)
+				leaf_nodes = curr->next;
+			else {
+				for (prev = leaf_nodes;
+				     prev && (prev->next != curr);
+				     prev = prev->next);
+				if (prev)
+					prev->next = curr->next;
+			}
+		}
+		/* Delete node */
+		delete_from_proc(curr);
+		free_node(curr);
+	} while (node != curr);
+}
+
+
+/* Clean up NODE and containing path in case it would be left empty. */
+static void
+cleanup_node_and_path(struct gcov_ftree_node *node)
+{
+	while (node->parent &&
+	       node->parent != &tree_root &&
+	       !node->parent->files->sibling)
+		node = node->parent;
+	cleanup_node(node);
+}
+
+
+/* Create a new directory node named NAME under PARENT. Upon success return
+ * zero and update RESULT to point to the newly created node. Return non-zero
+ * otherwise. */
+static int
+create_dir_node(struct gcov_ftree_node *parent, char *name,
+		struct gcov_ftree_node **result)
+{
+	struct gcov_ftree_node *node;
+
+	/* Initialize new node */
+	node = alloc_node(name, NULL);
+	if (!node)
+		return -ENOMEM;
+	/* Create proc filesystem entry */
+	node->proc[0] = proc_mkdir(name, parent->proc[0]);
+	if (!node->proc[0]) {
+		free_node(node);
+		return -EIO;
+	}
+	/* Insert node into tree */
+	node->parent = parent;
+	node->sibling = parent->files;
+	parent->files = node;
+	*result = node;
+	return 0;
+}
+
+
+static struct file_operations proc_gcov_operations = {
+	read: read_gcov,
+	write: write_gcov,
+	owner: THIS_MODULE
+};
+
+/* Create a new file node named NAME under PARENT. Associate node with BB.
+ * Return zero upon success, non-zero otherwise. */
+static int
+create_file_node(struct gcov_ftree_node *parent, char *name, struct bb *bb)
+{
+	struct gcov_ftree_node *node;
+	char *link_target;
+	char *link_name;
+	int i;
+
+	/* Initialize new node */
+	node = alloc_node(name, bb);
+	if (!node)
+		return -ENOMEM;
+	/* Create proc filesystem entry */
+	node->proc[0] = create_proc_entry(name, S_IWUSR | S_IRUGO,
+					  parent->proc[0]);
+	if (!node->proc[0]) {
+		free_node(node);
+		return -EIO;
+	}
+	node->proc[0]->data = node;
+	node->proc[0]->proc_fops = &proc_gcov_operations;
+	node->proc[0]->size = sizeof_da_file(bb);
+	/* Create symbolic links */
+	if (gcov_link) {
+		/* Note: temp string length is calculated as upper limit */
+		link_target = (char *) kmalloc(strlen(bb->filename) +
+					       strlen(da_ending) +
+					       strlen(gcov_sourcepath),
+					       GFP_KERNEL);
+		if (!link_target) {
+			delete_from_proc(node);
+			free_node(node);
+			return -ENOMEM;
+		}
+		for (i = 0; i < sizeof(endings) / sizeof(endings[0]); i++) {
+			if ((strcmp(endings[i], "c") == 0) &&
+			    (strcmp(gcov_sourcepath, gcov_objectpath) != 0) &&
+			    (strncmp(bb->filename, gcov_objectpath,
+				     objectpath_len) == 0)) {
+				strcpy(link_target, gcov_sourcepath);
+				strcat(link_target,
+				       bb->filename + objectpath_len);
+			} else {
+				strcpy(link_target, bb->filename);
+			}
+			link_target[strlen(link_target) -
+				    strlen(da_ending)] = 0;
+			strcat(link_target, endings[i]);
+			link_name = strrchr(link_target, '/') + 1;
+			node->proc[i + 1] = proc_symlink(link_name,
+							 parent->proc[0],
+							 link_target);
+			if (!node->proc[i + 1]) {
+				kfree(link_target);
+				delete_from_proc(node);
+				free_node(node);
+				return -EIO;
+			}
+		}
+		kfree(link_target);
+	}
+	/* Insert node into tree */
+	node->parent = parent;
+	node->sibling = parent->files;
+	parent->files = node;
+	node->next = leaf_nodes;
+	leaf_nodes = node;
+	return 0;
+}
+
+
+/* Return proc filesystem entry name for FILENAME. */
+static char *
+get_proc_filename(const char *filename)
+{
+	char *result;
+
+	/* Is this file located in the kernel source directory? */
+	if (strncmp(filename, gcov_objectpath, objectpath_len) == 0) {
+		/* Use relative path */
+		result = strdup(filename + objectpath_len + 1);
+	} else {
+		/* Use full path in module subdirectory */
+		result = (char *) kmalloc(strlen(GCOV_PROC_MODULE) +
+					  strlen(filename) + 1, GFP_KERNEL);
+		if (result) {
+			strcpy(result, GCOV_PROC_MODULE);
+			strcat(result, filename);
+		}
+	}
+	return result;
+}
+
+
+/* Create tree node and proc filesystem entry for BB. Create subdirectories as
+ * necessary. Return zero upon success, non-zero otherwise. */
+static int
+create_node(struct bb *bb)
+{
+	struct gcov_ftree_node *parent;
+	struct gcov_ftree_node *node;
+	char *filename;
+	char *curr;
+	char *next;
+	int rc;
+
+	filename = get_proc_filename(bb->filename);
+	if (!filename)
+		return -ENOMEM;
+	/* Recreate directory path in proc filesystem */
+	parent = &tree_root;
+	for (curr = filename; (next = strchr(curr, '/')); curr = next + 1) {
+		/* Skip empty path components */
+		if (curr == next)
+			continue;
+		*next = 0;
+		/* Check whether directory already exists */
+		for (node = parent->files;
+		     node && (strcmp(node->fname, curr) != 0);
+		     node = node->sibling);
+		if (!node) {
+			/* Create directory node */
+			rc = create_dir_node(parent, curr, &node);
+			if (rc) {
+				if (parent != &tree_root)
+					cleanup_node_and_path(parent);
+				kfree(filename);
+				return rc;
+			}
+		}
+		parent = node;
+	}
+	rc = create_file_node(parent, curr, bb);
+	kfree(filename);
+	return rc;
+}
+
+
+/* Return a copy of BB which contains only data relevant to this module. */
+static struct bb *
+clone_bb(struct bb *bb)
+{
+	struct bb *result;
+	size_t len;
+
+#if GCC_VERSION_LOWER(3, 3)
+
+	/* Allocate memory */
+	len = sizeof(struct bb) + bb->ncounts * sizeof(gcov_type) +
+	      strlen(bb->filename) + 1;
+	result = (struct bb *) kmalloc(len, GFP_KERNEL);
+	if (!result)
+		return NULL;
+	memset(result, 0, len);
+	/* Copy count data */
+	result->counts = (gcov_type *) (result + 1);
+	result->ncounts = bb->ncounts;
+	memcpy(result->counts, bb->counts, result->ncounts * sizeof(gcov_type));
+	/* Copy filename */
+	result->filename = (const char *) &result->counts[result->ncounts];
+	strcpy((char *) result->filename, bb->filename);
+
+#elif GCC_VERSION_EQUAL(3, 3) && CONFIG_GCOV_HAMMER
+
+	unsigned int i;
+	unsigned char *curr;
+	struct function_info *func;
+	struct counter_section_data *sec;
+
+	/* Allocate memory */
+	len = sizeof(struct bb) +
+	      bb->n_functions * sizeof(struct function_info) +
+	      bb->n_counter_sections * sizeof(struct counter_section_data) +
+	      strlen(bb->filename) + 1;
+	for (i=0; i < bb->n_functions; i++) {
+		len += strlen(bb->functions[i].name) + 1;
+		len += bb->functions[i].n_counter_sections *
+		       sizeof(struct counter_section);
+	}
+	for (i=0 ; i < bb->n_counter_sections; i++)
+		len += bb->counter_sections[i].n_counters * sizeof(gcov_type);
+	result = (struct bb *) kmalloc(len, GFP_KERNEL);
+	if (!result)
+		return NULL;
+	memset(result, 0, len);
+	curr = (unsigned char *) result + sizeof(struct bb);
+	/* Copy relevant function data */
+	result->n_functions = bb->n_functions;
+	result->functions = (struct function_info *) curr;
+	curr += sizeof(struct function_info) * bb->n_functions;
+	for (i=0; i < bb->n_functions; i++) {
+		func = (struct function_info *) &result->functions[i];
+		func->checksum = bb->functions[i].checksum;
+		func->n_counter_sections = bb->functions[i].n_counter_sections;
+		func->counter_sections = (struct counter_section *) curr;
+		curr += sizeof(struct counter_section) *
+			func->n_counter_sections;
+		memcpy((struct counter_section *) func->counter_sections,
+		       bb->functions[i].counter_sections,
+		       sizeof(struct counter_section) *
+		       func->n_counter_sections);
+	}
+	/* Copy relevant counter section data */
+	result->n_counter_sections = bb->n_counter_sections;
+	result->counter_sections = (struct counter_section_data *) curr;
+	curr += sizeof(struct counter_section_data) *
+		result->n_counter_sections;
+	for (i=0; i < bb->n_counter_sections; i++) {
+		sec = (struct counter_section_data *)
+			&result->counter_sections[i];
+		sec->tag = bb->counter_sections[i].tag;
+		sec->n_counters = bb->counter_sections[i].n_counters;
+		sec->counters = (gcov_type *) curr;
+		curr += sizeof(gcov_type) * sec->n_counters;
+		memcpy(sec->counters, bb->counter_sections[i].counters,
+		       sizeof(gcov_type) * sec->n_counters);
+	}
+	/* Copy filename */
+	result->filename = (char *) curr;
+	curr += strlen(bb->filename) + 1;
+	strcpy((char *) result->filename, bb->filename);
+	/* Copy function names */
+	for (i=0; i < bb->n_functions; i++) {
+		func = (struct function_info *) &result->functions[i];
+		func->name = (char *) curr;
+		curr += strlen(bb->functions[i].name) + 1;
+		strcpy((char *) func->name, bb->functions[i].name);
+	}
+
+#elif GCC_VERSION_LOWER(3, 4)
+
+	unsigned int i;
+	char *name;
+
+	/* Allocate memory */
+	len = sizeof(struct bb) + bb->ncounts * sizeof(gcov_type) +
+	      strlen(bb->filename) + 1 + sizeof(struct bb_function_info);
+	for (i = 0; bb->function_infos[i].arc_count != -1; i++)
+		len += sizeof(struct bb_function_info) +
+		       strlen(bb->function_infos[i].name) + 1;
+	result = (struct bb *) kmalloc(len, GFP_KERNEL);
+	if (!result)
+		return NULL;
+	memset(result, 0, len);
+	/* Copy count data */
+	result->counts = (gcov_type *) (result + 1);
+	result->ncounts = bb->ncounts;
+	memcpy(result->counts, bb->counts, result->ncounts * sizeof(gcov_type));
+	/* Prepare copy of function infos */
+	result->function_infos = (struct bb_function_info *)
+					&result->counts[result->ncounts];
+	/* Copy filename */
+	result->filename = (const char *) &result->function_infos[i + 1];
+	strcpy((char *) result->filename, bb->filename);
+	/* Copy function infos */
+	name = (char *) result->filename + strlen(result->filename) + 1;
+	for (i = 0; bb->function_infos[i].arc_count != -1; i++) {
+		result->function_infos[i].checksum =
+			bb->function_infos[i].checksum;
+		result->function_infos[i].arc_count =
+			bb->function_infos[i].arc_count;
+		strcpy(name, bb->function_infos[i].name);
+		result->function_infos[i].name = name;
+		name += strlen(name) + 1;
+	}
+	result->function_infos[i].arc_count = -1;
+	result->sizeof_bb = bb->sizeof_bb;
+
+#else /* GCOV_VERSION */
+
+	unsigned int active;
+	unsigned int i;
+	char *name;
+	struct gcov_fn_info *func;
+
+	/* Allocate memory for struct bb */
+	active = num_counter_active(bb);
+	len = sizeof(struct bb) +
+	      sizeof(struct gcov_ctr_info) * active +
+	      strlen(bb->filename) + 1;
+	for (i=0; i < active; i++)
+		len += sizeof(gcov_type) * bb->counts[i].num;
+	result = (struct bb *) kmalloc(len, GFP_KERNEL);
+	if (!result)
+		return NULL;
+	memset(result, 0, len);
+	/* Allocate memory for array of struct gcov_fn_info */
+	len = bb->n_functions * get_fn_stride(bb);
+	func = (struct gcov_fn_info *) kmalloc(len, GFP_KERNEL);
+	if (!func) {
+		kfree(result);
+		return NULL;
+	}
+	/* Copy function data */
+	memcpy(func, bb->functions, len);
+	result->functions = func;
+	/* Copy counts */
+	for (i=0; i < active; i++) {
+		result->counts[i].num = bb->counts[i].num;
+		result->counts[i].merge = bb->counts[i].merge;
+		if (i == 0) {
+			result->counts[i].values =
+				(gcov_type *) &result->counts[active];
+		} else {
+			result->counts[i].values =
+				result->counts[i - 1].values +
+				result->counts[i - 1].num;
+		}
+		memcpy(result->counts[i].values, bb->counts[i].values,
+		       sizeof(gcov_type) * result->counts[i].num);
+	}
+	/* Copy rest */
+	result->stamp = bb->stamp;
+	name = (char *) (result->counts[active - 1].values +
+			 result->counts[active - 1].num);
+	strcpy(name, bb->filename);
+	result->filename = name;
+	result->n_functions = bb->n_functions;
+	result->ctr_mask = bb->ctr_mask;
+
+#endif /* GCC_VERSION */
+
+	return result;
+}
+
+
+/* Return non-zero if BB1 and BB2 are compatible, zero otherwise. */
+static int
+is_compatible(struct bb *bb1, struct bb *bb2)
+{
+#if GCC_VERSION_LOWER(3, 3)
+	return (bb1->ncounts == bb2->ncounts);
+#elif GCC_VERSION_EQUAL(3, 3) && CONFIG_GCOV_HAMMER
+	unsigned int i;
+
+	if (bb1->n_functions != bb2->n_functions ||
+	    bb1->n_counter_sections != bb2->n_counter_sections)
+		return 0;
+	for (i=0; i < bb1->n_counter_sections; i++)
+		if (bb1->counter_sections[i].tag !=
+			bb2->counter_sections[i].tag ||
+		    bb1->counter_sections[i].n_counters !=
+			bb2->counter_sections[i].n_counters)
+			return 0;
+	for (i=0; i < bb1->n_functions; i++) {
+		if (bb1->functions[i].checksum != bb2->functions[i].checksum ||
+		    bb1->functions[i].n_counter_sections !=
+			bb2->functions[i].n_counter_sections)
+			return 0;
+	}
+	return 1;
+#elif GCC_VERSION_LOWER(3, 4)
+	int i;
+
+	if ((bb1->ncounts != bb2->ncounts) ||
+	    (bb1->sizeof_bb != bb2->sizeof_bb))
+		return 0;
+	for (i = 0; (bb1->function_infos[i].arc_count != -1) &&
+		    (bb2->function_infos[i].arc_count != -1); i++)
+		if (bb1->function_infos[i].checksum !=
+		    bb2->function_infos[i].checksum)
+			return 0;
+	return (bb1->function_infos[i].arc_count == -1) &&
+	       (bb2->function_infos[i].arc_count == -1);
+#else /* GCC_VERSION */
+	return (bb1->stamp == bb2->stamp);
+#endif /* GCC_VERSION */
+}
+
+
+/* Add count data from SOURCE to DEST. */
+static void
+merge_bb(struct bb *dest, struct bb *source)
+{
+#if GCC_VERSION_EQUAL(3, 3) && CONFIG_GCOV_HAMMER
+	unsigned int i;
+	unsigned int j;
+
+	for (i=0; i < dest->n_counter_sections; i++)
+		for (j=0; j < dest->counter_sections[i].n_counters; j++)
+			dest->counter_sections[i].counters[j] +=
+				source->counter_sections[i].counters[j];
+#elif GCC_VERSION_LOWER(3, 4)
+	long i;
+
+	for (i = 0; i < dest->ncounts; i++)
+		dest->counts[i] += source->counts[i];
+#else /* GCC_VERSION */
+	unsigned int i;
+	unsigned int j;
+
+	for (i=0; i < num_counter_active(dest); i++)
+		for (j=0; j < dest->counts[i].num; j++)
+			dest->counts[i].values[j] +=
+				source->counts[i].values[j];
+#endif /* GCC_VERSION_LOWER */
+}
+
+
+/* If there is a ghosted node for BB, merge old and current data, set status
+ * to normal and return zero. Return non-zero otherwise. */
+static int
+revive_node(struct bb *bb)
+{
+	struct gcov_ftree_node *node;
+
+	/* Check for a ghosted node */
+	for (node = leaf_nodes; node &&
+	     (strcmp(node->bb->filename, bb->filename) != 0);
+	     node=node->next);
+	if (!node)
+		return -ENOENT;
+	/* Check for compatible data */
+	if (!is_compatible(bb, node->bb)) {
+		printk(KERN_WARNING GCOV_PROC_HEADER "discarding saved data "
+		       "for %s due to incompatibilities\n", bb->filename);
+		cleanup_node_and_path(node);
+		update_vmlinux_data();
+		return -EINVAL;
+	}
+	/* Revive */
+	merge_bb(bb, node->bb);
+	kfree(node->bb);
+	node->bb = bb;
+	node->status = status_normal;
+	return 0;
+}
+
+
+/* Make a copy of the struct bb associated with node and set node status to
+ * ghost. Return zero on success, non-zero otherwise. */
+static int
+ghost_node(struct gcov_ftree_node *node)
+{
+	struct bb *bb;
+
+	/* Ghost node instead of removing it */
+	bb = clone_bb(node->bb);
+	if (!bb) {
+		printk(KERN_ERR GCOV_PROC_HEADER "not enough memory to save "
+		       "data for %s", node->bb->filename);
+		return -ENOMEM;
+	}
+	node->bb = bb;
+	node->status = status_ghost;
+	return 0;
+}
+
+
+/* Callback used to keep track of changes in the bb list. */
+static void
+gcov_proc_callback(enum gcov_cmd cmd, struct bb *bb)
+{
+	struct gcov_ftree_node *node;
+	int rc;
+
+	down(&gcov_lock);
+	switch (cmd) {
+	case gcov_add:
+		if (gcov_persist && (revive_node(bb) == 0))
+			break;
+		/* Insert node */
+		rc = create_node(bb);
+		if (rc) {
+			printk(KERN_ERR GCOV_PROC_HEADER "add failed: could "
+			       "not create node for %s (err=%d)\n",
+			       bb->filename, rc);
+		}
+		update_vmlinux_data();
+		break;
+	case gcov_remove:
+		/* Find node to remove */
+		for (node = leaf_nodes; node && (node->bb != bb);
+		     node=node->next);
+		if (!node)
+			break;
+		if (gcov_persist && (ghost_node(node) == 0))
+			break;
+		/* Remove node and empty path */
+		cleanup_node_and_path(node);
+		update_vmlinux_data();
+		break;
+	}
+	up(&gcov_lock);
+}
+
+
+/* Initialize module. */
+static int __init
+gcov_init_module(void)
+{
+	struct bb *bb;
+	int rc;
+
+	printk(KERN_INFO GCOV_PROC_HEADER "initializing proc module: "
+	       "persist=%d link=%d format=%s\n",
+	       gcov_persist, gcov_link, gcov_proc_format);
+	sourcepath_len = strlen(gcov_sourcepath);
+	objectpath_len = strlen(gcov_objectpath);
+	/* Initialize root node and /proc/gcov entry */
+	tree_root.fname = GCOV_PROC_ROOT;
+	tree_root.proc[0] = proc_mkdir(tree_root.fname, NULL);
+	if (!tree_root.proc[0]) {
+		printk(KERN_ERR GCOV_PROC_HEADER "init failed: could not "
+		       "create root proc filesystem entry\n");
+		return -EIO;
+	}
+	/* Create /proc/gcov/vmlinux entry */
+	proc_vmlinux = create_proc_entry(GCOV_PROC_VMLINUX, S_IWUSR | S_IRUGO,
+					 tree_root.proc[0]);
+	if (!proc_vmlinux) {
+		printk(KERN_ERR GCOV_PROC_HEADER "init failed: could not "
+		       "create proc filesystem entry %s\n", GCOV_PROC_VMLINUX);
+		cleanup_node(&tree_root);
+		return -EIO;
+	}
+	proc_vmlinux->proc_fops = &proc_gcov_operations;
+	/* Initialize /proc/gcov tree */
+	down(&gcov_core_lock);
+	for (bb = bb_head; bb ; bb = bb->next) {
+		rc = create_node(bb);
+		if (rc) {
+			printk(KERN_ERR GCOV_PROC_HEADER "init failed: could "
+			       "not create node for %s (err=%d)\n",
+			       bb->filename, rc);
+			remove_proc_entry(proc_vmlinux->name,
+					  tree_root.proc[0]);
+			cleanup_node(&tree_root);
+			up(&gcov_core_lock);
+			return rc;
+		}
+	}
+	gcov_callback = gcov_proc_callback;
+	update_vmlinux_data();
+	up(&gcov_core_lock);
+	up(&gcov_lock);
+	printk(KERN_INFO GCOV_PROC_HEADER "init done\n");
+	return 0;
+}
+
+
+/* Clean up module data. */
+static void __exit
+gcov_cleanup_module(void)
+{
+	down(&gcov_lock);
+	gcov_callback = NULL;
+	remove_proc_entry(proc_vmlinux->name, tree_root.proc[0]);
+	cleanup_node(&tree_root);
+	printk(KERN_INFO GCOV_PROC_HEADER "proc module is now unloaded\n");
+}
+
+
+module_init(gcov_init_module);
+module_exit(gcov_cleanup_module);
diff -ruN linux-omap-2.6/kernel/gcov/Kconfig maemo_src/kernel/gcov/Kconfig
--- linux-omap-2.6/kernel/gcov/Kconfig	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/kernel/gcov/Kconfig	2007-10-02 03:09:33.000000000 -0400
@@ -0,0 +1,55 @@
+#
+# GCOV coverage profiling
+#
+
+menu "GCOV coverage profiling"
+
+config GCOV_PROFILE
+	bool "Include GCOV coverage profiling"
+	---help---
+        Provide infrastructure for GCOV kernel coverage support.
+
+        Enable GCOV_ALL to get coverage data for the entire kernel
+        source.
+
+        To get coverage data for only specific files or directories,
+        add the following line to the respective Makefile:
+
+                EXTRA_CFLAGS += $(GCOV_FLAGS)
+
+        Note that GCOV_PROC has to be enabled to access GCOV kernel
+        coverage data.
+
+config GCOV_ALL
+	bool "Profile entire Kernel"
+	depends on GCOV_PROFILE
+	---help---
+	If you say Y here, it will compile the entire kernel with coverage
+	option enabled.
+
+config GCOV_PROC
+	tristate "Provide GCOV proc file system entry"
+	depends on GCOV_PROFILE && PROC_FS
+	---help---
+        Install a proc file system entry at /proc/gcov which provides
+        access to the current coverage state of the kernel code.
+
+        This option is also available as a module called gcov-proc.o.
+        It can be loaded using:
+
+          modprobe gcov-proc
+
+config GCOV_HAMMER
+	bool "Support for modified GCC version 3.3.x (hammer patch)"
+	depends on GCOV_PROFILE
+	---help---
+	Some Linux distributions ship a modified version of GCC 3.3.x that
+	produces GCOV data incompatible with the format of the standard
+	GCC 3.3.x. If you are using such a distribution, you need to enable
+	this option for the GCOV kernel support to work correctly.
+
+	Distributions known to include this modification:
+		SUSE SLES9
+		Mandrake Linux 10.x
+
+endmenu
diff -ruN linux-omap-2.6/kernel/gcov/Makefile maemo_src/kernel/gcov/Makefile
--- linux-omap-2.6/kernel/gcov/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/kernel/gcov/Makefile	2007-10-02 03:09:33.000000000 -0400
@@ -0,0 +1,14 @@
+#
+# Makefile for GCOV profiling kernel module
+#
+
+# 2006-03-07, anderson.lizardo@gmail.com:
+# Disable coverage for the gcov-kernel module itself. In the ARM platform, it
+# generates a soft-lockup while trying to read the data from /proc/gcov.
+CFLAGS := $(CFLAGS_NOGCOV)
+
+obj-$(CONFIG_GCOV_PROFILE) += gcov-core.o
+obj-$(CONFIG_GCOV_PROC)	   += gcov-proc.o
+
+CFLAGS_gcov-core.o := -DGCOV_SRC_PATH='"$(srctree)"' -DGCOV_OBJ_PATH='"$(objtree)"'
+
diff -ruN linux-omap-2.6/kernel/Makefile maemo_src/kernel/Makefile
--- linux-omap-2.6/kernel/Makefile	2011-02-06 19:45:12.053333272 -0500
+++ maemo_src/kernel/Makefile	2007-10-02 03:09:33.000000000 -0400
@@ -46,6 +46,7 @@
 obj-$(CONFIG_GENERIC_HARDIRQS) += irq/
 obj-$(CONFIG_SECCOMP) += seccomp.o
 obj-$(CONFIG_RCU_TORTURE_TEST) += rcutorture.o
+obj-$(CONFIG_GCOV_PROFILE) += gcov/
 obj-$(CONFIG_RELAY) += relay.o
 obj-$(CONFIG_SYSCTL) += utsname_sysctl.o
 obj-$(CONFIG_UTS_NS) += utsname.o
diff -ruN linux-omap-2.6/kernel/module.c maemo_src/kernel/module.c
--- linux-omap-2.6/kernel/module.c	2011-02-06 19:45:12.123333273 -0500
+++ maemo_src/kernel/module.c	2007-10-02 03:09:33.000000000 -0400
@@ -43,6 +43,7 @@
 #include <asm/uaccess.h>
 #include <asm/semaphore.h>
 #include <asm/cacheflush.h>
+#include <linux/gcov.h>
 #include <linux/license.h>
 
 #if 0
@@ -1207,6 +1208,11 @@
 	/* Arch-specific cleanup. */
 	module_arch_cleanup(mod);
 
+#ifdef CONFIG_GCOV_PROFILE
+	if (mod->ctors_start && mod->ctors_end)
+		remove_bb_link(mod);
+#endif
+
 	/* Module unload stuff */
 	module_unload_free(mod);
 
@@ -1371,11 +1377,22 @@
 		for (i = 0; i < hdr->e_shnum; ++i) {
 			Elf_Shdr *s = &sechdrs[i];
 
+#ifndef CONFIG_GCOV_PROFILE
 			if ((s->sh_flags & masks[m][0]) != masks[m][0]
 			    || (s->sh_flags & masks[m][1])
 			    || s->sh_entsize != ~0UL
 			    || strncmp(secstrings + s->sh_name,
 				       ".init", 5) == 0)
+#else
+			if ((s->sh_flags & masks[m][0]) != masks[m][0]
+			    || (s->sh_flags & masks[m][1])
+			    || s->sh_entsize != ~0UL
+			    || ((strncmp(secstrings + s->sh_name,
+					".init", 5) == 0) &&
+				(strncmp(secstrings + s->sh_name,
+					".init_array",11) != 0))
+			)
+#endif
 				continue;
 			s->sh_entsize = get_offset(&mod->core_size, s);
 			DEBUGP("\t%s\n", secstrings + s->sh_name);
@@ -1389,11 +1406,22 @@
 		for (i = 0; i < hdr->e_shnum; ++i) {
 			Elf_Shdr *s = &sechdrs[i];
 
+#ifndef CONFIG_GCOV_PROFILE
 			if ((s->sh_flags & masks[m][0]) != masks[m][0]
 			    || (s->sh_flags & masks[m][1])
 			    || s->sh_entsize != ~0UL
 			    || strncmp(secstrings + s->sh_name,
 				       ".init", 5) != 0)
+#else
+			if ((s->sh_flags & masks[m][0]) != masks[m][0]
+			    || (s->sh_flags & masks[m][1])
+			    || s->sh_entsize != ~0UL
+			    || ((strncmp(secstrings + s->sh_name,
+					".init", 5) != 0) ||
+				strncmp(secstrings + s->sh_name,
+					".init_array",11) == 0)
+			)
+#endif
 				continue;
 			s->sh_entsize = (get_offset(&mod->init_size, s)
 					 | INIT_OFFSET_MASK);
@@ -1780,6 +1808,13 @@
 	/* Module has been moved. */
 	mod = (void *)sechdrs[modindex].sh_addr;
 
+#ifdef CONFIG_GCOV_PROFILE
+	modindex = find_sec(hdr, sechdrs, secstrings, ".init_array");
+	mod->ctors_start = (char *)sechdrs[modindex].sh_addr;
+	mod->ctors_end   = (char *)(mod->ctors_start +
+				sechdrs[modindex].sh_size);
+#endif
+
 	/* Now we've moved module, initialize linked lists, etc. */
 	module_unload_init(mod);
 
@@ -2005,6 +2040,14 @@
 	blocking_notifier_call_chain(&module_notify_list,
 			MODULE_STATE_COMING, mod);
 
+#ifdef CONFIG_GCOV_PROFILE
+	if (mod->ctors_start && mod->ctors_end) {
+		do_global_ctors((ctor_t *) mod->ctors_start,
+			(mod->ctors_end - mod->ctors_start) / sizeof(ctor_t),
+			 mod);
+	}
+#endif
+
 	/* Start the module */
 	if (mod->init != NULL)
 		ret = mod->init();
diff -ruN linux-omap-2.6/kernel/sched.c maemo_src/kernel/sched.c
--- linux-omap-2.6/kernel/sched.c	2011-02-06 19:45:12.179999938 -0500
+++ maemo_src/kernel/sched.c	2007-10-02 03:09:33.000000000 -0400
@@ -4750,6 +4750,8 @@
 			show_task(p);
 	} while_each_thread(g, p);
 
+	touch_all_softlockup_watchdogs();
+
 	read_unlock(&tasklist_lock);
 	/*
 	 * Only show locks if all tasks are dumped:
diff -ruN linux-omap-2.6/kernel/softlockup.c maemo_src/kernel/softlockup.c
--- linux-omap-2.6/kernel/softlockup.c	2011-02-06 19:45:12.183333272 -0500
+++ maemo_src/kernel/softlockup.c	2007-10-02 03:09:33.000000000 -0400
@@ -34,12 +34,32 @@
 	.notifier_call = softlock_panic,
 };
 
+/*
+ * Returns seconds, approximately.  We don't need nanosecond
+ * resolution, and we don't need to waste time with a big divide when
+ * 2^30ns == 1.074s.
+ */
+static unsigned long get_timestamp(void)
+{
+	return sched_clock() >> 30;  /* 2^30 ~= 10^9 */
+}
+
 void touch_softlockup_watchdog(void)
 {
-	__raw_get_cpu_var(touch_timestamp) = jiffies;
+	__raw_get_cpu_var(touch_timestamp) = get_timestamp();
 }
 EXPORT_SYMBOL(touch_softlockup_watchdog);
 
+void touch_all_softlockup_watchdogs(void)
+{
+	int cpu;
+
+	/* Cause each CPU to re-update its timestamp rather than complain */
+	for_each_online_cpu(cpu)
+		per_cpu(touch_timestamp, cpu) = 0;
+}
+EXPORT_SYMBOL(touch_all_softlockup_watchdogs);
+
 /*
  * This callback runs from the timer interrupt, and checks
  * whether the watchdog thread has hung or not:
@@ -48,9 +68,18 @@
 {
 	int this_cpu = smp_processor_id();
 	unsigned long touch_timestamp = per_cpu(touch_timestamp, this_cpu);
+	unsigned long print_timestamp;
+	unsigned long now;
+
+	if (touch_timestamp == 0) {
+		touch_softlockup_watchdog();
+		return;
+	}
+
+	print_timestamp = per_cpu(print_timestamp, this_cpu);
 
-	/* prevent double reports: */
-	if (per_cpu(print_timestamp, this_cpu) == touch_timestamp ||
+	/* report at most once a second */
+	if (print_timestamp < (touch_timestamp + 1) ||
 		did_panic ||
 			!per_cpu(watchdog_task, this_cpu))
 		return;
@@ -61,12 +90,14 @@
 		return;
 	}
 
+	now = get_timestamp();
+
 	/* Wake up the high-prio watchdog task every second: */
-	if (time_after(jiffies, touch_timestamp + HZ))
+	if (now > (touch_timestamp + 1))
 		wake_up_process(per_cpu(watchdog_task, this_cpu));
 
 	/* Warn about unreasonable 10+ seconds delays: */
-	if (time_after(jiffies, touch_timestamp + 10*HZ)) {
+	if (now > (touch_timestamp + 10)) {
 		per_cpu(print_timestamp, this_cpu) = touch_timestamp;
 
 		spin_lock(&print_lock);
@@ -87,6 +118,9 @@
 	sched_setscheduler(current, SCHED_FIFO, &param);
 	current->flags |= PF_NOFREEZE;
 
+	/* initialize timestamp */
+	touch_softlockup_watchdog();
+
 	/*
 	 * Run briefly once per second to reset the softlockup timestamp.
 	 * If this gets delayed for more than 10 seconds then the
@@ -118,7 +152,7 @@
 			printk("watchdog for %i failed\n", hotcpu);
 			return NOTIFY_BAD;
 		}
-  		per_cpu(touch_timestamp, hotcpu) = jiffies;
+  		per_cpu(touch_timestamp, hotcpu) = 0;
   		per_cpu(watchdog_task, hotcpu) = p;
 		kthread_bind(p, hotcpu);
  		break;
diff -ruN linux-omap-2.6/kernel/sysctl.c maemo_src/kernel/sysctl.c
--- linux-omap-2.6/kernel/sysctl.c	2011-02-06 19:45:12.199999939 -0500
+++ maemo_src/kernel/sysctl.c	2011-02-06 20:12:10.583333271 -0500
@@ -611,6 +611,7 @@
    We use these as one-element integer vectors. */
 static int zero;
 static int one_hundred = 100;
+static int one_thousand = 1000;
 
 
 static ctl_table vm_table[] = {
@@ -655,7 +656,7 @@
 		.proc_handler	= &proc_dointvec_minmax,
 		.strategy	= &sysctl_intvec,
 		.extra1		= &zero,
-		.extra2		= &one_hundred,
+		.extra2		= &one_thousand,
 	},
 	{
 		.ctl_name	= VM_DIRTY_RATIO,
@@ -666,7 +667,7 @@
 		.proc_handler	= &proc_dointvec_minmax,
 		.strategy	= &sysctl_intvec,
 		.extra1		= &zero,
-		.extra2		= &one_hundred,
+		.extra2		= &one_thousand,
 	},
 	{
 		.ctl_name	= VM_DIRTY_WB_CS,
diff -ruN linux-omap-2.6/kernel/timer.c maemo_src/kernel/timer.c
--- linux-omap-2.6/kernel/timer.c	2011-02-06 19:45:12.209999938 -0500
+++ maemo_src/kernel/timer.c	2011-02-06 20:12:10.586666605 -0500
@@ -74,7 +74,7 @@
 	tvec_t tv3;
 	tvec_t tv4;
 	tvec_t tv5;
-} ____cacheline_aligned_in_smp;
+} ____cacheline_aligned;
 
 typedef struct tvec_t_base_s tvec_base_t;
 
@@ -82,6 +82,37 @@
 EXPORT_SYMBOL(boot_tvec_bases);
 static DEFINE_PER_CPU(tvec_base_t *, tvec_bases) = &boot_tvec_bases;
 
+/*
+ * Note that all tvec_bases is 2 byte aligned and lower bit of
+ * base in timer_list is guaranteed to be zero. Use the LSB for
+ * the new flag to indicate whether the timer is deferrable
+ */
+#define TBASE_DEFERRABLE_FLAG		(0x1)
+
+/* Functions below help us manage 'deferrable' flag */
+static inline unsigned int tbase_get_deferrable(tvec_base_t *base)
+{
+	return ((unsigned int)(unsigned long)base & TBASE_DEFERRABLE_FLAG);
+}
+
+static inline tvec_base_t *tbase_get_base(tvec_base_t *base)
+{
+	return ((tvec_base_t *)((unsigned long)base & ~TBASE_DEFERRABLE_FLAG));
+}
+
+static inline void timer_set_deferrable(struct timer_list *timer)
+{
+	timer->base = ((tvec_base_t *)((unsigned long)(timer->base) |
+	                               TBASE_DEFERRABLE_FLAG));
+}
+
+static inline void
+timer_set_base(struct timer_list *timer, tvec_base_t *new_base)
+{
+	timer->base = (tvec_base_t *)((unsigned long)(new_base) |
+	                              tbase_get_deferrable(timer->base));
+}
+
 /**
  * __round_jiffies - function to round jiffies to a full second
  * @j: the time in (absolute) jiffies that should be rounded
@@ -295,6 +326,13 @@
 }
 EXPORT_SYMBOL(init_timer);
 
+void fastcall init_timer_deferrable(struct timer_list *timer)
+{
+	init_timer(timer);
+	timer_set_deferrable(timer);
+}
+EXPORT_SYMBOL(init_timer_deferrable);
+
 static inline void detach_timer(struct timer_list *timer,
 				int clear_pending)
 {
@@ -325,10 +363,11 @@
 	tvec_base_t *base;
 
 	for (;;) {
-		base = timer->base;
+		tvec_base_t *prelock_base = timer->base;
+		base = tbase_get_base(prelock_base);
 		if (likely(base != NULL)) {
 			spin_lock_irqsave(&base->lock, *flags);
-			if (likely(base == timer->base))
+			if (likely(prelock_base == timer->base))
 				return base;
 			/* The timer has migrated to another CPU */
 			spin_unlock_irqrestore(&base->lock, *flags);
@@ -365,11 +404,11 @@
 		 */
 		if (likely(base->running_timer != timer)) {
 			/* See the comment in lock_timer_base() */
-			timer->base = NULL;
+			timer_set_base(timer, NULL);
 			spin_unlock(&base->lock);
 			base = new_base;
 			spin_lock(&base->lock);
-			timer->base = base;
+			timer_set_base(timer, base);
 		}
 	}
 
@@ -397,7 +436,7 @@
 	timer_stats_timer_set_start_info(timer);
   	BUG_ON(timer_pending(timer) || !timer->function);
 	spin_lock_irqsave(&base->lock, flags);
-	timer->base = base;
+	timer_set_base(timer, base);
 	internal_add_timer(base, timer);
 	spin_unlock_irqrestore(&base->lock, flags);
 }
@@ -548,7 +587,7 @@
 	 * don't have to detach them individually.
 	 */
 	list_for_each_entry_safe(timer, tmp, &tv_list, entry) {
-		BUG_ON(timer->base != base);
+		BUG_ON(tbase_get_base(timer->base) != base);
 		internal_add_timer(base, timer);
 	}
 
@@ -634,6 +673,9 @@
 	index = slot = timer_jiffies & TVR_MASK;
 	do {
 		list_for_each_entry(nte, base->tv1.vec + slot, entry) {
+ 			if (tbase_get_deferrable(nte->base))
+ 				continue;
+
 			found = 1;
 			expires = nte->expires;
 			/* Look at the cascade bucket(s)? */
@@ -662,6 +704,8 @@
 		index = slot = timer_jiffies & TVN_MASK;
 		do {
 			list_for_each_entry(nte, varp->vec + slot, entry) {
+				if (tbase_get_deferrable(nte->base))
+					continue;
 				found = 1;
 				if (time_before(nte->expires, expires))
 					expires = nte->expires;
@@ -1615,6 +1659,13 @@
 						cpu_to_node(cpu));
 			if (!base)
 				return -ENOMEM;
+
+			/* Make sure that tvec_base is 2 byte aligned */
+			if (tbase_get_deferrable(base)) {
+				WARN_ON(1);
+				kfree(base);
+				return -ENOMEM;
+			}
 			memset(base, 0, sizeof(*base));
 			per_cpu(tvec_bases, cpu) = base;
 		} else {
@@ -1656,7 +1707,7 @@
 	while (!list_empty(head)) {
 		timer = list_entry(head->next, struct timer_list, entry);
 		detach_timer(timer, 0);
-		timer->base = new_base;
+		timer_set_base(timer, new_base);
 		internal_add_timer(new_base, timer);
 	}
 }
diff -ruN linux-omap-2.6/lib/bust_spinlocks.c maemo_src/lib/bust_spinlocks.c
--- linux-omap-2.6/lib/bust_spinlocks.c	2011-02-06 19:45:12.219999940 -0500
+++ maemo_src/lib/bust_spinlocks.c	2011-02-06 20:12:10.636666607 -0500
@@ -12,7 +12,7 @@
 #include <linux/tty.h>
 #include <linux/wait.h>
 #include <linux/vt_kern.h>
-
+#include <linux/console.h>
 
 void __attribute__((weak)) bust_spinlocks(int yes)
 {
@@ -22,6 +22,7 @@
 #ifdef CONFIG_VT
 		unblank_screen();
 #endif
+		console_unblank();
 		oops_in_progress = 0;
 		wake_up_klogd();
 	}
diff -ruN linux-omap-2.6/lib/Kconfig maemo_src/lib/Kconfig
--- linux-omap-2.6/lib/Kconfig	2011-02-06 19:45:12.213333272 -0500
+++ maemo_src/lib/Kconfig	2007-10-02 03:09:33.000000000 -0400
@@ -47,6 +47,12 @@
 	depends on AUDIT && !AUDIT_ARCH
 	default y
 
+config LZO_COMPRESS
+	tristate
+
+config LZO_DECOMPRESS
+	tristate
+
 #
 # compression support is select'ed if needed
 #
diff -ruN linux-omap-2.6/lib/Kconfig.debug maemo_src/lib/Kconfig.debug
--- linux-omap-2.6/lib/Kconfig.debug	2011-02-06 19:45:12.216666606 -0500
+++ maemo_src/lib/Kconfig.debug	2007-10-02 03:09:33.000000000 -0400
@@ -446,3 +446,5 @@
 	select FRAME_POINTER
 	help
 	  Provide stacktrace filter for fault-injection capabilities
+
+source "kernel/gcov/Kconfig"
diff -ruN linux-omap-2.6/lib/lzo/lzo1x_compress.c maemo_src/lib/lzo/lzo1x_compress.c
--- linux-omap-2.6/lib/lzo/lzo1x_compress.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/lib/lzo/lzo1x_compress.c	2007-10-02 03:09:33.000000000 -0400
@@ -0,0 +1,227 @@
+/*
+ *  LZO1X Compressor from MiniLZO
+ *
+ *  Copyright (C) 1996-2005 Markus F.X.J. Oberhumer <markus@oberhumer.com>
+ *
+ *  The full LZO package can be found at:
+ *  http://www.oberhumer.com/opensource/lzo/
+ *
+ *  Changed for kernel use by:
+ *  Nitin Gupta <nitingupta910@gmail.com>
+ *  Richard Purdie <rpurdie@openedhand.com>
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/lzo.h>
+#include <asm/unaligned.h>
+#include "lzodefs.h"
+
+static noinline size_t
+_lzo1x_1_do_compress(const unsigned char *in, size_t in_len,
+		unsigned char *out, size_t *out_len, void *wrkmem)
+{
+	const unsigned char * const in_end = in + in_len;
+	const unsigned char * const ip_end = in + in_len - M2_MAX_LEN - 5;
+	const unsigned char ** const dict = wrkmem;
+	const unsigned char *ip = in, *ii = ip;
+	const unsigned char *end, *m, *m_pos;
+	size_t m_off, m_len, dindex;
+	unsigned char *op = out;
+
+	ip += 4;
+
+	for (;;) {
+		dindex = ((size_t)(0x21 * DX3(ip, 5, 5, 6)) >> 5) & D_MASK;
+		m_pos = dict[dindex];
+
+		if (m_pos < in)
+			goto literal;
+
+		if (ip == m_pos || ((size_t)(ip - m_pos) > M4_MAX_OFFSET))
+			goto literal;
+
+		m_off = ip - m_pos;
+		if (m_off <= M2_MAX_OFFSET || m_pos[3] == ip[3])
+			goto try_match;
+
+		dindex = (dindex & (D_MASK & 0x7ff)) ^ (D_HIGH | 0x1f);
+		m_pos = dict[dindex];
+
+		if (m_pos < in)
+			goto literal;
+
+		if (ip == m_pos || ((size_t)(ip - m_pos) > M4_MAX_OFFSET))
+			goto literal;
+
+		m_off = ip - m_pos;
+		if (m_off <= M2_MAX_OFFSET || m_pos[3] == ip[3])
+			goto try_match;
+
+		goto literal;
+
+try_match:
+		if (get_unaligned((const unsigned short *)m_pos)
+				== get_unaligned((const unsigned short *)ip)) {
+			if (likely(m_pos[2] == ip[2]))
+					goto match;
+		}
+
+literal:
+		dict[dindex] = ip;
+		++ip;
+		if (unlikely(ip >= ip_end))
+			break;
+		continue;
+
+match:
+		dict[dindex] = ip;
+		if (ip != ii) {
+			size_t t = ip - ii;
+
+			if (t <= 3) {
+				op[-2] |= t;
+			} else if (t <= 18) {
+				*op++ = (t - 3);
+			} else {
+				size_t tt = t - 18;
+
+				*op++ = 0;
+				while (tt > 255) {
+					tt -= 255;
+					*op++ = 0;
+				}
+				*op++ = tt;
+			}
+			do {
+				*op++ = *ii++;
+			} while (--t > 0);
+		}
+
+		ip += 3;
+		if (m_pos[3] != *ip++ || m_pos[4] != *ip++
+				|| m_pos[5] != *ip++ || m_pos[6] != *ip++
+				|| m_pos[7] != *ip++ || m_pos[8] != *ip++) {
+			--ip;
+			m_len = ip - ii;
+
+			if (m_off <= M2_MAX_OFFSET) {
+				m_off -= 1;
+				*op++ = (((m_len - 1) << 5)
+						| ((m_off & 7) << 2));
+				*op++ = (m_off >> 3);
+			} else if (m_off <= M3_MAX_OFFSET) {
+				m_off -= 1;
+				*op++ = (M3_MARKER | (m_len - 2));
+				goto m3_m4_offset;
+			} else {
+				m_off -= 0x4000;
+
+				*op++ = (M4_MARKER | ((m_off & 0x4000) >> 11)
+						| (m_len - 2));
+				goto m3_m4_offset;
+			}
+		} else {
+			end = in_end;
+			m = m_pos + M2_MAX_LEN + 1;
+
+			while (ip < end && *m == *ip) {
+				m++;
+				ip++;
+			}
+			m_len = ip - ii;
+
+			if (m_off <= M3_MAX_OFFSET) {
+				m_off -= 1;
+				if (m_len <= 33) {
+					*op++ = (M3_MARKER | (m_len - 2));
+				} else {
+					m_len -= 33;
+					*op++ = M3_MARKER | 0;
+					goto m3_m4_len;
+				}
+			} else {
+				m_off -= 0x4000;
+				if (m_len <= M4_MAX_LEN) {
+					*op++ = (M4_MARKER
+						| ((m_off & 0x4000) >> 11)
+						| (m_len - 2));
+				} else {
+					m_len -= M4_MAX_LEN;
+					*op++ = (M4_MARKER
+						| ((m_off & 0x4000) >> 11));
+m3_m4_len:
+					while (m_len > 255) {
+						m_len -= 255;
+						*op++ = 0;
+					}
+
+					*op++ = (m_len);
+				}
+			}
+m3_m4_offset:
+			*op++ = ((m_off & 63) << 2);
+			*op++ = (m_off >> 6);
+		}
+
+		ii = ip;
+		if (unlikely(ip >= ip_end))
+			break;
+	}
+
+	*out_len = op - out;
+	return in_end - ii;
+}
+
+int lzo1x_1_compress(const unsigned char *in, size_t in_len, unsigned char *out,
+			size_t *out_len, void *wrkmem)
+{
+	const unsigned char *ii;
+	unsigned char *op = out;
+	size_t t;
+
+	if (unlikely(in_len <= M2_MAX_LEN + 5)) {
+		t = in_len;
+	} else {
+		t = _lzo1x_1_do_compress(in, in_len, op, out_len, wrkmem);
+		op += *out_len;
+	}
+
+	if (t > 0) {
+		ii = in + in_len - t;
+
+		if (op == out && t <= 238) {
+			*op++ = (17 + t);
+		} else if (t <= 3) {
+			op[-2] |= t;
+		} else if (t <= 18) {
+			*op++ = (t - 3);
+		} else {
+			size_t tt = t - 18;
+
+			*op++ = 0;
+			while (tt > 255) {
+				tt -= 255;
+				*op++ = 0;
+			}
+
+			*op++ = tt;
+		}
+		do {
+			*op++ = *ii++;
+		} while (--t > 0);
+	}
+
+	*op++ = M4_MARKER | 1;
+	*op++ = 0;
+	*op++ = 0;
+
+	*out_len = op - out;
+	return LZO_E_OK;
+}
+
+EXPORT_SYMBOL_GPL(lzo1x_1_compress);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("LZO1X-1 Compressor");
+
diff -ruN linux-omap-2.6/lib/lzo/lzo1x_decompress.c maemo_src/lib/lzo/lzo1x_decompress.c
--- linux-omap-2.6/lib/lzo/lzo1x_decompress.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/lib/lzo/lzo1x_decompress.c	2007-10-02 03:09:33.000000000 -0400
@@ -0,0 +1,254 @@
+/*
+ *  LZO1X Decompressor from MiniLZO
+ *
+ *  Copyright (C) 1996-2005 Markus F.X.J. Oberhumer <markus@oberhumer.com>
+ *
+ *  The full LZO package can be found at:
+ *  http://www.oberhumer.com/opensource/lzo/
+ *
+ *  Changed for kernel use by:
+ *  Nitin Gupta <nitingupta910@gmail.com>
+ *  Richard Purdie <rpurdie@openedhand.com>
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/lzo.h>
+#include <asm/byteorder.h>
+#include <asm/unaligned.h>
+#include "lzodefs.h"
+
+#define HAVE_IP(x, ip_end, ip) ((size_t)(ip_end - ip) < (x))
+#define HAVE_OP(x, op_end, op) ((size_t)(op_end - op) < (x))
+#define HAVE_LB(m_pos, out, op) (m_pos < out || m_pos >= op)
+
+#define COPY4(dst, src)	\
+		put_unaligned(get_unaligned((const u32 *)(src)), (u32 *)(dst))
+
+int lzo1x_decompress_safe(const unsigned char *in, size_t in_len,
+			unsigned char *out, size_t *out_len)
+{
+	const unsigned char * const ip_end = in + in_len;
+	unsigned char * const op_end = out + *out_len;
+	const unsigned char *ip = in, *m_pos;
+	unsigned char *op = out;
+	size_t t;
+
+	*out_len = 0;
+
+	if (*ip > 17) {
+		t = *ip++ - 17;
+		if (t < 4)
+			goto match_next;
+		if (HAVE_OP(t, op_end, op))
+			goto output_overrun;
+		if (HAVE_IP(t + 1, ip_end, ip))
+			goto input_overrun;
+		do {
+			*op++ = *ip++;
+		} while (--t > 0);
+		goto first_literal_run;
+	}
+
+	while ((ip < ip_end)) {
+		t = *ip++;
+		if (t >= 16)
+			goto match;
+		if (t == 0) {
+			if (HAVE_IP(1, ip_end, ip))
+				goto input_overrun;
+			while (*ip == 0) {
+				t += 255;
+				ip++;
+				if (HAVE_IP(1, ip_end, ip))
+					goto input_overrun;
+			}
+			t += 15 + *ip++;
+		}
+		if (HAVE_OP(t + 3, op_end, op))
+			goto output_overrun;
+		if (HAVE_IP(t + 4, ip_end, ip))
+			goto input_overrun;
+
+		COPY4(op, ip);
+		op += 4;
+		ip += 4;
+		if (--t > 0) {
+			if (t >= 4) {
+				do {
+					COPY4(op, ip);
+					op += 4;
+					ip += 4;
+					t -= 4;
+				} while (t >= 4);
+				if (t > 0) {
+					do {
+						*op++ = *ip++;
+					} while (--t > 0);
+				}
+			} else {
+				do {
+					*op++ = *ip++;
+				} while (--t > 0);
+			}
+		}
+
+first_literal_run:
+		t = *ip++;
+		if (t >= 16)
+			goto match;
+		m_pos = op - (1 + M2_MAX_OFFSET);
+		m_pos -= t >> 2;
+		m_pos -= *ip++ << 2;
+
+		if (HAVE_LB(m_pos, out, op))
+			goto lookbehind_overrun;
+
+		if (HAVE_OP(3, op_end, op))
+			goto output_overrun;
+		*op++ = *m_pos++;
+		*op++ = *m_pos++;
+		*op++ = *m_pos;
+
+		goto match_done;
+
+		do {
+match:
+			if (t >= 64) {
+				m_pos = op - 1;
+				m_pos -= (t >> 2) & 7;
+				m_pos -= *ip++ << 3;
+				t = (t >> 5) - 1;
+				if (HAVE_LB(m_pos, out, op))
+					goto lookbehind_overrun;
+				if (HAVE_OP(t + 3 - 1, op_end, op))
+					goto output_overrun;
+				goto copy_match;
+			} else if (t >= 32) {
+				t &= 31;
+				if (t == 0) {
+					if (HAVE_IP(1, ip_end, ip))
+						goto input_overrun;
+					while (*ip == 0) {
+						t += 255;
+						ip++;
+						if (HAVE_IP(1, ip_end, ip))
+							goto input_overrun;
+					}
+					t += 31 + *ip++;
+				}
+				m_pos = op - 1;
+				m_pos -= le16_to_cpu(get_unaligned(
+					(const unsigned short *)ip)) >> 2;
+				ip += 2;
+			} else if (t >= 16) {
+				m_pos = op;
+				m_pos -= (t & 8) << 11;
+
+				t &= 7;
+				if (t == 0) {
+					if (HAVE_IP(1, ip_end, ip))
+						goto input_overrun;
+					while (*ip == 0) {
+						t += 255;
+						ip++;
+						if (HAVE_IP(1, ip_end, ip))
+							goto input_overrun;
+					}
+					t += 7 + *ip++;
+				}
+				m_pos -= le16_to_cpu(get_unaligned(
+					(const unsigned short *)ip) >> 2);
+				ip += 2;
+				if (m_pos == op)
+					goto eof_found;
+				m_pos -= 0x4000;
+			} else {
+				m_pos = op - 1;
+				m_pos -= t >> 2;
+				m_pos -= *ip++ << 2;
+
+				if (HAVE_LB(m_pos, out, op))
+					goto lookbehind_overrun;
+				if (HAVE_OP(2, op_end, op))
+					goto output_overrun;
+
+				*op++ = *m_pos++;
+				*op++ = *m_pos;
+				goto match_done;
+			}
+
+			if (HAVE_LB(m_pos, out, op))
+				goto lookbehind_overrun;
+			if (HAVE_OP(t + 3 - 1, op_end, op))
+				goto output_overrun;
+
+			if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4) {
+				COPY4(op, m_pos);
+				op += 4;
+				m_pos += 4;
+				t -= 4 - (3 - 1);
+				do {
+					COPY4(op, m_pos);
+					op += 4;
+					m_pos += 4;
+					t -= 4;
+				} while (t >= 4);
+				if (t > 0)
+					do {
+						*op++ = *m_pos++;
+					} while (--t > 0);
+			} else {
+copy_match:
+				*op++ = *m_pos++;
+				*op++ = *m_pos++;
+				do {
+					*op++ = *m_pos++;
+				} while (--t > 0);
+			}
+match_done:
+			t = ip[-2] & 3;
+			if (t == 0)
+				break;
+match_next:
+			if (HAVE_OP(t, op_end, op))
+				goto output_overrun;
+			if (HAVE_IP(t + 1, ip_end, ip))
+				goto input_overrun;
+
+			*op++ = *ip++;
+			if (t > 1) {
+				*op++ = *ip++;
+				if (t > 2)
+					*op++ = *ip++;
+			}
+
+			t = *ip++;
+		} while (ip < ip_end);
+	}
+
+	*out_len = op - out;
+	return LZO_E_EOF_NOT_FOUND;
+
+eof_found:
+	*out_len = op - out;
+	return (ip == ip_end ? LZO_E_OK :
+		(ip < ip_end ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN));
+input_overrun:
+	*out_len = op - out;
+	return LZO_E_INPUT_OVERRUN;
+
+output_overrun:
+	*out_len = op - out;
+	return LZO_E_OUTPUT_OVERRUN;
+
+lookbehind_overrun:
+	*out_len = op - out;
+	return LZO_E_LOOKBEHIND_OVERRUN;
+}
+
+EXPORT_SYMBOL_GPL(lzo1x_decompress_safe);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("LZO1X Decompressor");
+
diff -ruN linux-omap-2.6/lib/lzo/lzodefs.h maemo_src/lib/lzo/lzodefs.h
--- linux-omap-2.6/lib/lzo/lzodefs.h	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/lib/lzo/lzodefs.h	2007-10-02 03:09:33.000000000 -0400
@@ -0,0 +1,43 @@
+/*
+ *  lzodefs.h -- architecture, OS and compiler specific defines
+ *
+ *  Copyright (C) 1996-2005 Markus F.X.J. Oberhumer <markus@oberhumer.com>
+ *
+ *  The full LZO package can be found at:
+ *  http://www.oberhumer.com/opensource/lzo/
+ *
+ *  Changed for kernel use by:
+ *  Nitin Gupta <nitingupta910@gmail.com>
+ *  Richard Purdie <rpurdie@openedhand.com>
+ */
+
+#define LZO_VERSION		0x2020
+#define LZO_VERSION_STRING	"2.02"
+#define LZO_VERSION_DATE	"Oct 17 2005"
+
+#define M1_MAX_OFFSET	0x0400
+#define M2_MAX_OFFSET	0x0800
+#define M3_MAX_OFFSET	0x4000
+#define M4_MAX_OFFSET	0xbfff
+
+#define M1_MIN_LEN	2
+#define M1_MAX_LEN	2
+#define M2_MIN_LEN	3
+#define M2_MAX_LEN	8
+#define M3_MIN_LEN	3
+#define M3_MAX_LEN	33
+#define M4_MIN_LEN	3
+#define M4_MAX_LEN	9
+
+#define M1_MARKER	0
+#define M2_MARKER	64
+#define M3_MARKER	32
+#define M4_MARKER	16
+
+#define D_BITS		14
+#define D_MASK		((1u << D_BITS) - 1)
+#define D_HIGH		((D_MASK >> 1) + 1)
+
+#define DX2(p, s1, s2)	(((((size_t)((p)[2]) << (s2)) ^ (p)[1]) \
+							<< (s1)) ^ (p)[0])
+#define DX3(p, s1, s2, s3)	((DX2((p)+1, s2, s3) << (s1)) ^ (p)[0])
diff -ruN linux-omap-2.6/lib/lzo/Makefile maemo_src/lib/lzo/Makefile
--- linux-omap-2.6/lib/lzo/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/lib/lzo/Makefile	2007-10-02 03:09:33.000000000 -0400
@@ -0,0 +1,5 @@
+lzo_compress-objs := lzo1x_compress.o
+lzo_decompress-objs := lzo1x_decompress.o
+
+obj-$(CONFIG_LZO_COMPRESS) += lzo_compress.o
+obj-$(CONFIG_LZO_DECOMPRESS) += lzo_decompress.o
diff -ruN linux-omap-2.6/lib/Makefile maemo_src/lib/Makefile
--- linux-omap-2.6/lib/Makefile	2011-02-06 19:45:12.216666606 -0500
+++ maemo_src/lib/Makefile	2007-10-02 03:09:33.000000000 -0400
@@ -47,6 +47,8 @@
 obj-$(CONFIG_ZLIB_INFLATE) += zlib_inflate/
 obj-$(CONFIG_ZLIB_DEFLATE) += zlib_deflate/
 obj-$(CONFIG_REED_SOLOMON) += reed_solomon/
+obj-$(CONFIG_LZO_COMPRESS) += lzo/
+obj-$(CONFIG_LZO_DECOMPRESS) += lzo/
 
 obj-$(CONFIG_TEXTSEARCH) += textsearch.o
 obj-$(CONFIG_TEXTSEARCH_KMP) += ts_kmp.o
diff -ruN linux-omap-2.6/mm/page-writeback.c maemo_src/mm/page-writeback.c
--- linux-omap-2.6/mm/page-writeback.c	2011-02-06 19:45:12.346666606 -0500
+++ maemo_src/mm/page-writeback.c	2011-02-06 20:12:14.153333273 -0500
@@ -67,12 +67,12 @@
 /*
  * Start background writeback (via pdflush) at this percentage
  */
-int dirty_background_ratio = 10;
+int dirty_background_ratio = 100;
 
 /*
  * The generator of dirty data starts writeback at this percentage
  */
-int vm_dirty_ratio = 40;
+int vm_dirty_ratio = 400;
 
 /*
  * The interval between `kupdate'-style writebacks, in jiffies
@@ -139,23 +139,23 @@
 #endif
 
 
-	unmapped_ratio = 100 - ((global_page_state(NR_FILE_MAPPED) +
-				global_page_state(NR_ANON_PAGES)) * 100) /
+	unmapped_ratio = 1000 - ((global_page_state(NR_FILE_MAPPED) +
+				 global_page_state(NR_ANON_PAGES)) * 1000) /
 					vm_total_pages;
 
 	dirty_ratio = vm_dirty_ratio;
 	if (dirty_ratio > unmapped_ratio / 2)
 		dirty_ratio = unmapped_ratio / 2;
 
-	if (dirty_ratio < 5)
-		dirty_ratio = 5;
+	if (dirty_ratio < 1)
+		dirty_ratio = 1;
 
 	background_ratio = dirty_background_ratio;
 	if (background_ratio >= dirty_ratio)
 		background_ratio = dirty_ratio / 2;
 
-	background = (background_ratio * available_memory) / 100;
-	dirty = (dirty_ratio * available_memory) / 100;
+	background = (background_ratio * available_memory) / 1000;
+	dirty = (dirty_ratio * available_memory) / 1000;
 	tsk = current;
 	if (tsk->flags & PF_LESS_THROTTLE || rt_task(tsk)) {
 		background += background / 4;
@@ -552,6 +552,7 @@
  */
 void __init page_writeback_init(void)
 {
+	init_timer_deferrable(&wb_timer);
 	mod_timer(&wb_timer, jiffies + dirty_writeback_interval);
 	writeback_set_ratelimit();
 	register_cpu_notifier(&ratelimit_nb);
diff -ruN linux-omap-2.6/mm/slab.c maemo_src/mm/slab.c
--- linux-omap-2.6/mm/slab.c	2011-02-06 19:45:12.406666606 -0500
+++ maemo_src/mm/slab.c	2011-02-06 20:12:14.146666606 -0500
@@ -956,7 +956,7 @@
 	 */
 	if (keventd_up() && reap_work->work.func == NULL) {
 		init_reap_node(cpu);
-		INIT_DELAYED_WORK(reap_work, cache_reap);
+		INIT_DELAYED_WORK_DEFERRABLE(reap_work, cache_reap);
 		schedule_delayed_work_on(cpu, reap_work,
 					__round_jiffies_relative(HZ, cpu));
 	}
diff -ruN linux-omap-2.6/mm/swapfile.c maemo_src/mm/swapfile.c
--- linux-omap-2.6/mm/swapfile.c	2011-02-06 19:45:12.416666605 -0500
+++ maemo_src/mm/swapfile.c	2011-02-06 20:12:14.123333273 -0500
@@ -1192,8 +1192,13 @@
 		goto out;
 
 	victim = filp_open(pathname, O_RDWR|O_LARGEFILE, 0);
-	putname(pathname);
 	err = PTR_ERR(victim);
+	if (IS_ERR(victim)) {
+		victim = filp_open(pathname, O_RDONLY|O_LARGEFILE, 0);
+		err = PTR_ERR(victim);
+	}
+
+	putname(pathname);
 	if (IS_ERR(victim))
 		goto out;
 
diff -ruN linux-omap-2.6/net/bluetooth/hci_conn.c maemo_src/net/bluetooth/hci_conn.c
--- linux-omap-2.6/net/bluetooth/hci_conn.c	2011-02-06 19:45:12.473333272 -0500
+++ maemo_src/net/bluetooth/hci_conn.c	2007-10-02 03:09:33.000000000 -0400
@@ -72,11 +72,11 @@
 			inquiry_entry_age(ie) <= INQUIRY_ENTRY_AGE_MAX) {
 		cp.pscan_rep_mode = ie->data.pscan_rep_mode;
 		cp.pscan_mode     = ie->data.pscan_mode;
-		cp.clock_offset   = ie->data.clock_offset | __cpu_to_le16(0x8000);
+		cp.clock_offset   = ie->data.clock_offset | cpu_to_le16(0x8000);
 		memcpy(conn->dev_class, ie->data.dev_class, 3);
 	}
 
-	cp.pkt_type = __cpu_to_le16(hdev->pkt_type & ACL_PTYPE_MASK);
+	cp.pkt_type = cpu_to_le16(hdev->pkt_type & ACL_PTYPE_MASK);
 	if (lmp_rswitch_capable(hdev) && !(hdev->link_mode & HCI_LM_MASTER))
 		cp.role_switch	= 0x01;
 	else
@@ -107,7 +107,7 @@
 
 	conn->state = BT_DISCONN;
 
-	cp.handle = __cpu_to_le16(conn->handle);
+	cp.handle = cpu_to_le16(conn->handle);
 	cp.reason = reason;
 	hci_send_cmd(conn->hdev, OGF_LINK_CTL,
 				OCF_DISCONNECT, sizeof(cp), &cp);
@@ -123,8 +123,8 @@
 	conn->state = BT_CONNECT;
 	conn->out = 1;
 
-	cp.pkt_type = __cpu_to_le16(hdev->pkt_type & SCO_PTYPE_MASK);
-	cp.handle   = __cpu_to_le16(handle);
+	cp.pkt_type = cpu_to_le16(hdev->pkt_type & SCO_PTYPE_MASK);
+	cp.handle   = cpu_to_le16(handle);
 
 	hci_send_cmd(hdev, OGF_LINK_CTL, OCF_ADD_SCO, sizeof(cp), &cp);
 }
@@ -348,7 +348,7 @@
 
 	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
 		struct hci_cp_auth_requested cp;
-		cp.handle = __cpu_to_le16(conn->handle);
+		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(conn->hdev, OGF_LINK_CTL, OCF_AUTH_REQUESTED, sizeof(cp), &cp);
 	}
 	return 0;
@@ -368,7 +368,7 @@
 
 	if (hci_conn_auth(conn)) {
 		struct hci_cp_set_conn_encrypt cp;
-		cp.handle  = __cpu_to_le16(conn->handle);
+		cp.handle  = cpu_to_le16(conn->handle);
 		cp.encrypt = 1;
 		hci_send_cmd(conn->hdev, OGF_LINK_CTL, OCF_SET_CONN_ENCRYPT, sizeof(cp), &cp);
 	}
@@ -383,7 +383,7 @@
 
 	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
 		struct hci_cp_change_conn_link_key cp;
-		cp.handle = __cpu_to_le16(conn->handle);
+		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(conn->hdev, OGF_LINK_CTL, OCF_CHANGE_CONN_LINK_KEY, sizeof(cp), &cp);
 	}
 	return 0;
@@ -423,7 +423,7 @@
 
 	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
 		struct hci_cp_exit_sniff_mode cp;
-		cp.handle = __cpu_to_le16(conn->handle);
+		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(hdev, OGF_LINK_POLICY,
 				OCF_EXIT_SNIFF_MODE, sizeof(cp), &cp);
 	}
@@ -452,21 +452,21 @@
 
 	if (lmp_sniffsubr_capable(hdev) && lmp_sniffsubr_capable(conn)) {
 		struct hci_cp_sniff_subrate cp;
-		cp.handle             = __cpu_to_le16(conn->handle);
-		cp.max_latency        = __constant_cpu_to_le16(0);
-		cp.min_remote_timeout = __constant_cpu_to_le16(0);
-		cp.min_local_timeout  = __constant_cpu_to_le16(0);
+		cp.handle             = cpu_to_le16(conn->handle);
+		cp.max_latency        = cpu_to_le16(0);
+		cp.min_remote_timeout = cpu_to_le16(0);
+		cp.min_local_timeout  = cpu_to_le16(0);
 		hci_send_cmd(hdev, OGF_LINK_POLICY,
 				OCF_SNIFF_SUBRATE, sizeof(cp), &cp);
 	}
 
 	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
 		struct hci_cp_sniff_mode cp;
-		cp.handle       = __cpu_to_le16(conn->handle);
-		cp.max_interval = __cpu_to_le16(hdev->sniff_max_interval);
-		cp.min_interval = __cpu_to_le16(hdev->sniff_min_interval);
-		cp.attempt      = __constant_cpu_to_le16(4);
-		cp.timeout      = __constant_cpu_to_le16(1);
+		cp.handle       = cpu_to_le16(conn->handle);
+		cp.max_interval = cpu_to_le16(hdev->sniff_max_interval);
+		cp.min_interval = cpu_to_le16(hdev->sniff_min_interval);
+		cp.attempt      = cpu_to_le16(4);
+		cp.timeout      = cpu_to_le16(1);
 		hci_send_cmd(hdev, OGF_LINK_POLICY,
 				OCF_SNIFF_MODE, sizeof(cp), &cp);
 	}
diff -ruN linux-omap-2.6/net/bluetooth/hci_core.c maemo_src/net/bluetooth/hci_core.c
--- linux-omap-2.6/net/bluetooth/hci_core.c	2011-02-06 19:45:12.476666605 -0500
+++ maemo_src/net/bluetooth/hci_core.c	2007-10-02 03:09:33.000000000 -0400
@@ -216,10 +216,10 @@
 	/* Host buffer size */
 	{
 		struct hci_cp_host_buffer_size cp;
-		cp.acl_mtu = __cpu_to_le16(HCI_MAX_ACL_SIZE);
+		cp.acl_mtu = cpu_to_le16(HCI_MAX_ACL_SIZE);
 		cp.sco_mtu = HCI_MAX_SCO_SIZE;
-		cp.acl_max_pkt = __cpu_to_le16(0xffff);
-		cp.sco_max_pkt = __cpu_to_le16(0xffff);
+		cp.acl_max_pkt = cpu_to_le16(0xffff);
+		cp.sco_max_pkt = cpu_to_le16(0xffff);
 		hci_send_cmd(hdev, OGF_HOST_CTL, OCF_HOST_BUFFER_SIZE, sizeof(cp), &cp);
 	}
 #endif
@@ -240,11 +240,11 @@
 	}
 
 	/* Page timeout ~20 secs */
-	param = __cpu_to_le16(0x8000);
+	param = cpu_to_le16(0x8000);
 	hci_send_cmd(hdev, OGF_HOST_CTL, OCF_WRITE_PG_TIMEOUT, 2, &param);
 
 	/* Connection accept timeout ~20 secs */
-	param = __cpu_to_le16(0x7d00);
+	param = cpu_to_le16(0x7d00);
 	hci_send_cmd(hdev, OGF_HOST_CTL, OCF_WRITE_CA_TIMEOUT, 2, &param);
 }
 
@@ -1034,7 +1034,7 @@
 	}
 
 	hdr = (struct hci_command_hdr *) skb_put(skb, HCI_COMMAND_HDR_SIZE);
-	hdr->opcode = __cpu_to_le16(hci_opcode_pack(ogf, ocf));
+	hdr->opcode = cpu_to_le16(hci_opcode_pack(ogf, ocf));
 	hdr->plen   = plen;
 
 	if (plen)
@@ -1060,7 +1060,7 @@
 
 	hdr = (void *) hdev->sent_cmd->data;
 
-	if (hdr->opcode != __cpu_to_le16(hci_opcode_pack(ogf, ocf)))
+	if (hdr->opcode != cpu_to_le16(hci_opcode_pack(ogf, ocf)))
 		return NULL;
 
 	BT_DBG("%s ogf 0x%x ocf 0x%x", hdev->name, ogf, ocf);
@@ -1075,8 +1075,8 @@
 	int len = skb->len;
 
 	hdr = (struct hci_acl_hdr *) skb_push(skb, HCI_ACL_HDR_SIZE);
-	hdr->handle = __cpu_to_le16(hci_handle_pack(handle, flags));
-	hdr->dlen   = __cpu_to_le16(len);
+	hdr->handle = cpu_to_le16(hci_handle_pack(handle, flags));
+	hdr->dlen   = cpu_to_le16(len);
 
 	skb->h.raw = (void *) hdr;
 }
@@ -1140,7 +1140,7 @@
 		return -EINVAL;
 	}
 
-	hdr.handle = __cpu_to_le16(conn->handle);
+	hdr.handle = cpu_to_le16(conn->handle);
 	hdr.dlen   = skb->len;
 
 	skb->h.raw = skb_push(skb, HCI_SCO_HDR_SIZE);
diff -ruN linux-omap-2.6/net/bluetooth/hci_event.c maemo_src/net/bluetooth/hci_event.c
--- linux-omap-2.6/net/bluetooth/hci_event.c	2011-02-06 19:45:12.476666605 -0500
+++ maemo_src/net/bluetooth/hci_event.c	2007-10-02 03:09:33.000000000 -0400
@@ -783,7 +783,7 @@
 		if (conn->type == ACL_LINK && hdev->link_policy) {
 			struct hci_cp_write_link_policy cp;
 			cp.handle = ev->handle;
-			cp.policy = __cpu_to_le16(hdev->link_policy);
+			cp.policy = cpu_to_le16(hdev->link_policy);
 			hci_send_cmd(hdev, OGF_LINK_POLICY,
 				OCF_WRITE_LINK_POLICY, sizeof(cp), &cp);
 		}
@@ -793,8 +793,8 @@
 			struct hci_cp_change_conn_ptype cp;
 			cp.handle = ev->handle;
 			cp.pkt_type = (conn->type == ACL_LINK) ?
-				__cpu_to_le16(hdev->pkt_type & ACL_PTYPE_MASK):
-				__cpu_to_le16(hdev->pkt_type & SCO_PTYPE_MASK);
+				cpu_to_le16(hdev->pkt_type & ACL_PTYPE_MASK):
+				cpu_to_le16(hdev->pkt_type & SCO_PTYPE_MASK);
 
 			hci_send_cmd(hdev, OGF_LINK_CTL,
 				OCF_CHANGE_CONN_PTYPE, sizeof(cp), &cp);
@@ -970,7 +970,7 @@
 		if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
 			if (!ev->status) {
 				struct hci_cp_set_conn_encrypt cp;
-				cp.handle  = __cpu_to_le16(conn->handle);
+				cp.handle  = cpu_to_le16(conn->handle);
 				cp.encrypt = 1;
 				hci_send_cmd(conn->hdev, OGF_LINK_CTL,
 					OCF_SET_CONN_ENCRYPT, sizeof(cp), &cp);
diff -ruN linux-omap-2.6/net/bluetooth/hidp/core.c maemo_src/net/bluetooth/hidp/core.c
--- linux-omap-2.6/net/bluetooth/hidp/core.c	2011-02-06 19:45:12.479999938 -0500
+++ maemo_src/net/bluetooth/hidp/core.c	2011-02-06 20:12:10.383333273 -0500
@@ -246,14 +246,14 @@
 {
 	struct sk_buff *skb;
 
-	BT_DBG("session %p hid %p data %p size %d", session, device, data, size);
+	BT_DBG("session %p data %p size %d", session, data, size);
 
 	if (!(skb = alloc_skb(size + 1, GFP_ATOMIC))) {
 		BT_ERR("Can't allocate memory for new frame");
 		return -ENOMEM;
 	}
 
-	*skb_put(skb, 1) = 0xa2;
+	*skb_put(skb, 1) = HIDP_TRANS_DATA | HIDP_DATA_RTYPE_OUPUT;
 	if (size > 0)
 		memcpy(skb_put(skb, size), data, size);
 
@@ -456,27 +456,73 @@
 	kfree_skb(skb);
 }
 
+static inline struct sk_buff *hidp_do_sar(struct hidp_session *session, struct sk_buff *skb)
+{
+	struct sk_buff *ret;
+	int len = skb->len;
+	int imtu = l2cap_pi(session->intr_sock->sk)->imtu;
+
+	if (!session->intr_skb) {
+		if (len == imtu - 1) {
+			session->intr_skb = skb;
+			return NULL;
+		} else {
+			return skb;
+		}
+	}
+
+	if (len + session->intr_skb->len > (64*1024)) {
+		BT_ERR("Too large HID frame");
+		kfree_skb(session->intr_skb);
+		session->intr_skb = NULL;
+		kfree_skb(skb);
+		return NULL;
+	}
+
+	if (skb_padto(session->intr_skb, len + session->intr_skb->len) < 0) {
+		BT_ERR("Out of memory");
+		session->intr_skb = NULL;
+		return NULL;
+	}
+
+	memcpy(skb_put(session->intr_skb, len), skb_pull(skb, len), len);
+	kfree_skb(skb);
+
+	if (len == imtu - 1)
+		return NULL;
+
+	ret = session->intr_skb;
+	session->intr_skb = NULL;
+
+	return ret;
+}
+
 static inline void hidp_recv_intr_frame(struct hidp_session *session, struct sk_buff *skb)
 {
 	unsigned char hdr;
-
 	BT_DBG("session %p skb %p len %d", session, skb, skb->len);
 
 	hdr = skb->data[0];
 	skb_pull(skb, 1);
 
-	if (hdr == (HIDP_TRANS_DATA | HIDP_DATA_RTYPE_INPUT)) {
-		hidp_set_timer(session);
+	if (!(hdr == (HIDP_TRANS_DATA | HIDP_DATA_RTYPE_INPUT) ||
+	    hdr == (HIDP_TRANS_DATC | HIDP_DATA_RTYPE_INPUT))) {
+		kfree_skb(skb);
+		return;
+	}
 
-		if (session->input)
-			hidp_input_report(session, skb);
+	skb = hidp_do_sar(session, skb);
+	if (skb == NULL)
+		return;
 
-		if (session->hid) {
-			hid_input_report(session->hid, HID_INPUT_REPORT, skb->data, skb->len, 1);
-			BT_DBG("report len %d", skb->len);
-		}
-	} else {
-		BT_DBG("Unsupported protocol header 0x%02x", hdr);
+	hidp_set_timer(session);
+
+	if (session->input)
+		hidp_input_report(session, skb);
+
+	if (session->hid) {
+		hid_input_report(session->hid, HID_INPUT_REPORT, skb->data, skb->len, 1);
+		BT_DBG("report len %d", skb->len);
 	}
 
 	kfree_skb(skb);
@@ -686,7 +732,8 @@
 } hidp_blacklist[] = {
 	/* Apple wireless Mighty Mouse */
 	{ 0x05ac, 0x030c, HID_QUIRK_MIGHTYMOUSE | HID_QUIRK_INVERT_HWHEEL },
-
+	/* Nokia wireless keyboard */
+	{ 0x5555, 0x00dd, HID_QUIRK_SU_8W },
 	{ }	/* Terminating entry */
 };
 
diff -ruN linux-omap-2.6/net/bluetooth/hidp/hidp.h maemo_src/net/bluetooth/hidp/hidp.h
--- linux-omap-2.6/net/bluetooth/hidp/hidp.h	2011-02-06 19:45:12.483333272 -0500
+++ maemo_src/net/bluetooth/hidp/hidp.h	2011-02-06 20:12:10.383333273 -0500
@@ -151,6 +151,8 @@
 
 	struct sk_buff_head ctrl_transmit;
 	struct sk_buff_head intr_transmit;
+
+	struct sk_buff *intr_skb;
 };
 
 static inline void hidp_schedule(struct hidp_session *session)
diff -ruN linux-omap-2.6/net/bluetooth/l2cap.c maemo_src/net/bluetooth/l2cap.c
--- linux-omap-2.6/net/bluetooth/l2cap.c	2011-02-06 19:45:12.499999939 -0500
+++ maemo_src/net/bluetooth/l2cap.c	2007-10-02 03:09:33.000000000 -0400
@@ -459,8 +459,8 @@
 			sk->sk_state = BT_DISCONN;
 			l2cap_sock_set_timer(sk, sk->sk_sndtimeo);
 
-			req.dcid = __cpu_to_le16(l2cap_pi(sk)->dcid);
-			req.scid = __cpu_to_le16(l2cap_pi(sk)->scid);
+			req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);
+			req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
 			l2cap_send_cmd(conn, l2cap_get_ident(conn),
 					L2CAP_DISCONN_REQ, sizeof(req), &req);
 		} else {
@@ -507,6 +507,7 @@
 	}
 
 	/* Default config options */
+	pi->conf_len = 0;
 	pi->conf_mtu = L2CAP_DEFAULT_MTU;
 	pi->flush_to = L2CAP_DEFAULT_FLUSH_TO;
 }
@@ -652,7 +653,7 @@
 		if (sk->sk_type == SOCK_SEQPACKET) {
 			struct l2cap_conn_req req;
 			l2cap_pi(sk)->ident = l2cap_get_ident(conn);
-			req.scid = __cpu_to_le16(l2cap_pi(sk)->scid);
+			req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
 			req.psm  = l2cap_pi(sk)->psm;
 			l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
 					L2CAP_CONN_REQ, sizeof(req), &req);
@@ -868,8 +869,8 @@
 
 	/* Create L2CAP header */
 	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->cid = __cpu_to_le16(l2cap_pi(sk)->dcid);
-	lh->len = __cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));
+	lh->cid = cpu_to_le16(l2cap_pi(sk)->dcid);
+	lh->len = cpu_to_le16(len + (hlen - L2CAP_HDR_SIZE));
 
 	if (sk->sk_type == SOCK_DGRAM)
 		put_unaligned(l2cap_pi(sk)->psm, (u16 *) skb_put(skb, 2));
@@ -1096,7 +1097,7 @@
 		} else if (sk->sk_state == BT_CONNECT) {
 			struct l2cap_conn_req req;
 			l2cap_pi(sk)->ident = l2cap_get_ident(conn);
-			req.scid = __cpu_to_le16(l2cap_pi(sk)->scid);
+			req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
 			req.psm  = l2cap_pi(sk)->psm;
 			l2cap_send_cmd(conn, l2cap_pi(sk)->ident, L2CAP_CONN_REQ, sizeof(req), &req);
 		}
@@ -1192,13 +1193,13 @@
 		return NULL;
 
 	lh = (struct l2cap_hdr *) skb_put(skb, L2CAP_HDR_SIZE);
-	lh->len = __cpu_to_le16(L2CAP_CMD_HDR_SIZE + dlen);
-	lh->cid = __cpu_to_le16(0x0001);
+	lh->len = cpu_to_le16(L2CAP_CMD_HDR_SIZE + dlen);
+	lh->cid = cpu_to_le16(0x0001);
 
 	cmd = (struct l2cap_cmd_hdr *) skb_put(skb, L2CAP_CMD_HDR_SIZE);
 	cmd->code  = code;
 	cmd->ident = ident;
-	cmd->len   = __cpu_to_le16(dlen);
+	cmd->len   = cpu_to_le16(dlen);
 
 	if (dlen) {
 		count -= L2CAP_HDR_SIZE + L2CAP_CMD_HDR_SIZE;
@@ -1265,42 +1266,6 @@
 	return len;
 }
 
-static inline void l2cap_parse_conf_req(struct sock *sk, void *data, int len)
-{
-	int type, hint, olen;
-	unsigned long val;
-	void *ptr = data;
-
-	BT_DBG("sk %p len %d", sk, len);
-
-	while (len >= L2CAP_CONF_OPT_SIZE) {
-		len -= l2cap_get_conf_opt(&ptr, &type, &olen, &val);
-
-		hint  = type & 0x80;
-		type &= 0x7f;
-
-		switch (type) {
-		case L2CAP_CONF_MTU:
-			l2cap_pi(sk)->conf_mtu = val;
-			break;
-
-		case L2CAP_CONF_FLUSH_TO:
-			l2cap_pi(sk)->flush_to = val;
-			break;
-
-		case L2CAP_CONF_QOS:
-			break;
-
-		default:
-			if (hint)
-				break;
-
-			/* FIXME: Reject unknown option */
-			break;
-		}
-	}
-}
-
 static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)
 {
 	struct l2cap_conf_opt *opt = *ptr;
@@ -1316,11 +1281,11 @@
 		break;
 
 	case 2:
-		*((u16 *) opt->val) = __cpu_to_le16(val);
+		*((u16 *) opt->val) = cpu_to_le16(val);
 		break;
 
 	case 4:
-		*((u32 *) opt->val) = __cpu_to_le32(val);
+		*((u32 *) opt->val) = cpu_to_le32(val);
 		break;
 
 	default:
@@ -1346,46 +1311,82 @@
 	//if (flush_to != L2CAP_DEFAULT_FLUSH_TO)
 	//   l2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO, 2, pi->flush_to);
 
-	req->dcid  = __cpu_to_le16(pi->dcid);
-	req->flags = __cpu_to_le16(0);
+	req->dcid  = cpu_to_le16(pi->dcid);
+	req->flags = cpu_to_le16(0);
 
 	return ptr - data;
 }
 
-static inline int l2cap_conf_output(struct sock *sk, void **ptr)
+static int l2cap_parse_conf_req(struct sock *sk, void *data)
 {
 	struct l2cap_pinfo *pi = l2cap_pi(sk);
-	int result = 0;
+	struct l2cap_conf_rsp *rsp = data;
+	void *ptr = rsp->data;
+	void *req = pi->conf_req;
+	int len = pi->conf_len;
+	int type, hint, olen;
+	unsigned long val;
+	u16 result = L2CAP_CONF_SUCCESS;
 
-	/* Configure output options and let the other side know
-	 * which ones we don't like. */
-	if (pi->conf_mtu < pi->omtu)
-		result = L2CAP_CONF_UNACCEPT;
-	else
-		pi->omtu = pi->conf_mtu;
+	BT_DBG("sk %p", sk);
+
+	while (len >= L2CAP_CONF_OPT_SIZE) {
+		len -= l2cap_get_conf_opt(&req, &type, &olen, &val);
 
-	l2cap_add_conf_opt(ptr, L2CAP_CONF_MTU, 2, pi->omtu);
+		hint  = type & 0x80;
+		type &= 0x7f;
+
+		switch (type) {
+		case L2CAP_CONF_MTU:
+			pi->conf_mtu = val;
+			break;
+
+		case L2CAP_CONF_FLUSH_TO:
+			pi->flush_to = val;
+			break;
+
+		case L2CAP_CONF_QOS:
+			break;
+
+		default:
+			if (hint)
+				break;
+
+			result = L2CAP_CONF_UNKNOWN;
+			*((u8 *) ptr++) = type;
+			break;
+		}
+	}
+
+	if (result == L2CAP_CONF_SUCCESS) {
+		/* Configure output options and let the other side know
+		 * which ones we don't like. */
+
+		if (pi->conf_mtu < pi->omtu)
+			result = L2CAP_CONF_UNACCEPT;
+		else
+			pi->omtu = pi->conf_mtu;
+
+		l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);
+	}
 
-	BT_DBG("sk %p result %d", sk, result);
-	return result;
+	rsp->scid   = cpu_to_le16(pi->dcid);
+	rsp->result = cpu_to_le16(result);
+	rsp->flags  = cpu_to_le16(0x0000);
+
+	return ptr - data;
 }
 
-static int l2cap_build_conf_rsp(struct sock *sk, void *data, int *result)
+static int l2cap_build_conf_rsp(struct sock *sk, void *data, u16 result, u16 flags)
 {
 	struct l2cap_conf_rsp *rsp = data;
 	void *ptr = rsp->data;
-	u16 flags = 0;
-
-	BT_DBG("sk %p complete %d", sk, result ? 1 : 0);
 
-	if (result)
-		*result = l2cap_conf_output(sk, &ptr);
-	else
-		flags = 0x0001;
+	BT_DBG("sk %p", sk);
 
-	rsp->scid   = __cpu_to_le16(l2cap_pi(sk)->dcid);
-	rsp->result = __cpu_to_le16(result ? *result : 0);
-	rsp->flags  = __cpu_to_le16(flags);
+	rsp->scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
+	rsp->result = cpu_to_le16(result);
+	rsp->flags  = cpu_to_le16(flags);
 
 	return ptr - data;
 }
@@ -1470,10 +1471,10 @@
 	bh_unlock_sock(parent);
 
 sendresp:
-	rsp.scid   = __cpu_to_le16(scid);
-	rsp.dcid   = __cpu_to_le16(dcid);
-	rsp.result = __cpu_to_le16(result);
-	rsp.status = __cpu_to_le16(status);
+	rsp.scid   = cpu_to_le16(scid);
+	rsp.dcid   = cpu_to_le16(dcid);
+	rsp.result = cpu_to_le16(result);
+	rsp.status = cpu_to_le16(status);
 	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONN_RSP, sizeof(rsp), &rsp);
 	return 0;
 }
@@ -1529,7 +1530,7 @@
 	u16 dcid, flags;
 	u8 rsp[64];
 	struct sock *sk;
-	int result;
+	int len;
 
 	dcid  = __le16_to_cpu(req->dcid);
 	flags = __le16_to_cpu(req->flags);
@@ -1542,25 +1543,40 @@
 	if (sk->sk_state == BT_DISCONN)
 		goto unlock;
 
-	l2cap_parse_conf_req(sk, req->data, cmd->len - sizeof(*req));
+	/* Reject if config buffer is too small. */
+	len = cmd->len - sizeof(*req);
+	if (l2cap_pi(sk)->conf_len + len > sizeof(l2cap_pi(sk)->conf_req)) {
+		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
+				l2cap_build_conf_rsp(sk, rsp,
+					L2CAP_CONF_REJECT, flags), rsp);
+		goto unlock;
+	}
+
+	/* Store config. */
+	memcpy(l2cap_pi(sk)->conf_req + l2cap_pi(sk)->conf_len, req->data, len);
+	l2cap_pi(sk)->conf_len += len;
 
 	if (flags & 0x0001) {
 		/* Incomplete config. Send empty response. */
 		l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
-				l2cap_build_conf_rsp(sk, rsp, NULL), rsp);
+				l2cap_build_conf_rsp(sk, rsp,
+					L2CAP_CONF_SUCCESS, 0x0001), rsp);
 		goto unlock;
 	}
 
 	/* Complete config. */
-	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,
-			l2cap_build_conf_rsp(sk, rsp, &result), rsp);
-
-	if (result)
+	len = l2cap_parse_conf_req(sk, rsp);
+	if (len < 0)
 		goto unlock;
 
-	/* Output config done */
+	l2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);
+
+	/* Output config done. */
 	l2cap_pi(sk)->conf_state |= L2CAP_CONF_OUTPUT_DONE;
 
+	/* Reset config buffer. */
+	l2cap_pi(sk)->conf_len = 0;
+
 	if (l2cap_pi(sk)->conf_state & L2CAP_CONF_INPUT_DONE) {
 		sk->sk_state = BT_CONNECTED;
 		l2cap_chan_ready(sk);
@@ -1613,8 +1629,8 @@
 		l2cap_sock_set_timer(sk, HZ * 5);
 		{
 			struct l2cap_disconn_req req;
-			req.dcid = __cpu_to_le16(l2cap_pi(sk)->dcid);
-			req.scid = __cpu_to_le16(l2cap_pi(sk)->scid);
+			req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);
+			req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
 			l2cap_send_cmd(conn, l2cap_get_ident(conn),
 					L2CAP_DISCONN_REQ, sizeof(req), &req);
 		}
@@ -1652,8 +1668,8 @@
 	if (!(sk = l2cap_get_chan_by_scid(&conn->chan_list, dcid)))
 		return 0;
 
-	rsp.dcid = __cpu_to_le16(l2cap_pi(sk)->scid);
-	rsp.scid = __cpu_to_le16(l2cap_pi(sk)->dcid);
+	rsp.dcid = cpu_to_le16(l2cap_pi(sk)->scid);
+	rsp.scid = cpu_to_le16(l2cap_pi(sk)->dcid);
 	l2cap_send_cmd(conn, cmd->ident, L2CAP_DISCONN_RSP, sizeof(rsp), &rsp);
 
 	sk->sk_shutdown = SHUTDOWN_MASK;
@@ -1696,8 +1712,8 @@
 
 	BT_DBG("type 0x%4.4x", type);
 
-	rsp.type   = __cpu_to_le16(type);
-	rsp.result = __cpu_to_le16(L2CAP_IR_NOTSUPP);
+	rsp.type   = cpu_to_le16(type);
+	rsp.result = cpu_to_le16(L2CAP_IR_NOTSUPP);
 	l2cap_send_cmd(conn, cmd->ident, L2CAP_INFO_RSP, sizeof(rsp), &rsp);
 
 	return 0;
@@ -1794,7 +1810,7 @@
 			BT_DBG("error %d", err);
 
 			/* FIXME: Map err to a valid reason */
-			rej.reason = __cpu_to_le16(0);
+			rej.reason = cpu_to_le16(0);
 			l2cap_send_cmd(conn, cmd.ident, L2CAP_COMMAND_REJ, sizeof(rej), &rej);
 		}
 
@@ -1993,10 +2009,10 @@
 			result = L2CAP_CR_SEC_BLOCK;
 		}
 
-		rsp.scid   = __cpu_to_le16(l2cap_pi(sk)->dcid);
-		rsp.dcid   = __cpu_to_le16(l2cap_pi(sk)->scid);
-		rsp.result = __cpu_to_le16(result);
-		rsp.status = __cpu_to_le16(0);
+		rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
+		rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);
+		rsp.result = cpu_to_le16(result);
+		rsp.status = cpu_to_le16(0);
 		l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
 				L2CAP_CONN_RSP, sizeof(rsp), &rsp);
 
@@ -2041,10 +2057,10 @@
 			result = L2CAP_CR_SEC_BLOCK;
 		}
 
-		rsp.scid   = __cpu_to_le16(l2cap_pi(sk)->dcid);
-		rsp.dcid   = __cpu_to_le16(l2cap_pi(sk)->scid);
-		rsp.result = __cpu_to_le16(result);
-		rsp.status = __cpu_to_le16(0);
+		rsp.scid   = cpu_to_le16(l2cap_pi(sk)->dcid);
+		rsp.dcid   = cpu_to_le16(l2cap_pi(sk)->scid);
+		rsp.result = cpu_to_le16(result);
+		rsp.status = cpu_to_le16(0);
 		l2cap_send_cmd(conn, l2cap_pi(sk)->ident,
 				L2CAP_CONN_RSP, sizeof(rsp), &rsp);
 
diff -ruN linux-omap-2.6/net/bluetooth/rfcomm/core.c maemo_src/net/bluetooth/rfcomm/core.c
--- linux-omap-2.6/net/bluetooth/rfcomm/core.c	2011-02-06 19:45:12.503333272 -0500
+++ maemo_src/net/bluetooth/rfcomm/core.c	2007-10-02 03:09:33.000000000 -0400
@@ -622,7 +622,7 @@
 	bacpy(&addr.l2_bdaddr, src);
 	addr.l2_family = AF_BLUETOOTH;
 	addr.l2_psm    = 0;
-	*err = sock->ops->bind(sock, (struct sockaddr *) &addr, sizeof(addr));
+	*err = kernel_bind(sock, (struct sockaddr *) &addr, sizeof(addr));
 	if (*err < 0)
 		goto failed;
 
@@ -643,7 +643,7 @@
 	bacpy(&addr.l2_bdaddr, dst);
 	addr.l2_family = AF_BLUETOOTH;
 	addr.l2_psm    = htobs(RFCOMM_PSM);
-	*err = sock->ops->connect(sock, (struct sockaddr *) &addr, sizeof(addr), O_NONBLOCK);
+	*err = kernel_connect(sock, (struct sockaddr *) &addr, sizeof(addr), O_NONBLOCK);
 	if (*err == 0 || *err == -EINPROGRESS)
 		return s;
 
@@ -1058,6 +1058,12 @@
 		case BT_DISCONN:
 			d->state = BT_CLOSED;
 			__rfcomm_dlc_close(d, 0);
+
+			if (list_empty(&s->dlcs)) {
+				s->state = BT_DISCONN;
+				rfcomm_send_disc(s, 0);
+			}
+
 			break;
 		}
 	} else {
@@ -1067,6 +1073,9 @@
 			s->state = BT_CONNECTED;
 			rfcomm_process_connect(s);
 			break;
+		case BT_DISCONN:
+			rfcomm_session_put(s);
+			break;
 		}
 	}
 	return 0;
@@ -1757,19 +1766,12 @@
 
 	BT_DBG("session %p", s);
 
-	if (sock_create_lite(PF_BLUETOOTH, sock->type, BTPROTO_L2CAP, &nsock))
+	err = kernel_accept(sock, &nsock, O_NONBLOCK);
+	if (err < 0)
 		return;
 
-	nsock->ops  = sock->ops;
-
 	__module_get(nsock->ops->owner);
 
-	err = sock->ops->accept(sock, nsock, O_NONBLOCK);
-	if (err < 0) {
-		sock_release(nsock);
-		return;
-	}
-
 	/* Set our callbacks */
 	nsock->sk->sk_data_ready   = rfcomm_l2data_ready;
 	nsock->sk->sk_state_change = rfcomm_l2state_change;
@@ -1851,18 +1853,18 @@
 	BT_DBG("");
 
 	while (!atomic_read(&terminate)) {
+		set_current_state(TASK_INTERRUPTIBLE);
 		if (!test_bit(RFCOMM_SCHED_WAKEUP, &rfcomm_event)) {
 			/* No pending events. Let's sleep.
 			 * Incoming connections and data will wake us up. */
-			set_current_state(TASK_INTERRUPTIBLE);
 			schedule();
 		}
+		set_current_state(TASK_RUNNING);
 
 		/* Process stuff */
 		clear_bit(RFCOMM_SCHED_WAKEUP, &rfcomm_event);
 		rfcomm_process_sessions();
 	}
-	set_current_state(TASK_RUNNING);
 	return;
 }
 
@@ -1885,7 +1887,7 @@
 	bacpy(&addr.l2_bdaddr, ba);
 	addr.l2_family = AF_BLUETOOTH;
 	addr.l2_psm    = htobs(RFCOMM_PSM);
-	err = sock->ops->bind(sock, (struct sockaddr *) &addr, sizeof(addr));
+	err = kernel_bind(sock, (struct sockaddr *) &addr, sizeof(addr));
 	if (err < 0) {
 		BT_ERR("Bind failed %d", err);
 		goto failed;
@@ -1898,7 +1900,7 @@
 	release_sock(sk);
 
 	/* Start listening on the socket */
-	err = sock->ops->listen(sock, 10);
+	err = kernel_listen(sock, 10);
 	if (err) {
 		BT_ERR("Listen failed %d", err);
 		goto failed;
diff -ruN linux-omap-2.6/net/bluetooth/rfcomm/tty.c maemo_src/net/bluetooth/rfcomm/tty.c
--- linux-omap-2.6/net/bluetooth/rfcomm/tty.c	2011-02-06 19:45:12.506666605 -0500
+++ maemo_src/net/bluetooth/rfcomm/tty.c	2007-10-02 03:09:33.000000000 -0400
@@ -95,6 +95,10 @@
 
 	BT_DBG("dev %p dlc %p", dev, dlc);
 
+	write_lock_bh(&rfcomm_dev_lock);
+	list_del_init(&dev->list);
+	write_unlock_bh(&rfcomm_dev_lock);
+
 	rfcomm_dlc_lock(dlc);
 	/* Detach DLC if it's owned by this dev */
 	if (dlc->owner == dev)
@@ -156,8 +160,13 @@
 	read_lock(&rfcomm_dev_lock);
 
 	dev = __rfcomm_dev_get(id);
-	if (dev)
-		rfcomm_dev_hold(dev);
+
+	if (dev) {
+		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
+			dev = NULL;
+		else
+			rfcomm_dev_hold(dev);
+	}
 
 	read_unlock(&rfcomm_dev_lock);
 
@@ -265,6 +274,12 @@
 
 	dev->tty_dev = tty_register_device(rfcomm_tty_driver, dev->id, NULL);
 
+	if (IS_ERR(dev->tty_dev)) {
+		list_del(&dev->list);
+		kfree(dev);
+		return PTR_ERR(dev->tty_dev);
+	}
+
 	return dev->id;
 }
 
@@ -272,10 +287,7 @@
 {
 	BT_DBG("dev %p", dev);
 
-	write_lock_bh(&rfcomm_dev_lock);
-	list_del_init(&dev->list);
-	write_unlock_bh(&rfcomm_dev_lock);
-
+	set_bit(RFCOMM_TTY_RELEASED, &dev->flags);
 	rfcomm_dev_put(dev);
 }
 
@@ -329,7 +341,7 @@
 	if (copy_from_user(&req, arg, sizeof(req)))
 		return -EFAULT;
 
-	BT_DBG("sk %p dev_id %id flags 0x%x", sk, req.dev_id, req.flags);
+	BT_DBG("sk %p dev_id %d flags 0x%x", sk, req.dev_id, req.flags);
 
 	if (req.flags != NOCAP_FLAGS && !capable(CAP_NET_ADMIN))
 		return -EPERM;
@@ -370,7 +382,7 @@
 	if (copy_from_user(&req, arg, sizeof(req)))
 		return -EFAULT;
 
-	BT_DBG("dev_id %id flags 0x%x", req.dev_id, req.flags);
+	BT_DBG("dev_id %d flags 0x%x", req.dev_id, req.flags);
 
 	if (!(dev = rfcomm_dev_get(req.dev_id)))
 		return -ENODEV;
@@ -415,6 +427,8 @@
 
 	list_for_each(p, &rfcomm_dev_list) {
 		struct rfcomm_dev *dev = list_entry(p, struct rfcomm_dev, list);
+		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
+			continue;
 		(di + n)->id      = dev->id;
 		(di + n)->flags   = dev->flags;
 		(di + n)->state   = dev->dlc->state;
@@ -517,9 +531,10 @@
 	if (dlc->state == BT_CLOSED) {
 		if (!dev->tty) {
 			if (test_bit(RFCOMM_RELEASE_ONHUP, &dev->flags)) {
-				rfcomm_dev_hold(dev);
-				rfcomm_dev_del(dev);
+				if (rfcomm_dev_get(dev->id) == NULL)
+					return;
 
+				rfcomm_dev_del(dev);
 				/* We have to drop DLC lock here, otherwise
 				   rfcomm_dev_put() will dead lock if it's
 				   the last reference. */
@@ -974,8 +989,12 @@
 
 	rfcomm_tty_flush_buffer(tty);
 
-	if (test_bit(RFCOMM_RELEASE_ONHUP, &dev->flags))
+	if (test_bit(RFCOMM_RELEASE_ONHUP, &dev->flags)) {
+		if (rfcomm_dev_get(dev->id) == NULL)
+			return;
 		rfcomm_dev_del(dev);
+		rfcomm_dev_put(dev);
+	}
 }
 
 static int rfcomm_tty_read_proc(char *buf, char **start, off_t offset, int len, int *eof, void *unused)
diff -ruN linux-omap-2.6/net/core/flow.c maemo_src/net/core/flow.c
--- linux-omap-2.6/net/core/flow.c	2011-02-06 19:45:12.573333272 -0500
+++ maemo_src/net/core/flow.c	2011-02-06 20:12:10.259999939 -0500
@@ -355,7 +355,7 @@
 	flow_lwm = 2 * flow_hash_size;
 	flow_hwm = 4 * flow_hash_size;
 
-	init_timer(&flow_hash_rnd_timer);
+	init_timer_deferrable(&flow_hash_rnd_timer);
 	flow_hash_rnd_timer.function = flow_cache_new_hashrnd;
 	flow_hash_rnd_timer.expires = jiffies + FLOW_HASH_RND_PERIOD;
 	add_timer(&flow_hash_rnd_timer);
diff -ruN linux-omap-2.6/net/core/neighbour.c maemo_src/net/core/neighbour.c
--- linux-omap-2.6/net/core/neighbour.c	2011-02-06 19:45:12.579999940 -0500
+++ maemo_src/net/core/neighbour.c	2011-02-06 20:12:10.259999939 -0500
@@ -1372,7 +1372,7 @@
 	get_random_bytes(&tbl->hash_rnd, sizeof(tbl->hash_rnd));
 
 	rwlock_init(&tbl->lock);
-	init_timer(&tbl->gc_timer);
+	init_timer_deferrable(&tbl->gc_timer);
 	tbl->gc_timer.data     = (unsigned long)tbl;
 	tbl->gc_timer.function = neigh_periodic_timer;
 	tbl->gc_timer.expires  = now + 1;
diff -ruN linux-omap-2.6/net/ipv4/inetpeer.c maemo_src/net/ipv4/inetpeer.c
--- linux-omap-2.6/net/ipv4/inetpeer.c	2011-02-06 19:45:12.716666605 -0500
+++ maemo_src/net/ipv4/inetpeer.c	2011-02-06 20:12:10.389999940 -0500
@@ -129,6 +129,7 @@
 	/* All the timers, started at system startup tend
 	   to synchronize. Perturb it a bit.
 	 */
+	init_timer_deferrable(&peer_periodic_timer);
 	peer_periodic_timer.expires = jiffies
 		+ net_random() % inet_peer_gc_maxtime
 		+ inet_peer_gc_maxtime;
diff -ruN linux-omap-2.6/net/ipv4/ip_fragment.c maemo_src/net/ipv4/ip_fragment.c
--- linux-omap-2.6/net/ipv4/ip_fragment.c	2011-02-06 19:45:12.716666605 -0500
+++ maemo_src/net/ipv4/ip_fragment.c	2011-02-06 20:12:10.449999940 -0500
@@ -739,7 +739,7 @@
 	ipfrag_hash_rnd = (u32) ((num_physpages ^ (num_physpages>>7)) ^
 				 (jiffies ^ (jiffies >> 6)));
 
-	init_timer(&ipfrag_secret_timer);
+	init_timer_deferrable(&ipfrag_secret_timer);
 	ipfrag_secret_timer.function = ipfrag_secret_rebuild;
 	ipfrag_secret_timer.expires = jiffies + sysctl_ipfrag_secret_interval;
 	add_timer(&ipfrag_secret_timer);
diff -ruN linux-omap-2.6/net/ipv4/netfilter/ipt_IDLETIMER.c maemo_src/net/ipv4/netfilter/ipt_IDLETIMER.c
--- linux-omap-2.6/net/ipv4/netfilter/ipt_IDLETIMER.c	2011-02-06 20:17:26.183333272 -0500
+++ maemo_src/net/ipv4/netfilter/ipt_IDLETIMER.c	2011-02-06 20:12:10.389999940 -0500
@@ -4,8 +4,9 @@
  * Netfilter module to trigger a timer when packet matches.
  * After timer expires a kevent will be sent.
  *
- * Copyright (C) 2004 Nokia Corporation. All rights reserved.
+ * Copyright (C) 2004, 2007 Nokia Corporation. All rights reserved.
  * Written by Timo Teras <ext-timo.teras@nokia.com>
+ * IPv6 support added by Jukka Rissanen <jukka.rissanen@nokia.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License 
@@ -30,10 +31,11 @@
 #include <linux/notifier.h>
 #include <linux/netfilter.h>
 #include <linux/rtnetlink.h>
-#include <linux/netfilter/x_tables.h>
-#include <linux/netfilter_ipv4/ipt_IDLETIMER.h>
 #include <linux/kobject.h>
 #include <linux/workqueue.h>
+#include <linux/netfilter/x_tables.h>
+/* IPv6 is using the same ipc struct as IPv4 */
+#include <linux/netfilter_ipv4/ipt_IDLETIMER.h>
 
 #if 0
 #define DEBUGP(format, args...) printk("%s:%s:" format, \
@@ -42,6 +44,8 @@
 #define DEBUGP(format, args...)
 #endif
 
+static int ipv6_registered;
+
 /*
  * Internal timer management.
  */
@@ -182,12 +186,13 @@
 				unsigned long event, void *ptr)
 {
 	struct net_device *dev = ptr;
+	int st;
 
 	switch (event) {
 	case NETDEV_UP:
 		DEBUGP("NETDEV_UP: %s\n", dev->name);
-		device_create_file(&dev->dev,
-					 &dev_attr_idletimer);
+		st = device_create_file(&dev->dev,
+					&dev_attr_idletimer);
 		break;
 	case NETDEV_DOWN:
 		DEBUGP("NETDEV_DOWN: %s\n", dev->name);
@@ -268,6 +273,16 @@
 
 static struct xt_target ipt_idletimer = {
 	.name		= "IDLETIMER",
+	.family         = AF_INET,
+	.target		= ipt_idletimer_target,
+	.checkentry	= ipt_idletimer_checkentry,
+	.me		= THIS_MODULE,
+	.targetsize     = sizeof(struct ipt_idletimer_info),
+};
+
+static struct xt_target ip6t_idletimer = {
+	.name		= "IDLETIMER",
+	.family         = AF_INET6,
 	.target		= ipt_idletimer_target,
 	.checkentry	= ipt_idletimer_checkentry,
 	.me		= THIS_MODULE,
@@ -287,11 +302,22 @@
 		return -EINVAL;
 	}
 
+	if (xt_register_target(&ip6t_idletimer)) {
+		DEBUGP("IPv6: xt_register_target() failed\n");
+		/* Ignore the IPv6 error */
+		ipv6_registered = 0;
+	} else
+		ipv6_registered = 1;
+
 	return 0;
 }
 
 static void __exit fini(void)
 {
+	if (ipv6_registered) {
+		xt_unregister_target(&ip6t_idletimer);
+		ipv6_registered = 0;
+	}
 	xt_unregister_target(&ipt_idletimer);
 	utimer_fini();
 }
@@ -300,5 +326,5 @@
 module_exit(fini);
 
 MODULE_AUTHOR("Timo Teras <ext-timo.teras@nokia.com>");
-MODULE_DESCRIPTION("iptables idletimer target module");
+MODULE_DESCRIPTION("iptables idletimer target module for IPv4 and IPv6");
 MODULE_LICENSE("GPL");
diff -ruN linux-omap-2.6/net/ipv4/route.c maemo_src/net/ipv4/route.c
--- linux-omap-2.6/net/ipv4/route.c	2011-02-06 19:45:12.826666606 -0500
+++ maemo_src/net/ipv4/route.c	2011-02-06 20:12:10.389999940 -0500
@@ -3159,9 +3159,9 @@
 
 	init_timer(&rt_flush_timer);
 	rt_flush_timer.function = rt_run_flush;
-	init_timer(&rt_periodic_timer);
+	init_timer_deferrable(&rt_periodic_timer);
 	rt_periodic_timer.function = rt_check_expire;
-	init_timer(&rt_secret_timer);
+	init_timer_deferrable(&rt_secret_timer);
 	rt_secret_timer.function = rt_secret_rebuild;
 
 	/* All the timers, started at system startup tend
diff -ruN linux-omap-2.6/net/ipv4/tcp_input.c maemo_src/net/ipv4/tcp_input.c
--- linux-omap-2.6/net/ipv4/tcp_input.c	2011-02-06 19:45:12.869999938 -0500
+++ maemo_src/net/ipv4/tcp_input.c	2011-02-06 20:12:10.396666606 -0500
@@ -978,6 +978,9 @@
 	if (before(TCP_SKB_CB(ack_skb)->ack_seq, prior_snd_una - tp->max_window))
 		return 0;
 
+	if (!tp->packets_out)
+		goto out;
+
 	/* SACK fastpath:
 	 * if the only SACK change is the increase of the end_seq of
 	 * the first block then only apply that SACK block
@@ -1227,6 +1230,8 @@
 	if ((reord < tp->fackets_out) && icsk->icsk_ca_state != TCP_CA_Loss)
 		tcp_update_reordering(sk, ((tp->fackets_out + 1) - reord), 0);
 
+out:
+
 #if FASTRETRANS_DEBUG > 0
 	BUG_TRAP((int)tp->sacked_out >= 0);
 	BUG_TRAP((int)tp->lost_out >= 0);
diff -ruN linux-omap-2.6/net/ipv6/exthdrs.c maemo_src/net/ipv6/exthdrs.c
--- linux-omap-2.6/net/ipv6/exthdrs.c	2011-02-06 19:45:12.916666606 -0500
+++ maemo_src/net/ipv6/exthdrs.c	2011-02-06 20:12:10.353333272 -0500
@@ -651,6 +651,14 @@
   Hop-by-hop options.
  **********************************/
 
+/*
+ * Note: we cannot rely on skb->dst before we assign it in ip6_route_input().
+ */
+static inline struct inet6_dev *ipv6_skb_idev(struct sk_buff *skb)
+{
+	return skb->dst ? ip6_dst_idev(skb->dst) : __in6_dev_get(skb->dev);
+}
+
 /* Router Alert as of RFC 2711 */
 
 static int ipv6_hop_ra(struct sk_buff **skbp, int optoff)
@@ -677,25 +685,25 @@
 	if (skb->nh.raw[optoff+1] != 4 || (optoff&3) != 2) {
 		LIMIT_NETDEBUG(KERN_DEBUG "ipv6_hop_jumbo: wrong jumbo opt length/alignment %d\n",
 			       skb->nh.raw[optoff+1]);
-		IP6_INC_STATS_BH(ip6_dst_idev(skb->dst),
+		IP6_INC_STATS_BH(ipv6_skb_idev(skb),
 				 IPSTATS_MIB_INHDRERRORS);
 		goto drop;
 	}
 
 	pkt_len = ntohl(*(__be32*)(skb->nh.raw+optoff+2));
 	if (pkt_len <= IPV6_MAXPLEN) {
-		IP6_INC_STATS_BH(ip6_dst_idev(skb->dst), IPSTATS_MIB_INHDRERRORS);
+		IP6_INC_STATS_BH(ipv6_skb_idev(skb), IPSTATS_MIB_INHDRERRORS);
 		icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, optoff+2);
 		return 0;
 	}
 	if (skb->nh.ipv6h->payload_len) {
-		IP6_INC_STATS_BH(ip6_dst_idev(skb->dst), IPSTATS_MIB_INHDRERRORS);
+		IP6_INC_STATS_BH(ipv6_skb_idev(skb), IPSTATS_MIB_INHDRERRORS);
 		icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, optoff);
 		return 0;
 	}
 
 	if (pkt_len > skb->len - sizeof(struct ipv6hdr)) {
-		IP6_INC_STATS_BH(ip6_dst_idev(skb->dst), IPSTATS_MIB_INTRUNCATEDPKTS);
+		IP6_INC_STATS_BH(ipv6_skb_idev(skb), IPSTATS_MIB_INTRUNCATEDPKTS);
 		goto drop;
 	}
 
diff -ruN linux-omap-2.6/official maemo_src/official
--- linux-omap-2.6/official	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/official	2011-02-06 19:38:22.563333272 -0500
@@ -0,0 +1 @@
+fake
diff -ruN linux-omap-2.6/README.Debian maemo_src/README.Debian
--- linux-omap-2.6/README.Debian	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/README.Debian	2011-02-06 19:38:22.563333272 -0500
@@ -0,0 +1,2 @@
+kernel-source for Nokia 770
+---------------------------
diff -ruN linux-omap-2.6/rules maemo_src/rules
--- linux-omap-2.6/rules	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/rules	2011-02-06 19:38:22.573333274 -0500
@@ -0,0 +1,70 @@
+#!/usr/bin/make -f
+#
+# debian/rules for kernel-source.
+#
+# GNU copyright 1997 to 1999 by Joey Hess.
+# Copyright (c) 1999-2002 Herbert Xu <herbert@debian.org>
+# Copyright (c) 2004 Jens Schmalzing <jensen@debian.org>
+#
+
+release := $(shell dpkg-parsechangelog | awk '/^Version: / { print $$2 }')
+upstream := $(shell echo "$(release)" | sed 's/:\?\([0-9\.]\+\)-[0-9]*/\1/')
+KSOURCE := $(shell sed -n 's/^Package: .*\(kernel-source-[^ ]\+\).*$$/\1/; t e; b; :e; p; q' debian/control)
+PACKAGE := $(KSOURCE)
+DEFCONFIG := nokia_2420_defconfig
+REPO := kernel-source
+
+build:
+
+clean:
+	dh_testdir
+	dh_testroot
+
+# Hack in case we killed it in the middle of something
+
+	#find . -name .git -type d |xargs rm -rf
+	$(MAKE) -C $(REPO) distclean
+	rm -f modules/modversions.h debian/files debian/buildinfo
+	cd $(REPO)
+	rm -f modules/modversions.h modules/ksyms.ver conf.vars scripts/cramfs/cramfsck \
+		scripts/cramfs/mkcramfs applied_patches stamp-* .config*
+
+	dh_clean
+
+install:
+	dh_testdir
+	dh_testroot
+	dh_clean -k
+	dh_installdirs
+
+debian/kernel-tree-$(upstream).substvars: debian/make-substvars
+	sh debian/make-substvars $(upstream) > $@
+
+# Build architecture-independent files here.
+binary-indep: install
+	dh_testdir
+	dh_testroot
+	
+	make -C $(REPO) HOSTCC=host-gcc $(DEFCONFIG)
+	install -p -d -o root -g root -m 755 debian/$(PACKAGE)/usr/src/$(KSOURCE)
+	( cd $(REPO); tar cf - `echo *` | (cd ../debian/$(PACKAGE)/usr/src/$(KSOURCE); umask 000; tar xspf -))
+	( cd debian/$(PACKAGE)/usr/src/ && tar --bzip2 -cf $(KSOURCE).tar.bz2 $(KSOURCE) && rm -rf $(KSOURCE) )
+	pwd
+	dh_testroot
+	dh_installchangelogs
+	dh_installdocs
+	dh_link
+	dh_strip
+	dh_compress
+	dh_fixperms
+	dh_installdeb
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+# Build architecture-dependent files here.
+binary-arch:
+
+binary: binary-indep binary-arch
+	
+.PHONY: build clean binary-indep binary-arch binary install
diff -ruN linux-omap-2.6/scripts/Kbuild.include maemo_src/scripts/Kbuild.include
--- linux-omap-2.6/scripts/Kbuild.include	2011-02-06 19:45:13.426666606 -0500
+++ maemo_src/scripts/Kbuild.include	2007-10-02 03:09:34.000000000 -0400
@@ -122,6 +122,7 @@
 
 # Prefix -I with $(srctree) if it is not an absolute path.
 addtree = $(if $(filter-out -I/%,$(1)),$(patsubst -I%,-I$(srctree)/%,$(1))) $(1)
+addtree2 = $(if $(filter-out -I/%,$(1)),$(patsubst -I%,-I$(objtree)/%,$(1)),$(1))
 
 # Find all -I options and call addtree
 flags = $(foreach o,$($(1)),$(if $(filter -I%,$(o)),$(call addtree,$(o)),$(o)))
diff -ruN linux-omap-2.6/scripts/Makefile.build maemo_src/scripts/Makefile.build
--- linux-omap-2.6/scripts/Makefile.build	2011-02-06 19:45:13.426666606 -0500
+++ maemo_src/scripts/Makefile.build	2007-10-02 03:09:34.000000000 -0400
@@ -156,7 +156,8 @@
 quiet_cmd_cc_o_c = CC $(quiet_modtag)  $@
 
 ifndef CONFIG_MODVERSIONS
-cmd_cc_o_c = $(CC) $(c_flags) -c -o $@ $<
+cmd_cc_o_c = $(CC) $(c_flags) -c -o $@ \
+	     $(if $(filter-out /%,$<),$(srctree)/$<,$<)
 
 else
 # When module versioning is enabled the following steps are executed:
@@ -171,7 +172,9 @@
 #   replace the unresolved symbols __crc_exported_symbol with
 #   the actual value of the checksum generated by genksyms
 
-cmd_cc_o_c = $(CC) $(c_flags) -c -o $(@D)/.tmp_$(@F) $<
+cmd_cc_o_c = $(CC) $(c_flags) -c -o $(@D)/$(@F) \
+	     $(if $(filter-out /%,$<),$(srctree)/$<,$<) ; \
+             mv -f $(@D)/$(@F) $(@D)/.tmp_$(@F)
 cmd_modversions =							\
 	if $(OBJDUMP) -h $(@D)/.tmp_$(@F) | grep -q __ksymtab; then	\
 		$(CPP) -D__GENKSYMS__ $(c_flags) $<			\
diff -ruN linux-omap-2.6/scripts/Makefile.headersinst maemo_src/scripts/Makefile.headersinst
--- linux-omap-2.6/scripts/Makefile.headersinst	2011-02-06 19:45:13.426666606 -0500
+++ maemo_src/scripts/Makefile.headersinst	2007-10-02 03:09:34.000000000 -0400
@@ -108,7 +108,7 @@
 
 quiet_cmd_gen		  = GEN     $(patsubst $(INSTALL_HDR_PATH)/%,%,$@)
       cmd_gen		  = \
-FNAME=$(patsubst $(INSTALL_HDR_PATH)/$(_dst)/%,%,$@)			\
+FNAME=$(patsubst $(INSTALL_HDR_PATH)/$(_dst)/%,%,$@);			\
 STUBDEF=__ASM_STUB_`echo $$FNAME | tr a-z.- A-Z__`;			\
 (echo "/* File autogenerated by 'make headers_install' */" ;		\
 echo "\#ifndef $$STUBDEF" ;						\
diff -ruN linux-omap-2.6/scripts/Makefile.lib maemo_src/scripts/Makefile.lib
--- linux-omap-2.6/scripts/Makefile.lib	2011-02-06 19:45:13.426666606 -0500
+++ maemo_src/scripts/Makefile.lib	2007-10-02 03:09:34.000000000 -0400
@@ -93,7 +93,7 @@
 # If building the kernel in a separate objtree expand all occurrences
 # of -Idir to -I$(srctree)/dir except for absolute paths (starting with '/').
 
-ifeq ($(KBUILD_SRC),)
+ifeq ($(KBUILD_SRC)$(CONFIG_GCOV_PROFILE),)
 __c_flags	= $(_c_flags)
 __a_flags	= $(_a_flags)
 __cpp_flags     = $(_cpp_flags)
@@ -103,7 +103,7 @@
 # $(call addtree,-I$(obj)) locates .h files in srctree, from generated .c files
 #   and locates generated .h files
 # FIXME: Replace both with specific CFLAGS* statements in the makefiles
-__c_flags	= $(call addtree,-I$(obj)) $(call flags,_c_flags)
+__c_flags	= $(call addtree,-I$(obj)) $(call addtree2,-I$(obj)) $(call flags,_c_flags)
 __a_flags	=                          $(call flags,_a_flags)
 __cpp_flags     =                          $(call flags,_cpp_flags)
 endif
diff -ruN linux-omap-2.6/scripts/package/Makefile maemo_src/scripts/package/Makefile
--- linux-omap-2.6/scripts/package/Makefile	2011-02-06 19:45:13.479999938 -0500
+++ maemo_src/scripts/package/Makefile	2007-10-02 03:09:34.000000000 -0400
@@ -74,7 +74,7 @@
 	$(MAKE) KBUILD_SRC=
 	$(CONFIG_SHELL) $(srctree)/scripts/package/builddeb
 
-clean-dirs += $(objtree)/debian/
+#clean-dirs += $(objtree)/debian/
 
 
 # tarball targets
diff -ruN linux-omap-2.6/security/lowmem.c maemo_src/security/lowmem.c
--- linux-omap-2.6/security/lowmem.c	2011-02-06 20:17:26.183333272 -0500
+++ maemo_src/security/lowmem.c	2007-10-02 03:09:34.000000000 -0400
@@ -9,6 +9,7 @@
 #include <linux/pagemap.h>
 #include <linux/hugetlb.h>
 #include <linux/sysfs.h>
+#include <linux/oom.h>
 
 #define MY_NAME "lowmem"
 
@@ -207,6 +208,10 @@
 		if (cap_sys_admin)
 			return 0;
 
+		/* OOM unkillable process is allowed to consume memory */
+		if (OOM_DISABLE == current->oomkilladj)
+			return 0;
+
 		/* uids from allowed_uids vector are also allowed no matter what */
 		for (i = 0; i < LOWMEM_MAX_UIDS && allowed_uids[i]; i++)
 			if (current->uid == allowed_uids[i])
diff -ruN linux-omap-2.6/sound/arm/Kconfig maemo_src/sound/arm/Kconfig
--- linux-omap-2.6/sound/arm/Kconfig	2011-02-06 20:17:26.183333272 -0500
+++ maemo_src/sound/arm/Kconfig	2007-10-02 03:09:34.000000000 -0400
@@ -48,6 +48,12 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called snd-omap-aic23.
 	  
+config SND_AIC33
+	tristate "Texas Instruments TLV320AIC33 Audio Codec"
+	select I2C
+	help
+	  Say Y here if you have Texas Instruments TLV320AIC33 audio codec.
+
 config SND_OMAP_TSC2101
  	tristate "OMAP TSC2101 alsa driver"
  	depends on ARCH_OMAP && SND
diff -ruN linux-omap-2.6/sound/arm/omap/eac.c maemo_src/sound/arm/omap/eac.c
--- linux-omap-2.6/sound/arm/omap/eac.c	2011-02-06 20:17:26.186666606 -0500
+++ maemo_src/sound/arm/omap/eac.c	2011-02-06 20:12:09.116666607 -0500
@@ -45,6 +45,8 @@
 #include <sound/driver.h>
 #include <sound/core.h>
 #include <sound/initval.h>
+#include <sound/asound.h>
+#include <sound/control.h>
 
 
 #define EAC_CPCFR1		0x0000
@@ -251,6 +253,47 @@
 #define ASTCTR_ATT_BITS		(0x7f << 1)
 #define ASTCTR_ATTEN		(1 << 0)		/* side tone enabled/disabled */
 
+/* BPCTR */
+#define BPCTR_MC_EN		(1 << 7)
+#define BPCTR_PRE_MC(val)	((val & 0x07) << 1)	/* Main channel enable */
+#define BPCTR_PRE_MC_BITS	(0x07 << 1)
+#define BPCTR_CKEN		(1 << 0)		/* Enable AuSPI clock */
+
+/* BPMCCFR */
+#define BPMCCFR_DFILL_MC	(1 << 14)		/* Justified data filling value */
+#define BPMCCFR_DJUST_MC	(1 << 13)		/* Data justification */
+#define BPMCCFR_COMPAND(val)	((val & 0x03) << 11)	/* Compand mode for main channel */
+#define BPMCCFR_COMPAND_BITS	(0x03 << 11)
+#define BPMCCFR_EXPAND(val)	((val & 0x03) << 9)	/* Expand mode for recv reg */
+#define BPMCCFR_EXPAND_BITS	(0x03 << 9)
+#define BPMCCFR_MCM		(1 << 8)		/* Main channel mode */
+#define BPMCCFR_FSP_MC		(1 << 7)		/* Frame syncro polarity */
+#define BPMCCFR_FSBL_MC		(1 << 6)		/* Frame syncro level */
+#define BPMCCFR_CPB_MC		(1 << 5)		/* Clock polarity */
+#define BPMCCFR_WS_MC(val)	((val & 0x1f) << 0)	/* Word size for main channel */
+#define BPMCCFR_WS_MC_BITS	(0x1f << 0)
+
+/* MBPDMACTR */
+#define MBPDMACTR_BPDDMA(val)	((val & 0x03) << 10)	/* Bluetooth port d/u DMA write channel */
+#define MBPDMACTR_BPDDMA_BITS	(0x03 << 10)
+#define MBPDMACTR_BPUDMA(val)	((val & 0x03) << 8)	/* Bluetooth port u/d DMA read channel */
+#define MBPDMACTR_BPUDMA_BITS	(0x03 << 8)
+#define MBPDMACTR_MPDDMA(val)	((val & 0x03) << 6)	/* Modem port d/u DMA write channel */
+#define MBPDMACTR_MPDDMA_BITS	(0x03 << 6)
+#define MBPDMACTR_MPUDMA(val)	((val & 0x03) << 4)	/* Modem port u/d DMA read channel */
+#define MBPDMACTR_MPUDMA_BITS	(0x03 << 4)
+#define MBPDMACTR_BPDSRC(val)	((val & 0x03) << 2)	/* Bluetooth port d/u data source sel */
+#define MBPDMACTR_BPDSRC_BITS	(0x03 << 2)
+#define MBPDMACTR_MPDSRC(val)	((val & 0x03) << 0)	/* Modem port d/u data source sel */
+#define MBPDMACTR_MPDSRC_BITS	(0x03 << 0)
+
+/* SYSSTATUS */
+#define SYSS_AUD_RST_DONE	(1 << 5)		/* AUD reset done */
+#define SYSS_AUDRHEA_RST_DONE	(1 << 4)		/* AUDRHEA reset done */
+#define SYSS_CP_RST_DONE	(1 << 3)		/* CP reset done */
+#define SYSS_MD_RST_DONE	(1 << 2)		/* modem reset done */
+#define SYSS_BT_RST_DONE	(1 << 1)		/* bluetooth reset done */
+#define SYSS_OCP_RST_DONE	(1 << 0)		/* OCP reset done */
 
 /* internal structure of the EAC driver */
 struct omap_eac {
@@ -262,14 +305,39 @@
 	struct clk *			fck;
 	struct clk *			ick;
 	struct eac_codec *		codec;
-
-	unsigned			clocks_enabled:1;
+	s8				usecount;
 };
 
 static char *id = SNDRV_DEFAULT_STR1;
 module_param(id, charp, 0444);
 MODULE_PARM_DESC(id, "ID string for OMAP24xx EAC");
 
+#define EAC_ACTL_BOOL(xname, xprivate_value) \
+{\
+	.name		= xname, \
+	.iface		= SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.index		= 0, \
+	.access		= SNDRV_CTL_ELEM_ACCESS_READWRITE, \
+	.info		= eac_switch_info, \
+	.get		= eac_switch_get, \
+	.put		= eac_switch_put, \
+	.private_value	= xprivate_value, \
+}
+
+#define EAC_SINGLE(xname, reg, shift, mask) \
+{ \
+	.name		= xname, \
+	.iface		= SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.index		= 0, \
+	.access		= SNDRV_CTL_ELEM_ACCESS_READWRITE, \
+	.info		= eac_single_info, \
+	.get		= eac_single_get, \
+	.put		= eac_single_put, \
+	.private_value	= reg | (shift << 8) | (mask << 16) \
+}
+#define EAC_SINGLE_REG(v)	((v) & 0xff)
+#define EAC_SINGLE_SHIFT(v)	(((v) >> 8) & 0xf)
+#define EAC_SINGLE_MASK(v)	(((v) >> 16) & 0xff)
 
 #define MOD_REG_BIT(val, mask, set) do { \
 	if (set) \
@@ -288,6 +356,20 @@
 	return __raw_readw(eac->base + idx);
 }
 
+static int eac_wait_until_reset_done(struct omap_eac *eac, u16 resets)
+{
+	int i;
+
+	i = 10000;
+	while (!(eac_read_reg(eac, EAC_SYSSTATUS) & resets)) {
+		if (--i == 0)
+			return -ETIMEDOUT;
+		udelay(1);
+	}
+
+	return 0;
+}
+
 static int eac_get_clocks(struct omap_eac *eac)
 {
 	eac->ick = clk_get(NULL, "eac_ick");
@@ -312,39 +394,43 @@
 	clk_put(eac->ick);
 }
 
+/* Must be called with mutex lock held */
 static int eac_enable_clocks(struct omap_eac *eac)
 {
 	int err = 0;
 
-	if (eac->clocks_enabled)
-		return 0;
-
-	if (eac->pdata != NULL && eac->pdata->enable_ext_clocks != NULL) {
-		if ((err = eac->pdata->enable_ext_clocks(&eac->pdev->dev)) != 0)
-			return err;
+	if (eac->usecount == 0) {
+		clk_enable(eac->fck);
+		if (eac->pdata != NULL && eac->pdata->enable_ext_clocks != NULL)
+			if ((err = eac->pdata->enable_ext_clocks(&eac->pdev->dev)) != 0) {
+				clk_disable(eac->fck);
+				return err;
+			}
+		clk_enable(eac->ick);
 	}
-	clk_enable(eac->ick);
-	clk_enable(eac->fck);
-	eac->clocks_enabled = 1;
 
-	return 0;
+	eac->usecount++;
+
+	return err;
 }
 
+/* Must be called with mutex lock held */
 static void eac_disable_clocks(struct omap_eac *eac)
 {
-	if (!eac->clocks_enabled)
-		return;
-	eac->clocks_enabled = 0;
-
-	clk_disable(eac->fck);
-	clk_disable(eac->ick);
-	if (eac->pdata != NULL && eac->pdata->disable_ext_clocks != NULL)
-		eac->pdata->disable_ext_clocks(&eac->pdev->dev);
+	if (eac->usecount == 0)
+		BUG();
+
+	if (--eac->usecount == 0) {
+		clk_disable(eac->ick);
+		if (eac->pdata != NULL && eac->pdata->disable_ext_clocks != NULL)
+			eac->pdata->disable_ext_clocks(&eac->pdev->dev);
+		clk_disable(eac->fck);
+	}
 }
 
 static int eac_reset(struct omap_eac *eac)
 {
-	int i;
+	int r = 0;
 
 	/* step 1 (see TRM) */
 	/* first, let's reset the EAC */
@@ -353,14 +439,9 @@
 	eac_write_reg(eac, EAC_AGCTR, AGCTR_MCLK_EN | AGCTR_AUDEN);
 	/* step 3 (see TRM) */
 	/* wait until reset done */
-	i = 10000;
-	while (!(eac_read_reg(eac, EAC_SYSSTATUS) & 1)) {
-		if (--i == 0)
-			return -ENODEV;
-		udelay(1);
-	}
+	r = eac_wait_until_reset_done(eac, SYSS_OCP_RST_DONE);
 
-	return 0;
+	return r;
 }
 
 static int eac_calc_agcfr3_fsint(int rate)
@@ -466,11 +547,63 @@
 	return 0;
 }
 
+static int eac_bluetooth_port_init(struct omap_eac *eac)
+{
+	u16 reg;
+	int r;
+
+	reg = eac_read_reg(eac, EAC_AGCFR3);
+	reg = (reg & ~AGCFR3_BT_CKSRC_BITS) | AGCFR3_BT_CKSRC(1);
+	MOD_REG_BIT(reg, AGCFR3_CLK12MINT_SEL, 1);
+	eac_write_reg(eac, EAC_AGCFR3, reg);
+
+	/* Set sampling rate and wide band support */
+	reg = eac_read_reg(eac, EAC_AGCFR2);
+	MOD_REG_BIT(reg, AGCFR2_BT_MD_WIDEBAND, 0);
+	eac_write_reg(eac, EAC_AGCFR2, reg);
+
+	/* reset eac */
+	r = eac_wait_until_reset_done(eac, SYSS_AUD_RST_DONE |
+				  SYSS_AUDRHEA_RST_DONE |
+				  SYSS_BT_RST_DONE);
+	if (r < 0)
+		return r;
+
+	/* - Bluetooth port to master mode
+	 * - set 16 bit mode */
+	reg = eac_read_reg(eac, EAC_BPMCCFR);
+	MOD_REG_BIT(reg, BPMCCFR_MCM, 1);
+	reg = ((reg & ~BPMCCFR_WS_MC_BITS) | BPMCCFR_WS_MC(0x0f));
+	reg = ((reg & ~BPMCCFR_EXPAND_BITS) | BPMCCFR_EXPAND(0x00));
+	reg = ((reg & ~BPMCCFR_COMPAND_BITS) | BPMCCFR_COMPAND(0x00));
+	MOD_REG_BIT(reg, BPMCCFR_DFILL_MC, 0);
+	MOD_REG_BIT(reg, BPMCCFR_DJUST_MC, 0);
+	MOD_REG_BIT(reg, BPMCCFR_CPB_MC, 1);
+	MOD_REG_BIT(reg, BPMCCFR_FSP_MC, 1);
+	MOD_REG_BIT(reg, BPMCCFR_FSBL_MC, 1);
+	eac_write_reg(eac, EAC_BPMCCFR, reg);
+
+	/* - enable bluetooth channel
+	 * - set prescale clock divider
+	 * - enable AuSPI clock */
+	reg = eac_read_reg(eac, EAC_BPCTR);
+	MOD_REG_BIT(reg, BPCTR_MC_EN, 1);
+	reg = ((reg & ~BPCTR_PRE_MC_BITS) | BPCTR_PRE_MC(0x4));
+	MOD_REG_BIT(reg, BPCTR_CKEN, 1);
+	eac_write_reg(eac, EAC_BPCTR, reg);
+
+	reg = eac_read_reg(eac, EAC_MBPDMACTR);
+	reg = ((reg & ~MBPDMACTR_BPDSRC_BITS) | MBPDMACTR_BPDSRC(0x0));
+	eac_write_reg(eac, EAC_MBPDMACTR, reg);
+
+	return 0;
+}
+
 static int eac_codec_port_init(struct omap_eac *eac, struct eac_codec *conf)
 {
 	u16 agcfr, agcfr2, agcfr3, agctr;
 	u16 cpctl, reg;
-	int err = 0, i;
+	int err = 0;
 
 	/* use internal MCLK gating before doing full configuration for it.
 	 * Partial or misconfigured MCLK will cause that access to some of the
@@ -535,7 +668,7 @@
 
 	/* transparent DMA enable bits */
 	MOD_REG_BIT(agcfr3, AGCFR3_MD_TR_DMA, 1); /* modem */
-	MOD_REG_BIT(agcfr3, AGCFR3_BT_TR_DMA, 1); /* BT */
+	MOD_REG_BIT(agcfr3, AGCFR3_BT_TR_DMA, 0); /* BT */
 	if (conf->codec_mode != EAC_CODEC_I2S_SLAVE)
 		MOD_REG_BIT(agcfr3, AGCFR3_CP_TR_DMA, 0);
 	else
@@ -553,12 +686,9 @@
 
 	/* step 6 (see TRM) */
 	/* wait until audio reset done */
-	i = 10000;
-	while (!(eac_read_reg(eac, EAC_SYSSTATUS) & (1 << 3))) {
-		if (--i == 0)
-			return -ETIMEDOUT;
-		udelay(1);
-	}
+	err = eac_wait_until_reset_done(eac, SYSS_CP_RST_DONE);
+	if (err < 0)
+		return err;
 
 	/* step 7 (see TRM) */
 	reg = eac_read_reg(eac, EAC_AMSCFR);
@@ -653,13 +783,17 @@
 	BUG_ON(eac->codec != NULL);
 
 	mutex_lock(&eac->mutex);
-	eac->codec = codec;
 	eac_enable_clocks(eac);
+	eac->codec = codec;
 	err = eac_codec_port_init(eac, codec);
+	if (!err)
+		err = eac_bluetooth_port_init(eac);
 	eac_disable_clocks(eac);
 	mutex_unlock(&eac->mutex);
-	if (err)
+	if (err) {
+		dev_err(dev, "Register failed %d\n", err);
 		return err;
+	}
 
 	/* register mixer controls implemented by a codec driver */
 	if (codec->register_controls != NULL) {
@@ -688,13 +822,149 @@
 	eac->codec = NULL;
 }
 
+static int eac_switch_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type                     = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count                    = 1;
+	uinfo->value.integer.min        = 0;
+	uinfo->value.integer.max        = 1;
+
+	return 0;
+}
+
+static int eac_switch_get(struct snd_kcontrol *kcontrol,
+			  struct snd_ctl_elem_value *ucontrol)
+{
+	u16 reg;
+	unsigned long eac_switch;
+	struct omap_eac *eac = snd_kcontrol_chip(kcontrol);
+
+	eac_switch = kcontrol->private_value;
+
+	mutex_lock(&eac->mutex);
+	eac_enable_clocks(eac);
+	reg = eac_read_reg(eac, EAC_AMSCFR);
+	eac_disable_clocks(eac);
+	mutex_unlock(&eac->mutex);
+
+	ucontrol->value.integer.value[0] = reg & eac_switch;
+
+	return 0;
+}
+
+static int eac_switch_put(struct snd_kcontrol *kcontrol,
+			  struct snd_ctl_elem_value *ucontrol)
+{
+	u16 reg;
+	int val, old_val, changed = 0;
+	unsigned long eac_switch;
+	struct omap_eac *eac = snd_kcontrol_chip(kcontrol);
+
+	eac_switch = kcontrol->private_value;
+	val = ucontrol->value.integer.value[0];
+
+	mutex_lock(&eac->mutex);
+	eac_enable_clocks(eac);
+	reg = eac_read_reg(eac, EAC_AMSCFR);
+	old_val = reg & eac_switch;
+
+	if (old_val != val) {
+		MOD_REG_BIT(reg, eac_switch, val);
+		changed = 1;
+		eac_write_reg(eac, EAC_AMSCFR, reg);
+	}
+
+	eac_disable_clocks(eac);
+	mutex_unlock(&eac->mutex);
+
+	return changed;
+}
+
+static int eac_single_info(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_info *uinfo)
+{
+	int mask = EAC_SINGLE_MASK(kcontrol->private_value);
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = mask;
+
+	return 0;
+}
+
+static int eac_single_get(struct snd_kcontrol *kcontrol,
+			  struct snd_ctl_elem_value *ucontrol)
+{
+	struct omap_eac *eac = snd_kcontrol_chip(kcontrol);
+	int reg = EAC_SINGLE_REG(kcontrol->private_value);
+	int mask = EAC_SINGLE_MASK(kcontrol->private_value);
+	int shift = EAC_SINGLE_SHIFT(kcontrol->private_value);
+
+	mutex_lock(&eac->mutex);
+	eac_enable_clocks(eac);
+
+	ucontrol->value.integer.value[0] = (eac_read_reg(eac, reg) >> shift) &
+					   mask;
+
+	eac_disable_clocks(eac);
+	mutex_unlock(&eac->mutex);
+
+	return 0;
+}
+
+static int eac_single_put(struct snd_kcontrol *kcontrol,
+			  struct snd_ctl_elem_value *ucontrol)
+{
+	struct omap_eac *eac = snd_kcontrol_chip(kcontrol);
+	int reg = EAC_SINGLE_REG(kcontrol->private_value);
+	int mask = EAC_SINGLE_MASK(kcontrol->private_value);
+	int shift = EAC_SINGLE_SHIFT(kcontrol->private_value);
+	u16 old, new;
+	int changed;
+
+	mutex_lock(&eac->mutex);
+	eac_enable_clocks(eac);
+
+	new = old = eac_read_reg(eac, reg);
+	new &= ~(mask << shift);
+	new |= ((ucontrol->value.integer.value[0] & mask) << shift);
+	changed = (old != new);
+	if (changed)
+		eac_write_reg(eac, reg, new);
+
+	eac_disable_clocks(eac);
+	mutex_unlock(&eac->mutex);
+
+	return changed;
+}
+
+static struct snd_kcontrol_new eac_control[] __devinitdata = {
+	EAC_ACTL_BOOL("EACPCM Playback Switch", AMSCFR_K1),
+	EAC_ACTL_BOOL("BTM2PCM Loopback Switch", AMSCFR_K2),
+	EAC_ACTL_BOOL("BTM Playback Switch", AMSCFR_K3),
+	EAC_ACTL_BOOL("PCM2BTM Loopback Switch", AMSCFR_K4),
+	EAC_ACTL_BOOL("PCM Capture Switch", AMSCFR_K5),
+	EAC_ACTL_BOOL("BTM Capture Switch", AMSCFR_K6),
+	EAC_ACTL_BOOL("Modem Capture Switch", AMSCFR_K7),
+	EAC_ACTL_BOOL("BT Capture Switch", AMSCFR_K8),
+	EAC_ACTL_BOOL("Modem Playback Switch", AMSCFR_K9),
+	EAC_ACTL_BOOL("BT2Modem Loopback Switch", AMSCFR_K10),
+	EAC_ACTL_BOOL("BT Playback Switch", AMSCFR_K11),
+	EAC_ACTL_BOOL("Modem2BT Loopback Switch", AMSCFR_K12),
+
+	EAC_SINGLE("DMA Playback Volume", EAC_AMVCTR, 0, 0xff),
+	EAC_SINGLE("DMA Capture Volume", EAC_AMVCTR, 8, 0xff),
+};
+
 static int __devinit eac_probe(struct platform_device *pdev)
 {
 	struct eac_platform_data *pdata = pdev->dev.platform_data;
 	struct snd_card *card;
 	struct omap_eac *eac;
 	struct resource *res;
-	int err;
+	struct snd_kcontrol *control;
+	int err, i;
 
 	eac = kzalloc(sizeof(*eac), GFP_KERNEL);
 	if (!eac)
@@ -715,6 +985,7 @@
 	err = eac_get_clocks(eac);
 	if (err)
 		goto err1;
+	mutex_lock(&eac->mutex);
 	err = eac_enable_clocks(eac);
 	if (err)
 		goto err2;
@@ -727,6 +998,7 @@
 		 eac_read_reg(eac, EAC_VERSION) >> 4,
 		 eac_read_reg(eac, EAC_VERSION) & 0x0f);
 	eac_disable_clocks(eac);
+	mutex_unlock(&eac->mutex);
 
 	/* create soundcard instance */
 	card = snd_card_new(-1, id, THIS_MODULE, 0);
@@ -741,6 +1013,8 @@
 	sprintf(card->longname, "%s", card->shortname);
 	strcpy(card->mixername, "EAC Mixer");
 
+	card->private_data = eac;
+
 	if (eac->pdata->init) {
 		err = eac->pdata->init(&pdev->dev);
 		if (err < 0) {
@@ -749,6 +1023,22 @@
 		}
 	}
 
+	for (i = 0; i < ARRAY_SIZE(eac_control); i++) {
+		control = snd_ctl_new1(&eac_control[i], eac->card);
+		if (control == NULL) {
+			dev_err(&pdev->dev, "Cannot create audio control for %s\n",
+					eac_control[i].name);
+			break;
+		}
+
+		control->private_data = eac;
+
+		err = snd_ctl_add(eac->card, control);
+		if (err < 0)
+			dev_err(&pdev->dev, "Cannot add audio control %s error %d\n",
+					eac_control[i].name, err);
+	}
+
 	return 0;
 
 err4:
@@ -756,6 +1046,7 @@
 err3:
 	eac_disable_clocks(eac);
 err2:
+	mutex_unlock(&eac->mutex);
 	eac_put_clocks(eac);
 err1:
 	kfree(eac);
@@ -769,7 +1060,6 @@
 
 	snd_card_free(card);
 
-	eac_disable_clocks(eac);
 	eac_put_clocks(eac);
 
 	platform_set_drvdata(pdev, NULL);
diff -ruN linux-omap-2.6/sound/arm/omap/Makefile maemo_src/sound/arm/omap/Makefile
--- linux-omap-2.6/sound/arm/omap/Makefile	2011-02-06 20:17:26.183333272 -0500
+++ maemo_src/sound/arm/omap/Makefile	2007-10-02 03:09:34.000000000 -0400
@@ -16,3 +16,5 @@
 
 obj-$(CONFIG_SND_OMAP24XX_EAC) += snd-omap24xx-eac.o
 snd-omap24xx-eac-objs := eac.o
+
+obj-$(CONFIG_SND_AIC33) += tlv320aic33.o
diff -ruN linux-omap-2.6/sound/arm/omap/tlv320aic33.c maemo_src/sound/arm/omap/tlv320aic33.c
--- linux-omap-2.6/sound/arm/omap/tlv320aic33.c	1969-12-31 19:00:00.000000000 -0500
+++ maemo_src/sound/arm/omap/tlv320aic33.c	2011-02-06 20:12:09.083333272 -0500
@@ -0,0 +1,1242 @@
+/*
+ * tlv320aic33.c -- ALSA driver for Texas Instruments TLV320AIC33 Audio Codec
+ *
+ * Copyright (C) 2007 Nokia Corporation.
+ *
+ * Contact: Jarkko Nikula <jarkko.nikula@nokia.com>
+ *          Eero Nurkkala
+ *
+ * Known HW issues:
+ *
+ * - Extra few mA consumption can occur in AIC33 digital voltage domain if one
+ *   of the following condition is met
+ *
+ *   1. Output stage is once powered up and it is down when DAC is activated
+ *   2. Once powered output stage is in power down when PLL+DAC are shutdown
+ *   3. Once powered output stage is in power down when PLL is shutdown and
+ *      modifying that output stage control register while PLL is off
+ *
+ *   Consumption will recover to normal when this particular stage is
+ *   powered up and could be powered down if above conditions are met.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/tlv320aic33.h>
+
+#include <sound/driver.h>
+#include <sound/initval.h>
+#include <sound/control.h>
+
+#define DRIVER_NAME			"tlv320aic33"
+
+/* AIC33 Registers */
+#define PLL_PROGRAMMING_A		3
+#define PLL_PROGRAMMING_B		4
+#define PLL_PROGRAMMING_C		5
+#define PLL_PROGRAMMING_D		6
+#define CODEC_DATAPATH			7
+#define AUDIO_SERIAL_A			8
+#define AUDIO_CODEC_OVERFLOW		11
+#define AUDIO_DIGITAL_FILTER		12
+#define HEADSET_DETECTION_B		14
+#define LEFT_ADC_PGA_GAIN		15
+#define RIGHT_ADC_PGA_GAIN		16
+#define MIC3LR_TO_LEFT_ADC		17
+#define MIC3LR_TO_RIGHT_ADC		18
+#define LINE1L_TO_LEFT_ADC		19
+#define LINE2L_TO_LEFT_ADC		20
+#define LINE1R_TO_LEFT_ADC		21
+#define LINE1R_TO_RIGHT_ADC		22
+#define LINE2R_TO_RIGHT_ADC		23
+#define LINE1L_TO_RIGHT_ADC		24
+#define MICBIAS_CONTROL			25
+
+#define DAC_POWER_CTRL			37
+#define HPR_DRIVER_CTRL			38
+#define HPR_STAGE_CTRL			40
+#define DAC_OUTPUT_SWITCH		41
+
+#define LEFT_DAC_DIGITAL_VOLUME		43
+#define RIGHT_DAC_DIGITAL_VOLUME	44
+
+#define LINE2L_TO_HPLOUT_VOLUME		45
+#define PGA_L_TO_HPLOUT_VOLUME		46
+#define DAC_L1_TO_HPLOUT_VOLUME		47
+#define LINE2R_TO_HPLOUT_VOLUME		48
+#define PGA_R_TO_HPLOUT_VOLUME		49
+#define DAC_R1_TO_HPLOUT_VOLUME		50
+#define HPLOUT_OUTPUT_CTRL		51
+
+#define LINE2L_TO_HPLCOM_VOLUME		52
+#define PGA_L_TO_HPLCOM_VOLUME		53
+#define DAC_L1_TO_HPLCOM_VOLUME		54
+#define LINE2R_TO_HPLCOM_VOLUME		55
+#define PGA_R_TO_HPLCOM_VOLUME		56
+#define DAC_R1_TO_HPLCOM_VOLUME		57
+#define HPLCOM_OUTPUT_CTRL		58
+
+#define LINE2L_TO_HPROUT_VOLUME		59
+#define PGA_L_TO_HPROUT_VOLUME		60
+#define DAC_L1_TO_HPROUT_VOLUME		61
+#define LINE2R_TO_HPROUT_VOLUME		62
+#define PGA_R_TO_HPROUT_VOLUME		63
+#define DAC_R1_TO_HPROUT_VOLUME		64
+#define HPROUT_OUTPUT_CTRL		65
+
+#define LINE2L_TO_HPRCOM_VOLUME		66
+#define PGA_L_TO_HPRCOM_VOLUME		67
+#define DAC_L1_TO_HPRCOM_VOLUME		68
+#define LINE2R_TO_HPRCOM_VOLUME		69
+#define PGA_R_TO_HPRCOM_VOLUME		70
+#define DAC_R1_TO_HPRCOM_VOLUME		71
+#define HPRCOM_OUTPUT_CTRL		72
+
+#define LINE2L_TO_MONO_VOLUME		73
+#define PGA_L_TO_MONO_VOLUME		74
+#define DAC_L1_TO_MONO_VOLUME		75
+#define LINE2R_TO_MONO_VOLUME		76
+#define PGA_R_TO_MONO_VOLUME		77
+#define DAC_R1_TO_MONO_VOLUME		78
+#define MONO_OUTPUT_CTRL		79
+
+#define LINE2_TO_L_LO_VOLUME		80
+#define PGA_L_TO_L_LO_VOLUME		81
+#define DAC_L1_TO_L_LO_VOLUME		82
+#define LINE2R_TO_L_LO_VOLUME		83
+#define PGA_R_TO_L_LO_VOLUME		84
+#define DAC_R1_TO_L_LO_VOLUME		85
+#define LEFT_LO_OUTPUT_CTRL		86
+
+#define LINE2L_TO_R_LO_VOLUME		87
+#define PGA_L_TO_R_LO_VOLUME		88
+#define DAC_L1_TO_R_LO_VOLUME		89
+#define LINE2R_TO_R_LO_VOLUME		90
+#define PGA_R_TO_R_LO_VOLUME		91
+#define DAC_R1_TO_R_LO_VOLUME		92
+#define RIGHT_LO_OUTPUT_CTRL		93
+
+#define GPIO1_CONTROL			98
+#define GPIO2_CONTROL			99
+
+#define IS_OUTPUT_CTRL_REG(reg)		((reg) > 50 && (reg) < 94 && \
+					 (((reg) - 51) % 7) == 0)
+
+/* PLL definitions */
+#define PLL_VAL_P(val)			((val & 0x7) << 0)
+#define PLL_VAL_J(val)			((val & 0x3f) << 2)
+#define PLL_VAL_D_8MSB(val)		(((val >> 6) & 0xff) << 0)
+#define PLL_VAL_D_6LSB(val)		((val & 0x3f) << 0)
+#define PLL_VAL_R(val)			((val & 0x07) << 0)
+#define PLL_ENABLED			(1 << 7)
+
+/* output stage level control register bits */
+#define OUTPUT_POWERED			(1 << 0)
+#define OUTPUT_UNMUTED			(1 << 3)
+#define HP_OUTPUT_TRI_STATED		(1 << 2) /* only in HP control regs */
+
+/* DAC definitions */
+#define DAC_L1R1_ROUTE_ENABLE		(1 << 7)
+#define DAC_LEFT_POWER			(1 << 7)
+#define DAC_RIGHT_POWER			(1 << 6)
+#define DAC_LEFT_MUTE			(1 << 7)
+#define DAC_RIGHT_MUTE			(1 << 7)
+#define DAC_LEFT_PLAYS_LEFT_CHANNEL	(1 << 3)
+#define DAC_RIGHT_PLAYS_RIGHT_CHANNEL	(1 << 1)
+
+/* ADC definitions */
+#define ADC_LEFT_HIGHPASS(v)		(((v) & 3) << 6)
+#define ADC_RIGHT_HIGHPASS(v)		(((v) & 3) << 4)
+#define ADC_PGA_MUTE			(1 << 7)
+#define ADC_POWER			(1 << 2)
+
+/* Miscellaneous definitions */
+#define DMIC_OVERSAMPLING_MASK		(0x3 << 0)
+#define DMIC_OVERSAMPLING(v)		(((v) & 0x3) << 0)
+#define DMIC_OVERSAMPLING_VAL(v)	(((v) >> 0) & 0x3)
+#define GPIO1_CTRL(v)			(((v) & 0xf) << 4)
+#define GPIO2_CTRL(v)			(((v) & 0xf) << 4)
+#define MICBIAS_MASK			(0x3 << 6)
+#define MICBIAS(v)			(((v) & 0x3) << 6)
+#define MASTER_BCLK			(1 << 7)
+#define MASTER_WCLK			(1 << 6)
+#define HP_OUTPUT_AC_COUPLED		(1 << 7)
+
+/* kcontrol builders */
+#define AIC33_DOUBLE_R(xname, left_reg, right_reg, shift, maskbits, max, inv) \
+{\
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE, \
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = 0, \
+	.info = aic33_info_double_r, \
+	.get = aic33_get_double_r, \
+	.put = aic33_put_double_r, \
+	.private_value = left_reg | (right_reg << 8) | (max << 16) | \
+			 (maskbits << 24) | (shift << 27) | (inv << 30) \
+}
+#define AIC33_DOUBLE_R_LREG(v)		((v) & 0x7f)
+#define AIC33_DOUBLE_R_RREG(v)		(((v) >> 8) & 0x7f)
+#define AIC33_DOUBLE_R_MAX(v)		(((v) >> 16) & 0x7f)
+#define AIC33_DOUBLE_R_MASKBITS(v)	(((v) >> 24) & 0x7)
+#define AIC33_DOUBLE_R_MASK(v)		~(~0 << AIC33_DOUBLE_R_MASKBITS(v))
+#define AIC33_DOUBLE_R_SHIFT(v)		(((v) >> 27) & 0x7)
+#define AIC33_DOUBLE_R_INV(v)		(((v) >> 30) & 0x1)
+
+#define IG_MUTE				0xf
+#define ig_index(reg)			((reg) - MIC3LR_TO_LEFT_ADC)
+
+#define AIC33_IGAIN_DOUBLE(xname, reg, left_shift, right_shift, max) \
+{\
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE, \
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = 0, \
+	.info = aic33_info_igain_double, \
+	.get = aic33_get_igain_double, \
+	.put = aic33_put_igain_double, \
+	.private_value = reg | (left_shift << 8) | (right_shift << 12) | \
+			 (max << 16) \
+}
+#define AIC33_IGAIN_DOUBLE_REG(v)		((v) & 0x7f)
+#define AIC33_IGAIN_DOUBLE_LSHIFT(v)		(((v) >> 8) & 0x7)
+#define AIC33_IGAIN_DOUBLE_RSHIFT(v)		(((v) >> 12) & 0x7)
+#define AIC33_IGAIN_DOUBLE_MAX(v)		(((v) >> 16) & 0xf)
+
+#define AIC33_IGAIN_DOUBLE_R(xname, left_reg, right_reg, shift, max) \
+{\
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE, \
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = 0, \
+	.info = aic33_info_igain_double_r, \
+	.get = aic33_get_igain_double_r, \
+	.put = aic33_put_igain_double_r, \
+	.private_value = left_reg | (right_reg << 8) | (shift << 16) | \
+			 (max << 20) \
+}
+#define AIC33_IGAIN_DOUBLE_R_LREG(v)		((v) & 0x7f)
+#define AIC33_IGAIN_DOUBLE_R_RREG(v)		(((v) >> 8) & 0x7f)
+#define AIC33_IGAIN_DOUBLE_R_SHIFT(v)		(((v) >> 16) & 0x7)
+#define AIC33_IGAIN_DOUBLE_R_MAX(v)		(((v) >> 20) & 0xf)
+
+#define TLV320AIC33_BOOL(xname, func) \
+{ \
+	.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,\
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = xname, \
+	.index = 0, \
+	.info = aic33_info_bool, \
+	.get = aic33_get_bool, \
+	.put = aic33_put_bool, \
+	.private_value = (unsigned long)func \
+}
+#define	AIC33_BOOL_FUNC(v)		((int (*)(struct aic33 *, \
+						  int set, int *p))v)
+
+struct aic33 {
+	struct mutex	mutex;
+
+	struct		i2c_client client;
+
+	int		(*enable_clock)(struct device *dev);
+	void		(*disable_clock)(struct device *dev);
+
+	int		(*platform_init)(struct device *dev);
+	void		(*platform_cleanup)(struct device *dev);
+
+	void		(*ext_hp_amplifier_ctrl)(struct device *dev, int on);
+	void		(*ext_lo_amplifier_ctrl)(struct device *dev, int on);
+
+	unsigned	adc_enabled:1;
+	unsigned	dac_enabled:1;
+	unsigned	dmic_enabled:1;
+
+	struct aic33_dmic_data	*dmic_data;
+
+	/* register cache */
+	u8		cache[SIZE_REG_CACHE];
+
+	/*
+	 * we need separate gain cache for input level control registers since
+	 * the same bits are used both for gain value (0-8) and mute (0xf) and
+	 * we need to restore gain value when unmuting
+	 */
+	u8		igain_cache[SIZE_IGAIN_CACHE];
+};
+
+enum aic33_gpio1_ctrl {
+	AIC33_GPIO1_DISABLED,
+	AIC33_GPIO1_DMIC_CLK = 10,
+};
+
+enum aic33_gpio2_ctrl {
+	AIC33_GPIO2_DISABLED,
+	AIC33_GPIO2_DMIC_INPUT = 5,
+};
+
+static unsigned short normal_i2c[] = {
+	0x18, 0x19, 0x1a, 0x1b, I2C_CLIENT_END
+};
+
+I2C_CLIENT_INSMOD;
+
+static struct aic33_platform_data	*aic33_pdata;
+static struct i2c_driver		aic33_i2c_driver;
+
+int aic33_write(struct aic33 *aic, u8 reg, u8 value)
+{
+	int err;
+	u8 buffer[2];
+
+	aic->cache[reg] = value;
+	buffer[0] = reg;
+	buffer[1] = value;
+	err = i2c_master_send(&aic->client, &buffer[0], 2);
+	if (err < 0) {
+		dev_err(&aic->client.dev, "i2c error!\n");
+		return err;
+	}
+	return 0;
+}
+
+static int aic33_read_regs(struct aic33 *aic, u8 reg, u8 *buf, int len)
+{
+	int err;
+	struct i2c_adapter *adap = aic->client.adapter;
+	struct i2c_msg msg[] = {
+		{
+			.addr	= aic->client.addr,
+			.flags	= 0,
+			.len	= 1,
+			.buf	= &reg,
+		},
+		{
+			.addr	= aic->client.addr,
+			.flags	= I2C_M_RD,
+			.len	= len,
+			.buf	= buf,
+		},
+	};
+
+	BUG_ON(reg + len > 127 + 1);
+	err = i2c_transfer(adap, msg, 2);
+
+	return (err < 0) ? err : len;
+}
+
+static int aic33_check_output(struct aic33 *aic, u8 reg, int *active)
+{
+	int changed = 0;
+	int muted, powered;
+	u8 *cache = &aic->cache[reg];
+
+	muted = !(*cache & OUTPUT_UNMUTED);
+	powered = (*cache & OUTPUT_POWERED);
+	/* FIXME: take into account bypass paths */
+	*active = (aic->dac_enabled && !muted);
+
+	if (!*active && powered) {
+		changed = 1;
+	} else if (*active && !powered) {
+		changed = 1;
+	}
+
+	return changed;
+}
+
+static void aic33_change_output(struct aic33 *aic, u8 reg, int active)
+{
+	u8 temp;
+	u8 *cache = &aic->cache[reg];
+
+	/*
+	 * preserve cache content for maintaining mute state set by ALSA
+	 * control and power state for implementing workaround for extra
+	 * current consumption
+	 */
+	temp = *cache;
+
+	if (active) {
+		aic33_write(aic, reg, (*cache | OUTPUT_POWERED) &
+			    ~OUTPUT_UNMUTED);
+		*cache &= ~OUTPUT_POWERED; /* for logical power state */
+	} else {
+		aic33_write(aic, reg, (*cache | OUTPUT_POWERED) &
+			    ~OUTPUT_UNMUTED);
+		aic33_write(aic, reg, *cache & ~OUTPUT_POWERED);
+	}
+	*cache |= (temp & OUTPUT_UNMUTED); /* for maintaining mute state */
+}
+
+static void aic33_output_power_ctrl(struct aic33 *aic, u8 lreg, u8 rreg,
+				    void (*ext_amp)(struct device *dev,
+				    int on))
+{
+	struct device *dev = &aic->client.dev;
+	int l_changed, r_changed, l_act, r_act;
+	int ext_act;
+
+	l_changed = aic33_check_output(aic, lreg, &l_act);
+	r_changed = aic33_check_output(aic, rreg, &r_act);
+
+	ext_act = (l_act || r_act);
+	if (l_changed || r_changed)
+		if (!ext_act && ext_amp)
+			ext_amp(dev, 0);
+
+	/*
+	 * due HW issue, flush output stage control register cache into chip
+	 * only when output is active or when it becomes muted. In both cases,
+	 * output is kept physically powered whenever DAC is on. Driver uses
+	 * OUTPUT_POWERED bit internally for keeping up logical power state
+	 */
+	if (l_act || l_changed) {
+		aic33_write(aic, lreg, aic->cache[lreg] | OUTPUT_POWERED);
+		if (!l_act)
+			aic->cache[lreg] &= ~OUTPUT_POWERED;
+	}
+	if (r_act || r_changed) {
+		aic33_write(aic, rreg, aic->cache[rreg] | OUTPUT_POWERED);
+		if (!r_act)
+			aic->cache[rreg] &= ~OUTPUT_POWERED;
+	}
+
+	if (l_changed || r_changed)
+		if (ext_act && ext_amp)
+			ext_amp(dev, 1);
+}
+
+static void aic33_dmic_enable(struct aic33 *aic, int enable)
+{
+	enum aic33_dmic_rate rate;
+	enum aic33_micbias bias;
+	u8 val;
+
+	if (enable) {
+		/* activate bias if needed */
+		if (aic->dmic_data->needs_bias) {
+			bias = aic->dmic_data->dmic_bias;
+			val = aic->cache[MICBIAS_CONTROL] & ~MICBIAS_MASK;
+			aic33_write(aic, MICBIAS_CONTROL, val | MICBIAS(bias));
+		}
+		/*
+		 * enable digital mic. This must be done before GPIO
+		 * configuration in order to get correct DMIC CLK. Otherwise
+		 * ADC clock will show in DMIC CLK output before the rate is
+		 * set
+		 */
+		rate = aic->dmic_data->dmic_rate;
+		val = aic->cache[AUDIO_SERIAL_A] & ~DMIC_OVERSAMPLING_MASK;
+		aic33_write(aic, AUDIO_SERIAL_A,
+			    val | DMIC_OVERSAMPLING(rate));
+		/* configure GPIO1 and GPIO2 for digital mic */
+		aic33_write(aic, GPIO1_CONTROL,
+			    GPIO1_CTRL(AIC33_GPIO1_DMIC_CLK));
+		aic33_write(aic, GPIO2_CONTROL,
+			    GPIO2_CTRL(AIC33_GPIO2_DMIC_INPUT));
+	} else {
+		/* de-activate GPIO's and digital mic */
+		aic33_write(aic, GPIO1_CONTROL,
+			    GPIO1_CTRL(AIC33_GPIO1_DISABLED));
+		aic33_write(aic, GPIO2_CONTROL,
+			    GPIO2_CTRL(AIC33_GPIO2_DISABLED));
+		val = aic->cache[AUDIO_SERIAL_A] & ~DMIC_OVERSAMPLING_MASK;
+		aic33_write(aic, AUDIO_SERIAL_A,
+			    val | DMIC_OVERSAMPLING(AIC33_DMIC_DISABLED));
+		/* de-activate bias */
+		if (aic->dmic_data->needs_bias) {
+			bias = AIC33_MICBIAS_OFF;
+			val = aic->cache[MICBIAS_CONTROL] & ~MICBIAS_MASK;
+			aic33_write(aic, MICBIAS_CONTROL, val | MICBIAS(bias));
+		}
+	}
+}
+
+static void aic33_dmic_power_ctrl(struct aic33 *aic)
+{
+	int enable, changed = 0;
+	u8 val;
+
+	val = DMIC_OVERSAMPLING_VAL(aic->cache[AUDIO_SERIAL_A]);
+	if (aic->adc_enabled &&
+	    aic->dmic_enabled && (val == AIC33_DMIC_DISABLED)) {
+		/*
+		 * ADC enabled and digital mic enabled but it is not active
+		 * so activate it now
+		 */
+		enable = 1;
+		changed = 1;
+	} else if (val != AIC33_DMIC_DISABLED &&
+		   (!aic->dmic_enabled || !aic->adc_enabled)) {
+		/*
+		 * digital mic is active but either it or ADC are enabled
+		 * so de-activate it now
+		 */
+		enable = 0;
+		changed = 1;
+	}
+
+	if (changed)
+		aic33_dmic_enable(aic, enable);
+}
+
+void aic33_power_ctrl(struct aic33 *aic)
+{
+	/* high-power output control */
+	aic33_output_power_ctrl(aic, HPLOUT_OUTPUT_CTRL, HPROUT_OUTPUT_CTRL,
+				aic->ext_hp_amplifier_ctrl);
+
+	/* line output control */
+	aic33_output_power_ctrl(aic, LEFT_LO_OUTPUT_CTRL, RIGHT_LO_OUTPUT_CTRL,
+				aic->ext_lo_amplifier_ctrl);
+
+	if (aic->dmic_data)
+		aic33_dmic_power_ctrl(aic);
+}
+
+static int aic33_info_double_r(struct snd_kcontrol *kcontrol,
+			       struct snd_ctl_elem_info *uinfo)
+{
+	unsigned long priv = kcontrol->private_value;
+	int mask = AIC33_DOUBLE_R_MASK(priv); /* switch: mask == 1 */
+	int max = AIC33_DOUBLE_R_MAX(priv);
+
+	uinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN :
+				  SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = max;
+
+	return 0;
+}
+
+static int aic33_get_double_r(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct aic33 *aic = kcontrol->private_data;
+	u8 *cache = aic->cache;
+	unsigned long priv = kcontrol->private_value;
+	int lr = AIC33_DOUBLE_R_LREG(priv);
+	int rr = AIC33_DOUBLE_R_RREG(priv);
+	int mask = AIC33_DOUBLE_R_MASK(priv); /* switch: mask == 1 */
+	int max = AIC33_DOUBLE_R_MAX(priv);
+	int s = AIC33_DOUBLE_R_SHIFT(priv);
+	int inv = AIC33_DOUBLE_R_INV(priv);
+
+	mutex_lock(&aic->mutex);
+	if (inv) {
+		/*
+		 * inverted control
+		 * switch controls: 0 == active path, 1 == muted
+		 * volume controls: 0 == maximum, mask == minimum
+		 */
+		ucontrol->value.integer.value[0] = max -
+						   ((cache[lr] >> s) & mask);
+		ucontrol->value.integer.value[1] = max -
+						   ((cache[rr] >> s) & mask);
+	} else {
+		/*
+		 * switch controls: 0 == muted, 1 == active path
+		 * volume controls: 0 == minimum, mask == maximum
+		 */
+		ucontrol->value.integer.value[0] = (cache[lr] >> s) & mask;
+		ucontrol->value.integer.value[1] = (cache[rr] >> s) & mask;
+	}
+	mutex_unlock(&aic->mutex);
+
+	return 0;
+}
+
+static int aic33_put_double_r(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct aic33 *aic = kcontrol->private_data;
+	u8 *cache = aic->cache;
+	u8 lold, rold;
+	unsigned long priv = kcontrol->private_value;
+	int lr = AIC33_DOUBLE_R_LREG(priv);
+	int rr = AIC33_DOUBLE_R_RREG(priv);
+	int mask = AIC33_DOUBLE_R_MASK(priv); /* switch: mask == 1 */
+	int max = AIC33_DOUBLE_R_MAX(priv);
+	int s = AIC33_DOUBLE_R_SHIFT(priv);
+	int inv = AIC33_DOUBLE_R_INV(priv);
+	int changed = 0;
+
+	mutex_lock(&aic->mutex);
+	lold = cache[lr];
+	rold = cache[rr];
+	cache[lr] &= ~(mask << s);
+	cache[rr] &= ~(mask << s);
+	if (inv) {
+		/*
+		 * inverted control
+		 * switch controls: 0 == active path, 1 == muted
+		 * volume controls: 0 == maximum, mask == minimum
+		 */
+		cache[lr] |= ((max - ucontrol->value.integer.value[0]) &
+			      mask) << s;
+		cache[rr] |= ((max - ucontrol->value.integer.value[1]) &
+			      mask) << s;
+	} else {
+		/*
+		 * switch controls: 0 == muted, 1 == active path
+		 * volume controls: 0 == minimum, mask == maximum
+		 */
+		cache[lr] |= (ucontrol->value.integer.value[0] & mask) << s;
+		cache[rr] |= (ucontrol->value.integer.value[1] & mask) << s;
+	}
+
+	changed |= ((cache[lr] != lold) || (cache[rr] != rold));
+	if (changed) {
+		/*
+		 * workaround for extra current consumption: let the power
+		 * control function to decide when it is safe to flush output
+		 * stage control register into chip
+		 */
+		if (!IS_OUTPUT_CTRL_REG(lr))
+			aic33_write(aic, lr, cache[lr]);
+		if (!IS_OUTPUT_CTRL_REG(rr))
+			aic33_write(aic, rr, cache[rr]);
+		aic33_power_ctrl(aic);
+	}
+	mutex_unlock(&aic->mutex);
+
+	return changed;
+}
+
+static int aic33_info_igain_double_r(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_info *uinfo)
+{
+	unsigned long priv = kcontrol->private_value;
+	int max = AIC33_IGAIN_DOUBLE_R_MAX(priv); /* switch: max == 0xf */
+
+	uinfo->type = max == IG_MUTE ? SNDRV_CTL_ELEM_TYPE_BOOLEAN :
+				       SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = max == IG_MUTE ? 1 : max;
+
+	return 0;
+
+}
+
+static int aic33_get_igain_double_r(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct aic33 *aic = kcontrol->private_data;
+	u8 *cache = aic->cache;
+	u8 *igain_cache = aic->igain_cache;
+	u8 lval, rval;
+	unsigned long priv = kcontrol->private_value;
+	int lr = AIC33_IGAIN_DOUBLE_R_LREG(priv);
+	int rr = AIC33_IGAIN_DOUBLE_R_RREG(priv);
+	int s = AIC33_IGAIN_DOUBLE_R_SHIFT(priv);
+	int mask = IG_MUTE;
+	int max = AIC33_IGAIN_DOUBLE_R_MAX(priv);
+	int sw = max == IG_MUTE ? 1 : 0;
+
+	mutex_lock(&aic->mutex);
+	if (sw) {
+		/* switch. Path is muted if gain value is 0xf */
+		lval = ((cache[lr] >> s) & mask) != IG_MUTE;
+		rval = ((cache[rr] >> s) & mask) != IG_MUTE;
+	} else {
+		/* volume. All input gain volumes are inverted */
+		lval = max - ((igain_cache[ig_index(lr)] >> s) & mask);
+		rval = max - ((igain_cache[ig_index(rr)] >> s) & mask);
+	}
+	mutex_unlock(&aic->mutex);
+
+	ucontrol->value.integer.value[0] = lval;
+	ucontrol->value.integer.value[1] = rval;
+
+	return 0;
+}
+
+static int aic33_put_igain_double_r(struct snd_kcontrol *kcontrol,
+				    struct snd_ctl_elem_value *ucontrol)
+{
+	struct aic33 *aic = kcontrol->private_data;
+	u8 *cache = aic->cache;
+	u8 *igain_cache = aic->igain_cache;
+	u8 lold, rold;
+	u8 lval, rval;
+	unsigned long priv = kcontrol->private_value;
+	int lr = AIC33_IGAIN_DOUBLE_R_LREG(priv);
+	int rr = AIC33_IGAIN_DOUBLE_R_RREG(priv);
+	int s = AIC33_IGAIN_DOUBLE_R_SHIFT(priv);
+	int mask = IG_MUTE;
+	int max = AIC33_IGAIN_DOUBLE_R_MAX(priv);
+	int sw = max == IG_MUTE ? 1 : 0;
+	int changed = 0;
+
+	mutex_lock(&aic->mutex);
+	if (sw) {
+		/*
+		 * switch. If unmuted path, then use value from gain cache for
+		 * updating register cache and mute value otherwise
+		 */
+		lold = (igain_cache[ig_index(lr)] >> s) & mask;
+		rold = (igain_cache[ig_index(rr)] >> s) & mask;
+		lval = ucontrol->value.integer.value[0] == 1 ? lold : IG_MUTE;
+		rval = ucontrol->value.integer.value[1] == 1 ? rold : IG_MUTE;
+	} else {
+		/* volume */
+		lval = ucontrol->value.integer.value[0] & mask;
+		rval = ucontrol->value.integer.value[1] & mask;
+		/* do sanity check and value inversion to input gain volume */
+		lval = lval > max ? 0 : max - lval;
+		rval = rval > max ? 0 : max - rval;
+		/*
+		 * update gain cache. Do register update below only if path is
+		 * not muted
+		 */
+		igain_cache[ig_index(lr)] = lval << s;
+		igain_cache[ig_index(rr)] = rval << s;
+	}
+
+	lold = cache[lr];
+	rold = cache[rr];
+	if (sw) {
+		cache[lr] &= ~(mask << s);
+		cache[rr] &= ~(mask << s);
+		cache[lr] |= lval << s;
+		cache[rr] |= rval << s;
+	} else {
+		/*
+		 * if changing volume, update it into register cache only if
+		 * path is not muted
+		 */
+		if (((cache[lr] >> s) & mask) != IG_MUTE) {
+			cache[lr] &= ~(mask << s);
+			cache[lr] |= igain_cache[ig_index(lr)] & (mask << s);
+		}
+		if (((cache[rr] >> s) & mask) != IG_MUTE) {
+			cache[rr] &= ~(mask << s);
+			cache[rr] |= igain_cache[ig_index(rr)] & (mask << s);
+		}
+	}
+
+	changed |= ((cache[lr] != lold) || (cache[rr] != rold));
+	if (changed) {
+		aic33_write(aic, lr, cache[lr]);
+		aic33_write(aic, rr, cache[rr]);
+		aic33_power_ctrl(aic);
+	}
+
+	mutex_unlock(&aic->mutex);
+
+	return changed;
+}
+
+static int aic33_info_bool(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+
+	return 0;
+}
+
+static int aic33_get_bool(struct snd_kcontrol *kcontrol,
+			  struct snd_ctl_elem_value *ucontrol)
+{
+	struct aic33 *aic = kcontrol->private_data;
+	unsigned long priv = kcontrol->private_value;
+	int (*func)(struct aic33 *, int set, int *p) = AIC33_BOOL_FUNC(priv);
+
+	mutex_lock(&aic->mutex);
+	ucontrol->value.integer.value[0] = func(aic, 0, NULL);
+	mutex_unlock(&aic->mutex);
+
+	return 0;
+}
+
+static int aic33_put_bool(struct snd_kcontrol *kcontrol,
+			  struct snd_ctl_elem_value *ucontrol)
+{
+	struct aic33 *aic = kcontrol->private_data;
+	unsigned long priv = kcontrol->private_value;
+	int (*func)(struct aic33 *, int set, int *p) = AIC33_BOOL_FUNC(priv);
+	int changed;
+	int val = ucontrol->value.integer.value[0];
+
+	mutex_lock(&aic->mutex);
+	changed = func(aic, 1, &val);
+	mutex_unlock(&aic->mutex);
+
+	return changed;
+}
+
+static struct snd_kcontrol_new aic33_controls[] = {
+	/* ADC/DAC gains */
+	AIC33_DOUBLE_R("Capture Switch",
+		LEFT_ADC_PGA_GAIN, RIGHT_ADC_PGA_GAIN, 7, 1, 1, 1),
+	AIC33_DOUBLE_R("Capture Volume",
+		LEFT_ADC_PGA_GAIN, RIGHT_ADC_PGA_GAIN, 0, 7, 119, 0),
+
+	AIC33_DOUBLE_R("PCM Playback Switch",
+		LEFT_DAC_DIGITAL_VOLUME, RIGHT_DAC_DIGITAL_VOLUME, 7, 1, 1, 1),
+	AIC33_DOUBLE_R("PCM Playback Volume",
+		LEFT_DAC_DIGITAL_VOLUME, RIGHT_DAC_DIGITAL_VOLUME, 0, 7, 127, 1),
+
+	/*
+	 * FIXME: Input gain control for pin MIC1/LINE1L. These stereo switch
+	 * and volume controls route it into left and right ADC input.
+	 * Note that this is Nokia RX-44 specific implementation and actually
+	 * input routing configuration and control names should come from
+	 * platform configuration. However, (too) versatile AIC33 doesn't
+	 * make such implementation too easy...
+	 */
+	AIC33_IGAIN_DOUBLE_R("Mic1 Capture Switch",
+		LINE1L_TO_LEFT_ADC, LINE1L_TO_RIGHT_ADC, 3, 0xf),
+	AIC33_IGAIN_DOUBLE_R("Mic1 Capture Volume",
+		LINE1L_TO_LEFT_ADC, LINE1L_TO_RIGHT_ADC, 3, 8),
+
+	/* bypass path after input PGA to output stages */
+	AIC33_DOUBLE_R("Capture_to_HP Bypass Switch",
+		PGA_L_TO_HPLOUT_VOLUME, PGA_R_TO_HPROUT_VOLUME, 7, 1, 1, 0),
+	AIC33_DOUBLE_R("Capture_to_HP Bypass Volume",
+		PGA_L_TO_HPLOUT_VOLUME, PGA_R_TO_HPROUT_VOLUME, 0, 7, 117, 1),
+	AIC33_DOUBLE_R("Capture_to_Line Bypass Switch",
+		PGA_L_TO_L_LO_VOLUME, PGA_R_TO_R_LO_VOLUME, 7, 1, 1, 0),
+	AIC33_DOUBLE_R("Capture_to_Line Bypass Volume",
+		PGA_L_TO_L_LO_VOLUME, PGA_R_TO_R_LO_VOLUME, 0, 7, 117, 1),
+
+	/* output stage volume controls */
+	AIC33_DOUBLE_R("DAC_to_HP Playback Switch",
+		DAC_L1_TO_HPLOUT_VOLUME, DAC_R1_TO_HPROUT_VOLUME, 7, 1, 1, 0),
+	AIC33_DOUBLE_R("DAC_to_HP Playback Volume",
+		DAC_L1_TO_HPLOUT_VOLUME, DAC_R1_TO_HPROUT_VOLUME, 0, 7, 117, 1),
+	AIC33_DOUBLE_R("DAC_to_Line Playback Switch",
+		DAC_L1_TO_L_LO_VOLUME, DAC_R1_TO_R_LO_VOLUME, 7, 1, 1, 0),
+	AIC33_DOUBLE_R("DAC_to_Line Playback Volume",
+		DAC_L1_TO_L_LO_VOLUME, DAC_R1_TO_R_LO_VOLUME, 0, 7, 117, 1),
+
+	/* output stage level controls */
+	AIC33_DOUBLE_R("HP Playback Switch",
+		HPLOUT_OUTPUT_CTRL, HPROUT_OUTPUT_CTRL, 3, 1, 1, 0),
+	AIC33_DOUBLE_R("HP Playback Volume",
+		HPLOUT_OUTPUT_CTRL, HPROUT_OUTPUT_CTRL, 4, 4, 9, 0),
+	AIC33_DOUBLE_R("Line Playback Switch",
+		LEFT_LO_OUTPUT_CTRL, RIGHT_LO_OUTPUT_CTRL, 3, 1, 1, 0),
+	AIC33_DOUBLE_R("Line Playback Volume",
+		LEFT_LO_OUTPUT_CTRL, RIGHT_LO_OUTPUT_CTRL, 4, 4, 9, 0),
+};
+
+/*
+ * Sets or gets digital mic enable status
+ * Must be called while aic->mutex locked
+ */
+static int aic33_dmic_switch(struct aic33 *aic, int set, int *p)
+{
+	int ret = 1;
+
+	if (set) {
+		aic->dmic_enabled = *p;
+		aic33_power_ctrl(aic);
+	} else {
+		ret = aic->dmic_enabled;
+	}
+
+	return ret;
+}
+
+static int aic33_mixer_init(struct aic33 *aic, struct snd_card *card)
+{
+	unsigned int idx;
+	int err = 0;
+
+	snd_assert(card != NULL, return -EINVAL);
+
+	/* add AIC33 common/fixed controls */
+	for (idx = 0; idx < ARRAY_SIZE(aic33_controls); idx++) {
+		if ((err = snd_ctl_add(card, snd_ctl_new1(&aic33_controls[idx],
+				       aic))) < 0) {
+			goto out;
+		}
+	}
+
+	/* add control for digital mic if configured */
+	if (aic->dmic_data) {
+		struct snd_kcontrol_new ctrl =
+			TLV320AIC33_BOOL("Digital Mic Switch",
+					 aic33_dmic_switch);
+		err = snd_ctl_add(card, snd_ctl_new1(&ctrl, aic));
+	}
+
+out:
+	return err;
+}
+
+static int aic33_setup_chip(struct aic33 *aic,
+			    struct aic33_platform_data *pdata)
+{
+	int err;
+
+	err = aic33_read_regs(aic, 0, aic->cache, sizeof(aic->cache));
+	if (err < 0)
+		goto out;
+
+	/*
+	 * DAC is connected into L1/R1 path by default. Use it since it allow
+	 * to route DAC into every output via their mixer controls
+	 * Route left DAC into left outputs and right DAC into right outputs
+	 * respectively
+	 */
+	aic33_write(aic, DAC_L1_TO_HPLOUT_VOLUME, DAC_L1R1_ROUTE_ENABLE);
+	aic33_write(aic, DAC_R1_TO_HPROUT_VOLUME, DAC_L1R1_ROUTE_ENABLE);
+	aic33_write(aic, DAC_L1_TO_L_LO_VOLUME, DAC_L1R1_ROUTE_ENABLE);
+	aic33_write(aic, DAC_R1_TO_R_LO_VOLUME, DAC_L1R1_ROUTE_ENABLE);
+
+	aic33_write(aic, CODEC_DATAPATH, DAC_LEFT_PLAYS_LEFT_CHANNEL |
+		    DAC_RIGHT_PLAYS_RIGHT_CHANNEL);
+
+	/* PLL setup */
+	aic33_write(aic, PLL_PROGRAMMING_A, PLL_VAL_P(pdata->pll_p));
+	aic33_write(aic, PLL_PROGRAMMING_B, PLL_VAL_J(pdata->pll_j));
+	aic33_write(aic, PLL_PROGRAMMING_C, PLL_VAL_D_8MSB(pdata->pll_d));
+	aic33_write(aic, PLL_PROGRAMMING_D, PLL_VAL_D_6LSB(pdata->pll_d));
+	aic33_write(aic, AUDIO_CODEC_OVERFLOW, PLL_VAL_R(pdata->pll_r));
+
+	/* configure bit and word clock direction */
+	aic33_write(aic, AUDIO_SERIAL_A,
+		    (pdata->bclk_output ? MASTER_BCLK : 0) |
+		    (pdata->wclk_output ? MASTER_WCLK : 0));
+
+	/* configure ADC highpass filter */
+	aic33_write(aic, AUDIO_DIGITAL_FILTER,
+		    ADC_LEFT_HIGHPASS(pdata->adc_hp_filter) |
+		    ADC_RIGHT_HIGHPASS(pdata->adc_hp_filter));
+
+	if (pdata->hp_data) {
+		/* configure high-power output */
+		aic33_write(aic, HEADSET_DETECTION_B,
+			    (pdata->hp_data->ac_coupled ?
+			     HP_OUTPUT_AC_COUPLED : 0));
+
+		aic33_write(aic, HPLOUT_OUTPUT_CTRL,
+			    (pdata->hp_data->pd_tri_stated ?
+			     HP_OUTPUT_TRI_STATED : 0));
+		aic33_write(aic, HPROUT_OUTPUT_CTRL,
+			    (pdata->hp_data->pd_tri_stated ?
+			     HP_OUTPUT_TRI_STATED : 0));
+	}
+
+	err = 0;
+out:
+	return err;
+}
+
+static void aic33_enable_adcs(struct aic33 *aic, int enable)
+{
+	if (enable) {
+		aic33_write(aic, LINE1L_TO_LEFT_ADC,
+			    aic->cache[LINE1L_TO_LEFT_ADC] | ADC_POWER);
+		aic33_write(aic, LINE1R_TO_RIGHT_ADC,
+			    aic->cache[LINE1R_TO_RIGHT_ADC] | ADC_POWER);
+	} else {
+		aic33_write(aic, LINE1L_TO_LEFT_ADC,
+			    aic->cache[LINE1L_TO_LEFT_ADC] & ~ADC_POWER);
+		aic33_write(aic, LINE1R_TO_RIGHT_ADC,
+			    aic->cache[LINE1R_TO_RIGHT_ADC] & ~ADC_POWER);
+	}
+}
+
+static void aic33_enable_dacs(struct aic33 *aic, int enable)
+{
+	if (enable)
+		aic33_write(aic, DAC_POWER_CTRL,
+			    aic->cache[DAC_POWER_CTRL] |
+			    DAC_LEFT_POWER | DAC_RIGHT_POWER);
+	else
+		aic33_write(aic, DAC_POWER_CTRL,
+			    aic->cache[DAC_POWER_CTRL] &
+			    ~(DAC_LEFT_POWER | DAC_RIGHT_POWER));
+}
+
+static void aic33_enable_pll(struct aic33 *aic, int enable)
+{
+	if (enable) {
+		aic33_write(aic, PLL_PROGRAMMING_A,
+			    aic->cache[PLL_PROGRAMMING_A] | PLL_ENABLED);
+		/*
+		 * REVISIT: let the PLL to start before activating anything
+		 * else, especially DAC and outputs. Otherwise there will be
+		 * strong audiple pop when powering up the output path.
+		 * Proper delay seems to be somewhere bit less than
+		 * 10 ms (with mdelay)
+		 */
+		msleep(10);
+	} else {
+		aic33_write(aic, PLL_PROGRAMMING_A,
+			    aic->cache[PLL_PROGRAMMING_A] & ~PLL_ENABLED);
+	}
+}
+
+void aic33_mixer_set_power(struct device *dev, int dac, int adc)
+{
+	struct aic33 *aic = container_of(dev, struct aic33, client.dev);
+
+	dev_dbg(&aic->client.dev, "%s\n", __func__);
+
+	mutex_lock(&aic->mutex);
+	aic->adc_enabled = adc;
+	aic->dac_enabled = dac;
+	if (dac | adc)
+		aic33_enable_pll(aic, 1);
+	if (dac) {
+		aic33_enable_dacs(aic, 1);
+		/*
+		 * workaround: Power up all output stages in order to avoid
+		 * possible extra current consumption in digital domain
+		 */
+		aic33_change_output(aic, HPLOUT_OUTPUT_CTRL, 1);
+		aic33_change_output(aic, HPROUT_OUTPUT_CTRL, 1);
+		aic33_change_output(aic, LEFT_LO_OUTPUT_CTRL, 1);
+		aic33_change_output(aic, RIGHT_LO_OUTPUT_CTRL, 1);
+	}
+	if (adc)
+		aic33_enable_adcs(aic, 1);
+
+	aic33_power_ctrl(aic);
+
+	if (!adc)
+		aic33_enable_adcs(aic, 0);
+	if (!dac)
+		aic33_enable_dacs(aic, 0);
+	if (!(dac | adc)) {
+		aic33_enable_pll(aic, 0);
+		/*
+		 * workaround: Power down all output stages after DAC+PLL are
+		 * shutdown.
+		 * FIXME: take into account bypass paths
+		 */
+		aic33_change_output(aic, HPLOUT_OUTPUT_CTRL, 0);
+		aic33_change_output(aic, HPROUT_OUTPUT_CTRL, 0);
+		aic33_change_output(aic, LEFT_LO_OUTPUT_CTRL, 0);
+		aic33_change_output(aic, RIGHT_LO_OUTPUT_CTRL, 0);
+	}
+	mutex_unlock(&aic->mutex);
+}
+
+int aic33_mixer_register_controls(struct device *dev, struct snd_card *card)
+{
+	struct aic33 *aic = container_of(dev, struct aic33, client.dev);
+
+	aic33_mixer_init(aic, card);
+
+	return 0;
+}
+
+int aic33_enable_mclk(struct device *dev)
+{
+	struct aic33 *aic = container_of(dev, struct aic33, client.dev);
+	int err = 0;
+
+	dev_dbg(&aic->client.dev, "%s\n", __func__);
+
+	mutex_lock(&aic->mutex);
+	if (aic->enable_clock != NULL)
+		err = aic->enable_clock(dev);
+	mutex_unlock(&aic->mutex);
+
+	return err;
+}
+
+void aic33_disable_mclk(struct device *dev)
+{
+	struct aic33 *aic = container_of(dev, struct aic33, client.dev);
+
+	dev_dbg(&aic->client.dev, "%s\n", __func__);
+
+	mutex_lock(&aic->mutex);
+	if (aic->disable_clock != NULL)
+		aic->disable_clock(dev);
+	mutex_unlock(&aic->mutex);
+}
+
+static int aic33_detect_client(struct i2c_adapter *adapter, int address,
+			       int kind)
+{
+	int err = 0;
+	struct aic33 *aic;
+	struct i2c_client *new_client;
+	struct aic33_platform_data *pdata = aic33_pdata;
+
+	if (!(aic = kzalloc(sizeof(*aic), GFP_KERNEL))) {
+		err = -ENOMEM;
+		goto err1;
+	}
+
+	mutex_init(&aic->mutex);
+	new_client = &aic->client;
+	i2c_set_clientdata(new_client, aic);
+	new_client->addr = address;
+	new_client->adapter = adapter;
+	new_client->driver = &aic33_i2c_driver;
+	new_client->flags = 0;
+	strcpy(new_client->name, DRIVER_NAME);
+
+	if ((err = i2c_attach_client(new_client))) {
+		dev_err(&adapter->dev,
+			"can't attach %s to address %d, err %d\n",
+			DRIVER_NAME, address, err);
+		goto err2;
+	}
+
+	aic->enable_clock = pdata->enable_clock;
+	aic->disable_clock = pdata->disable_clock;
+	aic->platform_init = pdata->codec_init;
+	aic->platform_cleanup = pdata->codec_cleanup;
+	aic->ext_hp_amplifier_ctrl = pdata->ext_hp_amplifier_ctrl;
+	aic->ext_lo_amplifier_ctrl = pdata->ext_lo_amplifier_ctrl;
+	aic->dmic_data = pdata->dmic_data;
+
+	if ((err = aic33_setup_chip(aic, pdata))) {
+		dev_err(&new_client->dev,
+			"chip initialization failed, err %d\n", err);
+		goto err3;
+	}
+
+	if (aic->platform_init) {
+		if ((err = aic->platform_init(&new_client->dev))) {
+			dev_err(&new_client->dev,
+				"platform specific initialization failed, "
+				"err %d\n",
+				err);
+			goto err3;
+		}
+	}
+
+	return 0;
+
+err3:
+	i2c_detach_client(new_client);
+err2:
+	kfree(aic);
+err1:
+	return err;
+}
+
+static int aic33_attach_adapter(struct i2c_adapter *adapter)
+{
+	return i2c_probe(adapter, &addr_data, &aic33_detect_client);
+}
+
+static int aic33_detach_client(struct i2c_client *client)
+{
+	int err;
+	struct aic33 *aic = i2c_get_clientdata(client);
+
+	if (aic->platform_cleanup)
+		aic->platform_cleanup(&client->dev);
+
+	if ((err = i2c_detach_client(client)))
+		return err;
+
+	kfree(aic);
+
+	return 0;
+}
+
+static struct i2c_driver aic33_i2c_driver = {
+	.driver = {
+		.name	= DRIVER_NAME,
+	},
+	.id		= I2C_DRIVERID_MISC,
+	.attach_adapter	= aic33_attach_adapter,
+	.detach_client	= aic33_detach_client,
+};
+
+static int aic33_probe(struct platform_device *pdev)
+{
+	struct aic33_platform_data *pdata = pdev->dev.platform_data;
+
+	if (aic33_pdata) {
+		dev_err(&pdev->dev,
+			"only single %s platform device supported\n",
+			DRIVER_NAME);
+		return -EBUSY;
+	}
+	aic33_pdata = pdata;
+
+	if (pdata->codec_reset) {
+		/* perform chip reset */
+		pdata->codec_reset(1);
+		udelay(1); /* spec says reset must be active at least 10 ns */
+		pdata->codec_reset(0);
+		msleep(1); /* stetson guessed reset release delay */
+	}
+
+	return i2c_add_driver(&aic33_i2c_driver);
+}
+
+static int aic33_remove(struct platform_device *pdev)
+{
+	struct aic33_platform_data *pdata = pdev->dev.platform_data;
+
+	i2c_del_driver(&aic33_i2c_driver);
+	/* keep chip in reset */
+	if (pdata->codec_reset)
+		pdata->codec_reset(1);
+
+	aic33_pdata = NULL;
+
+	return 0;
+}
+
+static struct platform_driver aic33_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "aic33-driver",
+	},
+	.probe		= aic33_probe,
+	.remove		= aic33_remove,
+};
+
+static int __init aic33_init(void)
+{
+	if (platform_driver_register(&aic33_driver)) {
+		printk(KERN_ERR "Failed to register %s driver\n",
+		       DRIVER_NAME);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static void __exit aic33_exit(void)
+{
+	platform_driver_unregister(&aic33_driver);
+}
+
+MODULE_AUTHOR("Jarkko Nikula <jarkko.nikula@nokia.com>");
+MODULE_DESCRIPTION("TLV320AIC33 audio codec driver");
+MODULE_LICENSE("GPL");
+
+module_init(aic33_init);
+module_exit(aic33_exit);
